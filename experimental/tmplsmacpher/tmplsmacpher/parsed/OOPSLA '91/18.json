{"article_publication_date": "11-01-1991", "fulltext": "\n An Extensible Kernel Object Management System Rahim Yaseen, Stanley Y.W. Su and Herman Lam Database \nSystems Research and Development Center Department of Computer and Information Sciences Department of \nElectrical Engineering CSE 470, University of Florida Gainesville, FL3261 1. rmy@trout.cis.uJ.edu Abstract \nTraditional monolithic database system architec- tures have been found to be inadequate for supporting \nend-user data modeling paradigms needed in complex application domains. Instead, database system architectures \nwhich are open, multi-layered, and extensible must be developed. In this paper, we explore the concept \nof a multi-layer, extensible architecture for building new gen-eration knowledge/data base systems. A \nKer-nel Object Management System (KOMS) which serves as an intermediate layer in a multi-layer architecture \nis described. The aim is to build a generalized and extensible system which can be (a)upwardly extended \ninto a high-level, end-user, semantic model and (b)downwardly extended to interface with various storage \nsystems. To sat-isfy the generic or kernel requirement, the system uses an extensible Kernel Object Model \n(XKOM) which consists of a set of generalized or core ob-ject modeling constructs. Model Extensibility \nis facilitated by reflexively modeling the constructs of XKOM as objects, classes and associations. An \nobject-based specification and implementation of the system architecture is used to achieve System Extensibility. \nBy modifying and extending these model and system schemata, the model and sys-tem can be tailored or \ncustomized to suit various application domains. Various implementation is-sues and techniques related \nto the development of KOMS are also described. Permission to copy without fee all or part of this material \nis granted provided that the copies are not made or distributed for direct commercial advantage, the \nACM copyright notice and the title of the publication and its date appear, and notice is given that copying \nis by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires \na fee and/or specific permission. @ 1991 ACM 89791-446-5/9110010/0247...$1.50 1 Introduction In recent \nyears, the growing demand for database technology by advanced application domains (e.g. CAD/CAM, CASE, \nVLSI, etc.) coupled with the inadequacy of traditional (i.e. relational, net-work, hierarchical) data \nmodels to support such applications has prompted the development of ad- vanced data modeling paradigms. \nSeveral se-mantic and object-oriented data models, special-ized modeling constructs, languages, and systems \n[AND87, BAN87, COP84, DIT86, FIS87, HAM81, HULL87, LEC88, LO086, SH181, SU89, ZAN83], have been proposed. \nAn important issue is defin- ing and developing a suitable knowledge/data base system to support these \ndiverse applications and data models. Traditionally, database management systems have been built as \nmonolithic systems. Such sys-tems are monolithic in the sense that the system is developed based on some \noriginal specifications (e.g. a specific data model or language), and can-not accommodate any change \nin the original spec-ifications easily. For example, System R [AST76] provides two layers: a lower layer \n(RSS) to provide storage management and an upper layer (RDS) which is a monolithic implementation of \na specific (relational) model. A monolithic upper or lower layer is still not conducive to functional \nexten-sions, and such an architecture is inadequate for advanced applications. To address the limitations \nof traditional database systems, and to support advanced OOPSLA 91, pp. 247-263 applications, a new \nclass of database sys-tems called object-oriented database systems have evolved. Systems such as Orion[BAN87], \nGem-stone[MAI86a], Vbase[AND87], Iris[FIS87], etc., have mainly focussed on developing a specific sys-tem \nbased on a specific high-level object-oriented data model. These models and systems cater to advanced \napplications by offering enhanced func-tionalities. However, such systems are model-specific, and have \nnot been developed with extensi-bility as a key goal. Thus, such systems cannot eas-ily handle a change \nin their original specifications that an advanced or emerging application may re-quire. This implies \nthat an application must be forced to use the model and system even if the model or system does not match \nthe application requirements. Based on the premise that emerging applica-tions have dynamic requirements, \nseveral systems such as Exodus[CAR86b], Postgres[STO86], Star-burst[SCH86], and Genesis[BAT88] have been \nat the forefront of a class of systems known as ex-tensible database systems. Postgres and Starburst \naim to provide a complete extensible database sys-tem for all applications within a relational frame-work. \nExodus and Genesis have taken a toolkit approach in which a customized system is gener- ated for each \napplication. Genesis is based on the Unifying Model ( a variant of the network model) and uses a strict \nframework of building blocks to achieve layering and extensibility. Exodus is an object-based system \nwhich provides a set of fixed components plus a collection of tools for build-ing system components. \nAlthough having simi-lar goals, each system uses a different approach to achieve extensibility. With \nincreasing complexity of application do-mains, and the multitude of end-user data model-ing constructs, \nit is clear that monolithic database architectures are inadequate to support the diverse needs of advanced \napplication domains. On the one hand, it is not feasible for a single (fixed) data model and system to \nsupport all applications. Even in object-oriented database systems, a sin-gle system has not emerged \n(unlike the relational model) since there is no consensus [ATK89] on which object model is the right \nmodel. On the other hand, due to excessive monetary cost and de-velopment time, it is not feasible to \ndevelop many customized systems for many specialized models and different application domains. A viable \nalter-native is to have a kernel or generalized database system that can be extended or evolved to support \nspecialized models and application domains. We are currently exploring such an option by pursuing the \nconcept of an open, extensible, and multi-layer knowledge/data base system architec-ture. Our approach \nbuilds upon an integration of the object-oriented and extensible system ap-proaches described above. \nThe system under de-velopment, OSAM*.KBMS/X, is targeted to be a knowledge base management system that \nin- tegrates the notion of data (objects), methods, queries, and rules in a single extensible object- \noriented environment. The layered architecture of OSAM*.KBMS/X is shown in Fig 1. Our goals also parallel \nthose of the Darmstadt Kernel System [PAU87] and Oz[VEL89]. In both these systems, a layered approach \nis taken and ef-forts are made to be canonical. The Darmstadt Kernel System takes a kernel and extensible \nap-proach but their kernel is more oriented toward a storage kernel whereas our kernel is oriented to-wards \nan intermediate layer. 02 is targeted as a layered object-oriented system with not much emphasis on extensibility. \nAlthough these sys-tems have similar goals, the overall approach that we take and the mechanisms that \nwe propose for extensibility are considerably different from these systems. In this paper, we describe \na Kernel Object Man-agement System (KOMS) which serves as an in-termediate layer in the multi-layer architecture \nof OSAM*.KBMS/X. This intermediate layer is built on top of an underlying storage layer and is used to \nmanage kernel objects -objects whose abstrac-tions are described by an extensible Kernel Object Model \n(XKOM). Th e objectives of this approach are as follows. Firstly, to develop a Kernel Ob-ject Management \nSystem (KOMS), which can be extended (upwards) to support different object-oriented models to be used \nby different applica-tions. Secondly, to serve as an intermediate layer which provides upper layers with \na common inter- LOGICAL REPRESENTATION LAYER High level, logical (end-user) data modeling constructs \nEnd-user interfaces such as query languages, etc Other logical end-user abstractions (new association \ntypes), constructs, application-related features/constructs etc MAPPING Mappings from logical (end-user) \ndata models, constructs, abstractions, query languages to underlying Kernel Object Model (Kohl) Layer \n KERNEL OBJECT MANAGEMENT LAYER extensible Kernel Object Model (XKOM): a basic, canonical, object based \nmodel serving as an intermediate level of abstraction Provides extensibility mechanisms Provides a base \nset of extensible object-level operations for kernel objects MAPPING Defines the implementation of XKOM \nMapping the Kernel Object Model to underlying storage structures and implementation of the base set \nof object level operations UNDERLYING STORAGE LAYER Physical Storage of the kernel objects Figure 1: \nThe Layered Architecture of OSAM*.KBMS/X face to different underlying storage layers. Thirdly, with abstractions \nand issues that are relevant to to provide an interface comprising of a set of basic the storage level. \nConsequently, storage managers yet semantically meaningful operators for process-should not include functionalities \nsuch as high-level ing objects and object references (links). Such op-object representations, high-level \noperators, and erators are to be used by clients of the KOMS such set-oriented retrievals, but rather \nprovide adequate as the query processor, rule processor, transaction support for such functionalities. \nInstead, manage-manager, etc. ment of objects at a higher level of abstraction KOMS has been designed \nand implemented should be carried out in a layer above the storage to support an extensible Kernel Object \nModel layer -it is this layer that KOMS caters to. (XKOM). XKOM consists of a set of generalized or Extensibility \nis an important feature of the sys-core object modeling constructs. Based on these tem. Model Extensibility \nor data model extensions constructs, we extract a generic, uniform, and se-are facilitated by using the \nconcept of model reflex-mantically meaningful model of storage for kernel ivity. In model reflexivity, \na data model is used to objects. To support XKOM, a storage strategy model itself resulting in a set \nof meta-classes which based on a natural distribution of object instances represent data model constructs \nsuch as classes, along class boundaries is used. In order to pro-associations, identity, rules, methods, \netc., as first vide strong support for associations or relation-class objects. Data model extensions \nare realized ships among object classes, KOMS provides com-by modifying this set of meta-classes. System \nEx-prehensive support for object references or links. tensibility or extensions to the software architec-Based \non these features, a basic set of object ma-ture of the system are facilitated by explicitly mod-nipulation \noperators have been defined, and algo-eling system components as objects, classes, and rithms for their \nprocessing have been developed. associations. Similar to data model extensions, We note that KOMS differs \nfrom object man-system components can be modified or extended agers proposed in [CH085, CAR86a, SKA86, \nby manipulating the classes and objects that rep-VEL89]. Many of these object managers are more resent \ncomponents of the system architecture. The appropriately called storage managers primarily system is \ndeveloped as an open, modular, and ex-because the structural representation of an object tensible architecture \nwith well-defined interfaces. at this level is a low-level (storage) representation KOMS has been implemented \nusing the C++ (e.g. files, records). Furthermore, operators at this programming language [STR86] and \nthe ONTOS level provide a low-level interface (such as get/put, object server [ONT90] as the underlying \nstorage read/write), based on this storage level represen-layer. However, in the design and implementation \ntation. Ideally, a storage layer must deal only of KOMS, we have made a conscious attempt to define the \nintermediate layer with a view to inter-facing to a generic underlying storage layer, having get/put \nor read/write semantics. This paper is organized as follows. In Section 2, the extensible Kernel Object \nModel (XKOM) is presented. We describe design requirements, basic modeling constructs, a distributed \nmodel of stor-age for kernel objects, and mechanisms for achiev-ing data model extensions. Issues relating \nto the processing of kernel objects are discussed in Sec-tion 3, and a set of high-level operators that \ncon-stitute the interface are presented. Section 4 de- scribes the implementation of the system, and \nil-lustrates the notion of system extensibility. Sec-tion 5 presents a conclusion and discussion on fu-ture \nwork.  2 An Extensible Kernel Object Model (XKOM) 2.1 Data Model Requirements 1. Core or Kernel Reauirement: \nThe data model must support a set of core data model-ing constructs common to existing high-level semantic \nand/or object-oriented data mod-els. These include the notions of objects, classes, instances, identity, \nand associations (attributes). 2. Extensibilitv Reauirement: The data model should be extensible. It \nshould allow addi-tional data model constructs to be plugged in thereby extending the set of core constructs \nto support higher level data model constructs.  2.2 Basic Modeling Constructs The set of basic data \nmodeling constructs that comprise XKOM are identified and presented be-low. A deliberate attempt has \nbeen made to iden-tify constructs that are neither semantically too specialized nor too primitive. We \nwill use an ex-ample schema shown in Fig. 2 to illustrate these basic model constructs. Figure 2: An \nexample application schema 2.2.1 Objects, Instances, and Classes A kernel object is the basic unit that \nmodels the ab-stract representation of any entity. A kernel class is an abstraction that describes the \nstructural and behavioral semantics of a set of like objects. A ker- nel instance is the representation \nof a kernel object in a particular class. A kernel object may partic-ipate in (belong to) more than one \nclass. Thus, the structural and behavioral properties of a sin-gle kernel object are distributed across \nas many classes as it belongs to, and an object has an in-stance in every class it belongs to. Effectively, \na kernel object is a union of all its instances. This distributed view of objects is used to support \nthe notion of generalization and inheritance. A kernel object may be self-named or system-named. A self-named \nobject, e.g. the integer 3, is an object whose value is the only means of referenc- ing it. A system-named \nobject is one to which the system assigns a globally unique identifier. Such objects are used to model \nreal world entities: phys-ical objects (e.g. a person), abstract concepts (e.g. a company), relationships \n(e.g. marriages), or events (e.g. earthquakes). Self-named objects are usually embedded as part of system-named \nob-jects. An important concept that must be supported is the notion of different types of classes correspond-ing \nto different types of objects. Two kinds of classes are included in the set of core concepts to be supported: \nEntity classes (E-classes) and Domain classes (D-classes). Instances of E-classes are in-dependently \naccessible objects, i.e. system-named objects. D-classes serve mainly as type definitions for domains \nof values, and instances of D-classes are self-naming objects which are not stored as per- sistent instances. \nE-classes have an associated set of persistent instances. In the example schema shown in Fig. 2, enti-ties \nsuch as persons, courses are represented as E-classes, whereas domains of values such as age, ssn, course#, \nare represented as D-classes. Also, the structural and behavioral properties of an object corresponding \nto a TA (Teaching Assistant) are distributed across four classes (Person, Teacher, Grad Student, and \nTA) with the object having a corresponding instance in each class.  2.2.2 Identity A strong notion \nof identity, based on tagged sur-rogates is used for system-named objects. Our reasons for using surrogates \nrather than disk ad-dresses are discussed in Section 2.4 which deals with the implementation issues of \nidentity and identity-address mappings. Two forms of identity, namely object identity and instance identity, \nare proposed. object identity (oid): a unique p-bit integer assigned to each system-named object instance \nidentity (iid): a (p+p) bit integer used to identify the instantiation of a specific object in a particular \nclass. Thus, instance identity (iid) = (cid) (aid) where, class identity (cid): a unique p-bit integer \nas- signed to each class in the system  2.2.3 Associations In data modeling, an important concept is \nthe notion of associations or relationships among classes[SU89] and the corresponding associations among \ninstances. XKOM supports the notion of associations among classes. Two basic types of associations, namely \nAggre-gation and Generalization [SMI77] are included in the core set of concepts to be supported. Generalization \n(G): captures the super-sub class relationships among classes. Unlike in program-ming languages, in database \nsystems it is impor- tant to consider the extension of a class: the set of persistent instances of the \nclass. Consequently, the set-subset relationship among instances of super-sub classes must also be considered. \nThe example schema illustrates such a G-hierarchy whereby a person can be a teacher and a parent. Aggregation \n(A): defines a directed structural relationship between a defining class and a con-stituent class. It \nrepresents a named mapping from one class (the defining class) to any other class in the system. Aggregation \nassociations are used to describe the structure of a class in terms of other classes. Again, since extension \nis important, such associations define the structure of an instance in relation to instances of other \nclasses. In object-oriented terminology, aggregation associations are also referred to as attributes \nor instance variables. The example schema illustrates aggregation asso-ciations such as that between \nPerson and ssn, and that between Teacher and Course. All model level associations are internally im-plemented \nas either value attributes or object ref-erence attributes, and this aspect is described in Section 2.3.2. \n 2.3 Storage Model In KOMS, an important issue is a generalized map-ping to the underlying storage layer. \nTo facilitate such a mapping, a well-defined model of storage for kernel objects is used as a basis. \nIssues relating to such a storage representation are presented below. 2.3.1 Static Storage Model vs \nDistributed Storage Model In implementing the structural aspects of XKOM, the storage and processing \nof objects in a gener-alization or super-sub class hierarchy is an impor- tant consideration. This determines \nhow inherited attributes are stored and processed. We considered two possible strategies for objects \nin a Generalization (G) hierarchy; a Static Storage Model (SSM), and a Distributed Storage Model (DSM). \nThese strategies are illustrated in Fig. 3. In SSM, an object physically exists in exactly one class \nof the class hierarchy. Here, an object is pushed to the lowest class it belongs to in the hierarchy, \nand each object stores direct attributes 01:representsa Person object 02:representsa Teacher object \n03:representsa TA object I I I PERSON 4 TEACHER i a_ (a) Static Storage Model (b) Distributed Storage \nModel Figure 3: Models of storage of that class, and also stores statically inherited at-tributes from \nall superclasses. Thus, for example, a Teacher object contains storage slots or fields for direct attributes \n(degree, salary), and for inherited attributes (name, ssn). In DSM, the structural properties of an object \nare physically distributed into as many classes as it belongs. An instance is thus the corresponding \npartition of an object in a given class. Each instance only stores the at-tributes defined for that class. \nThus, for example, a Teacher object has a representation (instance) in the Teacher class and a representation \n(instance) in the Person class, as well. A dotted line shows that they represent the same object. The \nmain advantage of SSM is that since all the attributes (direct and inherited) are clustered to-gether, \ncreation, update, and deletion of objects is straightforward and efficient. For retrieving all attributes \nof a given object, this approach is fast. In SSM, a main disadvantage is that scan-based access is inefficient, \nand indexing is complicated. For example, retrieving all persons whose age > 50, is not very efficient. \nThis requires scanning all objects in the class Person, and all objects in all subclasses of Person. \nSimilarly, indexing becomes complicated, requiring strategies such as class hi-erarchy indexes [KIM89, \nMAI86b]. A more serious shortcoming is the inability to represent an object that spans more than one \nbranch of a hierarchy. For example, the case where a person is a parent and a teacher cannot be handled. \nFor DSM, the main advantages are faster ac-cess for scan based access (e.g. selection), and the ability \nto represent the instantiation of an object across many classes (including the case where the object \nspans more than one branch of the general-ization hierarchy). Both these factors are impor-tant in database \napplications, and thus we opted for using DSM. The DSM approach also allows instances to be clustered \non a class basis (all in-stances of a class clustered together) or on a class hierarchy basis (all distributed \ninstances of an ob-ject clustered together). In SSM, the latter tech-nique is built in, and cannot be \nchanged. The main disadvantage in DSM is the added complexity and overhead in creating, updating, and \ndeleting an object that is partitioned. The cost of inserts, up-dates, and deletes is higher than SSM, \nbut can be minimized by using class hierarchy clustering tech-niques. 2.3.2 Storage structure of a generic \nin-stance The storage structure of a generic instance based upon DSM is shown in Fig. 4. A storage in-stance \ncontains two types of attributes or fields; descriptive data attributes (value fields) and asso-ciation \nattributes (object reference fields). Using these two types of attributes or fields allows for the uniform \nrepresentation of all objects. Com-plex/composite objects can be represented using a combination of value \nand reference fields. Large uninterpreted objects can be represented using a value field called raw (i.e. \nblobs ). Complex data types can be similarly represented using value fields.  Value Fields Value fields \nare used to store primitive data types (e.g. integer, string) or D-class objects (e.g. user-defined data \ntypes) The primitive data types that are currently sup-ported are integers, floating point numbers, char-acters, \nand strings. It is planned to add two more primitive data types, called shortraw, and ~ &#38;id> . instance \nid of instance <id> <list of iid. reference attributes of instance <I&#38; of iiak> .,.,....,..,.,..,......,. \n(.....,...:I value (primitivedata type) value (D claw object) value II Figure 4: Stucture of a generic \nstorage instance long-raw, to accommodate user defined data types, and values that represent large/small \nunstructured objects (e.g. bitmaps). ShortJaw represents a short (<l block) uninterpreted sequence of \nbytes, and long-raw represents a large uninterpreted se-quence of bytes. Management of long-raw would \nrequire techniques such as those proposed by Ex-odus [CARSSa] and WiSS [CH085] (the long field manager). \nAlso, complex D-class objects (e.g. user-defined data types) would be stored as un-interpreted bytes \nand are interpreted by the Type Management Module of the Kernel System.  Object Reference Fields Object \nreference fields are used to support the no- tion of links between object instances. We imple-ment object \nreferences via identity reference, i.e., an instance stores the identity (surrogate) of the instance \nit refers to. Motivation and justification of this decision is presented in Section 2.5. An ob-ject reference \nfield is specified either as IID or as IID-ARRAY. The former supports 1:l references and the latter supports \n1:m references. Note that every instance stores its own identity using an IID field, as well.  2.4 \nIdentity and Identity-Address map-pings While it has been argued that logical disk ad-dresses can provide \na high performance mechanism for implementing identity, we use surrogates in or-der to insulate the upper \nlayers from having to know the address formats used by storage man-agers. This provides data independence \nand al-lows modules in upper layers such as query pro-cessors, to be developed in a manner that easily \naccommodates the substitution or replacement of the storage layer. For the same reasons, object references \nare implemented as identity references. System-defined surrogates can provide the highly desirable features \nof uniqueness, immutability, and the ability of the system to define surrogates in any specialized format. \nIn contrast, if disk addresses are used, identity is no longer immutable and disk garbage collection \nbecomes a serious problem when objects are moved around on disk. An in-depth study of these aspects can \nbe found in [KH086]. The main argument against using surrogates as identity is that it involves a performance \npenalty due to the use of an object table to perform identity-address mappings. While this is a valid \nargument, we believe that surrogates serve an im-portant purpose and instead better techniques for performing \nfast lookups must be developed. To perform faster lookups, the following techniques are utilized. a. \nspecialized formats for identity: Currently, the system uses 32 bit identifiers that are generated using \na counter or the system clock. To improve the hashing performance of an object lookup, a skewing technique \nmay be used to shuffle the posi-tions of the identifier bits by a predefined transfor-mation to produce \nanother 32 bit identifier having better hash characteristics. b. partitioned object tables: Partitioned \nobject tables are used, with each class maintaining a par-tition to perform identity-address mappings \nfor that class. The smaller size of the partition im-plies a faster lookup. c. main memory object tables: \nCurrently, if any class is referenced or an object of a class is accessed, the entire object table partition \ncorre-sponding to that class is staged in memory to pro-vide faster lookups.  2.5 Object References \nInternally, there is no distinction between a class and a meta-class. In KOMS, object references are \nimplemented as identity references. In main memory systems such as programming languages, object references \nare achieved through virtual memory pointers since there is no persistence. In persistent systems, ei-ther \ndisk pointers or identity can be used to im-plement references. If disk pointers are used, a given application \nmust ensure that disk pointers are correctly transformed to virtual memory point-ers and vice versa. \nThis requires techniques such as pointer swizzling and dual/three-way point-ers. Again, to achieve data \nindependence we use identity references. When access to the referenced object is required, a simple lookup \noperator (#) is used to return the virtual memory pointer (this lookup is done once, at the beginning). \nThe lookup operator(#) pro-vides transparent object access: if the object is already present in main \nmemory, the correspond-ing virtual memory pointer is returned, otherwise the object is retrieved from \ndisk, and the virtual memory pointer returned. The application deals only with identity and memory pointers. \nIt never sees the disk pointers, and thus does not have to keep track of disk pointers. This is shown \nbelow; IID x; /* x represents an iid */ OBJECT* y; /* y is a virtual memory pointer */ x = select (Person, \nssn = 111222333); /* set x to the iid of a given person */ Y = #x ; /* y is now the virtual memory pointer \nof x */  2.6 Class System Model reflexivity is the concept of using a given model to model itself. \nIn this section, we present the model meta-class system: a set of meta-classes which results when a data \nmodel is used to explic-itly model itself. This class system provides a spec- ification and implementation \nof the data model constructs, and can be used as a powerful mecha-nism for achieving extensibility and \nparameteriza-tion. We use the term meta-class to refer to a class which is used to define model or system \nsemantics. A simplified version (without many details) of these model meta-classes is shown in Fig. 5. \nModel constructs such as classes, associations, methods, and rules are treated as first class objects. \nOb-jects in the meta-class CLASS represent class ob-jects, including application classes, system classes \nor meta-classes. Similarly, objects in the meta-class ASSOCIATION represent associations or re-lationships \nbetween classes, including relationships such as generalization, aggregation or any other association \ntype. Each association has a defining class (the class that defines the relationship) and one or more \nconstituent classes (the classes over which the relationship is defined). In binary rela-tionships, an \nassociation has a single constituent class whereas in n-ary relationships, an associa-tion has multiple \nconstituent classes. Objects in the meta-class METHOD represent method ob-jects and objects in the meta-class \nRULE repre-sent rule objects. The root of this class hierarchy is the class OBJECT, which indicates that \nevery-thing in the model is an object. The meta-classes E-CLASS OBJECT and D-CLASS OBJECT, rep-resent \nthe fact that every object in the model is either a system-named object or a self-named ob-ject. The \nclass CLASS is sub-classed into classes E-CLASS and D-CLASS to represent class ob-jects corresponding \nto E-classes and D-classes re-spectively. Similarly, the class ASSOCIATION is sub-classed into classes \nGENERALIZATION and AGGREGATION to represent association objects corresponding to the two types of associations, \nnamely, Generalization and Aggregation. Other association types can be added to the model by creating \nsubclasses of the class ASSOCIATION and/or any of its subclasses. The meta-class CLASS is an important \nmeta-class, and is described further. It represents the concept of a class in the data model. Every class \nhas a className, a classID, a set of Associations, a set of Methods, and a set of Rules. The set of Associations \nassociated with a class can include G-associations, A-associations or any other form of Association. \nFor example, if the data model allows a class to have more than one superclass . Figure 5: Modeling the \n(i.e. multiple inheritance), then this is reflected in the model meta-schema by this class participating \nin G-associations with all its superclasses. Other meta-classes can be similarly described. When using \nthe model to model itself, a boot- strap process is required to initially populate the model schema \nwith information of the model itself. To bootstrap the meta-class CLASS, the meta-class CLASS must be \nfirst defined, and the first object that must be instantiated in this class is the object that represents \nthe meta-class CLASS itself. This is the first object in the system. For the sake of clarity, we will \nterm this first object as the CLASS-object. The CLASS-object is the only ob-ject in the system whose \nclass-id is identical to its object-id; the instance-id is thus a concatenation of two 32 bit integers, \nboth of which have the same value. In the model of the model, the attribute called SetOfInstances defined \nfor E-CLASS, repre-sents the fact that all E Classes have an extension. The meta-class CLASS is also \nan E-class, since instances of class CLASS represent system-named objects. Hence, CLASS-object must also \ninstanti- ate the meta-class E-CLASS. The extension of the meta-class CLASS is represented by the setOfIn-stances \nattribute of the instance in E-CLASS cor-responding to the CLASS-object. Thus, if we it-model (Model \nReflexivity) erate the extension of the meta-class CLASS, we would get all classes in the system. The \nbootstrap process proceeds by setting up the class hierarchy that defines the model, setting up the first \nobject of class CLASS, and then instantiating meta-classes such as CLASS, ASSOCIATION, etc., with all \nnec- essary objects that describe the model itself (i.e. classes and associations that describe the model). \nOnce this is done, the model is ready for use by an application. An initial version of this model meta--architecture \nhas been completed. A bootstrap pro-cess has been defined in which the C++ program-ming language is used \nto perform bootstrapping. The meta-classes METHOD and RULE have not yet been implemented, and are currently \nunder in-vestigation. The meta-model schema component that deals with user-defined complex data types \n(e.g. matrices) has not been investigated as yet.  2.7 Model Extensibility One requirement for the Kernel \nObject Manage-ment System is that the layer it represents be ex-tensible upwards to support different \napplication domains and data models. Model Extensibility en-compasses data model extensions such as various \nforms of inheritance, abstract data types, param-eterized classes, user-defined class and association \ntypes, etc. Model Extensibility is achieved by modifying the model meta-classes: the model meta-class \nsys-tem serves not only as a specification of the user data model constructs but also as a basis for \nthe implementation of such constructs. Meth-ods (functions) and/or rules defined in the meta-classes \nare used to implement data model con-structs. We illustrate some scenarios with respect to Fig. 5. For \nexample, modifying the specifica-tion and implementation of the meta-class CLASS causes the semantics \nof a class in the data model to change. Consider the case where the meta-class CLASS does not have the \nattributes setOfRules and set0fMethods. This implies a model that is structurally object-oriented but \nnot behaviorally object-oriented [DIT86]. Additionally, if the setO-fAssociations attribute of CLASS \nis constrained to only contain objects from D-CLASS AGGREGA-TION, this implies a model that has no Gener-alization \nor E-class Aggregation associations (e.g. the relational model). Similarly, appropriate con-straints \non the setOfAssociations attribute can de-termine whether a class has one or more super-classes, i.e. \nsingle or multiple inheritance. Two aspects of such model extensibility are of main interest to us, namely, \nclass extensibility, and association extensibility. We also note that another important consequence (actually, \na side-effect) of modeling the model is that it automati-cally provides a basis or schema for the data \ndic-tionary (catalog). In this case, the data dictionary maintains not only meta-information of the appli-cation, \nbut also of the data model and system ar-chitecture. Thus, the model itself, the meta-data, and application \nare all uniformly represented as objects using the o-o paradigm. Class and Association Extensibility \nClass Extensibility is a form of extensibility whereby a model can be extended to provide new types or \ncategories of classes. Similarly, Associa-tion Extensibility is a form of extensibility whereby a model \ncan be extended to provide new types or categories of associations or relationships among classes. To \nprovide such extensibility, we exploit the parameterization of classes and associations at a meta level. \nTo illustrate class extensibility, consider the two basic types or categories of classes in XKOM: E-classes \nand D-classes. One important distinction is that E-classes explicitly store an extension. Con-sequently, \noperations such as select (described in Section 3), can be defined and implemented in the (meta) class \nE-CLASS. If a class called Person is defined as a subclass of E-CLASS OBJECT, then the class Person inherits \nmethods that apply to all E-class objects. However, methods defined in E-CLASS apply to the Person class \nobject (the object representing the class Person), since the Person class object is an instance of the \nclass E-CLASS. Thus, it is possible to send a message called select to the instance of E-CLASS that represents \nthe Person class. Class Extensibility is carried out as follows. If a new class type called X is required, \nthen XCLASS OBJECT is defined as a subclass of Object, and XCLASS is defined as a subclass of CLASS. \nThe semantics of X classes are described by defining XCLASS in an appropriate manner. Existing class \ntypes (e.g. E-class, D-class) may also be extended by sub-classing the meta-classes corresponding to \nsuch existing class types. Similarly, we illustrate the notion of Association Extensibility. In [SMI77], \nAggregation and Gen-eralization, have been recognized as fundamental types of relationships or associations. \nFor Aggre-gation and Generalization, the explicit modeling of such association types is illustrated in \nFig. 5. Similar to class extensibility, it is possible to add a new association type or extend an existing \nasso-ciation type by sub-classing. Thus, the model can be extended by defining customized association \nor relationship types to fit a particular domain. Our experience with such meta-classes indicates that \nspecifying customized semantics is easily fa-cilitated by specifying constraints or rules in these meta-classes. \nThese constraints may govern the processing of object instances belonging to partic-ular class types \nand object references correspond-ing to specific association types. Thus, we plan to explore the specification \nof high-level declar- ative rules for expressing extended semantics in 3.2.1 Association-based access \norder to achieve model extensibility. Such rules will be defined for meta classes such as CLASS, E-CLASS, \nASSOCIATION, AGGREGATION and other classes representing class and association types.  3 Object Processing \n3.1 Processing Requirements The processing requirements of KOMS are pri-marily based on the needs of \nclient modules such as query and rule processors, transaction man-agers, etc., in the upper layers. To \nsupport such client processing needs, KOMS must support set-oriented processing, association-based processing \nand value-based processing.  3.2 Processing Issues In database applications, as evidenced by the na-ture \nof database query languages, a key require-ment is set-oriented processing. As such, KOMS provides a \nwell-defined and generic interface to clients in the upper layers in the form of a set of kernel object \noperations. These basic, seman-tically meaningful, and set-oriented operators are based on the small \nset of core object model con-structs described previously, and are used to per-form inserts, updates, \ndeletes and retrievals on ker-nel objects. In KOMS, the interface serves as access meth- ods which (1) \nare at the class level (operations in- volve the set of objects belonging to a single class), (2) at \nmost, require a single scan, and (3) are set-oriented. We expect operations that span multiple classes \nto be carried out by access methods in the clients of KOMS. The implementation of the inter-face uses \nthe underlying model of storage objects described in Section 2.3, and has been carried out with a view \ntowards extensibility, i.e. the addition of extra operators to the basic set provided. For re-trievals, \ntwo important form of access are provided: association-based access, and value-based access. A key feature \nin object-oriented databases (unlike in relational systems), is the notion of association queries. Such \nqueries compute patterns of associ- ations or relationships among instances of object classes. Consider \nthe following query; Teacher * Course This query computes all objects of class Teacher that are associated \nwith (i.e. related to) objects of class Course. The star (*) indicates associated with This requires \nKOMS to iterate the set of kernel objects of class Person, and determine all object references to class \nCourse. Such processing is set-oriented, and requires a single scan of the instances of a class. KOMS \nincorporates access methods (struc-tures, indexes and algorithms) to support such association-based access. \nThe following factors have been a consideration: (a) the processing of object references is set-oriented, \n(b) the nature of the processing is navigational, and (c) inverse ob-ject references may be required \nand must be opti-mized. In this respect, KOMS offers a functionality that is different from that of many \nother existing object-based systems. Also provided is the capability of determining non-associations, \ni.e. objects of one class that are not associated with objects of an-other class. In comparison with \nrelational systems, a join-operation is a value-based match on specific columns. Unlike relational systems, \nassociations can be considered as a set of pre-joins (links) which for a given class can be accessed \nin a single scan since links are explicitly stored. For the same rea-son, it is also possible to compute \nnon-associations easily and efficiently. Our work on a pattern based query language (OQL) and a pattern-based \ncon-straint language illustrating the use of association- based processing can be found in [ALA89, SU91]. \n3.2.2 Value-based access In object-oriented databases it is also necessary to perform value based processing \non descriptive data attributes or value fields of objects. This includes processing of complex data types \nsuch as matrices. Consider the following query; Teacher[select -cond] * Course This query illustrates \na combination of value-based access and association-based access. It com-putes all instances in the class \nTeacher satisfying a selection condition (placed on the value fields of teacher instances) which are \nassociated with in-stances of class Course. The value-based access refers to the ability to determine \nwhich instances of the class Teacher satisfy the value based selection condition. If the condition is \n[age = 351, a point ac-cess is desired and a scan may be necessary if there is no index on age. If the \ncondition is [age > 351, a partial scan may be required. For more com-plex selection conditions such \nas [age > 35 AND degree = PhD ], an index (if available) must be considered or full scans must be performed. \nThus, direct access, partial scans or furl scans are needed to support value-based processing. Traditional \nno-tions of indexing, and sorting can be used.  3.3 Interface The set of operations that comprise the \ninterface of KOMS can be broadly classified into five cate-gories: create, insert, update, delete, and \nretrieve. Currently, all retrieve operations are set-oriented, while the others are specified either \nas instance-level or object-level operations. Operations at the instance level simply deal with the semantics \nof a single instance within a given class, while those at the object level deal with the semantics of \nan ob-ject whose instances are distributed across a gen-eralization hierarchy or class lattice. 3.3.1 \nSyntax and informal description of operators Category #l: Create 1. create-Object 0: Creates a new oid. \nThis operation is called when a new object is cre-ated, invokes the necessary identity manage-ment routines, \nand returns a new oid. Category #2: Insert 2. insert-Instance ((class), (aid), (arg-list)): In-serts \nan instance of object (oid) into a class (class). The operation inserts the instance into the Object \nTable partition of the given class, sets the value fields of the instance, sets the association attributes, \nand finally, in-serts the instance in the database. An argu-ment list (arg-list) specifies association \nand value attributes as (name-value) pairs. Un- like insert-object, the argument list cannot specify \nany inherited attributes. Association attributes (except G) are specified by using oids as values. G-association \nattributes can-not be specified, since these attributes are au-tomatically maintained by the system as \nit en- forces the partitioning of the object along class boundaries. 3. insert-Object ((class), (aid), \n(aq-list)): In-serts an instance of object (oid) into a class (class), and corresponding instances into \nall appropriate classes in the superclass hierar-chy of the class (class). This operation is used when \ninserting an object for the first time in a class hierarchy or lattice, and when inserting an existing \nobject in another branch or a lower level of the class hierarchy. Starting with the given class (class), \nthe operation recursively navigates up each branch of the super-class hierarchy and invokes the insert-Instance \nop-eration for each class in the hierarchy, begin-ning from the top-most level reached down to the given \nclass. The algorithm corresponding to this operation implements the partitioning of the structural properties \nof an object along class boundaries. The argument list speci-fies association and value attributes as \n(name-value) pairs, including inherited attributes. Category #3: Update 4. update-Instance ((class), \n(aid), (aq-Zist)): Updates attributes of the instance of object (oid) in class (class). An argument list \n(arg-list) specifies attributes to be updated. The (arg-list) contains (direct) attributes from the specified \nclass only (no inherited attributes), and association attributes (except G) may be specified. 5. update-Object \n(( cZass), (oid), (arg-list)): Up-dates attributes of the instance of object (oid) in the given class \n(class) and of any in-stance of (oid) in the super-class hierarchy of (class}. Starting with the given \nclass, the operation determines which instances of the specified object in the superclass hierarchy of \nthe given class are to be updated. Then, up-date-Instance operation is invoked (with the appropriate \nargument list) in all classes con-taining instances that are to be updated. The argument list (arg-list) \nspecifies attributes to be updated. The (arg-list) may contain in-herited attributes, and association \nattributes (except G) are also allowed. 6. associate (( czassl), (aid) , (cZass2), ( oid-list), (ussoc-name)): \nAssociates the instance of ob- ject (oid) in class (classl) with instances of objects (oid-list) of class \n(class2). This oper-ation serves as a mechanism to set or update the association or object reference \nattribute of a kernel object. It ensures that when objects are associated, two-way(inverse) binary asso-ciations \n(or links) are created. The (assoc-name) specifies the name of the schema level association from (classl) \nto (class2).  7. dissociate (( cZussl) , (aid), (cluss2), (aid-list), (assoc-name)): Dissociates (unlinks) \nthe as- sociation that exists between the instance of object (oid) in class (classl) to the instances \nof objects (oid-list) of class (class2). This op-erator ensures that when objects are dissoci-ated, the \nbinary, two-way(inverse) association between objects is updated accordingly. The (assoc-name) specifies \nthe name of the schema level association from (classl) to (cIass2). Category #4: Delete 8. delete-Instance \n((clnss), (aid)): Deletes the instance of object (oid) in the class (class). The operation unlinks this \nobject instance from all other object instances, removes the entry corresponding to this instance in \nthe ob-ject table segment of the given class, and then removes the the instance removed from the database. \n9. deZete_Object ((~ZUSS), (aid)): Deletes all in-stances of a given object (oid) in the given class \n(class) and in all classes in the subclass hierarchy of class (class). This operation is used to remove \nall instances of an object start-ing at a specified level and below in the class hierarchy. If an object \nhas a single root class, and this operation is invoked at the root class, the net effect is the removal \nof all instances of the given object. The operation deter-mines the subclass hierarchy rooted at the \ngiven class, and invokes the delete-Instance operator for all classes in the subclass hier-archy, beginning \nfrom the bottom most class in the hierarchy up to the given class. The algorithm that implements this \noperation is based on the partitioning of an object along class boundaries. 10. destroy-Object ((aid)): \nDeletes all instances of a given object (oid). The operation proceeds by determining the root classes \nof the given object. The delete-object operation is then invoked for each root class.  Category #5: \nRetrieve 11. retrieve (( cluss), (aid-list), (attr-list)): Re-trieves a set of specified objects (oid-list) \nfrom the class (class). If a list of attributes (attr-list) is specified, only these selected attributes \nof the objects are projected out. If the (attr-list) is specified as (all), then all attributes are projected \nout. Inherited attributes may be specified. If the (oid-list) is specified as (all), then aids of all \ninstances of the given class (class) are used as the given oid-list. The op-eration returns a set of \npartial objects, where a partial object is a projection of the original object on the specified attributes. \n12 select ((class), (select-cod)): Selects a set of instances from the class (class), which sat-isfy \nthe selection condition (select-cond). The selection condition is specified as a conjunc-tion or disjunction \nof (name op value) triplets, where op is a comparison operator. The at-tributes used in the selection \ncondition must be value or descriptive attributes (inherited attributes are allowed). Returns a set of \noids that satisfy the condition. 13. star ((CZUSSl), (oid-list), (CZUSSZ), (ussoc- name)): Retrieves \nfrom the class (classl), those objects in (oid-list) which have object references to any objects in the \nclass (class2), through the association (assoc-name). If the (oid-list) is specified as (all), then all \nobjects of (classl) having object references to any ob-ject in the class (class2) are retrieved. Re-turns \na list of oid pairs, each pair signifying an object of (classl) which is associated with a particular \nobject of (class2). 14. non-star ((cZassl), (oid-list), (cZass2), (ussoc- name)): Retrieves from the \nclass (classl), those objects in (oid-list) that have no ob-ject references to any object in the class \n(class2). The (assoc-name) specifies the name of the schema level association from (classl) to (class2). \nIf the (oid-list) is specified as (all), then all objects of (classl) having no object references to \nany object in (class2) are retrieved. Returns a set of oids.   4 System Implementation The system \nconfiguration of KOMS as a layer on top of a storage management layer is shown in Fig. 6, and components \nof KOMS are shown within this layer. Components of KOMS have been im-plemented in C++, and use the persistent \nfacili-ties provided by ONTOS in the underlying storage layer. Details of this implementation can be \nfound in [LAW91]. In the following section, we describe system modules and components via schema dia-grams \nor class hierarchies. 4.1 System Extensibility System Extensibility is the ability to modify or extend \nthe modules that comprise the software ar-chitecture of the system. System extensibility is Figure 6: \nConfiguration of KOMS easily achieved if the software architecture of a sys- tem is developed as an \nopen, modular, and exten-sible architecture with well-defined interfaces. We develop a system architecture \nschema; a schema comprising system software modules and their associations (interactions) with one another. \nConsequently, software modules and interfaces are modeled and implemented as classes and objects for \nease of extension. Thus, files, buffers, file man-agers, buffer managers, query processors, data dic-tionaries, \nobject managers, etc., can be modeled as classes and objects. A software module is spec- ified using \nseveral classes, and is implemented us-ing member functions or methods in these classes. Each module \nhas one or more interface classes. 4.1.1 System Modules and Interface Classes An interface class is a \nspecial type of class that represents a particular interface to a group of other classes. For example, \na module that comprises 5 classes has a combined interface equal to the sum of the interfaces of each \nclass (say 30 methods). Col-lectively, these 5 classes represent a module which may have a much smaller \ninterface (e.g. 6 meth- ods). We take the collective (not combined) inter-face of these group of classes \nand package it into a class called an interface class of the module. A module thus serves as a higher \nlevel of system ab-straction than a class. IN THE MODEL $ Figure 7: Several 4.1.2 Example Modules We \nuse some simplified examples from our system, shown in Fig. 7, to illustrate the concept of mod- ules \nand interface classes. In the first example, identity and two cur-rently supported forms of identity, \ntime-stamp and skewed counter, are modeled as a class and two subclasses respectively. A single interface \nclass, ID-Handler, is used to access these different forms of identity. Thus, it it possible to easily \nextend the notion of identity. The second related example is that of identity-address mappings or object \nTa-bles. Two variants of object tables, a Linear Hash version and a B+/B* index version, are shown as \nsubclasses. The class OT-Handler serves as an in-terface. A more complex example is the meta-data or \ndata-dictionary module. The classes that comprise the structure of the data dictionary are the same (meta) \nclasses shown in Fig. 5. Interface to the data dictionary is via the DicHandler class. An external module \nuses the DicHandler class by first creating a DicHandler object, and then sending it a message to invoke \nthe appropriate interface func-tion. This is illustrated below: DicHandler *aDicHandler; aDicHandler \n+ getAllSuperClassesOf( TA ); The action taken by the corresponding method in the DicHandler class is \nas follows. It examines the arguments list, and unpacks the argument  System Modules list into various \nobjects (belonging to classes that comprise the module). Messages are sent to these objects, and the \nactual method is implemented in the classes that comprise the module. The Inter-face class, in effect \nplays the role of a message con-troller , and directs messages appropriately. This is illustrated (using \nC++ like code) below: DicHandler::getAIISuperClassesOf(char* name){ IID x; CLASS* y; KernelObjectHandler \nhl; /* unpack argument into appropriate objects */ x = hl + select( CLASS , name= TA ); /* x is now \nthe iid of the Class TA object */ /* get virtual pointer to TA class object */ y = #xi /* send message \nto appropriate object */ ;+ getAllSuperClassesOf(); The actual computation of the result is done by \nthe function getAZZSuperCZassesOf() in the meta-class CLASS. The above example also illustrates the use \nof the KernelObjectHandler class which represents the interface operators described in Sec- tion 3.3. \nConclusions In this paper, we have described our experi-ences with designing and implementing a Ker- \n nel Object Management System (KOMS): an in-termediate layer of a layered extensible object-oriented \nknowledge base management system called OSAM*.KBMS/X. The issues of building a generalized system have \nbeen addressed by propos- ing an intermediate layer with upward and down-ward extensibility instead of \nbuilding a monolithic system. A deliberate attempt has been made to use a set of core object modeling \nconstructs as a basis for the system. The system has been imple-mented with extensibility as a key goal. \nBy using the extensible Kernel Object Model (XKOM) to model itself, a well-defined model schema has been \ndeveloped, which can be used by a Database Implementor (DBI) to generate cus-tomized model semantics. \nAn initial version of this model meta-architecture has been implemented. Similarly, by modeling the system \narchitecture us-ing classes and objects, a well-defined schema (i.e. description and implementation) \nof the system ar-chitecture has been developed, which can be used by the DBI to extend the system. All \ncurrent mod-ules of KOMS have been implemented using such an extensible approach. In terms of extension, \nwe foresee that with the standardization of classes and objects representing software components, system \nextension would involve system synthesis from pre-existing software modules. This can form the basis \nfor rapid prototyping of software systems. Rapid prototyping is planned as one of the applications of \nKOMS. We have also identified and explored several con-cepts that relate to the notion of core object \nmod-eling constructs. A model of storage using a parti- tioning of objects along class boundaries has \nbeen developed. Correspondingly, a generalized stor-age structure for object instances has been defined. \nThe management of associations (or relationships) is a key issue that has been addressed by strong support \nfor object references. A set of basic object manipulation operators have been identified and implemented. \nCurrently, as part of the OSAM*.KBMS/X architecture, we are extending this concept to the design and \nimplementation of an Adjacency-Matrix-based Query Processor and an Integrated Rule Processor as upper \nlayer clients of KOMS. We expect to follow a similar system develop-ment approach, coupling a generalized \napproach with extensibility. We plan to extend the meta-architecture concept to support queries, rules, \nmethods, etc. as first class objects. The results achieved with our current effort have been encour-aging \nand lead us to believe that a similar approach to the development of the upper-layer software will provide \nus with the expected results in terms of modularity and extensibility.  Acknowledgements This research \nis partially supported by the Na-tional Science Foundation (Grant # DMC-8814989, IBM (Grant# S919FM81), \nand the Florida High Technology and Industry Council (Grant# UPN 90090708) Bibliography [ALA891 A. M. \nAlashqur, S. Y. W. Su, and H. Lam, OQL: A Query Language for Manipulat-ing Object-oriented databases, \n15th VLDB, 1989. [AND871 T. Andrews, and C. Harris, Combin-ing Language and Database Advances in an Object-oriented \nDevelopment Environment, ACM OOPSLA, 1987. [AST76] M. Astrahan, et al. System R: Rela-tional Approach \nto Database Management, ACM Trans. on Database Systems, l(2), June 1976. [ATK89] M.P. Atkinson, et al. \nThe Object-Oriented Database System Manifesto, Al-tair Technical Report 30-89, Rocquencourt, France, \nAug. 1989. [BAN871 J. B anerjee, et al. Data Model Issues for Object-oriented Applications, ACM Trans. \non Office Information Systems, 5(l), 1987. [BAT881 D.S.Batory, et al. GENESIS: An Exten-sible Database \nManagement System, IEEE Trans. on Software Engineering, 14( ll), 1988. [CARSSa] M.J. Carey, et al. Object \nand File Man-agement in the EXODUS Extensible Database System, 12th VLDB, August 1986. [CAR86b] M.J. \nCarey, et al. The Architecture of the Exodus Extensible DBMS, International Workshop on Object-Oriented \nDatabase Sys- tems, Sept. 1986. [CH085] H. T. Chou, et al. Design and Imple- mentation of the Software \n-Practice Oct. 1985. Wisconsin Storage and Experience, System, 15(10), [COP841 G. Copeland, and D. Maier, \n Making Smalltalk a Database System, ACM SIG- MOD, 1984. [DIT86] K.R. Dittrich, Object-Oriented Database \nSystems: The Notions and the Issues, In-ternational Workshop on Object-Oriented Database Systems, 1986. \n[FIS87] D. Fishman, et al. Iris: An Object Ori-ented Database Management System, ACM Trans. on Office \nInformation Systems, 5(l), Jan. 1986. [HAM811 M. Hammer, and D. McLeod, Database Description with SDM: \nA Semantic Data Model, ACM Trans. on Database Systems, 6(3), 1981. [HULL871 R. Hull, and R. King, Semantic \nDatabase Modeling: Survey, Applications and Research Issues, ACM Computing Surveys, 19(3), 1987. [KHOSG] \nS. Khoshfian, and G. Copeland, Object Identity, ACM OOPSLA, 1987. [KIM891 W. Kim, et al., Indexing techniques \nfor object-oriented databases, in Object-Oriented Concepts, Databases, and Applications, W. Kim and F. \nLochovsky (Ed.), Addison Wes-ley, 1989. [LAW911 S.F. Law, Object-oriented Design and Implementation of \na Kernel Object Manager, M.S. Thesis, University of Florida, May 1991. [LEC88] C. Lecluse, et al., 02, \nan object oriented data model , ACM SIGMOD, 1988. [LOO861 M.E.S. Loomis, Data Modeling -The IDEFlX Technique, \nIEEE Communications, March 1986. [MAI86a] D. Maier, et al. Development of an Object-Oriented DBMS, ACM \nOOPSLA, 1987. [MAI86b] D. Maier, and J. Stein, Indexing in an Object-oriented DBMS, International Work-shop \non Object-Oriented Database Systems, 1986. [MIT891 M.J. Mitchell, et al. Data Model Devel-opment and \nValidation for Product Data Ex- change, Technical Report, National Institute of Standards and Technology, \n1989. [ONT90] Ontologic Inc., ONTOS: Object Database, System Documentation, Version 1.5, 1990. [PAU87] \nH. -B. Paul, et al. Architecture and Im-plementation of the Darmstadt Database Ker-nel System, ACM SIGMOD, \n1987. [SCH86] P. Schwarz, et al. Extensibility in the Starburst Database System, International Workshop \non Object-Oriented Database Sys- tems, 1986. [SHI81] D. Shipman, The Functional Data Model and the Data \nLanguage DAPLEX, ACM Trans. on Database Systems, 6(l), 1981. [SKA86] A. Skarra, S. Zdonik, and S. Reiss, \nAn Object Server for an Object Oriented Database System, International Workshop Object-Oriented Database \nSystems, 1986. [SMI77] J. Smith, and C. Smith, Database Ab-stractions: Aggregation and Generalization, \nACM Trans. on Database Systems, 2(2), 1977. [ST0861 M. St onebraker, and L.A. Rowe, The De-sign of POSTGRES, \nACM SIGMOD, 1986. [SU89] S. Y. W. Su, V. Krishnamurthy, and H. Lam, An Object-oriented Semantic Association \nModel (OSAM*) in AI in Industrial Engi-neering and Manufacturing: Theoretical Is-sues and Applications, \nKumara, S., et al., (ed- itors), American Institute of Industrial Engi-neering, 1989. [SU91] s. Y. w. \ns u, and A. Alashqur, A Pattern- based Constraint Specification Language for Object-oriented Databases, \nProc. of Spring COMPCON, 1991. [VEL89] F. Velez, G. Bernard, and V. Darnis, The 02 Object Manager, an \noverview, 15th VLDB, 1989. [VER82] G.M.A. Verheijen, and J. Van Bekkum, NIAM: An Information Analysis \nMethod, in Information Systems Design Methodologies: A Comparative Review, T.W. Olle, H.G. Sol, Verrijn-Stuart \n(Ed.), North Holland, 1982. [ZAN83] C. Z aniolo, The Database Language GEM, ACM SIGMOD, 1983.  \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "Rahim Yaseen", "author_profile_id": "81392596530", "affiliation": "Database Systems Research and Development Center, Department of Computer and Information Sciences, Department of Electrical Engineering, CSE 470, University of Florida, Gainesville, FL", "person_id": "P237679", "email_address": "", "orcid_id": ""}, {"name": "Stanley Y. W. Su", "author_profile_id": "81451595578", "affiliation": "Database Systems Research and Development Center, Department of Computer and Information Sciences, Department of Electrical Engineering, CSE 470, University of Florida, Gainesville, FL", "person_id": "PP14048390", "email_address": "", "orcid_id": ""}, {"name": "Herman Lam", "author_profile_id": "81100237344", "affiliation": "Database Systems Research and Development Center, Department of Computer and Information Sciences, Department of Electrical Engineering, CSE 470, University of Florida, Gainesville, FL", "person_id": "PP40025208", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117973", "year": "1991", "article_id": "117973", "conference": "OOPSLA", "title": "An extensible kernel object management system", "url": "http://dl.acm.org/citation.cfm?id=117973"}