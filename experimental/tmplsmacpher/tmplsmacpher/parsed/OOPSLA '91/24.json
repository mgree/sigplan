{"article_publication_date": "11-01-1991", "fulltext": "\n Symbolic and Spatial Database for Structural Biology Dan Benson, Greg Zick Department of Electrical \nEngineering, FT-10 University of Washington / Seattle, WA 98 195 benson@ee.washington.edu zick@ee.washington.edu \nABSTRACT This paper describes the development of a database to support three-dimensional image reconstruction \nof structural biology using object-oriented technology. The requirements of this system encompass many \nof the popular justifications for the application of object-oriented technology, such as non-standard \ndata types and complex composite data, but we also find advantage in the increased functionality obtained \nfor spatial relationship operations and access methods. We focus attention on the implementation of the \nspatial data, its representation, operations, indexing, and queries. 1 INTRODUCTION Biomedical imaging \nis making a tremendous impact on medical knowledge, teaching, and practice due to the fact that images \nprovide a great deal of information that is otherwise unobtainable. Improvements on the acquisition, \ndissemination, understanding, and use of this information comprise the bulk of imaging research activities. \nA brief summary of them includes the development of new image modalities, image acquisition techniques, \nimage processing, feature extraction, object recognition, and applications which make Permission to copy \nwithout fee all or part of this material is granted provided that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \nappear, and notice is given that copying is by permission of the Association for Computing Machinery. \nTo copy otherwise, or to republish, requires a fee and/or specific permission. Q 1991 ACM 89791-446.5/91/0010/0329...$1.50 \nuse of the extracted information. As these technologies advance, and even become automated, the crucial \nmissing component is the organization and management of the underlying data that is generated [DUER83]. \nShown graphically in Figure 1, data generated by these biomedical imaging activities can be organized \nin a database that supports multiple data types and multi-level models. Figure 1. The role of a Biomedical \nImaging Database Images contain information about real world objects. Once acquired, each stage in the \nprocess carries this information along while squeezing out certain elements of the image contents forming \nan internal model or representation that can be used by applications. These stages are all related, in \nfact, they build off of each other.  OOPSTAW> pp. 329.-339 Likewise, there exists relationships among \nthe data each stage generates. There are two basic categories of data a biomedical imaging database must \nsupport, symbolic and spatial. Symbolic data is the sort of alphanumeric data commonly found in traditional \ndatabases, such as patient accounting information, or employee records. Spatial data, on the other hand, \nconsists of geometric information, such as maps, images and their contents, or three-dimensional anatomical \nobjects. A traditional relational database stores information describing real world entities but is limited \nin the ways these entities can be represented and accessed. There exists a semantic gap between the user \ns representation of the world and the representation in the database. This gap is substantially narrowed \nthrough an object-oriented implementation that provides multiple layers of abstractions closely modeling \nthe user s world view. In this paper, we describe the development of a database to support three-dimensional \nimage reconstruction of structural biology using object-oriented technology. This application involves \nall of the stages of biomedical imaging mentioned above. The requirements of this system encompass many \nof the popular justifications for the application of object-oriented technology, such as non-standard \ndata types and complex composite data, but we also find advantage in the increased functionality obtained \nfor spatial relationship operations and access methods. We place particular attention to the implementation \nof the spatial data, its representation, operations, indexing, and queries. The current prototype consists \nof the Gemstone [GEMS901 object-oriented database running as a server on an IBM RS/6000 and Objectworks \nfor Smalltalk-v. 2.5 [PARC901 running on a Macintosh IIfx as the application interface. We based our \nselection of these tools on their prototyping capabilities, data impedance matching, and availability \nat the time the project was initiated. The organization of this paper is as follows: Section 2 provides \nthe background and context of the application domain. Section 3 describes the spatial data representation \nand operations of spatial relationship. Section 4 presents an object-oriented spatial index that augments \nthe vendor-supplied access to object sets. Section 5 describes spatial queries and how the application \nof object- oriented technology improves accuracy and precision in spatial search. Section 6 concludes \nwith a summary and discussion of future work. 2 BACKGROUND For a number of years, researchers in the \ndepartment of Biological Structures at the University of Washington have been developing and refining \nmethods for 3-D image reconstruction [STIMSS, PROT89, MCLE91] in which three-dimensional images of anatomical \nobjects are reconstructed from sets of ordered 2-D cross-sectional slices, somewhat like a loaf of sliced \nbread. The images and animations produced by these techniques reveal anatomical structures in ways never \nseen before and allow interactive manipulation of accurate quantified data in anatomy. The data acquisition \nprocess leading up to the 3-D reconstruction begins with various specimens prepared in ways that allow \nmillimeter-thin slices to be removed as images are acquired of each new surface. The objects of interest \nare then traced manually by professional anatomists for each image taken, similar to contour lines on \na map. These surface boundaries are labeled and digitized into computer-readable form for input to a \n3-D graphics editor where the data is edited and displayed as three-dimensional surface reconstructions. \nCurrently underway is a project to acquire data encompassing the entire human body, providing the foundation \nfor a distributed knowledge base of structural biology that will be used to solve problems in basic science, \nteaching, and clinical medicine [BRIN89]. Because anatomy is a fundamental framework upon which most \nof the basic medical sciences rest, a knowledge base of biological structure would have profound implications \nin many areas of medicine. A key aspect to the success of this system is the underlying management of \nthe exceptionally large amount of data, the complexity and structure of the data, and its relationships. \nThe organization of this data must also provide efficient symbolic as well as spatial access to the anatomical \nobjects. Symbolic access is retrieval based on attribute values such as, Select all images of the liver \ntaken after October 6, 1991, whereas spatial access is based on spatial properties such as, Select all \nobjects within 10 mm of the heart. Up to now, this data has been stored in flat files and organized in \na file directory hierarchy. While this has been adequate for relatively small sets of data, knowledge \nof the relevancy and structure of objects, as well as relationships among various objects, exists in \nthe minds and memories of the biologists rather than as an integrated part of the data itself and information \nretrieval does not go beyond simple filename lookup. This method of organization fails as the amount \nof data increases, the relationships become more complex, and access to the data more sophisticated. \nConventional relational database technology does not meet the needs of modern imaging applications, characterized \nby highly complex and structured data, multiple data types and relationships, and non-traditional database \nprocessing. It lacks adequate data models and poses a rigid table structure for the definition of the \nrelationships between data records, thus preventing efficient representation and access of spatial or \ncomplex data structures. We believe that an object-oriented database approach offers many advantages \nin supporting biomedical applications having spatial data. It shortens the semantic gap between real-world \nobjects and their corresponding abstractions and thus offers a more flexible model for dealing with complex \ndata, The data modeling capabilities provided by the object-oriented model make it possible to support \nnot only multiple types of images but also highly structured data such as graphics. Furthermore, the \nextensibility of an object-oriented database allows us to implement user-defined index structures which \nare essential in achieving adequate performance in spatial data access. 3 SPATIAL DATA Spatial data \ncan be defined as anything having a location in a given global space with zero size (point) or non-zero \nsize (occupies space). A spatial database, then, supports data structures for the representation of spatial \ndata, efficient spatial access capabilities, and may also support a subset of geometric operators on \nthe data [GUNT88]. Spatial data is found in many application areas including anatomy, solid modeling, \ngeography, computer aided design (CAD), robotics, and others. Anatomical objects make up the primary \ndata set for the structural biology database. Each three-dimensional object is described spatially in \nterms of its boundary. This information is obtained from a series of images taken of 2-D cross-sectional \nslices in which objects of interest are identified explicitly as ordered sets of points that trace their \ncontours. Each set of ordered 2-D contours describe an object in three dimensions. The relationship between \nthe original images, the 2-D contours, and the 3-D surface reconstruction is depicted in Figure 2. SurfaceImages \nContours Reconstruction Figure 2. Spatial data abstractions In an object-oriented implementation, the \ninternal representation is hidden and can be modified with minimal effect on the overall system. No matter \nwhich representation is used internally, the object interface reflects generalizations about all spatial \nobjects. For instance, each object is located at a point in space. All spatial objects, therefore, respond \nto the message requesting their location. Another generalization is that all spatial objects occupy a \nportion of space (a point having zero size). Because the description of the regions occupied by objects \ncan be arbitrarily complex, a common approximation of an object s extent is a bounding box, defined by \nan n-dimensional rectangle describing intervals in n dimensions that completely enclose the bounds of \nthe object. We represent spatial data types through a class hierarchy defining 3-D objects, shown in \nFigure 3. ThreeDObject (boundingBox) The generalizations of all 3-D objects are captured in the common \nsuperclass called ThreeDObject. Some of the basic attributes ThreeDObjects can be asked for include: \nboundary returned in various forms such as points, lines, contours, etc. bounding box defined as the \nminimum ThreeDBox containing all of the object s extent center defined as the center point of the object \ns hounding box location defined as the closest point of the object s hounding box to the origin surface \narea area of object s surface volume volume of object s hounds Each subclass of ThreeDObject may override \nthese basic methods and may have additional specialized attributes, ThreeDPolygons, for instance, are \nconfined to a plane and can therefore be asked for their area and perimeter; a ThreeDPolyline can answer \nits length and a ThreeDSphere can provide its radius. The basic 3-D anatomical object is called a Tube. \nA Tube has instance variables describing symbolic information and one instance variable describing spatial \ndata called contours that is an ordered collection of instances of the class Contour. As a subclass of \nThreeDPolygon, each Contour is defined by an ordered collection of ThreeDPoints and is associated with \nits Tube and Image that contains the original bitmap data. Besides the general-purpose polyhedra objects, \nother specialized 3-D object classes are defined that are useful for spatial queries: ThreeDBox, \\ ...)ThreeDPolyline, \nand ThreeDSphere. ThreeDBox ThreeDPolyline (origin, comer) (vertices) I ThreeDSphere (center, radius) \nImage (bitmap, contours) Figure 3. ThreeD ThreeDPolygon I Contour (tube, image) class hierarchy. The \nvarious D objects relationships relationships attributes that can be obtained from 3- are used in determining \nspatial between objects. The two basic spatial are intersection and containment between two objects. \nFor example, an object can determine whether it intersects or contains another object through the messages, \nintersects: aSpatialObject and contains: aSpatialObject, respectively. The argument to these messages, \naSpatiaZObject, can be any spatial object. Each class of spatial object may rely on a specific set of \ntests when determining its relationship with other spatial objects. A brute-force implementation of the \nintersects: method would be to first determine the type of object passed and then invoke the appropriate \nalgorithm for intersection test based on the argument type. For example, the intersects: method for the \nTube class would look like: intersects: aSpatialObject (aSpatialObject isKindOf: Tube) iffrue: [ . . \n. code to test for intersection with another Tube . . . I. (aSpatialObject isKindOf: ThreeDPolygon) \nifDue: [ . . . code to test for intersection with a ThreeDPolygon . . .]. (aSpatialObject isKindOf: ThreeDSphere) \nifTrue: [ . . . code to test for intersection with a ThreeDSphere . . . 1. . . . This, however, results \nin a lengthy case-like statement that is both inefficient and difficult to maintain for each type of \nspatial object in the system. For spatial relationship operations, we prefer to implement a double-dispatching \ntechnique, similar to that used in the Smalltalk- kernel classes for handling arithmetic operations among \nNumber subclasses [GOLD83]. In double-dispatching, the receiver object returns the result of sending \nthe argument object a more specific message with itself as the argument. It is a useful technique for \nefficiently choosing an algorithm based on the class of the argument of a message and the class of the \nreceiver. Using the previous example, the Tube intersects: method becomes: intersects: aSpatialObject \n*aSpatialObject intersectsTube: self  A complete implementation requires that all spatial object classes \nimplement an intersectsTube: method containing the appropriate code to test specifically for intersection \nwith a Tube object. The same would apply for other types of spatial objects. Double-dispatching provides \nsignificant speed at the expense of a large number of typed methods and makes it possible to send the \ngeneric intersects: message to all types of spatial objects. If the number of classes participating in \ndouble-dispatching becomes too large, other techniques can be incorporated, such as coercion [PARC90]. \nThe intersection relationship is commutative so double-dispatching simply reverses the arguments. However, \nthe containment relationship must be rephrased to an equivalent relationship when double-dispatching. \nFor instance, the contains: method would return the result of sending containedIn[seZfClassName] : self \nto the argument object. 4 SPATIAL ACCESS An important aspect of a database containing spatial information \nis providing efficient spatial access to objects. For large data sets, indices can aid the search process \nin order to obtain adequate performance. Retrieval of spatial objects in the database is based on symbolic \nand/or spatial properties. Current database systems support conventional indices, such as B-tree, ISAM, \nand hashing on simple data types, but do not provide spatial data indexing [ULLM88]. Spatial access, \nthen, is limited to linear iterative search across the entire collection of objects. An object-oriented \ndatabase, being extensible, allows us to construct a user-defined indexing structure using high-level \nobjects. An ideal solution would implement the index at a low level inside the database kernel as close \nto the disk activity as possible. Although implemented at a higher level than conventional indices, an \nobject- level index does offer several advantages. The database administrator has direct control and \ndesign of the index and it can be tuned for specific applications. If desired, the index can be easily \nreplaced if an improved index is found. Care must be taken, however, to see that the index maintains \nconsistency and operates as a built-in index would. A number of index structures for organizing spatial \ndata have been proposed. The most common consist of variations of hierarchical and bucket methods such \nas quad-trees, act-trees, k-d trees, k-d-B trees, grid files, RTrees, and cell trees [GUNT88]. Most methods \nare designed primarily for point data. Of those that support objects of non-zero size, we chose the RTree \nas the most suitable structure for the anatomical data because it readily supports extended objects, \nsuch as lines, regions, and volumes, it does not sub-divide objects, and does not restrict occupancy \nto fixed- grid cells. We have designed and implemented an object-oriented R*Tree [BECK901 spatial index. \nThe R*Tree, an enhanced variant of the original RTree [GUTT84], is in the family of spatial access methods \nthat are based on the approximation of complex spatial objects by their bounding boxes. This approximation \nmakes the R*Tree efficient in terms of both space and time because the information stored at each node \nin the tree consumes a limited number of bytes and simple rectangular regions can be compared quickly. \nThe R*Tree organizes spatial objects in a height- balanced tree structure by essentially grouping objects \ninto neighborhoods. Each tree has one root node; each node can have a maximum of A4 children. Leaf nodes \ncontain references to the actual spatial objects and intermediate nodes contain references to children \nnodes and a parent node. Each node also stores its own bounding box representing the total region covered \nby its children. Based on a high-level tree-structure, the R*Tree is inherently object-oriented. It \nlends itself well to data and behavior encapsulation and is designed to intermix spatial objects of multiple \ndimensions. The basic behavior of an R*Tree object is specified through the actions of insertion, deletion, \nand searching. Database objects are stored in the database in container objects, such as Sets or Bags, \nsimilar to the function of a relation storing records in a relational database. For spatial objects the \ncontainer class, IndexedSpatialSet, is defined that has two instance variables, objectset, an instance \nof Set that acts as the holder for all spatial objects inserted into the container, and spatiazlndex, \nan instance of R*Tree that provides spatial access to the set of objects. When an object is inserted \ninto an IndexedSpatialSet it is inserted into the objectset and the spatiallndex, where the objectset \norganizes objects based on a hashing method and the spatiallndex organizes them based on their spatial \nproperties. Deletion of objects occurs in a similar fashion. An IndexedSpatialSet, with its instance \nvariables, is depicted graphically in Figure 4. anIndexedSpatialSet yzG2-p Figure 4. An IndexedSpatialSet \n During insertion, the R*Tree object needs to know the bounding box of the object to be inserted, obtained \nthrough the boundingBox message. The R*Tree object need not be concerned with the type of spatial object \nit is inserting as long as the object responds appropriately to the boundingBox message. In fact, an \nn-dimensional R*Tree is able to accept a spatial object of n dimensions or lower since all comparisons \nbetween bounding boxes are done by the bounding box objects themselves which can handle differences in \ndimensionality.  5 SPATIAL QUERIES Spatial queries on objects are formulated in terms of spatial properties \nsuch as location and regions of occupancy. The two most common queries are: Object intersection query: \nGiven a spatial object S, find all objects, 0, where OfiS# 0 Object containment query: Two variations: \nGiven a spatial object S, find all objects, 0, where (1) S 2 0, and (2) 0 1 S Two problems encountered \nwith spatial search, accuracy of results and precision of query region, are related to the index structure. \nConventional implementations of non-point spatial indices cannot provide completely correct answers to \nspatial queries [OREN90]. Furthermore, each index structure imposes a restriction on the type of query \nregion that can be specified. Most methods, for example, allow for only a rectangular region parallel \nto the global object space coordinate axes. While this may be adequate for some applications, there is \noften a need to specify other types and more precise search regions. For instance, given a set of three-dimensional \nanatomical objects, a possible query might be, Find all objects inside the skull. Restricting the search \nregion to a rectangular cube makes it impossible to describe precisely the volume inside the skull. We \nhave shown that an object-oriented spatial index overcomes the problems of inaccuracy and precision of \nquery region [BENS91]. Spatial index search operations are inaccurate because they are each based on \nan approximation of the data objects (e.g., bounding box) so the accuracy of the search is only as good \nas the approximation. The object-oriented R*Tree returns completely accurate answers because each candidate \nobject, identified at the leaf node level, is interrogated as to whether or not it actually does fulfill \nthe search criteria rather than only its approximation. Secondly, through polymorphism and late binding, \nany arbitrary spatial object may be specified as the search region so that the precision of the query \ndepends only on the precision of the query object. The object-oriented R*Tree uses the query object s \nbounding box during the tree traversal but the final intersect or contain operation is performed with \nthe actual query object, thereby guaranteeing accurate results. The flexibility of the IndexedSpatialSet \nclass is seen in its ability to perform symbolic queries, spatial queries, or combined symbolic and spatial \nqueries. For purely symbolic queries, such as Find all objects with names between K and M 9 the query \nrequest is redirected to the objectset where the built-in accessing methods are utilized. For purely \nspatial queries, such as Find all objects intersecting object 0, the query request is redirected to the \nspatiallndex which is more efficient in finding objects spatially. Queries that combine symbolic and \nspatial predicates are more complicated. The current system relies on the spatial access for any queries \ncontaining spatial predicates. However, at the leaf nodes, when the actual objects are interrogated, \nthe symbolic predicates are checked before the final spatial requirements. This heuristic is based on \nexperience gained from testing various combinations of queries and appears to provide the best performance \nso far. Additional investigation is needed in query optimization for a more thorough solution to this \nproblem. We have constructed a very simple interface to experiment with spatial query concepts on a \ndata set of randomly generated two-dimensional objects. Figure 5 shows the layout of the query interface \nwith a set of 1000 spatial objects from classes we ve named City, Crop, Lake, River, and Road. Figure \n5. A simple spatial query interface The set of possible spatial query objects are displayed as drawing \ntool icons on the left-hand side as: rectangle, polygon, polyline, point, and circle. The two-dimensional \nsearch space is shown as a bitmap image (Smalltalk Form) containing all the objects in the data set. \nThis image can be scaled and scrolled in all directions within its window. Spatial and symbolic query \npredicates are specified on the right-hand side of the interface. Check boxes indicate inclusion/exclusion \nof the predicate in the query, currently combined only by the AND operator. Specific operations for each \ntype of predicate are selected through radio buttons. The set of objects returned by the query appear \nas a scrolling list in the lower right-hand comer of the interface. Spatial queries are formulated graphically. \nThe spatial query object is specified by selection of an appropriate drawing tool and is drawn directly \nin the search space, denoting its location and boundary. Figure 6 shows the result of executing a spatial \nintersect query with a polygon object. For purely spatial queries such as this example, the R*Tree index \nuses the bounding box of the polygon object during tree traversal but relies on the polygon query object \nitself to check the final spatial predicate. The objects returned are listed by name and are drawn in \nthe search space. Figure 6. All objects intersecting a polygon Combinations of spatial and symbolic \nqueries are formulated by checking multiple check boxes in the query predicate area. Figure 7 shows the \nresult of a query involving all four possible predicates. The query asks for instances of the class Lake \nthat are inside the circle object having names <= West and areas between 400 and 600. In this case, the \nR*Tree index uses the bounding box of the circle object during tree traversal. As each candidate object \nis found, the symbolic predicates are checked before the final spatial predicate using the circle query \nobject. Figure 7. Combination spatial and symbolic query Queries in an object-oriented database can be \ndone in many ways. As yet there does not exist an equivalent SQL-like declarative language for specifying \narbitrary queries. The Gemstone database includes the OPAL language, which closely resembles Smalltalk, \nfor data definition and data manipulation. In the current prototype we generate a Gemstone Block object \nfor symbolic predicates. This block is passed to the IndexedSpatialSet object in the database for evaluation. \nFor queries involving spatial and symbolic predicates, the block object is passed to the R*Tree where \nit is evaluated at the leaf node level.  6 SUMMARY &#38; FUTURE WORK In this paper, we have described \nthe development of a database to support three-dimensional image reconstruction of structural biology \nusing object-oriented technology. The application domain is characterized by multiple data types and \nmulti-levels of abstraction of data obtained from images. Much of this information is spatial data, so \nparticular attention was placed on the implementation of the spatial data, its representation, operations, \nindexing, and queries. We represent spatial data through the class hierarchy of three-dimensional objects. \nThe ThreeDObject class contains generalizations of all 3-D objects and serves as the superclass for \ncurrent and future specializations. We implement spatial relationship operations through double-dispatching \ntechniques that provide an efficient method of choosing appropriate algorithms based on the class of \nthe argument of a message and the class of the receiver. A container class for spatial objects was defined \nthat has two instance variables, a Set object that holds the spatial objects and provides access based \non symbolic attributes, and an R*Tree index object that provides efficient spatial access to the object \nset. We have shown how the object-oriented R*Tree extends the functionality of spatial indices through \naccuracy of query results and precision of query region. This was possible because of the object-oriented \nfeatures of polymorphism and late binding. Our work presented here accomplishes the framework for a database \nschema that outlines the representation, operations, and access methods for spatial objects and a spatial/symbolic \nquery interface. As a prototype, the current system is in its development stage and requires further \nrefinement before it can be integrated with the data acquisition and production system in Biological \nStructures. Once completed, it will have an impact on and improve the 3-D reconstruction efforts in Biological \nStructures by providing advanced data management capabilities with increased functionality and support \nfor spatial data. The spatial query examples shown in this paper were done with a set of two-dimensional \nobjects. Formulation of 3-D query objects will be accomplished through an enhancement to the 3-D editor \napplication currently in use [PROT89] to include support for arbitrary 3-D query object construction \nand connection to the database. The R*Tree spatial index is designed to support objects of any dimension \nso it requires no modifications. One path of research currently underway is the presentation of symbolic \nqueries in a more generalized fashion. The interface should be dynamic such that the choices presented \nreflect the set of instance variables in the scope of target objects. For instance, queries over all \nThreeDObjects can be formulated according to those instance variables common to all ThreeDObjects. However, \nif the query is narrowed to only Contour objects, then the predicate choices should include those variables \ncommon to all Contours. In this way, the presentation of query predicates can be generated as the query \nis formulated interactively. One observation we have regarding spatial queries is the proportion of time \nspent on computation of spatial relationships done by the objects compared to the time spent in traversal \nof the index. Intersection seems to be the most computationally intensive operation and appears to be \nthe bottleneck that overshadows the index search. As some spatial operations are hindered by the data \nrepresentation, we are looking at alternative representations, the roles they play in aiding spatial \noperations, and the feasibility of object conversions in the database.  ACKNOWLEDGEMENTS We wish to \nthank the 3D Reconstruction researchers in the Department of Biological Structures for their assistance \non the work presented here. We also wish to thank IBM for support provided through a Graduate Student \nFellowship awarded to the first author, and the W. M. Keck Foundation for initial support of this research. \n REFERENCES BECK90 N. Beckmann, H-P Kriegel, R. Schneider, B. Seeger. The R*Tree: An Efficient and Robust \nAccess Method for Points and Rectangles. Proceedings ACM-SIGMOD International Conference on the Management \nof Data, 322-33 1, 1990. BENS9 1 D. Benson, G. Zick. Obtaining Accuracy and Precision in Spatial Search. \nTechnical Report DEL-91 -01, Department of Electrical Engineering, University of Washington, 1991. BRIN89 \nJ. F. Brinkley, J. S. Prothero, J. W. Prothero, C. Rosse. A Framework for the Design of Knowledge-Based \nSystems in Structural Biology. Proceedings Thirteenth Annual Symposium on Computer Applications in Medical \nCare, IEEE Computer Society Press, 61-65, 1989. DUER83 A. J. Duerinckx, S. J. Dwyer. Guest Editors Introduction: \nDigital Picture Archiving and Communication Systems in Medicine. Computer, Vol. 16, No. 8, Special Issue \non Digital Image Archiving in Medicine, 14-16, August 1983. GEMS90 Gemstone Object-Oriented Database \nManagement System, Version 2.0, Servio Corporation, 1990. GOLD83 A. Goldberg, D. Robson. SmaZZtalk-80 \nThe Language and its Implementation. Addison-Wesley, 714 pgs., 1983. GUTT84 A. Gunman. R-Trees: A Dynamic \nIndex Structure for Spatial Searching. Proceedings ACM-SIGMOD International Conference on the Management \nof Data, 47-57, 1984. GijNT88 0. Gunther. Efficient Structures for Geometric Data Management, Lecture \nNotes in Computer Science 337, edited by G. Goos and J. Hartmanis, Springer Verlag, 1988. MCLE91 M. \nMcLean, J. Prothero. Three-dimensional reconstruction from serials sections. V. Calibration of dimensional \nchanges incurred during tissue preparation and data processing. Analytical &#38; Quantitative Cytology \nand Histology (in press), 1991. OREN J. Orenstein. A Comparison of Spatial Query Processing Techniques \nfor Native and Parameter Spaces. Proceedings ACM-SIGMOD International Conference on the Management of \nData, 343-352, 1990. PARC90 Objectworks for SmaIltalk-80, Version 2.5, ParcPlace Systems, Inc. 1990. \nPROT89 J. S. Prothero, J. W. Prothero. A software package in C for interactive 3-D reconstruction and \ndisplay of anatomical objects from serial section data. NCGA Conference Proceedings. 1:187-192, 1989. \nSTIM88 G. K. Stimac, J. W. Sundsten, J. S. Prothero, J. W. Prothero, R. Gerlach, R. Sorbonne. Three-dimensional \nContour Surfacing of the Skull, Face, and Brain from CT and MR Images and from Anatomic Sections. AJR \n15 1: 807-8 10, 1988. ULLM88 J. Ullman. Principles of Database and Knowledge-Base Systems, Vol. I. Computer \nScience Press, 1988. \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "Dan Benson", "author_profile_id": "81545184356", "affiliation": "Department of Electrical Engineering, FT-10, University of Washington/Seattle, WA", "person_id": "PP14166901", "email_address": "", "orcid_id": ""}, {"name": "Greg Zick", "author_profile_id": "81339541393", "affiliation": "Department of Electrical Engineering, FT-10, University of Washington/Seattle, WA", "person_id": "PP31102522", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117979", "year": "1991", "article_id": "117979", "conference": "OOPSLA", "title": "Symbolic and spatial database for structural biology", "url": "http://dl.acm.org/citation.cfm?id=117979"}