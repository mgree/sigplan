{"article_publication_date": "11-01-1991", "fulltext": "\n Equate: An Object-Oriented Constraint Solver Michael R. Wilk Computer Science Department, Cornell University \nIthaca, New York 14853 wilk@cs.cornell.edu Abstract This paper presents a constraint-solving method that \nobeys the principle of object encapsulation. Under this method, constraints are translated into procedures \nfor achieving constraint satisfaction. Neither the constraints nor their procedural trans-lations refer \ndirectly to an object s implementation; all object references are through the interfaces provided by \nclasses. Translation is performed using definite-clause backward chaining, a tech-nique borrowed from \nlogic programming. Because object classes guide the translation process, the method is applicable to \nobjects of all data types. Introduction Although computer programs for general constraint solving have \nexisted for thirty years, insufficient attention has been given incorporating such programs cations. \nIdeally, applications to adapt to the design of instead, constraint solvers to the problem of into real-world \nappli- should not be required the constraint solvers; should be designed to meet the needs of the applications. \nPermission to copy without fee all or part of this material is granted provided that the copies are not \nmade or distributed for direct commercial advantage, the ACM copyright title of the publication and its \ndate appear, and that copying is by permission of the Association Machinery. To copy otherwise, or to \nrepublish, and/or specific permission. c 1991 ACM 89791-446-5/9110010/0286...$1.50 notice and the notice \nis given for Computing requires a fee  Y . . . . . . BOX2 I/ areas equal Figure 1: Two boxes with constraints. \nConsider one application: a geometric figure editor. Rectangles in as objects called bozes. specification \nof the box a constraint solver to this editor are represented (Refer to Appendix A for a class.) The \neditor could use find arrangements of figures that meet certain conditions. Figure 1 shows a pair of \nboxes and two constraints: the boxes should be of equal area and their tops should coincide with the \nline y = 5. Let us compare two approaches to solving these constraints. The first uses a constraint solver \nthat returns a solution to a set of algebraic equations. OOPSLA 91, pp. 286-298 Let boxn.slot represent \nthe state variable of boxn with name slot. We could express our constraints as follows: Areas equal: \nbox1 .area = box2.area Box1 top at 5: boxl. bottom + box1 .height = 5 .O Box2 top at 5: box2 .bottom \n+ boxl.height = 5 .O Box1 area: boxl. area = box1 .width x boxl.height Box2 area: box2. area = box2 .width \nx box2,height Here is one solution: boxl.bottom = 0.0 box2.bottom = 4.0 boxl.width = 1.0 box2.width = \n5.0 boxi.height = 5.0 box2.height = 1.0 box1 .area = 5.0 box2. area = 5.0 Although the constraint solver \nprovided a solu- tion to the problem it was given, we still might question whether the solver was suitable \nfor our application. One complaint is its violation of ob- ject encapsulation. Encapsulation is the process \nof hiding all of the details of an object that do not contribute to its essential characteristics. In \nprac- tice, one hides the representation of an object, as well as the implementation of its methods. \n[Boo911 Encapsulation was first violated by the constraint expressions. We named state variables explicitly, \ndisclosing the representation of boxes. When refer- ring to the tops of the boxes we disclosed the imple- \nmentation of the method top. We also disclosed the formula used to maintain consistency between width, \nheight, and area. Encapsulation was also violated by the solution, which told us how to set individual \nstate variables. These variables should not be manipulated directly: boxes should be changed using the \ninterface pro- vided by the box class. In circumventing this inter- face one might inadvertently set \na state variable to an illegal value (such as giving a box negative width), or one might bypass a necessary \nside effect (such as triggering the redraw of an object). The fundamental problem with this constraint \nsolver is that it conforms more to mathemati- cal concepts than to any principles of program- ming, and \ncertainly not to principles of object- oriented programming. In contrast let us consider the Equate constraint \nsolver, designed with object-oriented programming in mind. This time con-straints are expressed in the \nlanguage of the objects: Areas equal: area(box1) = area(box2) Tops at 5: top(box1) = top(box2) = 5.0 \n Using some guidance provided by the box class, Equate could produce the following solution: move-to(box1, \nnil, 5.0-height(box1)); move-to(box2, nil, 5.0-height(box2)); scale(box2, (area(boxi)/height(box2))/width(box2), \n1.0); Instead of a set of variable assignments, here the solution is a program. The first instruction \nmoves box1 vertically so that its top is at y = 5; the sec-ond one does the same for box2; the third \nadjusts the width of box2 so that its area is equal to that of boxl. Execution of this program puts the \ntwo boxes in a state that satisfies the constraints. The solution obeys the principle of encapsulation: \nboxes are queried and modified using only the interface provided by the box class. This paper explains \nhow Equate is built. The next four sections describe the form of constraints and their solutions, the \nprocess of finding solutions, and the use of Equate within applications. An example is then presented \nin which Equate solves a set of overlapping constraints. The paper concludes with a review of related \nwork, some thoughts on future directions, and a few final observations. 2 Equate Defined The Equate \nconstraint solver takes as input a con-straint in the form of an equation: em = expcp2 where exppl and \nexpcp2 are programming language expressions1 . Equate produces as output a set of programs called solutions. \nAny solution executing successfully will cause the constraint to be satisfied without changing the value \nof exp2. Equate itself Examples in this paper are presented without reference to a specific programming \nlanguage. A working version of Equate is implemented in the Common Lisp Object System. does not satisfy \na constraint; it translates a declar- ative constraint into procedural solutions. Some examples: equation: \nx+y=z solution: x := 2 - Y solution: y := 2 -x equation: (x + y = 2) = true solution: x := 2 - Y solution: \ny := 2 -x solution: 2 :=x+y equation: left(box1) = left(box2) solution: move-to(box1, left(box2), nil) \n Because undecidable problems can easily be phrased as equations, Equate cannot always pro-vide solutions. \nIndeed, Equate may return no solutions even when there exist infinitely many. Although we cannot always \nexpect Equate to return solutions, the equational format does not limit con-straint expression. For example, \na request for pro-grams that generate counterexamples to Fermat s Last Theorem can be expressed as the \nequation: ( int?(a) A int?(b) A int?(c) A int?(n) A a>0 A b>O A c>O A n>2 A (a-n + b-n = c-n) ) = true \n 3 The Structure of Solutions A solution S is a program represented by a directed, acyclic graph (V, \nE). A vertex of S is called a step. Each step o; comprises both a goal G; and a corre-sponding instruction \n1; for achieving that goal. A solution is executed by performing the instructions according to a topological \nordering of the steps. The solution in Figure 2 has two possible exe-cution sequences: 11, Iz, 13 and \n12,1r, Is. Step v2 contains a special instruction fail-unless. Some solutions, like the one in this example, \nwork only under certain conditions; fail-unless aborts the solution when these conditions are not met. \nSolu-tions running to completion achieve the conjunction of their goals. For simplicity of presentation, \na solution is some- times shown as a list of its instructions in an order corresponding to one topological \nordering of steps. G2: b # 0 12: fail-unless b # 0 13: c := a/b Figure 2: A solution to (a = 3 A b*c \n= a) = true. 4 The Search for Solutions Equate s constraint-solving method can be summa-rized as follows: \ndecompose a large constraint into smaller constraints for which solutions are known, then combine those \nsolutions into a solution that satisfies the large constraint. Constraints are recur-sively decomposed \nusing definite-clause backward chaining, the search technique used in logic pro-gramming languages [Llo87] \nof which Prolog is the best-known example. 4.1 Rewrite Rules The search for solutions is guided by rewrite \nrules provided by object classes. These rules are simi-lar to the program clauses of logic programs. \nIn Equate rewrite rules serve two purposes: to pro-vide solutions to equations directly, and (when direct \nsolutions cannot be given) to convert equa-tions into equivalent sets of equations that are more easily \nsolved. Equate s simplification strategy is to rewrite an equation until its left-hand side is simple \nenough that a solution can be given directly. The form of a rewrite rule is A -B,; . . . ; B, (n L 1) \n where A is called the head and B,; . . . ; B, is called the body. To find a solution set for an equation \nE, Equate searches for rules whose heads match E. For each matching rule, a solution set is created by \nsynthesizing the solution sets generated from each B; in the body. The complete solution set for E is \nthe union of the solution sets created for each of these rules. Section 4.2 explains the process of solution \nset synthesis. The head of a rewrite rule is always in the form of an equation. Each B; in the body can \nbe in one of two forms: . An instruction. The solution set for an in-struction consists of a single solution \nof one step with that instruction. If the instruction is of the form fail-unless predicate then the \ngoal of the step is predicate; otherwise, the goal is E. . An equation. The solution set for an equation \nis found recursively. Let us look at some rewrite rules. right(boz) = ezp - left (boz) + uidth(boz) = \nezp This rule says that to get the coordinate of the right edge of a box to equal some value, it is suf- \nficient to get the sum of the coordinate of the left edge and the width to equal that value. em = ezp2 \n-fail-unless symbol?( ezpl) ; ezpl := expz This rule says that an assignment statement can be used to \ngive a symbol a particular value. abs(ezpl) = ezpcpa -fail-unless ezp2 2 0; fwl = exp2 This rule says \nthat to get the absolute value of one expression to equal the value of a second, if the value of the \nsecond expression is non-negative then it is enough to make the values of the two expres-sions equal. \nAppendix B contains more examples of rewrite rules. The search for solution sets is improved by con-stant \nfolding, in which constant expressions are replaced by their values. This is particularly important when \nthe predicate of a fail-unless instruction is a constant expression. If the value of the predicate is \ntrue, then the fail-unless instruction is superfluous and can be removed from any solution that contains \nit. If the value of the predicate is false, then the instruction causes any solution that contains it \nto abort, so that solution can be discarded.  4.2 Synthesizing Solution Sets So far we have discussed \nhow rewrite rules are used to break down an equation into instructions and simpler equations for which \nsolution sets are found. Now let us discuss how to synthesize these solution sets into a single solution \nset for the original equa-tion. The process is associative, so we need describe only the synthesis of \ntwo solution sets. Let w, s2, . . . , S,,,} be one set of solutions and let {Ti,T2,. . .,T,} b e another \nset of solutions. A join of two solutions is defined to be a solution that achieves all the goals in \nboth solutions. The synthesis of the two solution sets is the set of all joins of a solution from the \nfirst set with a solution from the second set. Using W as the join opera-tor, we can express the synthesis \nof the two solution sets as {Sj W Tk 1 15 j < m, 15 k 5 n}.  4.3 Computing a Join Let Sr = (VI, El) \nand S2 = (Vz, E2) be two solu-tions. To compute Sr W S2 = Ss = (V3, Es), first let Ss be a supergraph \nof Sr and Ss such that Vs = VI U V2 and Es = El U Ea. The construction is not yet complete. Whereas El \nand E2 guarantee that execution sequences achieve the respective goals of Si and S2, execu-tion sequences \ngiven by El U E2 may not achieve all the goals of Ss. Additional edges may need to be added to Ss to \nensure that all goals are protected during execution; that is, once achieved they stay achieved. A step \nv; with instruction 1i and goal Gi is said to dobber a step vi with instruction Ij and goal Gj if Gj \ndoes not hold after the execution sequence Ij, 1;. To protect each goal in Sa, Equate inserts into S \ns an edge from v; to vj for all steps vu; that might clobber step vj, forcing v; to execute before vi \nin any execution sequence. If the resulting graph is cyclic, then there is no topological ordering of \nsteps and the solution is discarded. Figure 3: S s is the join Equate concludes that a step ~i might \nclobber a step uj if I; writes to any memory location that is both read by Gj and read or written by \n1je The need for the first condition is clear: Gj can be made false only if 1; writes to a location used \nin its eval-uation. The need for the second condition is more subtle: if Ij is sure to make Gj hold, \nthen the values in locations not read or written by Ij are of no con-sequence. Figure 3 shows Sa as the \njoin of two solutions SI = &#38;,~2},{)> and SZ = (hd, b,22q))). Because 13 writes b and both Gr and \n11 read b, an edge from 113 to vr is included in Sa. Like-wise, edges from v2 to vs and from 212 to 214 \nare also included. Equate distinguishes two types of memory loca-tion, The first is a symbol, like a \nor x, for which the symbol itself provides its own unique identity. The other type of location is a state \nvariable. A unique identifier for the state variable of any object is a pair of the identity of that \nobject with the name of the state variable. Thus the state variable of box1 that stores its width is \nuniquely identified by (box1 ,width). of solutions Sr and Sz. 4.4 Location Rules To decide if one step \nmight clobber another, Equate must compute the locations read and written by expressions; that is, their \nread sets and write sets. It does so using location rules provided by object classes. Location rules \nare similar to rewrite rules, but the information returned is not a set of pro-grams but a set of locations. \nA few examples: read-set(ezpi * ezpa) - read-set (ezpcpl) U read-set (ezpz)  This rule says that the \nread set of expr * expcp2is the union of the read sets of exppl and expcpz. read-set(top(boz)) - requires \nbox? (boz) ; {(boz,bottom),(boz,height)}  This rule says that to be able to compute the read set of \ntop (box), boz must be an explicit box object: the read set cannot be computed if the value of box is \nknown only when the solution containing that expression is executed. Given that requirement, the locations \nread by top( boz) are the bottom and height of box. write-set(ezpr := ezpz) - requires symbol?(ezpl); \n {emI U write-set( ezpz) This rule says that the write set of the assignment statement ezpr : = expz, \nwhere expl is a symbol, includes expr as well as any locations written by exp2. write-set(scale(boz,sz,sy)) \n- requires box? (boz) ; if sz # 1.0 then {(boz,width)} U if sy # 1.0 then {(boz,height)} U if sz # 1.0 \nor sy # 1.0 then { (boz,area)} U write-set (sz) U write-set (sy) This rule says that the execution of \nscale( box,sx,sy) could change the value of (box, width) unless sx is the constant 1.0; like-wise for \n(box,height). Its execution could change the value of (box,area) unless both sx and sy are 1.0. It is \nunlikely that expressions sx or sy would write locations, but because they might we union in write-set \n(sx) and write-set (sy>.  4.5 The safe Function As Equate composes solutions to an equation em = exp2 \nit sometimes generates instructions that would change the value of expcpz while changing the value of \nexpcpl.Consider the symbol-assignment rule from Section 4.1. Applying the rule to the equation x = 2*x-l \ngenerates the incorrect solu-tion x := 2*x-l. The error is avoided because Equate discards any solutions \ncontaining instruc-tions that read and write the same location. This filtering frees the rule itself \nfrom having to pre-vent such instructions. (To solve equations like x = 2*x-l, rewrite rules for transforming \nlinear equations can be written.) Occasionally instructions that read and write the same location should \nbe permitted. Consider this ineffective rewrite rule: int?( ezp) = true - ev = floor(ezp) The rule says \nthat to get an expression exp to be an integer it is sufficient to make exp equal to the largest integer \nno larger than exp. Applying this rule to the equation int?(a) = true generates a := floor(a) which, \nalthough correct, would be discarded by Equate. The rule needs to tell Equate that changing exp to establish \nthe equality will not also change floor (exp) . It can do so by using the identity function safe for \nwhich there is the loca-tion rule: read-set(safe(ezp)) - 0 The correct rewrite rule is: int?( ezp) = \ntrue - ezp = safe(floor(ezp)) With this rule the equation int?(a> = true generates a := safe(floor(a)). \nThis looks to Equate like an instruction with an empty read set and therefore it would not be discarded. \ncalls to safe serve no purpose during the execution of solutions, so they vanish from instructions once \nread sets have been determined.  5 Using Equate Equate only transforms an equation into a set of solutions; \nthe application has the responsibility of managing constraints and executing solutions. This section \ndescribes how an application should accom-plish these tasks. 5.1 Adding and Removing Constraints When \nan application has several constraints to be solved, it should ask Equate for solutions to each, cache \nthose results, and then call Equate s rou-tine for synthesizing solution sets. This approach is more \nefficient than asking Equate to solve the conjunction of constraints directly: if an individual constraint \nis added or removed, only the synthesis needs to be recomputed.  5.2 Choosing a Solution Once a solution \nset for all the constraints has been created, the application must choose a solution from that set to \nexecute when it decides to sat-isfy the constraints. Although that choice may be application-specific, \nthere are some general guide-lines to follow. First, solutions with the fewest fail-unless instructions \nare preferable as they are perhaps most likely to run to completion. Solutions with no fail-unless instructions \nwill always succeed. Second, it may be desirable to avoid changing certain locations. For example, if \nthe user of the application has just issued a command that assigns values to some locations, solutions \nthat do not write to those locations should be favored; otherwise, a solution might simply undo the user \ns operation. Third, the execution time for each solution can be estimated by its apparent complexity. \nShorter, simpler solutions should obviously be favored. 5.3 Aborted Solutions A solution is executed \nby performing its instruc-tions according to a topological ordering of its steps. If the predicate of \na fail-unless instruction eval-uates to false then the solution aborts: no more instructions are executed, \nand a failure is signaled. When a solution aborts then in all likelihood the constraints have not been \nsatisfied. But because the solution has accessed objects using the proper interface, the objects themselves \nare always consis-tent. Depending on the application it may be pos-sible to try another solution immediately \nwithout rolling back the effects of the failed solution. It is sometimes desirable to restore the applica-tion \nto its state before a solution was attempted. Anticipating this, the application can copy out the values \nof all locations in the write set of a solution. If the solution aborts then these locations can be restored. \nIf all solutions fail, the application must some-how cope with a state where the constraints do not hold. \nThe user of the application might attempt to change the state to one from which a solution will run to \ncompletion. Alternatively, the user might be asked to remove or change constraints. areas eaual -12 - \ntouching I 10 BOX1 BOX3 aligned I e at 0 C space + f aligned at 0 aligned Figure 4: The constraints \non the arch.  6 A Final Example Let us examine the performance of Equate on a nontrivial example. Figure \n4 shows an arch com-posed of three boxes; eight constraints guarantee the arch is well-formed. The following \nequation expresses these constraints: ((left(box1) = left(box2) = 0.0) A (bottom(box1) = bottom(box3) \n= 0.0) A (height(box1) + height(box2) = 10.0) A (width(box2) = 12.0) A (top(box1) = bottom(box2) = top(box3)) \nA (right (box21 = right (boxd)) A (area(boxl) = area(box2) = area(box3)) A (right(box1) < left(box3))) \n= true Using the rules in Appendix B, Equate returns four solutions. The arch is highly constrained, \nso in each solution only one memory location remains fixed while the others are changed to satisfy the \nequation. The first solution fixes the height of boxl, the second fixes the height of box2, the third \nfixes the height of box3, and the fourth fixes the bottom of box2. Because of these fixed values, none \nof the solutions can succeed from every start state; for example, the first solution will fail if executed \nin a state where the height of box1 is greater than 10. Figure 5 shows an arch that already satisfies \nthe constraints. Let us change the arch, increasing the height of box2 from 2 to 2.5 as shown in Figure \n6. (The dashed line shows the height of box2 before the change.) The arch no longer has a height of 10, \nso let us choose a solution to reestablish the con-straints. The second solution does not write to loca- \ntion (box2 ,height), so we know that if we execute it our change to the height of box2 will remain. Here \nis that solution: fail-unless iO.O-height(box2) > 0.0; move-to(box1, 0.0, nil); move-to(box2, 0.0, nil); \nmove-to(boxi, nil, 0.0); move-to(box3, nil, 0.0); scale(box1, 1.0, (iO.O-height(box2))/height(boxl)); \nfail-unless top(boxl)-bottom(box3) > 0.0; scale(box2, 12.0/aidth(box2), 1.0); fail-unless area(box2)/height(boxl) \n> 0.0; move-to(box2, nil, top(box1)); scale(box3, 1.0, (top(boxl)-bottom(box3))/height(box3)); fail-unless \narea(box2)/height(box3) > 0.0; scale(box1, (area(box2)/height(boxl))/width(boxl), 1.0); scale(box3, (area(box2)/height(box3))/width(box3), \n1.0); move-to(box3, right(box2)-width(box3), nil); fail-unless (right(boxl)<left(box3)) = true; Execution \nof this solution gives us the arch shown in Figure 7. (The dashed lines show the arch in the state before \nthe solution was executed.) Any of the other three solutions would have succeeded, but would have merely \nreduced the height of box2 back to 2, restoring the arch to its state in Figure 5. Y A 10 8 0 3 9 12 \ns x Figure 5: The arch in its original state. Y t 10.5:------------: 8 z-0 3 9 12 x Figure 6: The arch \nafter changing its height. Y A -- --__------_ 10 7.5 ---1------. r--- I I I I I I I I I I I 1 I I 0 I \nI >X 4 8 12 Figure 7: The arch after executing the solution.  Related Work The constraint-solving \ntechnique most similar to Equate s is ThingLab s use of propagation of de-grees of freedom [Bor79]. ThingLab \nalso divides the constraint satisfaction process into two phases: a planning phase and a plan execution \nphase. (This approach had been taken in Sutherland s trail-blazing Sketchpad [Sut63].) But whereas Equate \ncomposes its solutions as constraints are declared, ThingLab composes its plans when objects are asked \nto change. ThingLab propagates degrees of freedom within a constraint graph by finding parts that have \nonly one constraint affecting them; Equate s better conflict detection (see Section 4.3) overcomes this \nlimitation, yielding more solutions. Borning later enhanced ThingLab by allowing con-straints of differing \nstrengths [B+87, B+89]. ThingLab II [MBFB89, FBMBSO] improved upon its predecessor by including an incremental \nplanning algorithm so that its constraint graphs need not be recomputed from scratch with each addition \nor removal of a constraint. Vander Zanden [Van881 provided an incremental planner for collec- tions of \nrequired constraints. Concurrent to the development of ThingLab were the studies of Steele and Sussman \n[SSSO, Ste80] on local propagation of values through hierarchi-cal constraint networks. Their systems \nfeature multiple views for high-level reasoning about net-works, the ability to retract assumptions that \nled to contradictions, efficient backtracking, and the generation of explanations. Other well-known con-straint \nsolvers include IDEAL [Van82], which type-sets graphics into documents by solving systems of slightly \nnonlinear equations; Magritte [Gos83], which uses algebraic techniques to eliminate cycles from constraint \ngraphs; and TK!Solver [KJ85], a commercial product for personal computers that solves sets of equations \nusing local propagation and relaxation. [Le188] contains a summary of these and other systems, including \nLeler s own system Bertrand. Among constraint solvers, Equate is unique in its use of location rules \nto determine con-flicts in solutions. Some concepts in Equate (goal clobbering, back-ward chaining, fail \nconditions, solution graphs) have parallels in planning, a highly-studied subfield of artificial intelligence. \nPlanning is the process of finding a sequence of actions that a robot (or some other agent) can take \nto accomplish a pre-specified goal. HACKER [Sus73] introduced a sub-goal protection technique to assure \nthe satisfac-tion of conjunctive goals when combining plans. WARPLAN [War741 was the first Prolog planner; \nits successor WARPLAN-c [War761 generates plans with conditional branches. NOAH [Sac751 was the first \nnonlinear planner, where a plan is represented as a partial order on steps. [AHTSO] is a collection of \nmajor papers on planning. Equate s rules for transforming equations are similar to (but currently much \nsimpler than) those found in symbolic arithmetic systems. PRESS [BW81] is an equation solver implemented \nin Prolog that controls its algebraic manipulations with meta-level inference rules. MACSYMA [Sym89] \nand Math- ematica [Wo188] are well-known symbolic arith-metic packages. Logic programming has recently \nbeen extended to include constraint satisfaction [CohSO]. A theo- retical foundation for constraint logic \nprogramming has been presented by Jaffar and Lassez [JL87]. Prolog III [Co190] is an instance of the \ntheory. Constraint logic programming allows the inclusion of constraints in program clauses. Conjunctions \nof constraints are simplified using domain-specific constraint solvers, such as SL resolution for boolean \nformulas and Gaussian elimination or the simplex method for systems of linear equations and inequa-tions. \nAlthough constraint satisfaction is most often the search for a direct matching of values to vari-ables, \nsome studies have shown particular concern for encapsulation. [Tom891 describes difficulties with placing \nconstraints on encapsulated objects in a CAD system but offers no concrete solutions. Encapsulation comes \nnaturally to ThingLab, pri-marily because its constraints come from within class definitions and are \nnot arbitrarily imposed from outside. Apogee [HH88] is a user-interface management system that respects \nencapsulation, but it does not do true constraint solving because dependencies among objects are expressed \nprocedu-rally (and purely functionally) rather than declar-atively. [Bar86, SM88, Giu89] are other systems \nwith procedural dependencies. Future Directions Reducing search time. A direct implementation of the \nsearch method described in Section 4 is too inefficient for solving substantial constraint prob- lems. \nCurrently in development are heuristics for eliminating incompatible solutions sets before those sets \nare computed explicitly. Also in development is a scheme for representing large solution sets economically. \n Solution optimization. Before execution, solu-tions can be filtered so that they do not contain instructions \nfor satisfying constraints that have not been violated. Common subexpression elimination would also improve \nsolution efficiency. Smarter joining. The join algorithm could detect special conditions; for example, \nit should know that identical steps never clobber each other. More locations. Locations can be defined \nfor array and list elements, for example. Inexplicit references. Currently all constraints must refer \nto objects explicitly. One would like to be able to place a constraint on the largest box, where the \nidentity of that box is variable. Automatic rule generation. Using modern code-analysis techniques it \nis sometimes possible for the computer to generate location rules. Guarantee of termination. PRESS [BW81] \nguar-antees termination of its search by requiring each rule to reduce some numerical property of the \nexpression to which it is applied. Equate could support a similar requirement. The safe function. The \nuse of safe is some-what ad hoc ; an alternative is sought. Polymorphism. To allow for polymorphic func-tions \nit will be necessary to consider types when matching expressions to rules. Summary and Conclusions Equate \nwas created to provide an object-oriented paradigm for constraint programming. Equate respects the principle \nof object encapsulation in its constraints and solutions, easing the task of incorporating it into applications. \nBeyond respect-ing this principle, Equate has other advantages. Because each class provides the rules \nfor decom-posing and solving constraints placed on instances of that class, Equate is especially useful \nto appli-cations with heterogenous data. Because rewrite and location rules are kept separate from the \nmethods of an application, these methods do not need to be written in a special constraint language. \nBecause Equate produces procedural translations of constraint equations, the application can pick the \nappropriate time to reestablish constraints. The constraint-solving power of Equate depends on the rules \nprovided by object classes. Equate uses these rules to break a large constraint into smaller, solvable \nconstraints, then finds an ordering of solutions to these constraints that ensures that the effects of \none solution are not clobbered by another. Any constraint for which a solution method is known can be \nsolved using Equate, pro- vided that the constraint is in a form that can be matched to a rule for solving \nit. Finding solutions requires a considerable search. Fortunately, this is required only as constraints \nare declared. In most applications the constraints seldom change as the application is used. The need \nto reestablish constraints occurs much more frequently, and this requires only the choice and execution \nof a solution, not a lengthy analysis. Even when some constraints do change, the con-straints that remain \nunchanged do not require reanalysis. This paper has presented the basic principles of Equate. Before \nEquate will be ready as a fully-functioning constraint solver it will be necessary to resolve many of \nthe issues raised in Section 8. The prototype has performed well, so the outlook is promising.  Acknowledgements \nThanks to Paul Bay, Alan Borning, Roy Hall, John Hopcroft, Kevin Novins, Rick Palmer, and Len Wanger \nfor constructive comments on drafts of this paper. This work was supported by The Advanced Research Projects \nAgency of the Department of Defense under Office of Naval Research Contract N00014-88-K-0591, ONR Grant \nN00014-89-J-1946, and NSF Grant IRI-9006137.  Appendix A Y A box is an instance of BOX-CLASS. Each \nbox has the following state variables: LEFT, BOTTOM, WIDTH, HEIGHT, and AREA. Figure 8 shows a dia-gram \nof a box with its state variables indicated. These methods operate on boxes: left ( boz) bottom( boz) \nuidth( boz) height (boz) area( boz) returns the value of the appropriate state variable. right ( boz) \nreturns the value of LEFT + WIDTH. top( box) returns the value of BOTTOM + HEIGHT. move-to(boz,z,y) sets \nLEFT to x (unless z is nil) and sets BOTTOM to y (unless y is nil). scale( boz, sx, sy) scales WIDTH \nby the amount sz (if sx > 0) and HEIGHT by the amount sy (if sy > 0), then assigns AREA the product of \nWIDTH and HEIGHT. box? ( ezp) a predicate for testing if exp is a box. Appendix B Rewrite rules from \nBOX-CLASS: left(boz) = exp - move-to(box, ezp,nil) bottom(box) = exp - move-to( box,nil, exp) uidth( \nbox) = exp - fail-unless exp > 0.0; scale(box,exp/safe(uidth(box)),l.0) height(box) = exp - fail-unless \nexp > 0.0; scale(box,l.O,exp/safe(height(box))) area(box) = exp - width( box) = exp/height (boz) t \nc-WIDTH + f + LEFT --) AREA HEIGHT I t BOTTOM I >X Figure 8: The state variables of a box. area(box) \n= exp - height (box) = exp/width( boz) right( box) = exp - left( box) + width( box) = exp top(box) \n= exp -bottom(box) + height( box) = exp Some rewrite rules for numbers and booleans: (em + ezp2) = exp3 \n- expepl= exp3 -exp2 ( expl + exp2) = exp3 - exp2 = exp3 -expl (ezpl < exp2) = true - expcpl= exp2 \n-I .O (expl < exp2) = true - w2 = expl + 1.0 (em < exp2) = exp3 -fail-unless ( expl < exp2) = exp3 \n( ew A exp2) = exp3 - expl = exp3; exp2 = exp3 (expl = exp2) = true - em = ezp2 ( expl = exp2) = true \n- exp2 = ezpl  References [Gos83] J. Gosling. Algebraic Constraints. [AHTSO] [B+87] [B+89] [Bar861 [Boo911 \n[Bor79] [BW8i] [CohSO] [Co190] [FBMBSO] [Giu89 I J. Allen, J. Hendler, and A. Tate, editors. Readings \nin Planning. Mor-gan Kaufmann, San Mateo, California, 1990. A. Borning et al. Constraint hierar-chies. \nIn OOPSLA Conference Proceed-ings, Orlando, Florida, pages 48-60, October 1987. A. Borning et al. Constraint \nhierar-chies and logic programming. In Pro-ceedings of the Sixth International Con-ference on Logic Programming, \nLisbon, Portugal, pages 149-164, June 1989. P. S. Barth. An object-oriented ap-proach to graphical interfaces. \nACM Transactions on Graphics, 5(2):142-172, April 1986. G. Booth. Object Oriented Design with Applications. \nBenjamin/Cummings, Redwood City, California, 1991. A. Borning. ThingLab -a constraint-oriented simulation \nlaboratory. Tech-nical Report SSL-79-3, Xerox PARC, Palo Alto, California, July 1979. A. Bundy and B. \nWelham. Using meta-level inference for selective application of multiple rewrite rule sets in alge-braic \nmanipulation. Artificial Intelli-gence, 16:189-212, 1981. J. Cohen. Constraint logic program-ming languages. \nCommunications of the ACM, 33(7):52-68, July 1990. A. Colmerauer. An introduction to Pro-log III. Communications \nof the ACM, 33(7):69-90, July 1990. B. N. Freeman-Benson, J. Maloney, and A. Borning. An incremental \nconstraint solver. Communications of the ACM, 33(1):54-63, January 1990. D. Giuse. KR: constraint-based \nknowl-edge representation. Technical Report CMU-CS-89-142, Department of Com-puter Science, Carnegie-Mellon \nUniver-sity, Pittsburgh, Pennsylvania, April 1989. [HH88] [JL87] [KJ85 [Le188] [Llo87] [MBFB89] [Sac751 \n[SM88] [SSSO] PhD thesis, Department of Computer Science, Carnegie-Mellon University, Pittsburgh, Pennsylvania, \nMay 1983. T. R. Henry and S. E. Hudson. Using active data in a UIMS. In Proceedings of the ACM SIGGRAPH \nSymposium on User Interface Software, pages 167-178, Banff, Alberta, October 1988. J. Jaffar and J.-L. \nLassez. Constraint logic programming. In Conference Record of the Fourteenth Annual ACM Symposium on \nPrincipEes of Pro-gramming Languages, pages 111-119, Munich, West Germany, January 1987. M. Konopasek \nand S. Jayaraman. Con-straint and declarative languages for engineering applications: the TK!Solver contribution. \nProceedings ofthe IEEE, 73(12):1791-1806, December 1985. W. Leler. Constraint Programming Languages: \nTheir Specification and Generation. Addison-Wesley, Reading, Massachusetts, 1988. J. W. Lloyd. Foundations \nof Logic Programming. Springer-Verlag, Berlin, 1987. J. H. Maloney, A. Borning, and B. N. Freeman-Benson. \nConstraint technol-ogy for user-interface construction in ThingLab II. In OOPSLA Conference Proceedings, \nNew Orleans, Louisiana, pages 381-388, October 1989. E. D. Sacerdoti. The nonlinear nature of plans. \nIn Advance Papers of the Fourth International Joint Conference on Artificial Intelligence, pages 206-214, \nTbilisi, USSR, September 1975. P. A. Szekely and B. A. Myers. A user interface toolkit based on graphical \nobjects and constraints. In OOPSLA Conference Proceedings, San Diego, California, pages 36-45, September \n1988. G. J. Sussman and G. L. Steele Jr. CON-STRAINTS -a language for expressing almost-hierarchical \ndescriptions. Art+ cial Intelligence, 14:1-39, 1980. [Ste80] G. L. Steele Jr. The Definition and Implementation \nof a Computer Programming Language Based on Constraints. PhD thesis, Depart-ment of Electrical Engineering \nand Computer Science, M.I.T., Cambridge, Massachusetts, August 1980. [Sus73] G. J. Sussman. A Computational \nModel of Skill Acquisition. PhD the-sis, Artificial Intelligence Laboratory, M.I.T., Cambridge, Massachusetts, \nAu-gust 1973. [Sut63] I. E. Sutherland. Sketchpad: a man-machine graphical communication sys-tem. In \nProceedings of the AFIPS Spring Joint Computer Conference, pages 329-346, Detroit, Michigan, May 1963. \nPym891 Symbolics, Inc., Burlington, Massachu-setts. MACSYMA Reference Manual, 14th edition, 1989. [Tom891 \nT. Tomiyama. Object oriented pro-gramming paradigm for intelligent CAD systems. In Intelligent CAD Sys-tems \nII: Implementational Issues, pages 3-16. Springer-Verlag, Berlin, 1989. [Van821 C. J. Van Wyk. A high-level \nlanguage for specifying pictures. ACM Trans-actions 073 Graphics, 1(2):163-182, April 1982. [Van881 B. \nT. Vander Zanden. An incremental planning algorithm for ordering equa-tions in a multilinear system of \nconstraints. Technical Report 88-910, Department of Computer Science, Cornell University, Ithaca, New \nYork, April 1988. [War741 D. H. D. Warren. WARPLAN: a system for generating plans. Department of Computational \nLogic Memo 76, Univer- sity of Edinburgh, Scotland, June 1974. [War761 D. H. D. Warren. Generating condi-tional \nplans and programs. In Pro-ceedings of the AISB Summer Con-ference, pages 344-354, University of Edinburgh, \nScotland, 1976. [Wo188] S. Wolfram. Mathematics: A System for Doing Mathematics by Computer. Addison-Wesley, \nRedwood City, Cali-fornia, 1988.  \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "Michael R. Wilk", "author_profile_id": "81100270799", "affiliation": "Computer Science Department, Cornell University, Ithaca, New York", "person_id": "P199282", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117976", "year": "1991", "article_id": "117976", "conference": "OOPSLA", "title": "Equate: an object-oriented constraint solver", "url": "http://dl.acm.org/citation.cfm?id=117976"}