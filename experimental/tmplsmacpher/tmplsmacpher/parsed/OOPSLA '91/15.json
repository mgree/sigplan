{"article_publication_date": "11-01-1991", "fulltext": "\n TOWARDS A METRICS SUITE FOR OBJECT ORIENTED DESIGN Shyam R. Chidamber Chris F. Kemerer Sloan School \nof Massachusetts Institute Cambridge, ABSTRACT While software metrics are a generally desirable feature \nin the software management functions of project planning and project evaluation, they are of especial \nimportance with a new technology such as the object-oriented approach. This is due to the significant \nneed to train software engineers in generally accepted object-oriented principles. This paper presents \ntheoretical work that builds a suite of metrics for object-oriented design. In particular, these metrics \nare based upon measurement theory and are informed by the insights of experienced object-oriented software \ndevelopers. The proposed metrics are formally evaluated against a widely- accepted list of software metric \nevaluation criteria. I. INTRODUCTION In order for object-oriented software production to fulfill its \npromise in moving software development and maintenance from the current craft environment into something \nmore closely resembling conventional engineering, it will require measures or metrics of the process. \nWhile software metrics are a generally desirable feature in the software management functions of project \nplanning and project evaluation, they are of especial importance with a new technology such as the object-oriented \napproach. Permission to copy without fee all or part of this material is granted provided that the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that copying is by permission of the Association \nfor Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. \n o 1991 ACM 89791-446-5/91/0010/0197...$1.50 OOJ SJA !ill, Management of Technology MA 02139 This is \ndue to the significant need to train current and new software engineers in generally accepted object-oriented \nprinciples. This paper presents theoretical work that builds a suite of metrics for object-oriented design \n(OOD). In particular, these metrics are based upon measurement theory and are informed by the insights \nof experienced object-oriented software developers. The proposed metrics are evaluated against a widely-accepted \nlist of seven software metric evaluation criteria, and the formal results of this evaluation are presented. \nDevelopment and validation of software metrics is expected to provide a number of practical benefits. \nIn general, techniques that provide measures of the size and of the complexity of a software system can \nbe used to aid management in: -estimating the cost and schedule of future projects, -evaluating the productivity \nimpacts of new tools and techniques, -establishing productivity trends over time, -improving software \nquality, -forecasting future staffing needs, and -anticipating and reducing future maintenance requirements. \nMore specifically, given the relative newness of the 00 approach, metrics oriented towards 00 can aid \nin evaluating the degree of object orientation of an implementation as a learning tool for staff members \nwho are new to the approach. In addition, they may also eventually be useful ,- pp. 197-211 objective \ncriteria in setting design standards for an organization. This paper is organized as follows. Section \nII presents a very brief summary of the need for research in this area. Section III describes the theory \nunderlying the approach taken. Section IV presents the proposed metrics, and Section V presents Weyuker \ns list of software metric evaluation criteria [Weyuker, 19881. Section VI contains the results of the \nevaluation of the proposed metrics, and some concluding remarks are presented in Section VII.  II. RESEARCH \nPROBLEM There are two types of criticisms that can be applied to current software metrics. The first \ncategory are those criticisms that are leveled at conventional software metrics as they are applied to \nconventional, non-00 software design and development. These metrics are generally criticized for being \nwithout solid theoretical bases1 and for failing to display what might be termed normal predictable behavior \nweyuker, 19881. The second category is more specific to 00 design and development. The 00 approach centers \naround modeling the real world in terms of its objects, which is in stark contrast to older, more traditional \napproaches that emphasize a function- oriented view that separated data and procedures. Given the fundamentally \ndifferent notions inherent in these two views, it is not surprising to find that software metrics developed \nwith traditional methods in mind do not direct themselves to notions such as classes, inheritance, encapsulation \nand message passing. Therefore, given that current software metrics are subject to some general criticism \nand are easily seen as not supporting key 00 concepts, it seems appropriate to develop a set, or suite \nof new metrics especially designed to measure unique aspects of the 00 approach. lFor example, see [Vessey \nand Weber, 19841 and [Keamey, et al., 19861. Some early work has recognized the shortcomings of existing \nmetrics and the need for new metrics especially designed for 00. Some proposals are set out by Morris, \nalthough they are empirically suggested rather than theoretically driven [ 19881. Pfleeger also suggests \nthe need for new measures, and uses counts of objects and methods to develop and test a cost estimation \nmodel for 00 development [Pfleeger, 1989; Pfleeger and Palmer, 19901. Moreau and Dominick suggest three \nmetrics for 00 graphical information systems, but do not provide formal, testable definitions [ 19891. \nIn contrast, Lieberherr and his colleagues present a well-articulated, formal approach in documenting \nthe Law of DemeterTM [ 19881. Given the extant software metrics literature, the approach taken here is \nto develop theoretically-driven metrics that can be shown to offer desirable properties, and then choose \nthe most promising candidates for future empirical study. This paper is an initial presentation of six \ncandidate metrics specifically developed for measuring elements contributing to the size and complexity \nof object- oriented design. Since object design is considered to be a unique aspect of OOD, the proposed \nmetrics directly address this task. The metrics are constructed with a firm basis in theoretical concepts \nin measurement, while capturing empirical notions of software complexity.  III. THEORY BASED METRICS \nFOR OOD Booth (1986) defines object oriented design to be the process of identifying objects and their \nattributes, identifying operations suffered by and required of each object and establishing interfaces \nbetween objects. Design of classes involves three steps: 1) definition of objects, 2) attributes of objects \nand 3) communication between objects. Methods design involves defining procedures which implement the \nattributes and operations suffered by objects. Class design is therefore at a higher level of abstraction \nthan the traditional data/procedures approach (which is closer to methods design). It is the task of \nclass design that makes OOD different than data/procedure design [Taylor &#38; Hecht, 19901. The reader \nis referred to works by Deutsch, et al. [1983], Meyer [1988], Page, et aZ. [ 19891, Parnas, et al. [ \n19861, Seidewitz and Stark [1986] and others for an introduction to the fundamental concepts and terminology \nof object-oriented design. Figure 1 shows the fundamental elements of object oriented design as outlined \nby Booth [ 19861.  I obied I I Methods I f Object Attributesof Communication Definition Objects Among \nObjects Figure 1: Elements of Object Oriented Design Measurement theory base A design can be viewed as \na relational system, consisting of object elements, empirical relations and binary operations that can \nbe performed on the object elements. Notationally: design P = (A, RI... Rn,Ol...Om) where A is a set \nof object elements Rl...Rn are empirical relations on object elements A (e.g, bigger than, smaller than, \netc) Ol...Om are binary operations (e.g., concatenation) A useful way to conceptualize empirical relations \non a set of object elements in this context is to consider the measurement of complexity. A designer \nhas ideas about the complexity of different objects, as to which object is more complex than another. \nThis idea is defined as a viewpoint. The notion of a viewpoint was originally introduced to describe \nevaluation measures for information retrieval systems and is applied here to capture designer views [Chemiavsky, \n197 11. An empirical relation is the embodiment of a viewpoint. A viewpoint is a binary relation 2 defined \non the set P. For P, P , P E set P , the following axioms must hold: P 2 P (reflexivity) P 2 P or P \n2 P (completeness) P.2 P , PI.2 P => P.2 P (transitivity) i.e., a viewpoint must be of weak order [&#38;se, \n19871. To be able to measure something about a object design, the empirical relational system as defined \nabove needs to be transformed to a fomzal relational system [Roberts, 19791. Therefore, let a formal \nrelational system Q be defined as follows: Q E (C, Sl... Sn, bl... bm) C is a set of elements (e.g., \nreal numbers) S I... Sn areformal relations on C (e.g., >, C, =) bl... bm are binary operations (e.g., \n+,-,*) This is accomplished by a metric /J which maps an empirical system P to a formal system Q. For \nevery element a E P, p(a) E Q. Definitions The ontological basis principles proposed by Bunge in his \nTreatise on Basic Philosophy forms the basis of the concept of objects [Bunge, 19771. Consistent with \nthis ontology, objects are defined independent of implementation considerations and encompass the notions \nof encapsulation, independence and inheritance. According to this ontology, the world is viewed as composed \nof things, referred to as substantial individuals ,and concepts. The key notion is that substantial individuals \npossess properties. A property is a feature that a substantial individual possesses inherently. An observer \ncan assign features to an individual, these are attributes and not properties. All substantial individuals \npossess a finite set of properties. There are no bare individuals except in our imagination [Bunge, 19791. \nSome of the attributes of an individual will reflect its properties. Indeed, properties are recognized \nonly through attributes. A known property must have at least one attribute representing it. properties \ndo not exist on their own but are attached to individuals. On the other hand, individuals are not bundles \nof properties. A substantial individual and its properties collectively constitute an object [Wand, 1987; \nWand and Weber, 19901. An object can be represented in the following manner: X = <x, p(x)> where x is \nthe substantial individual and p(x) is the finite collection of its properties. x can be considered to \nbe the token or name by which the individual is represented in a system. In object oriented terminology, \nthe instance variables together with its methods are the properties of the object [Banerjee, et al., \n19871. Coupling Two things are coupled if and only if at least one of them acts upon the other [Wand, \n19901. X is said to act upon Y if the history of Y is affected by X, where history is defined as the \nchronologically ordered states that a thing traverses in time. let X = <x, p(x)> and Y = <y, p(y)> be \ntwo objects. P(X) = ( SX 1 u 1 IX 1 P(Y) = ( SY 1 u 1 Iy I where { Si ) is the set of methods and { Ii \n) is the set of instance variables of object i. Using the above definition of coupling, any action by \n(SX) on (Sy) or (Iy] constitutes coupling, as does any action by (Sy} on (SX) or (1~). Therefore, any \nevidence of a method of one object using methods or instance variables of another object constitutes \ncoupling. This is consistent with the law of Demete? [Lieberherr, et al., 19881. In order to promote \nencapsulation of objects it is generally considered good practice to reduce coupling between objects. \nCohesion Bunge [ 19771 defines similarity o() of two objects to be the intersection of the sets of properties \nof the two objects: WLY) =PC4 n p(y) Following this general principle of defining similarity in terms \nof sets, the degree of similarity of the methods within the object can be defined to be the intersection \nof the sets of instance variables that are used by the methods. It should be clearly understood that \ninstance variables are not properties of methods, but it makes intuitive sense that methods that operate \non the same instance variables have some degree of similarity. o(Ml,Mz...Mn) = ( Ml ) n ( M2 ) n ( M3 \n} . . . 1 Mn 1 where (T() = degree of similarity and { Mi ) = set of instance variables used by method \nMi. The degree of similarity of methods relates both to the conventional notion of cohesion in software \nengineering, (i.e., keeping related things together) as well as encapsulation of objects, that is, the \nbundling of methods and instance variables in an object. Cohesion of methods can be defined to be the \ndegree of similarity of methods. The higher the degree of similarity of methods, the greater the cohesiveness \nof the methods and the higher the degree of encapsulation of the object. Complexity of an object Bunge \ndefines complexity of an individual to be the numerosity of its composition , implying that a complex \nindividual has a large number of properties. Using this definition as a base, the complexity of an object \ncan be defined to be the cardinality of its set of properties. Complexity of <x, p(x)> = I p(x) I, where \nI p(x) I is the cardinality of p(x). Scope of Properties The scope of a property P in J ( a set of objects) \nis the subset G (P; J) of objects possessing the property. G(P; J) = ( x I x E J and P E p(x) ), where \np(x) is the set of all properties of all x E J. Wand defines a class on the basis of the notion of scope \n[ 19871. A class P with respect to a property set p is the set of all objects possessing all properties \nin p. C(P; J> = n all p ( G(P) I P E p(x) ) The inheritance hierarchy is a tree structure with classes \nas nodes, leaves and a root. Two useful concepts which relate to the inheritance hierarchy can be defined. \nThey are depth of inheritance of a class and the number of children of a class. Depth of Inheritance \n= height of the class in the inheritance tree The height of a node of a tree refers to the length of \nthe longest path from the node to the root of the tree. Number of Children = Number of immediate descendents \nof the class Both these concepts relate to the notion of scope of properties. i.e., how far does the \ninfluence of a property extend? The number of children and depth of inheritance collectively indicate \nthe genealogy of a class. Depth of inheritance indicates the extent to which the class is influenced \nby the properties of its ancestors and number of children indicates the potential impact on descendents. \nMethods as measures of communication In the object oriented approach, objects can communicate only through \nmessage passing. A message can cause an object to behave in a particular manner by invoking a particular \nmethod. Methods can be viewed as definitions of responses to possible messages [Banerjee, et al., 19871. \nIt is reasonable therefore to define a response set for an object in the following manner: Response set \nof an object = {set of all methods that can be invoked in response to a message to the object} Note that \nthis set will include methods outside the object as well, since methods within the object may call methods \nfrom other objects. The response set will be finite, since the properties of an object are finite and \nthere are a finite number of objects in a design. IV. THE CANDIDATE METRICS The candidate metrics outlined \nin this section were developed over a period of several months. This was done in conjunction with a team \nof software engineers in an organization which has used GGD in a number of different projects over the \npast four years. Though the primary development language for all projects at this site was C++, the aim \nwas to propose metrics that are not language specific. The viewpoints presented under each metric reflect \nthe object oriented design experiences of many of the engineers, and are presented here to convey the \nintuition behind each of the metrics. Metric 1: Weighted Methods Per Class WMC) Defmition: Consider \na Class Cl, with methods Ml,... Mn. Let Cl,... cn be the static complexity of the methods. Then WMC =2 \nCi. i=l If all static complexities are considered to be unity, WMC = n, the number of methods. Theoretical \nbasis: WMC relates directly to the definition of complexity of an object, since methods are properties \nof objects and complexity of an object is determined by the cardinality of its set of properties. The \nnumber of methods is, therefore, a measure of object definition as well as being attributes of an object, \nsince attributes correspond to properties. Viewpoints: The number of methods and the complexity of methods \ninvolved is an indicator of how much time and effort is required to develop and maintain the object. \nThe larger the number of methods in an object, the greater the potential impact on children, since children \nwill inherit all the methods defined in the object. Objects with large numbers of methods are likely \nto be more application specific, limiting the possibility of reuse. Metric 2: Depth of Inheritance Tree \n(DIT) Definition: Depth of inheritance of the class is the DIT metric for the class. Theoretical basis: \nDIT relates to the notion of scope of properties. DIT is a measure of how many ancestor classes can potentially \naffect this class. Viewpoints: The deeper a class is in the hierarchy, the greater the number of methods \nit is likely to inherit, making it more complex. Deeper trees constitute greater design complexity, since \nmore methods and classes are involved. It is useful to have a measure of how deep a particular class \nis in the hierarchy so that the class can be designed with reuse of inherited methods. Metric 3: Number \nof children (NOC) Definition: NOC = number of immediate subclasses subordinated to a class in the class \nhierarchy. Theoretical basis: NOC relates to the notion of scope of properties. It is a measure of how \nmany sub-classes are going to inherit the methods of the parent class. Viewpoints: Generally it is better \nto have depth than breadth in the class hierarchy, since it promotes reuse of methods through inheritance. \nIt is not good practice for all classes to have a standard number of sub-classes. Classes higher up in \nthe hierarchy should have more sub-classes than classes lower in the hierarchy. The number of children \ngives an idea of the potential influence a class has on the design. If a class has a large number of \nchildren, it may require more testing of the methods in that class. Metric 4: Coupling between objects \n(CBO) Definition: CBO for a class is a count of the number of non- inheritance related couples with other \nclasses. Theoretical basis: CBO relates to the notion that an object is coupled to another object if \ntwo objects act upon each other, i.e., methods of one use methods or instance variables of another. This \nis consistent with traditional definitions of coupling as measure of the degree of interdependence between \nmodules [Pressman, 19871. Viewpoints: Excessive coupling between objects outside of the inheritance hierarchy \nis detrimental to modular design and prevents reuse. The more independent an object is, the easier it \nis to reuse it in another application. Coupling is not associative, i.e., if A is coupled to B and B \nis coupled to C, this does not imply that C is coupled to A. In order to improve modularity and promote \nencapsulation, inter-object couples should be kept to a minimum. The larger the number of couples, the \nhigher the sensitivity to changes in other parts of the design and therefore maintenance is more difficult. \nA measure of coupling is useful to determine how complex the testing of various parts of a design are \nlikely to be. The higher the inter-object coupling, the more rigorous the testing needs to be. Metric \n5: Response For a Class (RFC) Definition: RFC = I RS I where RS is the response set for the class. Theoretical \nbasis: The response set for the class can be expressed as:  RS={Mi) Ualln(&#38;) where Mi = all methods \nin the class and ( Ri ) = set of methods called by Mi The response set is a set of methods available \nto the object and its cardinality is a measure of the attributes of an object. Since it specifically \nincludes methods called from outside the object, it is also a measure of communication between objects. \nViewpoints: If a large number of methods can be invoked in response to a message, the testing and debugging \nof the object becomes more complicated. The larger the number of methods that can be invoked from an \nobject, the greater the complexity of the object. The larger the number of possible methods that can \nbe invoked from outside the class, greater the level of understanding required on the part of the tester. \nA worst case value for possible responses will assist in appropriate allocation of testing time. Metric \n6: Lack of Cohesion in Methods (LCOM) Definition: Consider a Class Cl with methods Ml, Mz... , Mn. Let \n(Ii) = set of instance variables used by method Mi. There are n such sets (Il),... (In). LCOM = The \nnumber of disjoint sets formed by the intersection of the n sets. Theoretical basis: This uses the notion \nof degree of similarity of methods. The degree of similarity for the methods in class Cl is given by: \n  (JO = (11) n II2)... f-7 IIn) If there are no common instance variables, the degree of similarity \nis zero. However, this does not distinguish between the case where each of the methods operates on unique \nsets of instance variables and the case where only one method operates on a unique set of variables. \nThe number of disjoint sets provides a measure for the disparate nature of methods in the class. Fewer \ndisjoint sets implies greater similarity of methods. LCOM is intimately tied to the instance variables \nand methods of an object, and therefore is a measure of the attributes of an object. Viewpoints: Cohesiveness \nof methods within a class is desirable, since it promotes encapsulation of objects. Lack of cohesion \nimplies classes should probably be split into two or more sub-classes. Any measure of disparateness of \nmethods helps identify flaws in the design of classes. Low cohesion increases complexity, thereby increasing \nthe likelihood of errors during the development process. Summary The table below summarizes the six metrics \nin relation to the elements of OOD shown in figure 1. Metric Object Object Object Definition Attributes \nCommun- ication CBO 1 2 I ! Table 1: Mapping of Metrics to OOD Elements IV. METRICS EVALUATION PROPERTY \nLIST Weyuker has developed a list of desiderata for software metrics, and has evaluated a number of existing \nsoftware metrics using these properties weyuker, 19881. These properties are repeated below. Property \n1: Non-coarseness Given an object P and a metric p another object Q can always be found such that: I-@ \n) f I (Q). This implies that every object cannot have the same value for a metric, otherwise it has lost \nits value as a measurement. Property 2: Non-uniqueness (notion of equivalence) There can exist distinct \nobjects P and Q such that ~1 (P) = p(Q). This implies that two objects can have the same metric value, \ni.e. the two objects are equally complex. Property 3: Permutation is signijkant There exist objects P \nand Q such that if P is a permutation of Q (i.e., elements in P are simply a different ordering of the \nelements of Q) then p(P) f P(Q). Property 4: Implementation not function is important Suppose there \nare two object designs P and Q which perform the same function, this does not imply that p(P) = p.(Q). \nThe intuition behind Property 4 is that even though two object designs perform the same function, the \ndetails of the implementation matter in determining the object design s metric. Property 5: Monotonicity \nFor all objects P and Q, the following must hold: P(P) 2 W+Q) cl(Q) 5 M +Q) where P + Q implies concatenation \nof P and Q. This implies that objects are minimally zero, and therefore that the combination of two \nobjects can never be less than either of the component objects. Property 6: Non-equivalence of interaction \nGiven 3 P, 3 Q, 3 R, p(P) = p(Q) does not imply that p(P+R) = MQ+R). This implies that interaction between \nP and R can be different than interaction between Q and R. Property 7: Interaction increases complexity \n3 P and Q such that: The idea is that interaction between objects will tend to increase complexity. V. \nRESULTS: PROPERTIES OF THE CANDIDATE METRICS A design goal for all six metrics is their use in analysis \nof object oriented designs independent of the programming language.in which the application is written. \nHowever, there are some basic assumptions made regarding the distribution of objects, methods and instance \nvariables in the discussions for each of the metric properties. Assumntion 1: Let Xi = The number of \nmethods in a given class i. Yi = The number of methods called from a given method i. Zi = The number \nof instance variables used by a method i. Ci = The number of couplings between a given object i and all \nother objects. Xi, Yi, Zi, Ci are discrete random variables each characterized by some general distribution \nfunction. Further, all the Xis are independent and identically distributed. The same is true for all \nthe Yis, Zis and Cis. Assumution 2: Xi 2 1 i.e., each class contains one or more methods. Assumntion \n3: Two classes can have identical methods, in the sense that combination of the two classes into one \nclass would result in one of the methods being redundant. Assumution 4: The inheritance tree is full \ni.e., there is a root, several intermediate nodes which have siblings, and leaves. The tree is not balanced, \ni.e., each node does not necessarily have the same number of children. These assumptions while believed \nto be reasonable, are of course subject to future empirical test. Metric 1: Weighted Methods Per Class \nWMC) Let Xp = number of methods in class P and Xq = number of methods in class Q. Let y = probability \nXp # Xq , and (1 -y) = probability Xp = Xq As 0 c P < 1 from assumption 1, there is a finite probability \nthat 3 a Q such that p(P) # p(Q), therefore property 1 is satisfied. Similarly, 0 < 1 - y < 1, there \nis a finite probability that 3 a Q such that p(P) = p(Q). Therefore property 2 is satisfied. Permutation \nof elements inside the object does not alter the number of methods of the object. Therefore Property \n3 is not satisfied. The function of the object does not define the number of methods in a class. The \nchoice of methods is an implementation decision, therefore Property 4 is satisfied. Let p(P) = np and \np(Q) = nq, then p(P+Q) = np + nq. Clearly, p(P+Q) 2 p(P) and p.(P+Q) 2 p(Q), thereby satisfying property \n5. Now, let p(P) = n, p(Q) = n, 3 an object R such that it has a number of methods a in common with Q \nbut no methods in common with P. Let p(R) = r. p(P+R) = n + r p(Q+R)=n+r-a therefore p(P+Q) # p(Q+R) \nand property 6 is satisfied. For any two objects P and Q, p(P+Q) = np + nq - a, where np is the number \nof methods in P, q is number of methods in Q and P and Q have a methods in common. Clearly, np + nq -a \n5 np + nq for all P and Q. i.e., p.(P+Q) I p(P) + p(Q) for all P and Q. Therefore Property 7 is not satisfied. \n Metric 2: Depth of Inheritance Tree (DIT) Per assumption 4, every tree has a root and leaves. The depth \nof inheritance of a leaf is always greater than the root. Therefore, property 1 is satisfied. Also, since \nevery tree has at least some nodes with siblings, there will always exist at least two objects with \nthe same depth of inheritance, i.e., property 2 is satisfied. Permutation of the elements within an Case \nii) P &#38; Q are siblings object does not alter the position of the object in the inheritance tree, \nand therefore property 3 is not satisfied. Implementation of an object involves choosing what properties \nthe object must inherit in order to perform its function. In other words, depth of inheritance is implementation \ndependent, and property 4 is satisfied. When any two objects P &#38; Q are combined, there are three \npossible cases: i) when one is a child of the other: In this case, /-t(P) = p(Q) = n and l.t(P+Q) = \nn, i.e. Property 5 is satisfied. Case iii) P &#38; Q are not directly connected. In this case, p(P) = \nn, cl(Q) = n + 1, but l(P+Q) = n, i.e. p(P+Q) < l.r (Q). Property 5 is not satisfied. If P+Q moves to \nP s location in the tree, Q does cannot inherit methods from C, however if P+Q moves to Q s location, \nP maintains its inheritance. Therefore, P+Q will be in Q s old location. In this case, l.t(P) = x, p(y) \nand y > x. l.t(P+Q) = y, i.e., W+Q)> CL(P) and W+Q) = CL(Q>ad property 5 is satisfied. Since p(P+Q) 2 \np(P) is not satisfied for all possible cases, Property 5 is not satisfied. Let P and Q be siblings, i.e. \nb(P) = l.t.(Q)= n, and let R be a child of P. Then p(P+R) = n and p(Q+R) = n + 1. i.e. ~.L(P+R) is not \nequal to p(Q+R). Property 6 is satisfied. For any two objects P &#38; Q, p ( P+ Q) = p(P) or = p(Q). \nTherefore, l.t(P+Q) I p(P) + p(Q) i.e. Property 7 is not satisfied. Metric 3: Number Of Children (NOC) \nLet P and R be leaves, p(P) = CL(R)= 0, let Q be the root p(Q) > 0. l..t(P) # p(Q) therefore property \n1 is satisfied. Since p(R) = p.(P), Property 2 is also satisfied. Permutation of elements within an object \ndoes not change the number of children of that object, therefore Property 3 is not satisfied. Implementation \nof an object involves decisions on the scope of the methods declared within the object, i.e, the sub-classing \nfor the object. The number of sub-classes is therefore dependent upon implementation of the object. Therefore, \nproperty 4 is satisfied. Let P and Q be two objects with np and nq sub-classes respectively (i.e., p(P) \n= np and p(Q) = nq). Combining P and Q, will yield a single object with np + nq - a sub-classes, where \na is the number of children P and Q have in common. Clearly, a is 0 if either np or nq is 0. Now, np \n+ nq -a 2 np and np + nq -3 2 nq. This can be written as: p(P+Q) 2 /..t(P) and l.t(P+Q) 2 cl(Q) for all \nP and all Q. Therefore, Property 5 is satisfied. Let P and Q each have n children and R be a child of \nP which has r children. p(P) = n = cl(Q). The object obtained by combining P and R will have (n- 1) + \nr children, whereas an object obtained by combining Q and R will have n + r children, which means that \np(P+R) f p(Q+R). Therefore property 6 is satisfied. Given any two objects P and Q with np and nq children \nrespectively, the following relationship holds: p(P) = np and cl(Q) = nq. p(P+Q) = np + nq -a where a \nis the number of common children. Therefore, p(P+Q) < p(P) + p(Q) for all P and Q. Property 7 is not \nsatisfied. Metric 4: Response for a Class (RFC) Let Xp = RFC for class P Xq = RFC for class Q. Let y \n= probability Xp f Xq , (1 -y) = probability xp=xq Xp = F(Yi) and Xq = F(Yj) i.e., Xp is some function \nof the number of methods called by a method in class P. Now, F() is monotonic in Y, since the response \nset can only increase as the number of methods called increases. Yi and Yj are independent identically \ndistributed discrete random variables, as per assumption 1. Therefore, F(Yi) and F(Yj) are also discrete \nrandom variables that are i.i.d. Therefore, there is a finite probability that 3 a Q such that p,(P) \nf CL(Q) resulting in property 1 being satisfied. Also as 0 < 1 - y < 1 there is a finite probability \nthat 3 a Q such that p(P) = cl(Q), therefore property 2 is satisfied. Permutation of elements within \nan object does not change the number of methods called by that object, and therefore property 3 is not \nsatisfied. Implementation of an object involves decision about the methods that need to be called and \ntherefore Property 4 is satisfied. Let P and Q be two classes with RFC of P = np and RFC of Q = nq If \nthese two classes are combined to form one class, the response for that class will be the larger of \nthe two RFC values for P and Q j ~1 (P+Q) = Max(np, nq). Clearly, Max(np,nq) 2 np and Max(np,nq) 2 nq \nfor all possible P and Q. p(P+Q) 2 p(P) and 2 cl(Q) for all P and Q. Therefore, property 5 is satisfied. \nLet P, Q and R be three classes such that, p(P) = CL(Q)= n and CL(R)= r. Then p(P+Q) = Max(n,r) and l(Q+R) \n+ Max(n,r). i.e., p(P+Q) = p(R+Q). Therefore property 6 is not satisfied. For any two classes P and Q, \npL(P+Q) = Max~pO3, p(Q)). Clearly, Max@(P), p,(Q)) I p(P) + CL(Q) which means that Property 7 is not \nsatisfied. Metric 5: Lack Of Cohesion Of Methods (LCOM) Let Xp = LCOM for class P Xq = LCOM for class \nQ. Let y = probability Xp f Xq , (1 -y) = probability xp=xq Xp = F(Yi) and Xq = F(Yj) i.e., Xp is some \nfunction of the number of instance variables used by a method in class P. Now, F() is monotonic in Y, \nsince the LCOM can only decrease as the number of instance variables used increases. Yi and Yj are independent \nidentically distributed discrete random variables, as per assumption 1. Therefore, F(Yi) and F(Yj) are \nalso discrete random variables that are i.i.d. therefore property 1 is satisfied. Also as 0 < 1 - y c \n1. then there is a finite probability that 3 a Q such that CL(P) = p(Q), therefore property 2 is satisfied. \nPermutation of the elements of an object does not alter the set of methods called from that object, consequently \nnot changing the value of LCOM. Therefore, property 3 is not satisfied. The LCOM value depends on the \nconstruction of methods, which is implementation dependent, making LCOM also implementation dependent \nand satisfying property 4. Let P and Q be any two objects with CL(P) = np and k(Q) = nq. Combining these \ntwo objects can potentially reduce the number of disjoint sets. i.e., l..t(P+Q) = np + nq - 3 where a \nis the number of disjoint sets reduced due to the combination of P and Q. The reduction a is some function \nof the particular sets of instance variables of the two objects P and Q. Now, np 2 a and nq 2 a since \nthe reduction in sets obviously cannot be greater than the number of original sets. Therefore, the following \nresult holds: np + nq -3 2 np for all P and Q and np+nq-a>nqforallPandQ. Property 5 is satisfied. Let \nP and Q be two objects such that cl(P) = p,(Q) = n , and let R be another object with p(R) = r. p(P+Q) \n= n + r - a, similarly p(Q+R)=n+r-13 Given that a and 13 are not functions of n, they need not be equal. \ni.e., p(P+R) # p(Q+R), satisfying property 6. For any two objects P and Q, p(P+Q) = np + nq -a. i.e., \np(P+Q) = p(P) + p(Q) - a which implies that p(P+Q) I p(P) + p(Q) for all P and Q. Therefore property \n7 is not satisfied. Metric 6: Coupling Between Objects VW As per assumption 1, there exist objects P, \nQ and R such that p.(P) f p.(Q) and CL(P) = p(R) satisfying properties 1 and 2. Permutation of the elements \ninside an object does not change the number of inter-object couples, therefore property 3 is not satisfied. \nInter-object coupling occurs when methods of one object use methods or instance variables of another \nobject, i.e., coupling depends on the construction of methods. Therefore property 4 is satisfied. Let \nP and Q be any two objects with p,(P) = np and p(Q) = nq. If P and Q are combined, the resulting object \nwill have np + nq - 8 couples, where a is the number of couples reduced due to the combination. That \nis p(P+Q) = np + nq - a, where a is some function of the methods of P and Q. Clearly, np - 3 2 0 and \nnq - a 2 0 since the reduction in couples cannot be greater than the original number of couples. Therefore, \nnp+nq-a>npforallPandQand np+nq-aZnqforallPandQ i.e., l.t(P+Q) 2 l.t(P) and p(P+Q) 2 cl(Q) for all P and \nQ. Thus, property 5 is satisfied. Let P and Q be two objects such that p(P) = p(Q) = n , and let R be \nanother object with p(R) = r. p(P+Q) = n + r - 3, similarly p(Q+R)=n+r-l3 Given that a and 13 are not \nfunctions of n, they need not be equal, i.e., p(P+R) is not equal to l.t(Q+R), satisfying property 6. \nFor any two objects P and Q, I-W-Q) = np + q -a. l.t(P+Q) = p(P) + p(Q) - a which implies that p(P+Q) \nI p(P) + p-(Q) for all P and Q. Therefore property 7 is not satisfied. Summary of results All six metrics \nfail to meet property 3, suggesting that perhaps permutation of elements within an object is not significant. \nThe intuition behind this is that measurements on class design should not depend on ordering of elements \nwithin it, unlike program bodies where permutation of elements should yield different measurements reflecting \nthe nesting of if-then-else blocks. The rationale behind property 7 according to Weyuker is to allow \nfor the possibility of Summary increased complexity due to potential interaction weyuker, 19881. All \nsix metrics fail to meet this, suggesting that perhaps this is not applicable to object oriented designs. \nThis also raises the issue that complexity could increase, not reduce as a design is broken into more \nobjects. Further research in this area is needed to clarify this issue. The RFC metric fails to satisfy \nproperty 6 and the DIT metric fails to satisfy property 5. These deficiencies are a result of the definition \nof the two metrics and further refinements will be required to satisfy these properties. It is worth \npointing out that Harrison [1988] and Zuse [1991] have criticized the non-equivalence of interaction \nproperty (property 6) and note that this property may not be widely applicable. Also, the DIT metric, \nas shown earlier does not satisfy the monotonicity property (property 5) only in the case of combining \ntwo objects in different parts of the tree, which empirical research may demonstrate to be a rare occurrence. \nTable 2 presents a summary of the metrics properties. of Results Table 2: Summary of Metrics Properties \nVI. CONCLUDING REMARKS This research has developed a new set of software metrics for 00 design. These \nmetrics are based in measurement theory, and also reflect the viewpoints of experienced 00 software developers. \nIn evaluating these metrics against a set of standard criteria, they are found to both (a) perform relatively \nwell, and (b) suggest some ways in which the 00 approach may differ in terms of desirable or necessary \ndesign features from more traditional approaches. Clearly some future research designed both to extend \nthe current proposed metric set and to further investigate these apparent differences seems warranted. \nIn particular, this set of six proposed metrics is presented as a first attempt at development of formal \nmetrics for OOD. They are unlikely to be comprehensive, and further work could result in additions, changes \nand possible deletions from this suite. However, at a minimum, this proposal should lay the groundwork \nfor a formal language with which to describe metrics for OOD. In addition, these metrics may also serve \nas a generalized solution for other researchers to rely on when seeking to develop specialized metrics \nfor particular purposes or customized environments. Currently planned empirical research will attempt \nto validate these candidate metrics by measuring them on actual systems. In particular, a three-phased \napproach is planned. In Phase I, the metrics will be measured on a single pilot system. After this pilot \ntest, Phase II will consist of calculating the metrics for multiple systems and simultaneously collecting \nsome previously established metrics for purposes of comparison. These previously existing metrics could \ninclude such well-known measures as source lines of code, function points, cyclomatic complexity, software \nscience metrics, and fan-in/fan-out. Finally, Phase III of the research will involve collecting performance \ndata on multiple projects in order to determine the relative efficacy of these metrics in predicting \nmanagerially relevant performance indicators. It is often noted that 00 may hold some of the solutions \nto the software crisis. Further research in moving 00 development management towards a strong theoretical \nbase should provide a basis for significant future progress. REFERENCES Abbot, R. J. (1987). Knowledge \nAbstraction, Communications of the ACM, 30, 664-671. Banerjee, J., et al. (1987). Data Model Issues \nfor Object Oriented Applications, ACM Transactions on Ofice Information Systems, 5, January, 3-26. Booth, \nG. (1986). Object Oriented Development, IEEE Transactions on Software Engineering, SE-12, February, 211-221. \nBunge, M. (1977). Treatise on Basic Philosophy : Ontology I : The Furniture of the World. Boston, Riedel. \nBunge, M. (1979). Treatise on Basic Philosophy : Ontology II : The World of Systems. Boston, Riedel. \nChemiavsky, V. and D. G. Lakhuty (1971). On The Problem of Information System Evaluation, Automatic Documentation \nand Mathematical Linguistics, 4, 9-26. Cunningham, W. and K. Beck (1987). Constructing Abstractions for \nObject Oriented Applications , Computer Research Laboratory, Textronix Inc. Technical Report CR-87-25, \n1987. Deutsch, P. and A. Schiffman (1983). An Efficient Implementation of the Smalltalk- System, Conference \nrecord of the Tenth Annual ACM Symposium on the Principles of Programming Languages. Fenton, N. and A. \nMelton (1990). Deriving Structurally Based Software Measures, Journal of Systems and Software, 12, 177-187. \nHarrison, W. (1988). Software Science and Weyuker s Fifth Property , University of Portland Computer \nScience Department Internal Report 1988. Hecht, A. and D. Taylor (1990). Using CASE for Object Oriented \nDesign with C++, Computer Language, 7, November, Miller Freeman Publications, San Francisco, CA. Kearney, \nJ. K., et al. (1986). Software Complexity Measurement, Communications of the ACM, 29 (1 l), 1044-1050. \nLieberherr, K., et al. (1988). Object Oriented Programming : An Objective Sense of Style, Third Annual \nACM Conference on Object Oriented Meyer, B. (1988). Object Oriented Software Construction (Series in \nComputer Science). New York, Prentice Hall International. Moreau, D. R. and W. D. Dominick (1989). Object \nOriented Graphical Information Systems: Research Plan and Evaluation Metrics, Journal of Systems and \nSoftware, 10,23-28. Morris, K., (1988). Metrics for Object Oriented Software Development, unpublished \nMasters Thesis, M.I.T., Cambridge, MA. Page, T., et al. (1989). An Object Oriented Modelling Environment, \nProceedings of the Fourth Annual ACM Conference on Object Oriented Programming Systems, Languages ana \nApplications (OOPSLA). Parnas, D. L., et al. (1986). Enhancing Reusability with Information Hiding. Tutorial.- \nSoftware Reusability. P. Freeman, Ed., New York, IEEE Press. 83-90. Peterson, G. E. (1987). Tutorial: \nObject Oriented Computing. IEEE Computer Society Press. Pfleeger, S. L. (1989). A Model of Cost and Productivity \nfor Object Oriented Development , Contel Technology Center Technical Report. Pfleeger, S. L. and J. D. \nPalmer (1990). Software Estimation for Object Oriented Systems, Fall International Function Point Users \nGroup Conference. San Antonio, Texas, October l-4, 181-196. Pressman, R. S. (1987). Software Engineering: \nA Practioner s Approach. New York, McGraw Hill. Roberts, F. (1979). Encyclopedia of Mathematics and its \nApplications. Addison Wellesley Publishing Company. Seidewitz, E. and M. Stark (1986). Towards a General \nObject Oriented Software Development Methodology, First international Conference on the ADA Programming \nLanguage Applications for the NASA Space Station. D.4.6.1-D4.6.14. Vessey, I. and R. Weber (1984). Research \non Structured Programming: An Empiricist s Evaluation, IEEE Transactions on Software Engineering, SE-10 \n(4), 394-407. Wand , Y. and R. Weber (1990). An Ontological Model of an Information System, IEEE Transactions \non SofhYare Engineering, 16, N 11, November, 1282- 1292. Wand, Y. (1987). A Proposal for a Formal Model \nof Objects. Research Directions in Object Oriented Programming. Ed., Cambridge, MA, M.I.T. Press. 537-559. \n Weyuker, E. (1988). Evaluating Software Complexity Measures, IEEE Transactions on Software Engineering, \n14, No 9, September, 1357-1365.  Wybolt, N. (1990). Experiences with C++ and Object Oriented Software \nDevelopment, USENZX Association C+ + Conference Proceedings. San Francisco, CA. Zuse, H. (1991). Software \nComplexity: Measures and Methods. New York, Walter de Grutyer. Zuse, H. and P. Bollman (1987). Using \nMeasurement Theory to Describe the Properties and Scales of Static Software Complexity Metrics , I.B.M. \nResearch Center Technical Report RC 13504, August. \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "Shyam R. Chidamber", "author_profile_id": "81100361680", "affiliation": "Sloan School of Management, Massachusetts Institute of Technology, Cambridge, MA", "person_id": "P264892", "email_address": "", "orcid_id": ""}, {"name": "Chris F. Kemerer", "author_profile_id": "81100079220", "affiliation": "Sloan School of Management, Massachusetts Institute of Technology, Cambridge, MA", "person_id": "P46161", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117970", "year": "1991", "article_id": "117970", "conference": "OOPSLA", "title": "Towards a metrics suite for object oriented design", "url": "http://dl.acm.org/citation.cfm?id=117970"}