{"article_publication_date": "11-01-1991", "fulltext": "\n Object-Preserving Class Transformations Paul L. Bergstein Northea,stern University, College of Computer \nScience Cullina,ne Hall, 360 Huntington Ave., Boston IVIA 02115 pberg@corwin.CCS.northeastern.EDU Abstract \nReorganization of classes for object-oriented pro-gramming and object-oriented databa.se design ha,s \nrecently received considerable a.ttention in the lit-erature. In this paper a small set of primitive \ntransformations is presented which forms a.n or-thogonal ba,sis for object-preserving class reorgani-zations. \nThis set is proven to be correct, complet,e, and minimal. The primitive transforma.tions help form a \ntheoretical basis for cla.ss orgxlization and are a powerful tool for reasoning about particular organizations. \nKeywords: Object-oriented progra.mming and de- sign, object-oriented database design, class libra.ry \norganization.  Introduction Reorganization of cla.sses for object-oriented pro-gramming and object-oriented \ndata.ba.se design has recently received considerable attent.ion in t,he lit-erature: [BCG*W], [LBSSO], \n[LBS91]. [AHS$ [BMW%], [CasSS], [CasSO]! [LM91]! [Pi&#38;S], [PWS9]. A number of researchers ha.ve suggested \nalgorithms and hueristics to produce good ? clxs organizations. A good class organiza.tion ma.y be variously \ndefined as one which promotes efficient reuse of code, one with a. minimum of multiple-inheritance, a \nminimum of repeated-inlierita.Ilce: or some other chara.cteristics depending on the ~,II-thor s point \nof view. Permission to copy without fee all or part of this material is granted provided that the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that copying is by permission of the Association \nfor Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. \n@ 1991 ACM 89791~446-5/91/0010/0299...$1.50 In any case, it is usually desirable that reorga-nization \nof a$ class hierarchy should not cha.nge the set of objects which the classes define, that is the reorganization \nshould be object-preserving. For object-oriented da.taba.se design, this means tha.t the da.tabase does \nnot need to be repopula.ted. For object-oriented programming, this mea.ns tha,t pro- grams will st i11accept \nthe sa.me inputs and produce the same outputs. Furthermore, met,hods need not be rewritten (although \nthey may need to be at-tached to different cla.sses). In this paper a small set of primitive transforma-tions \nis presented which forms an 0rthogona.l basis for object-preserving class organizations. This set is \nproven to be correct, complete, and minimal. The primitive transformations help form a. theo-retical \nbasis for class orga.nization a.nd are useful in proving characteristics of particu1a.r orga.nizations. \nThe concept of a primitive set of object-preserving class tra.nsformations \\vas developed a,s part of \nthe Demeter project, to develop CASE tools for object-oriented design and programming. While t,lie cla.ss \nmodel used in this paper is the simplified one of [LBSSl], the Demeter System actua.lly uses an expanded \nnlodel Ivliicli includes optional pa,rts? collection (repetition) classes, and the ability t,o specify \nconcret,e synta.s used for pars-ing a.nd printing objects. Each notation has the advantage of being p \nrogramming la.ngua.ge inde-pendent and is t,herefore useful t,o programmers who use object-orieiikcl \nlangua,ges such as C++ [St,rSCi], Sma.lltalk [GRS3]> CJ,OS [BDG*SS] or Eif-fel [MeySS]. The C+$ Demeter \nSystem incoq)ora.tes a C++ OOPSLA 91, pp. 299-313 LawnMower Wheel Gas-tank Figure 1: Construction class \n code generation algorithm to translate the class definitions into C++ and generate methods for manipulating \nthe application objects (e.g. pars-ing, printing, copying, comparing? traversing, etc.). The primitive \ntransformations discussed in this pa-per were very helpful in developing and analyzing the latest additions \nto the Demeter System: tools for the abstraction of optimal class organizations from object examples, \nand for the optimization of e,xisting class organiza.tions [LBSSl] [BL91]. The second section provides \na brief description of the class notation. In section 3 the primitive transformations are presented along \nwith related proofs. In section 4 some practical rules for class hierarchy optimization, which can be \nbuilt from the primitive transformations, are given. Class notation The class notat.ion of [LBSSl] \nuses two kinds of cla.sses: construction a,nd alterna.tion classes. A construction class definition is \nan abstra.ction of a class definition in a typical st,atically typed pro-gramming langua.ge (e.g., C++). \nA construction class does not reveal implementa.tion informa.tion. Exa.mplcs of construction cla.sses \nare in Fig. 1 for: LawnMower, Wheel, etc. Ea.ch construction class defines a set of objects which can \nbe thought of as being elements of the direct product of the part classes. When model-ing an applica.tion \ndomain, it is natural t,o ta.ke the union of object sets defined by construct,ion classes. For esa.mple, \nthe motor of a lawn-mower can be ei-ther a gasoline engine or an electric motor. So the objects tl1a.t \nca,n be stored in the motor part of a. km Gasoline-Engine Figure 2: Alternation class  gb*&#38; /TELL \n c] &#38;LIMotor \\o DriveShaft Gasoline-Engi ne Figure 3: Common parts lawn-mower are either gasoline-engine \nor electric motor objects. Alternation classes a,re used to de-fine such union classes. An example of \na.n alterna-tion class is in Fig. 2. Gasoline-Engine and Electric are called alternatives of the alternation \ncla.ss. Of-ten the alternatives have some common parts. For example, each motor has a drive shaft. The \nno-tation in Fig. 3 is used to express such common parts. Alternation classes have their origin in the \nvariant records of Pasca,l. Beca.use of the delayed binding of function ca.lls to code in object-oriented \nprogramming, alternation classes a.re easier to use than variant records. Alternation classes which have \ncommon parts a.re implemented by inherita.nce. III Fig. 3: Electric and Gasoline-Engine inherit from \nMotor. Cla.ss Motor 1la.s methods and/or insta,nce variables to imple-ment the parts horsepower and shaft. \nConstruction and alternation classes correspond to the two basic data type constructions in deno-tational \nsemantics: Cartesian products and disjoint sums. They also correspond to the two ba.sic rnech-anisms \nused in formal langua.gcs: conca.tenation and alternation. The concept of a. part class which is used \nthroughout this paper needs further csplaIla.tion. A part object does not have to be a physical part; \nany attribute of an object is a part of it. Object 02 is said to be a part of object 01 if ol knows about \n02 . Therefore, the part-of relation is a gen-eralization of the aggregation relation which only describes \nphysical containment. For example, a car is part of a wheel if the wheel knows about the ca.r. Definition \n1 . A class dictionary graph 4 is a directed graph q4 = (V,iI; EC, EA) with finitely mnny vertices V. \nh is n fiyzile set of labels. There are two defining relations EC, EA. EC is Q ternary relatiol2 on \nI/ x I/ x A, culled the (labeled) con- struction edges: (v,w, 1) E EC <ff there is (1 con- struction \nedge with label I frown v to w. EA is c1 binary Telation on 1 X L, , crtlld the alternation edges: (II, \nw) E EA i,ff tl 2crc is nn altcwotion edge from v to w. Next, the set of vcrt,ices is partitioned into \ntwo sub-classes, called the construction and alt,ernation ver-tices. Definition 2 . . The construction \nvertices rare defined by VC = {v 1 v E V>t w E V : (u, w) @ EA}. I12 other words, the ~~0ilstruction \nvertices have no outgoing alternotion eclg6.s. Soiiietimcs, it. is more conveliient to tltscrih a class \ndicti0iia.q graph as a tuple which coli-t,ains explicit references to \\,,.C illld \\; /I: ci = (T C> VA, \nA; EC. EA). The tlefinit.ioll of a clash dicliona.ry graph is mo-tivat,ctl by the interpreta.tion iIr \nol)ject,-oriented de-sign given in Figure 4. During t.he progralnniing process, the aJi,erllatioll classes \nserve lo define in-terfaces (i.P.> they serve tire role of types) and the construction classes serv( \nt 0 l)rovidt> implement,a-t,iollh for i.hc int,erfaces. GraDh 1 Obiect-oriented design Vertex Class construction \ninstantiable alternation I abstract E@sze I Class relationship construction y&#38;$ rc;lgr;;pip I labels \nk-e Dart n ames alternation I inheritance relationship s ecialization, c assification P Figure 4: Standard \nInterpretation The standa.rd interpretation implies that the la.-bcls on construction vertices are significa.nt. \nCoIi-sider t\\vo class dictionary graphs ea.ch with only a. single construction vertes and no edges. From \na gra.ph theoretic point of view, the graphs are equal regardless of the labels on the vertices, but \nif the construction vertex of one gra.ph is labeled Integer and the vertex of the other graph is labeled \nString, then the two class dictionary graphs define different sets of objects in the standard interpretation. \nSince the mapping from construction vertices to labels is a bijection, its explicit inclusion in the \ndefi-nition of class dictionary graphs would only clutter the theory. When referring to a.n element of \nthe construction vertices of a class dictiona.ry graph, the reference is sometimes to a vertex and some-t,imcs \nto the label of a vertex. The meaning should be c1ea.r from the context. The following graphical notation \nj based OII ['YYFEXj], is used for drawing class dictionary gra.phs: squares for construct,ion vertices, \nhexagons for alterna.tion vertices, thin lines for const,ruction ctlgcs and double lines for alternation \nedges. Example 1 Fig. 5 shows a clnss dictioncrry grcrph for telepho72es. Telephones CGU either be si,nnrlrtrd \nor cordlrss and they also can be either rotary dial or touch-ione. Cordless phones halve nn anterzrzn \nwhile ~~tcr~,rlwlYlpl1or1es hmr (1. linrlrl.wl~ cord. me dialer on a lourh-lorjc phone i.3 II, keypad, \n~idie7ws 0 r~otury Definition 4 A class dictionary graph C$ = (I/ : *A; EC, EA) is legal if it satisfies \nthe follow- ing two axioms: dial phone hns a dial. For fbther illwtration components of the formal dqfinition \nare given, V = { Telephone, Cordless, Standard, Antenna, Handset-Cord, Dialer, Rotary, Dial, TouchTone, \nKeypad ) the i.e.: Unique labels uziom: vu, v, v , 70, wf E v, 1 E A such thnf v 3 11, ?I s u, u11d (V~lC) \nf (71 ,w ) {(?I, w, I), (,U > ,W > 1)) g EC : VC = ( Cordless, Standard, Handset-Cord, Rotary, TouchTone, \nKeypad 3 Antenna, Dial, VA = ( Telephone, Dialer ) EC = ( (Telephone, Dialer, dialer), (Rotary, Dial, \ndial), (TouchTone, Keypad, dial), (Cordless, Antenna, ant), (Standard, Handset-Cord, cord) 1 EA = ( (Telephone, \nCordless), (Telephone, Standard), (Dialer, Rotary), (Dialer, TouchTone) 1 A = {dialer, ant, cord, dial \n). 1. Cycle-free crlt~~~72ationaxiom: There are I?(J cyclic nlternation pnths, i.e.: { (71, w) 1 v, \nw E 11, 71 # II!, and 21 3 7l =s ?I} = 0. Cordless d Standard   ant CoKi I I Antenna Handset-Cord \nFigure 5: Intuit,ively, two class dictionary graphs are object-equivalent if they define sets of correspond-ing \nconstruction classes with the same names, and for each construction class defined by one class dic-tionary \ngraph the parts are the same as those de-fined for the corresponding class in the other class dictionary \ngraph. Example 2 Th,e two class dictionary graphs in Fig. 6, 41 and 42, are ob.ject-equivalent since: \nlfC(p, = VC~, = {Undergrad, Grad, Prof, TA, Adminasst, Coach, Num, Real-Num} PartCl~usters+, (Undergrad) \n= PartCluster.s~, (Undergrad) = {(ssn, {Num}), (gpa, {Real-Num})} PudC luster-sd, (Grad) = PartC /usfers~, \n(Grad) = {(ssn, {Num}), (gpa, {Real-Num})} PartClusters,f,l (TA) = PnrtClwterq,, (TA) = {(ssn, { Num}), \n(salary, { Real-Num}), (assigned, {Course, Committee})} PnrtCI~uster.~~,l (Profj = PartClustel.sd,( Prof) \n = {(ssn, {Num}), (salary, {Real-Num}), (assigned, {Course, Committee})} 303 k. dia1 q-J TouchTone Keypad \n Telephones PartClustersd, (Admin-asst) = PartClusters4, (Admin-asst) = {(ssn, { Num}), (salary, { Real-Num})} \nPa~rtClusters~, (Coach) = PartClusters4, (Coach) = {(ssn, {Num}), (salary, {Real-Num})} PartClusters~, \n(Course) = PartClustersb, (Course) = 0 Pa7dClusters~, (Committee) = PartClusters+, (Committee) = 0 PartClu.sters#, \n(Real-Num) = Pnrtclt~sters&#38;, (Real-Num) = 0 PartClusters~, (Num) = PnrtClwstersg,(Num) = fl Definition \n6 A class dictiolzary g~~rph transfor- ination; T, is a rule which cle,fines nn allowdle nzodi,fication \nof class dictiorzary graphs. Le2 RT = {(&#38;! 42) / 4.2 cm be obtained fro712 41 by a sirqle application \nof T}. Then T is called object-preserving if ~$1 is Object-equiwlent to $2 fO1' all (&#38;,&#38;) E IiT. \n3.1 Priinitive Transforinations The following five primitive tra.nsformations form an ort1~ogona.l basis \nfor object,-preserving transfer-mations: <niv-employee &#38;--pa~i?jgfyc~\\ El 0 rlrlrl r-l Undergrad \nGrad TA Prof Abmin Czh asst \\ I Course cl Committee 0 (a) Class Dictionary Graph Q1 Occupation (b) \nClass Dictionary Graph $2 1. Deletion of useless alternation. An al-classes then the defined objects \ndo not change ternation vertex is useless if it has no incom-when Cl is replaced by C2 in a part definition. \ning edges and no outgoing construction edges. If an alternation vertex is useless it may be The set of \nprimitive object-preserving transfor- deleted along with it s outgoing alternation mation given in this \nsection is correct, i.e. any edges. sequence of primitive transformations preserves object-equivalence; \ncomplete, i.e. for any two Intuitively, an alternation vertex is useless if object-equivalent class dictionary \ngraphs, #Q, &#38;, it is not a part of a,ny construction class, and there is a. sequence of primitive \noperations which it has no parts for any construction class to transforms 41 to 42; and minimal, i.e. \nnone of theinherit. primitive transformations can be derived from any 2. Addition of useless alternation. \nAn al-set of the others. ternation vertex, v, can be added along with 3.2 Proofs outgoing alternation \nedges to any set of ver- tices already in the class dictionary graph. 3.2.1 Correctness This is the inverse \nof transformation 1. Each primitive operatibn preserves object- 3. Abstraction of common parts. If 3v, \nw, 1 equivalence. such that Vu , where (72, .I! ) E EA : ( u , w, I) E  3.2.2 Completeness EC, then \na,11 of the edges, (v , w,I), can be Given two object-equivalent class dictiona.ry deleted and replaced \nlvith a new construction graphs, 41 and 42, 41 can be transformed to $2 edge, (.u, w, 1). using only \nprimitive operations as follows: Intuitively, if all of the immediate subclasses of class C have the \nsame part, that part can  1. Use primitive operation 2 (addition of useless be moved up the inheritance \nhiera.rchy so that alternation) to superimpose the alternation ea.&#38; of the subcla.sses will inherit \nthe part from subgraph of 42 onto &#38;. C, rather than duplicating the part in each Since there are \nno alterna.tion cycles in 42, subclass. there must be some 2) E VA$, with outgoing 4. Distribution of \ncommon parts. An outgo- alternation edges only to construction vertices ing construction edge, ( u, w,I) \ncan be deleted (if there are any alternation vertices a.t all). from an a.lt,ernation vert,ex, ?I, if \nfor each For each such alternation vertex, add a new (u, 2) ) E EA a, new construction edge, (v , 10, \nI) alternation vertex to 41 with alternation edges is added. to the corresponding construction vertices. \nThis is the inverse of transformation 3. Now continue adding new alternatipn vert,ices corresponding \nto a.lternation vertices in $2 5. Part replacement. If the set of construc-that have outgoing alterna.tion \nedges only t,otion vertices which a.re alternation-reacha.ble construction vertices and alternation vert,icesfrom \nsome vertex, v E V, is equal to the set which have already been added in C;l until all of construction \nvertices a.lterna,tion-reachable the alternation vertices in 42 a.re duplicated in from another vertex, \n%: E V, t,hen any con- struction edge (PO,V:,~) E EC can be deleted 41. a.nd replaced with a new construction \nedge, 2. Use primitive operation 4 (distribution of com-( 10, v , I). mon parts) to remove the outgoing \nconstruc-Intuitively, if two class Cl and C2 have the tion edges from all of the 0rigina.l alt,ernation \nsame set of inst.a.nt.ial)le (construction) sub vertices in ~5,. Distribution of common parts is applied \nre-peatedly until all of the parts are attached di-rectly to construction vertices. 3 Use primitive \noperation 3 (abstraction of com-mon parts) to move construction edges up the new inheritance hierarchy \nin 41 until they are all atta.ched to vertices corresponding to the vertices where they are attached \nin 42. This must be possible since $1 a.nd 42 are object-equivalent. At this point ~$1 and 42 have the \nsame num-ber of construction edges and the construc-tion edges have the same labels and the same sources, \nbut may have different targets. 4. Use primitive number 5 (pa.rt replacement,) to move any const.ruction \nedge 1vit.h a.n old al-ternation vertex or construction vertex a.s its ta.rget so that its ta.rget corresponds \nto the proper verbes in ~$2. 5. Use primitive transforma.tion 1 (deletion of useless alternation) to \ndelete the old alter-nation subgraph from $1. At this point there are no construction edges (either incoming \nor outgoing) attached to any of the old alter-nation vertices. i\\lso, since there a.re no cycles in the \nold alternation subgraph, a,nd since we have not added any edges from new alter-nation vertices to old \nalterna.tion vertices or vice versa, at least one of the old a.lterna.-tion vertices must be useless \n(if there a.re any a.t all). After deleting t,ha.t useless a.l-terna.tion vcrt.ex t,he condition still \nholds, so we can cont,inue delet,ing the old alterna.tion vertices unt.il there a.re none left.   3.2.3 \nMinirnality No primitive transformation can be derived from a,ny set, of the ot,hers since: 0 No sequence \nof primitive opera.tions can re-duce the number of alternat,ion vertices with-out deletion of useless \na.lterna.t.ions. . No sequence of primitive operations can in-crease the number of alternation vertices \nwith-out addition of useless alternations. . No sequence of primitive operations can re-duce the number \nof construction edges without abstraction of common parts. . No sequence of primitive operations can \nin-crea.se the number of construction edges with-out distribution of common parts. . No sequence of \nprimitive operations can change the construction edge in-degree of a vert,ex from 0 to 1 or from 1 to \n0 without part replacement. Example 3 This example illustrutes the construc-tion of the completeness \nproof with the class dic-tionnry graphs of Figure 6. Note that ulthough the labels on construction vertices \nare significant, the labels on the alternation vertices nre only provided as a means of ,referring to \nparticular vertices in the following discussion. Addition of Useless Alternations. In c+&#38; there are \nthree alternation vertices which have outgoing al-ternation edges only to construction vertices: Fac-ulty, \nAssignment, and Student. These are added to C$~ along with their outgoing a.lternation edges. Next, the \nEmployee vert.ex is added with its outgo-ing alterna.tion edges, including an edge to Faculty. Finally, \nthe Occupation vertex is a.dded along with its edges to Student and Employee. At this point ~$1 ha.s \nbeen t,ransformed to the class dictiona.ry graph shown in Figure 7. Distribution of C ommon Parts. The \nssn a.nd gpa pa.rts a,re distributed from class Univstudent to cla,sses Undergrad and Grad where they \na.re inher-it,ed. Simikrly, parts ssn and salary are distributed from Univ-employee to TA, Prof, Admin-asst, \nand Coach. The result is the cla.ss dictionary gra.ph shown in Figure S. In a deeper inheritance hi-erarchy \nsome parts might need to be distributed repea.tedly until they a.re attached directly to con-struction \ncla.sses. Abstraction of Common Parts. Pa.rts ssn and gpa a.re a.bstract,ed from Undergrad a.nd Grad \nto Student. Num 0 0 Admin Coach Occupation Figure T: Addition of Useless Alternations N u m - Univ-student \n_--, \\\\ ConZ ttee -%a/ Occupation Figure S: Distribution of Common ~ a.rts 307 Univ-student 0 Real-Nun1 \nFigure 9: Abstrxtion of C:ommon I'ar'l s  Next, parts ssn, salary, and assigned are abstracted 2. Removal \nof singleton alternation ver- from TA and Prof to Faculty. Parts ssn and salary are then abstracted from \nFaculty, Admin-asst, and Coach to Employee. Finally, part ssn is abstracted from Employee and Student \nto Occupation. The re-sult is shown in Figure 9. Part Replacement. The old alternation vertex FacultyAssignment \nstill 1la.s an incoming construc-tion edge from the new vertex Faculty. In q!~ the corresponding edge \nis to vertex Assignment, so the edge is moved accordingly in 41. This is allowed since the set of construct,ion \nvertices alternation reachable from Assignment is equa.1 to the set al-terna.tion reachable from Faculty-Assignment. \nSuch a. part replacement must always be possible since 41 is ohj~~ct.-equivn.lent to ~$2. The result \nis shown in Figure 10. Deleiion of I~seless Altevlcltions. The alterna.-tion vert,ices FacultyAssignment, \nUniv-student, and Univ-employee are now useless since they have no incoming edges a.nd no outgoing construct.ion \nedges. These vertices aad their outgoing alterna- tion edges are deleted, and the transformation from \n~$1 to q52 is complete.  Practical Applications There are ma.ny useful rules which can be derived from \nthe primitive tra.nsformations and are there-fore gua.rant,eetl object-preserving. The following esa.rnples \nshow how object-preserving transforma-tions can be uhed to improve class orga.nization by reducing t,lie \nnumber OF const.riiction edges: Ihe number of a.lt,ernat,ion edges, or the degree of mul-tiple inlleritance \nin a class dictionary graph. 1. Elimination of redundant parts. If ;1 vort (>S, I . 11as two incoming \nconst,ruc-tion edges wit.11 the same la.bel, (u, II, 1) and (CL . u, I), then those edges should be replaced \nby a. single edge (711, V. /) where PU is a,n alterna- tion vertex \\vit 11 esact,ly 21 and 7b a.5 a.lternation \nsuccessors, by obstmction of comnzon pnrts. If neccssa,ry, 71.1is first introduced by cltltlifion of \nII,W/~S.Y rtllf rnoliorl. ( SW k ig. 11.)  tices. If an alternation vertex, V, has only one outgoing \nalternation edge, (u, w), then that vertex should be removed. Incoming con- struction edges (u, u, I), \nand alternation edges, (u, v), are replaced by edges (u, w, 1) and (u, UJ) respectively. Outgoing construction \nedges, (D, x,1), are replaced by edges (w,x,~). The incoming construction edges can be moved by pm-t \nreplncement and the outgoing construc- tion edges by distribution of common parts. Moving the incoming \nconstruction can be ac- complished by wltern,ation replacement which is analogous to purt replacement \nbut is not primitive. It, is easy to see how wlternation reylwcement can be a.ccomplished using only \nprimitive transformations. Finally, the vertes 11is delet,ed by deletion 01 useless alternation. (See \nFig. 12.) 3. Complete Cover If a. subset, S, of the outgoing alternation edges from a vertex, U, completely \ncover the alternatives of another alternation vertex, U, then replace the edges in 5 with a single alter-nation \nedge to II. We sa.y the alternatives of an alternation vertex, V> are completely cov-ered by a set of \nedges, S, if every vertex which is the target of an outgoing a.lternation edge from 1: is a.lso the target \nof an edge in S. This rule can be derived from the primitive trans-formations using a construction similar \nto that given in section 3.2.2. (See Fig. 13.) 4. Partial Cover This rule applies if two alternation \nvertices, 7~ and ~1, cover a common set of a.lternatives, but neither contains a subset of outgoing al-ternation \nedges t,liat completely covers the al-ternatives of the ot,her. In lhis ca,se, a new alternation vertex, \n7~ ~ is created with an out-going alterna.tion edge t,o each of the vertices that is a. target of outgoing \nalternation edges from both 71 and 21, and incoming alternation ctlges (71,7X) a.nd ( V. 10). For each \nedge (714.2.) Univ-student Univ-employee 0 0 Figure 10: Pxt Replacement 0 Ll Figure 11: Elimina~tion \nof redundant pa.rt,s u . --J--w c2 c4 0 c6 0  0 Y )O c5 III  Figure 13: Complete Cover Figure 14: \nPa.rtial cover U 0 1 Figure 15: MI minimization which is added, the corresponding edges (u, X) and (v, \nZ) are deleted. (See Fig. 14.) 5. MI Minimization If there are alternation edges, (u, w) and (21, w) \nsuch that for all other alternation edges from 21, (u, w ), 20 is alternation reachable from 21, then \nreplace the edge (u, w) with the edge (u,~). This rule reduces the amount of multi-ple inheritance without \nchanging the edge size. However, it introduces repeated inheritance. (See Fig. 15.)  Conclusion The \nprimitive object-preserving class transforma-tions presented in this paper are a powerful tool for reasoning \nabout object-preserving transfor-mations and optimizations. In order to deter-mine whether a. transformation \nis gua.ranteed to be object-preserving it is only necessa.ry to show whether it can be derived from the \nprimitive trans-formations. To prove that a particular class organization is in some sense optimal (see, \nfor example, [LBSSl]), it is only necessary to consider improvements that might be possible through the \nprimitive transfor-mations. An area for further research is the study of object-extending class reorganizations \n[LHXSI]. An object-extending transformation is one which adds to the set of defined objects or adds part \nclasses to previously defined 0bject.s. For object-oriented data base design this mea.ns that the objects \ncan be upda,ted automatically. For object-oriented pro-gra.mming it means t.1~a.t the progra.ms will \nstill a.c-cept simi1a.r inputs and produce similar out,puts. Acknowledgments: I would like to t,ha.nk \nKarl Lieberherr for Additional tha.polishing some his nks of generous go to the defi support Gun Xia.0 \nnitions. a.nd feedba.ck. for his help in References [AH871 S. Abiteboul and R. Hull. A formal se-mantic \ndataba.se model. A6 M Trc~n.wc- tions on Databnse Systems, 12(4):525- 56.5> Dec. 1987. [BCG 87] Jay \nBanerjee, Hong-Tai Chou, Jorge F. Garza, Won Kim, Darrell Woelk, and Nat Ballou. Data model is-sues for \nobject-oriented applications. ACM Transactions on O&#38;e Informa-tion Systems, 5(1):3 -26, January, \n1987. [BDG*88] D.G. Bobrow, L.G. DeMichiel, R.P. Ga.briel, S.E. Keene, G. Kiczales, and D.,4. Moon. Common \nLisp Object Sys-tem Specification. SIGPLAhT Notices, 23, September 1988. [BL91] Paul Bergstein a.nd Karl \nLieberherr. Incremental class dictionary learning and optimization. In Europewn Con-ference on. Oljjcct-Orierzted \nP1~ogmm-ming, page ?, Springer Verlag, Geneva, Switzerland, 1991. [BMWSS] ~4lexa.nder Borgida, Tom Mitchell, \nand Keith Williamson. Learning improved integrity constraints and schemas from exceptions in data and \nknowledge bases. In Michael L. Brodie and John My-lopoulos, editors, On Knowledge Base Management Systems, \npages 2599286, Springer Verlag, 1986. [Cas89] Eduardo Casais. ject system. editor, Oi5ject pages 161-189, \nD lnforma.tique, Reorga.nizing a,n ob-In Dermis Tsichritzis, Oriented llevelopment, Centre Universitaire \nGeneve, 1989. [Ca.s90] Etlua.rdo Ca.sa.is. Managing cla.ss cvolu-tion in object-orient,ed sysk~iis. In \nDen-nis Tsichritzis: edit,ol, 06jcct Mw~ge-menf, pages 133-19.5, Cent,re Universi-t,aire D Informaticlue, \nGeneve, 1990. [GR83] [LBS90] Karl and J. Lieberhcrr. lgnacio Silva-Lepc. l aul Bcrgstcin, :\\bslra~ction \n of object-oriented data models. In [PW89] Winnie W. Y. Pun and Russel L. Hannu Kangassalo, editor, Proceedings \nWinder. Automating Class Hierarchy of International Conference on Entity- Graph Construction. Technical \nReport, Relationship, pages 81-94, Elsevier, University College London, 1989. Lausanne, Switzerland, \n1990. [Sno89] Richard Snodgrass. The interface de- [LBSSl] Karl J. Lieberherr, Paul Bergstein, and scription \nlanguage. Computer Science Ignacio Silva- Lepe. From objects to Press, 1989. classes: algorithms oriented \ndesign. .Jo~wnal, 1991. for optimal object-Software Engineering Accepted for publica.- [Str86] B. Stroustrup. \nThe Language. Addison C++ Programming Wesley, 1986. tion. [TYF86] T.J. Teorey, D. Ya.ng, and J.P. Fry. \n[LHXSl Karl and Clnss .J. Lieberherr, Walter L. Hiirsch? Cun Xi;,,. O~~ecl-E:3:tenn ir2g ~rn,~2s~~7,mntio72s. \nTechnica.l Re- A logical design tional data bases. veys, 18(2):197-222, methodology for ACM Computing \nJune 1986. rela-Sur- port NU-CCS-91-8, Northeastern Un- versity, July 1991. [LM91] Qing Li and Dennis \nMcLeod. Concep- tual data.base evolution through learn- ing. In Rajiv Gupta and Ellis Horowitz, editors, \nObject-oriented Databases with application,s to CASE! networks und VLSI CAD, pa,ges 62-74, Prentice Hall \nSeries in Da,ta and Knowledge Ba.se Sys- tems, 1991. [MeySS] Bertrand Meyer. Object-Oriented Soft- ware \ncIo7l.5trudion. Se,rirs i,n Con2- puAcr SCimY, Prentice IIall Inkrna.- tional, 1981. [Prw S9] 1~. l erllici? \nT; . Barbie, M.G. Fugini, 1~. h!la.iocchi, J.R. Ra.mes! and C. Rolland. C- IODOS: an antonia.tic tool \nfor office system co1~ceptua1 design. /I C M Trcrrw c~c~ion.~ o/i (!J~!I; cFIr~~jormf~tio77 ,Sysle7izs, \n7(4):3Z-4 19, October 1989. [PirSS Fiora?. Pirri. nlodelling a multiple iii- licritance lattice with \nescept,ions. In P~occolir2g.s oj the Il orkshop 077 Inher*- itance unfl Hierarchic.5 in Iinowleclge Ilcpr~es~72ff~fio7~ \n(171~1 PI,o!jrt/.inming Lu72- yufI~/e.~, plgc~s 91 104. vixcggio, l+l,n- arv I SS!).  \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "Paul L. Bergstein", "author_profile_id": "81100274110", "affiliation": "Northeastern University, College of Computer Science, Cullinane Hall, 360 Huntington Ave., Boston, MA", "person_id": "P220923", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117977", "year": "1991", "article_id": "117977", "conference": "OOPSLA", "title": "Object-preserving class transformations", "url": "http://dl.acm.org/citation.cfm?id=117977"}