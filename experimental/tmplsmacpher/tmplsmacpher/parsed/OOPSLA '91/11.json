{"article_publication_date": "09-01-1991", "fulltext": "\n Phoenix, Arizona 6 -11 October 1991 Objects in Large Distributed Applications Organizer: Peter Dickman \nThe OLDA (Objects in Large Distributed Applications) workshop brought together people from a wide variety \nof backgrounds to share their insights into scalable object systems. Ranging from academics investigating \nsystem-level support mechanisms to industrial researchers restructuring applications, addressing issues \nfrom software engineering to memory management, a total of 16 papers were presented to an gathering of \ntwo dozen attendees. This report summarises the presentations, with a list of the papers attached as \na bibliography. Any errors in presentation are entirely mine, and I apologise to the particip ants if \nI have accidentally misrepresented their work. The day was divided into four major sessions, with presentations \nlasting from ten to twenty minutes and lots of discussion and questions. In addition a short discussion \nsession addressed the question of the wider context of our work. What support would we like from other \nbranches of computing and what did we have to offer the wider community? (I) Systems and (IV) System \nIssues The workshop began with a session on complete systems. Three long presentations covered the Y- \nsystem from GMD-FOKUS in Germany, COOPERATION from NCR, and Emerald, originally developed at the University \nof Washington. Of these Emerald is probably the best known, being one of the early and influential distributed \nobject systems projects. Eric Jul gave a brief overview of Emerald before moving on to discuss the extension \nof Emerald to wide-area networks. Erik addressed the issues of bootstrapping a system, naming and location \nas they arise in large scale systems, indicating that the preferred solution relied heavily on directories \nin the gateways onto the WAN. These permitted improved control over failure recovery Addendum to the \nProceedings OOPSLA 91 and gave management advantages. MunTuck Yap then presented COOPERATION,an environment \naimed at the enterprise scale. Unlike the Emerald strategy, of using self-correcting remote pointers \nwith a fallback search mechanism, for object location COOPERATIONuses Directory Services; security is \nalso addressed explicitly, with classes embodying the ECMA security architecture. Using a third solution \nto the object finding problem the Y-system uses traders to map service requests onto service offers, \nthus differing again in its approach to naming. Furthermore, a very detailed model of interactions between \ncomponents in a broadband ISDN network is a major feature of this project. Y-system was developed from \nthe start with barge networks in mind and explicitly addresses management issues and low-level support. \nCOOPERA I ION, in contrast, has aimed more at the user interface. Finally, one major respect in which \nEmerald and the Y-system are closely allied is in the large granularity of their object models, although \nEmerald also has fine- grained objects embedded within, but migratable independently of, the larger objects. \nSupplementing the first session, the last (and longest) one focussed 011 particular issues in distributed \nobject-support systems. Five presentations covered consistency, persistence, load balancing and memory \nmanagement as well as an overview of the support for load balancing and garbage collection in the Bellerophon \nproject. Eliot Moss began the session by presenting some new ideas on consistency management for distributed \nsystems. Carefully distinguishing consistency requirements from mechanisms such as concurrency control, \nrecovery and so forth he discussed consistency in terms of a logical time at which a transaction commits. \nTransactions lead to new versions of objects in this model, with at most one committed child version \nof an object. The approach was based on read and write sets for transactions and rules relating the commit \ntime of a transaction to those of the members of its read and write sets. The major [911 advantage of \nthis approach is that additional flexibility is gained. A transaction may not be able to commit, due, \nsay, to a member of the read set having been superseded. The transaction may, however, be able to discard \nthat value (which will still exist) from its read set and retain some significance; thus it may recover \nand attempt to commit again. The value of the proposal thus lies not in the behaviour after commitment, \nbut in the additional flexibility that arises during transaction processing itself. Steve Crawley then \nconsidered orthogonal addressability in the context of persistent programming languages and distribution \nissues relating to them. Orthogonal addressability requires that the semantics for a name or address \nassociated with a first class value are independent of the location of the value. Steve presented a proposed \narchitecture to support his Alex language (a CLU- like language supporting distributed and persistent \nprogramming). This provided a vehicle within which he could show the advantages of an orthogonal addressing \nmechanism, as well as indicating a number of simple optimisations to ensure that the mechanism overheads \nwere acceptable. Copying immutable objects and object migration permitted a simplifying assumption to \nbe made: at most one active copy of each persistent object exists in the system at any time. Although \nsuperficially similar to some work done over Mach, the avoidance of cache coherency mechanisms in the \nAlex architecture aids scalability. The Bellerophon project was next discussed. This proposed an architecture \nfor a scalable distributed object-support layer with naming and location strategies similar to Emerald, \nbut explicitly designed to scale across extremely large networks. Bellerophon also addressed issues in \ndistributed garbage collection and load balancing. The system architecture consisted of a vast number \nof establishments connected by one or more wide-area networks. Gateways connected these networks to the \ninternal networks of the establishments, in each of which one or more networks connected a large number \nof processors, each capable of holding a large number of medium-sized objects. All references in the \nsystem were made explicit and this assisted a many-layered hybrid garbage detector. Load balancing was \nlimited to individual establishments and utilised information provided locally at each processor by the \ngarbage collector. Load Balancing was also the focus of Raj Tewari s work, in which a variety of optimisation \ntechniques were being used to study availability and reliability issues and their role in load balancing. \n[92 1 9-11 October Finally, Paul Wilson addressed the issue of memory management. At the lowest levels \nof object systems there must be mechanisms for relating objects and machine memory. Paul discussed the \nrole of virtual memory primitives in supporting a number of novel techniques. Examples included pointer \nswizzling, which permits large object identifiers to be efficiently used as addresses on stock hardware, \nand compressed paging. This latter idea involves the use of compression algorithms to provide an additional \nlayer in the memory hierarchy. Memory pages are compressed, rather than moved to secondary storage, since \n(un)compression can be performed rather more rapidly than transfers to and from disk. Only if the compressed \npage store (an area of RAM) is filled will paging (of the compressed material) to disk occur. Other uses \nof VM primitives included checkpointing schemes and a variant of adaptive prefetching, as well as support \nfor the local garbage collectors that must underpin any distributed garbage detection algorithm. Paul \nwound up the afternoon with a plea to operating system and language designers to clean-up virtual memory \nand pointers. The lowest common denominator approach, which leaves us struggling with Unix, C and C++ \nisn t really helping!  II Software Engineering The second half of the morning was dedicated to software \nengineering. Wolfgang Gerteis substituted for Max Miihlhtiuser in presenting the item-oriented programming \nparadigm, developed by the DOCASE project in Germany. The view was put forward that Distributed Object-Oriented \nProgramming Languages are the assembly languages of the future, since they offer a small and straightforward \nmodel that lacks support for large size, cooperation and multimedia and also do not adequately address \nall distribution issues. Aimed at Large Distributed Cooperative Multimedia Applications item-oriented \nprogramming extends the O-O approach with additional items (classes) that capture the semantics of major \nkinds of objects and relations typical to the LDCMA domain. Whereas O-O programming focuses on behaviour \nand hyperslructures are based primarily on considerations of status (non-executable data etc) item-oriented \nprogramming is intended to combine the two. Thus relations become first class entities, alongside objects, \nand appearance (human interaction) becomes au integral part of the language and model. In addition to \nthis extended presentation two other papers were given. Hari Madduri related some of the problems that \narise if O-O techniques are used with inadequate software engineering in large systems. Having given \nhis apocalyptic vision, he then suggested an approach to 1991 Phoenix, Arizona large-scale O-O programming \nin which classes are organized into a groups, which are then partially ordered to provide large-scale \nstructure in the system. John O Connell, in contrast, addressed the problem of trading and run-time information. \nHis proposal, for object interfaces to be extended with information to be used by traders, also provided \nsupport for debugging and monitoring. Appropriate and accurate run-time information and trader- mediated \nbinding has the advantage also of permitting upgrades to be made to running systems; however, again, \ncurrent object interfaces do not provide a means of describing and selecting different implementations \nof the same interface. Following this session a few minutes were dedicated to considering wish-lists. \nFacilities that would assist the production of scalable applications and object-support systems were \ndiscussed and ways in which we could encourage the development of such facilities were proposed. The \nprinciple conclusion of the discussion was that raising the lowest common denominator of operating systems \nand programming languages was essential. It was, of course, recognised that no proposal will receive \nwide acceptance unless there is a migration path for Unix/C/C++ applications, but some improvement is \nessential if we <are to build robust and extensible huge scale distributed systems. In particular, large \nsystems demand more powerful management techniques, such as g arbage collection and (perhaps) load balancing \nand these are really only feasible if references can be easily identified. Better control over virtual \nmemory, for example, would improve many aspects of our work, from logging to garbage collection.  (Ill) \nDesign Issues and Applications Of more general interest, however, is likely to be the early afternoon \nsession. This consisted of five presentations on applications and design issues. The Melampus project \nwas introduced by Allen Luniewski. This is an ambitious undertaking aimed at developing a single distributed \nmodel and system capable of managing all the worlds data and making it accessible (in a secure fashion) \nubiquitously. Melampus is intended to provide both navigational and associative access using type conformance \nand compile time type-checking. Allen addressed in particular the issues exacerbated by scale in such \na model, in particular schema evolution and problems in associative access. Melampus also has an unusually \nfine-grained access control model: ACLs are to be associated with each method of every object, using \nhardware support for paging, and assuming a high degree of commonahty in the ACLs, so that an efficient \nmechanism can be constructed. A similarly global view wras presented by Christopher Lozinski in his discussion \nof the role of large portable object libraries for use in both education and manufacturing. A library \nalone is insufficient without the management tools required to manipulate and update the library contents, \nreorganising and extending as required. Presenting their experience in using a large library of objects, \naimed at operations management applications, Christopher indicated directions and issues that must be \nconsidered if widely reusable large scale software is to be successfully developed. In particular, the \nneed for persistence, schema evolution and timestamped versioning, automatic and incremental redistribution \nand object fragmentation facilities were noted. In this session Wolfgang presented a second extended \npaper, covering the ABCD architecture of hybrid design and implementation languages for large distributed \napplications. ABCD provides an Application framework, Behavioural model, Component model and Distribution \nmodel. The component model corresponds to the traditional types and instances of O-O programming, with \na clean approach to structuring. The behaviour model exteuds normal message passing and strong typing \nwith facilities to describe configuration management, multiparty communication and loose cooperation \nof disparate threads. The application framework forms an integral part of the design language, providing \ncategories that (as far as possible) are complete and disjoint and with which object-types are associated. \nCategories have associated language constructs and are used to identify major semantic differences hence \nindicating distinct sorts of object type. Finally the distribution model defines the initial configuration \nof the application. An environment based on this approach and supporting the DODL language is under development. \nThe final papers of this third session concerned actual applications, Mark Pearson described D- Router, \na distributed route-planning system implemented in CLIDE over CLOUDS. CLOUDS is a distributed operating \nsystem supporting threads and persistent object memory; CLIDE is a distributed persistent object-based \nprogramming system in which LISP enviromnents are held as large-grained persistent objects. D-Router \ncombines two model- based reasoning engines, a c ase-based reasoner and a graphics engine with a user-interface \nand is composed of five major components in a distributed system. The use of remote invocation and distributed \nshared memory proved most useful in developing the application. Parts of D-Router were implemented in \nCC++, an extended C++, although Distributed Eiffel could also have been used. In concluding Mark noted \nthat programming in the large Addendum to the Proceedings OOPSLA 91 [ 93 1 (megaprogramming) requires \nprogramming semantics support beyond that of typical fine- grained object-systems and that support for \nthese semantics must be provided by the underlying operating system; neatly tying in with the systems \nmaterial on persistence and orthogonal addressing, for example. The final paper in the third session \nwas presented by Sharon Lamb and covered both the ESP environment and several applications used on it. \nESP is an extended C++ environment, supporting distributed application objects on heterogeneous nodes \nand targeted at an experimental system built from stock hardware and combining dozens of low- cost processors. \nTo evaluate and gain experience with ESP several significant applications have been ported or recoded, \nthree were presented. The Sandia Labs hypervelocity modelling package is extremely communication intensive \nand suffers from the need for lock-step synchronized message passing. A finite element solver for partial \ndifferential equations did, however, display economies of scale. This application manipulates complex \ngeometries with irregular, unstructured meshes. Finally the Ballistic research Lab CAD raytracing benchmark \nwas used; with one instance of the code per node forming large-grained worker objects. A driver passed \nwork on demand to these workers and (we were assured) provides a nice demo with pretty pictures. The \nray-tracer provided an extreme test of the hardware and software, however the hypervelocity and finite-element \npackages provided greatest insight into the development and use of large distributed applications. Summary \nTo quote from Sharon Lamb s position paper: The grand challenge for ESP developers is to provide a complete \ndistributed system: hardware, kernel, compilers, tools etc. such that programming distributed computers \nis convenient and makes optimal use of resources. This workshop, I believe, showed that the challenge \nhas also been taken up by others across industry and academia. It is clear that issues of scale and distribution \nhave ramifications in a range of sub- disciplines of computer science, from software engineering to language \ndesign, influencing everything from operating system mechanisms to object models. Although it is hard \nto draw a single point out of the web of inter-related material presented during the day, perhaps one \nrepeated point is worth noting. Orthodoxy in O-O work has it that everything is an object , providing \na simple unifying model. However, throughout the presentations it was clear that there is a need to explicitly \nrecognise the changes that occur as one moves up through a system: from hardware to o/s abstractions, \nto multiple address spaces and distributed systems (which exhibit complex failure modes) and then finally \nto a global vision of cooperating autonomous establishments using highly interconnected and interactive, \nyet widely distributed, applications. Identifying the mechanisms that support the transitions from one \nlayer of this view to the next, providing efficient and effective implementations when low-level design \ndecisions have major ramifications at the highest levels, and building applications at each of these \nscales, will occupy us for some time to come! References 111 rcY9 : Concepts and experience with a distributed \nobject-oriented system supporting applications in a broadband ISDN environment Linda Strick strick@fokus.berlin.gmd.dbp.de \nGMD-FOKUS, Hardenbergplatz 2, W-1000 Berlin 12, Germany El COOPERATION-A distributed computing system \nMuntuck Yap rnuntuck@oiscola.columbia.ncr.cont NCR (CCSD), 3245 Platt Springs Road, West Columbia, SC \n29170, USA [31 Porting a locally distributed system to a wide-area network Eric Jul eric@diku.dk University \nof Copenhagen, Dept of Computer Science, 1 Universiteitsparken, Copenhagen, DK-2100, Denmark [41 From \nObjects to Items-Facing the Upcoming Generation of Software Applications Max Miihlh;iuser (presented \nby Wolfgang Gerteis, see below for address) max@informatik.uni-kl.de r51 Going back to structured programming? \nHari Madduri rnadduri@ausvml.iinusi.ibm corn IBM Object Technology Products, 11501 Burnet Road (internal \nzip 9641), Austin, TX 78758, USA 194 1 Q-l 1 October 1991 Phoenix, Arizona RI Extending Interface Definitions \nfor Large Distributed Applications John O Connell jnroOIl~~lb.hpl.1lp.co~~~ HP, Filton Road, Stoke Gifford, \nBristol BS 12 6QZ, UK [71 Scalability Issues in Melampus Allen Luniewski li~niew~alnzaden.ibrn.cotn IBM \nAhnaden, K55/803,650 Harry Road, San Jose, CA 95 120, IJSA PI Requirements of Large Object Libraries \nin Large Universities: A survey of support issues Christopher Lozinski BPG, 75 Glen Road, Sandy Hook, \nCT 06482, USA [91 Large Application Development using CLIDE in the Clouds Environment Mark Pearson mpearson@cc.gatech,edu \nCollege of Computing, Georgia Tech, Atlanta, GA 30332, USA [lo] The ABCD-Architecture of Hybrid Design/Implementation \nLanguages for Large Distributed Applications Wolfgang Gerteis gerteisQi7Uvca.iravcl.ira.uka.de University \nof Karlsruhe, Institute of Telematics, Zirke12, W-7500 Karlsruhe, Germany [1 l] MCC s Scalable Sharon \nLamb Distributed Computing ltrtllb@wlcc.cot~? MCC/Motorola ESL, 3500 W. Balcones Center Drive, Austin, \nTX 78759, USA [12] Simple and Flexible Consistency Management In Distributed Persistent Object Systems \nEliot Moss nloss@cs.utnass.edu Dept of Computer Science, Univ. of Mass., Amherst, MA 01003, USA [ 133 \nDistributed Persistence using Orthogonal Addressability Steve Crawley sxc@itd.dsto.oz.au DSTO Salisbury, \nPO Box 1600, Salisbury SA, Australia [14] Scalable Object Support Bellerophon Project Peter Dickman in \nthe Peter.DicktnanG?cl.canz.ac.uk Cambridge University Computer Lab, Pembroke S tree&#38; Cambridge CB2 \n3QE, UK [15] Object Allocation in Distributed Applications Raj Tewari tewari@cis.tetnyle.ed~~ CIS Dept, \nTemple University, Broad and Montgomery Street, Philadelphia, PA 19 122, USA [ 161 Operating System Objects \nPaul Wilson Support for Small wilson.@cs.rdtexas.edu Dept of Computer Science, Taylor Hall 2.124, U. \nTexas at Austin, Austin, TX 78712, USA  Addendum to the Proceedings OOPSLA 91 195 1  \n\t\t\t", "proc_id": "143773", "abstract": "", "authors": [{"name": "Peter Dickman", "author_profile_id": "81100441864", "affiliation": "", "person_id": "PP31076423", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143773.143800", "year": "1991", "article_id": "143800", "conference": "OOPSLA", "title": "Objects in large distributed applications", "url": "http://dl.acm.org/citation.cfm?id=143800"}