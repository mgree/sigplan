{"article_publication_date": "11-01-1991", "fulltext": "\n Islands: Aliasing Protection In Object-Oriented Languages John Hogg Bell-Northern Ottawa, Abstract \nFunctions that are guaranteed not to have side ef-fects are common in modern procedural languages, but \nnot in object-oriented languages. Certain types of state changes are essential in object functions; the \ndifficulty lies in permitting these while banning undesirable side effects. A simple way of doing this \nis presented. Using this as a base, we can introduce islands of objects which can statically ensure non-aliasing \nproperties in a very non-restrictive way. Islands make construction of opaque object com-ponents more \npractical. They also make formal treatment of object behaviour more feasible, since the object structures \nthey encompass can be truly opaque to their clients.  Introduction Object-oriented languages have a \nlight side and a dark side. The light side is that the program-ming model makes rapid prototype implementa-tion \nmuch easier, since components can be easily reused. The dark side is that as these prototypes mature, \nthe components can manifest stra.nge be-haviours due to unforeseen interactions and interre-lationships. \nThe big lie of object-oriented program-ming is that objects provide encapsulation. In or-der to accomplish \na.nything, objects must interact with each other in complex ing these interactions can Permission to \ncopy ivithout fee granted provided that the copies direct commercial advantage, the ways, a,nd understand- \nbe difficult. all or part of this material is are not made or distributed for ACM copyright notice and \nthe title of the publication and its date appear, and notice is given that copying is by permission of \nthe Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific \npermission. @ 1991 ACM 89791-446-5/91/0010/0271 . ..$I .50 Research Ontario This paper presents two ways \nof making object interaction more predictable. The first is well-known to the programming world, but \nhas not yet been embraced by the object-oriented community: the division of routines into procedures, \nwhich change the system state but do not return values, and functions, which return values but are guaran-teed \nnot to change visible system state. (This dis-tinction is made informally in some object-oriented languages. \nHowever, compliance is the responsi-bility of the programmer.) Since functions must be allowed to create \nobjects, a complete ban on changing state is not a.cceptable, so the problem is slightly more involved \nthan in the traditional case. Nonetheless, the solution is straightforward, a,nd involves a. new version \nof the traditional read-only access mode. The second part of the paper extends access modes to present \nsomething more novel: islands of objects. Islands can be used to statically guar-antee that an object \nis not aliased, while placing minimal restrictions on its use. For instance, an object can be stored \nin a container object, changed by being passed to an external (and possibly heav-ily aliased) object \nfor use in a procedure method, and later passed on to an object tota,lly different from the one that \ninserted it in the container in the first place. At the end of these operations, the new owner of the \nobject can still be sure that it is unaliased. The syntactic cost of this is about three times that of \nproviding side effect-free func-tions, and in addition, a fairly natural destructive read operation must \nbe added. Islands also make proof systems that depend upon knowledge of explicit relationships between \nobjects more feasible. Within an island, objects a.re treated as friends in the sense of C-l-t [Str86], \nand analysed together. Externally, however, the island can be dealt with as a black box. The con-cepts \nof islands are widely applicable to different languages and models, and to different theoretical and \npractical needs. Side Effect-Free Functions The idea that routines should be divided into those that \nreturn a result ( functions ) and those that change their environment ( procedures ) is now firmly established \nin the world of tradit)ional pro-cedural programming la.nguages. To the theorist, formal analysis is \ngreatly simplified. Boehm has presented a logic for Russell, a language with func-tions having side effects \n[Boe84], but the Russell definition of side effect is quite non-standard. In general, the problem is \nunsolved. For the pragmatic software engineer, side effect-free functions make error detection ea.sier, \nand un-foreseen interactions between components are con-siderably decreased. It seems natural to extend \nthis approach to the object-oriented world, and provide languages in which procedures do not return val-ues, \nand functions do not have side effects. Before this can be done, however, the term side effect must be \ndefined. Intuitively, a programming construct (henceforth, an expression) has a side ef-fect if it chaages \nthe state of the system. However, consider the simple expression 3 + 4. Under a com- mon model of object \nbehaviour, this will result in the creation of a new instance of cla.ss Integer with value 7. The system \nstate has changed, yet we do not think of addition as having side effects. The answer, of course, is \nthat these system changes are not visible to any object in the sys-tem. The newly-created instance is \nnot accessible from any existing instance. More to the point, no instance reachable prior to the evaluation \nof the ex-pression (in fact, no instance eLstiny prior to the evaluation) is altered. From the theoretician \ns view of an expression as a mapping from states to states, no predicate on the initial state will be \nfalsified by the mapping. A programmer will say that an as-sertion will always be unaffected by the evaluation \nof an expression. We therefore have a nice intuitive understanding of what we want to achieve, and can \neasily formalize it. The tool usually used to achieve freedom from side effects in modern procedural \nlanguages is some sort of read-only access mode. An access mode is a statically-testable restriction \non the operations that ma.y be applied to a variable. In many lan-guages (such as Pascal) read-only is \nthe defa.ult mode for pa.rameters: a parameter is read-only un-less it is explicitly imported with a \nvar mode. A read-only parameter may not be assigned to, and ma.y only be exported to other routines with \na read- only mode. However, this is not sufficient in an object-oriented language, in which objects are \nre-ferred to using pointer semantics. It is not enough to protect the pointer; the object at the other \nend of it must also be gua.ranteed to be unaffected by an operation which purports to be free from side \neffects. This requirement for protection at two levels 1la.s been recognized before, with respect to \nthe Eiffel langua.ge [Mey88]. 2.1 Eiffel The Eiffel la.nguage has syntactic provision for value-returning \nfunctions and procedures without return values. Guaranteeing that a function will not have side effects \nrequires recognizing the cases in which side effects may occur. Meyer presents a list of these cases. \nThey are: 1. assignment to an attribute (instance variable) Z 7 2. procedure call having side effects \non an at-tribute 2; 3. local call ha.ving side effects (which in some  languages could be considered \na. form of the previous case); and 4. using an attribute as an argument where the called routine produces \na side effect on the cor-responding parameter. Meyer states that it would be simple to enforce these \nrules, but that side effects which only change the concrete state of an object and not the ab-stract \nstate should be allowed. In other words, internal state changes that cannot be detected through any sequence \nof method invocations should not be considered to be side effects at all. He there- fore relies on the \nprogrammmer to avoid unwa.nted state changes. Unfortunately, the list given above is incomplete. Consider \nthe following code: class C export hiddenSideEffects feature protected: MUTABLECLASS; hiddenSideEffects(): \nSTRING is local temp: MUTABLECLASS do temp := returnParam(protected); temp.mutate; Result := protected \nhas just been altered  end; returnParam(arg: MUTABLECLASS): h/IUTABLECLASS is do Result := arg end end \n class MUTABLECLASSexport mutate feature value: BOOLEAN; mutate0 is do value := not value; end; Here, \nall of the Eiffel side effect rules have been followed, but the attribute protected loses its sup-posed \nprotection by being the result of a function. When hiddenSideEflects returns, the object that its attribute \nprotected refers to will have its value negated, even though the only call of a routine with side effects \nwas on the local variable temp. Clearly, return values are a potential source of unexpected side effects \nin an object-oriented lan-guage. This is especially true because we cannot just decree that all function \nresults are read, for the reasons explained earlier: the function may have constructed a structure of \nobjects which is not vis-ible in the context (i.e., the object) from which it was called, but is to be \nreturned for use in that con-text. In non-object-oriented languages, the ability to generate structures \nof objects in this manner is not so central to the programming paradigm. This is why the designers of \nthe Turing language [HMRCSS] could reasonably ban the creation of new collection elements in a function. \nWhen an attempt is made to simulate an object-oriented lan-guage in Turing, however, the restriction \nis imme- diately apparent. The natural way to simulate the instances of a class of objects uses a collection. \nFortunately, there is no fundamenta,l reason why the desired behaviour of functions ca.nnot be ob-tained, \nas we shall see.  2.2 Access Modes and Types First, a word about typing. An interest in freedom from \nside effects is usually accompanied by con-cerns about other aspects of program predictabil-ity, and \ntherefore side effect-free functions are found in typed languages. Furthermore, attempts to understand \nobject behaviour are presently con-centrated on types and type inheritance. To ensure that there is no \nmisunderstanding, we will state the obvious: the access modes presented here and later on in the pa.per \nare completely orthogonal to any notion of typing, and of inherita.nce. Side effect-free functions (and \nlater, islands) will be most useful in the context of a typed language, but types are not necessary. \nTo drive the point home, the remainder of the examples in this paper will be expressed in a Smalltalk-like \nlanguage [GR83]. This is not meant to suggest tha.t Smalltalk is the most appropriate vehicle for anything \npresented here. The ideas a.re clearly translatable to other object-oriented lan-guages. In fact, since \nthe work presented here is orthogonal to inheritance, it applies to object-based languages in general \nand not just object-oriented languages, using the terminology of [Weg87]. Since parameters and results \nhave associated access modes, each method invocation must be checked for legality. This is done by treating \nthe set of modes associated with an invocation as an extension of the method selector. Mode confor-mance \nis therefore checked at runtime, and an im-plementation would supply a mechanism similar to doesNotUnderstand \nto deal with cases of mismatch between access modes of the invoking messa.ge and the methods supplied \nby a receiver object. In a statically-typed language, signature mode confor-mance would also be sta,tically \nchecked.  2.3 Rules for Side Effect-Free Functions We will now provide a set of rules for ensuring \nfree-dom from side effects in functions. They are ba.sed on the traditional notion of a read-only (hence-forth, \nread) access mode. In an object environ-ment, however, this mode must refer to both the variable and \nthe object to which it refers. The re-strictions on read are simple: Definition 1 (Read) A variable whose \ndeclara-tion has the label %read is read. If within a method the receiver (self) is read, then all instance \nvari-ables are implicitly read. A read expression is a read variable or the result of a read-valued func- \ntioiz. 1. A rea,d variable may not be assigned to. 2. A read expression may only be exported as read. \nAn expression is exported when it is used  An alternative name for this mode is const. However, that \nsuggests that an object that is the value of a const variable cannot change. If the object or the structure \nof objects reachable from it is aliased, i.e., is the value of an-other possibly non-const variable, \nthen the nomenclature is misleading, since it may change under foot . A mode is a property of a variable \nand describes the way that an ob-ject and its structure may be accessed. The mode is not a property of \nthe object or its structure. as a parameter of a method invocation or the result of a function method. \n3. A read expression may not be the right side of an assignment. The first restriction obviously protects \nthe read variable itself from being assigned to. The second restriction ensures that the object that \nthe vari-able refers to is protected when it is used in other contexts. The third restriction protects \nthe object within the current context. If a reference may be reta.ined in an instance variable, then \nthe protected object may be altered later in an execution by some other method. The persistent environments \nthat are the central concept of object-oriented program-ming make it difficult to specify during one \nentry to a context (an instance) that some reference should be treated in a special way when the context \nis re- turned to later. Permitting assignment to tempo-rary variables (which must subsequently be treated \nas reads) is somewhat simpler, but results in con-siderable syntactic baggage and also incomplete-ness, \nfor negligible advantages. The idea of a read access mode is usually ex-pressed in a syntax that is the \nreverse of the one used here: no variable may be changed unless it is declared var. Using var as a default \na.nd making read restriction explicit is a matter of taste, and makes it easier to express what read \nentails. The difference is minor. Definition 2 (Function) In a function method definition, all parameters \n(including the receiver, self) are read. Within a function method, then, all instance vari-ables (and \nthe objects they refer to) are read. A function invoca.tion will have no visible side effects. These \nrules imply that there are two sorts of function: those that return read results, and those with free \nresults. This addition to the signature of a function method is the price that must be paid for adding \nside effect-free functions to the pointer semantics of an object-oriented language.  2.4 A Function \nExample The following example is expressed in an extended Smalltalk in which method definitions have \nsigna-tures annotated by access modes. In Smalltalk, ev-ery method can have side effects, and also returns \na value. Since we have divided the world into proce-dure and function methods, it becomes convenient \nto make this distinction in the language, and there-fore function selectors have been distinguished from \nprocedure selectors by an initial uppercase letter. The mode of the receiver during the execution of \na method is prepended to the method name, and in-stance variables and pa.rameters have their modes appended. \nThe mode of a function result (if ex-plicit) follows a colon a,ppended to the signature. The example \nconcerns a class of complex objects having a method MaxAbs which returns the re-ceiver or its parameter, \ndepending upon which has the greater absolute value. We must ensure that regardless of the class of the \ncomponents of the receiver and the parameter, this method cannot change the visible state of the system. \nOne way of ensuring this is as follows: class name Complex instance variable names x Y instance methods \n. . . %read MaxAbs: aComplex%rend :%read ((self Abs) > (acomplex Abs)) ifTrue: [Tself] iffalse: [TaComplex] \n%read Abs :%read W*x) + (Y*Y)> SW This code does not specify the behaviour of the system by itself; \nthat will depend upon the classes of objects used to represent the x and y values of the receiver of \nthe method, and upon the para.me-ter. However, the demands made by these methods are fairly severe. They \nreturn read results, which restricts the use to which they can be put. 275 An alternative to this would \nbe the following im-plementation, which returns a result that canL be used in further processing: class \nname Complex instance variable names x Y instance methods . . . %read Max: aComplex%read ((self Abs) \n> (acomplex Abs)) ifTrue: [Iself Copy] iffalse: [j acomplex Copy] %read Abs :%read T((x*x) + (Y*Y)> SW \n%read Copy r(Complex new) x: x y: y %recld x: newX%read y: newY%read x +-newX Copy. y c newY Copy This \nis functionally a,n improvement, since the re-sult of Max may now be assigned to a variable in the calling \nmethod since there it has no read mode restriction. However, it is clearly quite inefficient, since copies \nmust be made to ensure that reud in-stance variables remain protected. The solut,ion to this involves \nintroducing an im-mutable mode, in the sense of [LG86]. Primitive objects are a.lmost always defined \nso as to be im-mutable: after an immutable instance is created, it ca.n never be changed, because there \nis no operation that can change it. As a result, it needs no explicit read protection. This mode would \nalso be useful in the second half of this pa,per. An immutable ob-ject need not be protected from aliasing, \nbecause the effects of this aliasing will never be seen by any holder of an alias. Immutability ca.n \nconsiderably simplify a.nalysis. However, this idea will not be further described here.   Islands \nFunctions that are free from side effects are valu-able in themselves to both the theoretician a.nd the \npractical programmer. They also provide a good introduction to the main contribution of this pa-per: \nthe notion of islands. The main problem in constructing a. usable for-mal semantics for an object-oriented \nlangua.ge is a.r- guably aliasing. An object is aliased (with respect to the context of another object \nand its associated state) if there are two puths to it. A path is a se-quence of variable names with \neach variable name denoting a context (i.e., a,n object) in which the succeeding variable is evaluated. \nIf a.liasing exists, then it becomes very difficult to determine whether an operation will change the \nstate of a seemingly-unrelated object. The aliasing found in a pure object system is not the same sort \nof aliasing that occurs in tra.di-tional procedural languages. Every object system variable is a pointer \nto an object, aad there is no way in which two variables can refer to the same pointer. However, the \ndistinct pointers may refer to the same object. Readers familiar with object systems will find the following \ndescription obvious. Those new to objects (even though they may have a strong ba.ckground in semantics) \nmay find it help- ful. Figure 1 gives two examples of aliasing, one harmless and one not. In Pa.rt (a), \nwe have a. prim- itive object (an integer) known in the current con-text by two aliases, the variables \nx and y. If x +-- x + 1 is now executed, there is no problem; x points to a new instance, and the value \nand behaviour of y both remain unchanged. Now consider Part (b) of the figure. Here, x and y both refer \nto an insta.nce of a user-defined class that conta.ins a value, and methods for accessing and altering \nthat value. A method x increment-Value (with the obvious semantics of the dia.gra.m) will now leave the \nvalue of y unchanged, but it will change the state of the object to which y refers, and thus its beha.viour. \nIn other words, a, con- struct will have changed the mea.ning of a variable in a. wa,y that is not syntactically \ndetectable. Note that object-oriented aliasing problems only occur at one level of indirection . Aliasing \ncan be divided into two types: static aliasing, and dynamic aliasing. An object is aliased statica.lly \nif the two different access paths are both composed entirely of chains of instance variables. The aliasing \nis dynamic if at least one of the access paths has a prefix consisting of tempora.ry variables or parameters. \nA dynamic alias will therefore dis-appear at the end of the execution of the method in which it appears. \nBy contrast, a static alias may make its existence felt during so me later invoca- tion. This persistence \nmakes a static alias much more troublesome than a. dynamic alias. A dynamic alias (i.e., the use of \nparameters, or most uses of tem-porary variables) has no effects beyond the scope in which it occurs. \nFrom an operational viewpoint, a static a.1ia.s can cause unplea.sant surprises at an arbitrarily distant \npoint in an execution. By the time the bomb goes off, the chains of variables in in- stances by which \nan aliased object is known may be arbitrarily long. From a denotational perspective, a static alias causes \nproblems because the meaning of an expression is dependent upon its context; the meaning of a function \ninvocation may be affected by a preceding procedure invocation even though the invoca,tions share no \nvariables. 3.1 Previous Work 3.1.1 SPOOL The most closely-related work in the literature to that presented \nhere is the proof system for SPOOL [AdBSO]. Some of the same ideas can be seen in the sema.ntics constructed \nfor the non-object-oriented language Turing [HMRC88]. The alia.sing problem is that an opera.tion involving \none set of identifiers ma.y affect the visible state of a disjoint set of iden:, tifiers. This occurs \nbecause some object is reacl - able from the current context through more than one chain of objects containing \npointers (i.e., vari-ables) to other objects. If these cha.ins and their re-lationships can be made explicit, \nthen the problem  X x Y 3 4 3 E +a  (a) W Figure 1 Aliasing problems is solved. Changes ma,de to an \ninstance through encapsulation: to determine the behaviour of an one alias can be reflected in other \naliases. object, not only must its implementation be ex- The SPOOL proof syskm is based on a Hoare amined, \nbut also the implementation of all of its logic, following the tradition of [Coo78]. Its pred-acquaintances. \nThis bodes ill for the late binding icate language contains not only simple variable of behaviour that \nis the essence of object-oriented names but also global ezcpressions. A global ex-systems. pression g.x \nhas the value of the variable x in the Finally, a variable chain system is impractical context of the \nglobal expression g. Conditionals because it does not provide modularity of proofs. may appear in global \nexpressions; otherwise, they Object-oriented libraries are supposed to provide reduce to chains of variable \nnames. The SPOOL the user with a. set of components that can be used proof system expresses predicates \nin terms of these to construct larger components and entire systems. chains of variables. A Hoare formula \ndescribes the If each use of a component requires proofs about body of a method as seen from within the \ncontext it to be reconstructed, then very little has been of its receiver. Proof rules express the same \nfor-gained. A practical proof system must enca.psulate mula from the context of the caller by prepending \nnot only code, but also specifications, so that a the variable indicating the receiver to each variable \ncomponent can be retrieved from a library as a true chain used in the body. A formula describing an black \nbox. object at a high level in the system therefore has a body consisting of some set of method invocations. \n3.1.2 FX Its predicates, however, have no invocations, but rather variables that are long chains. The \npolymorphic effect system of FX [LG88] is an- There are three obvious problems with this ap-other attempt \nto solve the aliasing problem. Ex-proach. From the description above, it is clear that pressions have \ntypes, and in addition have eflects, the technique does not scale. It may be reasonable which describe \nside effects (such as reading, writ- for small sets of classes, but is unusa.ble in anything ing, or \na.llocating), and regions, which describe larger than a toy system. Long chains of variable where these \neffects may occur. Regions are explic-names are not meaningful. itly specified by the progra.mmer. One \nexpression The use of pa.ths also massively violates object can be shown to have no effect on another \nif the effects of the first occur in a region not used by the second. Furthermore, an expression with \neffects can be shown to have none that are visible to the rest of the system if the region in which they \noc-cur is only visible from within the expression. An expression that only has such maslced effects corre-sponds \nto a function as described in the first part of this paper. Like the earlier work of Reynolds [Rey 78], \nef-fects are conservative. If the progra.mmer specifies regions with large granularity, potential interfer-ence \nwill be indicated where none actually exists. If small regions are used, then the task of region management \ncan overwhelm the programming un-derneath it. Again, calculating the reach (the re-gions a.ccessed by \nan expression) ca.n require aban-donment of the simple encapsulation that we would like to see in a set \nof objects. 3.2 Island Strategy In practice, programmers manage to muddle along even in the presence \nof aliasing without shooting themselves in the foot too often. We can speculate that this success is \ndue to the fa.ct that aliasing tends to be local, and between objects of closely-related classes. A programmer \nworking within one of these classes will have a good idea of how other classes will be affected by any \naliases present, and may well depend upon this knowledge. Approa.ches to object design such as CRC (Class, \nResponsibil-ity, Collaboration) [BC89] would seem to empiri-cally support this hypothesis. Assuming, \nthen, that islands of aliasing a.re used in an informal way at present, an obvious idea is to formalize \nthe concept, and control the existence of aliases in a rigorous manner. First, we will expand upon what \nan island should be, and what guaran-tees it should provide. An island is the transitive closure of a. \nset of ob- jects a.ccessible from a bridge object. A bridge is thus the sole access point to a set of \ninstances that make up an island; no object that is not a mem-ber of the island holds any reference to \nan object within the island apart from the bridge. Container structures make natural examples of islands. \nSince it must be possible to insert other objects (and structures of objects) into a container and later \nremove them without destroying the alias protection of the island, several other properties are required. \nIt must be possible to pass a structure into an island with a guarantee that no other ref-erences to \nit are held, and later it must be possible to retrieve the structure with the same assurance. While a \nstructure is held within an island, it should be usable: that is, it should be possible to invoke both \nfunctions and procedures on it, and to use it as a parameter to other functions and procedures external \nto the island, while still maintaining the guarantees of non-aliasing. For a more concrete view of the \nconcept, see Fig-ure 2. The boxes represent instances, and the ovals indicate the boundaries of islands. \nThe arrows rep-resent references from instance variables to objects. Here, we see a fragment of some \nglobal system state that includes a container island. An implementa-tion of this example will be presented \nlater. The topmost instances are users of the container. One instance inserts items which it guarantees \nto be unaliased, and this allows the other to have the same guarantee when it removes the items from \nthe container. The oval island boundary represents a wall across which no static references can exist, \nexcept through the bridge object at its top. Even dynamic references must be granted by the bridge. Since \nthe only access to the island is through the bridge, it follows that the state of an island remains unchanged \nbetween methods invoked on the bridge. When a bridge is itself unaliased, its sole holder is assured \nthat a,ny construct that does not contain a reference to the bridge cannot affect its (transitive) state. \nA lack of aliasing is thus a property to be jealously protected. The main bridge in the dia-gra,m here \ndoes not have that property. However, if we look inside the island, we see a set of smaller isla,nds \nwhich are unaliased, representing the items held in the container. These items are protected, but they \nare not inac-cessible. Figure 3 shows the dynamic use of an item by a.n object outside of the island. \nThe hea,vy lines Figure 2: Static references around an island are (temporary) references from parameters \nto ob-jects. The numbers on the objects represent their order in the calling stack, and it can be seen \nthat the external object has sent a message to the pro-tected item, which may change its state as a result. \nSince this access is through the bridge, however, it is controlled: invariants on the state of the island \nas a whole can be proven using a proof system. Also, when the methods terminate and the calling stack \nhas unwound, the situation of Figure 2 will return, and there will again be no references across the \nisland boundary. An island provides a true encapsulation of its components: all access is through a \nsingle bridge, and therefore the state of the island can never change without this change being visible \nto the bridge. Within the island, path variables (or other techniques) will in general be necessary to \ncon-struct proofs about intra-island behaviour. How-ever, the interface that the bridge presents to the \nworld need not, should not, and in fact must not ex-port references to island objects. This means that \nisland-based systems should scale: the complexity of a proof in terms of path lengths is limited by the \nsize of an island, instead of the size of an entire system. 3.3 Island Implementation We now turn to \nthe implementation of islands. First, a destructive read is needed. In addition to the previously-presented \nread access mode, two more access modes are required: unique and free. They are both orthogonal to the \nread mode, but mutually exclusive, so a variable z many be unre-stricted, reud, unique, free, read and \nunique, or read and free. The claim that the syntactic cost of is- lands is about three times the cost \nof side effect-free functions refers to this tripling of required access modes, and to a tripling of \nthe rules associated with them. The destructive read is simply an atomic opera-tion that returns the \nvalue of a variable (i.e., the identity of the object to which it points) and sets Figure 3: Dynamic \nreferences during island use the variable to nil. It will be written as J. x. This can also be extended \nto expressions: 1 (e) means that the value returned by the expression e is the identity of an object \nthat is not held elsewhere-that is, the object is not the value of any instance variable. The mode unique \nindicates that the object to which it refers has only one static reference in the entire system-i.e., \nits address is conta.ined in only one instance variable. The mode free indicates that no other references \nto the va.riable exist anywhere in the system. Clearly, there can never be a free instance variable. \nA destructive read of a unique instance variable produces a. free result, and a. free value can be assigned \nto a unique instaace varia.ble. Due to the lack of aliasing, an object held through a unique variable \nca.n only be affected by an expression in which the variable appea.rs. This is extremely useful in proving \nproperties about a system. The rules for read access have already been given. The rules for unique are \nas follows: Definition 3 (Unique) A variable whose decla-ratio12 has the label %unique is unique. A unique \nexpression is a unique variable or the result of a unique-valued function. 1. A unique variable may only \nbe assigned the re-suit of a free expression. 2. A unique expression may not be assigned to nnythirzg. \n 3. A unique expression may only be exported (as receiver, parameter or result) as unique. 4. If a method \nreceiver is unique, the12 every pa-rameter and the result must be read or unique or free.  These rules \nneed some justification. The first says that a reference cannot be urzique if it is held anywhere else, \nso an assignment to a unique vari-able caa only take place if the value being assigned is relea.sed wherever \nelse it may be held. Similarly, an expression is not unique if it is assigned to an-other variable. Access \nmodes must be protected on export, and the third rule ensures this. The least obvious rule is the last \none. Unique is a transitive property. If an object s acquaintances are aliased, then the observable state \nof the object may be unexpectedly changed, even if there is no aliasing of the object itself. Therefore, \nan object being accessed as unique must not import or ex-port any unprotected references. An unprotected \nparameter could be retained by the object, how-ever. This is shown in Part (a) of Figure 4. The light \nlines indicate the original variable references, while the heavy line is a reference retained after the \nexecution of a method. 11 has passed B as a pa-rameter of a method to C, which ha,s retained the reference; \nthereafter B is visible to C, but may be accessed without going through it. Likewise, Part (b) of Figure \n4 shows how an unprotected result 8 passed from C to A may result in exactly the same situation. Unique \ninsta,nce variables and unique parame-ters are somewhat different animals. Neither may be copied without \nrespecting the unique status, but in addition, only an instance va.ria.ble may be de-structively rea.d \nto genera,te a free reference. They are generally so similar, however, tlia,t the same access mode has \nbeen used to identify them to de-crease keyword (and concept) proliferation. The definition of free is \nsimple: Definition 4 (Free) A variable whose declaru-tion has the label %free is free. A free expression \nis the destructive read of a unique instance variable or a free variable, the result of a new method, \nor a the result of a free-valued function invocation. 1. A free variable mny only be accessed via a de-structive \nread. Free variables and values are extremely transi-tory: as soon as they are touched, they disappear. \nNote that there are no restrictions on the modes of para.meters methods with free receivers. This is \nbecause a free receiver ha,s essentially already va.n-ished over the event horizon from the original \nstate. The structure that it refers to may return in the re-sult of the function, but it will not have \nany alias in the rest of the system. In addition, we need to modify the meaning of read slightly by adding \nthis restriction, since a de- structive read has side effects: Definition 5 (Revised Read) 4. A read \nvari-able may not be destructively read. We can now relax the definition of a function slightly: Definition \n6 (Revised Function) In a function method definition, a.ll parameters (including the re-ceiver, self) \nare read or free. Finally, we have the following definition: Definition 7 (Bridge Classes) If every \nmethod of a class has the property that every parameter and function result is read, unique or free, \nthen every instance of that class is a bridge. A bridge class presents an external interface to a set \nof classes. A specification for a bridge may be given as a set of Hoa.re formulas, and the class may \nthereafter be used a.s a black box.2 Classes used within the island will not be visible to the user, \nand will be protected by the island. Bridge class instances ma.y then be used to construct larger is-lands \nand eventually entire systems. At each level, proofs will use pa,th variables to refer to visible bridge \ninstances, but not the instances within their islands. Every structure underneath an instance of a bridge \nclass is an island, but many islands are not headed by a bridge class instance. In particu-lar, every \nstructure underneath a unique instance (i.e., a,n instance referred to by a variable of unique mode) \nmust be an island. However, bridge-class islands and unique islands are different in two ma-jor ways. \nA bridge-cla,ss object may be aliased, while a unique instance may not. Also, a unique We recognize that \nthis is a very oversimplified and unre-alist,ic view of the software engineering process, and that true \nblack-box class usage will not be practical in the foreseeable fut.nre. Nevertheless, the principle still \nholds. Figure 4: Alias creation through retained references instance may later lose its uniqueness and \ntherefore the protection of its island by being assigned to a non-unique variable using a destructive \nread. By contrast, the objects underneath an instance of a bridge class are permanently protected. Islands \nhave the nice property that they are not forced upon a user. A language may provide a set of access modes, \nbut they can be ignored if the programmer so wishes, e.g. during prototyping. A set of collaborating \ncla.sses can later be turned into an island by the addition of appropriate access modes. If this is not \npossible, it could indicate that the design provides insufficient enca.psulation. 3.4 An Island Example \n Figures 2 and 3 depicted an island implementation of a container class. We now present a concrete implementation \nof this. It is a circular queue im-plementation of a bounded buffer, but it also al-lows items in the \nbuffer to be accessed. Items are inserted and removed in the normal way, but in ad- dition are associated \nwith keys. While an item is in the buffer, it may be changed by having its intern-Mutate method invoked. \nAdditionally, an object external to the island may borrow an item as a parameter to its mutate method. \nIn other words, dynamic aliasing of an instance can be permitted, while the subsequent non-aliasing of \nthe instance is guaranteed. class name DictionaryBuffer instance variable names head tail instance methods \ninitialize: size% read I temp I head c Slot new. tail t head. size do: [ temp t Slot new. head next: \ntemp. head t temp 1. head next: tail. tail -head insertKey: newKey%free value: newValue%free tail insertKey: \nJnewKey value: InewValue. tail +-- tail Next. transfer: destination%unique head transfer: destination. \nhead + head Next %read Find: searchKey%read :%read I temp I temp t head. [temp Key N= searchKey] whileTrue: \n[temp c temp Next]. Ttev internMutate: searchKey%read (self Find: searchKey) internMutate externMutate: \nsearchKey%read mutator mutate: (self Find: searchKey) class name Slot instance variable names next key%unique \nvalue%u?zique instance methods  next: newNext next t newNext %read Next :%read Tnext %read Key :%read \nl key insertKey: newKey%Jofree value: newValue%free key t J,newKey. value +-LnewValue  transfer: destination%onique \ndestination insertKey: ./key value: J.value internMutate value mutate  externMutate: mutator%onique \n mutator mutate: value From the class definitions given above, Dictio-naryBuffer is an island, but Slot \nis not. (The unreal-istic assumption is made here that DictionaryBuffer does not inherit from classes \nsuch as Object that provide methods for downright promiscuous access to priva.te parts. An island-based \nreimplementa-tion of the Smalltalk library would look very differ-ent from the present version.) An object \ninserted into the DictionaryBuffer is unique, and therefore any objects reachable from it form an island. \nThis uniqueness is preserved while the object is held in the container island, but the subsequent recipient \nof the held island structure may remove this pro-tection.   4 Conclusion An object-oriented version \nof functions that are statically guaranteed not to have side effects has been presented. Using this, \nislands have been in-troduced. Islands are of value both to the pra.g-ma.tic software engineer and to \nthose interested in formal proofs of object behaviour. To the software engineer, islands allow a set \nof objects to be nicely encapsulated. An instance of a bridge class nmy be used as a true black box: \nclients can use objects within an island, but can never do so except through a single, controllable interface. \nIslands are not forced upon users; the tool is an a.id, not a straitjacket. However, they are one more \nstep towards the holy grail of truly reusa.ble, black-box components. A component can only be a black \nbox if it comes with some sort of behaviour specification apart from the code. The most reliable sort \nof specifi-cation is one that implementations can be proven 283 to satisfy, such as a set of Hoare formulas \nor pre-and post-conditions on a method. Such a specifi-cation on a bridge class need not and cannot reveal \nthe implementation of the island it protects. It is hoped that this will overcome scaling problems that \nmake existing proof techniques for object systems inapplicable for non-trivial systems. Only sequential \nlanguages have been trea.ted in this paper. However, all of the ideas are directly applicable in some \nmodels of parallel object be-haviour, and some of the ideas are applicable in all (reasonably mainstream) \nmodels. Islands fit POOL [Ame89] particularly well. In that language, an object may only have one active \nthread of control at any point. If an object is ex-ecuting one thread (either directly within its own \ncontext, or indirectly through a procedure call in the context of another object) then any messages that \narrive are placed in a queue. As a result, an island will accept at most one external thread at a time. \nInside an island, however, any number of threads can be active. They may be persistent, or they may be \nstarted by an external thread. In any case, the requirements and protections described in this paper \nall still hold. An area for future work is the applicability of islands to models in which multiple threads \ncan be active within an instance. The problem is that unique loses its meaning: the reference may be \nheld by only one object, but two threads through tha.t object can still clash with one another. Bridges \nand islands were originally devised as a technique for making proof systems for object-oriented languages \npractical. However, other uses have also been suggested. Islands can grea,tly sim-plify some persistent-store \nand storage ma.na.ge-ment problems. An island with a unique bridge can be moved to persistent store or \nfreed with no possibility of dangling references. This presentation of access modes and their ap-plications \nhas been informal. A formal treatment requires presenting a forma.1 semantics of a la,n-guage based on \na formal model, which is beyond the scope of this forum. A complete treatment for a simplified object-oriented \nla.nguage is given in [HogSl]. References [AdBSO] [Ame89] [BC89] [Boe84] [Coo781 [GR83] [HMRC88] bwl \n[LG8G] Pierre America and Frank de Boer. A sound and complete proof system for SPOOL. Technical Report \n505, Philips Research Laboratories, May 1990. Pierre America. Issues in the de-sign of a parallel object-oriented \nlan-guage. Formal Aspects of Computing, 1(4):366-411, 1989. Kent Beck and Ward Cunningham. A laboratory \nfor teaching object-oriented thinking. In OOPSLA 89 Proceedings, pages 1-6, October 1989. Hans-Juergen \nBoehm. A logic for the Russell programming language. Tech-nical Report TR 84-593, Ph.D. thesis, Cornell \nUniversity, February 1984. Stephen A. Cook. Soundness and com-pleteness of an axiom system for pro-gram \nverification. SIAM Journal of Computing, 7( 1):70-90, February 1978. Adele Goldberg and David Rob- soil. \nSmalltalk-80: The Language and its Implementation. Addison-Wesley, 1983. Richard C. Holt, Philip A. Matthews, \nJ. Alan Rosselet, and James R. Cordy. The Turing Language: Design and Def-inition. Prentice-Hall, 1988. \nJohn S. Hogg. Formal Semantics of Opaque Objects in the Presence of Aliasing. PhD thesis, University \nof Toronto, 1991. (to appear). Barbara Liskov and John Guttag. Ab-straction and Specification in Program \nDevelopment. MIT Press, 1986. [LG88] John M. Lucassen and David K. Gif-ford. Polymorphic effect systems. \nIn Proceedings of the Fifteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Lan-guages, \npages 47-57, January 1988. PWW Bertrand Meyer. Object-oriented Soft-ware Construction. Prentice-Hall, \n1988. [Rey 781 John C. Reynolds. Syntactic interference. In Conference control Record of of the Fifth \nAnnual ACM Symposium on Principles of Programming Languages, January 1978. [Str86] Bjarne Stroustrup. \nThe C-t-+ Program-ming Language. Addison-Wesley, 1986. [We@71 Peter Wegner. based language 87 Proceedings, \nDimensions of object-design. In OOPSLA October 1987. 285 \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "John Hogg", "author_profile_id": "81100540839", "affiliation": "Bell-Northern Research, Ottawa, Ontario", "person_id": "PP31079688", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117975", "year": "1991", "article_id": "117975", "conference": "OOPSLA", "title": "Islands: aliasing protection in object-oriented languages", "url": "http://dl.acm.org/citation.cfm?id=117975"}