{"article_publication_date": "11-01-1991", "fulltext": "\n Re-engineering of old systems to an object-oriented architecture. Ivar Jacobson Fredrik Lindstriim Objective \nSystems SF AB Torshamnsgatan 39 BOX 1128 S-164 22 Kista, Sweden Phone:+4687034541 Fax: +46 8 751 30 96 \nAbstract Most of our present-day information systems have The basis of our technology is system development \nbeen in use for a long time. They have been developed using object-oriented technique. The technology \nimp-using the system development methods, programming lies that occurrences from the application domain \nare tools, data base handlers, etc. that were available when modelled as objects and associations between \nobjects. the development work started. Even if the systems are The resulting system model will be used \nas a mapping adapted to changed requirements from the surrounding between the occurrences of the application \ndomain and world, the basic structure and the original technical and methodological ties have been retained. \nOur goal programming elements in the existing system. is to show how an object-oriented development met-hod \ncan be used to gradually modernize an old system, Changes in the objects of the application domain can \ni.e re-engineer the system. We do this by showing how be traced directly to the same objects in the model. \nthree typical cases of re-engineering are related to Different discussions about changes in the system \nwill object-oriented development. The technique is based therefore be more precise. For example, if a \nnew type on experiences from real projects. of communication protocol shall be used, you can easi- ly \nidentify which program elements in the existing sys- 1. Introduction tem are candidates for a change. \nMore and more system owners face the following que-The technique is founded on two assertions: stions: \nHow do you build a model of your system that 1. A change in the application domain is fre- enables you \nto reason about modifications? How do quently local in the sense that it concerns a you gradually replace \nparts of the system? How can behaviour or an occurrence with a clear deli- you integrate a modern programming \ntechnique such mitation. as object-oriented programming into an existing sy-2. An object-oriented system \nmodel can be used stem? This paper will summarize a technology that to describe a system designed in \na non object- will answer these questions. oriented manner. Permission to copy without fee all or part \nof this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. @ 1991 ACM 89791-446-5/91/0010/0340...$1.50 \n 00PSLR 91? pp. 330-350 It is generally unrealistic to replace an old system by a completely new system; \nsuch a change requires too much resources. You must find ways of gradually rep- lacing older system parts \nwithout completely losing the investments made so far. Our basic principle is that an old system must \nbe modernized gradually. Figure [l] shows how changes successively can carve out the original system. \nEventually, the entire system will be replaced. The rest of this paper is organized in the following \nway. First, a presentation of re-engineering, its goals and definitions. Next, we introduce a combination \nof object-oriented system development and re-enginee- ring. Third, experiences from three projects are \npresen- ted. Last, a conclusion. Throughout this paper we assume a familiarity of concepts like object, \ninheritan- ce, encapsulation, analysis, and design.  2. Re-engineering. All systems have a limited lifetime. \nEach implemented change erodes the structure which makes the following change more expensive. As time \ngoes on, the cost to implement a change will be too high, and the system will then be unable to support \nits intended task. This is Figure [ 11.We gradually want to replace an existing implemen- tation with \nan object-oriented. true of all systems, independent of their application domain or technological base. \nBefore the system reaches this state something must be done. Depending on its position in a changeability \n- business value matrix one of four actions is possible, see figure [2]. We will assume that the old \nsystem is difficult to change but has a high business value, in this case we choose to re-engineer the \nsystem. A system with a sa- tisfactory degree of changeability or a low business value either does not \nneed the re-engineering invest-ment or is not worth it. What then is re-engineering ? Re-engineering \nis the process of creating an abstract description of a system, reason about a change at the higher abstraction \nlevel, and then re-implement the sy- stem. Re-engineering is subsequently defined in terms Changeability \nI Maintain Enhance I ---I------Discard 1 Re-engineer Business value Figure [2]. Decision matrix, what \nto do with an old system of relations between different levels of abstraction. Intuitively and similar \nto (1), this can be expressed with the following formula: Re-engineering = Reverse engineering+ A + Forward \nengineering. The first element of t-e-engineering, Reverse enginee- ring , is the activity of defining \na more abstract, and easier to understand, representation of the system. The second, A represents change \nof the system. Changes have two major dimensions, change of func- tionality and change of implementation \ntechnique. The third, Forward engineering (i.e normal system development) is the activity of creating \na representa- tion that is executeable, e.g. finally a program written in Smalltalk or C. Since the concept \nof forward engi- neering is familiar to most readers we will not discuss it further in this section. \n 2.1. Reverse engineering The goal of reverse engineering is to capture an under- standing of the behavior \nand the structure of the sy- stem and be able to communicate this to others. To do this we need at least \nthe three following things: a> A concrete graph that describes the compo- nents of the system and their \ninterrelationship. b) An abstract graph showing the behavior and the structure of the system. c> A mapping \nbetween the two, i.e how somet- hing in the abstract graph relates to the concre- te graph and vice versa. \nThe abstract graph should be free of implementation details. For example, mechanisms for persistent stora-ge \nor partitioning into processes should not appear on this graph . The concrete graph must, on the other \nhand, show these details. The mapping between the two should tell us how the ideal world of analysis \nis implemented the way the concrete graph describes.  2.2. Change From the perspective of re-engineering \nwe classify changes into two orthogonal dimensions, change of functionality and change of implementation \ntechnique. The first is the most common of the two but a change of implementation technique seems to \nbe in increasing demand, see (2) and (3). A change of functionality comes from a change of the business \nrules. Thus, modifications of the busines rules results in modifications of the system. Change of func- \ntionality doesn t affect how the system is implemen- ted, i.e how the forward engineering is carried \nout: an end user of a system need never know if the system is implemented with Smalltalk or C. A new \nimplementation technique of an information management system could mean that the organization will use \nC++ instead of C, or use an object-oriented database management system instead of a relational one. Needless \nto say, a change of implementation tech-nique is not an easy process, even if there are tools that can \ndo part of the job automatically. The dimensions are orthogonal in the sense that it is meaningful to \ntalk about changes in one without changes in the second. We can change the functionali- ty without changing \nthe implementation technique and vice versa. When only part of the system changes its implementation \ntechnique it is necessary to enable communication between the two parts. Different lang- uages and operating \nsystems are more or less supporti- ve in this task, a basic functionality that must be sup- ported is \nthat an application can be called on request from another application. (General reasoning about this \nis found in (4)). 2.3. A small example Let us consider an invoice system as a small and trivial example \nto illustrate the process of re-engineering.We assume that the only available description of the sys- \ntem is a number of files of C-code and a database description in SQL. The changes involve both functionality \nand implementation technique. The change in functionality is that two limitations of the current system \nhave to be removed. It only allows one address per customer and a user can only work with one invoice \nat the time. The change of implementation technique will be to rewrite part of the system in C++. The \nfirst step, reverse engineering, means that we identify how the components of the system relate to each \nother and then create a more abstract description of the system. The relationships between components \nare identified, e.g. the dependencies between the files and the C-functions, the C-functions and the \ndatabase descriptions, etc. After that, an abstract description (in the sense that we deliberately leave \nout implementa- tion relevant information) of the system is created, e.g. a dataflow diagram for the \nC-functions and an entity relationship model of the database description. The process of creating a more \nabstract description can in theory be repeated as many times as necessary. Practi-cally, it is enough \nwith two levels (design and analy- sis). After the first step, we will have an abstract model that shows \nthe business rules of the invoice system and a number of mappings between the different levels of abstraction. \nPart of the abstract model represents how invoices are regulated by the legal system, other parts represent \nhow the organization that once ordered the system wanted the invoice system to work. The map- pings comprise \nthe design decisions that occur when transforming an abstract representation to a concrete one. The second \nstep, reasoning about the changes in func- tionality, is done at a more abstract level. Without the abstract \nmodel we would have to reason with low-le- vel non-problem domain concepts and make state-ments like \nadd one more table that contains the refe- rences between customers and addresses . Instead, at the higher \nlevel of abstraction, we can say change the association between the entities Customer and Ad- dress . \nNext, we redesign the system from the abstract repre- sentation to the more concrete representation, \ni.e for- ward engineering. In this process we must take the changes of implementation technique into \nconsidera- tion. Since we only change the technique for part of the system we have to answer the question \nWhere should the border between the old and the new system be ? When we formulate the answer we have \nto consi- der what mechanisms there are available that make the communication possible. When implementing \nthe sy- stem we also must take all recaptured design decisions into consideration. To summarize, when \nwe re-engineer a system we need: a> A representation of the system some level of abstraction. as it \nis , at b) A logical representation of the system, at a le- vel that makes it possible to reason about \nchanges in functionality. c> A way to capture design decisions, or knowing why the system is implemented \nthe way it is. d) A technique that enables two different mentations to communicate. imple- d A technique \nto delimit the part of the system that we want to explore (without this it is im- possible to re-engineer \na large sytem)   3. Different scenarios for re-engineering . This chapter outlines a combination of \nobject-oriented system development and re-engineering. Since there are many issues involved in the process \nwe introduce the necessary concepts one at the time using three dif- ferent scenarios. Scenarios that \ncan be combined in a straightforward manner. We will describe re-enginee-ring with: 1. A complete change \nof implementation techni-que and no change in the functionality. 2. A partial change in implementation \ntechnique and no change in functionality. 3. A change in functionality. 3.1. Complete re-engineering \nwith no change in functionality. A complete change of implementation technique will seldom occur for \na large system. Nevertheless, we will use the scenario to illustrate part of the re-engineering process, \nnamely reverse engineering and introduce some concepts. Figure [3] shows an overview of the transformation \nprocess. In the figure, the rectangles describe different representations of the system. The dark grey \nrepresents the existing system, the light grey  l/O0 O 0 O0\\ Figure [3]. The figure describes how \nall of the old system is transformed into an object-oriented implementation. represents the analysis \nmodel, and the middle grey rep resents the object-oriented implementation, i.e the lighter a rectangle \nis, the more abstract it is. Rectan- gles inside the existing system represent the primitive description \nelements(defined in 3.1.1). Circles inside the analysis model represent analysis objects. Rectan- gles \ninside the object-oriented implementation repre-sent design objects. The main steps of the re-engineering \nprocess are: 1. Prepare an analysis model. Described in 3.1.1. 2. Map each analysis object to the implementa- \ntion of the old system. Described in 3.1.2 3. Redesign the system using a forward enginee- ring technique \nfor object-oriented system de- velopment. The last step of this re-engineering scenario is to implement \nthe analysis model. This is achieved through a forward enginee-ring process as described in (5).  3.1.1, \nme an analysis model The first step, prepare an analysis model, requires that we assimilate the existing \ninformation about the sy- stem. The existing information has many different forms, e.g. requirements \nspecifications, user operating instructions, maintenance manuals, training manuals, design documentation, \nsource code files, and database schema descriptions. We call them here description elements. An important \nsubset of the description ele-ments is the set of description elements that represent the true system, \ne.g. source code or documentation that is consistent with the source code, these are called primitive \ndescription elements. What is then a primitive description element? Natural- ly, their nature depends \non the quality of the documen- tation. In the worst case, e.g. when we only trust the source code, their \ngranularity is on the level of met- hods of a class. D is the set of all description elements. DpntiliVC \nis a subset of D, where DRimirivc represents a description of the system that is consistent with the \nsource code. From the set of description elements we prepare an analysis model, see figure [4]. This \nis done by using the critetias for finding objects that are described in the object-oriented method we \nuse, e.g. see (5), (6), (7), (8). The resulting analysis model can be regarded as a graph, we have a \nnumber of analysis objects Ai that are connected to one another with a set of directed edges, E. The \nedges have different semantics in the analysis model, but these are ignored at this stage (they all imply \nsome kind of dependency of the termi- nal object). Reconstructing analysis Analysis model of the system \nExisting documentation Figure [4]. Preparation of the analysis model. The analysis model is represented \nby a directed graph (A, E, f(ai , aj)). A, the nodes, is the set of all analysis objects identified from \nthe description elements, E is the set of all arcs between the nodes, and f is a function that associates \nan arc with an ordered pair of nodes. The function represents a dependency between the analysis object. \n 3. 1.2. Map each analysis object to the implemen- ption of the old svstem, Part of the reverse engineering \nprocess is to have a mapping between the analysis model and the system. We have two constraints on the \nanalysis model: a> All analysis objects must be motivated by at least one primitive description element. \nWe can express that with is-motivated-by, a map- ping from the analysis model to the set of pri- mitive \ndescription elements. For each analysis object A. there mus exist at least one element D,,,, i such L \nthat is-motivated-by(Ai,D,m,) exists. b) All edges in the analysis model must be moti- vated by at least \none primitive description ele-ment. This is also expressed with is-motivated-by. For each edge E, of \nthe analysis model, there must exist at least one element D,.j such that is-motivated-by(E,, DRimj) exists. \n Also abstract analysis objects and inheritance associa-tions can be motivated by description elements. \nWe use the analysis objects, the description elements (both primitive and non-primitive), and the guidance \nfrom the experts of the system to map the analysis objects to the implementation of the old system.This \nis comparable with the normal process of analyzing a system, except for the vast amount of information. \nAfter this step we have a situation as described in figu- re [S]. 3.2. Partial re-engineering with no \nchange in functionality. ,fXd system \\ Figure [5] All analysis objects and edges must be motivated by \nat least one primitive description element. Note that they also can be motivated by non-primitive description \nelements. The goal is to make the object-oriented application be- lieve that the whole system consists \nof objects, the process is visualized in figure [6]. The thick arrows symbolizes the transformations \nbetween different le-vels of abstraction. The thin lines shows the communi- cation between the object-oriented \nsystem and the remaining part of the old system. The main steps of this process are: 1.  2.  3. 4. \n 5. 6.  5.1 5.2 Identify the part of the system that will be reimplemented using object-oriented techni-que. \nPrepare an analysis model of the part to be exchanged and its environment. Map each object to the old \nimplementation of the system . Iterate the previous steps until the interface between the part to be \nexchanged and the rest of the existing system is acceptable. In parallel: Design the new subsystem and \nits interface to the rest of the old system. Modify the old system and add an interface to the new subsystem. \nIntegrate and test the new subsystem and the modified old system. Figure [6]. Part of the system is \nimplemented with an object-oriented technique. The thick arrows symbolizes the transformations between \ndifferent levels of abstraction. The thin lines shows the communication between the object-oriented system \nand the remaining part of the old system. 3.2.1. Identifv the Dart of the old system that will be reimtAemented \nusing obiect-oriented techniaue, Two subsets are created. is D,, of DRimitivc The first which contains \nthe elements that the new subssystem exchange. The second subset is DEnv, which contains the neighbours \nof D,. A neighbour is an element that: 4 isn t already included in D,. b) is adjacent to elements in \nDxin a dependency graph, i.e either a terminal or a initial node. Thus, there must be a graph that shows \nthe dependen- cies between the primitive description elements. The graph is either implicit, i.e exists \nin the minds of the technical experts, or explicit, i.e exists in a readable form. In an ideal situation, \nwe would like to have the complete graph. However, due to the size of such a graph we only make it explicit \nfor the part we need to study. A readable form is always preferable. Although advan- ced tools and techniques \nexist, technical experts will always make the task substantially easier. A directed graph (DRimiliVC, \ng(D,, E,, D,)) is created. DRitilivc,the nodes, is the set of all primitive description elements, E,is \nthe set of arcs between the nodes, and g is a function that associates an arc with an ordered pair of \nnodes. The function represents a dependency between the primitive description elements.  3.2.2, Prenare \nan analysis model of the part to be exchanged and its environment. This step is similar to the corresponding \nstep in the previous scenario. The difference is that we only have to concentrate our efforts of understanding \nthe system to a limited part of D. Thus, prepare an analysis model representing the union of D, and D,. \n 3.2.3, Map each analysis object to the implemen- I&#38;ion of the old svstem, We use the function is-motivated-By(x, \nDJ to map the objects and edges of the analysis model to the ele- ments in DRimitivc. mo- We can then \ndivide the analysis del into two subsets: a) A,, which represents the part of the model that defi- nitely \nwill be implemented with the new technique. b) A, analysis objects will serve as wrappers of the old \nsystem. They represent objects that A, is related to. 3.2.4, Evaluate the interface between the part \nto be exchanged and the remaining nart of the old system, When we have decided what part of the old system \nthat we want to change, we can create an interface be- tween the new and the old system. At this stage, \nwhen a better understanding of the old system is reached, it is time to evaluate the interface, i.e we \nhave to exami- ne the partition of DRimitin. Through changing the set Dx it is possible to get a set \nD , that, through DIPmv, gi-ves a better interface between the old and new subsy-stems. When we do this \nwe have to repeat the previous steps until we have an interface that is acceptable in terms of implementation \ncost. During the evaluation of the interface we must take technical aspects in consideration, e.g. see \n(9) who describes the technical problems that occurred when an object-oriented language was built on \ntop of an exi- sting system. In general, most of these aspects arises from the problem of communicating \nthe state of one instance between the new and the old subsystem. The basic problem is atomicity of transactions, \ni.e no inter- mediate states of the instance should be visible for its clients. As a goal, the cut between \nthe subsystems should be made so that only one of them manages the state of an object and works as a \nserver to the other subsystems. Despite this goal, implementation restric-tions may make it unattainable. \nIn that case, we must allow multiple copies of the instance. 3.25 Design the new subsystem and its interfa- \nge to the old system, The new system is implemented as the object-oriented method prescribes. Objects \nin AEnv are implemented with a set of classes that let the object communicate with the old system, see \nfigure [7]. Figure [7]. The objects half-b&#38;ed in the interface encapsulate the old system. lnls way, \nme olher object; OK lhc application only sees objects. The objects of A, behave like objects from the \nnew subsystem and like old software from the old subsystem Thus, the encapsulation property of objects \nmakes it possible to successively move the plane further and further into the old system. This way it \nis possible to gradually replace the old system with an object-orien- ted system.  3.2.6, Modify the \nold system and add an intex-fa- ce to the new svstem. In parallel, we have to modify the old system. \nAll parts that communicate with D, , i.e. calls procedures or uses data in D, , are replaced. Instead \nof their original code, they have to use the interface to the new system. The set D, contains these parts. \nAlso, we must modi- fy the parts in D, so that a call or an access to them results in an error. An activation \nof them means that we have missed redirecting communication meant for the new subsystem. 3.3. Re-engineering \nwith change of functionality. This scenario is a normal forward engineering process. We add changes in \nfunctionality in the analysis model and implement them using the object-oriented techni-que. The result \nof this process is described in figure @I. The main steps of the process are: 1. Change the analysis \nmodel according to requi- rements. 2. Design the system. Only the first step is described, for a description \nof the second see (5). Figure [8]A change of functionality. In this case an addition is depicted. 3.3.1. \nChange analvsis model accordinP to reauirements We change the analysis model in accordance with the requirements \non changes in functionality. New objects and edges are added as described in the normal for-ward engineering \nprocess. Objects identified from the old system either are deleted or receive new attributes and edges. \nThus, the resulting analysis model can be partitioned into three subgraphs, one that contains all the \nnew objects, one that contains the changed ones, and one that contains the unchanged. We then have three \ndifferent subsets of the analysis model: a> A Ncw, which represents the new objects. represents the elements \nwith a b) J%f&#38; which new functionality. c> A Nobtiac., the elements which represents not af- fected \nby the change in functionality.  4. Case studies We have used ObjectOry to re-engineer a number of systems, \nincluding two major systems. The first sy- stem was a military system for handling spare parts, and the \nsecond system was a telecommunication sy-stem. One of the others, a traffic control system is also presented. \nOur experiences with re-engineering come from using ObjectOryTM (see (5)), an industrial software develop- \nment process. ObjectOry is a mature object-oriented technique with many important features for supporting \nthe reverse engineering process. Particulary, one uni- que concept of ObjectOry, use cases, have been \nan ex- cellent tool for reverse engineering. Briefly, a use case is a sequence of user interactions with \nthe system. Its purpose is to define a typical way of using the system. In the context of reverse engineering, \nwe explore an old system with use cases. That is, together with an ex- pert of the old system, the system \nanalyzer identify a use case. Then, they follow the use case through the existing documentation of the \nsystem. Another important aspect of ObjectOry is the separa- tion of analysis and design. As a result \nof the projects with re-engineering, our belief in this has been enfor- ced. With an analysis model that \nclearly, without imp- lementation details, captures the business rules of an organization, it is much \neasier to understand and change a system. The role of the design model is to capture all the necessary \nmodifications dependent on the implementation environment. Today, all the sy- stems we have reversed \nor re-engineered have only been documented with at most a design model, They have completely lacked an \nanalysis model. 4.1. Spare part system The goal of the first project was to demonstrate practi-cally \nhow an object-oriented system development met-hod can be used when designing distributed informa-tion \nsystems. The example used for the work was DELTA, a system for redistribution of stock. The sy- stem \nis used by all defence branches in the Swedish Armed Forces. The project was executed on assign- ment \nfrom the Defence Materiel Administration FMV, and our work amounted to about 4 to 5 manyears. The re-engineering \nhas been done down to class level on a smaller part of the system that concerns spare parts, for example \ncustomer orders and redistribution of material between storage places. These functions have been implemented \nin an object-oriented environ-ment including an object-oriented data base. We have also specified and \nimplemented the changes required to make the system a geographically distribu-ted system. The same DELTA \nsystem has been used in a parallel study to demonstrate how a conventional, form-based user interface \nin a terminal environment can be exten- ded with window handling, graphics, and direct mani- pulation \nin a personal computer environment. The main categories of the description elements of the project were: \nBefore the project had started, the organisation respon-sible for the system had planned to replace the \nwhole system at once. However, after evaluating the initial results of the project they changed their \nminds. The effort to replace the whole system was found too large. Instead it was decided that a way \nof gradual replace- ment must be found. a> database schemas b) Cob01 code c> user manuals d) interviews \nwith users and technical experts 4.2. Telecommunication system The communication system was reverse \nengineered in a small project of about 1 manyear. The original work of the system was about 120 manyears \nand it was de- veloped with an object-based technology. The purpose of the project was to make an analysis \nmodel that will be used to restructure the system. After the project, the organisation responsible for \nthe system estimated that a complete reverse engineering process would take about 10 manyears. Due to \nthe understandibility of the analysis model, they also concluded that the model should make it possible \nto reduce the time to get expe- rienced system engineers from 5 to 2 years. 4.3. Traffic control system \nBasically, the traffic contol system involves three dif- ferent systems. A resource allocation system, \na traffic control system, and a communication system. Histori- cally, the traffic control system was \ndeveloped first, then the resource allocation system, and last the com- munication system. Related to \nfigure [2], the traffic control system is the most difficult to change, closely followed by the re- source \nallocation system. But, the resource allocation system has a high business value and it depends on the \ntraffic control system. Therefore, the company has choosen to re-implement part of the traffic control \nsy- stem and part of the resource allocation system. The communication system is left untouched since \nits de- gree of changeability is considered sufficiently high. The project has both a partial change \nof implementa- tion technique and a change in functionality. To get a complete understanding of the three \nsystems we stu- died functions that spanned over all of the systems . After that, we created an analysis \nmodel and its motivations,see figure [9]. Resource allocation system Traffic control system Communication \nsystem Figure [9]. The delimitations and the objects of the trafic control system. The desired result \nis found in figure [lo]. Part of the resource allocation system and part of the traffic con-trol system \nwill be implemented with object-oriented technology. The change is that the new technology will only \nbe used for a part of the traffic control sy-stem, the other part will be left out. Thus, we have to \ncreate an interface between the different subsystems and modify them accordingly. On the other hand, \nthe communication system will not be effected by any changes and can be left as it is. Modified Resource \nUnchanged Communication system Figure [lo]. The desired result of the re-engineering of the resource \nallocation system. Based on these projects, we estimate that it requires l/ 10 - l/20 of the total development \ntime of the old sys- tem to create an analysis model. That is, if the total development time of a system \nis 10 manyears, the ana- lysis model takes about 0.5 -1 manyear to reverse eng- ineer. Of course this \nfigure is uncertain, but we believe that the magnitude is correct. 5. Conclusions The life span of an \ninformation system comprises spe-cification, design and maintenance. The maintenance phase dominates \nin time and often also with respect to resources. During this phase the system is subjected to a number \nof changes and additions. The gap between the older technology in the system and the new techno- logy \nthat becomes available increases successively. Changes in the activities of an organization also mean \nthat systems grow old. Gradually the system approaches a limit where it no longer is cost-efficient or \neven technically motivated to continue the maintenance. But the cost of enforcing the required changes \nis usually very high. This poses a serious dilemma for system managers and similar per- sonnel. A possible \nway out of this dilemma is to define well delimited system parts that are candidates for modernization. \nProvided this delimitation is made in an efficient manner, replacement can be made with moderate changes \nin the existing system. This is where re-engineering can help. We have described a practical method for \nre-enginee- ring. The method is based on an object-oriented mo-delling. We have described how the work \ncan be divi- ded into a number of steps from analysis to design and finally design and testing, i.e. \nthe method can be per- formed in a systematic manner. We have achieved the following: In a simple manner \nand with limited efforts you can make a model of an existing system. By means of the model you can rea- \nson about where a change can be made, its extent and how it shall be mapped on the existing system. The \nnew model is object-oriented and can serve as a basis for a future development plan. The extensions can \nbe designed as additions outside the existing systems with a minimum of adaptations in the form of interfaces. \nToday, we think that the subject of re-engineering is too focused on tools. Despite their importance \nthey are not sufficient. We think it is necessary to change the focus of re-engineering to the complete \nlife-cycle of the system, i.e. try to incorporate re-engineering as a part of a development process, \nand not as a substitute for it. In the long run, we want to industrilize reenginering techniques so \nthat they will be incorporated as a part of ObjectOry. We belive that Objectory has a good foundation \nfor this. Besides beeing object-oriented, it is based on a mature forward enginering process (see 5). \nThis means that a new system will keep a high degree of changeability. 6. References (1) J. Chikovsky \nand J. H. Cross. Reverse enginee-ring and Design Recovery: A Taxonomy. . IEEE Soft- ware 1990;(January):13-17. \n (2) Economist. How computers can choke compa-nies . 1990 June 9:71-72. (3) J. Duntemann and C. Marinacci. \nNew objects for old structures . Byte 1990 April:261-266. (4) P. Zave. A Compositional Approach to Multipara- \ndigm Programming . IEEE Software 1989;(Septem-ber):15-25. (5) I. Jacobson. Object Oriented Development \nin an Industrial Environment. . In: Proc. OOPSLA. Orlan-do, Florida.: ACM Press, 1987: 183-191. (6) \nP. Coad. Object-Oriented Analysis.Englewood Cliffs, New Jersey: Prentice-Hall, 1990:232. (E. Your- don, \ned.) Yourdon Press Computing Series (7) G. Booth. Object Oriented Design.Redwood City, California: The \nBenjamin/Cummings Publishing Com-pany, Inc., 1990:580. (G. Booth, ed.) The Benjamin/ Cummings Series \nin Ada and Software Engineering (8) R. Wirfs-Brock, B. Wilkerson and L. Wiener. De- signing Objet-Oriented \nSu@vare.Englewood Cliffs, New Jersey: Prentice-Hall, 1990:341. (9) C. Dietrich, L. R. Nackman and F. \nGrater. Saving a Legacy with objects . In: Proc. OOPSLA. New Or- leans: ACM Press, 1989: 77-83.   \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "Ivar Jacobson", "author_profile_id": "81100030692", "affiliation": "Objective Systems SF AB, Torshamnsgatan 39, BOX 1128, S-164 22 Kista, Sweden", "person_id": "P117558", "email_address": "", "orcid_id": ""}, {"name": "Fredrik Lindstr&#246;m", "author_profile_id": "81332512924", "affiliation": "Objective Systems SF AB, Torshamnsgatan 39, BOX 1128, S-164 22 Kista, Sweden", "person_id": "PP31028943", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117980", "year": "1991", "article_id": "117980", "conference": "OOPSLA", "title": "Reengineering of old systems to an object-oriented architecture", "url": "http://dl.acm.org/citation.cfm?id=117980"}