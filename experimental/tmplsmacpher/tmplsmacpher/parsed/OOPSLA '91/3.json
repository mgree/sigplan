{"article_publication_date": "09-01-1991", "fulltext": "\n Phoenix, Arizona 6 - 77 October 7997 Organizer and moderator: Tom Wisdom Hewlett-Packard Co. Developing \nHP s Network Advisor using Smalltalk in a Large Project Team  Introduction We will describe our experience \ndeveloping software for a new Hewlett-Packard product called Network Advisor in Smalltalk with a large \nteam of programmers. We will describe how we have overcome some major obstacles to developing Smalltalk \napplications among a large team of programmers and some of the benefits and drawbacks of our approach. \nSpecifically we will describe how we dealt with such issues as Reuse, Parallel Development, Performance, \nTesting, and Configuration Management. First we will describe the scope of the project by giving you \nan overview of the product, the project team, and the underlying system architecture. Next we will describe \nthe challenges we faced using Smalltalk in a large project and the approaches we used to overcome them. \nFinally, we will conclude with a summary of our experience and what we will do differently in the future. \n Project Scope Product Description Network Advisor is a new generation Protocol Analyzer that can analyze \nboth 802.3 Ethernet and 802.5 Token Ring networks. The target customer for this product is network administrators \nwho must maintain small to large networks on a daily basis. The instrument can be used to troubleshoot \nnetwork problems and tune network performance. A key Addendum to the Proceedings OOPSLA 91  Network \nAdvisor feature of this product is the Fault Finder expert system that can assist the user in diagnosing \nnetwork problems. The rule-based expert system develops hypotheses from observed or user-entered symptoms \nand then proves or disproves these hypotheses by executing measurements until a conclusion is reached. \nProject Team The project consisted of multiple project teams responsible for both hardware and software \ndevelopment. Few of the software engineers had much experience with object-oriented design or programming \nso a Design Team was formed at the start of the project to do the initial architecture and design. An \nexperienced 00 designer was brought in to assist this team. He was a strong advocate of application frameworks \nand 00 programming and convinced the team and management to use these technologies. The team picked Smalltalk \nas a prototyping language. A successful prototype was built in a few months and the management team asked \nthe Design Team to pick the implementation language for the product. Because of the time to market pressures \nand buoyed by their perceived increased productivity using Smalltalk, the Design Team decided to gamble \non Smalltalk as an implementation language. System Architecture The product consists of two major subsystems \nwhich communicate over the PC AT Bus using a proprietary light-weight transport protocol called Inter-Environment \nProcess Communication (IEPC). The Analysis Real-Time (ART) subsystem is the front-end processor that \nis responsible for capturing data off the network and decoding protocol fields and computing statistics. \nThis software was written in C++ and executes on a RISC processor running a proprietary real-time operating \nsystem. A FORTH interpreter provides a command interface to the ART subsystem from the General Purpose \n(GP) subsystem. The GP subsystem is the I/O processor that is responsible for running the User Interface \n(UI), device IfO, and overall system control software. This software is written almost entirely in Smalltalk \n(except for some low level primitives written in C) and executes on an Intel 386SX processor running \nMS-DOS . Applications written for this instrument have an ART component and a GP component. The ART component \nis responsible for real-time parsing or statistical computation on the frames. The GP component is responsible \nfor presentation, configuration, and control. In some cases, the GP component also performs some additional \ncomputation on the data before it is displayed. Challenges Faced in a Large Smalltalk Project Smalltalk \nhas a reputation for being a good environment for developing in-house applications. These are usually \nsingle person or small team projects where code is shared at the source code level only (i.e. via fileIns). \nThis project however required a large number of software developers due to the large amount of functionality \nprovided across a diverse set of communication protocols. The areas we had to overcome in order to develop \nsoftware for a large project in Smalltalk are many of the same areas that come up on any large software \nproject. The way we dealt with these issues was very different from the way we have dealt with them in \nthe past (when we were using procedural languages like C). In particular we will describe how we dealt \nwith the following issues: 1 Code Reuse: to increase productivity. 2 Vague Requirements: due to the delegation \nof the requirements task to a large project team that was already in place. 3 Developing many applications \nin parallel with the system software: due to time to market pressures. 4 Managing software releases to \nvarious teams: to insure that the correct versions of code and related files get released.  Our Approach \nto the Challenges There <are four prim ary factors that enabled us to successfully overcome the issues \nmentioned above: 1 System and Application Frameworks 2 Rapid Prototyping 3 The Smalltalk Interactive \nDevelopment Environment 4 A Smalltalk Team Programming Tool System and Application Frameworks A framework \nfor us meant that the skeleton of the application was already written and the programmer has to add the \nmeat of the specific functionality that this application is to provide. A framework is like an abstract \napplication where the common structure and functionality of a set of applications is collected together \ninto a set of classes, We also developed class libraries of functionality that provide complete functionality \nto be used by the application programmer. We organized our project team into a Systems Software group \nand an Applications Software group. The Systems group provided the base system features such as Persistent \nObject Store, File System, IPC, Database, Instrument Setup, Error Handling, Resource Management, and \nthe Windowing system. They also provided the Measurement Framework which is the basis for some more specific \napplication frameworks. It provides measurement configuration, control, and inter-measurement communication \nfunctionality. The specific frameworks extend the Measurement Framework to provide the ability for an \nApplications programmer to easily write a Decode, Statistical, or Canned Test measurement. The Decode \nFramework provides such a complete framework that the programmer only has to provide an ASCII file of \nfield identifier and format descriptions. The Fault Finder framework provides a framework for writing \nknowledge applications for troubleshooting network problems. A Knowledge engineer writes applications \nby providing rules in a Prolog-like language and writing any Canned Tests needed by these rules Rapid \nPrototyping and Rapid Redesign We iterated in on what we were trying to build via rapid prototyping. \nThe process we used was to first describe the problem we were trying to solve, then propose a variety \nof solutions (designs), pick the best design, prototype this design, solicit feedback on the prototype, \nredesign based on this feedback, and then iterate until we were satisfied with the result. Object-oriented \ndesign allowed us to quickly 9-11 October 1991 Phoenix, Arizona underst and the impact of different design \nalternatives. Smalltalk Interactive Development Environment The interactive development environment increased \nour implementation and debugging productivity tremendously due to the shortened edit-compile- debug cycle. \nImplementation and debug were usually the smallest percentages of our schedules. This allowed us to use \nrapid prototyping to try out several different design and implementation alternatives. This was important \nsince we had vague requirements in several areas and people did not know what they wanted exactly. So \nwe would prototype a piece of functionality and ask Is this what you had in mind? . If not, we would \nredesign based on their feedback. Smalltalk Team Programming Development Tool A team programming development \ntool called ENVY/Developer from Object Technology International enabled us to overcome many of the obstacles \nto developing in Smalltalk in a large team It gave us a network database that allowed all programmers \naccess to the entire project s source and object code via browsers. This facilitated reuse since it was \nvery easy to look at, search for, and cross reference classes and methods. ENVY allows ownership of classes \nto be assigned to specific users. The owner controls the definition of the class. This prevents uncontrolled \nchanges to class definitions. ENVY uses the concept of applications to organize sets of related classes. \nSometimes ENVY applications mapped directly to a Network Advisor application, but usually an ENVY application \nwas just a large module of an application. Each ENVY application has a mrlnager and members. The manager \ncontrols versioning and releasing of the application while members work on classes and methods within \nthe application. This was a very useful way to organize a large system because it clearly delineated \nmajor pieces of functionality and who was working on them. ENVY has a very robust version control system \nbuilt-in to the tool. Every method, class, application, and configuration map has a time stamp. All versions \nof the aforementioned objects are kept in the database. Therefore it is very easy to browse changes with \na previous version to see what has changed. Class, Application, and Configuration Map editions can be \nversioned. The edition then becomes unchangeable. This allows for software releases of specific versions \nof code. Scratches are a useful way for programmers who are not members of an application to try out \nchanges to an application without affecting other users of the application. They can then tell the application \nmember who owns the code to load the patched fixes. Configuration Maps are a way to specify which applications \nand what versions of those applications go together for software releases.  Conclusion Frameworks are \nworth the investment. They promote reuse and allow programmers to focus on the application solution instead \nof on the infrastructure. We found it difficult to build good frameworks on the first pass. You have \nto build several applications on the framework to know what needs to be changed in the framework. It \nis an iterative process. A lot of the productivity benetjlts were eaten up by the extra effort spent \nbuilding reusable components, the steep learning curve for Object-Oriented design and programming, and \nbuilding some components that should have been bought. We are just beginning to reap the benefits of \nthis investment. Our second software release is progressing ahead of schedule with a substantial amount \nof new functionality and performance improvements in only 4 months. Maintainability is very good. Engineers \nexperienced with the tools and environment have been able to pick up other people s code quickly and \ncontribute in a short amount of time.  Futures One of the possible future enhancements to the software \nis to port to other operating systems and window platforms. This should be relatively straight forward \nsince Smalltalk currently runs on several operating systems and window platforms. This allows us to take \nadvantage of the latest hardware and software advances on different platforms. Our investment in frameworks \nwill pay off here as well because they isolate the applications from the underlying windowing system \ndetails thereby reducing the porting costs. We will continue to polish our frameworks as we learn from \nthe applications written on top of them. This will make the job of writing new applications easier over \ntime. Now that we have a robust set of frameworks, we can produce many new applications in a short amount \nof time. This technology has given us an edge over our competitors because we will be able to respond \nto our customer needs with timely Contact information: software releases of new features and improved \nfunctionality. Tom Wisdom Forte Networks Inc. P.O. Box 62296 Colorado Springs, CO 80962 PHONE: (7 19) \n598-3842 FAX: (719) 599-4057  \n\t\t\t", "proc_id": "143773", "abstract": "", "authors": [{"name": "Tom Wisdom", "author_profile_id": "81392614108", "affiliation": "", "person_id": "P283793", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143773.143785", "year": "1991", "article_id": "143785", "conference": "OOPSLA", "title": "Developing HP's Network Advisor using Smalltalk in a large project team", "url": "http://dl.acm.org/citation.cfm?id=143785"}