{"article_publication_date": "11-01-1991", "fulltext": "\n An Empirical Study of the Object-Oriented Paradigm and Software Reuse John A. Lewis Sallie M. Henry \nDennis G. Kafura (Department of Computer Science) and Robert S. Schulman (Department of Statistics) \nVirginia Tech Blacksburg, Virginia 24060 Internet: lewis@vtopus.cs.vt.edu ABSTRACT While little or no \nempirical validation exists for many of software engineering s basic assumptions, the need for scientific \nexperimentation remains clear. Several assumptions are made about the factors affecting software reuse, \nand in particular, the role of the object-oriented paradigm. This paper describes the preliminary results \nof a controlled experiment designed to evaluate the impact of the object-oriented paradigm on software \nreuse. The experiment concludes that (1) the object-oriented paradigm substantially improves productivity, \nalthough a significant part of this improvement is due to the effect of reuse, (2) reuse without regard \nto language paradigm improves productivity, (3) language differences are far more important when programmers \nreuse than when they do not, and (4) the object-oriented paradigm has a particular affinity to reuse. \nPermission to copy without fee all or part of this material is granted provided that the copies are not \nmade or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy otherwise, or to republish, requires a fee and/or specific permission. o 1991 ACM \n89791-446-5/91/0010/0184...$1.50  1. Introduction The use of precise, repeatable experiments to validate \nany claim is the hallmark of a mature scientific or engineering discipline. Far too often, claims made \nby software engineers remain unsubstantiated because they are inherently difficult to validate or because \ntheir intuitive appeal seems to dismiss the need for scientific confirmation. The effects of the object-oriented \nparadigm on software reuse is one area which begs further empirical investigation. While the characteristics \nof the object-oriented approach and the qualities which support successful reuse seem to complement each \nother, little empirical evidence has been given to support this relationship. Studies related to software \nreuse are important because of the key role reuse assumes in improving software productivity. Brooks \nasserts that while no single development will result in an order-of-magnitude increase in productivity, \nsoftware reuse is an area where the greatest results can be achieved because reuse addresses the essence \n, as opposed to the accidents, of the development problem [BROF87]. However, reusable software is not \nbeing exploited to its full potential. According to Freeman, the state-of-the-practice of reuse in the \nUnited States is embarrassing [FREP87]. On an evolutionary scale, he puts reuse technology in an awakening \nstage, slowly approaching an early utilization period. Developers and users of potentially reusable products \nare unnecessarily hampered because they lack specific knowledge concerning the factors which influence \nsoftware reusability. Studies of the object-oriented paradigm are important because, according to Biggerstaff \ns framework of software reuse [BIGT87], the object-oriented paradigm has a good balance between power \nand generality. In his framework, procedural based solutions are also depicted having a good balance, \nbut are considered less effective than object-oriented solutions. The fundamental characteristics of \nthe object-oriented paradigm seem to complement the needs of the reusing developer. Encapsulation capabilities \ncreate self-contained objects which are easily incorporated into a new design [KERB84]. The data-based \ndecomposition of objects, resulting in class-hierarchies and inheritance, promotes reuse far more than \nthe top-down approach which promotes one-of-a-kind development [MEYB87]. Greater abstraction is the key \nto to greater reusability, and object-based languages provide abstraction far better than procedural \nlanguages [WEGP83]. Tracz makes several points which tend to support the use of the object-oriented paradigm \nto promote successful reuse [TRAW88]. For instance, special tools are not employed in current successful \nsoftware reuse situations and are not the answer to the problem. Reuse success comes from formalizations \nof process and product, which an object-oriented environment creates. Furthermore, unplanned software \nreuse is costly. Software must be designed for reuse, with an emphasis on interface and modularization. \nThe object-oriented paradigm stresses these characteristics. However, Tracz admits that no language, \nincluding an object-oriented one, will solve the the reuse problem inherently. While the reuse potential \nof the object-oriented paradigm has been promoted, little scientific experimentation has been conducted \nto confirm this expectation. The research described in this paper provides a comparison of a standard \nprocedural approach to that of the object-oriented techniques. A controlled experiment was designed and \nexecuted in order to measure the relative affects of a procedural language and an object-oriented language \nin terms of software reuse. Similar experiments have been successful in making comparisons of the object-oriented \nand procedural approaches relative to other aspects of software development. One study determined that \nthe object-oriented paradigm is quantitatively more beneficial than a procedural approach in terms of \nsoftware maintenance [HENS90]. An interesting point made in that research is that subjects viewed the \nobject-oriented techniques as more difficult to accomplish, even though all objective data supported \nthe hypothesis that using it resulted in fewer maintenance tasks and reduced maintenance effort. This \nresult clearly illustrates the danger of relying only on anecdotal evidence to assess software engineering \ntechnology. The goal of the experiment described in this paper is to answer the following questions with \nrespect to the impact of the object-oriented paradigm vs. the procedural paradigm on the successful reuse \nof software components: 1) Does the object-oriented paradigm promote higher productivity than the procedural \nparadigm? 2) Does reuse promote higher productivity than no reuse? 3) Does the object-oriented paradigm \npromote higher productivity than the procedural paradigm when programmers do not reuse? 4) Does the object-oriented \nparadigm promote higher productivity than the procedural paradigm when programmers reuse? 5) Does the \nobject-oriented paradigm provide incentives to reuse above those of the procedural paradigm? The experimental \ndesign was constructed with these questions in mind. We define productivity as the inverse of the effort \nexpended to produce a specific software product. Effort is measured in several quantifiable ways. We \nhypothesize that both reuse and the object- oriented paradigm are important factors in the software \ndevelopment effort. The next section describes the design of the experiment and discusses the specifications \nof the tasks performed. Section 3 defines the data collected and the statistical analysis performed. \nSection 4 draws conclusions from the analysis, specifically addressing the questions presented above. \nFinally, Section 5 summarizes the experimental results and discusses future work in this area. 2. Experimental \nDesign Some reuse experiments employ hypothetical, question-and-answer situations where the subjects \ndo not actually perform ti the various tasks inherent in the reuse process. The authors believe, however, \nthat to accurately determine influential factors, the experimental subjects must perform all of the following \ntasks: evaluating potentially reusable products, adapting them to the new situation, and integrating \nthem into a functionally complete product. It is important to create, as accurately as possible, a representative \nsituation while maintaining a valid experimental design [CURBSO]. The experiment described in this paper \nis based on a target system developed by each of a set of senior-level software engineering students. \nThe use of students as subjects, while sometimes considered unrealistic, is justified in this case due \nto two overriding considerations. First, empirical evidence by Boehm-Davis indicates that students are \nequal to professionals in many quantifiable measures, including their approach to developing software \n[BOED84]. Although new techniques are learned and further refinement does occur, a programmer s basic \napproach and development habits are formed quite early in their professional development. Second, given \nthe amount of control necessary to execute this experiment, students are the only viable alternative. \nThe efficacy of students as subjects is supported for within-subject experiments by Brooks [BROR80]. \nThe subjects in this experiment developed a specified target system. The system specification is couched \nin the guise of computerizing a fictional company and is separated into two tasks. The specific functions \nmaking up the system were abstracted from the commercial software development experience of the first \nauthor. They involve a variety of programming techniques including data management, numerical processing, \nand graphics. Previous research investigating the factors affecting software reuse have concentrated \non two issues: 1) the impact of software engineering characteristics of code components, such as readability, \nstructured code, etc., and 2) the techniques used to find appropriate code components from a set of possible \ncandidates. Neither of these issues are the focus of this study. Code quality was allowed to vary only \nwithin the controlled confines of adequate testing and software engineering standards. All completed \nprojects were verified to meet a set of requirements concerning documentation, code quality, and functional \ncorrectness. Furthermore, subjects were given no special tools for searching or identifying candidate \ncomponents. It is assumed that any assistance in this area would only improve the reuse results. This \nstudy focuses on language issues, specifically the comparison of the object-oriented paradigm to the \nprocedural approach with respect to reuse of previously developed components. In the experiment, reusable \ncode components were made available to the subjects implementing the target system. To affect further \ncontrol, the code component sets were specifically generated for this study. Therefore, the research \nconsists of two phases. The first phase was preparatory, in which potentially reusable components were \ndesigned and implemented. The experiment was executed in the second phase, in which the target system \nwas developed by a set of subjects, who are unrelated to the programmers who designed and implemented \nthe reusable components. These two phases are described in the following sections.  2.1 Phase 1: Component \nDevelopment Two sets of potentially reusable components were created during phase one. One set was implemented \nin a procedural based language, Pascal, and the other in an object- 187 oriented language, C++. The \nchoice of languages was not arbitrary. We deliberately chose not to use C as the procedural programming \nlanguage to make as clear a distinction as possible between the object- oriented approach and the procedural \napproach. Since C is basically a subset of C++, we feared the similarities of the two languages might \ncloud that distinction. C++ was chosen over Smalltalk because we believed the powerful programming environment \nof Smalltalk, not available to a Pascal programmer, might jeopardize the comparison. Finally, both C++ \nand Pascal emphasize strong typing, thus controlling another possible source of variation. Both component \nsets were implemented on Apple Macintosh II s running A/UX. They were designed to be functionally equivalent, \nthough design and coding techniques naturally vary. Equivalence was guaranteed by ensuring that all code \nmet the same fundamental functional and error-handling requirements. Furthermore, all developed code \npassed the same level of testing thoroughness. Knowing the requirements of the target system to be implemented \nin the second phase, each component was designed to have a specific level of applicability. The levels \nof reuse can be described as: 1) completely reusable, 2) reusable with slight revision ( < 25% >, 3) \nreusable with major revision ( > 25% >, and 4) not applicable for reuse. 188 With respect to the target \nsystem, the component sets were designed to contain elements from each reuse level. The 25% marks of \nlevels 2 and 3 are only intuitive guidelines and refer to the amount of code that must be added, deleted \nand modified to create a component that meets the target system s requirements. Providing components \nwhich span a wide range of applicability ensures a realistic, diverse collection from which subjects \nevaluate and choose components. 2.2 Phase 2: Project Implementation Using the two sets of components, \nindependent subjects were assigned the task of implementing the target project. The subjects were divided \ninto four groups, pictured as cells in Figure 1. Half the subjects implemented the project in Pascal, \nthe other half in C++. Furthermore, a portion of the students from each language were not allowed to \nreuse at all, while the others were encouraged to reuse. The no reuse groups serve as control groups. \nNo Reuse Reuse Procedural Procedural No Reuse Reuse Object-Oriented Object-Oriented  Figure 1: Subject \ngroup breakdown. Twenty-one subjects were distributed unevenly across the groups. The uneven distribution \nof subjects was factored into the statistical analysis. The subjects were divided into the groups randomly, \nbut were statistically blocked across their computer science grade point averages. This blocking was \nan effort to reduce variability within each group. An anova test comparing the grade point averages of \nsubjects showed no significant differences between groups (p < 0.9795). The functional requirements of \nthe system are divided into two equal tasks concerned with employee management and business management. \nEmployee management functions deal with processes such as an employee database, payroll, security control, \nand cost center management. Business management functions are concerned with the details of shop floor \ncontrol, quality control testing, warehouse management, and customer interactions. Although the two tasks \nfocus on different aspects of running a business, they were designed to be comparable in computational \ncomplexity. Both are divided into seven subtasks, each of which has a counterpart in the other task designed \nto require approximately the same amount of effort to develop. Since preliminary analyses showed that \nthe results are not affected by the difference between the two tasks, this factor was ignored in subsequent \nanalysis, thereby increasing statistical power in addressing the questions of primary interest. To further \ncontrol this aspect of the experiment, half of the subjects designed and implemented the employee management \ntask first, while the other half of the subjects designed and implemented the business management task \nfirst. Then each half switched, resulting in both system tasks being developed by each subject. This \norganization offsets any learning benefit of doing a particular task first. An introductory material \nsection was provided with information both groups need to perform their respective tasks.  3. Data Analysis \nGiven a feasible and well-controlled experimental design, the rigorous analysis of data collected during \nthe experiment determines the conclusions that can be made about the hypotheses. In this experiment, \nthe goal is to determine which groups from Figure 1, on average, had a significantly different productivity \nrate than others. The data collected during the experiment measures the productivity of a subject in \nimplementing the target system. Productivity and effort are considered to have an inverse relationship. \nTherefore, the less effort expended by a subject to satisfy the requirements of one task, the higher \nthe productivity of that subject. The measurements of effort, and therefore of productivity, are: Main \nproductivitv measures . Runs -The number of runs made during system development and testing, . RTE -The \nnumber of run time errors discovered during system development and testing, and . Time -The time (in \nminutes) to fix all run time errors, 189 . . Secondarv pMduchvrtv mea~ufe~ . Edits - The number of \nedits performed during system development and testing, and . Sjn. - The number of syntax errors made \nduring system development and testing. Since each subject implemented the same tasks, a comparison of \ndata across subjects yields a relative measure of the effort used to develop a task. A subject with a \nhigh value for a given measure is considered less productive than a subject with a low value. Multiple \nproductivity variables are used to obtain a complete picture of the development process. The Runs, RTE \nand Time variables, given their significance to the development process, are considered the main variables \nof interest. The Edits and Syntax Errors variables are gathered for completeness, but are given less \nemphasis. To reduce the overhead of the data collection, some measures that might have been of interest, \nsuch as total development time, were not collected. Data was collected by the subjects using tally sheets. \nTo assure the data s validity, subjects were informed that their names would not be associated with these \ndata, and that the values themselves would have no bearing on their course evaluation. They were also \ntold that a negative impact on their course evaluation would occur if they did not record their development \ninformation honestly and completely. The tally sheets were coded such that no subject name was ever connected \nto particular data. The group means for each productivity variable are depicted graphically in Figure \n2. These charts give a rough indication of how the groups compare although statistical analyses are employed \nto verify perceived differences. In each analysis, a difference in means was considered significant if \nthe p-value for the test was less than 5% (p < 0.05), which is an accepted norm. Since our research questions \nall predict the direction of difference, all tests were performed in a one-sided manner. Initial analysis \nof the task factor determined that the difference between the two tasks played no role in influencing \nany of the productivity variables (all p-values for task effects were 2 0.2073). In other words, the \ntwo tasks were determined to be equally difficult. The lack of difference is attributed to the careful \ndesign of task specifications and the blocking of subjects across grade point average. Therefore, all \nfurther analyses ignore the task factor, effectively creating 42 observ ations on which to perform the \ntests, which gives them more statistical power.  4. Experimental Results This section draws conclusions \nfrom the analysis performed on the productivity data. In general, the hypotheses suggested at the beginning \nof this paper are supported, with some notable exceptions. 190 Number of Runs 100 80 % 80 gj 40 20 \n0 Proc -No Reuse 0.0. -No Reuse Proc -Reuse 0.0. - Reuse (b) Number of Run Time Errors 100 80 B 80 \ns 40 20 0  Proc -No Reuse 0.0. - No Reuse Proc -Reuse 0.0. - Reuse Time to Fix Run Time Errors Proc \n-No Reuse 0.0. - No Reuse Proc -Reuse 0.0. - Reuse (d) Number of Edits 500 400 m .% 300 3 200 100 \n 0 Proc -No Reuse 0.0. - No Reuse Proc -Reuse 0.0. - Reuse (e) Number of Syntax Errors Proc -No Reuse \n0.0. - No Reuse Proc -Reuse 0.0. -Reuse Figure 2. Group means for each production variable. The experimental \nquestions posed in Section 1 will be used as a framework for discussion of the statistical analysis. \nEach question will be addressed separately, giving the results of the appropriate analysis. 1) Does \nthe object-oriented paradigm promote higher productivity than the procedural paradigm? The third column \nin Table 1 list the means of the productivity variables calculated from all subjects using the procedural \nlanguage, including subjects who reused as well as those who did not. The fourth column shows similar \nmeans for subjects in the object-oriented categories. Our hypothesis is that the values for the object-oriented \nparadigm will be lower than those of the procedural paradigm, indicating a higher productivity for the \nobject-oriented subjects. Means Signifkant? p-value medural o-o Runs Yes 0.0066 59.27 47.50 RTE Yes 0.0078 \n65.00 50.20 Time Yes 0.0104 354.41 261.70 No 0.3469 271.55 263.65 Syn. No 0.8675 183.67 202.40 Edits \nTable 1. Language Main Effect For each productivity variable, a p-value was computed for the difference \nbetween the means. The p-value is the probability that the difference could have been obtained by chance, \nrather than reflecting a true difference in productivity. Following conventional criteria, a difference \nis deemed statistically significant if its p-value is less than 0.05. In such cases, it is extremely \nunlikely that the difference in means is due to chance, and we conclude that productivity was indeed \nhigher for subjects using the object- oriented paradigm. The three main productivity variables (Runs, \nRTE and Time) show a significant difference between the means, favoring the object-oriented paradigm. \nIn addition, the object- oriented mean for the Edit variable was also lower than the procedural mean, \nalthough not to a significant degree. The means on the Syntax Errors variable did not differ in the predicted \ndirection. Considering the nature of the Edits and Syntax Errors variables, the lack of significance \nis attributed to the subjects lack of practice using the object-oriented language. The results of the \nanalysis on the main variables indicate that the object-oriented paradigm does promote higher productivity \nthan the procedural paradigm. 2) Does reuse promote higher productivity than no reuse? From the results \nin Table 2, the answer to this question is clearly yes. The means in the third column of Table 2 are \ncalculated for all subjects who did not reuse, regardless of the Means Significant? p-value No Reuse \nAil Reuse Runs Yes 0.0001 78.71 41.14 RTE Yes 0.0001 83.79 45.04 The yes 0.0001 420.07 255.36 Edits \nYes 0.0001 405.71 198.82 Syn. Yes 0.0001 302.14 150.92 Table 2. Reuse Main Effect language used. Likewise, \nthe fourth column shows means for all subjects who did reuse. Our hypothesis is that the means will be \nlower for the reuse groups, indicating a higher productivity for the subjects who were encouraged to \nreuse. This hypothesis is strongly supported by all variables. Means Significant? p-due Procedural No \nReuse Procedulal All Reuse Runs RTE Yes Yes 0.0001 0.0008 75.38 81.25 50.07 55.71 Tii Yes I 0.0047 I \n446.38 301.86 Edits Yes 0.0001 416.00 189.00 Syn. Yes 0.0001 311.00 137.14 Table 3. Procedural ( No \nReuse vs. Reuse ) Means o-o o-o Significant? p-value No Reuse All Reuse Runs YeS 0.0001 83.17 32.21 RIE \nYes 0.0001 87.17 34.36 Tii Yes 0.0017 385.00 208.86 Edits Yes 0.0001 392.00 208.64 SVIL YeS O.oool 290.33 \n164.71 Table 4. Object-Oriented ( No Reuse vs. Reuse ) This result is further supported by the charts \nin Tables 3 and 4, which view the data across the reuse factor, but consider each language separately. \nTable 3 shows the means for the procedural groups with respect to reuse, and Table 4 shows the means \nfor the object-oriented groups with respect to reuse. In both analyses, all variables showed a significant \ndifference in the hypothesized direction. 193 3) Does the object-oriented paradigm promote higher productivity \nthan the procedural paradigm when programmers do not reuse? The means listed in Table 5 are calculated \nfor subjects who did not reuse. The third column represents subjects using the procedural language, and \nthe forth column represents subjects using the object-oriented language. Our hypothesis is that the object-oriented \nvalues will be lower than the procedural values. Surprisingly, none of the variables indicate a significant \ndifference. Interestingly, the group means do not consistently favor one language or the other. The means \nfor the object-oriented groups are lower for Time, Edits, and Syntax Errors, but the means for the procedural \ngroups are lower for Runs and RTEs. According to this analysis, we must conclude that when reuse is not \na factor, the object-oriented paradigm does not promote higher productivity. In other words, in the absence \nof reusable components, either language works equally well. Means medulal o-o Significant? p-value No \nReuse No Reuse Table 5. No Reuse ( Procedural vs. Object-Oriented )   4) Does the object-oriented paradigm \npromote higher productivity than the procedural paradigm when  programmers reuse? Given the answers \nto the first and third questions, the answer to this question should logically be yes. The results in \nTable 6 confirm this for the three main productivity variables. The means listed are for subjects who \ndid reuse, with the third column representing subjects using the procedural paradigm and the forth column \nrepresenting subjects using the object-oriented paradigm. Once again, our hypothesis favors the object-oriented \nparadigm. Means Procedural o-o Significant? p-value All Reuse All Reuse ~~1 Table 6. Reuse ( Procedural \nvs. Object-Oriented ) Variables Runs, RTE and Time all proved significant with means favoring the object- \noriented group, but the Edits and Syntax Errors variables did not differ in the hypothesized direction. \nGiven the importance of the main productivity variables, we can conclude that the object-oriented paradigm \ndoes promote higher productivity than the procedural paradigm when reuse in employed. Note that most \nof the support given to the first question comes from differences between the groups which were encouraged \nto reuse. 5) Does the object-oriented paradigm provide incentives to reuse above  those of the procedural \nparadigm? As shown by the results in Tables 3 and 4, reuse improved productivity over non-reuse for \nboth the procedural and object-oriented paradigms. The fifth question asks whether the extent of improvement \nis comparable for the two language paradigms. Our hypothesis is that the improvement due to reuse will \nbe greater for the subjects using the object-oriented paradigm than those using the procedural paradigm, \nindicating that the object-oriented paradigm is particularly suited to reuse. The third column in Table \n7 shows for each variable the difference between the mean of the procedural non-reuse group and the mean \nof the procedural reuse group. This is a measure of the amount of improvement in productivity due to \nreuse --the large the difference, the greater the increase in productivity. The forth column show comparable \nmean differences for the object-oriented groups. Therefore, our hypothesis predicts that values in the \nfourth column should be greater than those in the third column. Mean Differences Frocedl.ual o-o Significant? \np-value NR-R NR-R Yes 0.0009 25.31 50.96 RTJZ Runs YeS 0.0062 25.54 52.81 The No 0.3 176 144.52 176.14 \n No 0.8753 227.00 183.36 Syn. No 0.9716 173.86 125.62 Edits , Table 7. Interaction (Extent of Improvement) \n On the Runs and RTE variables, the increase in productivity due to reuse was greater for the object-oriented \nparadigm than for the procedural paradigm. The same pattern occurred on the Time variable, although the \ndifference in means was not large enough to be statistically significant. Once again, contrary to the \nmain productivity variables, the Edits and Syntax Errors variables seem to oppose the hypothesis. Given \nthat two of the three main measures of productivity (Runs and RTE) show significant differences in the \nhypothesized direction, and that the third main variable (Time) favored the same direction, we conclude \nthat there is a significant difference between the extent of improvement due to reuse across the two \nlanguage paradigms. In other words, the results show that the object- oriented paradigm demonstrates \na particular affinity to the reuse process.  5. Summary and Future Work The experiment in this paper \nhas shown: (1) The object-oriented paradigm substantially improves productivity, although a significant \npart of this improvement is due to the effect of reuse (questions 1,3 and 4), (2) Software reuse improves \nproductivity no matter which language paradigm is used (question 2), (3) Language differences are far \nmore important when programmers reuse than when they do not (questions 3 and 4), and (4) The object-oriented \nparadigm has a particular affinity to the reuse process (question 5).  Although we did not demonstrate \nthat the object-oriented paradigm promotes productivity when reuse is not a factor, the development efforts \nusing either language paradigm were not significantly different. Furthermore, given the reuse potential \ndemonstrated by the object-oriented paradigm, greater benefits can be achieved by using the object-oriented \nparadigm than by using a procedural approach. An important facet of the experimental method is that the \nresults are repeatable. Experiments similar to the one described in this paper should be conducted to \nverify the results of this experiment. In particular, the secondary variables of Edits and Syntax Errors \ndid not always support the analysis of the main variables, even when intuition says they should. This \ntendency deserves further investigation. Other experiments should be conducted which independently investigate \nthe two main elements of this research: software reuse and the object-oriented paradigm. The factors \nwhich affect software reuse are many and varied. Similar experiments can be designed to determine the \nimpact of human factors, code characteristics, and other language differences. The object-oriented paradigm \ncontains a wealth of possible benefits that have yet to be proven empirically. Claims that associate \nthe object-oriented approach with improved design, less and easier maintenance, and higher reliability \nwhen compared to its procedural counterpart demand further investigation. Experience reports alone, while \nuseful, are not enough to validate 195 the assumptions that are associated with the object-oriented \nparadigm. Experimental research into these areas is necessary to provide a solid base to support the \ntheories that shape state-of-the-art software production. References [BIGT87] Biggerstaff, T., Richter, \nC., Reusability Framework, Assessment, and Directions, IEEE Software, March 1987, pp. 41-49. [BROF87] \nBrooks, F.P., No Silver Bullet: Essence and Accidents of Software Engineering, Computer, April 1987, \npp. 10-19. [BOED84] Boehm-Davis, D., Ross, L., Approaches to Structuring the Software Development Process, \nInternational Journal of Man-Machine Systems, (to appear 1991). [BROR80] Brooks, R., Studying Programmer \nBehavior Experimentally: The Problems of Proper Methodology, Communications of the ACM, 1980, Volume \n23, Number 4, pp. 207-213. [CURB801 Curtis, B., Measurement and Experimentation in Software Engineering, \nProceedings of the IEEE, 1980, Volume 68, Number 9, pp. 1144-l 157. [FREP87] [HENS901 [KERB84] [MEYB87] \n[TRAW88] [WEGP83] Freeman, P., A Perspective on Reusability, Software Reusability, Computer Society Press \nof the IEEE, 1987, pp. 2-8. Henry, S.M., Humphrey, M., Lewis, J.A., Evaluation of the Maintainability \nof Object-Oriented Software, Proceedings of the Conference on Computer and Communication Systems, Volume \n1, Hong Kong, September 1990, pp. 404-409. Kernighan, B.W., The Unix System and Software Reusability, \nIEEE Transactions on Software Engineering, September 1984, pp. 513-518. Meyer, B., Reusability: The Case \nfor Object-Oriented Design, IEEE Software, March 1987, pp. 50-64. Tracz, W., Software Reuse Myths, ACM \nSIGSOFT Software Engineering Notes, January 1988, pp. 17-21. Wegner, P., Varieties of Reusability, ITT \nProceedings of the Workshop on Reusability in Programming, 1983, pp. 30-44.  \n\t\t\t", "proc_id": "117954", "abstract": "", "authors": [{"name": "John A. Lewis", "author_profile_id": "81339512203", "affiliation": "Department of Computer Science, Virginia Tech, Blacksburg, Virginia", "person_id": "PP39075133", "email_address": "", "orcid_id": ""}, {"name": "Sallie M. Henry", "author_profile_id": "81451597193", "affiliation": "Department of Computer Science, Virginia Tech, Blacksburg, Virginia", "person_id": "PP95030991", "email_address": "", "orcid_id": ""}, {"name": "Dennis G. Kafura", "author_profile_id": "81100565123", "affiliation": "Department of Computer Science, Virginia Tech, Blacksburg, Virginia", "person_id": "P65771", "email_address": "", "orcid_id": ""}, {"name": "Robert S. Schulman", "author_profile_id": "81100641564", "affiliation": "Department of Statistics, Virginia Tech, Blacksburg, Virginia", "person_id": "P246378", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/117954.117969", "year": "1991", "article_id": "117969", "conference": "OOPSLA", "title": "An empirical study of the object-oriented paradigm and software reuse", "url": "http://dl.acm.org/citation.cfm?id=117969"}