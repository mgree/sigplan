{"article_publication_date": "10-26-2003", "fulltext": "\n Teaching Polymorphism with Elementary Design Patterns Joseph Bergin Pace University http://csis.pace.edu/~bergin \nberginf@pace.edu Abstract Polymorphism is often treated as an advanced topic by educators. Many feel \nthat if statements are in some sense more fundamental to computing. On the contrary, polymorphism is \nboth fundamental to object programming and is an elementary topic that can be easily understood by students. \nPrevious papers [1] have shown how role-play exercises can remind students that they already have a deep \nunderstanding of dynamic polymorphism. The question then becomes how do we find effective teaching techniques \nto present this topic when we move from the level of metaphor to that of programming. A few elementary \npatterns [2] can be used to teach this topic even before the student is introduced to ad-hoc selection \nwith if statements. Teaching these patterns early has the added benefit that they are pervasive in the \nJava libraries, so understanding them eases the student's later work. Categories and Subject Descriptors \nD.1.5 [Programming Techniques]: Object Oriented Programming polymorphism, control structures. General \nTerms: Design, Languages. Keywords: Teaching, Design Patterns. 1. Think polymorphically using elementary \ndesign patterns. Consider the following simple polymorphism pattern: Context: You are at a point in a \nprogram at which one of several things needs to be processed. These things are objects (rather than ints...). \nYou may have different kinds of things and in any case different things need to be processed in different \nways. Problem/Forces: You want the program to be simple and extendable. You want the object autonomy \nto be maintained as usual. You want a single point of change for each logical element as the program \nevolves. Therefore, organize your code so that all of the different object types share an interface, \nperhaps because they derive from a common ancestor. At the point of commonality define a method to perform \nthe processing you need done, and implement this method as appropriate in each type. If you need different \nkinds of information (parameters) for each type, then you can delegate Copyright is held by the author/owner(s). \nOOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. the processing \nto an auxiliary object called a Strategy. In many cases this additional object can be created when the \noriginal object is and can be held as part of its state. The strategy object can encapsulate all of the \nadditional information. For example, imagine a library processing books. There are CheckableBooks and \nPermanentReserveBooks. When books are brought back to the desk after use, they need to be returned. In \nthis case we probably already have these two classes extending a common class, Book. If the same processing \nis required for all books, we can put a doReturn method into the Book class. You can now say simply book. \ndoReturn(); Even in the case in which one or more of the subclasses must process returned books differently, \nwe can simply override this method as appropriate, provided the parameter structure (here no parameters) \nof the method can properly be the same. Even with different implementations of doReturn in the different \nclasses, the invocation is identical. We would like to maintain this simplicity in harder cases as well. \n 2. Harder Cases: Strategy In some cases different things need to be done on return of a book, however. \nFor example, a reserve book needs to be returned immediately to a certain shelf, and a checked book needs \nto be processed through the patron's library records for late fees and outstanding fines. In this case \nwe can delegate the process to a strategy. If we write methods with different parameters in the two classes \nit will be hard to use them polymorphically unless we provide an intermediary, a strategy. For flexibility, \nstrategies are best defined in interfaces. In this case, we can say interface ReturnStrategy { public \nvoid returnBook(); } Then individual strategies can be defined in classes that implement this, such as: \nclass CheckableReturn implements ReturnStrategy { public CheckableReturn(Patron p, CheckableBook b) { \nthis.patron = p; this.book = b; } public void returnBook() { book.returnCheckable(this.patron); } Patron \npatron; CheckableBook book } class PermanentReserveReturn implements ReturnStrategy { public PermanentReserveReturn(Shelf \ns, PermanentReserveBook b) { this.shelf = s; this.book = b; } ... } Then, when the book is given to \na patron, one of these strategy objects is created and saved within the book object itself. In fact, \nthe strategy could be created by an appropriate method of the individual class itself. So the CheckableBook \nclass can have a method void createReturn(Patron p), { this.returnStrategy = new CheckableReturn(p, this); \n} Then later, when the book is returned, the book can be asked to book.doReturn(); This method is defined \nin the Book class as public void doReturn() { this.returnStrategy.returnBook(); //Delegation this.returnStrategy \n= null; } What do we gain? The original problem was that we were at a point in a program at which different \nthings could occur. Now, the code for this is just a simple command like book.doReturn(); We do not here \nneed to ask what kind of book it is. To see why this is important, read on. The above is a bit different \nfrom the way many programmers would solve the problem. When the program is originally written an if statement \ndistinguishing the cases would be simple enough, with different methods called depending on the test. \nHowever, this means that when the problem changes or is extended (common occurrences) this point in the \nprogram would need to be visited again for update. If a new type of book is introduced, we would need \nto replace the if with a switch or more complex if structure. If the processing of any book changes we \nmight need to change the bodies of the if/else clauses if they were more than just simple messages. This \nsort of programming, with frequent changes to many places in a program is very error prone as has been \nshown in practice over many years. With the strategy solution, however, we don't need to modify this \npoint in the program for future changes. If we create a new kind of book we create a new kind of strategy \nas well if necessary. If the processing of some kind of book changes we update or extend the appropriate \nstrategy class that handles returns for that kind of book. In a large program that will change, this \nis hugely beneficial as we have localized the points of change to the classes in which the change occurs \nand not those places where objects of the classes are used. The key to thinking above was that in a situation \nin which many things are possible, one object delegates an action to another kind of object (the strategy). \nDelegation is the key. You arrange to create the new object at the early point at which you have the \nnecessary knowledge to do so. One consequence is that you have more objects, but the individual objects \nare simpler. Simple objects are easy to understand and maintain. They may also be easy to extend through \ninheritance or other mechanisms. We note that there are other ways to use the strategies than have them \nheld within the book objects. For example, we could put the return strategies into a hashmap using the \nbook as the value and the strategy as the key. Since the strategy contains all the information necessary \nto return a book, we could, when asked to return a book, find the corresponding strategy in the hashmap \nand then send it a returnBook() message. There are many other possibilities, of course. 3. New Strategies \nFrom Old: Decorators As your program develops you will find yourself with several strategy classes and \nthe need to define new ones. Sometimes this can be done with inheritance, but there is another way that \noften works. Suppose you have a strategy that does one thing and you need a strategy that does that thing, \nbut also some independent thing as well. For example, suppose that we discover that some (but perhaps \nnot all) of our book return actions also need to record how much time the book was out. It might even \nbe the case that not all CheckableBooks need this extra action, but only some. One way to proceed is \nto write a Decorator for strategies that holds another strategy and performs its action in addition to \nanother. For example, let's build a timer Decorator for return strategies. For simplicity we will assume \nthat the time the decorator is created is the desired check out time. class TimerStrategy implements \nReturnStrategy { public TimerStrategy(ReturnStrategy d) { this.decorated = d; } public void returnBook() \n{ decorated.returnBook(); timeRecorder.record(this.timeOut, new Date()); } private ReturnStrategy decorated; \nprivate Date timeOut = new Date(); // Time the strategy is created. } Then when we need such a thing, \nwe can create it, wrapping any other kind of return strategy, for example returnStrategy = new TimerStrategy( \nnew CheckedStrategy (aPatron)); We can now return the book exactly as before with this.returnStrategy.returnBook(); \nand both actions will be done. 4. Cleaner Code: Null Object Note that we have left the returnStrategy \nobject of the Book class null after a book is returned. The value null is difficult to work with. If \nyou dereference it by accident or poor design your program will crash (actually, throw an exception). \nWe assumed that an invariant of the field was that it was null when the book was in, and not null otherwise. \nWe can do a bit better, actually, and lessen the chance of using null incorrectly, by not using it at \nall. Here we will apply another design pattern called Null Object [3]. We let a special object take the \nplace of null. Here we will develop an NullStrategy. class NullStrategy implements ReturnStrategy { public \nvoid returnBook() { // do nothing } } Now the returnStrategy field of Book could be initialized with \none of these ReturnStrategy returnStrategy = new NullStrategy(); And the doReturn method could be modified \nto: public void doReturn() { this.returnStrategy.returnBook(); //Delagation this.returnStrategy = new \nNullStrategy(); } 5. Keep it Simple: Singleton Well, we can do even better than this. Note that the \nNullStrategy has no state and so always behaves in exactly the same way. If we have two or more of these \nthey all behave exactly alike. Therefore it is really unnecessary to have more than one of these, so \nwe can and should turn the NullStrategy (as is true of most null objects) into a Singleton. We do this \nby giving the class a private constructor but a public static instance. class NullStrategy implements \nReturnStrategy { public void returnBook() { // do nothing } public static NullStrategy value = new NullStrategy(); \nprivate NullStrategy() { } } It is now impossible to create more of these since the constructor is private. \nBut we have exactly one of them available defined by the class itself, hence it is a Singleton. Now wherever \nelse we previously said new NullStrategy() we now say NullStrategy.value. Note that Singleton objects \nare useful in other places. If there is no need to create more than one object of a certain class, or \nthe logic of the program suggests it is incorrect to do so, then the class should be a singleton. 6. \nKeep it Safe: Immutable Object Finally we note that all of the strategy classes we have shown, including \nthe decorator, were Immutable. An object is immutable provided that its state cannot be changed after \nit is created. The constructor must supply all data necessary to create it (which it must do anyway) \nand there are no mutator methods that change the state later. Immutable objects are very useful in a \nprogram since they make the program easier to reason about. If objects don't change state, we know that \nthe state we find them in at any point, including after a crash, is the state they were created with. \nDon't provide mutator methods for your classes unless they are really necessary and try to design your \ncode overall so that they are mostly not necessary. Programs with few mutatorsare easier to maintain \nand debug. It is hard to do much of this if you are processing things that are not objects or even for \nfinal objects. This is because you can't attach additional methods to them, though if you have access \nto the source code, you can modify the definition of a final class. There may be other reasons for not \ndoing so, however. 7. References [1] Andrianoff, Levine, Bergin, Role Playing: Easing the Paradigm Shift, \nOOPSLA 2002 Educator's Symposium, Seattle, WA [2] Gamma, Helm, Johnson, and Vlissides; Design Patterns; \nAddison-Wesley; 1995. [3] Woolf; Null Object ; Pattern Languages of Program Design 3, edited by Martin, \nRiehle, and Buschmann, Addison-Wesley, 1998.  \n\t\t\t", "proc_id": "949344", "abstract": "Polymorphism is often treated as an advanced topic by educators. Many feel that if statements are in some sense more \"fundamental\" to computing. On the contrary, polymorphism is both fundamental to object programming and is an elementary topic that can be easily understood by students. Previous papers [1] have shown how role-play exercises can remind students that they already have a deep understanding of dynamic polymorphism. The question then becomes how do we find effective teaching techniques to present this topic when we move from the level of metaphor to that of programming. A few elementary patterns [2] can be used to teach this topic even before the student is introduced to ad-hoc selection with if statements. Teaching these patterns early has the added benefit that they are pervasive in the Java libraries, so understanding them eases the student's later work.", "authors": [{"name": "Joseph Bergin", "author_profile_id": "81314493368", "affiliation": "Pace University", "person_id": "PP43137236", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949393", "year": "2003", "article_id": "949393", "conference": "OOPSLA", "title": "Teaching polymorphism with elementary design patterns", "url": "http://dl.acm.org/citation.cfm?id=949393"}