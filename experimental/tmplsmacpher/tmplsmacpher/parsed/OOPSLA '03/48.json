{"article_publication_date": "10-26-2003", "fulltext": "\n A Pair-Programming Experiment in a Non-Programming Course Edward F. Gehringer North Carolina State \nUniversity Department of Computer Science Box 8206 Raleigh, NC 27606 +1 919-515-2066 efg@ncsu.edu ABSTRACT \nPair programming is a concept where two programmers work side by side at the same computer, writing code \njointly. One of them, called the driver, is in control of the keyboard and mouse. The other, called the \nnavigator, observes what the driver is doing and offers advice. It is the driver s job to write the code. \nThe navigator has a chance to observe the larger picture, evaluating the driver s code for correctness \nof design and implementation. Studies have shown that pair programming is very effective. Two programmers \ncan finish a task in little over half the elapsed time that a single programmer takes. And the quality \nof the code measured in terms of absence of defects is much higher. In the past few years, pair programming \nhas made inroads into industry and into programming courses. However, it has not typically been used \nin courses that teach subjects other than programming or software engineering, nor has it been used in \nthe analysis of experimental results. This paper reports on an experiment in a combined senior/masters-level \ncomputer architecture class, using Hennessy &#38; Patterson s Computer Architecture: A Quantitative Approach \nas a text. Students were required to implement three projects simulating various aspects of a microarchitecture \n(cache, branch predictor, dynamic instruction scheduler). Then they engaged in an experimental analysis \nto find the best configuration in a design space. Students reported high levels of satisfaction with \nthe experience of pair programming. Pair programmers obtained significantly higher grades on Project \n1; however, differences on the other projects were not statistically significant.  Categories and Subject \nDescriptors D.2.3 [Coding Tools and Techniques]: Pair programming. D.1.5 [Object-Oriented Programming]: \nMethodologies. K.3.2 [Com\u00adputer and Information Science Education]: Computer-science education programming \nexercises, laboratory techniques. General Terms Reliability, Languages.  Keywords Pair programming, \nlaboratory exercises, computer architecture. Copyright is held by the author/owner(s). OOPSLA 03, October \n26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. 1. INTRODUCTION Pair programming is \none of the twelve practices of Extreme Pro\u00adgramming (XP), which is the best known of the agile software\u00addevelopment \nmethodologies that have gained widespread atten\u00adtion in recent years. Agile methodologies attempt to \nmitigate some of the up-front design costs of heavyweight methodologies, which expend a lot of effort \non design before code is written, and to adapt more gracefully to change in project requirements or scope. \nPair programming [1] is a style of programming in which two programmers work side by side at one computer, \ncontinu\u00adously collaborating on the same design, algorithm, code or test. One of the pair, called the \ndriver, is typing at the computer or writing down a design. The other partner, called the navigator, \nhas many jobs. One of the roles of the navigator is to observe the work of the driver, looking for tactical \nand strategic defects in the work of the driver. Tactical defects are syntax errors, typos, calls to \nthe wrong method, etc. Strategic defects are said to occur when the team is headed down the wrong path \n what they are implementing won t accomplish what it needs to accomplish. Any of us can be guilty of \nstraying off the path. A simple, Can you explain what you re doing? from the navigator can serve to bring \nthe driver back onto the right track. The navigator has a much more objective point of view and can better \nthink strat\u00adegically about the direction of the work. The driver and navigator can brainstorm on demand \nat any time. An effective pair\u00adprogramming relationship is very active. The driver and the navi\u00adgator \ncommunicate at least every 45 seconds to a minute. It is also very important for them to switch roles \nperiodically. Note that pair programming includes all phases of the development process design, debugging, \ntesting, etc. not just coding. Experience shows that programmers can pair at any time during development, \nin particular when they are working on something that is complex. The more complex the task, the greater \nthe need for two brains [2, 4]. Previous research [2, 3] has indicated that pair programming is better \nthan individual programming in a collocated environ\u00adment. Research has shown that pairs finish in about \nhalf the time of individuals and produce higher quality code. The technique has also been shown to assist \nprogrammers in enhancing their technical skills, to improve team communication, and to be more enjoyable \n[2, 4, 5, 6]. The observed success of pair programming in industry has led to its introduction in many \ncomputer science courses. Most experiments on introductory programming courses [7, 8] report great success. \nIn 2001 and 2002, the author conducted an experi\u00adment in his graduate-level object-technology course \nthat again showed [9, 10] that the pair-programming teams wrote code more quickly and reported better \ncommunication with teammates than those teams that did not pair-program.. 2. BACKGROUND The author taught \nECE 463, Advanced Microprocessor Design and ECE 521, Computer Design and Technology for the first time \nin Fall 2002. This is a combined senior-level/ beginning-graduate course that is taught in a single lecture \nhall with the same homework and exams, but extra requirements for the graduate students. Traditionally, \nthree simulation projects had been as\u00adsigned: a cache, a branch predictor, and a dynamic instruction \nscheduler. These were fairly long projects, and constituted the majority of the homework in the course. \nBased on the experience in his other class, the author hypothesized that pair programming should be more \neffective than solo programming in courses that use, but do not teach, programming skills. Students appeared \nto learn more with less effort, so why not? Previous instructors cautioned the author against this approach. \nIn previous semesters where the students had been allowed to team up in pairs, sometimes one of the members \ndid not do any of the work. This was often revealed on the second or third project. The need to guard \nagainst freeloaders had led the instructors either to limit team programming to the undergrad\u00aduates, \nor disallow it altogether. However, pair programming and the tools developed for it seemed to address \nthese concerns. The students would be encouraged to pair-program. With both of them in front of the \nsame monitor, it was far less likely that one could escape doing any of the work.  In order to record \ntheir progress, the students utilized an online tool called Bryce [11], a Web-based software-process \nanalysis system used to record metrics for software develop\u00adment. The tool required times to be recorded \nfor each session. So a student who was going to slack off would have to lie about it frequently, and \nthe lies would be apparent to his/her partner.  After each project was due, each team member was asked \nto evaluate the other member s contribution. This appears to provide a way to assign a lower grade to \na student who did little work (although in fact it was not used that way because in the case of conflicting \nreports, it is difficult to tell who is telling the truth).  In most cases, the same students were not \nallowed to pair up for more than one project. The need to choose a different partner each time would \nprevent a student from taking advantage of the same student time and again. Moreover, the research on \npair programming seems to indicate that it is best to switch partners frequently. (This is because one \nlearns different things from different partners.)  In about a half-dozen cases, though, two students \nwere al\u00adlowed to pair together more than once. These were cases in which the students had a reason for \nwanting to maintain a part\u00adnership (e.g., they had the same class schedule) and they had submitted similar \nevaluations of each other on past projects. The students were shown a short video on pair programming, \nand then allowed to choose whether or not to pair-program. The majority chose to pair-program on the \nfirst and third projects, but ironically not on the second project. 3. STUDENT PERCEPTIONS All students \nwere surveyed after the end of the semester. Responses were received from 59 of the 96 students who participated \nin the projects, a response rate of 61%. Students who had pair-programmed viewed the experience in a \nvery positive light. When asked, How was the experience of pair program\u00adming? they ranked it 3.17 on \na scale of 1 to 4. Ironically, this was the exact same value as the computer-science students gave it \nlast year. Only 2 out of 42 this year s respondents rated it poor. When asked about cooperation among \nteam members, the students were even more enthusiastic. They rated it 3.48 on a scale of 1 to 4 (compared \nto 3.51 by the CS students). Only one respondent rated it poor. Moreover, none of the 96 students complained \nto the instructor about their partnership. Students were similarly positive about the communication with \ntheir partners, rating it as 3.36 on a scale of 1 to 4 (compared to 3.43 for the CS students). Table \n1. Student perceptions of pair programming Vy. Good Good Fair Poor Avg. How was the experience of pair \nprogramming? 20 11 9 2 3.17 How was the cooperation among your team members? 26 11 4 1 3.48 How was the \ncommunication with your team? 20 18 3 1 3.36  4. QUALITY OF WORK In a course such as this, grades are \na good measure of the quality of student work. A statistical analysis was performed using analy\u00adsis of \nvariance (ANOVA) with student grades as the response variable and paired or not paired as the explanatory \nvariable. We counted each grade of a non-paired individual, and each grade of a programming pair as a \nsingle observation. The instructor reserved the right to assign different grades to each member of a \nprogramming pair, based on feedback from the two members. However, there was no case in which different \ngrades were assigned to the two partners. We were not sure how to handle the separate projects. First, \nwe decided to do a separate analysis for each project assuming that the results would be the same. This \nwas not the case. For Project 1, pair programming produced significantly better results than solo programming, \nbut there was no significant difference for Projects 2 and 3. To obtain a single result, all of the data \nwas merged together, a new variable was created to indicate the project. Then ANOVA was run treating \nthe project as a replica\u00adtion variable (three replications). This analysis resulted in no significant \ndifference between pair programming and regular programming (p-value = .065). Table 2. Grade Comparison \nfor Pair vs. Solo Programming Project 1 Project 2 Project 3 Mean Std. Mean Std. Mean Std. n 41 grade \ndev. 94.7 0.92 p 0.007 n 23 grade dev. 99.33 3.95 p 0.664 n 28 grade dev. 94.68 9.37 p 0.17 Paired Solo \n19 90.2 1.39 29 96.28 7.87 17 91.18 15.75 All 101 93.2 8.87 75 97.54 8.53 73 91.42 17.00 Note that the \nn for all students is derived by taking the number of pairs \u00d7 2 + the number of solo programmers. However, \nit should be noted that statistical significance is difficult to obtain in pair-programming experiments. \nFirst there is the limited number of observations: Each project was done by 88 to 96 students, which \nmeans that even in the best case we would have only about 30 pairs performance to compare with the performance \nof about 30 solo programmers. Then there is the fact that grades for programming projects usually do \nnot vary much: For Project 2, the 1st quartile, median, third quartile, and high grade were all 100%. \nThe situation was not quite so uniform for Project 1 (1st quartile of 90, 3rd quartile of 98) or Project \n3 (1st quartile of 94, 3rd quartile of 100). In this environment, the fact that statistical significance \nwas found for one of the projects is surprising. Project 1 (a simulator of a cache with prefetching) \nwas definitely the most difficult of the projects, and this may have served to spread out the grades \nenough for significance to be obtained. From Table 2, we also observe that fewer students paired for \nProjects 2 and 3 than for Project 1. Table 1 would suggest that this is not due to any disenchantment \nwith pair programming. Three factors may be at work. First, after Project 1, students were more comfortable \nwith the computing environment and with wri\u00adting simulation programs, leading to less perceived need \nto pair with someone else. Second, as noted above, Projects 2 (branch prediction) and 3 (out-of-order \nexecution) were not as difficult as Project 1. Finally, students schedules fill up as the semester progresses, \nand they are less able to make time to meet with a partner. Further support for the theory that pair \nprogramming helped is the fact that the students who did not pair for any of the three projects had an \naverage score for the rest of their homework and exams in this class of 79.4%, while those who paired \nfor all three projects had an average of only 77.0% on their other work. This suggests that while the \nsolo programmers were in some sense better computer architecture students, they still scored lower on \nthe projects. However, this difference was not significant (p = .531). We might be able to establish \nsignificance with an analysis of covariance of the project scores and final grades with the final adjusted \ngrade as the covariate, but this analysis could not be performed in time for publication.  5. CONCLUSION \nOur experience shows that pair programming is a useful technique even in courses where programming is \nnot taught. Through the process of pair programming and the tools to track progress, our students managed \nto avoid the problems that had plagued programming teams in this class in earlier semesters. The students \nreacted very well to the experience, and, while data on productivity and grades is still forthcoming, \nwe are confident that they will show the experiment to be a success. 6. ACKNOWLEDGMENTS The author wishes \nto acknowledge the contributions of Computer Science graduate students Nachiappan Nagappan, who wrote \nthe Bryce tool for data collection, and Vinay Ramachandran, who wrote the Web-based program that collected \nthe reports on students perceptions of their partners, as well as Dr. Laurie Williams, their supervisor. \nNagappan was funded by NSF DUE CCLI grant #0088178. Ramachandran was funded by the Center for Advanced \nComputing and Communication (CACC), a membership-based industry/university cooperative research center \nco-located at North Carolina State University and Duke University. The statistical analyses were performed \nby Janet L. Bartz, a graduate student in statistics, under the supervision of Dr. Christopher Basten. \n 7. REFERENCES [1] L. A. Williams, Pair programming, http://www4.ncsu.edu/~lawilli3/PP/PairProgramming.pdf \n[2] L. A. Williams, The Collaborative Software Process PhD Dissertation , Department of Computer Science, \nUniversity of Utah. Salt Lake City, 2000. [3] J. T. Nosek, The case for collaborative programming , Communications \nof the ACM 41:3, March 1998, p. 105 108. [4] L. A. Williams, and R. Kessler, Pair Programming Illumina\u00adted, \nBoston, MA: Addison Wesley, 2002. [5] L. Williams, R. Kessler, W. Cunningham, and R. Jeffries, Strengthening \nthe case for pair-programming , IEEE Software 17:4, July/Aug 2000, pp. 19 25. [6] A. Cockburn, and L. \nWilliams, The costs and benefits of pair programming , in Extreme Programming Examined, Succi, G., Marchesi, \nM. eds., pp. 223 248, Boston, MA: Addison Wesley, 2001. [7] H. Bullock, J. Fernald, C. McDowell, and \nL. Werner The effects of pair programming on performance in an introductory programming course, Proc. \n33rd SIGCSE Technical Symposium on Computer Science Education, Covington, KY, Feb. 27 Mar. 3, 2002, pp. \n38 42. [8] H. Bullock, J. Fernald, C. McDowell, and L. Werner, The impact of pair programming on student \nperformance and pursuit of computer science-related majors, Proc. International Conference on Software \nEngineering 2003 [to appear]. [9] P. P. Baheti, E. F. Gehringer, and David Stotts, Exploring the efficacy \nof distributed pair programming, Proc. XP Agile Universe 2002, Lincolnshire, IL, Aug. 4 7, 2002 [10] \nP. P. Baheti, L. A. Williams, Edward F. Gehringer, and David Stotts, Exploring pair programming in distributed \nobject-oriented team projects, Proc. OOPSLA (Object-Oriented Programming Languages, Systems, and Applications), \nEducators Symposium, Seattle, Nov. 5, 2002. [11] http://bryce.csc.ncsu.edu/tool/default.jsp  \n\t\t\t", "proc_id": "949344", "abstract": "Pair programming is a concept where two programmers work side by side at the same computer, writing code jointly. One of them, called the <i>driver</i>, is in control of the keyboard and mouse. The other, called the <i>navigator</i>, observes what the driver is doing and offers advice. It is the driver's job to write the code. The navigator has a chance to observe the larger picture, evaluating the driver's code for correctness of design and implementation. Studies have shown that pair programming is very effective. Two programmers can finish a task in little over half the elapsed time that a single programmer takes. And the quality of the code-measured in terms of absence of defects-is much higher.In the past few years, pair programming has made inroads into industry and into programming courses. However, it has not typically been used in courses that teach subjects other than programming or software engineering, nor has it been used in the analysis of experimental results. This paper reports on an experiment in a combined senior/masters-level computer architecture class, using Hennessy & Patterson's <i>Computer Architecture: A Quantitative Approach</i> as a text. Students were required to implement three projects simulating various aspects of a microarchitecture (cache, branch predictor, dynamic instruction scheduler). Then they engaged in an experimental analysis to find the best configuration in a design space. Students reported high levels of satisfaction with the experience of pair programming. Pair programmers obtained significantly higher grades on Project 1; however, differences on the other projects were not statistically significant.", "authors": [{"name": "Edward F. Gehringer", "author_profile_id": "81100280253", "affiliation": "North Carolina State University, Raleigh, NC", "person_id": "P75228", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949397", "year": "2003", "article_id": "949397", "conference": "OOPSLA", "title": "A pair-programming experiment in a non-programming course", "url": "http://dl.acm.org/citation.cfm?id=949397"}