{"article_publication_date": "10-26-2003", "fulltext": "\n Smart Play-Out * David Harel, Hillel Kugler, Rami Marelly and Amir Pnueli {dharel,kugler,rami,amir}@wisdom.weizmann.ac.il \nDepartment of Computer Science and Applied Mathematics The Weizmann Institute of Science Rehovot, Israel \n ABSTRACT We describe smart play-out , a new method for execut\u00ading and analyzing scenario based behavior, \nwhich is part of the Play-In/Play-Out methodology and the Play-Engine tool. Behavior is played in directly \nfrom the system s GUI, and as this is being done the Play-Engine continuously constructs Live Sequence \nCharts (LSCs), a powerful exten\u00adsion of sequence diagrams. Later, behavior can be played out freely from \nthe GUI, and the tool executes the LSCs directly, thus driving the system s behavior. An inherent di.culty \nin constructing a play-out mechanism is how to resolve the nondeterminism allowed by the LSC speci.ca\u00adtion \nin order to obtain an executable model. Smart play\u00adout, is a recent strengthening of the play-out mechanism, \nwhich addresses this problem by using powerful veri.cation methods, mainly model-checking, to execute \nand analyze the LSCs, helping the execution to avoid deadlocks and viola\u00adtions. Thus, smart play-out \nutilizes veri.cation techniques to run programs, rather than to verify a program with re\u00adspect to given \nrequirements, as in traditional veri.cation ap\u00adproaches. The ideas appear to be relevant in various stages \nof system development, including requirements speci.cation and analysis, implementation and testing. \nCategories and Subject Descriptors: D.2.1 [Software Engineering] : Requirements/Speci.cations, Software/ \nPro\u00adgram Veri.cation. General Terms: Languages, Veri.ca\u00adtion. Keywords: System Modeling and Execution, \nSce\u00adnarios, Object-Oriented Analysis and Design, UML, LSCs, Play-Out. 1. INTRODUCTION 1.1 Scenario \nbased requirements and LSCs Understanding system and software behavior by looking at various stories \nor scenarios seems a promising approach, and it has focused intensive research e.orts in the last few \nyears. One of the most widely used languages for spec\u00adifying scenario-based requirements is that of message \nse\u00ad * This research was supported in part by the John von Neu\u00admann Minerva Center for the Veri.cation \nof Reactive Sys\u00adtems and by the European Commission project OMEGA (IST-2001-33522). Copyright is held \nby the author/owner. OOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. \n quence charts (MSCs), adopted long ago by the ITU [10], or its UML variant, sequence diagrams [9]. \nSequence charts (whether MSCs or their UML variant) possess a rather weak partial-order semantics that \ndoes not make it possible to capture many kinds of behavioral requirements of a system. To address this, \nwhile remaining within the general spirit of scenario-based visual formalisms, a broad extension of MSCs \nhas been proposed, called live sequence charts (LSCs) [2]. LSCs distinguish between behaviors that may \nhappen in the system (existential) from those that must happen (uni\u00adversal). A universal chart contains \na prechart,which spec\u00adi.es the scenario which, if successfully executed, forces the system to satisfy \nthe scenario given in the actual chart body. The distinction between mandatory (hot) and provisional \n(cold) applies also to other LSC constructs, e.g., conditions and locations, thus creating a rich and \npowerful language, which among many other things can express forbidden be\u00adhavior ( anti-scenarios ). \n 1.2 The Play-In Play-Out Approach In [5] a methodology for specifying and validating require\u00adments, \ntermed play-in/play-out approach is described. Ac\u00adcording to this approach, requirements are captured \nby the user playing in scenarios using a graphical interface of the system to be developed or using an \nobject model diagram. The user plays the GUI by clicking buttons, rotating knobs and sending messages \n(calling functions) to objects in an intuitive manner. By similarly playing the GUI, the user describes \nthe desired reactions of the system and the con\u00additions that may or must hold. As this is being done, \nthe supporting tool, called the Play-Engine, constructs a formal version of the requirements in the form \nof LSCs. Play-out is a complementary idea to play-in, which, rather surprisingly, makes it possible to \nexecute the requirements directly. In play-out, the user simply plays the GUI ap\u00adplication as he/she \nwould have done when executing a sys\u00adtem model, or the .nal system implementation, but limiting him/herself \nto end-user and external environment actions only. While doing this, the Play-Engine keeps track of the \nactions and causes other actions and events to occur as dic\u00adtated by the universal charts in the speci.cation. \nHere too, the engine interacts with the GUI application and uses it to re.ect the system state at any \ngiven moment. This process of the user operating the GUI application and the Play-Engine causing it to \nreact according to the speci.cation has the e.ect of working with an executable model, but with no intra-object \nmodel having to be built or synthesized. Play-out is actually an iterative process, where after each \nstep taken by the user, the Play-Engine computes a super\u00adstep, which is a sequence of events carried \nout by the system as its response to the event input by the user. The play-out mechanism of [5] is rather \nnaive when faced with nondeter\u00adminism, and makes essentially an arbitrary choice among the possible responses. \nThis choice may later cause a vio\u00adlation of the requirements, whereas by making a di.erent choice the \nrequirements could have been satis.ed.  2. SMART PLAY-OUT Smart play-out was introduced in [4] and \nsince then has been extended to cover a larger set of the LSC language fea\u00adtures and to deal more e.ciently \nwith larger models. We have also gained experience in applying the method to sev\u00aderal applications and \ncase studies. 2.1 Motivation The motivation is to try to resolve the nondeterminism allowed by the LSC \nspeci.cation in a smarter way. From a conceptual point of view, the potential of many possi\u00adble sequences \nof reactions to a user event is due to the fact that LSCs is a declarative, inter-object language, and \nas such it enables formulating high level behavior in pieces (e.g., scenario fragments), leaving open \ndetails that may de\u00adpend on the implementation. Technically, the two sources of this nondeterminism are \nthe partial order semantics among events in each chart, and di.erent charts containing scenar\u00adios that \ndo not have enough information about their inter\u00adrelationship. These features are very useful in early \nrequire\u00adment stages, but can cause undesired under-speci.cation when one attempts to consider them as \nthe system s exe\u00adcutable behavior. Smart play-out attempts to remove these sources of nondeterminism \nduring execution. It should be noted that smart play-out, at least as it stands today, looks one super-step \nahead, while full synthesis algorithms [3] per\u00adform a complete analysis. However, the latter are still \nim\u00adpractical, due to computational complexity problems. 2.2 The Approach The approach we use is to formulate \nthe play-out task as a veri.cation problem, and to use the counterexample pro\u00advided by a model-checking \n[1] algorithm as the desired super\u00adstep. The system on which we perform model-checking is constructed \naccording to the universal charts in the LSC speci.cation. We de.ne a transition relation generated from \nthe LSC speci.cation, which is designed to allow progress of active universal charts, but prevents any \nviolations. The system is initialized to re.ect the status of the application just after the last external \nevent occurred, including the cur\u00adrent values of object properties, information on the universal charts \nthat were activated as a result of the most recent ex\u00adternal events, and the progress in all precharts. \nThe model\u00adchecker is then given a property claiming that always at least one of the universal charts \nis active. This is really the nega\u00adtion of what we want since in order to falsify the property, the model-checker \nsearches for a run in which eventually none of the universal charts is active; i.e., all active uni\u00adversal \ncharts complete successfully, and by the de.nition of the transition relation no violations occurred \nin the process. Such a counter-example is the desired super-step. If the model-checker veri.es the property \nthen no correct super\u00adstep exists but if it doesn t, the counter-example is exactly what we seek. For \nmore details see [4].  2.3 Satisfying Existential Charts Smart play-out can also be used to satisfy \nexistential charts, which can be used to specify system tests. Smart play-out can then be used to automatically \n.nd a trace (if there is one) that satis.es the chart without violating universal charts on the way. \nThis can be very useful in understanding the possible behavior of a system and also in detecting prob\u00adlems \nby asking if a certain scenario, which we believe cannot be realized by the system, can be satis.ed. \nIf smart play-out manages to satisfy the chart it will execute the trace, thus providing evidence for \nthe cause of the problem.  3. APPLICATIONS In the demo session we will show and explain the tool, illustrating \nthe approach as applied to several applications we have studied. These include a phone network [8], a \nma\u00adchine for manufacturing smart-cards [6] and a model of a biological system [7]. *** As a long-term \nvision, we believe that for certain kinds of systems the play-out methodology, enhanced by formal ver\u00adi.cation \ntechniques, could serve as the .nal implementation too, with play-out being all that is needed for running \nthe system itself. 4. REFERENCES [1] E.C. Clarke, O. Grumberg, and D. Peled. Model Checking. MIT Press, \n1999. [2] W. Damm and D. Harel. LSCs: Breathing life into message sequence charts. Formal Methods in \nSystem Design, 19(1):45 80, 2001. Preliminary version appeared in Proc. 3rd IFIP Int. Conf. on Formal \nMethods for Open Object-Based Distributed Systems(FMOODS 99). [3] D. Harel and H. Kugler. Synthesizing \nState-Based Object Systems from LSC Speci.cations. Int. J. of Foundations of Computer Science (IJFCS)., \n13(1):5 51, Febuary 2002. (Also,Proc. Fifth Int. Conf. on Implementation and Application of Automata \n(CIAA 2000), LNCS 2088, Springer-Verlag, 2000.). [4] D. Harel, H. Kugler, R. Marelly, and A. Pnueli. \nSmart play-out of behavioral requirements. In Proc. 4th Intl. Conference on Formal Methods in Computer-Aided \nDesign (FMCAD 02), Portland, Oregon, volume 2517 of Lect. Notes in Comp. Sci., pages 378 398, 2002. [5] \nD. Harel and R. Marelly. Come, Let s Play: Scenario-Based Programming Using LSCs and the Play-Engine. \nSpringer-Verlag, 2003. [6] H. Kugler and G. Weiss. Modeling a Smart-Card Personalization Machine with \nLSCs. Technical report, Weizmann Institute, 2003. [7] N.Kam,D.Harel,H.Kugler, R. Marelly,A.Pnueli, E.J.A. \nHubbard, and M.J. Stern. Formal Modeling of C. elegans Development: A Scenario-Based Approach. Proc. \nInt. Workshop on Computational Methods in Systems Biology (CMSB 2003), 2003. [8] R. Marelly, D. Harel, \nand H. Kugler. Multiple instances and symbolic variables in executable sequence charts. In Proc. 17th \nAnn. ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA 02), pages \n83 100, Seattle, WA, 2002. [9]UML.Documentation ofthe uni.ed modelinglanguage (UML). Available from OMG, \nhttp://www.omg.org.  [10] Z.120 ITU-TS Recommendation Z.120: Message Sequence Chart(MSC).ITU-TS, Geneva, \n1996.  \n\t\t\t", "proc_id": "949344", "abstract": "We describe \"smart play-out\", a new method for executing and analyzing scenario based behavior, which is part of the Play-In/Play-Out methodology and the Play-Engine tool. Behavior is \"played in\" directly from the system's GUI, and as this is being done the Play-Engine continuously constructs Live Sequence Charts (LSCs), a powerful extension of sequence diagrams. Later, behavior can be \"played out\" freely from the GUI, and the tool executes the LSCs directly, thus driving the system's behavior. An inherent difficulty in constructing a ``play-out\" mechanism is how to resolve the nondeterminism allowed by the LSC specification in order to obtain an executable model. Smart play-out, is a recent strengthening of the play-out mechanism, which addresses this problem by using powerful verification methods, mainly model-checking, to execute and analyze the LSCs, helping the execution to avoid deadlocks and violations. Thus, smart play-out utilizes verification techniques to run programs, rather than to verify a program with respect to given requirements, as in traditional verification approaches. The ideas appear to be relevant in various stages of system development, including requirements specification and analysis, implementation and testing.", "authors": [{"name": "David Harel", "author_profile_id": "81100197485", "affiliation": "The Weizmann Institute of Science, Rehovot, Israel", "person_id": "PP14078578", "email_address": "", "orcid_id": ""}, {"name": "Hillel Kugler", "author_profile_id": "81100514755", "affiliation": "The Weizmann Institute of Science, Rehovot, Israel", "person_id": "P397038", "email_address": "", "orcid_id": ""}, {"name": "Rami Marelly", "author_profile_id": "81100333946", "affiliation": "The Weizmann Institute of Science, Rehovot, Israel", "person_id": "P397047", "email_address": "", "orcid_id": ""}, {"name": "Amir Pnueli", "author_profile_id": "81100648459", "affiliation": "The Weizmann Institute of Science, Rehovot, Israel", "person_id": "PP15038449", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949353", "year": "2003", "article_id": "949353", "conference": "OOPSLA", "title": "Smart play-out", "url": "http://dl.acm.org/citation.cfm?id=949353"}