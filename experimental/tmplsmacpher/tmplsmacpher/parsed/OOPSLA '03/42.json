{"article_publication_date": "10-26-2003", "fulltext": "\n Using Graphics to Support the Teaching of Fundamental Object-Oriented Principles in CS1 Carl Alphonce \nDept. Comp. Sci. &#38; Eng. University at Buffalo, SUNY Buffalo, NY 14260-2000 alphonce@cse.buffalo.edu \nABSTRACT Teaching object-oriented programming in CS1 is hard. Keep\u00ading the attention of CS1 students \nis perhaps even harder. In our experience the former can be done successfully with very satisfying results \nby focusing on the fundamental prin\u00adciples of object-orientation, such as inheritance, polymor\u00adphism \nand encapsulation. The latter can be done by hav\u00ading students create graphical event-driven programs. \nCare must be taken, however, since teaching graphics can eas\u00adily distract students and certainly takes \ntime away from the fundamentals being taught. We use Java as a vehicle for OO instruction, but rather \nthan expose CS1 students to the intricacies of Swing we employ an elegant and small graphics package \ncalled NGP. NGP allows students to create event-driven graphical programs using only inheritance and \nmethod overriding. We describe how we use NGP to en\u00adhance rather than detract from our teaching of fundamental \nOO principles. Categories and Subject Descriptors K.3.2 [Computers and Education]: Computer and Infor\u00admation \nScience Education Computer Science Education General Terms Design  Keywords Object-orientation, CS1, \nJava, NGP, graphics 1. CONTEXT OF EXPERIENCE 1.1 The course We have been teaching object-orientation \nin CS1 using Java for many years. The course has evolved a great deal Copyright is held by the author/owner. \nOOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. Phil Ventura Dept. \nComp. Sci. &#38; Eng. University at Buffalo, SUNY Buffalo, NY 14260-2000 pventura@cse.buffalo.edu since \nits early Java-based o.erings. The course now empha\u00adsizes design in an objects-.rst approach. Objects \nare introduced to students in the very .rst day of classes, and object-oriented fundamentals such as \ninher\u00aditance, polymorphism and encapsulation are introduced to the students within the .rst few weeks. \nBy the end of the course students are able to write rea\u00adsonably sophisticated event-driven graphical \nprograms. The .nal project typically requires students to implement a well\u00adknown computer game such as \nTetris or Nibbles. 1.2 The students The course enrolls 200 to 300 students per semester, spread over \nthree to four lecture sections and twelve to sixteen lab sections. Although our CS1 course has no formal \ncourse prerequisites, approximately half of the students have prior programming experience, though only \nrarely is this experi\u00adence truly object-oriented. Our students, like the majority of today s students, \nare well acquainted with the use of computers and therefore with graphical event-driven programs. Writing \ntext-based programs rarely captures their attention. In fact, it typi\u00adcally does just the opposite. \n 2. DESCRIPTION OF EXPERIENCE 2.1 Piquing and keeping students interest Teaching object-oriented programming \nin CS1 is hard. Keeping the attention of CS1 students is perhaps even harder. Making course materials \nand course projects appealing to students is a prerequisite to learning. In early August of this year \na thread (Simplifying Java for CS1 ) discussing the use of text I/O arose on the SIGCSE list. We feel \ncom\u00adpelled to quote a highly relevant comment by Ian Utting in this thread: In the olden days, when I \nlearnt programming, printing out a triangle made of asterisks (on the ASR-33 console) was a signi.cant \nachievement. Today s students, bought up on cinema-quality shoot-em-ups, are much less impressed. One \nof the authors has a similar recollection. Printing a Celsius-to-Fahrenheit conversion table was a signi.cant \nachievement. User input was often not considered at all. Today s students have grown up in an environment \nin which computers are a part of everyday life. Text-based programs are not only unimpressive to these \nstudents, they are for\u00adeign to them. Students use graphical event-driven systems such as web browsers, \nword processors, automated banking machines, self-service checkouts and even pay-at-the-pump systems \nat gas stations every day. 2.2 Our philosophy Like many other educators, we have found that using graphics \nin a CS1 course can capture and hold the inter\u00adest of our students. A signi.cant challenge for educators \nis to make course materials interesting to their students with\u00adout giving up course content and without \ngetting bogged down in irrelevant details of a graphics package. There are, of course, many ways in which \none can do this. Alice (www.alice.org) is an excellent example of an environ\u00adment in which students can \nexplore programming concepts in a graphically rich environment. The intent of this paper is not to survey \nexisting environments or promote a partic\u00adular one (though we do discuss the graphics library we have \nfound useful). Instead our goal is to highlight how the use of graphics in the classroom can serve the \ndual purpose of keep\u00ading the attention and interest of students while simultane\u00adously supporting instruction \nof fundamental object-oriented concepts. In our environment we use Java as a vehicle for OO in\u00adstruction, \nbut rather than expose CS1 students to the in\u00adtricacies of Swing we employ an elegant and small graphics \npackage called NGP ( Nice Graphics Package ), developed at Brown University by Andries van Dam. 2.3 \nWe re not teaching the library A concern often expressed, one echoed in the SIGCSE mail list discussion \nmentioned above, is that non-standard libraries are a waste of time since students will not use them \noutside the scope of the one course. Our response to this is that we are not teaching students the library, \nwe are teaching students object-orientation using the library as a supportive mechanism to accomplish \nthis. We are no more interested in teaching students AWT/Swing in the .rst course than we are in teaching \nthem NGP. Trying to use raw AWT/Swing in the .rst course is more complex than using NGP be\u00adcause of the \nlarge amount of background understanding of object-oriented concepts required to use it. Students cannot \nwrite graphical event-driven programs using AWT/Swing until much later in the course, when they already \nunder\u00adstand the object-oriented concepts. An obvious way around this is to provide students with classes \nwhich hide the complexity of AWT/Swing. This is what NGP does for us. It allows us to focus on using \ngraph\u00adical event-driven programs to deepen our students under\u00adstanding of object-oriented concepts. \n 2.4 NGP in brief NGP provides basic yet very functional graphical contain\u00aders and components. Here we \ngive a thumbnail sketch of NGP. For those who are interested Brown University has a more comprehensive \nNGP tutorial on the web: www.cs.brown.edu/courses/cs015/2002/Docs/tutorial Basic containers include (among \na handful of others) Row and Column. These are essentially JPanels with layout man\u00adagers already installed. \nA Row arranges items placed within it in a row, while a Column arranges its contained items in a column. \nThe parent (containing) container of any NGP con\u00adtainer or component is given as an argument in its construc\u00adtor. \nThe superclass constructor adds the item to the parent container automatically. NGPs pallet of containers \nis not as varied or as .exible as that found using raw AWT/Swing, but a surprising amount of very reasonable \nlayout can be accomplished using inly Rowsand Columns. NGP.Component classes, such as PushButton, provide \nevent\u00addriven reactivity by in e.ect making instances be their own event handlers. For example, a PushButton \nobject provides a release() method which a subclass can override to de\u00ad.ne a behavior. The actionPerformed \nmethod of (an inner class event handler of) the superclass calls the superclass release() method, which \nis de.ned with an empty body. This complexity is hidden from the students by design. To specify what \nshould happen when a button is clicked a stu\u00addent needs only to subclass the PushButton class and over\u00adride \nthe release() method. The same approach is taken with NGP.Graphics classes (shapes and images) which \ncan be placed in a special con\u00adtainer called a DrawingPanel. Objects instantiated from NGP.Graphics classes \nsuch as FilledRectangle and Filled Ellipse, are represented by shapes and are reactive. In the simplest \ncase a student needs only to subclass the Filled Rectangle (or similar) class and override the react() \nmethod to specify what should happen when the mouse is clicked over the shape. Using such containers \nand components students are able to create graphical event-driven applications without need\u00ading to know \nabout things such as layout managers or event listeners. Students are able to build cool programs while \nlearning about inheritance, the importance of being able to specify a method in a superclass but de.ne \nit in a subclass, polymorphism and polymorphic dispatch, the role of inter\u00adfaces, and so on. 2.5 Teaching \nfundamental object-oriented prin\u00adciples A good starting point when teaching students about a new concept \nis to ground it in something our students are already familiar with. Luckily, concepts such as inheritance \nand polymorphism are natural to students from everyday life. Inheritance is seen in typologies of many \nsorts. An ex\u00adample surely many educators have used is that of animals, mammals, reptiles, dogs, cats \nand other creatures arranged into an inheritance hierarchy. Polymorphism and polymorphic dispatch is \nalso fairly easy to explain in everyday terms. The .rst author frequently tells his class,1 Assume that \nall pets have tails. Suppose I know that John has a pet and that Mary also has a pet. Unbeknownst to \nme John has a cat and Mary has a dog. I only know that each one has a pet. If I pull John s pet s tail \nit growls at me. If I pull Mary s pet s tail it hisses at me and scratches me. The same message results \nin di.erent behaviors. Students understand this. Understanding these concepts and applying them in a \npro\u00adgramming environment is a bit trickier. Graphical reinforce\u00adment of the concepts is therefore quite \nhelpful, especially if it 1No pets were harmed in the making of this example. helps students tie the \nabstract programming notion to their grounded real-world understanding of the concept. The goal of this \npaper is to demonstrate one way in which this can be done using graphical event-driven programs to support \nthe teaching of these concepts. A key component of the ap\u00adproach is to use a graphical package which \nprovides such pedagogical support. We have found the NGP library to be e.ective in this regard, though \nother libraries or home-grown approaches could work just as well.  2.6 Creating objects On the .rst \nday of class we present and discuss the notion of an object, noting that objects have properties and \nbehav\u00adiors, and show how objects can be created. The students .rst programming exercise requires them \nto create instances of pre-de.ned classes. These classes are graphical in nature and thus provide visual \nfeedback. At this stage of thecourseweprovide studentswithtwo .les as a starting point for their laboratory \nwork. These two .les are an html .le for running an applet as well as a skeleton for an Applet which \nthey are instructed to .ll in: package Example1; public class Applet extends EdSymp.Applet { public Applet \n() { } } The superclass EdSymp.Applet is a subclass of the NGP\u00adprovided Applet class and adds a static \nDrawingPanel for displaying NGP.Graphics objects. Since the DrawingPanel is static we can easily de.ne \nspe\u00adcializations of NGP.Graphics objects to display automati\u00adcally on that (single) DrawingPanel. For \nexample, we can de.ne an EdSymp.Circle class, a subclass of the NGP.Graphics. FilledEllipse class, which \ndisplays a red circle on the Applet s DrawingPanel at a random location as follows: package EdSymp; public \nclass Circle extends NGP.Graphics.FilledEllipse { public Circle() { super(EdSymp.Applet._drawingPanel); \nsetDimension(new java.awt.Dimension(20,20)); setCenterLocation(EdSymp.Applet._drawingPanel. randomPoint()); \nsetColor(java.awt.Color.RED); } } Students do not see this code, however. In order to create an instance \nof the EdSymp.Circle class they need only add the code to instantiate this class in the skeleton we provide: \npackage Example1; public class Applet extends EdSymp.Applet { public Applet () { new EdSymp.Circle(); \n} } Figure 1 shows the result of running this applet. Of course, creating a single object is not as \ninteresting as creating multiple objects: package Example2; public class Applet extends EdSymp.Applet \n{ public Applet () {  Figure 1: Applet with one EdSymp.Circle object rep\u00adresented new EdSymp.Circle(); \nnew EdSymp.Circle(); new EdSymp.Circle(); } } Doing this results in a display such as that shown in \n.g\u00adure 2. Because each EdSymp.Circle object displays at a randomly generated position on the Applet s \nDrawingPanel the students receive visual reinforcement that the three dif\u00adferent class instantiations \nthey put into their source code really does result in three distinct objects, each with a dif\u00adferent \nvalue for the object s location property. None of this is new or revolutionary. The point to note is \nhow little code the students need to be exposed to in order to make this happen. To this point we have \nonly considered object creation. To demonstrate inheritance we have students create a subclass of an \nexisting class, per\u00adhaps an NGP component such as PushButton or one we provided to them like EdSymp.Circle. \nTode.ne aclass of circles similar to EdSymp.Circle but whose instances are java.awt.Color.WHITE a student \nmay write:2 package Example3; public class MyCircle extends EdSymp.Circle { public MyCircle () { super(); \nthis.setColor(java.awt.Color.WHITE); } } and modify their Applet to create a few instances of each kind \nof circle: package Example3; public class Applet extends EdSymp.Applet {  2The examples in the paper \nare representative of examples we discuss in lecture. They are, however, selected and mod\u00adi.ed to assist \nin the paper presentation and .gure printing. We also discuss more active, behavior-based examples whose \nscreenshots do not reproduce well on a static, printed page.  Figure 2: Applet with many EdSymp.Circle \nobjects represented public Applet () { new EdSymp.Circle(); new EdSymp.Circle(); new EdSymp.Circle(); \nnew Example3.MyCircle(); new Example3.MyCircle(); new Example3.MyCircle(); } } to produce what is shown \nin .gure 3. Students receive visual reinforcement of what they have written in code, with very little \noverhead.  2.7 Polymorphism An example we often use to introduce polymorphism is a state button. A state \nbutton is a PushButton which can be in di.erent states. A very simple example is a button whose text \nalternates between On and O. when clicked. A class diagram for this is shown in .gure 4. Of course, once \nthe state pattern is set up it is straightforward to incorporate more complex behaviors into the states \nif so desired. This example is interesting because, though small, it touches on all of the following \nconcepts: object creation inheritance overriding  polymorphic dispatch  and allows us to talk about \nthe state pattern. Because NGP hides the mechanics of event handling students need only write the following \ncode to create such a button class. package Example4; public class StateButton extends NGP.Components.PushButton \n{ private ButtonState _state;  Figure 3: Applet showing representations of objects of two di.erent classes \npublic StateButton() { super(EdSymp.Applet2._column, \"\"); _state = new OffState(); _state.activate(this); \n} public void release() { _state = _state.next(); _state.activate(this); } }  Note that the code which \nde.nes the behavior of the button when clicked is simply: public void release() { _state = _state.next(); \n_state.activate(this); } Rather than get bogged down with the details of AWT/Swing event handlers students \ncan focus on the relevant concepts being reinforced. Condensed somewhat in format to conserve space, \nthe rest of thecoderequiredfor this example isshown below: public interface ButtonState { public ButtonState \nnext(); public void activate(StateButton b); } public class OffState implements ButtonState { public \nButtonState next() { return new OnState(); } public void activate(StateButton b) { b.setText(\"Off\"); \n} } public class OnState implements ButtonState { public ButtonState next() { return new OffState(); \n } public void activate(StateButton b) { b.setText(\"On\"); } } To demonstrate the power of polymorphism \nin program\u00adming we borrow a project developed by Stephen Wong named BallWorld. Although a web search \nof BallWorld pulls up many di.erent projects with this name and with simi\u00adlar visual appearance, his \nis the only one we ve found which stresses good object-oriented design, through the use of de\u00adsign patterns \nand polymorphic dispatch. His original de\u00adscription can be found at www.exciton.cs.rice.edu/cs150/labs/lab1/ \nwww.exciton.cs.rice.edu/cs150/labs/lab2/section2.htm www.exciton.cs.rice.edu/cs150/labs/lab3/section2.htm \nBallWorld has proven to be a very rich environment in which to explore the power of polymorphism and \na variety of design patterns. BallWorld is a simulation of a set of bouncing balls within a virtual world. \nBallWorld becomes especially interesting when one starts to vary the behaviors of the balls, combine \nthem, and permit them to change dy\u00adnamically in response to event-driven user input. In order to do this \nstudents must be able to, handle event-driven user input,  encapsulate behaviors as objects,  set \nup polymorphic dispatch, and  employ relevant design patterns.  Moreover, the student must be able \nto show the results of this in a graphical manner. The basic design which we want students to aim for \nis shown in .gure 5. Event-driven user input is handled using the simple mech\u00adanism mentioned above involving \nsubclassing an existing class with the event-driven mechanism built in and over\u00adriding the magic method. \nThere is nothing special students need to do to get the graphical display since the Ball class we provide \ndoes the relevant work for them. Simplifying, our Ball class is essentially an NGP.Graphics.FilledEllipse \nwhich knows how to move. The whole simulation is driven by an NGP.Timer, which again follows the general \nevent\u00adhandling paradigm laid out earlier: the timer has a dedi\u00adcated event handler which calls a magical \nmethod in the Timer class. To make a special-purpose Timer class requires only that the NGP.Timer class \nbe subclassed and the magical method overridden. Students need to create a subclass (a BehaviorBall)which \nadds to the basic Ball class a Behavior as a property. The Behavior can be a Null behavior, in which \ncase the Behavior Ball behaves like an ordinary Ball. The behavior can also be composite, in which case \nall Behaviors of the composite must act on the BehaviorBall. A pull-down menu of available behaviors \nallows the user to select an arbitrary number of individual behaviors. The composite of the selected \nbehaviors is the current behav\u00adior . Whenever a BehaviorBall is created its initial behav\u00adior is the \ncurrent behavior . The BehaviorBalls need to be reactive too. When clicked they must change their behavior \ndynamically to whatever is now the currently selected composite behavior in the menu. The reactivity \nof the balls is achieved in the now familiar way of simply overriding the appropriate method from the \nsuperclass.  3. CONCLUSION Visual feedback is important to students -they see poly\u00admorphism working: \nno matter what speci.c behavior is asso\u00adciated with a BehaviorBall it acts appropriately: the timer calls \nan update method on the BehaviorBall, which dis\u00adpatches to the BehaviorBall s Behavior, which in turn \nacts on the BehaviorBall. Students can see composite behaviors at work. They see event dispatch (dynamic \nchanging of behavior), and they know why things are happening -because they wrote the code! That is to \nsay: they don t know the details of the event handling, but they do know how the change in be\u00adhavior \noccurs in response to a particular event. The code they wrote accomplishes the action of the behaviors \non the BehaviorBalls, or the dynamic changing of Behavior act\u00ading on a BehaviorBall. Students are able \nto focus on the interesting object-oriented concepts rather than on the par\u00adticulars of the graphics \nlibrary or the event-handling mecha\u00adnism. These things will be important in the second semester course. \nBy the time students take that course they under\u00adstand enough about object-orientation and design patterns \nto unwrap NGP and see the workings under the hood . What is the point? The point is that through the \nuse of appropriate exercises graphics can be used to accomplish two goals: (i) keep students interested \n(once they see how the pieces .t together students are excited about BallWorld), and (ii) reinforce the \nfundamental principles taught by mak\u00ading the relationship between the graphical components and the underlying \nprogram components and relationships as transparent as possible. 4. WHAT OTHER OO EDUCATORS CAN LEARN \nOur goal in this paper has been to highlight how the use of graphics in the classroom can serve the dual \npurpose of keep\u00ading the attention and interest of students while simultane\u00adously supporting instruction \nof fundamental object-oriented concepts. There is no doubt that today s students feel at home work\u00ading \nwith and writing graphical event-driven applications. As educators we should leverage this as much as \npossible in our teaching. Although signi.cant hurdles can exist in using the raw graphics libraries of \nlanguages not mainly designed for teaching, these can be overcome. In the speci.c case of Java we feel \nthe raw AWT/Swing classes require too much pre-existing knowledge of object-orientation and design pat\u00adterns \nto be helpful as a tool in teaching object-orientation and design patterns to beginning students. We \nhave found the NGP library useful because it wraps raw AWT/Swing classes in a sensible way to make available \nto students a very usable graphical library at an appropriate level of abstrac\u00adtion. With this we are \nable to get students started very early on in CS1 writing graphical event-driven programs while learning \nabout fundamental object-oriented concepts and good software design through design patterns. Figure \n4: The StateButton UML class diagram Figure 5: The BallWorld UML class diagram  \n\t\t\t", "proc_id": "949344", "abstract": "Teaching object-oriented programming in CS1 is hard. Keeping the attention of CS1 students is perhaps even harder. In our experience the former can be done successfully with very satisfying results by focusing on the fundamental principles of object-orientation, such as inheritance, polymorphism and encapsulation. The latter can be done by having students create graphical event-driven programs. Care must be taken, however, since teaching graphics can easily distract students and certainly takes time away from the fundamentals being taught. We use Java as a vehicle for OO instruction, but rather than expose CS1 students to the intricacies of Swing we employ an elegant and small graphics package called NGP. NGP allows students to create event-driven graphical programs using only inheritance and method overriding. We describe how we use NGP to enhance rather than detract from our teaching of fundamental OO principles.", "authors": [{"name": "Carl Alphonce", "author_profile_id": "81100135442", "affiliation": "University at Buffalo, SUNY, Buffalo, NY", "person_id": "PP14058142", "email_address": "", "orcid_id": ""}, {"name": "Phil Ventura", "author_profile_id": "81100151694", "affiliation": "University at Buffalo, SUNY, Buffalo, NY", "person_id": "P361190", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949391", "year": "2003", "article_id": "949391", "conference": "OOPSLA", "title": "Using graphics to support the teaching of fundamental object-oriented principles in CS1", "url": "http://dl.acm.org/citation.cfm?id=949391"}