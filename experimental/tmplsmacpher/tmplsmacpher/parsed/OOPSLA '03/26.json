{"article_publication_date": "10-26-2003", "fulltext": "\n Variant Management for Embedded Software Product Lines with Pure::Consul and AspectC++ Danilo Beuche \npure-systems GmbH Agnetenstr. 14 D-39106 Magdeburg danilo.beuche@pure-systems.com General Terms Design, \nLanguages, Management Categories and Subject Descriptors D.2.13 [Software Engineering]: Reusable Software \nDomain en\u00adgineering, Software product lines; D.2.9 [Software Engineering]: Management Software con.guration \nmanagement  Keywords aspect-oriented programming, variant management, C++, embed\u00added systems, aop 1. \nINTRODUCTION Software for embedded systems faces some special constraints not found in other domains. \nOne of these constraints is a hard lim\u00aditation on available RAM/ROM, processing power, and other re\u00adsources. \nTo cope with these limitations without losing the reusabil\u00adity of the software components, product line \ntechnologies are a promising approach. However, adequate tools for variant manage\u00adment are still rare. \nIn the demonstration we will apply Pure::Consul [1], a tool which supports the description of problem \nand solution domains of product lines, software families, or other variable artifacts in a highly .exible \nmanner, to a realistic application scenario: a weather station product line running on a small 8 bit \nmicrocontroller with only a few KBytes of memory. The implementation of the presented product line is \nbased on As\u00adpectC++, an aspect-oriented extension to C++ [3]. We will demon\u00adstrate that by applying aspect-oriented \nsoftware development, the number of con.guration points in the code can be reduced. Both tools together \nform an ideal tool chain for embedded software prod\u00aduct line development as one reduces the con.guration \ncomplexity on the source code level, while the other helps to manage the vari\u00adability on the abstract \nfeature level and provides a mapping of fea\u00adtures to aspects, classes, or other modularization units. \n 2. PURE::CONSUL The Pure::Consul tool chain has been designed for develop\u00adment and deployment of software \nprogram families. The core of Pure::Consul are several models which are used to represent the problem \ndomain of the family, the solution domain(s) and .nally Copyright is held by the author/owner. OOPSLA \n03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. Olaf Spinczyk University \nof Erlangen-Nuremberg Martensstr. 1 D-91058 Erlangen  olaf.spinczyk@informatik.uni-erlangen.de to specify \nthe requirements for a speci.c representative (member) of the family. The tool allows for integration \nof many different variability realization techniques through its customizable transfor\u00admation backend. \nThus, it is able to incorporate frame processors, code generators, or arbitrary other tools. The central \nrole is played by feature models which are used to represent the problem domain in terms of commonalities \nand vari\u00adabilities. Pure::Consul uses an enhanced version of feature models compared to the original \nfeature models as proposed in the FODA method [2]. The solution domain(s) (i.e. the implementations) \nare described using the Pure::Consul Component Family Model (CCFM). It al\u00adlows to describe the mapping \nof user requirements onto variable component implementations, i.e. the customization of a set of com\u00adponents \nfor a particular context. As the name suggests, this model has been newly developed for Pure::Consul. \nThe feature sets are used at deployment time and describe a par\u00adticular context in terms of features \nand associated feature values. Figure 1: Overview of Pure::Consul process Figure 1 illustrates the basic \nprocess of customization with Pure::Consul. Most steps can be performed automatically once the various \nmodels have been created. The developers of variable com\u00adponents have to provide the feature models, \nthe component family models, and the implementations itself. A user1 provides the re\u00adquired features, \nthe tools analyze the various models and generate the customized component(s). The key difference between \nPure::Consul and other similar ap\u00adproaches is, that Pure::Consul models only describe what has to be \ndone, not how it should be done. Pure::Consul provides only .Here a user can be either human or also \na tool which is able to derive the set of required features automatically from some input Figure 2: \nPure::Consul graphical user interface basic mechanisms for manipulation and generation, which can be \nextend according to the needs of the Pure::Consul user. This .ex\u00adibility is achieved by combining two \npowerful languages inside Pure::Consul and allowing the user to extend this system. The .rst language \nis Prolog, a widely known language for logic programming. Prolog is used for constraint checking, i.e. \nfor ex\u00adpressing relations between different features. The same logic en\u00adgine is used for component selection \nand customization control. The second language is a XML-based language called XML-Trans which allows \nto describe the way customization (transforma\u00adtion) actions are to be executed. Due to its modular structure, \nit can be extended with user supplied transformation modules. This can be used to provide seamless access \nto special generators or other tools from within the tool chain. The tool chain consists of several different \ntools for different pur\u00adposes. A command line client allows integration into automated processes, while \nthe graphiclal frontend (.gure 2) can be used for both, modelling purposes and also deployment.  3. \nASPECTC++ On the implementation level statically con.gurable software is typically dif.cult to maintain \nand reuse. Often a lot of con.gurable features affect the same module or a single feature affects large \nfractions of the system. That makes the modules hard to understand and the implementation of a feature \ncan be widely scattered across many modules. To overcome this modularization problem and to achieve clean \nseparation of concerns aspect-oriented programming (AOP) can be applied. The aim of AOP is to provide \nmeans to modularize the implementation of crosscutting concerns. AspectC++ is a language extension for \nC++ that supports AOP with C++ component code. As there is no expensive runtime system needed, our language \nand compiler are well suited for deployment in ressource restriced em\u00adbedded software projects. To understand \nthe advantage of using AspectC++ for the imple\u00admentation of con.gurable features consider the example \nillustrated in .gure 3. It shows three versions of bus transactions that might be executed by the CPU \nto communicate with peripheral ICs. Each transaction is a sequence of three single byte transfers. During \na byte transfer an exact timing is required and, thus, hardware inter\u00adrupts must be disabled. Depending \non the implemented synchro\u00adnizsation granularity the effects are different total execution times and \ndelays during interrupt processing. There is no best granularity. The best choice depends on the requirements \nin a concrete applica\u00adtion scenario. Thus, if the bus driver code should be reusable, the granularity \nmust become a con.gurable feature. Granularity ints disabled fine-grained enable ints coarse-grained \nbyte transfer disable ints none bus transaction execution time Figure 3: example: a con.gurable interrupt \nsynchronization granularity With tradidtional implementation techniques con.guration code has to be inserted \nat every point in the bus driver module, which might be relevant for synchronization in any of the scenarios. \nBy using AspectC++ the synchronization code can be completely sepa\u00adrated and there can be one aspect \nfor each granularity. For example, the following code fragment shows the .ne-grained synchroniza\u00adtion: \naspect FineGrainedIntSync { advice execution(\"void Bus::send(char)\") || execution(\"char Bus::receive()\") \n: around () { disable_int (); tjp->proceed (); enable_int (); } }; The code wraps calls to disable \nint() and enable int() around each execution of the send() and receive() functions of the bus driver \nfrom outside. By separating this code from the bus driver itself there is now a direct mapping of the \ncon.gurable feature in the Pure::Consul fea\u00adture model to an implementation module. This simpli.es the \nwhole development process and a high degree of reusability is achieved. 4. CONCLUSIONS Crucial factors \nin the devolopment of embedded software prod\u00aduct lines are adequate modells for the domain analysis and \ndesign, programming languages that support the modular implementation even of crosscutting concerns, \nand an integration of all this in a user-friendly development environment, which supports the whole process. \nThe demonstration will show that the Pure::Consul tool chain addresses these factors successfully. 5. \nREFERENCES [1] D. Beuche, H. Papajewski, and W. Schr\u00a8oder-Preikschat. Variability Management with Feature \nModels. In Proceedings of the Software Variability Management Workshop, pages 72 83, University of Groningen, \nThe Netherlands, Feb. 2003. Technical Report IWI 2003-7-01, Research Institute of Mathematics and Computing \nScience. [2] K. Kang, S. Cohen, J. Hess, W. Nowak, and S. Peterson. Feature Oriented Domain Analysis \n(FODA) Feasibility Study. Technical Report CMU/SEI-90-TR-21, Software Engineering Institute, Carnegie \nMellon University, Pittsburgh, PA, USA, Nov. 1990. [3] O. Spinczyk, A. Gal, and W. Schr\u00a8oder-Preikschat. \nAspectC++: An aspect-oriented extension to C++. In Proceedings of the 40th International Conference on \nTechnology of Object-Oriented Languages and Systems (TOOLS Paci.c 2002), pages 53 60, Sydney, Australia, \nFeb. 2002.   \n\t\t\t", "proc_id": "949344", "abstract": "", "authors": [{"name": "Danilo Beuche", "author_profile_id": "81100175392", "affiliation": "pure-systems GmbH, Magdeburg", "person_id": "PP39031017", "email_address": "", "orcid_id": ""}, {"name": "Olaf Spinczyk", "author_profile_id": "81100183689", "affiliation": "University of Erlangen-Nuremberg, Erlangen", "person_id": "PP14073914", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949373", "year": "2003", "article_id": "949373", "conference": "OOPSLA", "title": "Variant management for embedded software product lines with pure::consul and AspectC++", "url": "http://dl.acm.org/citation.cfm?id=949373"}