{"article_publication_date": "10-26-2003", "fulltext": "\n Using AspectJ for Component Integration in Middleware Adrian Colyer, Andy Clement IBM UK Limited Hursley \nPark Ron Bodkin New Aspects of Security1 216 27th Street Jim Hugunin Palo Alto Research Center 3333 Coyote \nHill Road Winchester, England San Francisco, CA 94131 Palo Alto, CA 94303 +44 1962 810000 +1 415-509-2895 \n+1 650-812-5000 {colyer,clemas}@uk.ibm.com rbodkin@newaspects.com hugunin@parc.com ABSTRACT This report \ndiscusses experiences applying AspectJ [1] to modularize crosscutting concerns in a middleware product \nline at IBM\u00ae. Aspect oriented programming techniques were used to cleanly separate platform specific \nfacilities for aspects such as error handling, performance monitoring and logging from base components, \npermitting those components to be reused in multiple environments. The initiative also guided the design \nof the AspectJ Development Tools (AJDT) for Eclipse, and influenced the technical direction of the AspectJ \nimplementation.  Categories and Subject Descriptors D 1.0 [Programming Techniques]: General. D 3.0 [Programming \nLanguages]: General. C 2.4 [Computer Communication Networks]: Distributed Systems distributed applications. \nGeneral Terms: Design, Languages Keywords: Aspect-orientation, AspectJ, middleware. 1. INTRODUCTION In \nMarch of 2002 a project team consisting of three consultants from PARC and six IBM employees undertook \na study to investigate the potential for separating crosscutting concerns from middleware components. \nThe concerns investigated were chosen both because they represented classic early use cases for AOP [2] \n(and hence were a good test to see if the claims for AOP could stand up in a real code base, as opposed \nto an educational example), and because project success would solve a real business need. This report \ndescribes the initial experiences from that project, and the subsequent development of the ideas and \ntools in the 18 months since then. The business motivation for using AspectJ was to target multiple runtime \nenvironments with a single source code base. The IBM team was releasing certain components under an open \nsource license, such that they could be used in open source environments. However, the same components \nwere also used in an IBM middleware product line where it was important to continue to take advantage \nof improved platform-specific facilities. Putting IBM proprietary features into the open source code \nbase was unacceptable both to IBM and to the open source community. 1 Ron Bodkin was working for Palo \nAlto Research Center, Inc. at the time the initial study was undertaken. Copyright is held by the author/owner(s). \nOOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. Because of the \npervasive nature of the concerns addressed, maintaining dual code bases would have been time consuming \nand error prone. The most important concerns addressed were tracing and logging, event reporting, error \nhandling, and performance monitoring. Figure 1 gives an indication of the pervasiveness of these concerns \nin the middleware product line. It presents an analysis of some of the components in the product line, \nshowing how many other components directly depend on them. Existing IBM policy documents in each of these \nareas were interpreted and embodied in aspects with no concessions made to make the task easier. The \nteam also assessed the organizational and architectural impacts of the aspect based solution, and the \nability of the AspectJ tools to scale to an industrial setting. The initial process involved two weeks \nof remote collaboration, including code reviews, preliminary design, and other preparation. This was \nfollowed by an intense week of hands on training and workshops that accomplished the following: o A review \nof the design of the pilot components o Analysis of the specific concerns under study o Interactive \ndesign of new aspects to address those concerns o Rapid prototyping of a solution, modifying production \ncode using AspectJ 1.0.3 o Integration of the AspectJ tool set into production build processes o Integration \nof prototype code into a deployable format o Analysis of findings  At the time the study was initiated, \nfour out of six of the IBM employees had no prior experience with AspectJ.  2. IMPLEMENTATION This section \ndescribes how aspects were used to address the various concerns, together with an assessment of the benefits \nand drawbacks of the AspectJ based solution. 2.1 Tracing and Logging All components in the product line \nhave extensive logging requirements. The product architecture team defines a detailed policy (about a \nfifty page document), which has been revised with each major release of the application. There are two \nmajor applications of logging: for tracing method entries and exits,and for recording system events. \nError handling also performs a type of logging, but that is handled through a separate infrastructure \n(and is further described in section 2.2). # Dependents 60 50 40 30 20 10 0 The tracing policy was implemented \nusing an abstract aspect that captured the policy, and concrete sub-aspects that defined the scope of \npolicy application. The single abstract aspect defined both when and how tracing was to be performed. \nIt also ensured that all calls to tracing were guarded with a check that determined whether tracing is \nenabled. One concrete sub-aspect was defined for each component to be traced in the product-line. This \ndivision of responsibility allows the architects to both set and implement a global policy, whilst component \nowners decide how that policy should be applied within their domain. A typical component aspect provides \na concrete definition of a scope pointcut indicating where the trace policy should be applied within \nthe component, and also a set of inter-type declarations for toTraceString() methods that override default \nlogging output where necessary. We were able to successfully implement the tracing policy using AspectJ. \nFurthermore, considering the accuracy and completeness of the implementation, the aspect-based solution \ncompared favourably to the traditional scattered implementation of inserting trace calls into every class. \nIn creating the prototype, the team found several examples where tracing was not implemented completely, \nother cases where there was inconsistency and ambiguity in interpreting the policy, and some places where \ntracing calls were not correctly guarded with checks on whether tracing was enabled. These last policy \nviolations can cause runtime performance overhead when running in production (by making calls that create \nstrings needlessly). In subsequent work with aspect implementations of policy we have found this experience \nto be entirely typical specifying and implementing the policy directly in an aspect gives a more complete \nand accurate implementation. The larger the development team (and hence the greater the degree of separation \nbetween the team specifying the policy and the developers who would have to implement it in a traditional \nmanner), the greater the benefit of the aspect approach. A further benefit of the aspect approach that \nhas been subsequently exploited is the ease with which the tracing implementation can be updated or replaced. \nWe have implemented tracing policies using the product-line internal interfaces, Log4j [3], and Jakarta \nCommons Logging [4]. Switching implementation is a simple build time decision of which implementation \naspect to include. Clearly, the larger the code-base, the greater the cost of  Components switching \nor updating a traditional scattered implementation - and therefore the greater the benefit of an aspect-based \nsolution. Our initial implementation of the tracing concern was based on AspectJ v1.03 and exposed the \nimportance of optimized performance. We were concerned that the aspect based solution may impose an estimated \nperformance overhead of up to 5%. The cause for this concern was the eager creation of thisJoinPoint \nobjects for advice that referenced thisJoinPoint in the advice body, even if dynamically the thisJoinPoint \nvariable would never be accessed (tracing was turned off by a flag for example). We subsequently ran \nsome performance tests with AspectJ 1.1, and measured the overhead in the case where tracing is disabled \n(the performance sensitive case) and advice does not use thisJoinPoint , at 1% or below. When advice \ndoes use thisJoinPoint the overhead caused by the additional object creations and also garbage collection \ncan be significant, depending on the profile of the application. The lazy creation of thisJoinPoint objects \nis a candidate item for the AspectJ 1.2 release and will resolve this issue fully. Also bear in mind \nthat a truer comparison of aspect-based and scattered implementations should take into account that not \nevery developer will faithfully follow all of the performance guidelines when implementing tracing by \nhand. Since the aspect implementation can be carefully optimized and then applied consistently everywhere, \nthe overall system performance, even if not as high as the perfect scattered implementation, can still \nbe very competitive. With an optimized AspectJ compiler implementation, the aspect-based solution may \nwell exhibit better performance than the scattered solution you would expect to find in a typical code \nbase. The default tracing facility used by the middleware product line required classes to register once \nwith the tracing facility, and to use a returned object for all future tracing. This registration is \ndone during static initialization of the class. By convention, the name used for identifying this tracing \nis the name of the class. However, AspectJ did not support any means of identifying the class in which \na static method is executing. This support would be important for statically initializing tracing for \nmany classes from the same aspect. The current version of AspectJ (v1.1) does not support inter-type \ndeclarations of static members across multiple classes. The proposed pertype language extension [5] will \nresolve this issue. These issues have been partially resolved on subsequent projects by tailoring the \ntracing policy to better match AspectJ s capabilities (by registering at the component, rather than class \nlevel). An alternative implementation could use HashMaps, but this solution has performance implications. \nSystematic logging for capturing events was prototyped with good results. In this case, an aspect was \ncreated for each component that defined pointcuts for the events to be logged. In some cases, this required \nminor refactoring of the code to expose a joinpoint of interest. In general we have found that a refactoring \nrequired to facilitate an aspect-oriented approach to some concern improves the quality of the code independently \nof the support for the concern in question. A corollary to this is that the better the object\u00adoriented \ndesign of the application, the easier it is to introduce aspect-orientation. We anticipate that the aspect-oriented \napproach to tracing and event logging will make the serviceability reviews that IBM holds prior to product \nshipment easier: the tracing policy and set of logged events are captured explicitly for review. A concern \nwith event logging though (as opposed to general tracing that tends to use robust property-based pointcuts) \nwas the potential fragility of the event pointcuts in the face of program maintenance by development \nprior to shipment, or service afterwards. If code is refactored, this has the potential to cause the \nevent pointcuts to no longer match as intended. One approach to mitigating this concern is using the \nAspectJ development tools such as AJDT that visually show where advice applies to given code. Another \ncould be to extend AspectJ to allow declaring warnings or errors if the events are no longer present \n(i.e., the pointcuts are empty). A longer-term solution is to integrate pointcut definitions into refactoring \ntools, and rely on these tools to correctly refactor all elements of a program. The infrastructure needed \nto support this approach is now being developed as part of the Eclipse 3.0 release, and the AJDT project \nplans to exploit this to allow aspect-aware refactoring [6]. A final significant benefit of applying \nAspectJ to tracing and logging came from writing an aspect that policed improper usage: it generated \ncompile-time errors when the user wrote results to System.out or System.err, or code that otherwise used \nthe logging facility improperly. This policing aspect found several policy violations in one of the components. \nWe have subsequently significantly extended our use of development-time policy enforcement aspects within \nthe product-line.  2.2 Error Handling The product line uses a sophisticated error analysis and reporting \nsubsystem following the principle of first-failure data capture (FFDC). In essence FFDC seeks to ensure \nthat all pertinent information relating to a failure is captured as close to the source of the error \nas possible. This information is then passed into a diagnostics and analysis component for logging and \nexecution of any recovery actions. When the FFDC capability was first introduced into large portions \nof the product-line a hand-built tool was used that rewrote source code. Another tool was created and \nmaintained to test for violations of policy (including checking for comments to indicate that an exception \nshould not be reported). New code needs to be manually instrumented. The tool has limited flexibility, \nand automates the process only for the initial introduction of error handling logic. However, the pain \nof handling the crosscutting error handling concern accurately made it better to introduce special purpose \ntools than try to enforce coding discipline without tools. By contrast, it was easy and effective to \nimplement the error handling policy in AspectJ. An abstract aspect was again developed to codify the \nerror handling policy. This captured the points where errors were detected (in exception handlers and \nin method returns), and passed the exception details and context information into the FFDC analysis engine. \nIn addition to the abstract aspect, the prototype included one concrete sub-aspect for each component \nfollowing the same principle as that outlined for tracing and logging. Here the component aspects also \nneeded to define any exceptions that should not be dealt with by error handling. There was initially \nconcern about pointcut fragility in determining where exceptions were being handled that shouldn t be \npassed to the error analysis and reporting subsystem. However, close analysis showed that there was always \na principle behind which exceptions and in which context exceptions weren t analyzed and reported. So \nthe pointcuts that excluded handling certain errors dealt mostly with classes of exception and domain \nclasses, and did not need to enumerate lists of methods or combinations of methods and exceptions. An \nexample of a common case that needed to be excluded from the exception handling logic was all calls to \nClass.forName(xxx) . This method throws a ClassNotFoundException to indicate a missing class. Every time \nthis method was used in the code base the exception was treated as a normal return value and handled \nat the call site. The reusable aspect was able to capture this pattern in a general way and remove the \nneed to hand-label each call-site which the current hand-built tool requires. The AspectJ solution was \nnot only consistent in applying policy and making it explicit, but it also made it easier to change the \npolicy in the future. Subsequent work has extended the set of FFDC capabilities handled by the aspect \nimplementation. We have used aspects to implement and register component diagnostic modules that can \nprovide component state information to the FFDC analysis engine on request. We have also prototyped an \naspect approach to capturing importanttransient data not available on the call-stack and making that \navailable to the FFDC engine in the case of failure too. Figure 2 illustrates the impact of the FFDC \npolicy as implemented in AspectJ for one of the components in the product-line. Each bar in the view \nrepresents a source file in the component. Every red line represents a place where the types defined \nin the source file are advised by the FFDC aspect. This visualization capability is part of the AspectJ \nDevelopment Tools (AJDT) for Eclipse developed subsequently to the original prototyping work. We have \nsince found it to be very effective in persuading developers of the power of the aspect-based solution. \n 2.3 Performance Monitoring This product-line is extensively instrumented to capture performance information \n(monitoring and statistics data). Components provide a class with stylized interfaces to access performance \nstatistics for the component. We initially analyzed the existing implementation of performance monitoring \ndata collection in a significant component of the product line. We found that data gathering was scattered \nacross ten classes in the component, and by considering the data collection as a concern in its own right \nwere able to uncover subtle inconsistencies in where information was collected.  Figure 2. Visualization \nof the Impact of the FFDC Aspect We then implemented the performance instrumentation concern for the \ncomponent in a single aspect that applied a consistent policy for capturing the performance statistics. \nThe team was especially pleased with the aspect implementation of this concern, since each statistic \nto be gathered mapped neatly into a single pointcut definition, making the code look just like the design \ndocument! Moreover, the original code had to manage state in multiple places just to count correctly. \nIn contrast, the AspectJ version was able to centralize this logic and disentangle it from the core component \nlogic. We were easily able to generalize the approach for a second component with comparable convenience \nand further reduced effort. Figure 3 shows the impact of the performance monitoring aspect for this component. \nThe view has been limited to show only affected classes which are a small subset of the total for the \ncomponent. Overall, statistics collection for performance monitoring was significantly improved by using \nAspectJ.  2.4 Impact on Program Comprehension A common question that comes up when discussing aspect\u00adoriented \nprograms is that of program comprehension. Isn t it harder to understand what s going on in the system \nwhen multiple aspects are in place? Our experience was to the contrary; the aspect solution improved \noverall program understanding by making the cross-cutting policies explicit, and by removing tangling \n(noise) from other routines so that their intended function could be more readily seen. The following \nexample illustrates this effect on a selected source extract. 01 try { 02 if (!removed) 03 entityBean.ejbPassivate( \n); 04 setState( POOLED ); 05 } catch ( RemoteException ex ) { 06 FFDCFilter.processException( 07 \nex, EntityBeanO.passivate() , 08 237 ,this); 09 destroy( ); 10 throw ex; 11 } finally { 12 if ( !removed \n&#38;&#38; pmiBean != null ) 13 pmiBean.beanPassivated( ); 14 removed = false; 15 beanPool.put( this); \n 16 if ( EJSDebug.EJSDEBUG) 17 Tr.exit( tc, passivate ); 18 } Lines 06-08, 12-13, and 16-18 are all \narising from tangled concerns. The sample below shows the same extract, but this time with the crosscutting \nconcerns refactored into aspects. 01 try { 02 if (!removed) 03 entityBean.ejbPassivate( ); 04 setState( \nPOOLED ); 05 } catch ( RemoteException ex ){ 06 destroy( ); 07 throw ex; 08 } finally { 09 removed = \nfalse; 10 beanPool.put( this); 11 }  2.5 Additional Concerns During the workshop the team also did preliminary \nprototyping and achieved good results in separating the definition of business events from source code. \nThis was fairly analogous to defining events for logging purposes (as described in section 2.1). However, \nthe pointcuts used were also able to support events in customer (3rd party)-written code by supporting \na naming pattern (or customer defined pointcuts). Subsequent work has used aspects to instrument components \nfor management via JMX . The aspects permit the addition of management operations to an existing class, \nand adaptation of fields and methods for management. An investigation into the use of aspects for profiling \nhas reported on in [7].In addition to these very homogenous concerns, the IBM team has also investigated \nthe use of AOSD to refactor large scale heterogeneous concerns in the product line, and this work will \nbe reported on separately. AspectJ was helpful as a debugging tool throughout the prototyping effort. \nIn addition, one attendee of the training tutorial who was not part of the prototyping effort immediately \napplied AspectJ to debugging a distributed system. The aspect reduced the time required to solve the \nproblem because it did not require invasive modification of code to identify what was wrong.  3. TOOLS \nINTEGRATION AND ASSESSMENT This section discusses how adding AspectJ to the existing system affected \nintegration with the project s development tools and process, and how the AspectJ tools themselves stood \nup to the test. The project team already had a very heterogeneous set of tools (including almost as many \nfavored editing environments as there were people prototyping). Most developers on the team preferred \nto use command-line compilation. The combination of Eclipse integration, emacs integration, and the stand-alone \nbrowser tool supported everyone s preferred development approach. (Subsequent to the initial workshop, \nthere has been a significant migration to Eclipse-based tools). The team initially worked with an alpha \nversion of the AJDT toolkit for Eclipse. This was helpful for understanding the effect of crosscutting \ndeclarations, but was hard to use because it was not yet a mature tool. The current release of AJDT is \na vast improvement on that early tool, and the IBM team now uses it on a daily basis for their work. \nThe AspectJ 1.03 compiler worked quite well on the code base: it was easy to compile existing code, add \naspects to it, and to test it. The product-line uses a sophisticated set of ant scripts, including a \ncustom ant task for compilation, and maintains separate files that define the classes in each component. \nHowever, in about one person day of effort the team was able to integrate AspectJ compilation into the \nprocess completely. The biggest drawback in the resulting build process resulted from how it handled \nreusable aspects in multiple components. AspectJ 1.0 did not provide a means for packaging a reusable \nlibrary of aspects, so reusable aspects needed to be included as source in the definition of each component \nto which they applied. AspectJ 1.1 addresses this issue by allowing aspect libraries to be built and \nby supporting binary weaving. A secondary issue was the compilation time, both in batch builds and within \nthe IDE. Part of this was attributed to the batch compiler implementation, and part to the lack of incremental \ncompilation for AspectJ, which made compilation during development feel slow, though it still remained \ntolerable. Incremental compilation was addressed in AspectJ 1.1 and is now supported by AJDT. AspectJ \n1.1 also switched the compiler implementation to be based on the Eclipse JDT compiler. Our latest measurements \nwith the AspectJ 1.1 release indicate that compilation is now quicker than with the standard javac compiler \n(a benchmark compile of nearly 3,000 classes showed that ajc gave a 10.5% reduction in compile time over \njavac). We have also found the AspectJ 1.1 compiler implementation to be very robust, having test compiled \nalmost 20,000 source files from the middleware product line and found only two bugs (both now fixed). \nThe ant support in AspectJ has also improved, and we have trivially integrated the AspectJ 1.1 compiler \ninto the build process of other products in the family. During the week of prototyping, the team had \na good opportunity to assess the quality of the AspectJ 1.0.3 compiler s error messages. The consensus \nwas that the error messages were good for compiling pure Java code, but needed improvement when AspectJ-specific \nproblems occurred. In practice, even the most confusing error messages weren t a problem on this project \nbecause one of the AspectJ compiler writers was present to translate any odd messages. However, it was \nclear that improving these messages would be important for teams without this sort of on-site consulting. \nThe clearest lesson learned from error handling was that having the compiler signal as many errors as \npossible was extremely helpful. All of the developers on the team used the 1.0 compiler s Xlint options \nto get the most possible warnings and the only complaint with this was that it didn t indicate more problems. \nAs a result of this experience, AspectJ 1.1 provided much more extensive support for catching simple \nspelling and type errors. The project did not test ajdoc integration for generating Javadoc output, nor \ndid it test the debugging support. It also did not investigate any issues in working with design tools \nthat convert between Java code and UML diagrams, nor testing tools that parse Java code. There should \nnot be integration issues with these if the project uses .aj file extensions for AspectJ source, rather \nthan .java. However, these tools may introduce secondary problems (e.g., refactorings that break pointcuts \nor generated tests that don t take account of aspect behavior). Whilst the AspectJ compiler (ajc) produces \n100% legal Java bytecodes, some tools that work at the bytecode level (for example, disassemblers) can \nget confused by the bytecodes that ajc emits. In general this is because the tools rely on recognizing \nbytecode patterns emitted by javac. 4. EFFECTIVE ADOPTION The results from the prototyping were quite \npromising technically, and the issues encountered were deemed to be addressable. Because of the scale \nand importance of the system under study, the dominant concerns to be considered in an adoption roadmap \nwere risk management and change management (i.e., how to train people and how to change processes to \nuse the technology). The principles defined in the follow up plan were phased adoption, clear vision \nand sponsorship, and building on continued successes from using the technology. Indeed, these same factors \nworked together to produce good results in short iterations during the investigation process. Our experience \nhas shown that face to face meetings accompanied by demonstrations of the technology in action are the \nmost effective means of exciting others about the technology s potential. Indeed, whilst white papers, \ntechnical reports, and presentations can give an intellectual understanding of the benefits of aspect-oriented \nprogramming, demonstrations have proven to be the key that unlocks doors like nothing else. There s something \nabout the claims of AO that seem just too good to be true until you ve seen it for yourself. The phases \nof adoption identified were the use of: 1. development-time aspects to police architectural, design, \nand coding guidelines 2. auxiliary aspects for policies such as those discussed in this report 3. core \naspects used to implement functional parts of the design 4. the creation of aspect libraries Progress \nhas been made in all of these areas. The phased adoption plan also envisioned increasing the scale and \nscope of usage to achieve increasing benefits over multiple releases. This, in turn, allowed for isolating \nhow the technology would impact different roles and skill sets. In particular, an important goal would \nbe to allow a small number of specialists to define and maintain project policies in AspectJ initially. \nThis would limit the training required for most developers to a basic level of awareness, rather than \nlearning how to design and develop with AOP. Some groups we have subsequently worked with have rejected \nthis idea, preferring  not to create a divide amongst the development team. Others are proceeding more \nas initially envisaged. An additional consideration was the need to address integration with a broader \nset of tools, including how to interoperate with ones that parse Java code such as UML modeling and testing \ntools. To date this has not yet proved to be a major stumbling block. 5. CONCLUSIONS The project had \ntremendous success in converting broad system\u00adwide policies from large and potentially ambiguous paper \ndocuments into AspectJ source code that unambiguously captured the same policies. This made the policies \neasier to understand, implement, and modify. It provided a convincing demonstration that AspectJ could \nbe used to modularize many important crosscutting problems. While the findings were mostly positive technically, \nthe project also identified some specific areas, primarily tools maturity issues that needed improvement. \nSubsequently, many of these became the focus of improvement in developing AspectJ 1.1 and AJDT. The project \nalso achieved significant results culturally; a large organization learned about AspectJ and AOSD and \nmany individuals started applying it to their own projects. Naturally, adopting a new technology like \nAOSD is not to be taken lightly on a massive engineering project, and there is a lot of additional effort \nrequired to mitigate risks and manage the change. Overall, the results of this effort were deemed to \nbe very favorable and formed an important input to IBM s initial assessment of AOSD. The IBM team has \ncontinued to work with AspectJ and to grow their involvement in the AspectJ project. Significant additional \nwork has been done to further the team s understanding of how AspectJ can be applied within the product-line, \nand progress has been made in all the envisioned adoption phases. 6. ACKNOWLEDGEMENTS Thanks to Tracy \nGardner, Ian Robinson, Jeremy Hughes, Graham Wallis, and all the team at IBM Hursley for making this \nproject happen. Thanks also to Gregor Kiczales who was instrumental in delivering the consulting, and \nto Erik Hilsdale, Mik Kersten and Wes Isberg for supporting the project efforts. George Harley and Matthew \nWebster helped carry the flag for subsequent extensions of the work inside IBM. IBM is a trademark of \nInternational Business Machines Corporation in the United States, other countries or both. Java and all \nJava-based trademarks are trademarks of Sun Microsystems, Inc. in the United States, other countries, \nor both. Other company, product or service names may be trademarks or service marks of others. 7. REFERENCES \n[1] Kiczales, G., Hilsdale, E., Hugunin, J., Kersten, M., Palm, J., Griswold, W. An Overview of AspectJ. \nIn Proc. of ECOOP 01, LNCS 2072, pp. 327-353, Springer, 2001 [2] 2. Kiczales, G., Lamping, J., Mendhekar, \nA., Maeda, C., Lopes, C., Loingtier, J., Irwin, J. Aspect Oriented Programming. In Proc. of ECOOP 97, \nLNCS 1241, pp. 220-243, Springer-Verlag, 1997 [3] 3. Log4j: The Apache Jakarta Project, http://jakarta.apache.org/log4j/docs/ \n[4] 4. Jakarta Commons Logging: The Apache Jakarta Project, http://jakarta.apache.org/commons/logging.html \n[5] 5. The AspectJ project team: New pertype aspect specifier, AspectJ 1.1 Readme. [6] 6. Colyer, A. \nClement, A. and Kersten, M. Aspect Oriented Programming with AJDT. In proceedings Analysis of Aspect \nOriented Software workshop, ECOOP 2003. [7] 7. Davies, J. et al. Aspect Oriented Profiler. Practitioner \nReport, AOSD 200  \n\t\t\t", "proc_id": "949344", "abstract": "This report discusses experiences applying AspectJ [1] to modularize crosscutting concerns in a middleware product line at IBM&#174;. Aspect oriented programming techniques were used to cleanly separate platform specific facilities for aspects such as error handling, performance monitoring and logging from base components, permitting those components to be reused in multiple environments. The initiative also guided the design of the AspectJ Development Tools (AJDT) for Eclipse, and influenced the technical direction of the AspectJ implementation.", "authors": [{"name": "Adrian Colyer", "author_profile_id": "81100049748", "affiliation": "IBM UK Limited, Hursley Park, Winchester, England", "person_id": "PP14028705", "email_address": "", "orcid_id": ""}, {"name": "Andy Clement", "author_profile_id": "81539988356", "affiliation": "IBM UK Limited, Hursley Park, Winchester, England", "person_id": "P643422", "email_address": "", "orcid_id": ""}, {"name": "Ron Bodkin", "author_profile_id": "81100609041", "affiliation": "New Aspects of Security, San Francisco, CA", "person_id": "P643483", "email_address": "", "orcid_id": ""}, {"name": "Jim Hugunin", "author_profile_id": "81100442943", "affiliation": "Palo Alto Research Center, Palo Alto, CA", "person_id": "PP39042999", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949440", "year": "2003", "article_id": "949440", "conference": "OOPSLA", "title": "Using AspectJ for component integration in middleware", "url": "http://dl.acm.org/citation.cfm?id=949440"}