{"article_publication_date": "10-26-2003", "fulltext": "\n * Yoshiki Ohshima Twin Sun, Inc. 360 N. Sepulveda Blvd. El Segundo, CA 90245 USA Yoshiki.Ohshima@acm.org \nABSTRACT The Parks PDA is a lightweight, handheld device for theme park guests that functions as a combination \nguidebook, map, and digital camera. Together with a small team of artists and designers, we created a \nprototype Parks PDA and con\u00adtent for a three hour guest experience, including a camera interface, a hyper-linked \nguide book, three games, an ani\u00admal spotters guide, a cross-referenced map, animated movies with lip-synched \nsound, a ride reservation system, and more. Over 800 visitors to Disney s Animal Kingdom.theme park tested \nthe Parks PDA over a two week period. Developing the software for this test posed a number of challenges. \nThe processor and memory of the target de\u00advice were slow, the screen was small, and we had only three \nmonths of development time. We attacked these problems using Squeak, a highly-portable, open source Smalltalk \nimplementation. We ported Squeak to the target device and used it to provide nearly bit-identical behavior \nacross four di.erent platforms. This supported a cross-platform development style that streamlined the \npro\u00adduction of both software and content. We created a tiny user interface and application framework \nfor pen-based de\u00advices and implemented a simple card-stack media editor and player using it. We isolated \nand addressed several challeng\u00ading performance issues. The project was completed on time and guest response \nwas favorable. Looking back, we can identify seven aspects of Squeak that contributed to the success \nof the project. In fact, we feel that Squeak was the ideal tool for this job. * Yoshiki was a student \nat Tokyo Institute of Technology and interning at WDI R&#38;D while doing this work. John was at Walt \nDisney Imagineering R&#38;D while doing this work. Andy was at Walt Disney Imagineering R&#38;D while \ndoing this work. Copyright is held by the author/owner. OOPSLA 03, October 26 30, 2003, Anaheim, California, \nUSA. ACM 1-58113-751-6/03/0010.  Figure 1: The PDA Showing the Home Page . There are .ve hyper-link \nbuttons on the screen. To the left of the screen there are seven silk-screened buttons. Attached to the \nright is the digital camera. Categories and Subject Descriptors D.2.6 [Software Engineering]: Programming \nEnvironments design prototyping, debugging on embedded systems; D.1.5 [Programming Techniques]: Object-oriented \nProgram\u00adming Squeak; H.3.2 [Information Storage and Retrieval]: Information Storage General Terms Design, \nExperimentation, Languages, Performance Keywords Handheld device, PDA, end-user software, multimedia \ndata management, rapid software development, development en\u00advironment 1. INTRODUCTION By the late 1990 \ns, computers were becoming small and light enough that you could carry one everywhere, even on vacation. \nAt Walt Disney Imagineering R&#38;D, the big ques\u00adtion was, could you create a user experience on a handheld \ndevice that was both fun and useful enough to justify carry\u00ading that device in a theme park? For us, \na color screen was essential. Unfortunately, theme park guests spend much of their time outdoors where \nan ordinary backlit color liquid crystal display (LCD) becomes illegible. In late 1999, Sharp announced \na very compact personal digital assistant (PDA), the Zaurus MI-C1, that had a re.ective color LCD display \nthat worked well even in direct sunlight. The MI-C1 was one of the .rst PDA s to have such a display. \nThe MI-C1 also supported a camera, another essential feature for us. With a new medium, such as a PDA \nin a theme park, pro\u00adviding a new content is challenging since there are no prior examples to study. \nIt is even possible that the medium itself has a fatal .aw. We decided to test this new medium by cre\u00adating \na working prototype with enough content to support three hours of use in Disney s Animal Kingdom.theme \npark and to test it on 800 randomly chosen guests. The business mission of this test was to rapidly evaluate \nthe potential appeal of a PDA user experience for theme park guests that might ultimately take advantage \nof wireless connectivity and location-sensing technologies without having to wait for the maturation \nof those technologies. The production team for this test consisted of nine cre\u00adative sta. artists, designers, \nand show writers plus two programmers. We had three months to create both the con\u00adtent and the software. \nWe also needed to integrate hardware components such as a digital camera and a location sensing system. \nUsing most languages and development processes, this would seem ambitious, perhaps even impossible. For\u00adtunately, \nwe had a secret weapon: Squeak[5]. Squeak is a highly-portable, open-source Smalltalk implementation \nwith a modest memory footprint and an easily extensible virtual machine. Yoshiki Ohshima had already \nported Squeak to an earlier Sharp Zaurus model with good results. This paper explains how Squeak supported \nthe object\u00adoriented programming techniques and cross-platform devel\u00adopment processes that made the project \nan overwhelming success. Towards the end of the paper, we identify seven properties of Squeak that were \nkey to that success.  2. A PDA FOR THEME PARKS The Parks PDA is a lightweight, handheld device for theme \npark guests that functions as a combination guidebook, map, and digital camera. Our prototype Parks PDA \ncontained content for a three hour guest experience covering about a third of Disney s Animal Kingdom. \ntheme park. In addi\u00adtion to the hyper-linked guide book and camera, the Parks PDA contained three games, \nan animal spotters guide, a cross-referenced map, a number of animated movies with lip-synched sound, \na simulated ride and restaurant reser\u00advation system, an online shopping application, and a short feedback \nsurvey. 2.1 The Guest Experience This section describes guest s experience of using the Parks PDA. All \nthe guests in a group (e.g., a family) typically shared a single Parks PDA device, either by standing \nclose together or by passing the unit around. Hosted Narrative Upon entering a new land (part of the \npark) guests were automatically prompted to play a narrative hosted by an animated character who explains \nthe story of that land. Since the earbud allowed only one guest at a time to hear the audio, a repeat \nbutton was provided to allow every member of the party to enjoy this experience. Digital Map and Index \nEither the digital map or an on-screen index could be used by guests to locate and learn about attractions, \nshops, restau\u00adrants, and restrooms. All information was cross-indexed, al\u00adlowing the guest to quickly \njump between the map and the information pages. Sign Posts Guests came upon sign posts distributed throughout \nthe park marked in a simple code consisting of four basic shapes. By entering this code using the silk-screened \nsymbol buttons on the Parks PDA, the guest could get detailed information in the form of audio, text \nand images about the plants or animals in that location. Symbol codes were used to create a detailed \nbotanical tour of one section of the park. Ride Reservations Guests could use their Parks PDA to make \na reservation for one of the most popular rides. To make sure that they had a chance to take advantage \nof this feature, they were prompted with an invitation as they passed selected locations for the .rst \ntime. If they made a reservation, then shortly before the reservation time, a reminder was presented, \ngiving them a comfortable amount of time to get to the ride. When the guest and their party arrived at \nthe ride, they showed their electronic ticket to the attendant and were allowed to bypass the queue line. \nGames While guests were waiting in the queue lines of other attrac\u00adtions they could pass the time enjoyably \nby playing inter\u00adactive games themed to reinforce the attraction they were about to see. Digital Picture \nTaking Guests could use the PDA s digital camera feature to take pictures during their test session. \nThe camera interface in\u00adcluded an easy to use erase function. Guests could take an unlimited number of \nphotos as long as they kept a maximum of 40. Online Picture Viewing Back home, guests could visit a website \nand enter their ID and password to access a page showing a map in the same graphical style as the one \nthat appeared on the Parks PDA, but with thumbnails of their pictures placed around the map in the approximate \nlocations where the photos were taken. The guest could either view full-sized versions of their photos \non the screen or print them out. The map showing the thumbnails could also be printed as a record of \ntheir visit and an implicit invitation to return to the park. 2.2 User Testing The Parks PDA was tested \non over 800 guests over a two\u00adweek period. PDA s were distributed to guests who agreed to participate. \nAfter using the Parks PDA for two to four hours, the guest returned it and gave us their feedback about \nthe experience. Selection Guests were chosen at random by Walt Disney World Mar\u00adket Research sta., shown \nan example Parks PDA, and in\u00advited to participate in the test. Most people visit theme parks with family \nor friends; we chose one adult member of each party to be our primary contact for the test. Registration \nEach guest was directed to a registration area where they were assigned a unique ID and password and \ngiven a num\u00adbered Parks PDA. The guest name, ID, password and PDA number were recorded in a database. \nThe guest name and ID were also downloaded into the Parks PDA via IrDA. Hav\u00ading the guest name and ID \nin the Parks PDA allowed the experience to be personalized and simpli.ed tracking of their photos. The \nID and password were written on a printed map given to the guest. This information allowed them to later \naccess their photos online. Instruction Groups of eight to twelve guests at a time were then given a \n.ve-minute brie.ng on how to use the Parks PDA. Instruc\u00adtions included a scripted overview of the content \nfeatures and how to use the PDA s graphical .nger push interface. Guests were given suggestions for picture \ntaking and shown how to wear the PDA and use the attached earbud for audio. The guests were then invited \nto explore the park with their PDA s and asked to return to the drop-o. location three to four hours \nlater. Interview At the end of the test session, guests dropped o. their Parks PDA at a restaurant in \nthe Africa land where a room was reserved for interviews. They were interviewed by Walt Dis\u00adney World \nMarket research specialists for approximately 20 minutes about their experience. They were also told \nhow to go online to view the pictures they took with the Parks PDA. Photo Upload The Parks PDA devices \nreturned by the guests were taken to a photo uploading station where the guest s photos and session log \nwere uploaded to a laptop computer via the IrDA port. The photo .les were later transferred to the website. \nPDA Recharging After uploading the guest photos, the Parks PDA was check\u00aded for damage and placed in \na charging rack. Early the next morning, the screen was cleaned to remove any .ngerprints, the earbud \ncushion was replaced, and the Parks PDA was checked for proper functioning.  3. THE HARDWARE PLATFORM \nThe hardware for the Parks PDA was the Sharp Corpora\u00adtion s Zaurus MI-C1 PDA, a device available only \nin Japan, where Sharp s Zaurus PDA s enjoyed a large market share. It s speci.cations are shown in Table \n1. The original retail model had only a single expansion slot. Sharp, our partner in this experiment, \ndesigned and built 100 custom MI-C1 units with a second expansion slot, allowing us to use both the digital \ncamera module and a 128MB Compact Flash memory card at the same time. Sharp also doubled the RAM of these \ncustom units, from 8MB to 16MB. The SH-3 CPU is a RISC processor with 16-bit .xed\u00adwidth instruction set \nwith low power consumption but only modest performance; our tests show that its arithmetic in\u00adtensive \nperformance is an order of magnitude slower than the 206MHz StrongARM. Access to the underlying hardware \nwas made through ZaurusOS, a Sharp proprietary operat\u00ading system based on a realtime microkernel called \nXTAL[2]. Along the left side of the screen, we created a strip of touch-sensible, silk-screened navigation \nbuttons: Home, Back, Camera and four symbols. The Home and Back but\u00adton function like their equivalents \nin a typical web browser. We dedicated a button to the camera because we wanted guests to be able to \naccess the Parks PDA camera as quickly as an ordinary camera. Table 1: The speci.cation of Sharp MI-C1 \ndimension: 136mm \u00d7 80mm \u00d7 22mm weight: 190g (incl. second CF slot) CPU: Hitachi SH-3 60MHz display screen: \n320 \u00d7 240, 16 bit color re.ective LCD Operating System: Sharp proprietary OS called ZaurusOS Memory capacity: \n16MB DRAM Sound Output Quality: 8-bit sample, mono, up to 22.5kHz sampling rate Com Ports: one serial \nport and one IrDA port Expansion Slots: 2 Compact Flash type I slots. Miscellaneous features: Silk screened \ntouch-sensitive area. Key Performance Numbers Read throughput CF card: 440kb/s Read throughput DRAM \n10.3MB/s Write throughput DRAM 5.7MB/s Typical Battery Life: 10 hours; 1.5 hours with camera on  We \nplugged a proprietary IR location sensor (about 40 \u00d7 15 \u00d7 10mm) into the serial port. This sensor received \nlo\u00adcation codes at various locations in the park. These loca\u00adtion codes were used to help guests navigate \nand to trigger location-speci.c events, such as playing an animated wel\u00adcome message when the guest .rst \nenters a new area. We used the MI-C1 s IrDA port to download guest regis\u00adtration information and to upload \ntheir photos and log .les. We built an impact-resistant plastic case to protect the unit, keep its attachments \nin place, and provide a themed look for a device that might otherwise look like a business tool. We also \nadded a neckstrap with an integrated ear\u00adbud style headphone to allow the user to hear audio output without \ndisturbing other guests. We assumed that the stylus would be easily lost, so we discarded it. The UI \nwas driven by pressing one s .nger directly against the touch screen. 4. THE SOFTWARE PLATFORM: SQUEAK \nSqueak is a highly portable, open-source implementation of Smalltalk-80 that provides nearly bit-identical \noperation across platforms. The Squeak virtual machine (VM) im\u00adplementation consists of three parts. \nThe bytecode inter\u00adpreter, the object memory system and a collection of primi\u00adtives. The bytecode interpreter \nand the object memory are written in Squeak itself and translated into ANSI C code. They are exactly \nthe same on all platforms. Most of the primitives are also portable, but a small handful of primi\u00adtives \nare OS-speci.c, including primitives for display output, touch-screen input, clocks, .le system access, \nsound, and so on. These primitives and a small amount of startup code must be ported to make Squeak run \non a new platform [4]. Squeak uses a virtual image model. A snapshot of the state of Squeak s object \nmemory can be saved in an im\u00adage .le that can later be resumed from the point at which the snapshot was \ntaken. Since Squeak runs on a platform\u00adindependent virtual machine, the image .le format is free from \nactual hardware dependencies. A Squeak image .le can be resumed and run on any computer for which you \nhave a Squeak virtual machine, even if the OS, processor, or even the byte-ordering is di.erent from \nthat of the platform that wrote the image .le. 4.1 Squeak VM extensions In addition to porting Squeak \nto the Zaurus, we also added a number of primitives to access Zaurus-speci.c hardware Figure 2: Runtime \nMemory Usage of the 16MB DRAM. ZaurusOS includes the work area of JPEG library and the camera, and the \nnative stack. The Free area satis.es the transient memory needs of the applications. features including: \n camera control and image capture  audio output  power saving and sleep  reading the current battery \nlevel  checking the amount of free space on the Compact Flash card  con.guring the Zaurus silk-screened \nbutton strip.  We also added primitives improve the performance of key graphic operations including: \n scaling and alpha-blending 16-bit images  JPEG image compression and decompression  The ability to \nport and easily extend the virtual machine was essential, and Squeak s open-source, portable design made \nit easy. Only about 6700 lines of C and 2000 lines of Smalltalk-80 glue code were needed to accomplish \nthe port to the Zaurus and to implement the custom primitives.  4.2 Memory Footprint Memory is a limited \nresource on handheld devices. Squeak helped us use that resource e.ciently. We stripped down a version \n2.4c Squeak image by remov\u00ading classes and methods that we didn t need. This base image, containing only \n204 classes and 4872 methods, was 835k bytes1 . Our application code added 88 classes and 1897 methods. \nThis code and it s associated objects added 134k bytes of CompiledMethods (these are mostly bytecodes) \nand 267k bytes of additional objects to the base image. 1The version 3.5 release image of Squeak distribution \nis more than 10MB in size and contains more than 1800 classes and over 41000 CompiledMethods. The virtual \nmachine also takes up space. The core of the Squeak VM, the interpreter and the object memory com\u00adpile \ninto about 150k bytes of SH-3 code. However, native libraries such as the JPEG decoder/encoder add hundreds \nof kilobytes to the executable. With all the necessary li\u00adbraries, the .nal virtual machine executable \n.le size was close to 500k bytes. Figure 2 shows the breakdown of the memory usage at runtime. The total \nDRAM capacity on the device was 16MB. We allocated 12MB for Squeak heap, leaving 4MB for the OS and the \nSqueak virtual machine. As shown in the .gure, the relative overhead for the Squeak virtual machine and \nthe base image is quite small. This allowed us to use mem\u00adory space for working with large graphics .les \nand, as we ll see, for a large image cache that was important for overall performance. 5. SOFTWARE ARCHITECTURE \n5.1 Applications The core Parks PDA application is an interactive informa\u00adtion retrieval program based \non hyper-linked pages, similar in concept to the World Wide Web. A Page contains zero or more links to \nother pages, and the user navigates through the content by following these links. We call this core appli\u00adcation \nStacker, since it models a stack of cards (pages). Many of the pages and links on the World Wide Web \nare textual, but we wanted the Parks PDA experience to be primarily graphical. Thus, every page of our \ncontent is a full-screen graphic image and every hyper-link is a graphi\u00adcal button. Using pre-rendered, \nfull-screen images gave the artists complete control over the visual experience; there were no tool bars, \nwindow, or menus that might remind guests of daily business tools or frustrating computer expe\u00adriences. \nHowever, high-quality graphics require memory. Each full-screen image is a 320 \u00d7 240 pixel, 16-bit color \nbitmap. Some pages had smaller images or animated sprites in front of the full-screen image. While the \ncontent for a Parks PDA might ultimately be delivered over a wireless network, for this test we kept \nthe content on a 128 megabyte Compact Flash storage card. This allowed us to create a user test with \nthe maximum quality graphics; our only limitation was how much content would .t onto the Compact Flash \ncard. In addition to Stacker, the Parks PDA software includes thirteen other applications as shown in \nTable 2. Navigating among these applications is completely seamless to the user. To help us analyze usage \npatterns, we logged guest actions as they used the Parks PDA. Each log entry includes a time stamp, the \naction taken (e.g., page transition, photo taken, or application switch), and additional action data \nsuch as the destination page or application. 5.2 UI Considerations for Handhelds Several considerations \narose when designing the user in\u00adterface for the Parks PDA. First, a handheld device has di.erent display \nand input a.ordances than a desktop, lap\u00adtop, or even a tablet computer. For example, it s screen is \nfar too small for overlapping windows to be e.ective. Fur\u00adthermore, theme park guests should be enjoying \nthe park around them; we didn t want to burden them with complex UI interactions such as scrolling, window \nmanipulation, or menu selection. Finally, the MI-C1, like most PDA s, uses a Table 2: The applications \nin Parks PDA Name Description Stacker (main app) player/editor of hyper-linked pages Map zooming, hyper-linked \npark map Talking Mask lip synched talking virtual host Restraunt Reservation make priority seating reservation \nOnline shopping buy park exclusive goods Fastpass get FASTPASS.ride reservation ticket remotely Bugboms \nan artillery game Camera digital camera interface and photo album Kilimanjaro Quiz trivia game PT Flee \ns Word Circus a hangman like game Symbol Code Entry enter four digit code to get info Survey online survey \nGuest Registration register the device to the guest Uploader upload photos, log .les, and survey data \nvia IrDA touch screen that can only track the pen (or a .nger) while it is in contact with the screen. \nTechniques such as roll-overs and changing the cursor to indicate the active user interface elements \ncannot be used, since they depend on being able to track the pointing device while the mouse button is \nup. For these reasons, we adopted a simple button-pressing convention for all user inputs, similar to \ntouch-screen in\u00adterfaces found on information kiosks. We used drop shad\u00adows and a 3-D look as a visual \ncue that a graphical object was a pressable button. Users pressed these screen buttons with their .nger. \nSince a .ngertip is less precise than a sty\u00adlus, our screen buttons had to be large, with bu.er space \naround them to avoid accidentally pressing an adjacent but\u00adton. Even with these precautions, user testing \nrevealed that the buttons were not quite large enough for some users with exceptionally large .ngers. \nOverall, we were happy with our decision to omit the stylus, even though it meant that screens collected \n.nger prints and had to be cleaned daily. The software for the Parks PDA was built using two object\u00adoriented \nframeworks: PenSprites, a stripped-down user in\u00adterface framework, and PDAApplications, an model to switch \napplications similar in spirit to Java Applets. A third pack\u00adage manages images and other media. The \nremainder of this section describes these three software components. 5.3 PenSprites PenSprites is simple, \nlightweight user interface framework that, like Morphic[12][7], combines the roles of display, user input, \nand autonomous behavior (animation or stepping ) into a single class, Sprite. As in Morphic, it is easy \nto create new kinds of Sprites with custom appearance and/or user input behavior by making a subclass \nof Sprite and adding just a few methods. However, PenSprites is much simpler than Morphic: PenSprites \nconsists of only 18 classes and 323 methods, and it takes up only 50k of space. In contrast, a recent \nversion of Morphic has over 400 classes and 10,000 methods, and consumes several megabytes. While we \ncould have created a stripped-down version of Morphic for this project, it was quicker to write PenSprites \nfrom scratch. The resulting framework is tiny and precisely tailored to handheld, touch-screen devices. \nAt the core of PenSprites are two key classes, Sprite and Stage.A Sprite knows its own position and bounds, \ncan draw itself, handles pen and keystroke input, can perform periodic activities, and can do simple \nanimations involving position, size, and transparency. The class Sprite de.nes default behaviors for \nall these things, although in many cases that default behavior is to do nothing. A Stage holds a collection \nof Sprites, manages display updates, dispatches user inputs, and processes any ongoing Sprite animations \nand periodic activities. A Stage also handles any pen and keyboard events that aren t handled by a Sprite. \n Both Sprite and Stage are designed to be specialized by subclassing. When building a PenSprites application, \none creates a subclass of Stage to hold the application state and behavior and subclasses of Sprite for \neach new kind of graph\u00adical object used by that application. For example, the Bug-Boms game de.nes its \nown subclass of Stage and eleven subclasses of Sprite. However, BugBoms is a fairly complex game with \nseveral screens and many custom widgets; most applications are made up of Sprites from a small library \nof reusable widgets. When PenSprites application is running, it s Stage repeat\u00adedly invokes the following \nmethod: doOneCycle self processInputs. self processActions. self updateDisplay. The methods processInputs, \nprocessActions, and update-Display, as well as doOneCycle can all be overridden and spe\u00adcialized by an \napplication stage. For example, PDAMoviePlayer overrides doOneCycle to check the millisecond clock and \nad\u00advance to the next frame of the movie if necessary. 5.4 PDA Application Switcher Although using the \nParks PDA is a seamless experience, its implementation actually consists of fourteen applications, each \nof which is a kind of Stage (see Table 2). The main application is a hyper-linked card stack containing \nnaviga\u00adtional screens and the bulk of the content. Certain pages in this main stack are placeholders \nthat link to the other applications. An instance of PDAApplicationSwitcher manages this suite of applications. \nAt any given moment, there is one active application that processes user inputs, runs animations and \nother ongoing activities, and updates the display. However, PDAApplicationSwitcher has its own version \nof the Stage in\u00adteraction loop that calls the active stage s doOneCycle and also: 1. checks for ride \nreservation state changes 2. checks the battery level 3. polls the location sensor 4. returns to home \ncard after a few minutes of idle time 5. optionally, puts the device to sleep when idle  Of course, \none could also use threads to perform these background tasks, but threads can be tricky to reason about \nand debug. Furthermore, tasks are not always independent. One might want to conserve processor cycles \nby omitting battery level checks and location sensor polling during a performance sensitive animation \nsequence. It s easy to im\u00adplement such policies in PenSprites. The application switcher allows the code \nfor the Parks PDA to be factored a number of small applications that can be independently implemented \nand tested. Each application retains complete control over its own screen display, user input, and background \nactivities. Care was taken to avoid extra screen updates when switching between applications, so application \nswitches are fast and appear seamless to the user. Many of the applications are quite small, some as \nfew as one or two methods. The application switcher was implemented fairly late in the development process, \nafter many of the applications had already been written. It is notable that it required few changes to \nthe existing applications. Most applications were converted by merely inserting the class PDAApplicationStage \nabove them in the class hierarchy. We attribute the ease of making this change to the clean design of \nthe PenSprites framework, OOP in general, and Smalltalk-80 in particular.   5.5 Managing the Media \nA multimedia application uses many images and sounds, which require a lot of space. The media for a large \nappli\u00adcation like Parks PDA cannot all .t into RAM at once; it must be kept in external storage until \nneeded. One way to to do this is to store every piece of media or asset as a separate .le. However, \nfor an application with hundreds of assets, managing .le names and versions can be a tedious and error-prone \nbusiness. Furthermore, all those .les must be dealt with when moving the application among machines or \nsharing it among team members. Some .le systems have trouble handling large numbers of .les. Finally, \nwhen space is tight, the amount of space lost due to rounding .le sizes up to the device s block size \ncan be signi.cant. To avoid these potential problems, we implemented a sim\u00adple media storage system that \nstores a collection of assets in a single .le. Assets are stored sequentially in the .le as records of \nthe form: <asset ID> (3 bytes) <type ID> (2 bytes) <size> (4 bytes) <serialized asset data...> A new \nasset is added by assigning it a unique ID and ap\u00adpending a new record to the asset .le. An existing \nasset can be updated by appending a record containing a new version of that asset to the .le. When an \nasset .le is opened, its as\u00adsets are scanned sequentially while constructing a dictionary mapping asset \nID s to .le o.sets. Versions of the same asset stored later in the .le merely update that asset s dictionary \nentry. When the scan is complete, every dictionary entry points to the most recent version of its asset. \nAn asset .le can be compacted to remove all but the latest asset versions to reclaim space. Asset .les \ngreatly simpli.ed media development. It was easy to keep the assets together, it was easy to move them \nonto a Compact Flash memory card for testing on the de\u00advice, and it allowed artists to work together \nmore easily. Initially, each artist had one or more asset .les for their sec\u00adtions of the project. As \nthe project progressed, these asset .les were merged into a small number of master asset .les. Artists \nwould often take turns working on an asset .le, each making some changes before passing the .le on to \nanother artist. In fact, this process worked so smoothly that we were able to make additions and changes \nto the content while user testing was underway. Table 3: Compression Comparison on MI-C1 Format File \nSize Read (r) Decode (d) r + d (bytes) (msecs) (msecs) (msecs) RAW 153600.0 362.99 1.18 364.17 RLE 124593.2 \n277.93 82.02 360.01 JPEG 18881.8 43.81 695.49 739.30 Table 4: Compression Comparison on iPAQ Format \nFile Size Read (r) Decode (d) r + d (bytes) (msecs) (msecs) (msecs) RAW 153600.0 123.47 0.24 123.71 RLE \n124593.2 90.80 11.62 102.42 JPEG 18881.8 15.07 44.15 59.22  6. PERFORMANCE TUNING Adequate performance \nis critical for a good guest expe\u00adrience. A key goal is to minimize the latency between a button press \nand the moment a response appears on the screen. Most of the Parks PDA content consisted of one full-screen \nimage per card. Thus, in response to a button press the system typically had to fetch and display a full\u00adscreen \nimage. The time for this operation is determined by 1) reading a screen image from Flash memory, 2) decoding \nthat image if necessary, and 3) updating the display. These operations were all implemented as primitives \nwritten in C. As with many media-rich applications, performance is so completely dominated by the media-manipulation \nprimitives that the speed of the bytecode interpreter is almost irrelevant. Compared to desktop and laptop \ncomputers, mobile de\u00advices have slow processors, narrow data paths, and small or non-existent caches. \nTo our surprise, we found that access\u00ading Flash memory on the Zaurus MI-C1 was slower than reading from \na disk drive on a desktop computer. This is due to an expensive error-correcting code computation. Thus, \nthe e.ective read speed of Flash memory depends on the speed of the CPU. On the Zaurus MI-C1, data can \nbe read from a Compact Flash card at about 440k bytes/sec. The next two sections explain how we achieved \nadequate performance even on a device with modest computational power. 6.1 Data Accessing Speed A full-screen \nimage (320x240 pixels, 16-bit color) con\u00adsumes about 154k bytes in uncompressed form. Thus, at 440k bytes/sec, \nit takes roughly 1/3 second to read an un\u00adcompressed image from the Compact Flash card. If the image \nis stored in compressed form, the reading time will decrease but that savings may be exceeded by the \nimage de\u00adcompression time. One must make empirical measurements on representative content to determine \nthe best compression strategy for a given device. We considered three compression options: no compression \n(RAW), Squeak run length encoding (RLE), and JPEG en\u00adcoding. Run length encoding works best for content \nwith ar\u00adeas of solid color, whereas JPEG works best on continuous\u00adtone images such as photographs and \nnatural textures. Both compression schemes are implemented using fast VM prim\u00aditives. Table 3 shows the \ntradeo.s among these options for the Zaurus MI-C1. The numbers are the average of the real content of \nthe Parks PDA, which contains 415 full screen images created by professional designers. As the table \nshows, using RLE compression doesn t save signi.cant time, but it does yield a modest 19% space sav\u00adings. \nJPEG compression signi.cantly reduced the contents size and hence the reading time, but unfortunately \ndecod\u00ading JPEG images was unacceptably slow on the MI-C1. We thus choose RLE compression for the Parks \nPDA. Table 4 shows how the tradeo. between read time and decompression time depends on the actual device. \nOn the Compaq iPAQ 3600 implementation of the Parks PDA, us\u00ading JPEG compression is the best choice. \nThe high speed of JPEG decoding on the iPAQ is due in part to our use of a fast JPEG library from Intel: \nthe Intel Integrated Perfor\u00admance Primitives (IPP) [6]. The .nal step is to display the decompressed \nimage on the screen. Compared to reading and decompressing the image, this operation is relatively quick: \n52.4 milliseconds on the MI-C1 and 10.5 milliseconds on the iPAQ.  6.2 Caching and Prefetching Assets \nUnfortunately, image compression did not solve our per\u00adformance problem. We decided to use 4 megabytes \nof DRAM as a cache for images. Images in the cache would not need to be read or decompressed, resulting \nin a much faster response time. The cache was simple: decompressed images were cached using an LRU replacement \nalgorithm. We implemented this cache as a subclass of AssetFile so no client code had to be changed. \nA cache hit returned the cached asset immediately; a miss called the normal asset .le read operation, \nthen added the newly-read asset to the cache before returning it. This worked well since frequently used \npages such as the home page and the map page were often cached. Response to the back button was also \nfast since recently visited pages would also be in the cache. However, we realized we could do even better. \nWe decided to anticipate upcoming asset requests and prefetch these as\u00adsets into the cache using time \nthat the processor would oth\u00aderwise be idle. Prefetch predictions were made by examining all links on \nthe current page. Since users often spend several seconds viewing a page, there is time to prefetch images \nfor several of these possible next pages. Once the user clicks on a link, the prefetch queue is cleared \nand a new prefetch cycle is started. We arbitrarily chose to limit prefetching to the .rst three outgoing \nlinks. One might imagine that prefetching would always be suc\u00adcessful if the user paused long enough. \nHowever, links on the page are not the only way to navigate to another page. The user can enter a symbol \ncode to jump to an arbitrary page. A page reached via symbol code entry is much less likely to be in \nthe cache. Another case is a page containing a large number of outgoing links. While many pages had four \nor fewer links, certain index pages (e.g., the page listing all the restaurants) had many more. How well \ndid caching and prefetching work? After the test, we analyzed 289 log .les taken during the last four \ndays of our user tests. In an average session, caching and prefetching resulted in cache hits 77.1% of \nthe time over 336.3 page visits. There are several questions one might ask. First, what Table 5: Cache \nhit rates for various policies Setting Hit Rate 1. Original policy 77.1% 2. Caching only 62.6% 3. Double \nprefetching 78.1% 4. Double cache, double prefetching 85.1% 5. Half-sized cache, no prefetching 52.1% \n is the breakdown of the cache e.ectiveness between caching and prefetching? Second, what would have \nhappened if the cache size was smaller or bigger? To answer these questions, we built a simulator to \nreplay user actions from the log .le and gathered data for di.erent combinations of caching and prefetching. \nTable 5 shows the result of this simulation. The table shows .ve cache policy variations, including the \none we used in the actual test: 1) the original policy, 2) caching only (no prefetching), 3) doubling \nthe number of links examined during prefetching (to 6) with the same the cache size, 4) doubling the \nnumber of links examined during prefetching and also doubling the cache size (to 8 megabytes) and 5) \ncaching only with half the cache size (2 megabytes) and no prefetching. These results show that, while \ncaching alone was quite e.ective, prefetching added a signi.cant 14.5% percent to the hit rate. Doubling \nthe number of links examined dur\u00ading prefetching with the same cache size would not have improved the \nhit rate signi.cantly, but doubling both the cache size and the prefetching (had we had the memory to \ndo so) could have improved the hitrate by 8%. Cutting the cache size in half would have decreased performance \nsignif\u00adicantly. On the whole, our cache size and prefetching pa\u00adrameters worked well for the amount of \nmemory that was available. We didn t have any usage data when we set these parameters; we were just lucky. \nAs showed earlier in section 3, reading and decoding a typical full-page asset takes more than 360 milliseconds, \na delay that feels noticeably sluggish. When the image for a page is in the cache, as it is 77% of the \ntime, the response time is dominated by the display update time. At only 52.4 milliseconds, this feels \nquite snappy. Based on our surveys, users were entirely happy with the performance of the Parks PDA. \n 7. RAPID DEVELOPMENT All the media content and most of the software for the Parks PDA was created by \na team of 9 artists and two pro\u00adgrammers in about three months. Considering the number of features, the \nintegration with hardware, and our lack of prior experience developing software for handheld devices, \nthis was extremely fast. Some of that speed can be at\u00adtributed to the innate e.ciency of the Smalltalk-80 \npro\u00adgramming environment. However, key aspects of the devel\u00adopment process were enabled by features unique \nto Squeak. This section explains how Squeak supported rapid develop\u00adment. 7.1 Put Artists in Control \nof Content It was clear from the beginning that if the artists de\u00adpended on the programmers to assemble \ncontent then the programmers would be the bottleneck. One of the artists pointed out that much of the \ndesired system behavior could be modeled as a stack of cards with links for navigating to other cards. \nWe thus implemented a simple card-stack editor called Stacker that allowed artists to create cards, import \nartwork as images attached to these cards, and add links between cards. All artwork for cards, as well \nas the card list itself, was stored using asset .le format described in section 5.5. A key point is that \nthe software that ran in the guest s Parks PDA was exactly the same software that was used for development, \nbut with a .ag set to disable editing. Thus, as the artists used Stacker to develop content, they were \nalso testing the .nal software that would be used by guests.  7.2 Bit-Identical Cross-Platform Operation \nWe distributed the Stacker program as a Squeak virtual image set up to run Stacker on startup. Because \nthe Squeak virtual machine had already been ported to Linux, Mac OS, and Windows, this one virtual image \ncould be run on the artists desktop computers regardless of what kind of com\u00adputer and OS they had and \nall three of these platforms were used. The same Stacker image could also be run on the Zaurus MI-C1, \nso artists could simply put Stacker and their current stack on a Compact Flash card to preview their \nartwork as it would be seen by guests. This was important because contrast and color di.erences made \nartwork read di.erently on the MI-C1. While it didn t surprise the artists, it s actually unusual for \na program like Stacker to operate virtually bit-identically across such a wide range of hardware and \nOS platforms. Squeak achieves this feat as the result of a number of de\u00adsign decisions, especially the \nfact that Squeak s class library was built to be as self-su.cient and platform-independent as possible. \nTake fonts, for example. Many programming systems rely on the fonts of the underlying operating system. \nWhen an application is moved from one system to another, some font may not be available, so a substitute \nis used. This causes changes in the appearance and spacing of text, which ef\u00adfects the placement and \nlayout of user interface elements. Squeak, in contrast, implements its own text display and every Squeak \nimage carries it s own fonts, so the appear\u00adance and letter spacings are bit-identical on all platforms. \nAs another example, Squeak hides platform di.erences in graphics output by de.ning its own virtual display \nscreen. All graphical operations on this virtual screen behave identi\u00adcally on all platforms right down \nto the pixel representation and byte ordering. There is only one place that knows about the native frame \nbu.er representation: the C code in the vir\u00adtual machine that copies pixels from Squeak s virtual screen \nto the hardware frame bu.er. One might think that maintaining a virtual display screen would adversely \nimpact performance and memory footprint. However, smooth animation requires the use of an o. screen display \nbu.er to avoid .ashing, and Squeak s display serves as that bu.er. Thus, assuming the application uses \ndouble\u00adbu.ering, there is scarcely any additional cost.  7.3 Simulate Missing Hardware In some cases, \nan application needs hardware that s unique to a given platform, such as the Zaurus camera and silk\u00adscreened \nbutton strip. In this case, our approach was to simulate these hardware features when running on other \nplatforms to support cross-platform development. For ex\u00adample, when running on a desktop computer, the \nZaurus silk-screened buttons were simulated by a set of virtual but\u00adtons to the left of the virtual PDA \nscreen. We actually developed and tested most of the camera ap\u00adplication on a laptop computer. After \nall, none of the logic for capturing and reviewing photos cares about the content of those photos, so \nany image of the right size will work as well as a real photo. However, the ZaurusCamera class uses primitives \nspeci.c to the Zaurus PDA platform that fail on any other platform. So, for development purposes, we \ncreated a subclass of ZaurusCamera called DummyZaur\u00adusCamera that replaces those primitives with methods \nthat emulate camera behavior in simple ways. For example, the shutter button is emulated by the enter \nkey and taking a picture with the camera is emulated by grabbing a snapshot of the screen. Using DummyZaurusCamera, \nwe were able to exercise the camera application on any desktop computer; we did not need to download \nit to a PDA. This allowed us to iterate through the testing cycle quickly, allowing us to work in tight \ncollaboration with a graphic designer, making and testing changes together as we re.ned the look and \nfeel of the user interface. Overall, the small investment of time required to simulate the unique hardware \nfeatures of the PDA paid o. many times over in saved development time. As a bonus, we can demo the Parks \nPDA application to large groups using a laptop computer and video projector. 7.4 Embedded Development \nEnvironment Squeak, like other Smalltalk-80 systems, has a built-in de\u00advelopment environment that allows \nevery method in the sys\u00adtem to be viewed, edited, and debugged at runtime. While it is possible to jettison \nthis programming environment to recover several hundred kbytes of memory, we had su.cient RAM to retain \nthe development environment in the virtual image we ran on the device even when we deployed the ap\u00adplication \nfor the user tests. That decision paid o. in many ways. Having the development environment available \non the de\u00advice had many uses during development. First, it was easy to evaluate expressions to test pieces \nof code in isolation. This was especially valuable for measuring performance, allowing the programmer \nto quickly isolate performance bottlenecks and compare the performance of alternate implementations. \nIt was also useful when debugging hardware speci.c VM features, such as the camera support code and optimized \ngraphics primitives. For this, the PDA VM was connected to a remote debugger running on a PC. Break points \nwere set in the C code of the camera support code and Smalltalk expressions were evaluated one at a time \nto see what hap\u00adpened. The Smalltalk expressions could be edited to pass di.erent arguments to the new \nprimitives to test di.erent cases and the results could be seen immediately. For exam\u00adple, one could \nevaluate an expression to grab a frame from the camera and display it on the screen. This interactive \ntesting was much faster than it would have been to write and compile tests in C. Since we could use the \nresults of earlier tests to decide what to try next, we were able to make quite a bit of progress in \nisolating problems before re\u00adcompiling the VM. Since it took many minutes to build a new VM and install \nit on the device, this technique saved a great deal of time. As mentioned, the Squeak development environment, \nin\u00adcluding the debugger, was so small that we decided not to bother removing it from the .nal application. \nThis turned out to be an unexpected life-saver during user testing. The day before the user test began, \nwe tested the Parks PDA on a group of park employees who had no prior ex\u00adposure to the project. This \ntesting revealed only a few mi\u00adnor problems that were easy to .x. After making these changes and loading \nthem onto all 100 Parks PDA devices, we were con.dent that the .rst day of user testing would go smoothly. \nWe were very wrong. Within half an hour, guests began bringing back PDA s that weren t working. Oddly \nenough, other guests were hav\u00ading no problems. The symptoms did not seem to be related to anything we \nhad changed. However, because the debug\u00adger was still available, we were able to examine the execution \nstack, look at variables, and evaluate expressions. After ex\u00adamining about six units, a pattern emerged: \none of the asset .les was corrupted. The essential clue was that the same ex\u00adact error appeared at the \nsame .le location in all six units. This was clearly not a coincidence. We deduced that one of the laptops \nwe had used to copy asset .les onto Compact Flash cards had somehow corrupted the master asset .le and \nthat error had been copied to all the Compact Flash cards created on that laptop. We even knew which \ncomputer was probably responsible, since one of us had had trouble read\u00ading .les from the master Compact \nFlash card. We added some code to verify the structure of asset .les at startup time, and re-copied the \nmaster .le set onto all 100 devices, this time avoiding the suspect laptop, and never had this problem \nagain for the remaining eight days of user testing. In most other programming languages, the error handler \ns capability is limited. When an unexpected error occurs dur\u00ading execution, the best that may happen \nis that the call stack is displayed or written to a .le and the program quits. Unfortunately, the call \nstack alone may not be enough to diagnose a problem. It is not exaggerating to say that having the full \ndebugger and development environment available at deployment time saved the user test from disaster. \nThe debugger allowed us to .nd the crucial clues that pointed to a .le corruption problem during Compact \nFlash card duplication. The prob\u00adlem was not due to a bug in the software at all, but without any hints \nabout the real nature of the problem we might have spent days fruitlessly trying to reproduce the bug \nunder laboratory conditions, rapidly using up our two-week window of opportunity for the user test. \n 8. SEVEN KEYS TO PROJECT SUCCESS A number of factors contributed to making Squeak an es\u00adpecially e.ective \nvehicle for the Parks PDA project. While some of these factors are a consequence of Smalltalk-80 s clean, \nobject-oriented semantics, most of them have little to do with the language; they stem from Squeak s \nopen imple\u00admentation and .exible packaging. In practical applications, such details can often make or \nbreak a project. Pointer safety Smalltalk-80 programmers take point-safety for granted, yet this property \nof the language allowed us to fearlessly make changes to the software in response to newly discovered \nneeds. For example, during the .rst week of the user test, we added a clock to the home screen, a set \nof hardware diagnostics, and a blinking reminder that a ride reserva\u00adtion was due, in addition to .xing \na number of minor bugs. We dared to do this because code changes had local e.ects. When adding a feature, \nwe did not worry that we might in\u00adtroduce a wild pointer bug or storage leak that would break some completely \nunrelated and perhaps critical part of the system. Portable, open-source virtual machine As we ve shown, \none key to our rapid development of both software and content centered on our ability to do cross\u00adplatform \ndevelopment. Squeak already ran on over a dozen platforms, including Windows, MacOS, and Linux. But be\u00adcause \nour chosen device was new and ran the proprietary Zaurus operating system, we needed to be able to do \nour own port of Squeak to it. Fortunately, Squeak s interpreter\u00adbased virtual machine is extremely portable. \nIt typically takes only a few weeks to get it running on a new platform. Small memory footprint Squeak \ns relatively modest memory footprint roughly 500k bytes for the virtual machine and about 800k bytes \nfor the base image, including the full development environment and debugger left us plenty of room for \napplication code and media. In fact, we were able to devote many megabytes of RAM to a media cache and \nwe were not even tempted to remove the development environment. Low-latency garbage collector Predictable \nresponse times and smooth animations are es\u00adsential for a quality multimedia experience. Large garbage \ncollection pauses would signi.cantly detract from the user experience. Squeak has an e.cient increment \ngarbage col\u00adlector that runs often but usually takes under 20 millisec\u00adonds. Such short pauses are unnoticeable \neven during ani\u00admation and user interaction. Although a full garbage collec\u00adtion can take a second or \ntwo, full-GC s happen very rarely in practice. Platform independence Cross-platform development could \nhave been a disaster had the application behaved di.erently on the target device. Thanks to Squeak s \ndeep commitment to platform indepen\u00addence, the operation of the software was bit-identical on all platforms. \nThe only di.erences were unavoidable ones, such as processor performance and color/contrast di.erences \nbe\u00adtween computer monitors and the re.ective LCD screen. System-level control and custom primitive support \nHaving complete control over the system as if Squeak were it s own operating system allowed us to manage \ninteractions with hardware devices, control system sleep mode, and use knowledge of user activities to \ncontrol the allocation of pro\u00adcessor cycles. In addition, Squeak s open virtual machine al\u00adlowed us to \nadd primitives to accelerate performance-critical operations. Self-contained development tool and debugger \nThe ability to evaluate expressions and do small amounts of programming directly on the device saves \ndevelopment time. The programmer can get much more testing and de\u00adbugging done before having to perform \nthe time-consuming process of copying a new version of the application from the development machine to \nthe device. Bugs that arise during such testing can be tracked down using Squeak s built-in debugger. \nIn fact, having Squeak s built-in debugger avail\u00adable even after we d deployed the .nished application \nmay have saved the entire project. Having the debugger on board is like using a seatbelt; you hardly \never need it, but putting it on after a collision does no good at all. 9. BUILDING A PARKS PDA TODAY \nMobile computing technology has evolved rapidly since our Parks PDA user test in November 2000. This \nsection discusses recent innovations and how we might use them if we were to create a new Parks PDA today. \nFirst, PDA processors and displays have improved dra\u00admatically. While a few handheld devices such as \nthe Apple Newton and the Palm Pilot were available in 2000, practi\u00adcally none of them had outdoor-viewable \ncolor screens. In fact, we believe that the Sharp MI-C1 was probably the only product then available \nthat combined a re.ective LCD screen, a camera, a compact and lightweight form factor, and support for \nan external memory card. Today, many PDA s have outdoor-viewable color displays, and most of them also \nboast high performance/low-power processors such as the Intel XScale chip. These devices would make it \nmuch easier to achieve acceptable performance. Cellular telephones have become powerful computing de\u00advices. \nSome high-end cellphones sold in Japan have a two\u00adinch QVGA color screen, a mega-pixel digital camera, \nand a faster processor than the MI-C1. As a hardware plat\u00adform, such a cellphone is a good candidate. \nUnfortunately, the software environment available on cellphones is closed, making it di.cult or impossible \nto control cellphone periph\u00aderals such as the digital camera or to write primitives in a low-level language \nto enhance performance. This situation may change as cellphones and PDA s converge. At the time of our \ntest, GPS was available, but not in a small form factor. It has now become much smaller and less power-hungry, \nbut typical GPS systems still don t provide resolutions down to the one to .ve meters that would be ideal \nfor theme park applications. Furthermore, GPS often doesn t work well when the sky is partially obscured \nby fo\u00adliage or buildings, and it can take minutes to get enough data for an accurate .x. Thus, we believe \nthat our pro\u00adprietary, IR-based system remains the cheapest and most reliable location-sensing solution \nfor theme parks. Several other mobile guide e.orts such as Active Badge[3] and Cy\u00adberguide[8] are based \non an IR system similar to ours. What about wireless? The Parks PDA did not have wire\u00adless communications, \nalthough we pretended that it did to simulate the user-experience of ride and restaurant reserva\u00adtions. \nWhile the 50 to 200 kbits/sec bandwidth available through current cellphone networks could be used to \npro\u00advide informational updates, instance messaging, and ride reservations, it would require signi.cantly \nmore bandwidth to retrieve all the Parks PDA graphical content wirelessly. Today, we might consider using \nan 802.11 network for this purpose, although it is not entirely clear how well this would scale. Theme \nparks pack many people into a small area and even if only few percent of them carry Parks PDA s, the \nnumbers can get large. Meanwhile, Flash memory has fallen in price so it may still be best for graphical \ncontent to be pre-loaded onto the PDA. We might need to consider alternatives to Squeak for the software \nplatform. For devices with insu.cient memory to use Squeak (under 1.5 megabytes) such as PalmOS devices \nand a cell phones, options include Java J2ME[11] or Pock-etSmalltalk[1]. However, since many of the success \nfactors discussed in section 8 do not apply to these languages, we would have to budget more time for \ndevelopment. Actually, Java J2ME is the only way to program most programmable cell phones. Unfortunately, \nthe J2ME virtual machines for cell phones are not open, so we would not be able to add primitives to \naccess camera hardware or perform high-performance graphic operations. One option for more open platforms \nwould be to port the virtual machine for Python[9] or Ruby[13]. To support multimedia, we would write \nour own cross-platform graphics library, possibly using a portable GUI library such as Qt or Qt/Embedded[10]. \nOur goal would be to create a tool with bit-identical operation across platforms as good as Squeak. Of \ncourse, it would be much easier to just use Squeak! 10. CONCLUSIONS The Parks PDA project was an ambitious \nundertaking. Part of the challenge involved creating a production-quality multimedia experience on a \nnew device while interfacing to a camera and other special hardware. Cross-platform de\u00advelopment of both \nsoftware and content was essential for rapid development. Squeak supported cross-platform de\u00advelopment \nwith essentially bit-identical operation between three di.erent desktop platforms and the device itself. \nOne of the big lessons from this project is that using a bytecode interpreter need not result in low \nperformance, even in a performance-hungry multimedia application. Most of the time is spent in a few \nkey operations, such as reading, decompressing, and displaying images. It is easy to write primitives \nin C to perform these operations at maximum speed. In fact, Squeak made it so easy to pinpoint and .x \nperformance bottlenecks that we re con.dent that the per\u00adformance of the Parks PDA software is very close \nto the maximum performance limits of the hardware for the key operations. We were fortunate that we had \nalready ported Squeak to the Zaurus platform before the project began. Yet, if we had to do a similar \nproject again, we would be glad to invest the two to four weeks necessary to port Squeak to a new platform, \nknowing that this investment would pay o. many times over for the rest of the project. If we had to use \na di.erent language, we believe that most of the key success factors that we discovered using Squeak \ncould be available in Python, Ruby, or Java J2ME, assuming that one could extend the virtual machine. \nWe d avoid C++ due to its lack of pointer safety and true garbage collection. Squeak turned out to be \nthe perfect tool for the Parks PDA project. It allowed us to move quickly and to ex\u00adplore completely \nnew territory on a handheld device. What s more, Squeak made the Parks PDA as much fun to develop as \nit is to use. Acknowledgements We thank all the team members of Parks PDA project, the engineers at Sharp \nCorporation, and all cast members at Disney s Animal Kingdom.. We especially thank Alan Kay and his team \nfor creating Squeak and Squeak s open source community for their ongoing contributions to it. 11. REFERENCES \n[1] E. Arseneau. Pocketsmalltalk. http://www. pocketsmalltalk.com. [2] AXE, Inc. XTAL. http://www.xtal.org. \n[3] A. Harter and A. Hopper. A distributed location system for the active o.ce. In IEEE Network, volume \n8, 1 1994. [4] Ian Piumarta. Porting Squeak, chapter 8, pages 215 262. Prentice Hall, 2002. [5] D. Ingalls, \nT. Kaehler, J. Maloney, S. Wallace, and A. Kay. Back to the future the story of Squeak, a practical \nSmalltalk written in itself. In Object-Oriented Programming, Systems, Languages, and Applications, pages \n318 326, 1997. [6] Intel Corporation. Intel Integrated Performance Primitives. http://www.intel.com/software/products/ipp/. \n[7] John Maloney. An Introduction to Morphic: The Squeak User Interface Framework. In Squeak: Open Personal \nComputing and Multimedia, chapter 2, pages 39 68. Prentice Hall, 2002. [8] S. Long, R. Kooper, G. D. \nAbowd, and C. G. Atkeson. Rapid prototyping of mobile context-aware applications: The cyberguide case \nstudy. In Mobile Computing and Networking, pages 97 107, 1996. [9] M. Lutz. Programming Python. O Reilly \n&#38; Associates, 1996. [10] Mathias Kalle Dalheimer. Programming with Qt, 2nd Edition. O Reilly &#38; \nAssociates, 2002. [11] Roger Riggs and Antero Taivalsaari and Mark VandenBrink. Programming Wireless \nDevices with the Java 2 Platform, Micro Edition. [12] R. B. Smith, J. Maloney, and D. Ungar. The Self-4.0 \nuser interface: Manifesting a system-wide vision of concreteness, uniformity, and .exibility. In Object-Oriented \nProgramming, Systems, Languages, and Applications, pages 47 60, 10 1995. [13] Yukihiro Matsumoto. Ruby \nin a Nutshell. O Reilly &#38; Associates, 2001.   \n\t\t\t", "proc_id": "949344", "abstract": "The Parks PDA is a lightweight, handheld device for theme park guests that functions as a combination guidebook, map, and digital camera. Together with a small team of artists and designers, we created a prototype Parks PDA and content for a three hour guest experience, including a camera interface, a hyper-linked guide book, three games, an animal spotters guide, a cross-referenced map, animated movies with lip-synched sound, a ride reservation system, and more. Over 800 visitors to Disney's Animal Kingdom&#8482; theme park tested the Parks PDA over a two week period.Developing the software for this test posed a number of challenges. The processor and memory of the target device were slow, the screen was small, and we had only three months of development time.We attacked these problems using Squeak, a highly-portable, open source Smalltalk implementation. We ported Squeak to the target device and used it to provide nearly bit-identical behavior across four different platforms. This supported a cross-platform development style that streamlined the production of both software and content. We created a tiny user interface and application framework for pen-based devices and implemented a simple card-stack media editor and player using it. We isolated and addressed several challenging performance issues.The project was completed on time and guest response was favorable. Looking back, we can identify seven aspects of Squeak that contributed to the success of the project. In fact, we feel that Squeak was the ideal tool for this job.", "authors": [{"name": "Yoshiki Ohshima", "author_profile_id": "81100179459", "affiliation": "Twin Sun, Inc., El Segundo, CA", "person_id": "P643502", "email_address": "", "orcid_id": ""}, {"name": "John Maloney", "author_profile_id": "81100652605", "affiliation": "MIT Media Lab, Cambridge, MA", "person_id": "PP15038585", "email_address": "", "orcid_id": ""}, {"name": "Andy Ogden", "author_profile_id": "81544221056", "affiliation": "Strategy, Design, and Development Consulting, Pasadena, CA", "person_id": "P643423", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949444", "year": "2003", "article_id": "949444", "conference": "OOPSLA", "title": "The parks PDA: a handheld device for theme park guests in squeak", "url": "http://dl.acm.org/citation.cfm?id=949444"}