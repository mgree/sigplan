{"article_publication_date": "10-26-2003", "fulltext": "\n Software Factories Assembling Applications with Patterns, Models, Frameworks and Tools Jack Greenfield \nVisual Studio Enterprise Frameworks &#38; Tools Microsoft Corporation One Microsoft Way Redmond, WA 98053 \njackgr@microsoft.com ABSTRACT The confluence of component based development, model driven development \nand software product lines forms an approach to application development based on the concept of software \nfactories. This approach promises greater gains in productivity and predictability than those produced \nby incremental improvements to the current paradigm of object orientation, which have not kept pace with \ninnovation in platform technology. Software factories promise to make application assembly more cost \neffective through systematic reuse, enabling the formation of supply chains and opening the door to mass \ncustomization. Categories and Subject Descriptors D.2.2 [Design Tools and Techniques], D.2.11 [Software \nArchitectures]: languages, patterns, domain-specific architectures, D.2.13 [Reusable Software] domain \nengineering. General Terms: Design, Languages. Keywords: Design Patterns, Domain-Specific Languages, \nModel-Driven Development, Software Product Lines, Software Factories. 1. INTRODUCTION 1.1 Industrializing \nSoftware Development The software industry remains reliant on the craftsmanship of skilled individuals \nengaged in labor intensive manual tasks. However, growing pressure to reduce cost and time to market, \nand to improve software quality, may catalyze a transition to more automated methods. We look at how \nthe software industry might be industrialized, and we describe technologies that might be used to support \nthis vision. We suggest that the current software development paradigm, based on object orientation, \nmay have reached the point of exhaustion, and we propose a model for its successor. Some have suggested \nthat software development cannot be industrialized because of its creative character. Others have suggested \nthat significant progress can still be made on the foundation of object orientation, especially in light \nof the growing agility of development methods. We are quite sympathetic with Copyright is held by the \nauthor/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. \n Keith Short Visual Studio Enterprise Frameworks &#38; Tools Microsoft Corporation One Microsoft Way \nRedmond, WA 98053 keithsh@microsoft.com these points of view, and have seen that small teams of skilled \ndevelopers can develop complex applications on time and on budget, with high levels of quality and customer \nsatisfaction. However, we have also seen that such results are the exception, not the rule. Recognizing \nthat software development is an inherently people-oriented discipline that cannot be reduced to purely \nmechanical and deterministic processes, however, we propose a people-oriented approach to industrialization, \none that uses vocabularies that are closer to the problem domain, and that leaves more of the mechanical \nand deterministic aspects to development tools. 1.2 Lessons from Other Industries Over the last ten \nyears, the software industry has met the demands of an increasingly automated society by honing the skills \nof individual developers, just as artisans met the demands of an increasingly industrialized society \nin the early stages of the industrial revolution by honing the skills of individual craftsmen. Up to \na point, this is an effective way to meet demand. Beyond that point, however, the means of production \nare quickly overwhelmed, since the capacity of an industry based on craftsmanship is limited by its methods \nand tools, and the by size of the skilled labor pool. A quick look at the state of software projects \nsuggests that we are already struggling to meet demand using the current means of production. According \nto the Standish Group [26], businesses in the United States spend more than $250 billion annually on \nsoftware development, with the cost of the average project ranging from $430,000 to $2,300,000, depending \non the company size. Only 16% of these projects are completed on schedule and on budget. Another 31% \nare canceled, primarily due to quality problems, creating losses of about $81 billion annually. Another \n53% cost more than planned, exceeding their budgets by an average of 189%, creating losses of about $59 \nbillion annually. Projects that reach completion deliver an average of only 42% of the originally planned \nfeatures. These results are likely to be exacerbated by continuing platform technology innovation, which \nhas outstripped the methods and tools used to develop software over the last ten years. In the business \napplication market, for example, we can now integrate heterogeneous systems in different businesses located \nanywhere on the planet, for example, but we hand-stitch the applications deployed on this platform technology \none at a time, treating each one as an individual, implementing coarse grained, domain specific concepts \nlike stock trades and insurance claims using fine grained, generic concepts like loops, strings and integers. \nSimilar observations can be made in markets for mobile devices, media, smart appliances, embedded systems \nand medical informatics. When faced with similar challenges many years ago, other industries moved from \ncraftsmanship to industrialization by learning to customize and assemble standard components to produce \nsimilar but distinct products, by standardizing, integrating and automating their production processes, \nby developing extensible tools that could be configured to automate repetitive tasks, by developing product \nlines to realize economies of scale and scope, and by forming supply chains to distribute cost and risk \nacross networks of highly specialized and interdependent suppliers. These changes enabled the cost effective \nproduction of a wider variety of products to satisfy a broader range of customer demands. What will industrialization \nmean in the software industry? No one will know until it happens, of course, but we can make educated \nguesses by looking at how the software industry has evolved. We can also gain insights by looking at \nwhat industrialization has meant in other industries, and by comparing them with ours to see how our \nexperience might be similar or different.  1.3 Economies of Scale and Scope Others have drawn and debated \nsuch analogies between the software industry and industries that produce physical goods [4, 12, 13]. \nHowever, some of the discussion has involved an apples\u00adto-oranges comparison between mass production \nin industries that produce physical goods, on the one hand, and the development of designs and one-off \nimplementations in the software industry, on the other. There are two keys to clearing up the confusion. \n The first is to distinguish between economies of scale and scope. While both refer to the realization \nof cost reductions by producing multiple products jointly, rather than independently, they arise in different \nsituations. Economies of scale arise in the production of multiple implementations of a single design, \nwhile economies of scope arise in the production of multiple designs and their initial implementations. \nEconomies of scale arise in the production of software, as in the production of physical goods, when \nmultiple copies of an initial implementation are produced mechanically from prototypes developed by engineers. \nEconomies of scope arise when the same styles, patterns and processes are used to develop multiple related \ndesigns, and again when the same languages, libraries and tools are used to develop the initial implementations \nof those designs [14]. When used to drive mass production, these initial implementations are called prototypes. \nAccurate comparisons between the software industry and industries that produce physical goods should \ncompare economies of scale in the mass production of copies in one industry with the same measure in \nthe other, or they should compare economies of scope in the development of prototypes in one industry \nwith the same measure in the other. They should not compare economies of scale in the mass production \nof copies in one industry with the development of prototypes in the other.  The second is to distinguish \nbetween mass markets and custom markets. In mass markets, where the same product can be sold many times, \neconomies of scale can be realized in software production, as in the production of physical  goods, \nby copying prototypes mechanically. In custom markets, each product is unique. Instead of being copied, \nthe prototypes are delivered to customers. Here, software production is more like the construction of \nbridges and skyscrapers. In custom markets, economies of scope can be realized in software production, \nas in commercial construction, through systematic reuse, by using the same assets to develop multiple \nunique but similar products. Of course, while the realization of economies of scale in the mechanical \nreplication of software is well understood, the realization of economies of scope in the development \nof multiple unique but similar software products is not well understood. We therefore focus on the latter \nas an avenue for further progress toward the industrialization of software development. 1.4 Software \nFactories Economies of scope can be realized in the context of a product family, whose members vary, \nwhile sharing many common features. A product family may contain either end products, such as portfolio \nmanagement applications, or components, such as account management frameworks used by portfolio management \nand customer relationship management applications. According to Parnas, a product family provides a context \nin which many problems common to family members can be solved collectively [23]. Building on software \nproduct line concepts, software factories exploit this context to provide family wide solutions, while \nmanaging variation among the family members [10]. Instead of waiting for serendipitous opportunities \nfor ad hoc reuse to arise under arbitrary circumstances, a software factory systematically captures knowledge \nof how to produce the members of a specific product family, makes it available in the form of assets, \nlike patterns, frameworks, models and tools, and then systematically applies those assets to automate \nthe development of the family members, reducing cost and time to market, and improving product quality \nover one-off development. Of course, there is a cost to developing a software factory in order to realize \nthese benefits. In other words, software factories exhibit the classical cost-benefit trade-off seen \nin product lines [28]. While the benefit side of the equation cannot be increased through the production \nof many copies in custom markets, it can be increased through the production of many related but unique \nproducts or product variants, as documented by many case studies [10]. In addition, the cost side of \nthe equation can be reduced by making product lines less expensive to build. In our view, the key to \nindustrialization is enabling the cost effective construction and operation of software factories. 1.5 \nA Vision of Software Factories Before looking at how software factories work, we offer the following \nvision of the future, when software factories are widely used to produce applications. Of course, in \norder to paint this vision, we necessarily gloss over many issues. This does not mean that we have ignored \nthose issues. Indeed, we have written a book identifying and examining as many as we can, and suggesting \nresolution strategies, where possible [24]. In other words, while this is a vision, and therefore necessarily \nincomplete, we think it is close enough to reality to start guiding the way we think now. It implies \nsignificant changes, not only in methods and tools, but also in the economics of software development, \nas expertise comes from field organizations with problem domain knowledge, instead of from platform vendors. \n1.5.1 Development by Assembly Application developers will build about 30% of each application. The remaining \n70% will be supplied by ready-built vertical and horizontal components. Most development will be component \nassembly, involving customization, adaptation, and extension. Instead of residing in large amounts of \nnew code written in house from scratch, new functionality will be distributed across many ready-built \nand built-to-order components provided under contract by many suppliers, each of whom will write small \namounts of new code from scratch. Standard components will be commoditized, and custom component suppliers \nwill become ubiquitous, specializing in a wide variety of domains. Software that would be prohibitively \nexpensive to build by current methods will become readily available. 1.5.2 Software Supply Chains To \nfeed the demand for components created by software factories, supply chains will emerge, creating standard \nproduct types with standard specification formats that help consumers and suppliers negotiate requirements, \nstandard architectures and implementation technologies that let third parties assemble independently \ndeveloped components, standard packaging formats that make components easy to consume, standard tools \nthat can be reconfigured for product specific feature variations, and standard development practices. \nOne of the keys to making this work will be the use of standard architectures that reduce component mismatch \nand simplify the management of supplier relationships by describing the contexts in which components \noperate. Architectural alignment has been a challenge to supply chain pioneers in the automotive and \ntelecommunications industries. 1.5.3 Relationship Management Requirements capture, analysis and negotiation \nwill become critical elements of customer relationship management. Service level agreements documenting \nthe expectations of consumers and suppliers will be govern transactions. Following product delivery and \nacceptance, repairs and assistance will be provided on a warranty basis. In most cases, consumers will \nlease components from suppliers, allowing them to receive patches and upgrades systematically. Dynamic \npatch and upgrade mechanisms will become ubiquitous and much less intrusive. Tools that manage the configurations \nof deployed products will become critical parts of the platform. Data generated from customer and supplier \ninteractions will be used to improve service levels, to optimize production and delivery, and to plan \nfuture product offerings.  1.5.4 Domain Specific Assets At every step, including final assembly, developers \nwill use tools configured for the purpose at hand. Tools for banking and health care application development, \nfor example, will be readily available. These tools will use powerful abstractions and appropriate best \npractices encoded as languages, patterns and frameworks for specific domains. Application developers \nwill no longer hand craft large amounts of code in general purpose languages. Instead, they will build \nvariants of existing products, customized to satisfy unique requirements, writing small amounts of code \nin domain-specific languages to complete frameworks. Imagine tools that look like user interface builders \nfor assembling web services and business logic. These languages, frameworks, patterns and tools will \nbe inexpensive to build, enabling organizations with domain expertise to encapsulate their knowledge \nas reusable assets. Of course, we are not suggesting that no one will write code by hand any more. When \nthis vision is realized, product line developers will build the languages, frameworks and tools used \nby application developers, in much the same way that operating system developers build device drivers \nand other system software components used by application developers today. The mix of product line and \nproduct developers will be much more evenly balanced, however, than the mix of operating system and application \ndevelopers today.  1.5.5 Mass Customization Some industries, such as the web based PC business, produce \nproduct variants on demand cheaply and quickly for individual customers today. While we will not see \nmass customization in software products for some time, the broad adoption of software factories will \neventually make it possible. Where this occurs in other industries today, business processes are highly \nautomated and highly integrated. A value chain that integrates processes like customer relationship management, \ndemand management, product definition, product design, product assembly and supply chain management is \na fundamental prerequisite for mass customization. When software suppliers achieve the level of value \nchain integration found in other industries, mass customization will dramatically change the economics \nof software development. Picture a buyer ordering a customized financial services application from a \nweb site, the same way that they order a customized desktop machine or server today, with the same level \nof confidence, and similar delivery time. 1.5.6 Organizational Change Clearly, everyone with a stake \nin application development will be affected by the broad adoption of software factories. Software developers \nof all kinds will change their focus and think more about assembly than about writing new code. New development \nmethodologies will arise, more in tune with the principles of manufacturing. Development organizations \nwill develop the skills, incentives and processes required to exploit these changes. Packaged software \nvendors will restructure their products into componentized product families developed and maintained \nusing software product lines. Business users will exploit the higher levels of services offered by their \nIT organizations.  1.6 Developing Software Factories The current innovation curve could be described \nas the era of object orientation. Many commentators have observed that it has reached a plateau, and \nthat new technologies are needed to create the next quantum leap forward in application development. \nAccording to Kuhn, new paradigms are catalyzed by the exhaustion of their predecessors, correcting mistakes \nand applying existing knowledge in new ways [22]. Building on domain engineering, software product line \ntechnology is catalyzing new developments in two object oriented technologies, model-driven development \nand component-based development, providing a medium for correcting mistakes and applying existing knowledge \nin new ways. These developments represent critical innovations on three axes, along which we can plot \nthe transition to the next innovation curve, as illustrated in Figure 1. The figure sets the course for \nthe remainder of this paper. In the next three sections, we will look at each dimension in turn, and \ncall out the maturity of techniques that support each dimension. In the last section, we ll give a concrete \nexample of software factories in action. ab s ra c abst r act c o s e gr ai  coa r se g r a in co \nn c r e te c onc ret e n s i ng l e us e re - ab l us able  Figure 1: Three Axes of Critical Innovation \n  2. ABSTRACTION Abstraction hides characteristics of a subject that are not relevant for some purposes, \nwhile emphasizing others, and defines a contract that separates the concerns of various stakeholders \n[7]. The abstraction axis ranges from abstract models that specify product features, to source code and \nother concrete artifacts used to produce executable implementations. Like refactoring and adaptive design, \nraising the level of abstraction reduces the complexity and brittleness of software through encapsulation. \nBy hiding implementations, it keeps complexity from growing as features are composed, and prevents changes \nfrom propagating to clients. The higher we move along the axis, the more powerful the abstractions, but \nalso the narrower their scope of application. Powerful abstractions that encapsulate large amounts of \nlow level code tend to address highly specialized domains. Since the start of the current innovation \ncurve, there has been a trend toward increasing abstraction in platform technology, from distributed \ncomputing to message oriented middleware, to distributed object and component middleware, and recently \nto asynchronous, loosely coupled web services. A similar trend in application development technology \nis reflected by component architectures, which encapsulate deployment concerns, and by patterns, which \ndescribe configurations of existing technologies that represent known solutions to recurring problems \nin specific domains. While these innovations have advanced the state of the art by giving developers \nnew vocabularies for solving problems [17], they have stopped short of giving them formal languages to \nexpress those vocabularies. We are now seeing the extension of the trend in this direction, with the \nadvent of byte code based languages and specialized languages based on XML, such as languages for process \nspecification and execution. In fact, this kind of progression has characterized the evolution of the \nindustry, as noted by Smith and Stotts. The history of programming is an exercise in hierarchical abstraction. \nIn each generation, language designers produce explicit constructs for conceptual lessons learned in \nthe previous generation, and then architects use [the new constructs] to build more complex and powerful \nabstractions. [25] 2.1 Model-Driven Development One of the key themes of object orientation was Object \nOriented Analysis and Design (OOA&#38;D) [3]. OOA&#38;D proposed a way to decompose functional requirements \nand map them onto object oriented implementation technologies. One problem with this approach was that \nit incorrectly assumed that the structure of the solution would match the structure of the problem [11]. \nAnother problem with OOA&#38;D, was that it promoted a methodical, top down approach to development. \nThese problems have been addressed through a series of adaptations, however, and the basic principles \nof OOA&#38;D remain the foundation of modern application development practices. Since it combined contributions \nfrom several OOA&#38;D methods, the Unified Modeling Language (UML) became a rallying point for a model-based \napproach to application development. But despite a large number of books about the UML and a large number \nof tools claiming to support the UML, the language has had little real impact on application development. \nIts primary use has been to produce visual representations of classes and the relationships between them. \nConstrained by weak extensibility mechanisms, the UML is tightly bound to the programming language concepts \nin vogue at the time of its creation. Its semantic ambiguity and poor organization have prompted a redesign, \nwith contenders for a major revision vying to define what appears to be an even larger and more complex \nlanguage that is just as ambiguous and as poorly organized as its predecessor. Even with the proposed \nrevisions, the UML falls far short of providing the highly focused, domain-specific modeling capabilities \nrequired by the next wave of application development technology. Its primary contribution was the idea \nof an extensible modeling language with an underlying metamodel. While the documentation of abstract \nconcepts has some value, the real opportunity for innovation lies not in visualizing the information \ncaptured by models, but in processing that information to automate development tasks. This is the thrust \nof model-driven development (MDD). Despite its ties to OOA&#38;D, MDD embodies ideas and technologies \nthat predate object orientation. It seeks to capture developer intent, usually expressed informally, \nif at all, in prose or ad hoc diagrams, as formal specifications that describe application features in \nabstract terms using modeling languages, and to automate the implementation of that intent, usually by \ncompiling the specifications to produce executables. This is valuable because the features are difficult \nto see in low level implementation artifacts, such as source code, and difficult to develop, maintain \nand enhance consistently, due to the number of independent elements that must be synchronized. The promise \nof MDD is that platform specific compilers will produce implementations for multiple platforms from a \nsingle specification, letting users retain investments in models describing application features as the \nplatform technology changes beneath them. Of course, this is the same promise offered by byte code languages, \nsuch as C# and Java, and by generations of earlier languages that raised the level of abstraction above \ntheir predecessors. With some notable exceptions, early attempts at MDD, represented by the CASE tools \nof the eighties, failed miserably. Most of these tools did not take advantage of platform-specific features, \nand produced na\u00efve, inefficient, least common denominator code. The upfront costs of adopting the modeling \ntechniques they required were prohibitively large. Added to this was the risk inherent in spending a \nsubstantial portion of the (b ) Figure 2: Models and Application Code project s budget building models \nwith the promise of code appearing only in later stages. This required enormous confidence in the tools \nand in the longevity of their vendors. Also, concepts like round-trip engineering, where a model could \nbe synchronized with changes made independently to the code it had generated from them, were overwhelmingly \ncomplex. Another criticism was that many CASE tools imposed a methodical top-down process. This was the \nultimate kiss of death, since rapid iteration of partial solutions has proven to be critically important \nto the success of application development, as so clearly demonstrated by agile development methods [2]. \nThese problems can be overcome using language technologies that allow higher fidelity in specifying application \nfeatures, and using more transformation techniques that give developers much greater control over generated \ncode.  2.2 Critical Innovations in Abstraction We have seen that CASE tools began to exploit the benefits \nof higher levels of abstraction, but were unable to manage the inherent complexities. Typically they \nselected a useful set of abstractions, but were na\u00efve about the mapping to the executable platform, and \ntended to fill the gap between abstractions and executable platform by generating layers of application \ncode. Even good products that successfully managed to keep generated code synchronized with the models, \ntended to overwhelm the developer with the resulting complexity, and the models fell into disuse. See \nFigure 2(a). A good example are the generic class modeling tools that have their own vocabulary and type \nsystem, and which require complex mapping and code generation to the languages they attempt to model. \nUsually after one trip through the generation process, the task of synchronization and re\u00adgeneration \nbecomes too troublesome and the model is abandoned. Remember that the idea is to simplify the use of \ncomplex concepts by hiding unnecessary details, while providing a holistic view that exposes the relationships \nand dependencies among those concepts, where otherwise such these might be difficult to detect. The key \nidea is to keep the model the set of useful simplifying abstractions as close as possible to the underlying \nframework in which the concepts lie. For example, consider a graphical class modeling. This tool surfaces \nthese class definition concepts with high fidelity to their original type system and vocabulary, allowing \nthe developer to manipulate parts of his program visually as he would in a source code editor, but the \ntool adds value to the developers job because it surfaces relationships and dependencies between classes \nthat are not easy to see in the source code alone. See Figure 2(b). 2.3 Domain Specific Languages If \nthe set of simplifying abstractions requires too much of a bridge to implementation, the answer is to \nraise the level of abstraction of the underlying (d ) execution platform. There are two ways this can \nbe done. The first is by providing a software framework that specifically addresses a well\u00addefined, narrow \nproblem domain, and using the abstractions in a model to define how the variability points in the framework \nmust be filled as in Figure 2(c). The model has become focused and specific to this domain it can be \nexpressed in a domain specific language, or DSL, which explicitly describes concepts the new framework \noffers. In contrast, attempts to capture details of the specific domain in a general purpose modeling \nlanguage such as UML yields a lower fidelity description. Of course, DSLs may have either graphical or \ntextual concrete syntaxes, whatever suits the developer best. Let s take the example of user interface \nform design in Microsoft Windows. When Windows was first introduced, only highly skilled programmers \nwere capable of building working Windows applications. When Microsoft Visual Basic was introduced, the \nForm and Control abstractions allowed huge numbers of less skilled developers to easily produce working \nWindows applications. Forms and Controls were highly effective abstractions for the domain of graphical \nuser interface manipulation. Today, in the Microsoft .Net world, these same abstractions are implemented \nby the .Net framework that underlies the Form designer. Few developers bother to look at the small pieces \nof code generated to fill the variability points in the framework. We call this approach, where we generate \nminimal code to fill variability points in a domain specific framework from a domain specific model, \nframework completion, to contrast it with brute force code generation. Alternatively, we can use a set \nof related patterns, called a pattern language, to implement the abstractions, instead of a framework. \nThe pattern language for business application development with J2EE published by Alur, Crupi and Malks \n[1], for example, defines a collection of related patterns, and shows how and when they can be combined \nto solve many different kinds of problems. We can tool this kind of pattern language, giving the developer \na way to apply the patterns, and then evaluating them automatically when applied. Of course, since frameworks \nembody patterns [20], we may be able to use a pattern language and a framework together, using the patterns \nto guide the assembly of components supplied by the framework. Note that we can now automate framework \nbased development using either DSLs or pattern languages. The difference is essentially a trade-off between \nviewpoints for a product family, Domain and tools can be developed Specific inexpensively to support \nthe Languages f o rm a Techn o logy B u sin e ss In format ion In rmatioA pplica t ion Technology editing \nand transformation of the .Use cases .Business .Business .Service and scenarios Entities and Processes \ndistribution .Business Relationships .Service . Abilities Goals and factoring strategy Objectives .Workflow \n.Message .Service .Logical models Schemas and Interactions Server types .Role document .Service .Service \nDefinitions specifications definitions .Object models Mappings .Process .DB schemas .Detailed .Physical \nspecification .Data access strategy design .Technology dependent design Servers .Software Installed .Network \nlayout associated DSLs. We call this graph a software schema, Co n c e p t u a l because it describes \nthe set of specifications that must be developed to produce a software product. A software schema for \na product family, the processes for capturing and using the information it describes, and the tools used \nto automate that process collectively form a software template. A software template can be loaded into \nan extensible tool, such as an Interactive Development Log i cal Environment (IDE), to produce a specific \ntype of product, in much the same way as a document template can be loaded into an extensible document \neditor, such as Word or Excel, to produce a I m p l em enta ti on  Figure 3: A Layered Grid for Categorizing \nModels complexity and control. Since the pattern language lets the implementations of the abstractions \nshow through, the developer has more control over their implementation, but must also assume more responsibility. \nBy contrast, a DSL hides the implementations of the abstractions, but gives the developer less control \nover their implementations. If it s not possible to build a software framework that can provide a natural \nplatform for implementing a useful DSL, it may be possible to define another layer of simplifying abstractions \ninto which the first set may be mapped. This second set of abstractions may prove easier to implement \nthan the first, leading to the notion of progressive transformations between models. The abstractions \nare transformed into executables by a series of steps as in Figure 2(d). When models stack one upon another \nin this way, it becomes useful to categorize and summarize the models in an orderly fashion, and to study \ncarefully the relationships between them.  2.4 Relationships Between Metamodels One common way to do \nthis is to use a grid as in Figure 3. The columns of the grid represent concerns (data, activity, location, \npeople, etc.), while the rows represent levels of abstraction. Each cell represents a viewpoint from \nwhich we can specify software. Typically, for a given family of applications, a path through the grid \nrepresents a sequence of modeling deliverables and transformations to properly address functional and \nnon-functional requirements in the course of building and deploying an application. This modeling grid \nis not in itself an innovation. What is novel is applying the grid to a product family, defining DSLs \nfor each cell, and mappings between and within the cells that support fully or partially automatic transformations. \nAs we have seen, we must use DSLs, not general purpose modeling languages designed for documentation, \nin order to provide this kind of automation. A grid like the one in Figure 3 can be generalized as a \ngraph of specific type of document. An IDE configured with a software template for a product family \nbecomes a factory for producing members of the family. This is what we call a software factory. Later, \nwe will see how software factories can be integrated to form automated supply chains. Given appropriate \nDSLs and transformations, we can drive from requirements to executables using framework completion and \nprogressive refinement, keeping related models synchronized. For example, we can produce a logical data \nmodel, and then an optimized database schema from a business entity model and usage statistics from a \nbusiness process model. We can also leverage constraints that relate neighboring cells. For example, \ninformation known about the deployment environment (e.g., the available protocols and system services) \ncan be used to constrain designs of service interactions (e.g., by limiting them to the protocols and \nsystem services available within the deployment environment). This helps to ensure that the implementations \nof the service interactions will deploy correctly to the designated deployment environment. 2.5 Transformations \nTransformations can be characterized as either horizontal, vertical or oblique [14]. Vertical transformations \nare mostly refinement transformations that map models based on a more abstract DSL to models based on \na more concrete one, or to code based on a general purpose programming language. For example, a transformation \nfrom a model that describes a business process to models that describe the collaborating web services \nthat implement the business process is a vertical transformation. Horizontal transformations may be either \nrefactoring [16] or delocalizing transformations [14]. Refactoring transformations reorganize a specification \nto improve its design without changing its meaning. Refactoring can be applied to both tree and graph \nbased languages. So f t w a re Inserted into Com p o nent s Projects Figure 4: Applying a Business \nEntity Pattern Delocalizing transformations can be used to optimize an implementation, or to compose \nparts of an implementation that are specified independently. Often, the implementation of an operational \nrequirement, such as security or logging, must be distributed across many functional modules, making \nmaintenance difficult. The implementation of the operational requirement is therefore tangled with the \nimplementations of the functional requirements. Delocalizing transformations allow the operational requirement \nto be defined once and automatically woven into the functional modules during compilation. The operational \nrequirement is called an aspect, and the process of weaving it into the functional modules is called \naspect weaving [21]. Like refactoring, aspect weaving can be applied to both tree and graph based languages. \nAt any layer of the grid, aspects can be modeled separately, and woven into the functional modules automatically \nwhen mapping to lower level models, by an aspect weaver. Separating aspect models from the functional \nmodules makes maintenance easier, since it lets the developer focus on one problem at a time.  2.6 Using \nPatterns in Transformations Transformations are inherently parameterized, and operate by binding objects \nin source models as parameter values, and creating or modifying objects in target models. We can think \nof a transformation as mapping a pattern of objects in a source model to a pattern of objects in a target \nmodel. It encodes best practices for improving or implementing models. Using patterns to describe mappings \nhas led to new approaches to model representation, transformation and constraint. Of course, not all \npatterns can be applied automatically, because in many cases, the mapping between the models cannot be \nfully defined in advance. In these cases, the patterns must be applied manually by a developer, often \nwith support from a development tool. Once they have been applied, however, they can generally be evaluated \nautomatically, as described earlier. Figure 4 shows a Business Entity pattern, a template for an abstraction \nthat lets an application designer think in terms of data bearing persistent objects. This is a common \nabstraction for components used in business applications. It can be implemented by writing a large amount \nof data access code, a moderate amount of object-relational mapping code, or a Cust om er  small amount \nof component Ty p e  P r oj ect S t r u c t ur e persistence code, using a data access D e faul t X \nS D schem as framework like Java Database C l a ss and M e t hod H e a der s Connectivity (JDBC), an \nobject-O R Ma p p in g File relational mapping framework like TopLink, or a component persistence D \na tabas e T a bl es framework like Enterprise JavaBeans, Def a u l t CRU D S p rocs The pattern has \nbeen applied to the Customer Type Model in the Customer Management component. Its parameters are bound \nat the time of application. Its Type Model parameter is bound to the Customer Type I m ple m ent at ion \nModel, and its Operations parameter Ar ti f a cts is bound to operations on the Customer Management component. \nAfter its parameters have been bound, the pattern can be evaluated to generate implementation artifacts \nthat manage the persistence of Customer entities. 2.7 Some Examples of DSLs If we revisit the grid from \nFigure 3, and zoom in to the bottom right hand corner, as in Figure 5, we can now look at the viewpoints \nand the relationships between them in more detail. In the figure, rectangles represent viewpoints, dashed \nlines represent refinement transformations and solid lines represent constraints. We now know that each \nviewpoint contains more than just DSLs. It also contains: refactoring patterns that can improve models \nbased on the viewpoint,  aspect definitions that are applicable to models based on the viewpoint,  \ndevelopment processes used to produce models based on the viewpoint,  definitions of constraints supplied \nby models based on neighboring viewpoint,  frameworks that support the implementation of models based \non the viewpoint,  mappings that support transformations within and between models based on the viewpoint \nor neighboring viewpoint. The figure illustrates the following:  The Business Entity DSL defines the \nbusiness entity abstraction, which describes efficient, message driven, loosely coupled data services \nthat map onto an object\u00adrelational framework. Examples of business entities include Customer and Order. \n The Business Process DSL defines the business activity, role and dependency abstractions, and a taxonomy \nof process patterns that can be used to compose them, forming business process specifications. An example \nof a business process is Enter Negotiated Order, which might use three process patterns: one for a User \nInterface Process to build a shopping cart, one for a sequential process to submit the order and perform \n credit checks, and one for a rule-driven process to calculate the discount. These two DSLs map onto \na Web Service DSL that describes collaborating web services in a service-oriented application architecture. \nThe Web Service DSL is used to describe how the business entities and processes are implemented as web \nservices, how the messages they exchange are defined and what protocols are used to support their interactions, \nusing abstractions that hide the underlying details of the web service implementations.  A DSL for describing \nvirtual datacenter configurations in terms of logical servers that will be deployment targets for the \nweb services described using the Web Service DSL, along with the software they have installed, and their \nconfiguration settings.  Information from one model can be used to develop another. Examples are the \ninteractions between business entities and processes, and between web services and logical servers. This \nlast one is particularly interesting because it can be used to design for deployment. Feeding knowledge \nof the deployment infrastructure into web service designs constrains those designs to prevent deployment \nproblems. Similarly, working this in reverse, if a design is to be deployed on a given logical server \ntype, then we can validate that the server on which it will be deployed is of the correct type, that \nit has the right software installed, and that it is configured correctly.  Mappings drive transformations \nbetween models at design time. For example, we use a transformation to map the model of web services \nto an implementation on the target platform, probably in the form of classes that complete a framework, \nsuch as ASP.NET.   3. GRANULARITY tables and exceptions, to medium grained components that represented \nuser interface controls, to coarse grained components that represented business entities and activity, \nand now to even more coarse grained services that typically represent large subsystems, such as billing \nor credit authorization. Increasing granularity can improve the reusability of abstractions because a \ncoarser grained construct encapsulates more functionality than a finer grained one, has fewer external \ndependencies, and forms a more independent unit of specification, design, implementation, deployment, \ntesting, execution, management, maintenance and enhancement. However, standardized mechanisms for describing \ncomponent behavior beyond simple interface descriptors, such as WSDL for web services, have been slow \nto materialize. These mechanisms are necessary to realize the reuse potential of coarse grained pre-built \n Figure 5: A Simple Software Schema components or built-to-order components and services for application \nassembly, because the services required and offered by these large constructs, and their valid sequences \nof interaction, are often too complex to understand by experimentation. 3.1 Component Based Development \nComponent-based development (CBD) arose in the late nineties [15, 6]. CBD is an attempt to facilitate \nthe independent deployment of coarse grained constructs using encapsulation to minimize the dependencies \nexposed by the objects they contained. Although they appeared at the height of interest in the UML, the \nprinciples of CBD are weakly supported by the UML. Perhaps the most serious problem is that the UML defines \ntoo many different and incompatible ways to describe abstractions, without defining enough semantics \nto make any of them usable for actual development. While it does a passable job of supporting language \nclass specification, it does even worse in its attempts at describing the packaging of those classes \ninto components. Its handling of component composition is also weak. Designers want to express relationships \nbetween larger units of design (such as business components [HS00], web services, subsystems, etc.), \nsince this can lead to greater reuse of pre-built and commercial off-the-shelf components, and to greater \ncomponent outsourcing by formalizing contracts that describe component behavior. Larger units of design \nmust compose smaller units without loss of rigor, and interactions between them must allow the same level \nof analysis as interactions between smaller units. For these reasons, CBD techniques focus on component \ncomposition and decomposition, and the challenges of partitioning functionality among interacting components. \nCBD surfaces two important ideas. First, building on the established concept of an interface, CBD asserted \nthat there should be a hard distinction between the specification of a component and its implementation. \nThere are several mechanisms in the UML that attempt to address this issue. Granularity is a measure \nof the size of the software constructs In addition to creating confusion by offering multiple ways to \nused as the vehicles of abstraction. Since the beginning of the era solve the same problem, these mechanisms \nare not used of object orientation, granularity has slowly increased, from fine consistently within the \nUML. A component specification should grained language classes that represented abstractions like hash \nbe the subject of a model that describes the behavior of the component, including its operations, parameters, \nand pre- and post-conditions, in terms of a model of relationships between specification types. No hint \nof any underlying implementation should surface through this abstract specification, and yet the specification \nshould be rigorous enough to permit tool based composition, analysis and meaningful search. Such a specification \nserves as a contract to consumers of the component [18, 6]. With this discipline in place, the stage \nis set for a proper treatment of reuse, and for contracted-out component provisioning in software supply \nchains. Second, CBD asserted that the structure and behavior of an application could be formalized and \nanalyzed in terms of collaborations among components using only the component specifications, independent \nof any potential implementation. A collaboration describes roles played by component specifications in \na sequence of interactions. By grouping collaborations, a complete picture of the design of a set of \ninteracting components can be produced without requiring any information about their underlying component \nimplementations. Collaborations provide a way to discover how functionality should be assigned to a specification, \nand thereby prescribe the behavior required of the implementation. Moreover, collaborations can be parameterized \nwith variability points and systematically reused as design templates. Implementations of component-based \ndesigns can be generated in part and sometimes in whole by progressively refining compositions of collaborations \nusing model-driven development techniques.  3.2 Critical Innovations in Granularity In many ways the \nCBD development techniques from the mid\u00adnineties were ahead of their time. While most of the techniques \nfor component specification and composition were mature, the underlying execution platform technology \nwas not mature enough to support applications based on large-scale built-to-order or ready-built components. \nIn 1997, competing platform technologies included the OMG s CORBA, J2EE and COM technology from Microsoft. \nAlthough each of these platform technologies succeeded in other ways, neither was able to support a component \nmarketplace, or architectures where distributed, large granularity components could interact in a secure, \nefficient manner at scales necessary to support the new application types demanded by business. The emerging \nweb service technology succeeds where they failed. Protocols and platform extensions based on XML and \nSOAP, are becoming available for sophisticated web-delivered applications. They offer key infrastructure \nfeatures, such as transactions, security, asynchronous messaging, routing and reliable, guaranteed-delivery \nmessaging. With broad industry agreement through bodies such as the W3C [27] and WS-I [29], interoperability \nbetween proprietary component implementation platforms is being designed in from the beginning. Web service \ntechnology uses the Web Service Description Language (WSDL) to define web services. A WSDL file is an \nXML file that defines a web service by specifying how it is invoked and what it returns, without describing \nits implementation. It can be advertised in a catalog and used by tools to generate adapters or client \nside code. As such, a WSDL file is the web service equivalent of a component specification, and can be \ngenerated by tools using CBD techniques for component definition, composition and interaction. However, \nthe WSDL specification is missing one critical concept that must be present to allow large scale composition \nof applications from web services. It is not enough to understand how to invoke a web service component. \nFor realistic applications, you also need to know how to perform a sequence of interactions. A web service \ncomponent specification must be explicit about the expected message order, and what happens when unexpected \nconditions arise. The protocol information that governs its interaction must be made explicit in a contract \nthat should form part of the component specification. Given an adequate definition of a contract, collaborations \nbetween web service components can be specified and composed. In many cases it will be possible to assemble \napplications using a process engine, such as Microsoft s BizTalk Server to declaratively define and manage \nthe sequence of messages interchanged by the application components. This kind of assembly is called \norchestration.  4. SPECIFICITY 4.1 Specificity Concerns Scope of Reuse The third dimension is specificity. \nSpecificity defines the scope of an abstraction. To paraphrase Jackson, the value of an abstraction increases \nwith its specificity to some problem domain [19]. More specific abstractions can be used in fewer products \n(i.e., by members of a smaller product family), but contribute more to their development. More general \nabstractions can be used in more products (i.e., by members of a larger product family), but contribute \nless to their development. Higher levels of specificity allow more systematic reuse. Of the three dimensions, \nspecificity is perhaps the most important to software factories. Historically, the software industry \nhas stayed at relatively low levels of specificity, compared with more mature industries, where specialized \nproducts and services are ubiquitous. The economics of software development reflect this tendency, rewarding \ngeneric products that can be used in many applications, but which contribute little to their development. \nThe fact that applications are built primarily by hand shows that reusable components are not available \nfor the vast majority of the features they require. Achieving the levels of reuse required to create \nsignificant economies of scope requires much higher levels of specificity, and a migration from generic \nproducts, such as tools and libraries for general purpose programming languages like Java and C#, to \nspecialized products, such as tools and frameworks for vertical domains like Banking and Insurance. In \norder for this migration to occur, companies with domain knowledge must become producers of reusable \ncomponents that support the development of applications in those domains. This might mean that barriers \nto component development will be lowered, so that domain knowledge holders can develop components in \nhouse, or it might mean that a component outsourcing industry will implement components from specifications \nsupplied by the domain knowledge holders. Both solutions can be seen in other industries. For example, \nin the consumer electronics industry, there are companies that build their own branded components, and \nthere are companies that build components branded by other companies on a contract basis. Of course, \nthis will require the development of new composition mechanisms, since software component assembly requires \nmuch higher levels of adaptation than the assembly of physical components, the standardization of specification \nformats, since software specification is currently quite informal, and much better customer and supplier \nrelationship management, since software development involves much higher levels of iteration. 4.2 Software \nProduct Lines While CBD focuses on the rigorous partitioning and composition of components, and MDD provides \na rigorous framework for abstraction and transformation, both methods are inherently focused on building \none product at a time. What they lack is the realization that most applications are members of families \n[23, 14, 10]. Software product lines are the critical innovation on the specificity axis that capitalizes \non the separation of commonality and variability in product families. Figure 6 describes the main steps \nand deliverables in product line development. Recall that a software product line produces a family of \nsoftware products that are deliberately designed to take advantage of common features and known forms \nof variation. Product line developers build production assets used by the product developers to produce \nfamily members. These include implementation assets, such as architecture and components, used to implement \nthe family members, and process assets, such as a process, which describes the use of the implementation \nassets, and tools, which automate parts of the process. A key step in developing the production assets \nis to produce one or more domain models that describe the common features of problems in the domains \naddressed by the product line, and the ways in which they can vary. These models become detailed descriptions \nof the problem domains. They collectively define the scope of the product line, and can be used to qualify \nprospective family members. Figure 6: Overview of a Software Product Line (adapted from [28]) 5. AN \nEXAMPLE OF SOFTWARE FACTORIES  5.1 Model-driven Product Lines We can now define a software factory as \na model-driven product line a product line automated by metadata captured by models using domain specific \nmodeling languages. We said earlier that software factories generalize the modeling grid for a product \nfamily, defining a graph of viewpoints called a software schema, which describes the information required \nto produce a family member. Since each viewpoint is supported by DSLs, we develop DSL based tools for \nediting the models, and for translating them either into executables, or into specifications at lower \nlevels of abstraction, such as general purpose programming language source code files, or models based \non more concrete DSLs. We then define the process assets for the software factory in terms of this process. \nFinally, we collect these assets into a software template that loads into an Interactive Development \nEnvironment (IDE), such as Microsoft s Visual Studio .NET. When configured in this way, the IDE becomes \na software factory for the product family, as illustrated in Figure 7. In other words, for a software \nfactory, the product line developers build production assets for a specific IDE, and deliver them as \nplug-ins to the IDE. Using the software factory, the product developers can rapidly assemble family \nmembers. Recall that in a product line, the requirements model is used to specify a family member by \nidentifying the feature variations that define it uniquely. In a software factory, selecting feature \nvariations automatically or semi-automatically configures the production assets for the selected family \nmember, including the project structure, imported subsystems and components, available viewpoints and \npatterns, and constraints. For example, imagine that when we select the content personalization feature \nfor an online commerce application, the following things happen: A folder for the personalization subsystem \nis added to the project we re using to build the application.  The personalization subsystem is imported \ninto the project.  The viewpoint used to configure personalization is added to the schema for the application, \ncausing the personalization configuration tool to appear on the menu.  The Front Controller pattern \nis applied automatically in the transformation between the user interaction model and the web front end \ndesign model, and is made available in the designer where we model the web front end design, instead \nof the Page Controller pattern, so that the application will vector to different pages for different \nusers, instead of showing the same content to all users.  We are not allowed to create a class that \nderives from PageController in the folder for the personalization subsystem   Having configured the \nsoftware factory appropriately, the product developers use it to build the family member. They build \nmodels for the viewpoints defined by the software schema, starting with models near the top of the graph, \nand then working theirway down, producing executables usingframeworkcompletion and progressive refinement. \nAt times, theymaywork bottom up, instead of top down, generating test harnessesfor various pieces of \nthe product, and testing the piecesas theywork.When the software schema is completely populated, the \nprocess iscomplete.  5.2 Software Factory Example Figure 5 illustrates a software schemafor a family \nof software products, in this case businessapplications that can be specified as interacting business \nprocesses and business entities, and deployed as collaboratingweb services. Imagine a bank that needs \nto build business applications for rapidly changingfinancial instruments. In Step 3 of Figure 8, the \nproduct line developersat the bank, armed with Software Factory B, build production assetsfor the schema \nshown in Figure 5. These assets comprisea softwaretemplate thatcan be loaded into another instance of \nthe same IDE. Configured in this way, the IDE is now Software Factory C. In Step 4 of Figure 8, the product \ndevelopers at the bank now use this software factory to build businessapplications forrapidly changing \nfinancial instruments. S t ep 3. B S o ft w a r e fa c t o r y u s ed by p r od uc t  P r oc es s Li \nb r ar i e s To o l s l i n e de v e l ope rs  A sse ts F r am ew o r k s t o bu i l d s o f t w a \nr e t e m p l a te A . So f t w a r e P r oc es s Li br ar i e s To o l s te m p l a te B . A sse \nts F r am ew o r k s St e p 4 . C S o f t w a r e fa cto r y  P r oc es s Li b r ar i e s us e d b \ny pr odu c t To o l s dev e l ope rs t o  A sse ts F r am ew o r k s bui l d bus i n e s s app l i \nc a t i on s . Figure 8:Building and Using a Software Factory Ofcourse, instead offairlygeneric production \nassetsfor business applications, Software Factory B could have been used to build more specialized production \nassetsforfinancial services applications, such as implementation assets like risk calculators and forecasting \nengines, and process assets like special project types and wizards for financial application development. \nConfigured with these assets, the IDE would become a software factoryforfinancial applications. Itwould \nbe used again by the product developers at the bank to build business applications for rapidly changingfinancial \ninstruments.This time, however, the DSLs, tools and frameworks attheir disposalwould bemuch more specific \nto the financial services domain. Theywould therefore be more productive using this softwarefactory than \nthey were using the previous one, since more ofeach application would be supplied by theframeworks and \ngenerated from the DSLs by the tools, leaving lesswork to be done by hand. At this point, we should ask \nwhere the product linedevelopersgot Software FactoryB, and why the examples above started out with Step \n3. As it turns out, softwarefactories can be used to produce other softwarefactories. In Step 1 of Figure \n9, an IDE is used to build a languages,frameworks and tools for building software factories.These assets \ncomprise a software template thatcan be   loaded into another instance of the same IDE. Configured \nin this way, the IDE is now Software FactoryA in Step 2. This software factory can be used to build software \nfactories.Wecan think of the IDE as Software FactoryA, although in practice, it is just an extensible \nIDE. This process, called bootstrapping, is standard practice in compiler development. How do supply \nchainsfit into the picture? From what we have said in the preceding paragraphs, we might conclude that \nsoftware factories do not allowmultiplesuppliers to collaborate in the development of the product. Onthe \ncontrary, they promote the formation of supply chains in two ways: Atany level, the schemacan be partitioned \nvertically among multiple suppliers. Thecomponents provided by the suppliersare then assembled at the \nlevel above. Imagine,for example, that the risk calculators and forecastingengines used by the bankcome \nfrom different suppliers, and areassembled by the developers at the bank. A S t e p 1 . IDE us e d \nt o bui l d so f t wa r e te m p l a t e A . So f t w a r e P r oc es s Li br ar i e s To o l s \n te m p l a t e A . A sse ts F r a m ew or k s St e p 2 . B S o ft w a r e fa cto r y  Pr o c e s \ns Li br ar i e s us e d b y pro duc t To o l s l i ne de v e l o p e r s  A sse ts F r a m ew or k \ns t o bu i l d s o f t w a re te m p l a t e B . Figure 9:Building a Software Factory with a Software \nFactory Within any vertical partition, theschemacan also be partitioned horizontallyamong multiple suppliers. \nImagine, for example,that instead ofworkingfor the bank, the product line developerswho created Software \nFactory Bworkfor an Independent Software Vendor. Instead of building softwarefactoriesfor in house developers, \nthey build themfor downstream consumers.They might then, in turn, use less specialized softwarefactories, \nsuch as the original Software Factory B that produced components for building business applications. \nOf course, the two types of partition can appearanywhere in the schema, and can be combined in arbitrary \nways.They canalso disappear and then reappear, asdictated by prevailing business conditions. In a mature \nindustry, wewould seemany levels of suppliers contributing to the completed application, and constant \nchurn in the supply chain, as suppliers enter themarket, consolidate or leave themarketatvarious points. \n 6. CONCLUSION Software Factoriesare the convergence ofkey ideas in software product lines, component-baseddevelopment \nand model-driven development. The innovation liesin integrating these ideas into a cohesiveframework \nthat supports new tools and new practices. Bycombiningmodel-driven and component-based techniques with \nproduct line principles, Software Factories usher in a new application development model, where highly \nextensible development tools are quickly and cheaply configured to create software factories for specific \ndomains. Realization of this vision is the goal of software factories. It will require us to rethink \ntools and methods, languages and frameworks. Of course, some parts of this vision may never be realized. \nHowever, it is commonly said that we frequently over\u00adestimate what can be achieved in five years, and \nunder-estimate what can be achieved in ten. That said, there is already substantial momentum toward the \nrealization of the vision. It is our conviction that key elements will be realized. The evidence of their \nrealization has already started to appear.  7. ACKNOWLEDGEMENTS Special thanks to Krzysztof Czarnecki \nand Paul Clements, who reviewed earlier versions of this material and provided valuable comments. Adapted \nfrom Software Factories: Assembling Applications with Patterns, Models, Frameworks and Tools, by Jack \nGreenfield and Keith Short, Copyright &#38;#169; 2003 by Jack Greenfield, Keith Short. All rights reserved. \nReproduced here by permission of Wiley Publishing, Inc.  8. REFERENCES [1] D. Alur, J. Crupi and D. \nMalks. Core J2EE Patterns, Best Practices and Design Strategies. Sun Microsystems Press, 2001. [2] K. \nBeck. Extreme Programming Explained: Embrace Change. Addison-Wesley, 1999. [3] G. Booch. Object Oriented \nAnalysis and Design With Applications. Second Edition. Addison-Wesley, 1994. [4] F. Brooks. No Silver \nBullet: Essence and Accidents of Software Engineering. Computer Magazine, 1987. [5] C. Christensen. The \nInnovator s Dilemma, Harvard Business School Press, 1997. [6] J. Cheesman and J. Daniels. UML Components: \nA Simple Process for Specifying Component-Based Software. Addison-Wesley, 2000. [7] J. Cleaveland. Program \nGenerators with XML and Java. Prentice Hall PTR, 2001. [8] A. Cockburn. Writing Effective Use Cases, \nAddison Wesley, 2000. [9] S. Cook. The UML Family: Profiles, Prefaces and Packages. Proceedings of UML2000, \nedited by A. Evans, S. Kent and B. Selic. 2000, Springer-Verlag LNCS. [10] P. Clements and L. Northrop. \nSoftware Product Lines: Practices and Patterns. Addison-Wesley, 2001. [11] J. Coplien. Multi-paradigm \ndesign. In Proceedings of the GCSE '99 (co-hosted with the STJA 99). [12] B. Cox. Planning the Software \nIndustrial Revolution. IEEE Software Magazine, November 1990. [13] B. Cox. No Silver Bullet Revisted. \nAmerican Programmer Journal, November 1995 [14] K. Czarnecki and U. Eisenecker, Genererative Programming: \nMethods, Tools, and Applications, Addison-Wesley, 2000. [15] D. D Souza and A. Wills. Objects, Components \nAnd Frameworks With UML. Addison-Wesley, 1998. [16] M. Fowler. Refactoring: Improving The Design Of Existing \nCode. Addison-Wesley, 1999. [17] E. Gamma, R. Helm, R. Johnson and J. Vlissides. Design Patterns, Elements \nof Reusable Object-Oriented Software. 1995, Addison-Wesley. [18] P. Herzum and O. Sims. Business Component \nFactory, A Comprehensive Overview of Component Based Development for the Enterprise. March 2000, John \nWiley and Sons. [19] M. Jackson. Problem Frames: Analyzing and Structuring Software Development Problems. \nAddison Wesley, 2000. [20] R. Johnson. Documenting Frameworks Using Patterns. ACM SIGPLAN Notices, volume \n27, number 10. [21] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. Griswold. An overview \nof AspectJ. In Proceedings of the European Conference on Object-Oriented Programming, 2001. [22] T. Kuhn. \nThe Structure Of Scientific Revolutions. The University Of Chicago Press, 1970. [23] D. Parnas. On the \nDesign and Development of Program Families. IEEE Transactions on Software Engineering, March 1976. [24] \nJ. Greenfield and K. Short. Software Factories: Assembling Applications with Patterns, Frameworks, Models \nand Tools. John Wiley and Sons. 2004. [25] F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, M. Stal. \nPattern-Oriented Software Architecture, Volume 1. A System Of Patterns. John Wiley and Sons, 1996. [26] \nJ. Smith and D. Stotts. Elemental Design Patterns - A Link Between Architecture and Object Semantics. \nProceedings of OOPSLA 2002. [27] Standish Group, Chaos A Recipe for Success, 1999, available online \nat http://www.standishgroup.com/sample_research/ [28] http://www.w3.org/. [29] D.M. Weiss, C.T. Robert \nLai. Software Product-Line Engineering, Addison-Wesley , 1999. [30] http://www.ws-i.org/. \n\t\t\t", "proc_id": "949344", "abstract": "The confluence of component based development, model driven development and software product lines forms an approach to application development based on the concept of software factories. This approach promises greater gains in productivity and predictability than those produced by incremental improvements to the current paradigm of object orientation, which have not kept pace with innovation in platform technology. Software factories promise to make application assembly more cost effective through systematic reuse, enabling the formation of supply chains and opening the door to mass customization.", "authors": [{"name": "Jack Greenfield", "author_profile_id": "81100515255", "affiliation": "Microsoft Corporation, Redmond, WA", "person_id": "P643454", "email_address": "", "orcid_id": ""}, {"name": "Keith Short", "author_profile_id": "81100382105", "affiliation": "Microsoft Corporation, Redmond, WA", "person_id": "PP14135032", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949348", "year": "2003", "article_id": "949348", "conference": "OOPSLA", "title": "Software factories: assembling applications with patterns, models, frameworks and tools", "url": "http://dl.acm.org/citation.cfm?id=949348"}