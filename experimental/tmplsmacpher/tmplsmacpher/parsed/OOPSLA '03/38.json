{"article_publication_date": "10-26-2003", "fulltext": "\n Things They Would Not Teach Me of in College: What Microsoft Developers Learn Later Eric Brechner, \nPh.D. Director, Microsoft Development Training One Microsoft Way Redmond, WA 98052 ericbrec@microsoft.com \nABSTRACT There has always been a gap between what college graduates in any field are taught and what \nthey need to know to work in industry. However, today the gap in computer science has grown into a chasm. \nCurrent college hires who join Microsoft development teams only know a small fraction of their jobs and \ncannot be trusted to write new code until they have received months of in-depth training. The cause of \nthis growing gap is a fundamental shift in the software industry, which now demands higher quality and \ngreater attention to customer needs. This paper presents five new courses to add to computer science \ncurriculums to help close this gap.  Categories and Subject Descriptors K.3.2 [Computers and Education]: \nComputer and Information Science Education computer science education; curriculum. General Terms: Management, \nDocumentation, Design, Reliability, Security, Human Factors, Standardization, Legal Aspects, Verification. \nKeywords: Design, analysis, cohesion, coupling, redundancy, testability, diversity, globalization, accessibility, \nmultidisciplinary, requirements, quality, commercial, coordination, collaboration, contracts, security, \nprivacy, reliability, FMEA, cryptography. 1. INTRODUCTION Is it fair or reasonable to expect developers \ncoming straight out of college to know how to write code for Office or Windows? Microsoft has traditionally \nhired much of its development staff directly from universities and put them right on these kinds of complex \nproducts, which affect millions of people. With the increasingly dramatic impact of malicious code on \nour customers, we are now paying a dear price for less-than-perfect products. Recently, Microsoft has \nfocused far more on training its employees how to write more secure, reliable software that protects \nthe privacy of our customers. Last year, as part of a larger initiative called Trustworthy Computing, \nwe stopped all development on Windows for months to train the entire staff (over eight thousand) on writing \nsecure code, and required them to Copyright is held by the author/owner(s). OOPSLA 03, October 26 30, \n2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. analyze, review, and fix problems throughout \nthe product. But that s not what I want to talk about. The question isn t whether college hires can write \ntrustworthy code, it s whether they can write shippable code at all. In college, students are often taught \na fair number of programming languages, a fair amount of theory, a fair number of application areas, \na wide selection of data types and associated algorithms, a bare sniff of team projects and software \ndesign, and almost nothing about commercial software development. Not that I m complaining. Some of my \nbest friends are college graduates. But it s time that we set our expectations higher. 2. WHAT STUDENTS \nSHOULD KNOW Of course, students can t be expected to know everything straight out of school. You don \nt want new graduates doing a heart transplant any more than you want them writing the software that matches \ndonors to patients. But they should know their way around, understand the roles, and be familiar with \nhow to prevent mistakes and catch them before they become catastrophic. So what are computer science \nstudents missing when they come to Microsoft? Here are five courses I d love to see taught: Design Analysis: \nHow to design and analyze software for strong cohesion, loose coupling, clear focus (simplicity), minimal \nredundancy, and high testability. Embracing Diversity: How to write one piece of code that supports users \nof many nationalities as well as users who can t see or hear. Multidisciplinary Project Teaming: How \nto work with a multidisciplinary team to complete a project that satisfies a customer s imprecise list \nof requirements and expectation of quality, all by a fixed date. Large-Scale Development: How to write \nan integrated piece of a larger project while other students simultaneously write their pieces and be \naccountable for every student s ability to read, modify, and debug each other s code. Quality Code That \nLasts: How to write code that withstands all forms of use, input, and attack without becoming inoperative, \ntaxing system resources, or exposing user s data, while simultaneously recording errors that unskilled \nsupport personnel or users are able to diagnose or report. 3. FIVE SUGGESTED COURSES 3.1 Design Analysis \nThis conference session is all about college courses that teach effective software design. What is often \nmissing from such courses is teaching students how to evaluate designs as they evolve. Many graduates \ncan apply or recite a design pattern; not many can critique an existing work and refactor it to be better. \nIt is ironic that an algorithm analysis course is as much a standard part of most curriculums as the \nassociated fully implemented and reusable algorithms are a standard part of most operating systems. In \ncontrast, design analysis courses are lacking; corresponding to the lack of good design within those \nsame operating systems. We ve already got the algorithms we need better designs.1 3.2 Embracing Diversity \nA course on globalization and accessibility is long overdue on college campuses. It is embarrassing to \ntake graduates from a college with a diverse student population and have to teach them how to write software \nfor a diverse set of customers. This should be part of introductory software development. Anything less \nis insulting to the students, their families, and the peoples of the world. 3.3 Multidisciplinary Project \nTeaming A course focused on a multidisciplinary project with real users, imprecise requirements, and \nreal dates begins to address the difference between college projects and commercial projects. It is based \non the presumption that computers are easy but people are hard. In a typical college project, the requirements \nand expectations are clearly delineated. If the professor were to change these requirements halfway into \nthe project, students would be outraged. If students were forced to depend intrinsically on non\u00adtechnical \npeople for their success, the students would cry, Unfair! If student projects were not judged by professors \nfor technical merit, but instead by non-technical, biased, fickle outsiders, you d probably get complaints \nto the dean. Of course, these are precisely the dynamics of commercial software projects. People who \nyou hope will buy your software never really know what they want until you give it to them. They need \na point of reference. This is, in part, why version one is never quite right. It s why beta copies and \nusability studies are so important. Students don t learn this until they actually receive requirements \nfrom real customers, instead of well-meaning but highly predictable teachers. Commercial software involves \nmore than algorithms. It involves the user interface, online help, button and dialog box labels, money \nand business plans, marketing, and of course, unpredictable users. No programmer will be good at all \nthese things and good at writing solid code. Programmers need to work with others: designers, usability \nengineers, and artists for the user interface, writers for online help and user interface text, planners \nfor thinking through money issues, marketers for selling the result, and employees who think like users \ntesters. 1 I firmly believe that algorithm analysis is important to continue teaching; it s the irony \nthat kills me. Working with people who think fundamentally differently than you is not easy. It also \nisn t easy to keep every member of a diverse team focused on the same goals, or even agreeing on what \nthe details of those goals are. Communication and negotiation are hard, yet essential; yet essentially \nnot taught to programmers who probably took up working with computers to avoid people in the first place. \nThen there s the question of a grade. How d we do? Only the customer can answer that. These are the same \npeople who demanded far more than you could provide, changed their minds several times during the project \n(assuming you bothered to ask), and didn t even like it when you gave them precisely what they said they \nwanted. Yet figuring out what they really need is the very essence of good product design and execution. \nProgrammers must learn to schedule and prioritize across the team clearly and precisely. You won t be \nable to do everything that the customer thought they wanted (you ll be lucky to do a third), and the \nend date can t be delayed to fix bugs or add features because some dates, like Christmas, just don t \nchange. Putting a course together like this would be invaluable. It would give students in different \nmajors an opportunity to interact, teach them strong project and communication skills, help them learn \nabout customers and business, and motivate them to become whole human beings capable of real understanding \nand perspective. But it s not enough. 3.4 Large-Scale Development Requiring students to each write an \nintegrated piece of a larger project while other students simultaneously write their pieces and be accountable \nfor every student s ability to read, modify, and debug each other s code addresses another major gap \nbetween college projects and commercial projects. Coordinating projects is hard, really hard. It s also \nsomething commercial programmers must deal with from day one. First, there s the issue of producing a \ngood, well-factored design for the larger project. Let s assume a design course took care of the design \naspect of the problem (worth reviewing, nonetheless). Next, there need to be clear and stable API definitions \nso that components can work together and be designed to matching specifications. Then you have to coordinate \nschedules, and synchronize, integrate, and stabilize the code base. You also must program each module \nin a way that allows everyone to understand and debug each other s piece. Unfortunately, not everyone \nwants to do things the same way. One person may like to carefully design everything up front and not \nwrite a line of code until he or she is sure that it will work. Another person may prefer to prototype \nand do incremental design. Another may choose to wing it and just start coding immediately. These people \nwill not get along, will not coordinate well, and will push each other out of their comfort zones. At \nMicrosoft, we use informal contracts between groups to clarify assumptions, state requirements and dates, \nset standards, and make explicit what happens when obligations aren t met. In the commercial world, every \nperson is responsible for the success of the whole. If one group fails, others must help fix it or everyone \ngets the big F (rhymes with hired ). Students must learn this lesson early or suffer greatly later. But \nunfortunately, these days even this course isn t enough to close the gap. 3.5 Quality Code That Lasts \nThe last course that I suggest is a relatively new one for most of us writing code that stands the test \nof time. Initially, code just needs to work as advertised. But these days this isn t enough. What if \nyour software was expected to work continuously for five years? Obviously, software must remain operative \nno matter what input it is given through any exposed interface. On a more subtle level, the software \nmust not harm the system or the user in any way, and vice-versa. This level of protection requires tight \ncontrol of all resources and resource failures (memory, disk, CPU, network, bus, and peripherals). And \nfinally, when the software cannot execute as instructed for whatever reason, it must record and report \nthe problem in such a way that the user need not suffer for long. Most college programming projects are \nevaluated by the readability of the code and the program producing a known set of outputs when it is \ngiven a fixed set of inputs. Clearly these requirements fall far short. Students must learn to write \nprograms that filter all input to remain within that fixed valid set. They must ensure that the processing \nof that input never demands, accesses, or exposes resources beyond a specified limit. Students must also \nensure that any resource failures are captured to be either rectified, or recorded and reported. Naturally, \nthis all assumes that the code works in the first place. Microsoft s own research into defects matches \nresearch reported by many other sources. Almost all bugs can be traced back to the failure of adequately \ndoing one of the following five basic things: creating a design document, performing a design review, \nconducting a code review, running a set of unit tests, and performing an automated code analysis (compilers \nand such). Don t leave school without them. Tightly controlling all resources may involve access control \nand cryptography to protect privacy and privilege. It may involve carefully scrutinizing requests to \navoid hidden scripting or deceptive URLs. It will likely mean that all buffers must be checked, all assumptions \nverified, and that all failure paths lead to freeing resources, closing access points, and returning \nto a secure state. Howard and LeBlanc [1] have a wonderful book on this subject. In general, handling \nfailures is a tricky business. At Microsoft, many groups are turning to Failure Mode and Effects Analysis \n[2] to methodically discover all failures and to plan recovery or reporting strategies for each. Almost \nevery team uses Microsoft Error Reporting [3] to record all failures on Windows XP and Office XP regardless \nof their source. The reports are cataloged by failure area and contain basic information such as a stack \ndump and hardware configuration. Teams can then search for reports on their feature area and fix trouble \nspots. Treating software programming as a true engineering discipline with high expectations of quality \nand low rates of failure is a tall order. Certain groups working on critical embedded software have done \nthis for years, but most commercial software companies haven t been held to such a high standard until \nrecently. College graduates with these skills will be in high demand; graduates without these skills \nwill be left behind.  4. CONCLUSION Five new courses is a great deal to ask (There are actually four, \nbecause globalization and accessibility should be part of any course on introductory programming). Because \nsoftware is our life s blood, we at Microsoft can t afford to wait. We train all our new developers on \nthese concepts and review their performance based on how effectively they apply these skills. It is quite \na culture shock, but it shouldn t be. If your goal as an educator is to prepare your students for a professional \ncareer and you leave out basic skills, you ve failed. Computer programming isn t just a nice mental exercise \nand clever tool anymore. People s lives and businesses depend on it. Telling programmers that it s just \nbetween them and the computer is a lie. It leaves out almost half of what programmers do working with \nother people. Telling programmers that it s all about algorithms is a lie. It leaves out everything that \nkeeps systems running and customers happy. I m told that universities can be as competitive as businesses \nfor students and funding. Want an advantage? Want to be cutting edge? Then give your students an advantage \nin the workplace. Make them more desirable hires and more effective employees. You ll have more fun in \nthe process with these great, challenging projects. After all, people are not just harder than computers, \nthey re more interesting too. 5. ACKNOWLEDGEMENTS The author would like to thank Asoke Bhattacharyya \nfor inviting this paper, Susan Fairo for her editing assistance, and Clemens Szyperski and Dan Fay for \nharassing me until I agreed to do it. 6. REFERENCES [1] Howard, Michael and David LeBlanc. Writing Secure \nCode (Second Edition). Microsoft Press, 2003. [2] McDermott, Robin E., et al. The Basics of FMEA. Productivity \nInc., 1996. [3] Microsoft Corporation. Find Solutions to Office XP Errors with Microsoft Error Reports. \nhttp://office.microsoft.com/assistance/2002/articles/oErrorR eport.aspx. Microsoft Corporation, 2003. \n \n\t\t\t", "proc_id": "949344", "abstract": "There has always been a gap between what college graduates in any field are taught and what they need to know to work in industry. However, today the gap in computer science has grown into a chasm. Current college hires who join Microsoft development teams only know a small fraction of their jobs and cannot be trusted to write new code until they have received months of in-depth training. The cause of this growing gap is a fundamental shift in the software industry, which now demands higher quality and greater attention to customer needs. This paper presents five new courses to add to computer science curriculums to help close this gap.", "authors": [{"name": "Eric Brechner", "author_profile_id": "81100311581", "affiliation": "Microsoft Corporation, Redmond, WA", "person_id": "P643443", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949387", "year": "2003", "article_id": "949387", "conference": "OOPSLA", "title": "Things they would not teach me of in college: what Microsoft developers learn later", "url": "http://dl.acm.org/citation.cfm?id=949387"}