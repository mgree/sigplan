{"article_publication_date": "10-26-2003", "fulltext": "\n Program Manipulation via Interactive Transformations Marat Boshernitsan University of California at \nBerkeley Computer Science Division, EECS Berkeley, CA 94720-1776 +1 510 642 4611 maratb@cs.berkeley.edu \nABSTRACT Systematic large-scale modification of source code is tedious and error-prone, because developers \nuse authoring and editing tools poorly suited to the program maintenance task. We combine the results \nfrom psychology of programming, software visualization, program analysis, and program transformation \nfields to create a novel environment that lets the programmers express operations on program source code \nat a level above text-oriented editing.  Categories and Subject Descriptors D.2.6 [Software Engineering]: \nProgramming Environments integrated environments, interactive environments.  General Terms Design, Human \nFactors, Languages. Keywords Interactive Environments, Programming Psychology. 1. INTRODUCTION Software \nartifacts are bound to change. Be it due to design changes, bug fixes, or addition of new features, the \nprocess of modifying software source code is often tedious and error-prone. The change process is complicated \nbecause many changes entail pervasive large-scale modifications to an existing body of source code. Examples \nabound in the many maintenance tasks faced by developers during the lifetime of a typical software project. \nFor instance, simply adding an argument to a procedure requires visiting every invocation site and supplying \nthe missing value. Another example, observed by the aspect-oriented programming researchers, involves \ndelocalized design abstractions such as exception handling, logging, synchronization, and others. Capturing \nthese design abstractions at the source code level is difficult due to limited data and procedural abstractions \nprovided by most programming languages. As trivial a modification as changing which exceptions are handled \nfollowing the call to a library routine requires finding all such calls and modifying the exception handlers. \nYet another flavor of high-level operations is the generative operations that produce chunks of boilerplate \ncode. Outputting fields of a data structure is an example of such an operation. If the list of fields \nis large and may change over the lifetime of the program, maintaining the output routine manually is \na tedious and boring task. Copyright is held by the author/owner(s). OOPSLA 03, October 26 30, 2003, \nAnaheim, California, USA. ACM 1-58113-751-6/03/0010. Various proposals have been made for systematic \nmodification to existing source code. However, few tools have found their way to the programming trenches. \nOur research attacks several major issues with prior approaches: generality, acceptance by the user community, \nimproved abstraction management, and proliferation of proprietary programming language extensions (such \nas those used in aspect-oriented programming). We believe that the problem stems from the fact that developers \nuse authoring and editing tools poorly suited to the program maintenance task. Most such tools provide \ntext-based interaction with minimal syntax knowledge and very little structural or high\u00adlevel language \nawareness. The use of such tools has significant limitations. On the one hand, developers utilize high-level \nlinguistic structure and programming language semantics when thinking about and discussing software artifacts. \nOn the other hand, the developers are forced to interact with computing systems to create and modify \nsoftware artifacts using low-level text editors and representations designed for compiler input. Our \nhypothesis is that enabling the programmers to express operations on program source code at a level above \ntext-oriented editing will improve programmer's efficiency and result in fewer errors. 2. INTERACTIVE \nTRANSFORMATIONS When describing their changes to one another, programmers evoke notions such as variables, \nexpressions, statements, loops, and assignments. They also directly refer to names found in source code. \nThese concepts represent the common terminology understood by programmers, making the use of those terms \nnatural for describing actions at a high level. Such descriptions can provide a user-friendly notation \nfor expressing source code manipulations using high-level update scripts . The scripts might be executed \ninteractively; they might be stored in a library or a catalog, or they might serve as update agents bound \nto program components. A sample update script might look like: foreach statement like f(@args@) replace \nwith f($args, true) This script describes an update following the addition of a new argument to function \nf. Another update script of a more generative flavor might be something like: generate method Node.mem_size() \nas int mem_size() { int result = 0; foreach field f of class Node emit result += $f.mem_size(); return \nresult; } This script acts as an update agent that describes how to generate a method. The generated \nmethod will be updated each time a field is added or removed in the class Node. The examples use a scripting \nlanguage that embeds both instances and abstractions from the user s source code. This scripting language \nis merely a sample; the actual language to be used must be carefully designed and is part of our research. \nThe scripting language must be expressive; that is, it must provide access to the syntactic and semantic \nstructure of source code. At the same time, the underlying program representation must not be exposed \nto end-users of the transformation tool, as it will hamper their ability to formulate transformations. \nTo design an appropriate notation, we turn to the field of the psychology of programming, which includes \nvarious hypotheses on how programmers construct mental models of programs that they manipulate [3]. However, \nthe existing studies are largely concerned with acquiring higher-level schematic knowledge and constructing \ndomain models. We are conducting a series of experiments to learn how expert programmers formulate update \nplans for Java programs and what forms these plans take. These studies will both contribute to the existing \nbody of research on psychology of programming and allow us to develop a methodology for working with \nlanguages other than Java. Along with the scripting language we are designing an interactive environment \nfor manipulating and executing update scripts. This environment will enable the programmer to visualize \nexecution of the script, examine each transformation site, selectively undo or modify individual transformations, \netc. The environment will also capture the source code change history in terms of high-level manipulations. \nSuch a capability will help to document important aspects of program evolution, as well as support selective \nrollback of high-level changes long after they had been performed. The environment will augment the scripting \nlanguage with direct manipulation. We believe that the scripting language will provide the right high-level \nvernacular for describing code, and we expect professional developers to have no trouble specifying the \ncontrol structure of pattern matching and transformations in a textual notation. At the same time, we \nintend to provide a by-example pattern matching mechanism, whereby the user selects language constructs \nthat look like the intended match. The pattern can be subsequently abstracted to match a larger class \nof code fragments. An important advantage of using an integrated environment for transforming source \ncode is the ability to treat the update scripts as abstractions. This permits naming scripts, storing \nthem in a library for reuse, and treating scripts as update agents. An update agent is a metaprogram \nbound to both the source and the target (generated) program elements. An integrated environment can track \ndependencies between the two sections of source code and act appropriately if the developer makes changes \nto either. 3. RELATED WORK A number of key issues differentiate existing systems for source\u00adto-source \ntransformations, metaprogramming, and source code refactoring from the kind of support for interactive \nprogram manipulation that we envision. A broad class of tools allows the developer to specify transformations \nin a general-purpose notation. Such tools range from the primitive text processing tools, such as the \nUnix sed, to the tools that operate on the lexical structure of the program (for example, LSME [7]), \nto the full featured program transformation tools that operate on annotated syntax trees (for example, \nASTLog [2]). However, text- and lexeme-oriented tools are not sufficiently expressive, whereas tree-based \ntools are not useful to anyone unfamiliar with a tree-based program representation. Furthermore, such \ntools do not include a facility for evaluating or visualizing pattern matching or selectively reversing \nor modifying transformations, thereby impeding high-level interactive operations. Metaprogramming tools \nform another class of transformation systems (AspectJ [6] is a good representative). Such tools are designed \nfor compiler-like use, inhibiting further manipulation of the result of the transformation. Moreover, \nthese tools work by extending the underlying programming language, limiting their applicability and deterring \ntheir acceptance by the industry. Many interactive development environments offer facilities for performing \nrefactoring transformations, such as those catalogued by Fowler [5]. However, many refactoring transformations \ncannot be generalized to arbitrary contexts, and, therefore, cannot be automated (for example, moving \na non-static method between two unrelated classes). 4. EVALUATION Our interactive transformation environment \nis being prototyped on the Eclipse platform [4], an open-source framework for building interactive development \ntools. Implementing general source-to-source transformation facilities requires a solid program analysis \ninfrastructure. Such infrastructure is not available in the Eclipse platform and will be contributed \nto Eclipse through integration with the Harmonia program analysis framework [1]. Our prototype will be \nevaluated against several criteria, including current mechanisms for manipulating source code in an interactive \nsetting, usability studies of the resulting prototype, and the outcome of deploying our Eclipse-based \nimplementation. The system will be instrumented to collect information about how it is used. We will \nstudy users carrying out a fixed set of modification tasks with and without our tools, and will compare \nsuch factors as modification time, user-perceived ease or difficulty of the task, and quality of the \nresulting transformations. 5. REFERENCES [1] Boshernitsan, M. HARMONIA: A Flexible Framework for Constructing \nInteractive Language-Based Programming Tools. Technical Report. University of California, Berkeley. UCB/CSD-01-1149, \n2001. [2] Crew, R.F. ASTLOG: A language for examining abstract syntax trees. In proceedings of the First \nConference on Domain Specific Languages, 1997, p. 229 242. [3] Detienne, F. Software Design: Cognitive \nAspects, Springer Verlag, 2001. [4] Eclipse Consortium. http://eclipse.org/ [5] Fowler, Martin. Refactoring: \nImproving the Design of Existing Code, Addison Wesley. 1999. [6] Kiczales, Gregor, et. al., Aspect-Oriented \nProgramming. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP). Springer-Verlag \nLNCS 1241. 1997. [7] Murphy, G.C. and Notkin D. Lightweight source model extraction. Proceedings of the \n3rd ACM Symposium on the Foundations of Software Engineering, 1995.  \n\t\t\t", "proc_id": "949344", "abstract": "Systematic large-scale modification of source code is tedious and error-prone, because developers use authoring and editing tools poorly suited to the program maintenance task. We combine the results from psychology of programming, software visualization, program analysis, and program transformation fields to create a novel environment that lets the programmers express operations on program source code at a level above text-oriented editing.", "authors": [{"name": "Marat Boshernitsan", "author_profile_id": "81100402373", "affiliation": "University of California at Berkeley, Berkeley, CA", "person_id": "P551567", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949451", "year": "2003", "article_id": "949451", "conference": "OOPSLA", "title": "Program manipulation via interactive transformations", "url": "http://dl.acm.org/citation.cfm?id=949451"}