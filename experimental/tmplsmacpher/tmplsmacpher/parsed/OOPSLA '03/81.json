{"article_publication_date": "10-26-2003", "fulltext": "\n An AspectJ-Enabled Eclipse Core Runtime Platform Martin Lippert Software Engineering Group, Faculty \nof Computer Science University of Hamburg Vogt-K\u00f6lln-Stra\u00dfe 30 22527 Hamburg, Germany ++4940 42883 2306 \nlippert@acm.org  ABSTRACT Separation of concerns and modularity are key elements of software engineering. \nThe work described here presents a combination of two proven techniques that help improve both of these \nelements: the Eclipse Core Runtime Platform, which introduces plugins to Java programming as a kind of \nmodule concept on top of packages, and aspect-oriented programming using AspectJ, which aims to improve \nthe modularity of crosscutting concerns. The work presents a combination of these two technologies in \nan AspectJ-enabled version of the Eclipse Core Runtime Platform. Unlike the standard implementation of \nthe Eclipse Core Runtime Platform, the AspectJ-enabled implementation allows aspects to modularize crosscutting \nconcerns beyond the boundaries of plugins (without the need for recompilation across plugins). It allows \ncrosscutting concerns to be modularized by means of aspects and plugins while using the enhanced but \ncompatible version of the Eclipse Core Runtime Platform as promoted by the Eclipse project. Categories \nand Subject Descriptors D.1 [Software]: Programming Techniques Aspect-Oriented Programming. D.3.2 [Programming \nLanguages]: Language Classifications AspectJ. D.3.3 [Programming Languages]: Language Constructs and \nFeatures modules and packages, classes, aspects General Terms Design, Languages Keywords Eclipse, \nplugin runtime infrastructure, aspect-oriented programming, AspectJ, cross-plugin pointcuts, modularization \n1. INTRODUCTION Many approaches to software engineering aim to improve separation of concerns and modularity \n[6], [7]. This work focuses on two promising approaches that are implemented for Java: the Eclipse Core \nRuntime Platform, which provides a plugin mechanism for Java [3], and aspect-oriented programming via \nAspectJ, which is designed to modularize crosscutting concerns Copyright is held by the author/owner(s). \nOOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. [2], [4], [5], \n[1]. While these two approaches seem to be orthogonal to each other, their combination would appear to \nbe powerful. But what happens if we try to combine these two approaches? What if we want to develop large \napplications on top of the Eclipse Core Runtime Platform using the Java dialect AspectJ? What, for example, \nif we want to develop the Eclipse system itself using the aspect-oriented programming features of AspectJ? \nTypically applications developed using AspectJ have to be completely compiled or woven via the AspectJ \ncompiler. The AspectJ compiler takes the parts of the system (libraries, sources and classes) and produces \na complete woven system. This basic assumption breaks with the modularization approach used via plugins. \nWhen we develop plugins, the compiler typically knows all the source code of the plugin itself and the \nbytecode of the required plugins and no more than that. As a result, aspects could only define pointcuts \nthat are completely inside a single plugin (they can define more, but the weaving functionality of the \naspect compiler will find only those targets of the pointcut that are inside the plugin where the aspect \nis defined). This is not enough. We would like to be able to define pointcuts that are beyond the boundaries \nof plugins. This would allow us to use Eclipse as a rich-client platform together with AspectJ. The goal \nis to allow developers to design aspects for pointcuts that may crosscut plugin boundaries (like object \nboundaries) and let them modularize and implement those aspects into their own plugins. 2. AN ASPECT-ENABLED \nECLIPSE CORE RUNTIME PLATFORM An AspectJ-enabled Eclipse Core Runtime that integrates load\u00adtime weaving \ncan solve the problem. The basic idea of load-time weaving of aspects is to let the aspect be woven into \nclasses at the time the classes are loaded into the VM (in the case of Java). This is typically done \nvia customized class loaders. These load the bytecode of the class to be loaded out of the .class file \nand weave the aspect hooks and calls into this bytecode. The woven bytecode is subsequently given to \nthe VM for actual definition of the class. Although load-time weaving functionality was not available \nfor the AspectJ 1.0 language, the bytecode weaving implementation of AspectJ 1.1 allows load-time weaving \nto be realized for the complete AspectJ 1.1 language. A weaving class loader could be implemented by \nsimply using the second part of the AspectJ compiler implementation, where the weaving is done at bytecode \nlevel. 2.1 A Weaving Runtime In contrast to the common way of enhancing the Eclipse system via additional \nplugins, the runtime architecture of Eclipse cannot, unfortunately, be AspectJ-enabled by an additional \nplugin. The reason for this is that the load-time weaving has to be injected at class-loading time, which \nis not designed to be modified or enhanced via plugins in the Eclipse system. Thus the idea of an AspectJ-enabled \nEclipse Core Runtime is based on modified versions of the basic core plugins of Eclipse instead of additional \nplugins. 2.1.1 Load-Time Bytecode Modification For Eclipse One way to introduce the weaving functionality \ninto the Eclipse system is to insert a basic load-time bytecode modification hook at the classloading \nmechanism of Eclipse. This hook allows us to inject the weaving functionality exactly where the bytecode \nof a class is loaded without greatly modifying the class loaders of Eclipse. 2.1.2 Inserting AspectJ \nBytecode Weaving The load-time bytecode modification hook provided by the modified runtime can be used \nby a plugin to insert the bytecode weaving functionality of AspectJ 1.1. This plugin just weaves class \nper class as they are loaded into the system. Therefore the plugin needs to know all aspects plugged \ninto the system at each startup. How could this be achieved? 2.1.3 The Aspect Extension Point A neat \nway of promoting aspects at startup time is to use the general Eclipse mechanism of Extension and Extension \nPoint for this purpose. While the mechanism is used by the Eclipse system to let plugins add parts (extensions) \nto the system at predefined points (extension points), it is already used by the core runtime to determine \nwhich applications are available (via the extension point org.eclipse.core.runtime.applications). We \ncan introduce a new extension point called aspects that lets other plugins define, in their plugin.xml \ndescription, the aspects they want to promote for weaving.  2.2 Summary We have discussed the basic \nintegration of a load-time aspect weaving functionality into the Eclipse Core Runtime Platform. We presented \nan approach enabling the basic weaving functionality of AspectJ 1.1 to be used to implement this. All \nof this is implemented and working for the current version of Eclipse (2.1) and AspectJ (1.1). The modified \nruntime is fully compatible with the original implementation in a way that the complete Eclipse platform \nincluding the Java IDE is working on top of it without any adaptations. So far, the static view of the \nsystem is complete. Aspects were woven into classes that are loaded by the Eclipse system. Apart from \nthe static view of the system, the runtime behavior of the Eclipse plugin infrastructure plays an important \nrole when aspects are defined inside plugins and should be woven into classes of other plugins. The AspectJ \nload-time weaving plugin can take care of these issues and ensure that the dynamic dependencies between \nload-time woven plugin code inside different plugins is mapped onto the general plugin dependency mechanisms \nof Eclipse.  3. ACKNOWLEDGMENTS I wish to thank Jim Hugunin and Wes Isberg of the AspectJ project for \ntheir help in implementing the weaving class loader and improving weaving performance. My special thanks \ngo to Axel Schmolitzky for his comments on earlier drafts of this work. 4. REFERENCES [1] AOSD Web Site. \nhttp://www.aosd.net/. [2] AspectJ Team. AspectJ home page. http://www.eclipse.org/aspectj/. [3] Eclipse \nProject. http://www.eclipse.org/eclipse/. [4] G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, C. V. \nLopes, J. Longtier, J. Irwan. Aspect-Oriented Programming. In Proceedings of ECOOP 97, Springer-Verlag \nLNCS 1241, June 1997. [5] G. Kiczales, E.Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. Griswold. \nAn Overview of AspectJ. In J. Knudsen, editor, European Conference on Object-Oriented Programming, Budapest, \n2001. Springer-Verlag. [6] D. L. Parnas. Information Distribution Aspects of Design Methodology. IFIP \nCongress Preprints. 1971. [7] D. L. Parnas. On the criteria to be used in decomposing systems into modules. \nIn Communications of the ACM, volume 15, pages 1053-1058, 1972.  \n\t\t\t", "proc_id": "949344", "abstract": "Separation of concerns and modularity are key elements of software engineering. The work described here presents a combination of two proven techniques that help improve both of these elements: the Eclipse Core Runtime Platform, which introduces plugins to Java programming as a kind of module concept on top of packages, and aspect-oriented programming using AspectJ, which aims to improve the modularity of crosscutting concerns. The work presents a combination of these two technologies in an AspectJ-enabled version of the Eclipse Core Runtime Platform. Unlike the standard implementation of the Eclipse Core Runtime Platform, the AspectJ-enabled implementation allows aspects to modularize crosscutting concerns beyond the boundaries of plugins (without the need for recompilation across plugins). It allows crosscutting concerns to be modularized by means of aspects and plugins while using the enhanced but compatible version of the Eclipse Core Runtime Platform as promoted by the Eclipse project.", "authors": [{"name": "Martin Lippert", "author_profile_id": "81100519018", "affiliation": "University of Hamburg, Hamburg, Germany", "person_id": "PP31045868", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949433", "year": "2003", "article_id": "949433", "conference": "OOPSLA", "title": "An AspectJ-enabled eclipse core runtime platform", "url": "http://dl.acm.org/citation.cfm?id=949433"}