{"article_publication_date": "10-26-2003", "fulltext": "\n Issues on Building T++, a Tool for Web Application Development with C++ Antonio Soares de Azevedo \nTerceiro terceiro@im.ufba.br Departamento de Ci encia da Computac\u00b8ao. Instituto de Matem\u00b4atica Universidade \nFederal da Bahia. Campus de Ondina Av. Ademar de Barros, Ondina 40170-110. Salvador, Bahia, Brazil \n ABSTRACT As the demand for web applications grows, so does the demand for tools that support them. \nAs a general rule, such tools extend gen\u00aderal purpose programming languages, like Servlets/JSP [2] does \nfor Java [4], or de.ne their own programming language, like PHP [3]. But there is no established engine \nfor web applications written with C++. This work presents technical challenges that were faced when developing \nT++, an engine that supports web application develop\u00adment with C++.  Categories and Subject Descriptors \n D.3.3 [Programming Languages]: Language Constructs and Fea\u00adtures Frameworks, Polymorphism, Concurrent \nprogramming struc\u00adtures, Classe sand objects General Terms Design, Languages Keywords Web Application \nDevelopment, C++, Object Orientation 1. INTRODUCTION The demand for web applications is getting more \nand more in\u00adtense. They require less resources from clients, since business logic resides in application \nservers. This characteristic also facilitates ap\u00adplication upgrades: they can be done simply by replacing \nthe code that resides in the application server. Two kinds of tools have been used for web application \ndevelop\u00adment: programming languages designed speci.cally for web appli\u00adcations, like PHP [3]; and extensions \nof general purpose program\u00adming languages, like Servlets/JSP [2], a Java [4] extension. The latter general \npurpose programming language extensions can be used to port applications originally designed for desktop \nsystems to the web environment. The C++ language [9] has been used in the development of many types of \napplications, from simple tools to complex information systems, including scienti.c and industrial applications. \nHowever, up until now, there is no established engine for web application de\u00advelopment in C++. The lack \nof such a tool complicates the devel\u00adopment of new C++ applications for the web environment; more\u00adover, \nit hampers the deployment of a solid bulk of C++ applications on the web. This work brie.y presents T++, \nan engine designed for running web applications written in C++. T++ comprises two parts: Figure 1: The \nprocessing of a request to a T++ document a programming language that works as an interface for web appli\u00adcation \ndevelopment in C++, and an execution engine. In the present work we focus on the execution engine implementation, \nwhile as\u00adpects related to the programming language interface are detailed in [5]. Specially, we discuss \nsome challenging issues regarding object-oriented implementation in C++, that have been subject of research \nduring T++ development. 2. TOOL DESCRIPTION T++ is a tool for web application development in C++. It \nis free software, licensed under the GNU General Public License [1]. T++ comprises a programming language \nand an execution engine. Run\u00adning T++ requires a GNU/Linux system, an Apache web server, and GNU Compiler \nCollection (gcc) with support to C++. Figure 1 shows a high-level representation of the behavior of a \nT++ application. From the users point of view, T++ documents are ordinary ones and are available for \nusers request through their web browsers (1). Users send HTTP requests, and receive arbitrary content \nas result. The web server forwards the request to the T++ engine (2). The T++ engine, then, maps the \nrequested document to an object in memory (3). If it is is necessary, this object is (re)built (4) before \nit is used to process the request (5). Finally, output generated by this object (6), often in HTML format, \nis sent back to the user (7). The T++ programming language supports writing T++ docu\u00adments, mixing up \nstatic content -often HTML code and C++ statements and expressions. C++ code is embedded in special \nlan\u00adguage blocks, surrounded by special delimiters. There are blocks for code execution, expression evaluation \nand others. 3. TECHNICAL ASPECTS C++ code is compiled into native code, unlike other languages commonly \nused for web application development. Java, for in- Copyright is held by the author/owner. stance, is \ncompiled into intermediate code, while PHP is purely OOPSLA 03, October 26 30, 2003, Anaheim, California, \nUSA. ACM 1-58113-751-6/03/0010. interpreted (but there are optional features for caching precompiled \nintermediate code). Restrictions related to working with native code, and the absence of a virtual machine \nto support portability raise several issues that must be handled when developing a tool like T++. In \nthe next sub\u00adsections, we discuss some important issues and describe the pro\u00adposed solutions to deal \nwith them. 3.1 Automatic C++ source code generation and compilation The objects shown in .gure 1 are \ndynamically created, based on T++ documents that contain static content (usually HTML code), C++ statements, \nand other types of C++ code (classes, methods, and preprocessor directive declarations, for example). \nTheir trans\u00adlation mixes both a template skeleton and the content read from the source document, creating \na class that represents the T++ doc\u00adument. The generated class extends an abstract Pageclass, which pro\u00advides \nthe standard interface for T++ documents. The translated content generates the body of a method called \nservice() in the tar\u00adget class, for answering users requests. After the class is generated, it is compiled \ninto a shared library (.soin UNIX systems), which will contain the class de.nition and other resources \nrequired for dynamic loading. 3.2 Dynamic class loading T++ needs a dynamic loading mechanism, because \nusers can change document source code after T++ and web server are al\u00adready running, and restarting web \nserver at each document update is a very bad idea. In this case, the class has to be generated once again, \nrecompiled, and reloaded in order to make the objects in memory correspond to the code in source documents. \nSince C++ is compiled, dynamic loading of classes is not as easy to implement as it could be in interpreted \nor even semi-interpreted programming languages. T++ dynamic loading mechanism is based on a technique \nfor dy\u00adnamic class loading in C++ proposed by Norton [8]. This technique is presented below. Each class \nis compiled into its own shared library. Native library calls are used to load object code from the shared \nlibrary .le and to get pointers to named symbols inside the module loaded. In order to process the request \nfor a document, T++ needs to get an instance of the corresponding class, de.ned in the shared library. \nHowever, the only available information is that such class is a subclass of the Page class. Furthermore, \nit is not possible to refer to types at runtime in C++. These restrictions lead to the following implementation: \n.The generated class extends the Pageclass, that de.nes the standard interface that all document classes \nmust conform to. .The generated source .le has a public function, with a prede\u00ad.ned name, let us say, \ngetInstance(), that returns a pointer to an instance of the class, implementing the Singleton design \npattern.  .After loading the library, the dynamic loading mechanism gets a pointer to getInstance(), \nand calls the function. The returned pointer is then used to forward the request to the object it points \nto. 3.3 Shared memory allocation Web servers are designed to be robust and scalable, since they can \nhost applications used by hundred, or even thousands of users. To achieve these requirements, web servers \nare by nature multipro\u00adgrammed: the main web server has several child processes that deal with users \nrequests. Document instances must be shared between all server s subpro\u00adcesses, so that all users will \nbe served by the same instance of the class corresponding to the requested document. Another reason for \nsharing unique instances between subprocesses, is that application programmers may wish to keep information \nbetween successive re\u00adquests for some document in the document s object internal state. These requirements \nwould pose unnecessary additional complexity if there were several instances of each document in memory. \nTo implement such functionality, we must: .Provide a shared memory allocation mechanism, and some means \nto instantiate objects in shared memory. .Provide a synchronization mechanism, since there will be a \nlot of race conditions using unique instances, specially if they keep internal state between requests. \n .Provide a programming library for using shared memory, like shared memory versions of C++ containers \nand shared mem\u00adory allocation operations.  An interesting approach for memory management was proposed \nby Meyers [7], using memory heaps and overloading C++ s new and deleteoperators. A technique that can \nbe used for attaching this approach to C++ standard template library containers, rede.n\u00ading their memory \nallocation strategy, was described by Austern [6]. In T++, the shared memory allocation problem is solved \nby com\u00adbining these two techniques, wrapping shared memory allocation with memory heaps and de.ning C++ \nallocators that are used when collections of objects are needed.  4. CONCLUSIONS T++ is a tool that \nhelps web application development, either for creating new applications from scratch, or for reusing \nexisting C++ source code for providing a web interface for existing, con\u00adventional, applications. T++ \nrepresents an important contribution, since, as far as we know, there is no established engine for web \napplication development in C++. The reported design and implementation issues are interesting by themselves, \nand putting them to work together has been really chal\u00adlenging. The resulting knowledge will certainly \nbene.t the design of other types of applications that have some requirements in com\u00admon with a web application \nserver mechanism, like on demand plu\u00adgin loading mechanisms, component architectures with dynamic component \nloading, memory sharing components, among others. Further information about T++ can be found at [5]. \n 5. REFERENCES [1] The GNU general public license. http://www.gnu.org/licenses/gpl.html. [2] Javaserver \npages technology. http://java.sun.com/products/jsp. [3] PHP Hypertext Preprocessor. http://www.php.net. \n[4] The source for Java technology. http://java.sun.com. [5] T++ website. http://tplusplus.sourceforge.net. \n[6] M. Austern. What are Allocators good for? The C/C++ Users Journal, Dec. 2002. [7] N. C. Mayers. Memory \nmanagement in C++. C++ report, July 1993. [8] J. Norton. Dynamic class loading for C++ on Linux. Linux \nJournal, May 2000. [9] B. Stroustrup. The C++ programming language. http://www.research.att.com/ bs/C++.html. \n  \n\t\t\t", "proc_id": "949344", "abstract": "As the demand for web applications grows, so does the demand for tools that support them. As a general rule, such tools extend general purpose programming languages, like Servlets/Jsp[2] does for Java [4], or define their own programming language, like PHP[3]. But there is no established engine for web applications written with C++. This work presents technical challenges that were faced when developing T++, an engine that supports web application development with C++.", "authors": [{"name": "Antonio Soares de Azevedo Terceiro", "author_profile_id": "81100025484", "affiliation": "Universidade Federal da Bahia, Salvador, Bahia, Brazil", "person_id": "P643426", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949452", "year": "2003", "article_id": "949452", "conference": "OOPSLA", "title": "Issues on building T++, a tool for web application development with C++", "url": "http://dl.acm.org/citation.cfm?id=949452"}