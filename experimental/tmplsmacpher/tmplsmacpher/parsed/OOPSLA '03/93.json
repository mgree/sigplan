{"article_publication_date": "10-26-2003", "fulltext": "\n A High-level View of Java Applications Eric Bodden Computing Laboratory University of Kent Canterbury, \nKent, CT2 7NF, UK eric@bodden.de ABSTRACT Static analysis of object-oriented applications has become \nwidespread over the last decade, mainly in the context of compile-time optimizations. The paper describes \nhow static analysis of virtual method calls can be employed to provide a high-level view of Java applications. \nThe result is a method call graph that can be built from either source or bytecode, and a graphical browser \nthat enables the user to analyze con\u00adtrol .ow and the coupling between classes and packages in an intuitive \nfashion, thereby supporting application design as well as refactoring and debugging. In order to achieve \nthe necessary bijection between source and bytecode repre\u00adsentations of classes, we implement a new approach \nbased on source code pre-processing. Categories and Subject Descriptors D.3.2 [PROGRAMMING LANGUAGES]: \nLanguage Classi.cations Object-oriented languages General Terms Design, Languages, Human Factors Keywords \nStatic analysis, call graph visualization, Java 1. THE GOAL Object-oriented programming, combining inheritance \nand polymorphism, provides a powerful means of describing the world. Although object-oriented programming \ncan produce reusable, modular, well structured code, program develop\u00adment and maintenance is still hard, \nespecially for systems that consist of many objects interacting in complex ways. Our goal is to provide \nprogrammers with a tool to allow exploration, at a high level, of the relationships between ob\u00adjects \nused in their program. Such a view should reveal the Copyright is held by the author/owner. OOPSLA 03, \nOctober 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. class Library { void newItem(boolean \nisBook, String title) { LibItem item; if (isBook) item = new Book(); else item = new DVD(); item.setTitle(title); \n... } } Figure 1: The need for virtual method calls. void aMethod() { LibItem item = new Book(); LibItem \notherItem = new DVD(); otherItem.setTitle(...); } Figure 2: More precise type analysis is possible. caller/callee \nrelationships between all methods1 in a Java application. Once this relationship is established, one \ncan examine how methods interact. The view should be intu\u00aditive, and should allow the programmer to explore \nthese re\u00adlationships in order to understand the consequences of a change to one class on this and other \nclasses. The mathematical entity for such a relation is a directed graph, here called a method call graph; \nit may be cyclic in the case of direct or indirect recursion. The graph com\u00adprises nodes representing \nmethods, and edges representing method calls. In order to build such a call graph, we need to determine \nmethod call sites and those methods that may be called at each such site. 2. DYNAMIC DISPATCH Like other \nobject-oriented programming languages, Java has one awkward property: virtual method calls.Java must \ndetermine, for each method call, the run-time type of the object to which this method belongs. In Java \nthis is im\u00adplemented by the invokevirtual bytecode. For example, the newItem method showninFigure 1 creates \nnew ob\u00adjects whose type depends on the parameters passed. The method Book.setTitle is called if and only \nif isBook is true,otherwise DVD.setTitle is called. Virtual method calls are not just useful but necessary. \nIn this case, our 1 The notion of method includes constructors. LibItem.setTitle(...) a b aMethod() Book.setTitle(...) \n c DVD.setTitle(...) Figure 3: Virtual calls derived from the example in Figure 2. tool must allow the \nprogrammer to explore (at least) the edges from Library.newItem to both Book.setTitle and DVD.setTitle. \n 3. CALL GRAPH CONSTRUCTION Three well-known techniques for call graph construction have been suggested \nin the literature. The simplest of these is Class Hierarchy Analysis (CHA) [2]. CHA analyses a program \nstatically to construct a graph of all possible edges between callees and callers. For Figure 1 it gives \nedges from newItem(...) to the setTitle(...) methods in the class LibItem and all its subclasses, since \nitem could be of any subtype at run-time. In our case, this would create all three edges of Figure 3, \nwhich is rather wrong and ine.cient. Fortunately, such graphs may be optimised if the run\u00adtime type of \na caller can be determined at compile-time, as in the example from Figure 2. Although the classes Book \nand DVD are subclasses of LibItem,for the method call setTitle(...) it is clear at compile-time that \nthe otherItem is a DVD. Rapid Type Analysis (RTA) [1] is somewhat slower in practice than CHA but can \neliminate some edges from the call graph. RTA .rst builds a call graph using CHA and then deletes any \nedges to classes for which no objects are instantiated inside the calling method. This is still quite \nquickand often trims the invoke graph substantially but usually still leaves dead edges . In our example, \nonly the edge a would be deleted. Finally, Variable Type Analysis (VTA) [4] is the most ex\u00adpensive but \nalso most sophisticated of the three algorithms. VTA uses type propagation to determine the static type. \nFrom every instantiation (by new), the type is propagated to the method call by examining all statements \nthat could change the type (such as assignments). In our example, this would delete all edges but c in \nFigure 3. The drawbackof VTA is thatitis expensive of time andspace. 4. IMPLEMENTATION We considered \nanalysing both source and bytecode. Byte\u00adcode leads to a more accurate representation of run-time behaviour \n(consider compile-time optimization), is easier to parse, quicker to process and always accessible. Any \naddi\u00adtional information provided by source code is unnecessary for our analysis. The chief drawbackof \nbytecode is that it must be converted into a human readable form for display. Our workcombines the analysis \ntechniques mentioned above with a powerful visualization tool that supports refac\u00adtoring by enabling \nthe user to investigate the application in a user-friendly way. Our analysis frameworkwas provided by \nthe SOOT bytecode analysis package [5] from the Sable2 2http://www.sable.mcgill.ca/ group at McGill University, \nwhich provides all three anal\u00adyses. Call graph visualization is provided through OpenJ-Graph3 . Our tool \nJAnalyzer4 enables developers to load and store projects containing source or bytecode .les. Source .les \nare pre-processed into an intermediate representation (one ex\u00adpression per line) in order to gain a bijection \nbetween single expressions in the source code and lines in the bytecode. This is performed using a JavaCC \ngenerated parser whose output is used directly to highlight syntax errors. As a re\u00adsult, the user can \ninvoke the bytecode analysis by clicking on the appropriate sourcecode item. The size of the call graph \ncan be limited by selecting speci.c methods as analysis en\u00adtry points and .ltering uninteresting classes; \n.ltered classes are considered as phantom classes in SOOT and represented as leaves of the call graph. \nOnce the graph is build, the user can enter the high-level view by simply clicking on a method invocation \nin the source code. A subset of the call graph, centred on this invocation, is displayed and can be further \nexplored. Remaining in this high-level view, the user can follow control .ow by follow\u00ading edges of the \ngraph displayed and can investigate further method calls by direct interaction with its method nodes. \n 5. CONCLUSIONS We believe that we have provided a useful tool to support program debugging and refactoring \n[3]. Once the call graph has been constructed, it is su.ciently fast to allow direct ex\u00adploration of \nthe relationships between methods. Complexity is controlled, and comprehensibility enhanced, through \n.l\u00adtering out uninteresting classes and by restricting the graph displayed to the nodes currently of \ninterest. We intend to integrate it into the Eclipse IDE5 and to provide enhance\u00adments such as a browser-like \nhistory for the visual graph, and incorporation of new SOOT 2.0 functionality. 6. ACKNOWLEDGEMENTS Much \ngratitude goes to Richard Jones who gave enor\u00admous contribution to the research of this project and helped \nin many ways to .nd appropriate solutions for many prob\u00adlems the team came across. Also many thanks to \nmy col\u00adleagues Piotr Piasecki and Jian Yang who contributed to JAnalyzer s research and development. \n 7. REFERENCES [1] D.F.Bacon and P.F.Sweeney. FastStatic Analysisof C++ Virtual Function Calls. In OOPSLA \n96, pages 324 341, November 1996. ACM Press. [2] J. Dean, D. Grove, and C. Chambers. Optimization of \nObject-Oriented Programs Using Static Class Hierarchy Analysis. In ECOOP 95, Lecture Notes in Computer \nScience, volume 952, pages 77 101, 1995. [3] M. Fowler. Refactoring: Improving the Design of Existing \nCode. Addison-Wesley, 1999. [4] V. Sundaresan, L. J. Hendren, C. Raza.mahefa, R. Vall\u00b4ee-Rai, P. Lam, \nE. Gagnon, and C. Godin. Practical virtual method call resolution for Java. In OOPSLA 00, pages 264 280, \n2000. ACM Press. [5] R. Vall\u00b4ee-Rai, L. Hendren, V. Sundaresan, P. Lam, E. Gagnon, and P. Co. SOOT -a \nJava Optimization Framework. In CASCON 1999, pages 125 135, 1999. 3http://openjgraph.sf.net 4http://janalyzer.bodden.de \n5http://www.eclipse.org  \n\t\t\t", "proc_id": "949344", "abstract": "Static analysis of object-oriented applications has become widespread over the last decade, mainly in the context of compile-time optimizations. The paper describes how static analysis of virtual method calls can be employed to provide a high-level view of Java applications. The result is a method call graph that can be built from either source or bytecode, and a graphical browser that enables the user to analyze control flow and the coupling between classes and packages in an intuitive fashion, thereby supporting application design as well as refactoring and debugging. In order to achieve the necessary bijection between source and bytecode representations of classes, we implement a new approach based on source code pre-processing.", "authors": [{"name": "Eric Bodden", "author_profile_id": "81100018194", "affiliation": "University of Kent, Canterbury, Kent, UK", "person_id": "PP39023425", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949447", "year": "2003", "article_id": "949447", "conference": "OOPSLA", "title": "A high-level view of Java applications", "url": "http://dl.acm.org/citation.cfm?id=949447"}