{"article_publication_date": "10-26-2003", "fulltext": "\n A Self-Optimizing Application Server Design for Enterprise Java Beans Applications Mircea Trofin Performance \nEngineering Laboratory Dublin City University +353 1 700 7644 mtrofin@eeng.dcu.ie ABSTRACT We propose \na self-optimizing application server design for EJB component technology. Optimizations are driven by \nthe discovery of inter-component communication patterns and the application of corresponding container \nrefactorings. Our solution attempts to address the impact the application server has on system performance. \n Categories and Subject Descriptors I.2.2 [Automatic Programming] --- Program transformation;  General \nTerms Performance, Design Keywords EJB, COTS, optimization, adaptation, container, platform 1. INTRODUCTION \nAs the complexity of software systems increases, so does the need for solution reusing. Component-based \nsoftware development is a natural answer to this need. Companies increasingly rely on component-oriented \ntechnologies, such as Enterprise Java Beans (EJB), and on Commercial Off-The-Shelf (COTS) components, \nin order to build large scale applications, reduce system development costs and capitalize on third party \nexpertise. While componentization addresses a number of issues, such as software maintainability and \nreusability, it does not necessarily address system performance issues. Modern component technologies \ncomplicate such issues even further, as system composition occurs late in the development cycle, sometimes \neven at runtime, thus thwarting any attempts for early performance reasoning. 2. MOTIVATION Quite often, \nin order to deal with performance issues, system developers choose to redesign the system, changing its \ncomposition by reducing modularity, in order to reduce the impact of the underlying platform (the application \nserver) [2]. Copyright is held by the author/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, \nUSA. ACM 1-58113-751-6/03/0010. This approach offers a hard to accept trade-off between application \nperformance, on one hand, and maintainability and functional extensibility, on the other. The impact \nthe platform and implementation choices have on performance has been documented and proves to be quite \nsignificant [1]. Rather than redesigning the application, we propose that the underlying platform, notably \nthe component containers, adapt to the application needs. The adaptation process is automatic, and is \ndriven by the acquisition of knowledge about call patterns between the constituent components of an application. \nWe present a container adaptation framework that aims at improving the performance of EJB applications \nwithout changing the component set. While we do not believe that our method will solve all performance \nissues, it will alleviate those introduced by the application server. 3. PROPOSED APPROACH We intend \nto devise a framework for adapting containers in order to transform the execution model of an application. \nThe key observation is that components are concepts observed at design and system composition time. While \na runtime environment contract exists between components and the underlying platform, this contract does \nnot mandate a unique realization. The current strategy for existing application servers is to determine \ncomponent runtime support at deployment time (when component containers are determined and stubs are \ncompiled). However, since the actual usage of such a component is unknown, the containers have to be \ngeneric with respect to the possible utilizations that would occur at runtime. The EJB specification \ndoes not clearly mark the boundary between containers and application servers. For our purposes, the \napplication server is an entity providing support for enterprise services, such as naming, transactional \nisolation, or security, while a container is an entity wrapping each component and mediating that component \ns runtime requirements, such as communication with other components, lifecycle, and runtime execution \ncontext properties (e.g. transactional or security) Following the above, if paths through the system \nwere known, the realization of component runtime requirements (i.e. container functionality) could be \noptimized by choosing different realizations of particular containers. Since runtime requirements are \ndescribed at the method level in the component deployment descriptor, we believe that it is sufficient \nto describe paths through the system by means of indicating which method of which component calls which \nmethod(s) of which component(s). Based on deployment descriptor information and call path information, \nthe actual services that have to be provided for each component in a call path, when its method(s) are \ncalled, can be predetermined. That leads to refactoring the corresponding containers, since they implement \nthese services. There are three concerns that have to be resolved: 1. how paths in the system are discovered \nand associated with an optimization strategy; 2. how those optimization strategies are implemented; 3. \nhow they become enforced at runtime with as little overhead as possible. We address the first concern \nby proposing a framework composed of a Monitor, and an Expert System. For the second concern, we introduce \na Container Refactoring Engine which transforms high-level optimization decisions into concrete container \nrefactorings; the last concern is addressed by a Container Re-Design Strategy which is applied whenever \na path through the system is optimized, at the level of individual containers, to ensure that the optimization \nactually takes place at runtime. We present each of these in more detail in the following sections. 3.1 \nMonitor This module collects real-time information about an EJB application. The collected data can be \nused to infer call paths through the system. Monitoring is not a standard EJB platform feature, but there \nis current research [3] in this area. We assume such a feature is available. 3.2 Expert System The expert \nsystem module is used to take decisions on how the platform has to be modified, given the monitoring \ninformation. We decided on an expert system solution for the following reasons: domain-specific information \ncan be expressed naturally, and, in such a system, a decision emerges after taking all facts into consideration; \nby its nature, the expert system can be extended with new rules dynamically. The expert system uses monitoring \ninformation, together with individual components deployment descriptor information, and produces assertions \nabout call paths through the system; these assertions indicate what can be assumed about the execution \ncontext at each stage in the call path. Based on this information, the Container Refactoring Engine is \nable to remove un-needed execution context handling (i.e. transactional or security), and optimize state \nmanagement services. 3.3 Container Refactoring Engine This module offers an interface into an EJB platform \nthat allows the high-level decisions of the Expert System to be mapped into concrete refactorings of \nindividual containers. The decisions given by the Expert System are interpreted by the Container Refactoring \nEngine as assumptions that can be made when factoring the services a container needs to offer. An example \nis that the Expert System decides that a stateless execution model would perform better for a given application. \nTo achieve that, full system interactions would need to be refactored into interactions that are equivalent \nto calling a stateless session bean s methods. That would involve the refactoring of the containers of \nall the beans involved in such an interaction, then applying the Container Re-Design Strategy (presented \nin the following section) to ensure that these refactored containers are used from this point on to realize \nthat interaction. The refactoring would involve: the removal/modification of transactional and security \ncontext handling services, and the customization of lifecycle services, in order to maintain state only \nfor the duration of the overall system interaction. Since a component can participate in more than one \nsystem interaction, assumptions used for container refactorings are tied to a particular interaction. \nTherefore, more than one variant of a bean s container would exist at a time. 3.4 Container Re-Design \nStrategy Central to the re-design strategy is the fact that EJB components bind only at runtime, and \nthat the binding is not done directly to a component, but rather to its container. Since there is more \nthan one container variant for the same component (see previous section), each such container variant \nwill have a different name. The Container Re-Design Strategy is a design pattern that is present in all \nthe refactored containers, and ensures that the right containers are picked for a particular system interaction. \nThis is achieved in two parts: first, the refactored containers are given names that uniquely associate \nthem with the situation (i.e. stage in a call path) the containers have to appear in order to function \ncorrectly (in other words, the situation in which the assumptions made when the refactored container \nwas created hold). Second, it is ensured that the client component is aware of the situation (stage in \ncall path) it is in when attempting to bind to another component (i.e. its refactored container). That \ncan be done at the level of the container of the client component. This container assumes the role of \na naming provider and maps the names the component wishes to bind to, to the names of the correct optimized \ncontainers.  4. CONCLUSIONS We have presented an approach for runtime optimization of EJB applications. \nOur proposal consists of providing self-optimizing capabilities to the software platform on which the \napplications run. It is expected that our approach would offer a solution to the conflict between having \nEJB systems that exhibit high modularity, and obtaining high performance from such systems. 5. ACKNOWLEDGMENTS \nThe authors work is funded by Enterprise Ireland Informatics Research Initiative 2002. 6. REFERENCES \n[1] E. Cecchet, J. Marguerite, W. Zwaenepoel. Performance and scalability of EJB applications , OOPSLA \n2002. [2] Brett McLaughlin. Building Java Enterprise Applications Volume I: Architecture , O Reilly, \n2002. [3] A. Mos, J. Murphy. Understanding Performance Issues in Component-Oriented Distributed Applications: \nThe COMPAS Framework , WCOP 2002, at ECOOP 2002, June 2002, Malaga, Spain.  \n\t\t\t", "proc_id": "949344", "abstract": "We propose a self-optimizing application server design for EJB component technology. Optimizations are driven by the discovery of inter-component communication patterns and the application of corresponding container refactorings. Our solution attempts to address the impact the application server has on system performance.", "authors": [{"name": "Mircea Trofin", "author_profile_id": "81100563368", "affiliation": "Dublin City University", "person_id": "P643476", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949453", "year": "2003", "article_id": "949453", "conference": "OOPSLA", "title": "A self-optimizing application server design for enterprise Java beans applications", "url": "http://dl.acm.org/citation.cfm?id=949453"}