{"article_publication_date": "10-26-2003", "fulltext": "\n A Framework for Using Component Redundancy for Self-Adapting and Self-Optimising Component-Based Enterprise \nSystems Ada Diaconescu Performance Engineering Laboratory Dublin City University, Ireland +353-1-7007644 \ndiacones@eeng.dcu.ie ABSTRACT We propose a framework that uses component redundancy for enabling self-adaptation, \nself-optimisation and self-healing capabilities in component-based enterprise software systems. Categories \nand Subject Descriptors D.2.9 [Software Engineering]: Management software configuration, management, \nsoftware quality assurance (SQA).  General Terms Management, Performance, Design. Keywords Redundancy, \nmiddleware, self-adaptation, self-optimisation, decision policy, component-based enterprise systems. \n1. INTRODUCTION AND PROBLEM A significant problem in the information technology (IT) industry at present \nis complexity [1]. The extensive use of software systems in various domains imposes certain requirements \non their quality characteristics (e.g. performance, dependability). Thus, building, managing and optimising \nsuch complex systems is becoming a growing concern. Component technologies [2], such as EJB, CCM or .NET, \naddress many of the complexity related difficulties, by facilitating software modularity and reusability. \nNevertheless, such technologies introduce new challenges. The way individual components behave and interact \nin a system, as well as their runtime environment, strongly influence global system performance. However, \nlack of system internal information, plus the dynamic nature of component-based applications, makes the \nperformance of complex systems hard to analyse and predict. Component developers do not know the running \ncontext(s) of their components and application integrators do not have access to component internal information. \nIn addition, runtime system modifications and execution context changes can render initial optimisations \nobsolete, as different design and implementation strategies are optimal in different running contexts \n[3], [4]. Thus, ensuring quality guarantees for complex component-based systems becomes a challenging \ntask at best. Copyright is held by the author/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, \nUSA. ACM 1-58113-751-6/03/0010.  2. PROPOSED SOLUTION We propose enabling component-based applications \nto automatically change their implementation at runtime in order to tune themselves and continuously \nadapt to variations in their environment (e.g. workload, usage patterns, available resources). For this \ngoal to be met, the following must be provided: i) different design and implementation strategies for \nsoftware components, available at runtime; ii) a mechanism for automatically alternating the available \nstrategies at runtime, as needed for reaching the high-level goals of software applications. 2.1 Component \nRedundancy Component redundancy is a concept we introduce for addressing the former requirement. It means \nthe presence, at runtime, of multiple component variants providing identical or equivalent services but \nwith different implementation strategies. We refer to these component variants as redundant components. \nOnly one of the redundant components providing a service is assigned, at any moment in time, for handling \na certain client request for that service. The selected variant is referred to as the active component \nvariant. Redundant components can be added, updated, or removed at runtime. We implemented and tested \nan example scenario that shows the applicability of our approach [4]. The EJB component technology was \nused for implementing this example. Different strategies were selected for implementing two distinct \ncomponent variants providing the same functionality: repeated retrieval of information from a remote \ndatabase (DB). The first variant consists of stateless session beans only and uses SQL code for directly \naccessing the DB. The second variant (session fa\u00e7ade) employs a stateless session bean as a wrapper to \nan entity bean, which encapsulates persistent data. The entity bean acts as a local cache for data in \nthe remote DB. We measured the response delays for each variant, in different environmental conditions \n(i.e. available bandwidth on the network link to the DB). When the link to the DB was lightly loaded, \nthe session-only variant proved optimal. For increased network loads however, the session fa\u00e7ade variant \nbecame optimal, as its inter-process communication and CPU overhead became lower than the repeated database \naccess overhead introduced by the sessions-only variant. As these results indicate, knowledgeably alternating \nthe usage of redundant components, optimised for different running contexts, ensures better overall performance \nthan either component variant could provide. 2.2 Our framework We propose a framework for supporting \nand managing redundant components, capitalizing on their redundancy to continuously adapt and optimise \napplications and meet their quality goals (e.g. response times, throughputs). The framework is divided \ninto three main logical tiers: monitoring, evaluation and action. The monitoring tier is concerned with \nobtaining run-time information on software applications, exclusively on active components (response times, \nthroughput), as well as on their execution environments (incoming workload, CPU, I/O usage). Collected \ninformation is analysed and potential problem components identified. The evaluation tier is responsible \nfor deciding which components to (in)activate and when, in order to obtain quality improvements. This \ninvolves two main activities: i) accumulate information on components and their running environment; \nii) process information and determine the optimal redundant component(s), in certain contexts. Component \ninformation is represented as a formal component description. Component providers can optionally supply \ninitial component descriptions, at deployment time. An initial description can indicate the used implementation \nstrategy, or the running context for which a component was optimised. It can also provide relative quality \nattribute values, and/or their variation with environmental conditions. This sort of information can \nbe acquired from testing results, estimations, or previous experience with provided components. These \ndescriptions are then updated at runtime with accurate monitoring information for the actual execution \ncontexts. Component descriptions and runtime monitoring information are used as input to decision policies. \nThese are sets of rules, dictating the actions to be taken in case certain conditions are being satisfied. \nDecision policies can be customised for each deployed application, for serving the specific application \ngoals (e.g. requested quality attributes and their values) and can be added, modified or deleted at runtime. \nThe action tier enforces decisions taken in the evaluation tier into the running application, using a \nrequest indirection mechanism. That is, incoming client calls are directed to an instance of the active \ncomponent variant, upon arrival. When the active component changes, new incoming requests are directed \nto instances of the new active component. State transfer is not needed in this case, as client requests \nare not transferred between instances of different components; a particular interaction always executes \nwith the component instances it started with. The three logical tiers operate in an automated, feedback-loop \nmanner: application performance is monitored and evaluated; optimal redundant component(s) are identified \nand activated (action); and the resulting application is (re-)monitored and (re\u00ad)evaluated. Component \ndescriptions and decision policies are tuned, or updated in effect. The evaluation tier can thus improve \nits decisions, in time, as it gradually learns about the performance and behavioural characteristics \nof the component\u00adbased application it has to manage. We are implementing our framework in a manner that \nmakes it independent of the specific applications it has to manage. Conceptually, our framework belongs \nto the execution platform (e.g. J2EE) on which applications are deployed and run, being at the same level \nwith already provided services (e.g. security, transaction support, connectivity). This makes our framework \ntransparent to clients of applications deployed on such platforms. For improved scalability, we decentralise \nour three-tiered framework and employ different intercommunicating instances of our framework to manage \napplications at different granularities (e.g. single component, component group, or global application). \nWe organise these instances in a hierarchical manner and specify a clear protocol for their intercommunication. \nThis allows for local application problems (e.g. at component level) to be dealt with locally, when possible, \nwhile also supporting global optimisations, when necessary. We instrumented the open source JBoss application \nserver so that to provide call path related information. This allows instances of our framework dynamically \ndetect when and what method(s), of what EJBs, are being called by a certain method of a certain EJB instance. \nThis information, together with component response time and throughput information, is used to determine \nwhether provided services are meeting their performance requirements, as well as help detect problem \ncomponents.  3. CONCLUSIONS AND FUTURE WORK Our main contribution is a framework that uses component \nredundancy to automatically manage complex software applications and meet their quality goals. The main \nfeatures of our framework that differentiate it from similar work in the area (e.g. [3], [5]) are its \nindependence from specific components or applications and its decentralised operation. The framework \nhas no strict requirements on the initial information to be provided on the deployed components. It is \ndevised to be able to collect information, and learn in time about the component-based application it \nhas to manage. Management activities at different granularity levels (e.g. component, application) can \nbe switched on and off dynamically, as needed for meeting quality goals, while introducing minimum overhead. \nThe evaluation and decision mechanism is critical to our approach and is therefore the focus of our ongoing \nresearch. We intend to adopt existing solutions, relevant to our framework, such as monitoring solutions \n(e.g. the COMPAS project [6]), rule engines, or learning methods. 4. ACKNOWLEDGMENTS This work is funded \nby Enterprise Ireland Informatics Research Initiative 2002s. 5. REFERENCES [1] J. O. Kephart, D. M. \nChess, The Vision of Autonomic Computing , IEEE Computer, January 2003 [2] C. Szyperski et al. Component \nSoftware: Beyond Object-Oriented Programming , Addison-Wesley, November 2002 [3] Daniel M. Yellin, Competitive \nalgorithms for the dynamic selection of component implementations , IBM Systems Journal, Vol. 42, no \n1, 2003 [4] A. Diaconescu, J. Murphy, A Framework for Using Component Redundancy for Self-Optimising \nand Self-Healing Component Based Systems , WADS workshop, ICSE 03, Hilton Portland, Oregon USA, May 3-10, \n2003 [5] S. Cheng, D. Garlan, et al., Using Architectural Style as a Basis for Self-repair , WICSA 02, \nMontreal, Aug. 2002 [6] The COMPAS project home page: www.ejbperformance.org  \n\t\t\t", "proc_id": "949344", "abstract": "We propose a framework that uses component redundancy for enabling self-adaptation, self-optimisation and self-healing capabilities in component-based enterprise software systems.", "authors": [{"name": "Ada Diaconescu", "author_profile_id": "81100548357", "affiliation": "Dublin City University, Ireland", "person_id": "PP14190594", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949450", "year": "2003", "article_id": "949450", "conference": "OOPSLA", "title": "A framework for using component redundancy for self-adapting and self-optimising component-based enterprise systems", "url": "http://dl.acm.org/citation.cfm?id=949450"}