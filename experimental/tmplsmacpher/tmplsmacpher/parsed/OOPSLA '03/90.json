{"article_publication_date": "10-26-2003", "fulltext": "\n Programming with Non-Heap Memory in the Real Time Specification for Java Greg Bollella1, Tim Canham2, \nVanessa Carson2, Virgil Champlin3, Daniel Dvorak2, Brian Giovannoni3, Mark Indictor2, Kenny Meyer2, Alex \nMurray2, Kirk Reinholtz2 1Sun Microsystems Laboratories 2Jet Propulsion Laboratory 3School of Computer \nScience 2600 Casey Avenue California Institute of Technology Carnegie Mellon University MS UMTV29-236 \n4800 Oak Grove Drive Building 17, First Floor Palo Alto, CA 94043 Pasadena, CA 91109 Moffett Field, CA \n94035 650-336-1693 818-393-1986 650-603-7005 greg.bollella@sun.com daniel.dvorak@jpl.nasa.gov champlin@cs.cmu.edu \n ABSTRACT The Real-Time Specification for Java (RTSJ) provides facilities for deterministic, real-time \nexecution in a language that is otherwise subject to variable latencies in memory allocation and garbage \ncollection. A major consequence of these facilities is that the normal Java practice of passing around \nreferences to objects in heap memory cannot be used in hard real-time activities. Instead, designers \nmust think carefully about what type of non-heap memory to use and how to transfer data between components \nwithout violating RTSJ s memory-area assignment rules. This report explores the issues of programming \nwith non-heap memory from a practitioner s view in designing and programming real\u00adtime control loops \nusing a commercially available implementation of the RTSJ. Categories and Subject Descriptors D.3.3 \n[Programming Languages]: Language Constructs and Features classes and objects, control structures, dynamic \nstorage management, frameworks General Terms Design, Experimentation, Languages. Keywords Programming \nmodel, scoped memory, architecture. 1. INTRODUCTION Automatic memory management is one of the biggest \nbenefits of the Java programming language relative to C++. This capability, achieved through automatic \ngarbage collection, eliminates a significant source of programmer error, enabling larger applications \nto be developed with fewer defects. A price for this benefit is that a thread s execution time and response \nlatency is Copyright is held by the author/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, \nUSA. ACM 1-58113-751-6/03/0010. non-deterministic because the garbage collector can preempt application \nexecution at any time. This fact precludes highly predictable real-time execution in ordinary Java. The \nReal-Time Specification for Java (RTSJ) [1] addresses this limitation through facilities that enable \napplication logic to execute without interference from the garbage collector. The key idea is to provide \nnew kinds of Runnable that are guaranteed not to access heap memory. Such Runnables can preempt the garbage \ncollector at any time and thus run with high temporal determinism. Of course, these Runnables need some \nkind of working memory, so the RTSJ provides two kinds of non-heap memory. However, these new memory \nareas come with some VM-enforced assignment rules to ensure that the garbage collector s business is \nseparated from hard real-time activities. The net result is that RTSJ programmers must confront some \nnew design issues that go beyond issues of real-time scheduling. This report focuses on the practical \ndesign issue of exchanging data between hard real-time components. Users of any RTSJ\u00adcompliant virtual \nmachine will confront the same issue and will have to consider how best to use the RTSJ s non-heap memory \nareas. This report is about application programming, not about JVM design or about potential changes \nto the RTSJ. Since knowledge of the RTSJ is probably not extensive among OOPSLA attendees, this report \nincludes some background to help readers understand the nature of non-heap memory areas and their consequences. \nThe evolution of real-time garbage collection technology for Java virtual machines will change the picture \nfor developers of real\u00adtime systems, but that topic is beyond the scope of this report. As yet there \nis no commercial product that combines real-time garbage collection with the RTSJ enhancements for threads, \nscheduling, synchronization, asynchrony, and physical memory access. 2. PROJECT GOLDEN GATE This report \npresents some early results from Project Golden Gate [2,3], a collaboration among Caltech s Jet Propulsion \nLaboratory, Sun Microsystems Laboratory, and the High Dependability Computing Program [8] led by Carnegie \nMellon University. The project is implementing JPL s state- and model-based control architecture named \nMission Data System (MDS) [4] in the RTSJ using the first commercial implementation of the RTSJ: the \nTimeSys JTime virtual machine [9]. The JTime VM runs on TimeSys Linux RTOS, a low-latency version of \nthe Linux operating system. The work reported herein occurred as the team designed control loops for \ndriving and steering a 6-wheel experimental Mars rover named Rocky 7 . The rover s processor is a 300 \nMHz PPC 750 with 256MB RAM. The rover hardware includes 6 driving motors, 2 steering motors, 3 stereo \ncamera pairs, a 3-axis accelerometer, a 1-axis gyroscope, a camera frame grabber, and five other motors \nfor controlling a camera mast and an arm.  3. INTRODUCTION TO RTSJ Ordinary Java technology is not suitable \nfor real-time systems for several reasons: no scheduling control over threads, unpredictable synchronization \ndelays, run-anytime garbage collection, coarse timer support, no event processing, and no safe asynchronous \ntransfer of control. The real-time specification for Java, known as RTSJ , addresses these limitations \nthrough several areas of enhanced semantics. The RTSJ was shaped by several guiding principles. Foremost \namong these is the principle to hold predictable execution as first priority in all tradeoffs . Another \nprinciple is that the RTSJ introduces no new keywords of other language extensions. Also, the RTSJ provides \nbackward compatibility, meaning that existing Java programs run on RTSJ implementations. Importantly, \nthe RTSJ supports leading-edge scheduling, going beyond simple priority-based scheduling. It s important \nto understand that real time doesn t mean real fast . The guiding principle of predictable execution \nplaces more importance on specifying and meeting timeliness constraints than on raw throughput. Real-time \napplications must respond to periodic, aperiodic, and sporadic events, and the RTSJ provides facilities \nfor informing a scheduler of such constraints and determining if a set of constraints admits a feasible \nschedule. The net result in RTSJ, in contrast to purely priority-based systems, is that scheduling and \ndispatching can be based on explicit timeliness information. Most real-time applications are a mixture \nof hard real-time , soft real-time , and non real-time parts, as shown in Figure 2. In this report we \nuse the term hard real-time to mean that temporal correctness criteria must always be met. For example, \nif a hard real-time computation misses a deadline, the system goes into an abnormal state. By soft real-time \nwe mean that temporal correctness criteria are almost always met, so an occasional missed deadline (for \nexample) is tolerated. By non real-time we mean that there are no temporal correctness criteria. A key \npoint to understand here is that a single RTSJ-compliant VM can support systems that mix hard, soft, \nand non real-time parts. No temporal predictability required. java.lang.Thread Medium temporal predictability \nrequired. RealtimeThread High temporal predictability required. NoHeapRealtimeThread Figure 2. Most \nreal-time systems are a mixture of hard real-time, soft real-time, and non-real-time, all of which can \nbe supported by a single RTSJ-compliant VM. The RTSJ extends Java semantics in several areas, as summarized \nbelow. This background information is intended to provide readers with a broad understanding of how the \nRTSJ supports various aspects of real-time programming. Some features of the RTSJ have been omitted for \nbrevity. 3.1 Threads The RTSJ introduces two new types of thread that have more precise scheduling semantics \nthan java.lang.Thread. Parameters provided to the constructor of RealtimeThread allow the temporal and \nprocessor demands of the thread to be communicated to the system. NoHeapRealtimeThread ( NHRT ) extends \nRealtimeThread with the restriction that it is not allowed to allocate or even reference objects from \nthe Java heap, and can thus safely execute in preference to the garbage collector. Such threads are the \nkey to supporting hard real-time execution because they have implicit execution eligibility logically \nhigher than any garbage collector. 3.2 Scheduling The scheduling area in RTSJ provides classes that \nallow the definition of schedulable objects, manage the assignment of execution eligibility of schedulable \nobjects, assign release characteristics to schedulable objects, and perform feasibility analysis for \nsets of schedulable objects. As seen in Figure 3, schedulable objects are instances of RealtimeThread, \nNoHeapRealtimeThread, and AsyncEventHandler. Each of these is assigned processor resources according \nto its release characteristics and execution eligibility. As shown in Figure 4, there are three types \nof ReleaseParameters to support periodic, aperiodic, and sporadic execution. Each of these subclasses \ncontains parameters needed to determine whether a feasible schedule can be found for a set of schedulable \nobjects.  Figure 4. Release parameters supply processor and temporal demands needed to determine schedule \nfeasibility. 3.3 Memory Management The RTSJ contains classes that allow the definition of regions of \nmemory outside the traditional Java heap. These new memory areas called ImmortalMemory and ScopedMemory \nare not managed by a garbage collector. This means that instances of NoHeapRealtimeThread can use such \nmemory to communicate results within hard real-time areas as well as between hard real-time areas and \nsoft- or non real-time areas. ImmortalMemory is a single memory area that is shared among all threads. \nObjects allocated in the immortal memory live until the end of the application. In fact, unlike standard \nJava heap objects, immortal objects continue to exist even after there are no other references to them. \nImportantly, objects in immortal memory are never subject to garbage collection. ScopedMemory is an abstract \nbase class for memory areas having limited lifetimes. A scoped memory area is valid as long as there \nare real-time threads with access to it. A reference is created for each accessing thread when either \na real-time thread is created with a ScopedMemory object as its memory area, or when a real-time thread \nruns the enter() method for the memory area. When the last reference to the object is removed, by exiting \nthe thread or exiting the enter() method, finalizers are run for all objects in the memory area, and \nthe area is emptied. Objects in scoped memory are never subject to garbage collection. The memory management \nenhancements in RTSJ also include facilities for access to physical memory, facilities for non-heap memory \nallocation in linear time, and facilities for obtaining information about the temporal behavior of the \ngarbage collector, such as its preemption latency.  Normal Java heap  Subject to GC  Not accessible \nby NoHeapRealtimeThread  Accessible by all threads  Not subject to GC  Objects live until end of application \n Object lifetime limited  Not subject to GC  Scope emptied after all threads exit it  Figure 5. The \nRTSJ introduces two kinds of non-heap memory that are not subject to garbage collection. 3.4 Synchronization \nThe RTSJ contains classes that allow application of the priority ceiling emulation algorithm to individual \nobjects; allow the setting of the system default priority inversion algorithm; and allow wait-free communication \nbetween real-time threads and regular Java threads. This strengthens the semantics of Java synchronization \nfor use in real-time systems by mandating priority inversion control. The wait-free queue classes provide \nprotected, concurrent access to data shared between instances of java.lang.Thread and NoHeapRealtimeThread. \n 3.5 Time The RTSJ contains classes that allow description of a point in time with up to nanosecond accuracy \nand precision (dependent on the precision of the underlying system), and allow distinctions between absolute \npoints in time, times relative to some starting point, and rational time, which allows the efficient \nexpression of number of occurrences per some interval of relative time. The time class relationships \nare depicted in Figure 6. Instances of AbsoluteTime represent absolute time expressed relative to midnight \nJanuary 1, 1970 GMT. Instances of RelativeTime encapsulate a point in time that is relative to some other \ntime value. Instances of RationalTime express a frequency as an integral number of cycles per an amount \nof relative time. Figure 6. High resolution time supports timing with nanosecond accuracy and precision, \nsubject to the underlying system s accuracy and precision. 3.6 Timers The RTSJ contains classes that \nallow creation of timer whose expiration is either periodic (PeriodicTimer) or set to occur at a particular \ntime (OneShotTimer). RTSJ also defines an abstract base class for clocks, recognizing that real systems \noften have other kinds of clocks (e.g. simulation clocks, user time clocks), and allows timers to specify \nsuch a clock in place of the default system clock. 3.7 Asynchrony The RTSJ contains classes for binding \nthe execution of program logic to the occurrence of internal and external events. Specifically, an asynchronous \nevent is represented as an instance of class AsyncEvent or a subclass. An event occurrence may be initiated \nby application logic (by invoking the event instance s fire() method) or by the occurrence of a happening \nthat is external to the JVM, such as a hardware interrupt. Each instance of AsyncEvent may have one or \nmore instances of AsyncEventHandler associated, as shown in Figure 7. The converse also holds: every \ninstance of AsyncEventHandler may have one or more instances of AsyncEvent associated. Every time an \nevent occurs, the associated handlers are made eligible to run; dispatching of the handler is subject \nto its release parameters.   4. SOME IMPLICATIONS OF RTSJ The central problem associated with using \nJava for systems with hard real-time requirements is that garbage collection always has non-interruptible \nsequences of instructions, the execution duration of which cannot be predicted. Furthermore, garbage \ncollection must always be able to enter a critical section, and so any activity in the system is subject \nto unpredictable delays waiting for garbage collection. Memory allocation or de-allocation can cause \na GC critical section to run, but these may run at anytime, not directly caused by a call to new. The \nRTSJ solves this problem with two constructs: the no-heap realtime thread and scoped memory. The no-heap \nreal-time thread (NHRT) runs at a higher priority than the garbage collector, and so is not subject to \ndelays caused by it in normal threads. Garbage collection is locked out while a no-heap real\u00adtime thread \nis executing. In fact, an NHRT can preempt the garbage collector at any time, and so it must not be allowed \nto change anything that could affect the state of garbage collection, including heap memory or any objects \nallocated from it. If code running under such a thread needs to allocate memory, this could lead to a \nconflict: garbage collection needs to run to satisfy the allocation request, but garbage collection can \nt run because the no-heap real-time thread cannot tolerate unpredictable delays. Therefore, the code \nin the no-heap real-time thread cannot be allowed to make allocations from memory that is managed by \nthe garbage collector (i.e. the heap), nor make changes to heap, because these could affect the garbage \ncollector. For each thread type, Table 1 shows what from kinds of memory it can allocate objects using \nnew . Table 1. Thread types and the memory areas in which they can allocate objects using new . Can thread \nallocate objects using new ? Heap Memory Immortal Memory Scoped Memory java.lang.Thread Yes No No RealtimeThread \nYes Yes Yes NoHeapRealtimeThread No Yes Yes One solution is to not allow code in no-heap real-time threads \nto allocate memory at all, but this is a severe limitation, very unattractive for Java programming. Another \nsolution is to allow the NHRT to allocate memory, but only from a pool of memory that is not under the \nresponsibility of garbage collection, and which can therefore be allocated from without having garbage \ncollection eligible to run. This is what the RTSJ does with the introduction of the scoped memory construct, \nexpressed by the ScopedMemory abstract class. A scoped memory area is a block of memory of fixed size \nthat can be associated with a running NHRT. The NHRT is said to enter the scoped memory area, and is \nsaid to be running in the scope of that memory area. When the NHRT is running in a scoped memory area, \nit can allocate memory from that area in the usual way, using the new statement. Objects allocated from \nthe memory area exist as long as some NHRT (multiple NHRT s can use the same scoped memory area) stays \nin the scope of that memory area. An NHRT leaves the scope either by exiting the scope explicitly or \nby finishing execution. When all NHRT s have exited the scope, all objects allocated in the scope by \nany thread become no longer accessible. But those objects are not garbage collected, since there is no \ngarbage collector that is responsible for freeing objects in the memory area. If a NHRT subsequently \nenters that scope again, it will be as if no objects were ever allocated in that scoped memory area. \nA NHRT can never allocate more objects in a scoped memory area than the fixed size of that area. Thus, \ncode running in a NHRT must be designed up front with known memory allocation needs that cannot be exceeded. \nWith this RTSJ solution, it is now possible to know the maximum amount of time that a sequence of instructions \nwill experience. This assurance is achieved by running that sequence of instructions under a NHRT, which \nnecessarily puts the execution of that code in a scoped memory area. Compared to the normal Java programming \nmodel, programming with NHRTs and scoped memories is more complicated. Fortunately, as shown in Figure \n2, most real-time systems contain a relatively small hard real-time part, so the added complexity is \ncontained. The soft real-time part as well as the non real-time part can freely allocate memory from \nthe heap, relying on garbage collection to reclaim those allocations when no longer needed. The RTSJ \nsolution also has implications for communication between hard real-time elements and other elements of \nthe system, especially for information flow from hard real-time to soft- or non-real-time components. \nThere is a distinct information boundary between these two types of system elements, which we call the \nhard real-time boundary. An object allocated in the scope of a memory area cannot be referenced is not \neven visible to code running outside the scope of the memory area. An object on heap, allocated by non-real-time \ncode, cannot be assigned to by hard real-time code. More formally, the RTSJ defines memory area assignment \nrules preclude certain kinds of references from one memory area to another. These rules are shown in \nTable 2. Table 2. The RTSJ s memory area assignment rules restrict certain kinds of inter-memory references \nin order to separate garbage collection from hard real-time activities. Reference to Heap Reference to \nImmortal Reference to Scoped Heap Yes Yes No Immortal Yes Yes No Scoped Yes Yes Yes, if same, outer or \nshared So how then, can information computed by hard real-time system elements be communicated to soft- \nor non-real-time system elements? We present our design solutions in Section 6. 5. CONTROL LOOPS IN \nMDS Our problem domain is that of real-time closed-loop control of physical systems. Such control systems \nare designed for continuous operation and they interact with the real world through imperfect sensors \nand actuators. In our case, these are embedded control systems that live within the resource-limited \nworld of planetary rovers and spacecraft. The design of our control loops is governed by the architecture \nof the Mission Data System (MDS), an information and control architecture that emphasizes explicit representation \nof physical states (continuous as well as discrete states), explicit models of hardware and physical \neffects, and goal-oriented operation that enables varying levels of onboard autonomy [4]. As shown in \nFigure 8, real-time control loops in MDS involve four kinds of components: hardware adapters, state variables, \nestimators, and controllers. There is a hardware adapter for each controllable hardware unit, and each \none provides software interfaces for sending commands and obtaining measurements. A state variable is \na component that holds information about a physical state (such as rover position) and whose value history \nis made available as telemetry. An estimator interprets measurements from potentially multiple sensors \nin order to generate state estimates. A controller compares current state estimates to a goal (a constraint \non the value of a state variable over a time interval) and issues commands to actuators, as needed, to \ninfluence a physical state. The dominant data flow around a control loop involves four flows: controllers \nquery state variables for state estimates; controllers submit commands to hardware adapters; estimators \nquery hardware adapters for measurements; and estimators update state variables. The main challenges \nin software design for hard\u00adreal-time control loops using the RTSJ involve appropriate use of non-heap \nmemory for these four data flows. In our case, coordinated control of the 6 driving motors and 2 steering \nmotors on the Rocky 7 rover involved 9 control loops, so we were motivated to find a good general solution. \n Figure 8. A simple hard real-time control loop in MDS involves data flows among four components. 6. \nSCOPED MEMORY SCRATCHPADS This section describes some design considerations in how to handle information \ntransfer between hard real-time components, and then describes the design we adopted, which we termed \nscoped memory scratchpads . 6.1 Complexities of Memory Management The most radical change to the Java \nprogramming model when using NoHeapRealtimeThread is that programmers are now required to manage their \nown memory. Being dissociated from general garbage collection requires the use of other means to recycle \nobject references. One way to do that is to use a memory pool (sometimes called a buffer pool ): a block \nof memory populated at initialization time with pre-allocated objects, often of the same type. A client \nthat needs a particular kind of object obtains one from a pool, assigns it a value, and uses it. Eventually \nthe object must be released back to the pool, thereby making it available for reuse. 6.1.1 Shared Pools \nIn our component architecture data needs to flow among separate component objects through well-defined \ninterfaces. In ordinary Java it is natural and efficient to pass values by reference. Thus, when using \nmemory pools, a natural approach is to have a single shared memory pool for each type of object that \nparticipates in inter-component communication. A component that produces information obtains a free object \nfrom the pool, assigns a new value to the object, and passes a reference to the object across an interface. \nThe receiving component uses the reference to access the object and, eventually, releases the object \nback to the pool, as depicted in Figure 9. Since a memory pool can exist in scoped memory, a further \nobvious requirement is that the receiving components have access to the memory area in which the object \nwas allocated. Also, since components may run on separate threads, pool operations must be multithread-safe. \n Figure 9. In a shared memory pool multiple clients share a single pool of objects of a given type, obtaining \nobjects as needed and releasing them back to the pool when no longer needed. For object references that \ncross component boundaries we considered a scheme in which objects in the pool would contain a reference \ncount, which the application code would be partially responsible for maintaining. The counter would be \nupdated through synchronized methods. Whenever a reference to an object was obtained, either from the \npool or from another component, the counter would have to be incremented. The objects would have a method \nthat atomically decremented the counter and released the object back to the pool if the counter went \nto zero. It would be the user's responsibility to call that method. Although we realize that using a \nsimple reference count to solve this problem might not be theoretically possible in the general case, \nwe felt that due to the structure imposed by the MDS architecture and our component model we could reasonably \nrestrict the movement of object references across component boundaries and provide some automation in \ncontrolling the reference count such that simple reference counting would prove sufficient. 6.1.2 Restricted \nPools A simpler and safer pattern involving memory pools is to restrict the visibility of a pool to within \none component. Each component that needs to use objects of a given type has its own pool of objects of \nthat type. To simplify object reference reuse we constrained the architecture so that references to an \nobject would never be allowed to pass across component boundaries. This requires a mechanism for copying \ndata across an interface instead of passing a reference. Copying eliminates the need for general reference \ncounting since there is never more than one user of a given object, but it still requires a strict discipline \nwithin the component to recycle object references in an organized manner. 6.1.3 Complexities of Memory \nPools Memory pools bring back vulnerabilities to the same kind of programmer error that is prevalent \nin any language requiring manual memory management. Pools require programmer discipline to return every \nobject back to the pool when it is no longer being used. Two kinds of mistakes can occur. First, any \nfailure to return an object to its pool results in a memory leak, and the hardest memory leaks to find \nare the slow ones. Second, and worse, an application may give an object back to the pool but continue \nto use the reference (accidentally, of course). That kind of bug can be extraordinarily hard to find \nbecause the effects may be non-local. For these reasons we favor restricted memory pools so that memory-usage \nverification can be localized to individual components. 6.1.4 Using Core / 3rd Party libraries in Scope \nJava programmers are accustomed to using the wealth of the Java core libraries and even 3rd party libraries \nto construct applications. For the most part these libraries take for granted that they are being used \nin a VM that has GC. This can be a big problem when used in conjunction with NoHeapRealtimeThread and \nScopedMemory since ScopedMemory is finite.  6.2 Scoped Memory Scratchpads As stated earlier, the RTSJ \nprovides a kind of non-heap memory area termed ScopedMemory. A ScopedMemory area can be entered by a \nthread, its critical section is bounded by a java.lang.Runnable, and any allocation that Runnable does \nafter having entered the memory area and until leaving it by exiting its run method comes out of that \nmemory area. When all Runnables exeunt the memory area, the scope will be emptied before being entered \nagain. We considered a scheme in which each component has its own memory area, which we call a scratchpad. \nThe component s run method is called in the scope of the scratchpad memory area. When the component calls \nanother component to get data, the callee can do a new to allocate an object to return, and that object \nis placed in the caller s scratchpad since the callee is running by call from the run method of the caller. \nWhen the call returns, the caller must either finish with the returned object before leaving the run \nmethod (i.e. exiting the scope), or make a copy of the object into a more permanent location before exiting \nthe scope. By using a wrapper on the component that handles the mechanics of entering the scope, the \ncomponent s logic need not be aware that it is running in the scope of a scratchpad memory area, or even \nthat it is running under a RTSJ-compliant VM instead of a regular JVM. It must however not keep references \nreturned from an interface call and expect them to be valid the next time the component is run. Components \nthat receive data by being called must only satisfy the requirement that they not hold onto a reference \nreceived in the call; if they need to have the object after returning, they must copy it. To avoid memory \nallocation a restricted pool is used per component for this copy. The design of our real-time thread \nwrapper is shown in Figure 10.  6.3 How do Scoped Memory Scratchpads simplify the RTSJ programming model? \nWe selected scoped memory scratchpads as the best combination of agreeable Java style, safety from programmer \nerror, and real\u00adtime determinism. Scoped memory is agreeable in the sense that Java programmers can allocate \nand manipulate objects in a familiar manner (using new ), without GC interference, but they must be cognizant \nof memory access restrictions and they must ensure that all threads exit the scoped memory in order to \nempty it. Scoped memory scratchpads do depend on programmer discipline to ensure that all threads exit \na scope in order to empty it, but this aspect can be handled in our framework code, rather than adaptation \ncode. Although restricted memory pools are still used in conjunction with the scratchpad approach, and \nthus require the discipline of releasing objects back to the pool, all of the pool management is confined \nto a single component and is thus much easier to design and verify. This design also allows the use of \ncore and 3rd party libraries without concerns of memory leaks since, on exit of the Runnables, transient \nobjects are released in a more stack-based approach to garbage collection.  7. FRAMEWORK SOFTWARE BENEFITS \nIn the Golden Gate/Mission Data System approach to software development, we make a clear distinction \nbetween aspects of the flight system that support particular objectives of a mission versus services \nand functionality that are common across most missions. A domain expert develops the functional aspects \nof the flight software such as control algorithms or hardware driver implementations. Such activities \nare developed more effectively when they are left unburdened by the prevalent considerations of communication \nbetween flight software subsystems, software deployments, or the complexities of underlying technologies. \nOne of the goals of Golden Gate is to relieve the application programmer of these concerns by addressing \nthem with a set of common services that are encapsulated in a framework and programming model, within \nthe context of a component/connector architectural style. This architecture style supports the separation \nof computation and communication, captured respectively in first class software entities of components \nand connectors. The adaptation of Golden Gate/MDS involves implementing mission\u00adspecific functionality \nin components and mediating communication of these functional elements to connectors. An objective of \nthe Golden Gate/MDS model is to focus the adapter s work solely on domain-specific implementation, while \ndelegating common framework patterns to a set of generic services accessible via supporting APIs. For \nthe Golden Gate project, RTSJ/Java-specific issues such as memory management and communication between \nhard and soft real time subsystems were primary candidates for framework encapsulation. In reasoning \nabout the component scoped memory scratchpad methodology, we viewed the component as a state machine, \nwhose execution is a set of state transitions, during which memory usage is finite and not persistent \noutside the scope of the execution. The component state undergoes changes based on its executions and/or \nexecutions associated with components that communicate with it. Hence, in the context of memory management, \na component has a dual task: it must manage its mutable state in a persistent manner while managing objects \nof transient nature allocated during its execution. The use of the scoped memory construct of the RTSJ \nas a scratchpad for execution provided a solution for these short-lived component executions. In order \nto manage the complexity of using the RTSJ scoped memory construct, we created a wrapper to easily specify \nand configure the memory area used and type of thread that would execute the component s methods. The \nresult is a programming model that was flexible enough to easily interchange between execution in RTSJ \nscoped memory scratchpad and heap memory and their respective thread types. As previously stated, with \nthe exception for some programmer discipline related to data copying, this model allows for memory allocation \ntechniques in the component that are equivalent to usual Java. By maintaining a clear separation between \nexecution specifications and functional code, the potential interleaving of these distinct properties \nis reduced the domain expert can leverage a reliable set of framework services to specify execution \nattributes while being removed from technical details of the RTSJ that implement them. 8. SUMMARY Most \nreal-time applications have timeliness requirements that can be categorized into non real-time, soft \nreal-time, and hard real\u00adtime. The Real-Time Specification for Java (RTSJ) was designed to support all \nthree categories in a single virtual machine. What practitioners must understand, however, is that the \ntraditional Java programming model, which relies on a garbage collector for automated memory management, \ncannot be applied in the hard real-time parts. Specifically, the RTSJ defines a special kind of thread \nnamed NoHeapRealtimeThread that runs without any latency due to garbage collection because it does not \nuse heap memory. Instead, it must use non-heap memory in the form of ScopedMemory and/or ImmortalMemory. \nUsage of such memory entails a degree of manual memory management, with design tradeoffs among programming \ncomplexity, verifiability, and memory and processor overhead. This report describes a point in that design \nspace that we feel represents a good combination of Java style and verifiability. This design supports \nnatural new-based creation of objects by running hard real-time components in scoped memory. Since objects \ncreated in scoped memory are subsequently discarded through scope emptying, a means must be provided \nfor preserving information that is needed for longer times. For that purpose the design employs memory \npools that are restricted in the sense that references to pool objects for component x are contained \nwithin component x. This choice significantly improves verifiability compared to shared pools, albeit \nat the cost of copying data that moves between components. Finally, our design is supported by framework \nsoftware that encourages application developers to follow the recommended approach and also shields them \nfrom some of the complexities of the RTSJ facilities. Other designers may choose a different point in \nthe design space for their hard real-time activities, based on their posture toward programming style, \nverifiability, and overhead. Regardless, a supporting framework will help application programmers follow \na consistent approach. 9. FUTURE WORK Much of our current work is focused on measurements of performance \nand resource usage that can be compared between two software platforms: RTSJ/Linux and C++/VxWorks. These \nmetrics include memory footprint, timing jitter, floating-point throughput, memory allocation time, and \nboot-up time. We are also measuring RTSJ-specific quantities such as the overhead for entering/exiting \nscoped memory and for firing asynchronous events. This work leverages and organizes a substantial body \nof performance tests from several sources including Boeing Corporation, the Air Force Research Laboratory, \nSun Microsystems Laboratories, the Open VM project, and Washington University in St. Louis. We have just \nbegun looking into some interesting work at Washington University that explores using AspectJ and additional \nprototype tools to automatically build memory area scope structure into perfectly regular Java code [5]. \nThis holds promise for the future. We will keep on the lookout for garbage collectors made specifically \nfor RTSJ, like perhaps limited scope collectors with predictable running times. See [6] for a discussion \nof RTSJ\u00adspecific GC optimizations. Also, we will explore the regulated garbage collection option further \nsuch as the work described in [7]. 10. ACKNOWLEDGEMENTS This work was performed jointly by the Jet Propulsion \nLaboratory of California Institute of Technology, by Sun Microsystems Laboratory, and by Carnegie Mellon \nUniversity. The work at JPL was performed under contract with the National Aeronautics and Space Administration. \nThe JPL team thanks the Office of the Chief Scientist for funding under the Research &#38; Technology \nDevelopment Program, and the strong support of the R&#38;TD committee on Advanced Software Techniques \n&#38; Methods Initiative. The authors also wish to acknowledge support through the High Dependability \nComputing Program from NASA Ames cooperative agreement NCC-2-1298. 11. REFERENCES [1] Greg Bollella et \nal, The Real-Time Specification for Java, Addison-Wesley, 2001. http://rtj.org [2] Project GoldenGate. \nhttp://research.sun.com/projects/goldengate/ [3] http://www.cs.unc.edu/rtss2002/absBollela.html [4] Dvorak, \nD., Rasmussen, R., Reeves, G., and Sacks, A. Software Architecture Themes in JPL s Mission Data System. \nProceedings of the 2000 IEEE Aerospace Conference, Big Sky, Montana, March, 2000. [5] Cytron, R., Deters, \nM., Automated Discovery of Scoped Memory Regions for Real-Time Java. http://www.cs.wustl.edu/~mdeters/doc/papers/automated_dis \ncovery_of_scoped_memory_regions_abstract.html . [6] Cytron, R., White Paper: RTSJ Memory Management. \nhttp://ww.cs.wustl.edu/~cytron/WhitePaper00/wp.html . [7] Kim, T., Chang N., Kim, N., Shin, H., Scheduling \nGarbage Collection for Embedded Real-Time Systems. http://citeseer.nj.nec.com/523601.html . [8] High \nDependability Computing Program, http://hdcp.org [9] TimeSys Corporation, http://www.timesys.com/  \n \n\t\t\t", "proc_id": "949344", "abstract": "The Real-Time Specification for Java (RTSJ) provides facilities for deterministic, real-time execution in a language that is otherwise subject to variable latencies in memory allocation and garbage collection. A major consequence of these facilities is that the normal Java practice of passing around references to objects in heap memory cannot be used in hard real-time activities. Instead, designers must think carefully about what type of non-heap memory to use and how to transfer data between components without violating RTSJ's memory-area assignment rules. This report explores the issues of programming with non-heap memory from a practitioner's view in designing and programming real-time control loops using a commercially available implementation of the RTSJ.", "authors": [{"name": "Greg Bollella", "author_profile_id": "81100615407", "affiliation": "Sun Microsystems Laboratories, Palo Alto, CA", "person_id": "PP14212053", "email_address": "", "orcid_id": ""}, {"name": "Tim Canham", "author_profile_id": "81100154759", "affiliation": "California Institute of Technology, Pasadena, CA", "person_id": "P643492", "email_address": "", "orcid_id": ""}, {"name": "Vanessa Carson", "author_profile_id": "81100278799", "affiliation": "California Institute of Technology, Pasadena, CA", "person_id": "P643496", "email_address": "", "orcid_id": ""}, {"name": "Virgil Champlin", "author_profile_id": "81100373251", "affiliation": "Carnegie Mellon University, Moffett Field, CA", "person_id": "P643499", "email_address": "", "orcid_id": ""}, {"name": "Daniel Dvorak", "author_profile_id": "81539235056", "affiliation": "California Institute of Technology, Pasadena, CA", "person_id": "PP309418000", "email_address": "", "orcid_id": ""}, {"name": "Brian Giovannoni", "author_profile_id": "81100655626", "affiliation": "Carnegie Mellon University, Moffett Field, CA", "person_id": "P643432", "email_address": "", "orcid_id": ""}, {"name": "Mark Indictor", "author_profile_id": "81100104988", "affiliation": "California Institute of Technology, Pasadena, CA", "person_id": "P643472", "email_address": "", "orcid_id": ""}, {"name": "Kenny Meyer", "author_profile_id": "81100568976", "affiliation": "California Institute of Technology, Pasadena, CA", "person_id": "P643464", "email_address": "", "orcid_id": ""}, {"name": "Alex Murray", "author_profile_id": "81540169056", "affiliation": "California Institute of Technology, Pasadena, CA", "person_id": "P643421", "email_address": "", "orcid_id": ""}, {"name": "Kirk Reinholtz", "author_profile_id": "81100209872", "affiliation": "California Institute of Technology, Pasadena, CA", "person_id": "P161956", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949443", "year": "2003", "article_id": "949443", "conference": "OOPSLA", "title": "Programming with non-heap memory in the real time specification for Java", "url": "http://dl.acm.org/citation.cfm?id=949443"}