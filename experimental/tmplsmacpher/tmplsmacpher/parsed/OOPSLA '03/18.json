{"article_publication_date": "10-26-2003", "fulltext": "\n MetaEdit+: Defining and Using Domain-Specific Modeling Languages and Code Generators Juha-Pekka Tolvanen \nMetaCase Consulting Ylistonmaentie 31 FIN-40500 Jyvaskyla, Finland +358 14 4451406 jpt@metacase.com \nABSTRACT MetaEdit+ is an environment that allows building modeling tools and generators fitting to application \ndomains, without having to write a single line of code. The capability to define modeling tools and generators \nis relevant as it provides the ability to raise the abstraction of design work from code to domain concepts, \nand a raise in abstraction leads to an imminent raise in productivity, as illustrated by the past years' \nexperiences. In domain-specific modeling and MetaEdit+, one expert defines a domain-specific language \nas a metamodel containing the domain concepts and rules, and specifies the mapping from that to code \nin a domain-specific code generator. For the method implementation, MetaEdit+ provides a metamodeling \nlanguage and tool suite for defining the method concepts, their properties, associated rules, symbols, \nchecking reports, and generators. Once the expert defines a modeling method, or even a partial prototype, \nthe rest of the team can start to use it in MetaEdit+ to make models with the modeling language and the \nrequired code is automatically generated from those models. Based on the metamodel, MetaEdit+ automatically \nprovides CASE tool functionality: diagramming editors, browsers, generators, multi\u00aduser/project/platform \nsupport, etc. The MetaEdit+ demo will focus on showing how the domain\u00adspecific languages and generators \nare made; complete with several examples of domain-specific methods and related code generators. Categories \nand Subject Descriptors D 2.2 [Design Tools and Techniques]: Computer-aided software engineering (CASE) \nGeneral Terms: Design, Languages. Keywords Metamodel; domain-specific modeling; code generators. 1. \nINTRODUCTION One tool fits all that seems to be the common principle followed by many tools on the market \ntoday. Alternatively, MetaEdit+ is an environment that enables you to build your own modelling tools \nand code generators fitting to your own domain without having to write a single line of code. Copyright \nis held by the author/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. \n Matti Rossi Helsinki School of Economics FIN-00100 Helsinki, Finland +358 9 43138996 mrossi@hkkk.fi \nThe capability to define modelling and generator tools is relevant as it provides the possibility to \nraise the abstraction of design work from code to domain concepts, and a raise in abstraction leads to \nan imminent raise in productivity, as illustrated by the past years experiences, such as those listed \nin the SEI Product Line Hall of Fame. Empirical studies such as [1] consistently back up this observation. \nWith these benefits, it is little wonder that there is a growing interest in domain-specific modelling, \nas shown by workshops at OOPSLA [2] and this year s theme of Domain-Driven Development. 2. DOMAIN-SPECIFIC \nMODELLING In domain-specific modelling and MetaEdit+, one expert defines a domain-specific language containing \nthe domain concepts and rules, and specifies the mapping from that to code in a domain\u00adspecific code \ngenerator. As soon as the expert defines a modelling method, or even a partial prototype, the team can \nstart to use it in MetaEdit+ to make models with the modelling language and code is automatically generated \nfrom those models. Developers no longer need to solve the problem of manually mapping domain ideas into \nquality code by themselves, time after time. As the modelling language is based on the already known \nand used domain concepts and rules, it is easy to remember and understand by all developers. 3. METACASE \nTECHNOLOGY For method implementation, MetaEdit+ provides a metamodeling language and tool suite for defining \nthe method concepts, their properties, associated rules, symbols, checking reports and generators with \nease [3]. The method definition is stored as a metamodel to the MetaEdit+ repository allowing future \nmodifications, which reflect automatically to models and generators. MetaEdit+ follows the given method \ndefinition and automatically provides full CASE tool functionality: diagramming editors, browsers, generators, \nmulti-user/project/platform support, etc. Whole team can immediately start to edit designs as graphical \ndiagrams, matrices or tables, switching between views according to user needs. User can browse designs \nwith filters, apply components, link models to other designs following domain rules, and check models \nwith various pre/user-defined reports. The results of modelling can be published to the web or word processors, \nand generated into code for your product. 4. CODE GENERATION In contrast to the generic code generators \nprovided with standard CASE tools, the basis of code generation in domain-specific modeling is the domain \nitself. As with product line engineering [4] the architecture and patterns of code found in implementations \nfor that domain are analyzed to determine code commonalities and variabilities over a product family \n[5]. The variabilities form a significant source of information when designing what information needs \nto be stored in models. For each variability point, there must be a corresponding point in a model where \ninformation can be stored about the choice of value for this product variant. The code generator s task \nis to transform the models into code, often largely in the form of calls to components using these values \nas arguments. Commonalities are abstracted out into framework code: a layer of code between the generated \ncode and the platform and standard libraries [6]. This information is thus not included as part of the \nmodels why should every model include something that is the same for all models? Instead, the framework \ncode is linked in with that generated from the models. 5. CONCLUSION Domain-specific modeling provides \nsignificant increases in productivity, especially for product families. Providing tool support for such \na modeling method has previously required at least a man-year of work. A metaCASE tool such as MetaEdit+ \nreduces the time needed down to the order of days or weeks. Industrial experiences such as Nokia [7] \nshow productivity gains of 5-10 times, and comparable decreases in the time needed for new users to become \nproductive. 6. REFERENCES [1] Kieburtz, R. et al., A Software Engineering Experiment in Software Component \nGeneration, Proceedings of 18th International Conference on Software Engineering, Berlin, IEEE Computer \nSociety Press, March, 1996. [2] OOPSLA Workshop on Domain-Specific Visual Languages (DSVL'01), Juha-Pekka \nTolvanen, Steven Kelly, Jeff Gray, Kalle Lyytinen (eds.), University of Jyv\u00e4skyl\u00e4 2001. [3] Kelly, S., \nLyytinen, K., Rossi, M., MetaEdit+: A fully configurable multi-user and multi-tool CASE and CAME environment, \nAdvanced Information Systems Engineering, proceedings of the 8th International Conference CAISE'96, Constantopoulos \net al (Ed.), Springer-Verlag, 1996. [4] Weiss, D., Lai, C. T. R., Software Product-line Engineering, \nAddison Wesley Longman, 1999. [5] Domain-Specific Application Frameworks, Mohamed E. Fayad and Ralph \nE. Johnson (Eds.), Wiley 1999. [6] Pohjonen, R., and Kelly, S., Domain-Specific Modeling, Dr. Dobbs Journal, \nAugust 2002. [7] MetaCase, Benefits of MetaCASE: Nokia Mobile Phones Case Study, http://www.metacase.com/papers/ \n ACKNOWLEDGEMENTS The authors would like to thank Slava Arion and Steven Kelly for their help in the \npreparation of this article.  \n\t\t\t", "proc_id": "949344", "abstract": "MetaEdit+ is an environment that allows building modeling tools and generators fitting to application domains, without having to write a single line of code. The capability to define modeling tools and generators is relevant as it provides the ability to raise the abstraction of design work from code to domain concepts, and a raise in abstraction leads to an imminent raise in productivity, as illustrated by the past years' experiences.In domain-specific modeling and MetaEdit+, one expert defines a domain-specific language as a metamodel containing the domain concepts and rules, and specifies the mapping from that to code in a domain-specific code generator. For the method implementation, MetaEdit+ provides a metamodeling language and tool suite for defining the method concepts, their properties, associated rules, symbols, checking reports, and generators. Once the expert defines a modeling method, or even a partial prototype, the rest of the team can start to use it in MetaEdit+ to make models with the modeling language and the required code is automatically generated from those models. Based on the metamodel, MetaEdit+ automatically provides CASE tool functionality: diagramming editors, browsers, generators, multi-user/project/platform support, etc.The MetaEdit+ demo will focus on showing how the domain-specific languages and generators are made; complete with several examples of domain-specific methods and related code generators.", "authors": [{"name": "Juha-Pekka Tolvanen", "author_profile_id": "81100508185", "affiliation": "MetaCase Consulting, Jyvaskyla, Finland", "person_id": "PP39046191", "email_address": "", "orcid_id": ""}, {"name": "Matti Rossi", "author_profile_id": "81100497433", "affiliation": "Helsinki School of Economics, Helsinki, Finland", "person_id": "PP39045715", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949365", "year": "2003", "article_id": "949365", "conference": "OOPSLA", "title": "MetaEdit+: defining and using domain-specific modeling languages and code generators", "url": "http://dl.acm.org/citation.cfm?id=949365"}