{"article_publication_date": "10-26-2003", "fulltext": "\n Time Conscious ObjectsTM: A Domain-Specific Framework and Generator Jorn Bettin Jeff Hoare jorn.bettin@softmetaware.com \njeff.hoare@softmetaware.com SoftMetaWare PO Box 617 Waiheke Island Auckland, New Zealand ABSTRACT In \nmost business software systems the time dimension of business objects plays a significant role. Time \nis a crosscutting concern that is hard to separate from other business logic. We have developed a toolkit \nthat allows existing business application systems to be extended with time-conscious behavior in a non-intrusive \nway by factoring out all aspects of time-related behavior into a framework and a set of classes that \nis distinct from the existing code base. The Time Conscious ObjectsTM (TCOTM) toolkit is currently implemented \nin JavaTM, but through the use of generation technology the toolkit can easily be made available in any \nlanguage that supports polymorphism. Categories and Subject Descriptors D.2.2 [Design Tools and Techniques]: \nModel Driven Architecture -domain-specific architectures.  General Terms Design, Standardization, Languages. \n Keywords Model Driven Architecture (MDA), domain-specific languages, domain-driven development, time, \ntemporal, versioning, undo, redo, auditability, logging. 1. INTRODUCTION We start with a few definitions \nthat provide us with a useful terminology for the domain. Definition: the creation time of an object \nis a timestamp (date and time) taken when the object was constructed within the system. Definition: In \nthe context of this article we use the term interval consistently with (a) the mathematical definition \nof a set of real numbers between two numbers either including or excluding one or both of them and (b) \nthe physical definition of a space of time between events . When talking about intervals, we use the \nterminology of start time and end time to describe the timestamps (date and time) which define the start \nand end of the interval. Definition: an object with lifetime behavior is an object that knows about its \nstate and its state changes over time. Definition: the lifetime of an object is the interval during which \nthe object is considered to exist by the business logic of the system. The concept of lifetime extends \nto object states. Objects and object states Copyright is held by the author/owner(s). OOPSLA 03, October \n26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. may exist in the system at points \nin time when they are not yet active or when they are no longer active . Constraints built into lifetime \nbehavior ensure that a system object can t violate the physical properties of time: 1. The start time \nfor new object states is always greater than, or equal to the creation time of the state. 2. The set \nof lifetimes of all the states of an object always forms a  contiguous interval. As opposed to real-time \nsystems, business application systems typically do not have real-time information exchange with real\u00adworld \nobjects, which leads to the following important definition. Definition: an object with baseline behavior \nis an object that knows about its current and historic representations in the system. The difference \nbetween lifetime behavior and baseline behavior may seem to be subtle, but it is critical in accurately \nmodeling time within software systems. When lifetime behavior is combined with baseline behavior the \nfirst constraint on lifetime behavior is removed, as the history of back-dated changes is accurately \nrecorded as part of baseline behavior, ensuring auditability.  it results in the ability to accurately \nmodel the lifecycle of real\u00adworld objects in the context of a system where information exchange with \nthe real world only occurs at discrete points in time.  Definition: a time-conscious object is an object \nthat implements aspects of the notion of time in its behavior. An object with time\u00adconscious behavior \nis an object with lifetime behavior, or baseline behavior, or the combination of both sets of behavior. \n 2. TYPICAL APPLICATION SCENARIOS The TCO framework has the potential to drastically simplify application \ncode that involves the aspect of state changes of business objects, in particular in those cases where \nboth lifetime and baseline behavior are required. Consequently time-conscious objects can have a major \nimpact on the quality and maintainability of applications by eliminating the complexity of dealing with \nthe time dimension. This is the case for example in all time-based billing systems in the telecommunications \nand utility industries, in the insurance industry, and in the modeling of parts in ERP and manufacturing \nsystems, where product composition changes over time, as new [product] components get developed and are \nphased into production. The TCO toolkit has been explicitly designed to allow non-intrusive and incremental \nintegration into existing systems. It allows existing classes to be extended with time-conscious behavior, \nwhich then enables application code in the next higher architectural layer to be refactored and simplified. \nExisting business logic can be incrementally modified to take advantage of time-conscious behavior in \nthe extended classes. Structurally TCO can be divided into three components: 1. A small framework that \nprovides support for the notion of intervals, lifetime behavior, and baseline behavior, 2. A tool that \nallows existing class structures to be annotated with high-level design information related to the required \nlevel of time-conscious behavior -giving the designer the ability to trade-off granularity of time-consciousness \nagainst performance requirements, 3. A generator which automates the extension of existing class  structures \nand the integration with the TCO framework. At compile-time and run-time only the first and the third \ncomponent are relevant, and of course the generated glue code which is encapsulated in a separate small \nsubsystem for each time-conscious class. The only assumption made about the architecture of existing \napplications is that classes which need to be made time-conscious provide modifier and accessor methods \nto the properties that the user intends to declare as time-conscious. TCO is geared towards use in MDA\u00ae \n[1] approaches where system functionality is expressed in Platform Independent Models (PIMs) at a high \nlevel of abstraction [2]. Time-conscious behavior is specified in a PIM by tagging classes as having \nlifetime and/or baseline behavior. The TCO toolkit then uses this information to generate the code required \nto hook into the TCO framework. To take into account practical performance and object size implications, \nthe commercial version of TCO will allow users to tag individual properties (attributes and associations) \nof classes as time-conscious, enabling the TCO generator to produce code that is optimized for a specific \ncontext. An interesting side effect of incrementally refactoring existing code to leverage time-conscious \nobjects is the impact on the business object model of the system in question. In each case where previously \nthe business object model contained a pattern of class Foo and a related class FooVersion with an aggregation \nlink between the two classes, the introduction of time-conscious objects eliminates the need for class \nFooVersion by providing a time\u00adconscious extension TcFoo of class Foo. As a consequence new code can \ntake advantage of time-conscious behaviour in TcFoo, but all existing code and all code that is not interested \nin the time dimension works with existing class Foo. 3. FUNCTIONALITY The TCO framework provides users \nwith the ability to specify and retrieve property values using standard modifier and accessor methods \nin combination with appropriate specification of associated intervals. This is the trivial part of TCO. \nThe interesting part of TCO consists of functionality to iterate over intervals and baselines, and to \ncompare the properties of two objects over time, iterating over the results of the comparison. Let the \nintervals over which objects a and b are valid within the business logic of a system be denoted by sets \nA and B correspondingly. The result of a comparison of two objects with lifetime behavior is shown in \nfigure 1. The graphical notation we use for open and closed ends of intervals is derived from the usual \nmathematical notation of [a1, a2] for the closed interval that includes a1 and a2, and [a1, a2) for the \nhalf open interval that includes a1 and excludes a2 etc. The pi in figure 1 denote the property values \nof an object over specific intervals. Object a p1 p2 p3 p4 p5 p6 Object b p1p2p7 p4 p8 p6 (A . B)-B \n  p1 p2p3 p5 p6 Comparison A n B Object p1p2 p4 p6 a.compare(b) (A . B)-A p1 p2 p7p4 p8 p6 Figure 1 \nThe TCO framework provides the ability to selectively iterate over the differences, commonalities, or \nall state changes across a and b. TCO emphasizes intervals and the ability to manipulate state information \nassociated with intervals in an intuitive way. For calculations involving the time dimension, TCO allows \nswitching to a perspective where the flow of time is the primary concern, and where object structure \nis a secondary concern. TCO can be used to standardize and replace existing implementations of versioning \nfunctionality. Even if an existing implementation is standardized, TCO adds significant value by raising \nthe level of abstraction of the versioning API . A related topic is undo/redo functionality. TCO can \nsimplify the implementation of such functionality by allowing users to work with objects that represent \nsnapshots in time. When handling object structures, the user can construct a snapshot by specifying the \ndesired point in time, without having to be concerned with the start time and end time of individual \nobject states. In the scenario of reactivating old object states, TCO preserves full auditability. 4. \nFURTHER WORK Currently further work is in progress to integrate time-conscious objects with other concerns \nsuch as persistence and distribution. The intention is to create the ability to easily integrate with \nthe persistence mechanisms of existing systems and to extend the interfaces of time-conscious objects \nwith behavior that is relevant when large time-conscious objects need to be processed in a distributed \nenvironment. The future direction of TCO will be determined by the feedback we get from users and potential \nusers. Different types of systems may have specific time-dimension related requirements that will either \nbe addressed by expanding the base functionality of TCO, or by creating domain-specific variants of TCO. \n 5. REFERENCES [1] Model Driven Architecture. www.omg.org/mda/ [2] J. Bettin. Raising the level of abstraction \nof design models. OOPSLA 2001 Companion, (October 2001).  \n\t\t\t", "proc_id": "949344", "abstract": "In most business software systems the time dimension of business objects plays a significant role. Time is a crosscutting concern that is hard to separate from other business logic. We have developed a toolkit that allows existing business application systems to be extended with \"time-conscious\" behavior in a non-intrusive way by factoring out all aspects of time-related behavior into a framework and a set of classes that is distinct from the existing code base. The Time Conscious ObjectsTM (TCOTM) toolkit is currently implemented in JavaTM, but through the use of generation technology the toolkit can easily be made available in any language that supports polymorphism.", "authors": [{"name": "Jorn Bettin", "author_profile_id": "81100085010", "affiliation": "Waiheke Island, Auckland, New Zealand", "person_id": "P643461", "email_address": "", "orcid_id": ""}, {"name": "Jeff Hoare", "author_profile_id": "81100032417", "affiliation": "Waiheke Island, Auckland, New Zealand", "person_id": "P643456", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949417", "year": "2003", "article_id": "949417", "conference": "OOPSLA", "title": "Time conscious objects&#8482;: a domain-specific framework and generator", "url": "http://dl.acm.org/citation.cfm?id=949417"}