{"article_publication_date": "10-26-2003", "fulltext": "\n Visualizing Class Interfaces with Formal Concept Analysis Uri Dekel Yossi Gil ISRI, School of Computer \nScience Department of Computer Science Carnegie Mellon University Technion Israel institute of Technology \nPittsburgh, PA 15213 Haifa, Israel 32000 udekel@cs.cmu.edu yogi@cs.technion.ac.il  ABSTRACT Our research \npromotes the use of a mathematical concept lattice as a novel visualization of the interfaces of JAVA \nclasses. The binary relation of accesses between methods and .elds, from which the lattice is constructed, \nserves as a heuristic for an automatic fea\u00adture categorization. We demonstrate in a detailed real-life \ncase study that such a lattice is valuable for understanding and reverse\u00adengineering purposes, in that \nit helps reason about the interface and structure of the class and .nd errors in the absence of source \ncode. We also show that if the source code of the class is available, then the lattice can be of assistance \nin selecting an ef.cient reading or\u00adder. Categories and Subject Descriptors D.2.3 [Programming Languages]: \nLanguage Constructs and Fea\u00adtures Classes and objects; D.2.7 [Software Engineering]: Distri\u00adbution, Maintenance, \nand Enhancement Documentation, restruc\u00adturing, reverse engineering, and reengineering. General Terms \nDocumentation, Languages Keywords Concept Analysis, Classes, Feature Categorization, Documenta\u00adtion, \nReverse-Engineering Extended Abstract The code listings of large classes can span dozens of pages, and \nalthough many development environments include class browsing tools, most follow the style of offering \na simple alphabetical list of the features of the class. The question which drives our curiosity is whether \nthe cohesive nature of a class can be used to present its features in a more meaningful order and thus \nto systematically reveal its structure? Our answer is based on applying formal concept analysis (FCA) \nto the task of studying individual OO classes. FCA, germinated by Copyright is held by the author/owner. \nOOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. Birkhoff [2] and \nconsiderably enriched by Ganter and Wille [14], is a mathematical technique for clustering abstract entities \nknown as formal objects that share common formal attributes into for\u00admal concepts organized in a concept \nlattice. This technique found many different applications in software engineering, such as con\u00ad.guration \nmanagement [11], debugging [1], searching software li\u00adbraries [7], and constructing class hierarchies \n[5, 12]. A very prominent such application is in studying legacy, non-OO code, usually with the purpose \nof .nding modules, and even organizing these in a hierarchical, OO-structure [8, 10, 13]. In such applications, \nthe formal objects are often the global variables of the program, while the formal attributes are procedures \nor subroutines. A formal concept is then a maximal set of variables and a maximal set of procedures such \nthat all variables are used by all procedures and all procedures use all variables. Formal concepts or \nclusters of concepts serve as candidates for modules or classes, while the partial order relation, depicted \nin the lattice, makes candidates for a containment relationship between modules or module abstraction \nlevels. Thus, our research makes the next obvious step: apply FCA in a similar fashion to OO code, where \n.elds take the role of global variables and methods that of procedures or programs. In doing so we can \nreveal the structure and improve our understanding of classes. Speci.cally, our .rst contribution is \nin describing the context of a class abstraction, and showing that it is useful for effective class analysis. \nIn essence, this abstraction is a tabular representation of the binary relation method accesses .eld \nof the class. For exam\u00adple, Table 1 represents the context of Pnt3D,a simple JAVA class which represents \npoints in space. Check marks denote that a .eld is accessed, directly or indirectly, by a method. attributes \ngetX setX getY setY setXY getColor setColor Pnt3D getZ setZ setXYZ draw objects x . . . . . . y . . . \n. . . z . . . . . color . . . . Table 1: Context of the Pnt3D class Our second contribution is in augmenting \nthe chest of tools avail\u00adable to class users and reverse engineers with the class sparse lat\u00adtice abstraction, \na visual and topological encoding of the context abstraction. As can be seen in Figure 1, the lattice \npartitions the methods into concepts according to their use of .elds, thus serv\u00ading as a heuristic for \nan automated feature categorization [9]. The methods in a particular concept use all the .elds in that \nconcept and all the concepts below it. Pnt3D() C8 draw() color getColor() setColor() C2 x getX() setX() \nC3 y getY() setY() C4 z getZ() setZ() C6 C1  Figure 1: Sparse lattice of the Pnt3D class. We argue that \nthe sparse lattice provides an even more effec\u00adtive means of examining the class context, even though \nit presents equivalent information. For example, Figure 1 highlights the struc\u00adtural separation between \nthe management of color and coordinates, as well as the asymmetry between the three coordinates. This \nnot only reveals a weakness in the interface of the class, but also pro\u00advides hints on its evolution. \nOf course, we do not expect these abstraction to be very useful in such small classes. Large classes, \nwhose interface may constitute hundreds of features and dozens of .elds are the primary candidates to \nenjoy the bene.ts of this technique. Investigation of large data sets con.rmed that such classes are \nfound in abundance. Our work describes both abstractions in depth, and explains why we expect them to \nbe useful as means to obtaining a general under\u00adstanding of a class, prior to more elaborate reverse-engineering, \nre\u00adengineering, or code-inspection efforts. The theoretical claims are supported, in part, by data obtained \nfrom an ensemble of circa 6,000 JAVA classes, as well as by a detailed case study and a preliminary user \nstudy. Another concrete contribution based on these abstractions, is an algorithm for selecting an ordering \nof the class methods for the purpose of a more effective code inspection. We argue that this algorithm \nis likely to place related methods together, and minimize the number of forward-references, as well as \nthe distance travelled by these references. We also describe the embedded call graph,an amalgam of sparse \nlattices and call graphs, which has the potential of combining the two visual methods to obtain new insights \nabout the class. While these techniques can be employed rapidly and indepen\u00addently, as con.rmed by our \npreliminary user study, we also offer a detailed 3-stage methodology for examining the interface, imple\u00admentation, \nand code, and apply it to a number of case studies [3]. An evidence to the ef.cacy of this methodology \nis that with no background and with minimal effort, we revealed problems which were con.rmed as new errors \nby the developers and were .xed in subsequent versions. While automatic tools may reveal some of the \nmore localized errors, our approach assists in discovering de\u00adlocalized problems which are more dif.cult \nto .nd and require an understanding of the class itself. In addition to theoretical work, we are currently \nworking on the development of interactive software tools and IDE accessories that realize our technique, \nsuch as an Eclipse [4] plug-in. Work on inte\u00adgration into documentation tools (e.g. [6]) is also in progress. \nWe are also exploring several new directions that build upon the foundations laid by this work. One such \ndirection is the application of our technique to the design of classes in CASE tools. We believe that \nthe process of adding features to a class, typically carried out by adding features to a list in a UML \nclass hierarchy diagram, can be more effective with a lattice-based interactive editor. Applica\u00adtions \nto the development of lattice-based class cohesion metrics are also being explored.  1. REFERENCES [1] \nG. Ammons, D. Mandelin, R. Bodik, and J. R. Larus. Debugging temporal speci.cations with concept analysis. \nIn Proceedings of the ACM SIGPLAN 03 Conference on Programming Language Design and Implementation,San \nDiego, CA, June 9-11 2003. ACM Press. [2] G. Birkhoff. Lattice Theory. Colloqulum Publications. American \nMathematical Society, Providence, RI, USA, 2nd edition, 1967. [3] U. Dekel. Revealing Java class structure \nwith concept lattices. Master s thesis, Technion Israel Institute of Technology, February 2003. [4] \nEclipse project homepage. http://www.eclipse.org. [5] R. Godin and H. Mili. Building and maintaining \nanalysis-level class hierarchies using galois lattices. In Proceedings of the 8th Annual Conference \non Object-Oriented Programming Systems, Languages, and Applications, pages 394 410, Washington, DC, USA, \nSept. 26 -Oct. 1 1993. [6] IBM java documentation enhancer. http://www. alphaworks.ibm.com/tech/docenhancer. \n [7] C. Lindig. Concept-based component retrieval. In Working Notes of the IJCAI-95 Workshop: Formal \nApproaches to the Reuse of Plans, Proofs, and Programs, pages 21 25, Montreal, Aug. 1995. [8] C. Lindig \nand G. Snelting. Assessing modular structure of legacy code based on mathematical concept analysis. In \n Proceedings ofthe 19th International Conference on Software Engineering, pages 349 359, Boston, MA, \nMay 1997. IEEE Computer Society Press. [9] B. Meyer. Reusable Software: The Base Object-Oriented Component \nLibraries. Prentice-Hall Object-Oriented. Prentice-Hall, 1994. [10] M. Siff and T. Reps. Identifying \nmodules via concept analysis. In Proceedings of the IEEE International Conference on Software Maintenance, \npages 170 179, Bari, Italy, Oct. 1997. IEEE Computer Society Press. [11] G. Snelting. Reengineering of \ncon.gurations based on mathematical concept analysis. ACM Transactions on Software Engineering and Methodology, \n5(2):146 189, 1996. [12] G. Snelting and F. Tip. Understanding class hierarchies using concept analysis. \nACM Transactions on Programming Languages and Systems, 22(3):540 582, 2000. [13] A. van Deursen and T. \nKuipers. Identifying objects using cluster and concept analysis. In Proceedings ofthe 21st International \nConference on Software Engineering, pages 246 255, Los Angeles, CA, May 1999. IEEE Computer Society Press. \n[14] R. Wille. Restructuring lattice theory: An approach based on hierarchies of concepts. In I. Rival, \neditor, Ordered Sets, pages 445 470. Reidel, 1982.  \n\t\t\t", "proc_id": "949344", "abstract": "Our research promotes the use of a mathematical <i>concept lattice</i> as a novel visualization of the interfaces of Java classes. The binary relation of accesses between methods and fields, from which the lattice is constructed, serves as a heuristic for an automatic <i>feature categorization</i>. We demonstrate in a detailed real-life case study that such a lattice is valuable for understanding and reverse-engineering purposes, in that it helps reason about the interface and structure of the class and find errors in the absence of source code. We also show that if the source code of the class is available, then the lattice can be of assistance in selecting an efficient reading order.", "authors": [{"name": "Uri Dekel", "author_profile_id": "81100230251", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "P643495", "email_address": "", "orcid_id": ""}, {"name": "Yossi Gil", "author_profile_id": "81100349003", "affiliation": "Technion -- Israel institute of Technology, Haifa, Israel", "person_id": "PP14124769", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949416", "year": "2003", "article_id": "949416", "conference": "OOPSLA", "title": "Visualizing class interfaces with formal concept analysis", "url": "http://dl.acm.org/citation.cfm?id=949416"}