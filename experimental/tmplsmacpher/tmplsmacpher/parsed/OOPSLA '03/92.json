{"article_publication_date": "10-26-2003", "fulltext": "\n Analyzing the Use of Interfaces in Large OO Projects Philip Mayer Information Systems Institute, Knowledge \nBased Systems, University of Hannover Appelstra\u00dfe 4 D-30167 Hannover, Germany pm@pmayer.net ABSTRACT \nUsing partial interfaces, i.e. interfaces that cover only a subset of the total set of published methods \nof a class, has several ad\u00advantages, among them being an increase in understandability of the code and \nextended substitutability of classes in frameworks. However, analysis of large frameworks such as the \nJava API suggests that partial interfaces are only sparsely used. We be\u00adlieve that this is partly due \nto the fact that introducing and main\u00adtaining partial interfaces is perceived as tedious by programmers \n[5]. Therefore, we have created a metrics suite and tool support to assist the developer in using partial \ninterfaces. Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and \nFeatures abstract data types, frameworks, polymorphism. General Terms Measurement, Design, Languages \nKeywords interfaces, partial interfaces, context-specific interfaces, roles, OO programming, Java, metrics, \ntool support, refactorings  1. INTRODUCTION Although the use of interfaces in variable declarations \nis widely accepted as a prerequisite for writing decoupled code [3], it seems that interfaces are rarely \nused in practice. A recent study showed that on average only 1 out of 5 variables in various large Java \nprojects declares an interface as its type [5]. Here, we go one step further and investigate to which \nextent the interfaces used (or just offered for use) in a project limit access to an ob\u00adject through \na variable to those features of the object actually needed from within the variable s context (a so-called \ncontext\u00adspecific interface). The idea is that a high specificity of the inter\u00adface would result in a \nbetter perception of a class s usage in the given context and in an increase in the number of classes \nbeing able to implement the interface. In general, partial interfaces tend to be less restrictive, allowing \na greater decoupling of classes, resulting in a higher degree of plugability of a design. Partial interfaces \ncan occur in different forms. In Java, a dedi\u00adcated interface construct (covering partial specifications) \nis part of the language. In languages such as C++, abstract classes with Copyright is held by the author/owner(s). \nOOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. no implemented \nfeatures qualify as partial interfaces if only a subset of the features of the concrete class is specified. \nWithout tool support, analyzing the usage of classes in all con\u00adtexts of a large software project and \nidentifying suitable context\u00adspecific or partial interfaces is clearly unfeasible. Therefore, we have \ndesigned a small metrics suite measuring the use of classes and their interfaces in software projects, \nand provide tool sup\u00adport for deriving and analyzing the metrics results. Identified partial interfaces \ncan then be introduced and maintained using a set of refactoring tools [5] developed in a companion project. \n2. A SMALL METRICS SUITE FOR ANA-LYZING INTERFACE USAGE We used the goal-question-metrics approach [1] \nto define the goal behind the use of partial interfaces and to derive questions and the set of metrics \nfor determining the achievement of our goal. Here, we focus on the metrics, of which there are four, \nnamely NODAS, ACD, BCD, and IMI. 2.1 Definition NODAS (Number Of Different Access Sets). Each variable \ndec\u00adlaration creates a new context with a specific type and specific method calls. The NODAS metric returns \na count of pairwise disjoint access contexts of a class and its implemented inter\u00adfaces. The value ranges \nfrom 0 to 2n, where n is the number of published methods of the class. ACD (Actual Context Distance). \nACD is an assessment of the distance between the methods available to a context (via the used type) and \nthe methods actually used in the context (con\u00adcrete method calls). A value of 0 indicates a perfect match, \nthat is, all available methods are being used, whereas a value close to 1 indicates that only few of \nthe available methods are being used (indicative of a missing suitable partial interface). BCD (Best \nContext Distance). The declared type of a variable needn t be the best-matching interface available. \nThe BCD met\u00adric finds better matches among already defined and implemented interfaces, and uses those \nmatches to calculate a best possible ACD. The value of BCD ranges between 0 and ACD. IMI (Interface Minimization \nIndicator). Methods available in interfaces, but not used in any context lead to unnecessarily high ACD/BCD \nvalues. The IMI metric detects such superfluous methods by dividing the number of methods actually used \nin the project by the number of methods available in the interface. A value of 1 indicates that all methods \nare being used whereas one of 0 indicates that none are. The metric is cumulated over all interfaces \nof a class to allow a quick assessment of the situation. 382  2.2 Interpretation NODAS ACD BCD Figure \n1: Interpreting the metrics The first step in the metrics evaluation is the comparison of the ACD and \nBCD metrics of a class. A large difference indicates that there are already interfaces available waiting \nto be used in the given contexts. The NODAS metric can help evaluate the absolute value of the ACD/BCD \nmetrics, as a high number of different access sets justifies higher ACD/BCD values. So can the IMI metric, \nsince a low number signals non-minimal inter\u00adfaces which lead to unnecessarily high ACD/BCD values. Classes \nwith high ACD/BCD values suggest missing partial interfaces the Context Analyzer (see below) can then \nbe used to determine what to do next.  3. RESULTS Table 1 shows the top 5 classes of the Java API with \nrespect to the NODAS metric. A comparison of the ACD/BCD values they differ slightly shows that not \nall contexts are typed with the best possible interface, yet the impact of replacing the types would \nbe small. The IMI metric being 1 shows that none of the implemented interfaces has methods not used, \nso that mini\u00admizing the interfaces would be no remedy. However, the ACD/BCD values are close to 1 which \nsuggests a lack of suit\u00adable partial interfaces. Having identified the problem, the Con\u00adtext Analyzer \ncan be used to determine the missing interfaces. Table 1: Top 5 NODAS classes of the Java API Name NODAS \nACD BCD IMI java.lang.String 238 0.941 0.734 1 java.util.Vector 197 0.782 0.729 1 java.awt.Component \n173 0.986 0.971 1 java.awt.Graphics 136 0.946 0.946 - javax.swing.JComponent 116 0.978 0.968 1 Table \n2, which has been produced by the Context Analyzer, shows the three most heavily used method subsets \nof the classes, the highest count being 568 usages of a subset containing only equals. The table also \nshows the types currently used in the contexts (C.Types) as well as the type best matching the context \n(B.Type) along with the distance to the given context (counted as the number of excessive methods). In \nthe case of String, a partial interface CharSequence including the methods length and charAt (and, per \ndefault, also equals) is readily available, but is only used in 2 out of 990 contexts; in the case of \nVector, the interface List could have been used had the method calls been renamed as suggested by the \nJava 2 collections framework . Of course, Vector and String serve as examples only; the real test would \nbe application domain classes. Table 2: Contexts for java.lang.String / java.lang.Vector Count C.Types \nB.Type(dist.) Methods java.lang.String 568 String (any interface) equals 279 String (277), CharSequence \n(2) CharSequence (3) length 143 String CharSequence (2) length/charAt java.lang.Vector 100 Vector Vector \n(108) size/elementAt 61 Vector Vector (107) size/ elementAt/ addElement 49 Vector Vector (109) addElement \n 4. TOOL SUPPORT The metrics suite and the Context Analyzer have been imple\u00admented as plug-ins for IntelliJ \nIDEA [4] (an IDE offering a fully resolved parse tree). Together with the set of refactorings devel\u00adoped \nseparately [5, 7], they make IDEA a very comfortable tool for the analysis, introduction and maintenance \nof partial inter\u00adfaces. All described tools can be downloaded from [7]. 5. OPEN ISSUES AND CONCLUSION \nOne problem not addressed here is that of context switches: If the content of a variable is passed to \nanother context, the set of methods required from the object may change requiring type\u00adcasts to another \ninterface. The implications of this circumstance prevent the introduction of minimal context-specific \ninterfaces in certain cases, yet they do not hinder the use of partial inter\u00adfaces in general, since \nrelated contexts together often form a role of an object, which is also naturally represented as a partial \ninterface [2, 6]. A more thorough investigation of these implica\u00adtions is under way. We have shown that \nour metrics and tool support can help iden\u00adtify possible partial interfaces. Further experiments are \nplanned to evaluate the results of the metrics, and to gain new insights from applying the refactorings \nsuggested by metrics and Context Analyzer to widely used packages.  6. REFERENCES [1] Basili, V., Caldiera, \nG., Rombach, D. The Goal Question Metric Approach. Encyclopedia of SE, Volume 1, 1994. [2] Fowler, M. \nRefactoring: Improving the Design of Existing Code. Addison-Wesley 2000. [3] Gamma, E., Helm, R., Johnson, \nR., Vlissides, J. Design Patterns. Addison-Wesley 1995. [4] IntelliJ IDEA. www.intellij.com/idea [5] \nSteimann, F., Siberski, W., K\u00fchne, T. Towards the System\u00adatic Use of Interfaces in JAVA Programming. \nIn Proc. of PPPJ 2003 (Kilkenny, Ireland, June 2003) 13 17. [6] Steimann, F. A radical revision of UML \ns role concept. In Proc. of UML 2000 (York, UK 2000) 194 209. [7] Framework for the Use of Java Interfaces. \nwww.kbs.uni\u00adhannover.de/fuji 383  \n\t\t\t", "proc_id": "949344", "abstract": "Using partial interfaces, i.e. interfaces that cover only a subset of the total set of published methods of a class, has several advantages, among them being an increase in understandability of the code and extended substitutability of classes in frameworks. However, analysis of large frameworks such as the Java API suggests that partial interfaces are only sparsely used. We believe that this is partly due to the fact that introducing and maintaining partial interfaces is perceived as tedious by programmers [5]. Therefore, we have created a metrics suite and tool support to assist the developer in using partial interfaces.", "authors": [{"name": "Philip Mayer", "author_profile_id": "81100132948", "affiliation": "University of Hannover, Hannover, Germany", "person_id": "PP14057327", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949446", "year": "2003", "article_id": "949446", "conference": "OOPSLA", "title": "Analyzing the use of interfaces in large OO projects", "url": "http://dl.acm.org/citation.cfm?id=949446"}