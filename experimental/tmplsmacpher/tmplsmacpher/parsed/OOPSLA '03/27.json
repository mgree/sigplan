{"article_publication_date": "10-26-2003", "fulltext": "\n Building Compilers for DirectX 9.0 Compatible Graphics Processors Yahya H. Mirza Aurora Borealis Software \nLLC 8502 166th Ave. NE, Redmond WA, 98052 E-mail: yahya@aurorasoft.net ABSTRACT Custom graphics processors \nor GPUs have been available for a few years now. Currently these graphics processors are slowing evolving \nto generalized stream processors. These custom vector processors [1] have special support for vector \nand matrix data types supported through packed arrays . Recently, Microsoft and 3D Labs (Open GL ARB) \nhave independently developed virtual execution environments to abstract these underlying graphics processors \n[2]. Additionally new languages including Cg [3], HLSL [4], and GLSlang [5] have been developed to target \nthese graphics virtual machines. This paper explores the technical issues involved with building compilers \nthat target DirectX 9.0 compatible programmable graphics processors.  Categories &#38; Subject Descriptors: \nCompilers Keywords: Virtual Machines, Computer Graphics, Micro-Programmable Graphics Hardware. 1. INTRODUCTION \nToday, near cinematic quality rendering capabilities once exclusively in the realm of high-end offline \nsoftware renderers, are now becoming available in real-time rendering systems. With the recent introduction \nof floating point calculations throughout the graphics hardware pipeline, the functionality required \nto target most of the capabilities of Pixar s Renderman shading language in real time are now achievable. \nOne mechanism being used to attain these goals, are multi-pass rendering techniques. A key player in \nthis arena is Microsoft with their DirectX 9.0 API. 2. THE GRAPHICS PIPELINE As in computer hardware \narchitecture, three performance optimization techniques commonly used in 3D graphics architectures, are \npipelining, vectorizing, and parallelizing. The graphics algorithms exposed through Direct3D9, the 3D \ngraphics component of the DirectX 9.0 API, are logically organized into a pipeline. The Direct3D9 pipeline \nshould be viewed as a set of algorithms that operate on 3D geometric quantities, which in the case of \nDirect3D9 are either vertices or primitives predefined by the Direct3D9 architecture. The objective of \nthe graphics pipeline is to convert geometric data into an image, which is renderable on the display. \nCurrently only two stages of the Direct3D9 pipeline illustrated in Figure 1 are programmable1: 1 Diagrams \n1 and 2 are based on the diagrams from the Microsoft Direct3D9 documentation. Copyright is held by the \nauthor/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. \n     Figure 1: The DX9 Graphics Pipeline  3. TARGETING GRAPHICS HARDWARE 3.1 Graphics Processor \nArchitecture Issues In this paper, we will focus on Direct3D9 compatible hardware architecture. Direct3D9 \nis based on a vector register processor model. Currently Direct3D9 exposes two separate though similar \nprocessor models: (vertex / pixel) processors. Within the Direct3D9 processor model there are multiple \nprocessor profiles including vertex shader 2.0, 30 and pixel shader 2.0, 3.0. Each profile defines the \nminimum set of required functionality, which must be provided by a GPU meeting that profile. For example, \nthe ATI Radeon 9700 is a Direct3D9 compatible GPU which meets the vertex / pixel shader 2.0 profiles. \nFinally, graphics hardware software co-evolution, a fundamental problem in today s graphics API s can \nnow be cleanly addressed through support for new instructions, additional registers, constants, program \nsize etc. Figure 2 illustrates the fundamental elements of the Direct3D9 virtual machine architecture: \n Samplers Output Pixels Figure 2: The DX9 Programmable Architecture Fi x e d F u n c t i o n P i p e \nlin e Al p h a T e st D e pth T e s t S t e n cil T e s t F o ggi ng A l p h a B l en di ng Ver t ex \nDat a Cl i p p i n g B a ck Fa ce C u l l i n g At t r i b u t e Eva l u a t i on R a st e r iz a t \nio n Pi xe l S h ad er Te s s e l l a t i o n P r o g r a m m abl e P i p e lin e P r im it i v e \nDat a Te x t u r e Sur f a c e Te x t u r e Sam p l e  110 3.2 Compilation Issues Although GPUs have \ngained wide spread popularity, the current generation of graphics processors have several limitations \nthat make them difficult targets for compiler writers. The missing features in the current generation \nof GPUs include a lack of random access to memory, hardware caching, hardware stacks, and pointers. Although \none could argue that these omissions were actually chosen by their designers [6]. Once one tries to push \nthe envelope with respect to higher-level language features these processor like features become more \nnecessary. 3.2.1 Random Access Memory Current GPU s do not support random access to memory. A way around \nthis limitation, is to use the graphics API s ability to dynamically create textures (arrays of floats) \nand read / write to elements of a texture array from within a pixel program. This multi-pass approach \n[7] is really just a hack to get around the lack of explicit support by GPU s for random access memory. \nShading language compilers from Stanford [8] and ATI s Ashli [9] leverage multi-pass techniques to overcome \nthe program size limitations of today s GPUs. This multi-pass approach to rendering should really be \nconsidered an idiosyncrasy of current GPUs opposed to an explicit feature to be leveraged by next generation \ngraphics compilers. 3.2.2 Hardware Caching Although caching is not essential in a graphics processor, \nit is highly useful in enabling performance. Caching makes spilling registers much more efficient and \neasier for the compiler writer. Due to the hard processor resource limits in current generation graphics \nhardware, register allocation is especially important for graphics compilers. Registers in Direct3D9 \nare used for inputs, constants, temporary variables as well as outputs. A key issue for graphics compilers \nis dealing with register spills. Since most of the current graphics hardware does not support an L2 cache \non the graphics card, there is no way to spill temporary variables into virtual memory. Shading languages \nby Stanford and ATI [10] use multi-pass techniques as described earlier to store spilled variables to \ndynamically created textures. 3.2.3 Hardware Stacks Another limitation of today s GPUs is that they \ndo not support a hardware stack. Although DirectX 9.0 s Pixel /Vertex Shader 2.0 processor profiles support \ncall instructions, the mechanism used is an address register. When a call is made, the return address \nis stored in the address register. This approach is similar to what is sometimes known as a link register, \nwhich was used in hardware from the 50 s and 60 s in systems that predated hardware stacks. A major limitation \nof the address or link register approach is that it does not enable recursion, which is useful for rendering \nalgorithms such as ray tracing. Additionally the lack of a hardware stack degrades the performance of \na function call, and makes the life of a compiler more difficult [11]. 3.2.4 Pointers Finally pointers \nare missing from the current generation of pixel vertex shader specifications as well as their implementing \nhardware. In computer graphics, pointers are especially useful for constructing DAG structures to represent \n3D scenes.  4. CONCLUSION In conclusion, given the fact that GPU s are slowly evolving to towards more \nprocessor like capabilities one must consider what s more useful: a GPU with processor like capabilities, \nor simply more processors with multiple vector units. Perhaps as has been the trend in the past, GPUs \nwill become less important with CPU s evolving to take their role. A concrete step in this direction \nis the IBM / Sony CELL processor. 5. ACKNOWLEDGMENTS I would like to acknowledge Henry DaCosta for our \nrecent exploration into Direct3D9. Dana Batali from Pixar for conversations on the RenderMan Shading \nLanguage. In addition, special thanks go to Raja Koduri and Arcot Preetham from ATI Research for insight \ninto the Ashli compiler. Mark Fiuczynski for reviewing this paper. Finally my deepest gratitude goes \nto George Bosworth for our discussions on compilers.  6. REFERENCES [1] Asanovic, Krste, Vector Processors \n, Department of Electrical Engineering and Computer Science, MIT, 2003. [2] Taylor, Philip, Programmable \nShaders for DirectX 8.0 , Microsoft Corporation, 2000. [3] Mark, William, R., Glanville, R., Steven, \nAkeley, Kurt, Kilgard, Mark, J., Cg: A system for programming graphics hardware in a C-like language. \nSiggraph Conference Proceedings, pp 896-907, 2003. [4] Peeper, Craig, Microsoft Meltdown UK Presentation: \nDirectX High Level Shading Language , Microsoft Corporation, 2002. [5] Baldwin, Dave, Rost, Randi, and \nKessenich, John, The OpenGL Shading Language , Version 1.0, June 12, 2002. [6] Lindholm, E., Kilgard, \nM., and Moreton, Henry, A User-Programmable Vertex Engine. Siggraph Conference Proceedings, pp 149-158, \n2001. [7] Peercy, Mark. S., Olano, Mark, Airey, John, and Ungar, Jeffrey, Interactive Multi-Pass Programmable \nShading. [8] Proudfoot, K., Mark W. R., Svetoslav T., and Hanrahan P., A Real-Time Procedural Shading \nSystem for Programmable Graphics Hardware. Siggraph Conference Proceedings, pp 159-170, 2001. [9] Bleiweiss, \nAvi, Preetham, Arcot, ASHLI Advanced Shading Language Interface. ATI Research Inc., 2003. [10] Preetham, \nArcot, Personal Communication, Summer 2003. [11] Wolzchko, Mario, Personall Communication, October 2003. \n 111  \n\t\t\t", "proc_id": "949344", "abstract": "Custom graphics processors or GPUs have been available for a few years now. Currently these graphics processors are slowing evolving to generalized stream processors. These custom vector processors [1] have special support for vector and matrix data types supported through \"packed arrays\". Recently, Microsoft and 3D Labs (Open GL ARB) have independently developed virtual execution environments to abstract these underlying graphics processors [2]. Additionally new languages including Cg [3], HLSL [4], and GLSlang [5] have been developed to target these graphics virtual machines. This paper explores the technical issues involved with building compilers that target DirectX 9.0 compatible programmable graphics processors.", "authors": [{"name": "Yahya H. Mirza", "author_profile_id": "81100198272", "affiliation": "Aurora Borealis Software LLC, Redmond, WA", "person_id": "P643501", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949374", "year": "2003", "article_id": "949374", "conference": "OOPSLA", "title": "Building compilers for DirectX 9.0 compatible graphics processors", "url": "http://dl.acm.org/citation.cfm?id=949374"}