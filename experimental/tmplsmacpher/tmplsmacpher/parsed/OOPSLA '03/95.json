{"article_publication_date": "10-26-2003", "fulltext": "\n A Language Based Formalism for Domain Driven Development Wei Zhao Computer and Information Sciences, \nUniversity of Alabama at Birmingham Birmingham, AL 35294-1170, USA 1-205-934-2213 zhaow@cis.uab.edu \nABSTRACT The evolution of programming languages (e.g. machine languages, assembly languages and high \nlevel languages) has been the driving force for the evolution of software development from the machine-centric \nto the application-centric. The 4th generation languages (4GLs), languages defined directly by the composition \nof domain features, serve as the language-based formalism for the emerging Domain Driven Development \nparadigm. The 4GLs are defined in Two-Level Grammar++ and can be compiled into 3GLs using the 4GL compiler \nframework.  Categories and Subject Descriptors D.2.13 [Software Engineering]: Reusable Software domain \nengineering. D.3.1 [Programming Languages]: Formal Definitions and Theory semantics, syntax. F.4.2 [Mathematical \nLogic and Formal Languages]: Grammars and Other Rewriting Systems Grammar types. General Terms Languages, \nTheory, Standardization, Reliability. Keywords 4th Generation Languages, Feature Model, Generative Domain \nModel, Two-Level Grammar, Domain Engineering, Application Engineering, 4Compiler. 1. INTRODUCTION Domain \nDriven Development (3D) covers many related research efforts such as Generative Programming (GP) [2], \nProduct-line Architecture, Feature-Oriented Programming [1], Domain-Specific Languages (DSLs) [3], Domain-Specific \nModeling [5], and Model-Driven Architecture (MDA) [4]. The essential goals of these technologies are \n1) moving the development abstraction up toward the domain, 2) achieving higher automation in software \ndevelopment, and 3) achieving a higher level of reuse. Although each individual technology has its suitable \nand well-defined theory or technique, what is the common and integrated language concept that supports \nthe essence of this new development paradigm? How can we program directly with domain abstractions? Copyright \nis held by the author/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. \n 2. THE 4GL PARADIGM When the domain maturates, the features are the communication and definition tool \nfor understanding the common abstraction of the domain. The anatomy of a feature is a modular encapsulation \nof multi-dimensional views: an abstract view at the domain business level, a constructive view at the \narchitectural pattern level and a concrete view at the implementation technologies level. Concrete features \nare implemented as software components. By observing that a language definition is a definition of the \ncomposition of language elements (tokens), we are motivated to use the language theory and techniques \nto define feature compositions (domain abstraction). Domain abstraction is analogous to a definition \nof a language; a particular feature composition instance is analogous to a program written in that language. \nWe call these domain abstraction languages 4GLs. 1. The 4GLs have abstract and concrete forms. The abstract \nrepresentation is the definition of domain abstraction defined by Two-Level Grammar++ (TLG++). A 4GL \nprogram s abstract form is encoded in XML. The concrete form of 4GLs can be one of the following: a model \nedited in a modeling language such as UML or GME [5], an online HTML form, a GUI wizard, a spreadsheet \nor simple text. Normally the abstract form can be generated from the concrete forms by the corresponding \ntool support by eliminating tool specifics. The abstract form of 4GL promotes reuse of domain abstractions \nacross the tools. Historical 4GLs emphasized the concrete form and there was no uniform definition of \n4GLs. Languages such as query languages, report generators, graphics languages, decision-support languages, \napplication generators, application languages and specification languages were categorized as 4GLs [7]. \nThe 4GLs were most popularized as data-query languages. As 4GLs varied drastically in form, there was \nno uniform means to describe the different syntax and semantics. Our work is focusing on the abstract \nform of 4GLs. 2. According to three-dimensional views of domain features, a 4GL program (a feature composition \ninstance) has three\u00addimensional views too: semantic, syntactic, and lexical compositions referred to \nrespectively as the 4GL semantics, syntax, and lexicality. The composition at each dimension is defined \nby that dimension s feature model. Composition at the lexical level mainly deals with the interoperation \nbetween the feature lexemes (software components).  3. RELATED WORK GP provides the notion of a Generative \nDomain Model (GDM) that we employed as the result of domain engineering in 4Compiler, a 4GL compiler. \nHowever, GP dose not address how to organize the generated 3GL product into a functioning architectural \norganization while accommodating heterogeneous implementation technologies at the same time, where we \nclaim our work will contribute. Batory has proposed feature oriented programming by static stepwise refinement \non the base programs defined by refinement algebra [1], whereas, we are focusing on the dynamic feature \ncomposition defined by grammars. Composition Language (CL) [6] in Prediction Enabled Component Technology \ndescribed composition semantics in the component model level such as latency, safety and availability. \nYet, CL did not address the composition semantics on the level of business meanings. DSLs offer language \nnotations tailored towards the specific needs of a particular domain, but they are not defined directly \nby the composition of domain features. MDA focuses on the abstraction level of Meta (M0, M1, M2, M3) \n[4], whereas the basic theory of our work is emphasizing the abstraction level in engineering knowledge \n(business logic, architecture and technologies). 4. 4GL DEFINITION IN TLG++ The 4GL semantics and syntax \nare defined respectively by each dimension s feature models. We developed a new language called TLG++ \nas an object oriented extension to TLG [10] suitable for specifying feature models. The term two-level \ncomes from the fact that a set of formal parameters may be defined using a context-free grammar, with \nthe possible generated strings used as arguments in predicate functions defined using another context\u00adfree \ngrammar. The second level, the rule of the first level for testing context sensitivity, has been extensively \nused in [10] to define the static semantics along with the language syntax. It has been proved and illustrated \nthat TLG has Turing computation power that can be used as a grammatical interpretive model for dynamic \nsemantics. The integration of syntax and semantics definition in a single grammatical notation is very \nconvenient for specifying feature models. The composition syntax of the feature model is the domain feature \norganizational structure that is the functional perspective of the composition. The static semantics \nare configuration constraints such as feature attributes, relationship cardinalities, pre and post condition \nfor the configurations, interdependencies and temporal concerns. The dynamic semantics of the composition \nmodels the stages of changes of system properties after the steps of composition, which has been called \nQuality-of-Service (QoS) composition [8]. Examples of QoS parameters are turn-around-time at the lexical \ncomposition level and the reliability at the syntactic composition level. The composition semantics is \nat the non-functional perspective of composition. Since both levels of TLG are context\u00adfree grammars, \na TLG interpreter reads the feature model definition (grammatical interpretive model) and generates the \n4GL semantics and syntax interpreter automatically by using parser generator facilities. 5. 4COMPILER \nCOMPILING THE 4GLS A 4Compiler that reads a 4GL program (in a concrete form) and produces a 3GL object \ncode is essentially a product line assembler for that particular domain. 4Compiler has two phases. 1) \nThe application development is a process of 4GL compilation. A 4GL program in a concrete form needs to \nbe converted into the abstract form. It is first parsed according to semantic composition (no business \nlogic violation), and secondly parsed according to syntactic composition (no architectural violation), \nand then transformed into an architecture representation with any necessary architectural instrumentation \ncode generated automatically. Then the UniFrame Resource Discovery System [9] searches for the necessary \nfeature implemented in the business domain search space. If there are any incompatibilities in the component \nmodels used in those feature implementations, the system will generate bridge code based on the knowledge \nfrom the technology GDM and parameters from the feature associated Unified Meta\u00adcomponent Model (UMM) \n[9]. 2) For 4GL compilation development, the domain level engineering phase simulates the domain development \nof three-dimensional domains (business domains, architecture domains and technology domains), which results \nin business GDM, architecture GDM and technology GDM, providing the 4GL semantic, syntactic and lexical \ndefinition feature model respectively. Concrete feature implementations are provided by designated programmers \nfacilitated with MDA in business domains. Domain level development provides the meta-data and reusable \nassets for the application engineering. 6. CONCLUSIONS Our prototyping starts from lexical composition. \nWe have designed a framework so that the bridge code can be automatically and dynamically generated for \ninteroperation between any pair of component models. The proposed Ph.D. research should be validated \nthrough a complete example that includes: a formal feature model definition in the Banking business domain; \nformal feature model definition in architectural pattern domain; and the ability to compile a sample \n4GL program written in GME using the proposed methods. This research is supported by the U. S. Office \nof Naval Research under the award number N00014-01-1-0746. 7. REFERENCES [1] D. Batory, J. N. Sarvela, \nA. Rauschmayer, Scaling Step-Wise Refinement , Proc. of 25th International Conference on Software Engineering, \npp.187-197, 2003. [2] K. Czarnecki, U. W. Eisenecker, Generative Programming: Methods, Tools, and Applications, \nAddison-Wesley, 2000. [3] A. v. Deursen, P. Klint, J. Visser, Domain-Specific Languages: An Annotated \nBibliography , CWI, 2000, http://homepages.cwi.nl/~arie/papers/dslbib/#foot85 [4] D. S. Frankel, Model \nDriven Architecture: Applying MDA to Enterprise Computing. Wiley Publishing, Inc., 2003. [5] GME User \ns Manual. The Institute for Software Integrated Systems, Vanderbilt University. http://www.isis.vanderbilt.edu/Projects/gme/Doc.html \n[6] J. Ivers, N. Sinha, K. Wallnau, A Basis for Composition Language CL , Technical Note, CMU/SEI-2002-TN-026, \n2002. [7] James Martin, Fourth Generation Languages, Volume 1: Principles. Pretice-Hall, Inc., 1985. \n[8] R. R. Raje, M. Auguston, B. R. Bryant, A. M. Olson, C. C. Burt, A Quality of Service-Based Framework \nfor Creating Distributed Heterogeneous Software Components, Concurrency and Computation: Practice and \nExperience Vol. 14, No. 2, pp. 1009\u00ad1034, 2002. [9] UniFrame Project, http://www.cs.iupui.edu/uniFrame/ \n[10] A. van Wijngaarden, Revised Report on the Algorithmic Language ALGOL 68. Acta Informatica, Vol. \n5, pp. 1-236, 1974  \n\t\t\t", "proc_id": "949344", "abstract": "The evolution of programming languages (e.g. machine languages, assembly languages and high level languages) has been the driving force for the evolution of software development from the machine-centric to the application-centric. The 4th generation languages (4GLs), languages defined directly by the composition of domain features, serve as the language-based formalism for the emerging Domain Driven Development paradigm. The 4GLs are defined in Two-Level Grammar++ and can be compiled into 3GLs using the 4GL compiler framework.", "authors": [{"name": "Wei Zhao", "author_profile_id": "81452594891", "affiliation": "University of Alabama at Birmingham, Birmingham, AL", "person_id": "PP14187109", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949449", "year": "2003", "article_id": "949449", "conference": "OOPSLA", "title": "A language based formalism for domain driven development", "url": "http://dl.acm.org/citation.cfm?id=949449"}