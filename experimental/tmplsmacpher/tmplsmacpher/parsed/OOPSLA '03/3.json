{"article_publication_date": "10-26-2003", "fulltext": "\n XAspects: An Extensible System for Domain-Speci.c Aspect Languages* Macneil Shonle Department of Computer \nScience and Engineering UC San Diego La Jolla, CA 92093-0114  mshonle@cs.ucsd.edu Karl Lieberherr College \nof Computer and Information Science Northeastern University Boston, MA 02115  lieber@ccs.neu.edu ABSTRACT \nCurrent general aspect-oriented programming solutions fall short of helping the problem of separation \nof concerns for several concern domains. Because of this limitation good solutions for these concern \ndomains do not get used and the opportunity to bene.t from separation of these con\u00adcerns is missed. By \nusing XAspects, a plug-in mechanism for domain-speci.c aspect languages, separation of concerns can be \nachieved at a level beyond what is possible for object\u00adoriented programming languages. As a result, XAspects \nal\u00adlows for certain domain-speci.c solutions to be used as easily as a new language feature.  Categories \nand Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features; D.2.11 [Software \nEngineering]: Software Architectures languages, domain-speci.c architectures General Terms Languages, \nDesign. Keywords Aspect-oriented programming, generative programming, language extensions, domain-speci.c \nlanguages. 1. INTRODUCTION The developing .eld of aspect-oriented programming ex\u00adplores the problem of \nseparation of concerns. While object\u00ad * This work was supported in part by the National Science Foundation \n(NSF) under Grant No. CCR-0098643, by DARPA and BBN under agreement F33615-00-C-1694, and by an Eclipse \nFellowship from OTI. Most of this work was done while this author was studying at North\u00adeastern University. \nCopyright is held by the author/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM1-58113-751-6/03/0010. \nAnkit Shah College of Computer and Information Science Northeastern University Boston, MA 02115 ankit@ccs.neu.edu \noriented languages provide constructs to allow many con\u00adcerns to be decomposed into separate classes \nand methods, there remain concerns that cannot be cleanly decomposed using constructs found in object-oriented \nlanguages. When a concern spans several components that concern is said to crosscut the components. For \nexample, in order for a Java program to support logging of method calls, the pro.ling in\u00adstrumentation \ncode must be inserted before and after every method de.nition, either manually or by a tool. The pro\u00ad.ling \ninstrumentation, therefore, crosscuts the components that are pro.led. The goal of aspect-oriented programming \nis to identify crosscutting concerns and modularize them into aspects.A compiler for an aspect-oriented \nlanguage takes these aspects together with the components and weaves them into a whole program. The most \npopular aspect-oriented programming language to date is AspectJ [32], which is a general purpose aspect \nlanguage built on top of Java. In AspectJ, logging and other concerns can be written as separate aspects \nthat are cleanly modularized, without the need for tools external to the compiler. While general purpose \naspect languages are useful, certain crosscutting concerns are best handled when using domain\u00adspeci.c \naspect languages. A domain-speci.c aspect language is a custom language that allows special forms of \ncross\u00adcutting concerns to be decomposed into modularized con\u00adstructs. Examples of domain-speci.c aspect \nlanguages in\u00adclude languages for dealing with coordination concerns, ob\u00adject marshaling concerns, and \nclass graph traversal concerns. Similarly, while some non-crosscutting concerns can be ex\u00adpressed as \ncomponents in an object-oriented language these concerns might be better expressed in a domain-speci.c \nlan\u00adguage: A domain-speci.c language sacri.ces generality for closeness to a .xed problem area. In this \npaper, we will refer to these non-crosscutting languages as domain-speci.c com\u00adponent languages. One \nexample of a domain-speci.c com\u00adponent language is a language for a parser generator tool. In this paper, \nwe present a system that integrates domain\u00adspeci.c aspect and component languages with AspectJ us\u00ading \na technique that allows domain-speci.c language imple\u00admentations to leverage a powerful subset of AspectJ. \nThe domain-speci.c languages are integrated by using a plug-in architecture that allows the constructs \ncreated by the lan\u00adguages to cooperate with each other while not being aware that the other plug-ins \nexist. 1.1 Background: The AspectJ Language The AspectJ language supports the decomposition of crosscutting \nconcerns with two concepts: (1) the join point model; and (2) inter-type declarations. These concepts \nare discussed below. A full de.nition of the AspectJ Program\u00adming Language can be found on the AspectJ \nwebsite [32]. 1.1.1 AspectJ s Join Point Model AspectJ s join point model is concerned with dynamic events \nthat occur during the execution of a program. Events recognized by AspectJ include: a call to a method \nor con\u00adstructor, an execution of a method or constructor, a write to or read from a .eld, an execution \nof an exception handler. These events are called join points in AspectJ parlance. Pointcuts. A pointcut \nrepresents a set of join points. Com\u00adplex pointcuts can be built by using the set theory oper\u00adators union, \nintersection, and complement on other point\u00adcuts. More advanced operations can be applied to pointcuts \nto pick out those events that occur within another pointcut. For example, a pointcut could identify all \nwrites made to any integer .eld named numItems during the execution of any method named count. Below, \nthat pointcut is given the name setOccuredInCount and is de.ned from the two pointcuts setOccured and \ninCount: pointcut setOccured(int rhs): set(int *.numItems) &#38;&#38; args(rhs); pointcut inCount(): \ncflow(execution(* *.count(..))); pointcut setOccuredInCount(int rhs): setOccured(rhs) &#38;&#38; inCount(); \n Pointcut setOccuredInCount (through pointcut inCount) selects all join points that are executed directly \nor indirectly in the control-.ow of the count method. The .. means that the count method can have any \nnumber of arguments. AspectJ also includes the withincode operator to identify only the code in the count \nmethod body itself. Advice. After the pointcuts have been speci.ed, new be\u00adhavior can be associated with \nthe events by using AspectJ s advice. The join points identi.ed by a pointcut can be ad\u00advised in three \nplaces: before the execution of the join point; after the execution of the join point, or around the \nex\u00adecution of the join point. Figure 1 shows an aspect that includes a pointcut de.nition and an after \nadvice applied to it. An around advice can be used to perform actions before, after, or instead of executing \nthe join point. Because each 01 aspect SetWatcher { 02 pointcut setOccuredInCount(int rhs): 03 set(int \n*.numItems) &#38;&#38; args(rhs) 04 &#38;&#38; cflow(execution(* *.count(..))); 05 06 after(int newVal): \nsetOccuredInCount(newVal){ 07 System.out.println(\"New value: \" + newVal); 08 } 09 } Figure 1: A Simple \nAspectJ Aspect. advice is lexically scoped an advice cannot access the local variables of the join point \nnor any other advice that may be associated with the join point: for example, an after advice cannot \nuse the variables declared in a before advice, therefore an around advice is useful when a resource needs \nto be acquired before a join point occurs and then released afterwards. An around advice is needed when \na join point execution needs to be conditional. 1.1.2 Inter-type Declarations Along with modifying the \nbehavior of the program dy\u00adnamically, AspectJ can be used to modify the static struc\u00adture of a program. \nStatic modi.cations are performed through AspectJ s inter-type declarations. Methods, con\u00adstructors or \n.elds can be introduced to preexisting classes from aspect de.nitions. Inter-type declarations can be \nused to express the static concerns of the program in a manner not allowed in Java. For example, an aspect \ncan be created to de.ne all of the image rendering functions of a family of classes in a single aspect \ninstead of scattering these similar functions across multiple classes. Yet another aspect could be created \nto de\u00ad.ne all of the caching .elds and functions of the family that is separate from the rendering aspect. \nInter-type declara\u00adtions and AspectJ s join point model can also be used to modify classes that exist \nonly in Java bytecode form.  1.2 Where AspectJ Falls Short Unfortunately the constructs of AspectJ are \nnot su.cient enough to separate all concerns. The visitor pattern [9] is one such concern: Given a root \nobject that contains (di\u00adrectly or indirectly) sub-objects of a particular class provide a mechanism \nfor a visitor object to be supplied with a reference to each sub-object. The visitor pattern can be im\u00adplemented \nusing AspectJ (as shown in [11]) but any e.cient implementation of it must depend on a solution where \nthe program states the object structure twice: once for the class de.nitions themselves and then again \nto specify the rela\u00adtionship of the root object to all of its sub-objects. This structural redundancy \nis a weakness because whenever the relationship between the root class and the composed classes change \nthe visitor methods also need to be changed. For ex\u00adample, if a new .eld is added such that it will need \nits own visit method de.ned then that visit method must be written and one of the existing visit methods \nmust be modi.ed to accommodate for the addition. While AspectJ allows the visitor pattern code to be \nencapsulated in an aspect, the structural properties still crosscut both the classes and the aspect. \nThe end result is a system where concerns are en\u00adcapsulated but still highly coupled1 . DemeterJ &#38; \nDAJ. The solution to the structure-awareness problem is solved by a domain-speci.c aspect language called \nDemeterJ [35]. DemeterJ supports the visitor pattern in a structure-shy way: Instead of writing the visit \nmeth\u00adods manually a compact path traversal language is used. The traversal language allows the program \nto describe what needs to be done, not how it should be done. For example, suppose we have a University \nobject that contains Library objects, and Library objects that contain Book objects. To 1Re.ection can \nbe used to dynamically compute the struc\u00adtural properties of the program, but at the cost of runtime \ne.ciency. specify the traversal path starting at a University instance down to each Book instance the \nfollowing could be written (the notation used here is from the DAJ language [34], the successor of DemeterJ): \ndeclare strategy: everyBook: \"from University to Book\"; How a University object contains Book objects \nis irrelevant to the traversal strategy. If the University class is changed by .rst decomposing it into \nColleges and decomposing Li\u00adbraries into a collection of Shelves the above strategy will still be valid. \nMore complex traversal paths can be made by specifying constraints and computing the intersection of \ntwo paths: declare strategy: everyBook: \"intersect(from University to Book, skipDorms)\"; declare strategy: \nskipDorms: \"from * bypassing Dorm to *\"; A traversal path can be forced to go through a particular type \nor .eld name by using the via operator and a traver\u00adsal path can be forced to bypass a particular type \nor .eld name by using the bypassing operator. These path require\u00adments can be composed and intersected \nwith further path requirements. A traversal is used in order to create the methods required to implement \nthe visitor: declare traversal: void visitBooks(): everyBook (MyBookVisitor); The only visible change \nto the structure of the program after the above traversal is used is that the University class now has \na visitBooks method: the visitBooks method is placed in the University class because the path speci.ed \nby the everyBook strategy starts at it (as speci.ed by the from keyword). Behind the scenes the DAJ compiler \nimplements the visitBooks method by adding support methods in the correct locations as speci.ed by the \nstrategy. The lack of constructs that support the visitor pattern is just one example of where the AspectJ \nlanguage falls short of separating concerns. We conjecture that this gap be\u00adtween domain-speci.c aspect \nlanguages and general purpose aspect languages will always exist because any general solu\u00adtion cannot \ncover all possible ways an aspect can crosscut a system. By their nature concerns are related to the \nprob\u00adlem domain, and there is an in.nite variety of forms that problem domains can take. AspectJ has \nsome support for particular domains via ab\u00adstract aspect libraries: The pointcut sets described by an \nabstract aspect can be de.ned later by a concrete aspect. Only a limited set of problems has thus far \ncreated useful aspect libraries. 1.3 Domain-Speci.c Solutions In order to address the problem of separation \nof concerns cleanly domain-speci.c solutions can be used. Domain\u00adspeci.c solutions (such as DemeterJ) \nallow decomposition on a level unachievable with object-oriented languages. Domain\u00adspeci.c aspect languages \nin particular can be used for con\u00adcerns whose implementation in an object-oriented language is either \nscattered or the implementation duplicates informa\u00adtion of other concerns. The DemeterJ and DAJ languages \nare useful for structure-shy concerns2 . By using domain-speci.c solutions productivity is in\u00adcreased, \nthe problem solved can be more complex, and the resulting quality is improved. 1.4 Problems Using Multiple \nDomain-Speci.c Solutions Most non-trivial problem domains have concerns that a single domain-speci.c \nsolution cannot entirely express. In order to use multiple domain-speci.c solutions, the program must \nbe fragmented into di.erent pieces that are read by each tool. For example, if one of the concerns is \nparsing then a parser-generator tool can be used along with the plain Java source .les. The fragmentation \nof tools causes problems when each concern relies on the solutions provided by the other tools: While \na parser can remain orthogonal to the rest of the sources, a traversal through the program cannot be \northog\u00adonal to the sources. In the next section we present how XAspects [1] addresses this problem. \n 2. A PLUG-IN ARCHITECTURE The fragmentation problem can be solved by forcing each domain-speci.c solution \nto conform to a particular frame\u00adwork and by de.ning a common language with which the domain-speci.c \ntools can communicate. The XAspects tool provides a plug-in framework that integrates domain-speci.c \nlanguages such that the tools become extensions of the As\u00adpectJ language. Rules restricting what a plug-in \ncan do are introduced in order to enhance the integration. A simple plug-in will .rst be introduced before \nthe dis\u00adcussion of the general architecture. 2.1 Example: Class Dictionary Plug-In The ClassDictionary \nplug-in can be used in order to solve parsing and printing concerns for a family of related classes. \nA class dictionary is a grammatical representation of a set of classes that are composed from each other. \nJust as in BNF grammars, class dictionary productions have a left hand side and a right hand side: The \nleft hand side is an identi.er that de.nes a new class and is the name of the new grammatical rule. The \nright hand side is a sequence of terminals and non-terminals. The non-terminals are members of the class \nidenti.ed by the left hand side and the terminals are to\u00adkens used to make the string representations \nof the objects parsable and printable. A sample class dictionary is pictured in Figure 2. The .rst class \nde.ned by the ClassDictionary aspect in Fig\u00adure 2 is the CD class, which has three .elds: (1) the CD \ns album title .eld, represented by a String; (2) the CD s artist .eld, represented by an Artist; and \n(3) the CD s upc .eld, represented by a UPCNumber. If a non\u00adterminal is found in a production without \na <fieldname> presented in angle brackets then the .eld name defaults to the name of the type with an \ninitial lower-case letter. The Artist class presented in Figure 2 is an abstract class with 2In general, \na concern C is X-shy if there is a C imple\u00admentation that depends on minimal knowledge of X and if the \nC implementation can adapt to any changes in X that do not a.ect dependency semantics. Domain-speci.c \nas\u00adpect languages allow problems to be decomposed to support concern-shy representations of concerns. \n01 aspect(ClassDictionary) CompactDisc { 02 CD = \"cd\" <album> String \"by\" Artist \",\" 03 \"(\" <upc> UPCNumber \n\")\" \".\"; 04 Artist : SingleArtist | MultipleArtist; 05 SingleArtist = Name; 06 MultipleArtist = Name \n\",\" Names; 07 Name = String; 08 UPCNumber = String; 09 CommaList(S) ~ S { \",\" S }; 10 Names = CommaList(Name); \n11 } Figure 2: A Class Dictionary Aspect, using EBNF Notation. two concrete sub-classes: SingleArtist \nand MultipleArtist. The CommaList class is a grammatical rule that is param\u00adeterized by other grammatical \nrules3.The {} brackets used is the EBNF representation for zero or more repeti\u00adtions of the enclosed \nterminals and non-terminals. A CD object might be printed with the following representation: cd \"The \nSteve Howe Album\" by \"S. Howe\", (\"07567-81559-25\"). The generated CD class can parse the above as input \nthrough its static parse method. Class dictionaries do not encapsulate crosscutting con\u00adcerns because \nclass dictionaries only generate new classes; they do not modify existing classes. For this reason the \nclass dictionary language is a domain-speci.c component language. Class dictionaries are useful for separating \nstruc\u00adtural concerns. For example, suppose the class structure was changed so that the Artist rule was \na concrete class representing lists of Names: Artist = CommaList(Name); Even though the class representation \nhas changed, the tex\u00adtual representation of a CD is the same. Class dictionaries together with traversals \ngive strong support for structure\u00adshy programming. For example, had a traversal been per\u00adformed to visit \nall Name instances then the code would be correct regardless of how Artist is structured. The class dictionary \nin Figure 2 generates seven classes: Had this solution been written in Java seven separate source .les \nwould have to be used, plus the additional code for parsing CDs. 2.2 Compilation Phases The XAspects \ncompiler (xajc) and each plug-in tool com\u00admunicate with each other during six phases: Source Code Identi.cation \nThe XAspects compiler iden\u00adti.es in the source code all program text that belongs to the plug-in and \nprovides that text to the plug-in. Generation of External Interfaces The plug-in gener\u00adates source .les \nthat de.ne the external (i.e. program visible) components introduced by the language that the plug-in \nimplements. 3 CommaList(Name) is the syntax for instantiating the pa\u00adrameterized CommaList rule with \nName.  Source Code Identification Generation of External Interfaces Initial Bytecode Generation  \n Crosscutting Analysis Generation of Semantics Final Bytecode Generation  Figure 3: The Compilation \nPhases. Initial Bytecode Generation The AspectJ compiler (ajc) generates bytecodes from the plug-in de.ned \nexternal interfaces and the remainder of the program. Crosscutting Analysis The XAspects compiler provides \neach plug-in the binary of the program to perform re\u00ad.ection or other analysis on it. Generation of Semantics \nThe plug-in generates behav\u00adioral changes to the generated program in the form of AspectJ source code. \n(Structural changes are prohib\u00adited during this phase, only methods can be modi.ed, and only aspect private \nmethods can be introduced.) Final Bytecode Generation Finally, the new behavioral code is woven into \nthe existing code to create the com\u00adplete program. An overview of the compilation phases is depicted \nin Fig\u00adure 3. Each of these steps are discussed in the following sections. 2.2.1 Source Code Identi.cation \nThe input .les to the XAspects compiler are Java and AspectJ source .les that are allowed to include \none minor syntactic extension: When the aspect keyword is followed by parentheses the parentheses must \ncontain a valid type name for a class that can be found on the current class-path (the class is the plug-in \nitself). Line one of Figure 2 is an example of this form. All of the tokens contained in the {}brackets \nare scanned without interpretation by XAspects. The tokens have the following restrictions: The tokens \nmust be valid Java tokens; and  Any { bracket must be balanced by a } bracket, without any dangling \nbrackets.  Non-Java tokens, such as @ and #, are not allowed in the aspect body. However, the plug-in \ncan choose to express these characters by having the user contain them in string literals. The tokens \nfound in the brackets are the plug-in s body. For example, in Figure 2 the body of the ClassDictionary \nplug-in aspect is lines 2 10. After the source code speci.c to each plug-in is identi.ed by the XAspects \ncompiler, each plug-in used is instantiated and provided with the text of all bodies that belong to the \nplug-in. At this point the plug-in can choose to parse the body or delay parsing until the next phase. \n 2.2.2 Generation of External Interfaces The XAspects compiler then queries each plug-in to pro\u00advide \na set of source .les that describe the program visi\u00adble interfaces generated by the plug-ins4 . For example, \nthe ClassDictionary plug-in at this point will provide the list of classes, methods and .elds that were \ndescribed by the grammar. The external interfaces are described through AspectJ source code. As such, \nthe external interfaces can express new classes or modi.cations to existing classes via inter-type declarations. \nThe AspectJ source code generated needs to meet the following restrictions: All new classes generated \nmust have a name that ap\u00adpeared as an identi.er token in the aspect body. This restriction allows the \nuser of the plug-in to have full control over the names generated. If this restriction were not in place \ndi.erent plug-ins could try to gener\u00adate the same class names, with no mechanism available for the user \nto resolve the con.ict.  All new public .elds or new public methods introduced to existing classes (via \ninter-type declarations) must have a name that appeared as an identi.er token in the aspect body.  All \nnew classes generated from each aspect body must be generated in the same Java package in which the aspect \nbody was de.ned.  The .elds or methods de.ned in new classes do not have to be named by identi.ers present \nin the aspect body be\u00adcause any further changes to that class will be done through external inter-type \ndeclarations or plug-ins. Therefore, any name clashes that arise can be handled in those changes. 2.2.3 \nInitial Bytecode Generation Any of the public methods generated by the plug-ins in the previous phase \nmay be stubs at this point (i.e. non-void functions that always return null or void functions that do \nnothing). These external interfaces are then woven with the rest of the AspectJ and Java source by using \nthe AspectJ compiler. 2.2.4 Crosscutting Analysis After the initial bytecode generation phase the structure \nof the program is complete and plug-ins cannot add new .elds to any of the classes. Because the structure \nof the 4Interface here means the API of the classes generated by the plug-in, which is not to be confused \nwith the Java interface construct. program is .xed the complete bytecodes for the program can be provided \nto each plug-in. Because the code generated by each plug-in can be translated into Java bytecodes (through \nAspectJ) the changes made by all plug-ins are in the same, well-de.ned language. During this phase domain-speci.c \naspect languages can perform structural analysis on the program through Java re.ection on those bytecodes. \nFor example, the Traversal plug-in (which supports DemeterJ style traversals) can gen\u00aderate concrete \npaths based on the traversal rules speci.ed. An alternative and more e.cient way to perform the crosscutting \nanalysis is to operate on the abstract syntax tree of the AspectJ program produced in the initial byte\u00adcode \ngeneration phase. The modi.ed abstract syntax tree would then be used to generate code. This would avoid \nhaving to use the AspectJ compiler twice but this approach would need an AspectJ compiler that has an \nAPI to import and export abstract syntax trees. The current implementa\u00adtion of XAspects invokes the AspectJ \ncompiler twice: The .rst compilation produces an executable that can be used (through re.ection or bytecode \nparsing) to produce the class graph for the crosscutting analysis. The second compilation produces the \n.nal program. 2.2.5 Generation of Semantics Each plug-in can provide semantic changes by using As\u00adpectJ \ns dynamic join-point model. The implementation of functions that were stubbed can be speci.ed by using \nAs\u00adpectJ s around advice. New private methods can also be introduced at this point by using inter-type \ndeclarations. Note that a private inter-type declaration does not intro\u00adduce a private method to the \nclass, rather it introduces a method to the class that is only visible by the generating aspect. For \nexample, the Traversal plug-in can generate private methods to each of the classes it needs to traverse: \nthese private methods cannot be called by other parts of the program, not even the classes of which the \nmethods are members. The AspectJ code generated during this phase must sat\u00adisfy the restriction that \nonly one AspectJ aspect can be gen\u00aderated at this phase for each domain-speci.c aspect de.ned. It must \nhave the name of the identi.er given to the domain\u00adspeci.c aspect (for example, the name of the domain-speci.c \naspect in Figure 2 is CompactDisc ). The AspectJ aspect generated should be careful with any use of the \ndeclare precedence rule. The declare precedence rule is a feature of AspectJ to manage con\u00ad.icts between \naspects that advise the same methods. If declare precedence might be necessary for the aspect, the user \nshould be able to specify the clause, because only the user has enough information to decide how to resolve \ncon\u00ad.icts. 2.2.6 Final Bytecode Generation Finally, the AspectJ source provided by the plug-ins are \ngathered by the XAspects compiler and the complete binary is created. The 1.1 release of the AspectJ \ncompiler includes support for incremental compilation that may allow a fu\u00adture implementation of XAspects \nto compile faster because unchanged .les will not have to be parsed twice. The actions taken during these \nphases are discussed with concrete examples in the next section. 01 class MusicRegistry { 02 public void \nregister(UPCNumber upc, CD cd) { 03 /* insert cd into the database */ 04 } 05 06 public CD getCD(UPCNumber \nupc) { 07 /* find the CD with the given upc */ 08 } 09 } 10 11 aspect(ClassDictionary) CompactDisc { \n12 CD = \"cd\" <album> String \"by\" Names 13 \",\" \"(\" <upc> UPCNumber \")\" \".\"; 14 Name = <name> String; 15 \nNames ~ Name { \",\" Name }; 16 UPCNumber = <upc> String; 17 } 18 19 aspect(Coordination) MusicRegistryThreading \n20 changes(MusicRegistry) { 21 declare selfex: register; 22 declare mutex: {register, getCD}; 23 } 24 \n25 aspect(Traversal) MusicCollections { 26 declare strategy: everyMusicalAlbum: 27 \"intersect(from AudioLib \nto CD, justMusic)\"; 28 /* skip books on CD */ 29 declare strategy: justMusic: 30 \"from * via MusicCollection \nto *\"; 31 declare traversal: void listAlbums(): 32 everyMusicalAlbum (PrintCD); 33 } 34 35 aspect(TraversalAdvice) \nPrintCD { 36 void before(CD cd) { 37 System.out.println(cd.toString()); 38 } 39 } Figure 4: An XAspects \nSource File using Multiple Plug-Ins.  3. EXAMPLE: AN AUDIO LIBRARY The following example demonstrates \na program that uses three di.erent domain-speci.c languages: (1) a class dictio\u00adnary language; (2) a \nthread coordination language; and (3) a traversal language. The thread synchronization aspect lan\u00adguage \nwas taken from the COOL programming language, a part of the D framework [18]. The class dictionary and \ntraversal languages were taken from the DemeterJ system. Figure 4 shows how these plug-ins can be used \nto implement an audio library. The code generated by each language is discussed in the following sections. \n3.1 Class Dictionary Language The ClassDictionary language is used for expressing struc\u00adture shy input \nand output languages. The aspect body given to the ClassDictionary plug-in is lines 12 16 of Figure 4. \nAfter given the body, the ClassDictionary generates the fol\u00adlowing classes for the generation of external \ninterface phase: CD, Name, Names, and UPCNumber. The CD class con\u00adtains the .elds album, names,and upc, \nalong with a default constructor and a constructor parameterized by the CD s .elds. The Name and UPCNumber \nclasses contain the sin\u00adgle String .elds name and upc, respectively, along with both default and parameterized \nconstructors. The Names class is a collection of one or more Name objects; it is a Java container typed \nin a way that a traversal can recognize that Name elements exist in it. (If a plain Java container was \nused a traversal could not know that the Object contained in it was of the desired type.) Because a ClassDictionary \nis a domain-speci.c component language it does not need to perform any crosscutting anal\u00adysis. 3.2 A \nCoordination Language The Coordination language is used for expressing thread coordination concerns. \nIn multithreaded programming an important concern is the synchronization policy: for a given object, \nor set of objects, locks must be used when various operations are being performed. The two features of \nthe Coordination plug-in we will ex\u00adamine are the selfex and mutex declarations. The selfex declaration \non line 21 of Figure 4 states that the register method of MusicRegistry is non-reentrant: At most one \ncall to register can occur across all threads at any time. The changes declaration on line 20 is one \nuse of a gen\u00aderalization of Java s extends and implements keywords. This generalization in XAspects recognizes \nthat the rela\u00adtionship among classes go further than the is-a and has\u00ada relationships. In this case, \nthe changes declaration is being parameterized with the name of the MusicRegistry class. This declaration \nis passed to the plug-in along with the aspect body during the source code identi.cation phase. The parenthesis \nare used to di.erentiate the new declara\u00adtion words, which can be any valid identi.er, from their arguments. \nThe mutex declaration on line 22 of Figure 4 states that calls to getCD and register cannot occur simultaneously. \nThat is, that the methods are mutually exclusive. The implementation of the Coordination aspect relies \non AspectJ s inter-type declarations to introduce new locks to the object and on the AspectJ s join point \nmodel to change the semantics of existing methods. The AspectJ code in Figure 5 was generated by the \nCoordination aspect to im\u00adplement the selfex behavior. By separating the locking policy and encapsulating \nit in an aspect both the compo\u00adnent code and locking policy code are easier to understand and the programmer \ncan reason about synchronization using language that is closer to the problem domain. 3.3 A Traversal \nLanguage The Traversal Language uses two plug-ins: Traversal and TraversalAdvice. The traversal declaration \non line 31 in\u00adtroduces a new listAlbums method to the AudioLib class. The listAlbums method calls new, \nprivate traversal meth\u00adods to locate each CD instance accessible through the Mu\u00adsicCollection class. \nThe visitor itself, PrintCD, is created through the TraversalAdvice plug-in, which is merely a wrapper \nfor a Java class. The Traversal plug-in assumes that the structure of the classes it needs to traverse \nare tightly typed (for example, the traversal will not visit generic Objects). If the structure information \nis not available 01 aspect MusicRegistryThreading { 02 Cool_Lock MusicRegistry.registerlock = 03 new \nCool_Lock(); 04 Object MusicRegistry.cool_sync = 05 new Object(); 06 pointcut in_register(MusicRegistry \ntar): 07 execution(* MusicRegistry.register(..) 08 &#38;&#38; target(tar); 09 before(MusicRegistry tar): \nin_register(tar) { 10 tar._enter_register(); 11 } 12 after(MusicRegistry tar): in_register(tar) { 13 \ntar._exit_register(); 14 } 15 void MusicRegistry._enter_register(){ 16 while (registerlock.othersRunning()) \n{ 17 try { synchronized(cool_sync) { 18 cool_sync.wait(); } } 19 catch (InterruptedException e) {} } \n20 registerlock.in(); 21 } 22 /*...*/ 23 } Figure 5: Partial View of Self-Exclusion Code Gen\u00aderation \nat compile-time it cannot insert the appropriate traversal methods. 3.4 Cooperation Between the Languages \nAn important issue in XAspects is how much informa\u00adtion an aspect A needs to have about other aspects \nfor A to function properly. Many aspects depend on each other by using common names and those common \nnames might indicate constraints that must hold between aspects. Con\u00adsider the Traversal aspect in Figure \n4, which depends on the ClassDictionary aspect. The statement from AudioLib to CD in the Traversal aspect \nmakes the assumption about the ClassDictionary aspect that there is a path from an Audi\u00adoLib object to \na CD object. If there is no such path it would be impossible to ever .nd a CD in the audio library. It \nis the responsibility of the plug-in designers to check for those dependencies. All properties of the \ncode that the Traversal aspect would need from any other aspects will be available in the .rst bytecodes \ngenerated. It is important that all visible inter\u00adface changes (done using inter-type declarations) are \nper\u00adformed by the plug-ins in the .rst compilation phase. An inter-type declaration might modify the \nclass graph and the complete class graph is needed for computing the traversals in the crosscutting analysis \nphase. It is interesting to notice that the Traversal aspect is dependent on all aspects that create \ninter-type declarations for additional parameterless methods. So one aspect may be dependent on many \nother aspects. The addition of one inter-type declaration might break many traversals and requires the \ntesting of all traver\u00adsals whose traversal graph changes because of the new inter\u00adtype declaration. The \nalternative of not using the traversal aspect would even be worse because then we would have to maintain \nall navigation code manually rather than using an automatic tool. We can generalize from this traversal \nexample to other aspects: All properties of the code that an aspect would need from the other aspects \nwill be available in the .rst bytecodes generated. A slightly modi.ed version of the Audio Library that \nthe current XAspects tool can handle, along with other XAs\u00adpects examples, is available through [1] (via \nthe resources link).  4. ADVANTAGES OF XASPECTS The XAspects system is unique because it separates con\u00adceptually \ntwo di.erent semantic provisions of a domain\u00adspeci.c language: the language s external interface and \nstructural modi.cations (structural meaning) and the lan\u00adguage s generated semantics (behavioral meaning). \nThe sep\u00adaration of these two concepts allows for the plug-ins to pas\u00adsively cooperate with each other. \nThe XAspects infrastructure essentially reduces the prob\u00adlem for a domain-speci.c language to the problem \nof reading in Java code and producing changes and additions to that code. Dependency issues among domain-speci.c \nlanguages are reduced because each plug-in only has to worry about the properties of Java classes, and \nnot the properties of con\u00adstructs of other domain-speci.c languages that created those classes. It could \nbe argued that it is not feasible to introduce many little domain-speci.c languages with which the pro\u00adgrammers \nhave to work. However, the inherent complexity of a project may require that the programmers address \nthe issues of composition of aspect languages on a conceptual level. A conscious language design that \naddresses the aspect composition issues systematically can simplify the program\u00admers s job: Without such \nan approach, the programmers will have to do this at the lower level of a general purpose aspect language, \nwhich results in more code that actually needs to be written, some of which will be redundant with the \nstructure of the program and could have been generated automatically. Another weakness of general aspect-oriented \nprogram\u00adming is the di.cultly of using the language correctly. A novice can easily create an in.nite \nloop in AspectJ if an ad\u00advice happens to apply to itself. More subtle misapplications of advice can also \noccur that are not so easily observed. If a custom aspect language is created for a speci.c domain these \nmisapplications can be checked by the plug-in. While a reusable AspectJ aspect might be able to implement \nsome of the functionalities of an XAspects plug-in, it cannot per\u00adform some of the compile time checks \nneeded to ensure that the aspect is being used correctly. Lieberherr et al. [14] discusses extensions \nthat could be made to AspectJ s static property checker to make it more useful. 5. IMPLEMENTATION DETAILS \nThe XAspects compiler is a wrapper around the ajc com\u00adpiler for AspectJ. This section describes some \ninteresting implementation details of the system. Self Implementation. The XAspects system is written \nin part using a minimal, earlier version of itself using the Class-Dictionary and Traversal plug-ins. \nBecause the ClassDic\u00adtionary language is made for parsing LL grammars it is useful for implementing the \nsyntax of domain-speci.c lan\u00adguages. After an AST is generated by the ClassDictionary provided parse \nmethod it can be traversed using constructs created by the Traversal language. In general, a plug-in \ncan be implemented by writing a class dictionary for the input language and traversing it. Compile Time \nRe.ection Implementation. The byte\u00adcodes provided during the crosscutting analysis phase dis\u00adcussed in \n\u00a72.2.4 largely represent the .nal bytecodes of the program except for the presence of private methods \nor changes to existing methods. Each plug-in is given these bytecodes in the form of a set of .les. Each \nplug-in can choose to load the bytecodes and perform analysis on them using the Java re.ection interfaces. \nThe Traversal plug-in makes extensive use of this information in order to deter\u00admine the class graph \nof the program. More advanced analysis can be performed by the plug\u00adin to compute properties of the program \nbeyond its static class graph. For example, a plug-in could analyze the loop\u00ading constructs in a manner \nsimilar to the Reverse Graphics system [21], a domain-speci.c aspect language from Xerox. In the Reverse \nGraphics system, a family of image process\u00ading .lters are composed from each other such that each .lter \nis easy to understand and debug yet ine.cient because each .lter iterates over the entire image each \ntime, creating mul\u00adtiple temporary copies. This ine.ciency is solved with the introduction of an aspect \nthat allows the loops to be fused together but without sacri.cing the code clarity: The task of fusing \nthe loops can be performed by the compiler instead of the programmer having to perform it by hand. The \ncompile-time re.ection and bytecode analysis tasks of a complex aspect language are simpler because the \nobject and execution model of the Java language is preserved, even with the additions created by other \nplug-ins. This preserva\u00adtion is important because there are many libraries already available for computing \nwith Java bytecodes or Java re.ec\u00adtion. 6. RELATED WORK XAspects builds on Crista Lopes s work on domain-speci.c \naspect languages. She proposed COOL and RIDL [19, 17] which she developed further in her thesis [18]. \nCOOL and RIDL were also the crystallization point for AspectJ. XAs\u00adpects combines all those innovations \ninto an integrated sys\u00adtem using the powerful features of AspectJ to implement COOL and RIDL and many \nother aspect languages using a plug-in approach. Czarnecki and Eisenecker [8] also propagate the idea \nof domain-speci.c aspect languages. In section 5.5, an aspec\u00adtual DSL is de.ned as a language that in.uences \nthe seman\u00adtics of other languages. The section goes on Implementing modularly composable DSLs requires \na common language implementation platform providing all the infrastructure for implementing language \nplug-ins. XAspects uses AspectJ and the XAspects compilation architecture as the imple\u00admentation platform. \nIn section 8.7 of [8] the point is made that the model of modular language extensions is very appropriate \nfor AOP. A modular language extension can be plugged into what\u00adever con.guration of language extensions \nwe currently use. Advantages of modular language extensions are enumerated (they all apply to XAspects): \ndeclarative representation, simpler analysis and reasoning, domain-level error checking, domain-level \noptimizations. In section 11.6 the point is made that Intentional Pro\u00adgramming [25] is a suitable technology \nfor implementing modular language extensions. We .nd that an XAspects\u00adbased approach that builds on AspectJ \nis more promising because it is easier to implement crosscutting abstractions when AspectJ is available \nas the underlying assembly lan\u00adguage. Jim Hugunin s paper [13] addresses domain-speci.c aspect languages. \nIn the section Aspects in specialized domains he writes: While aspect libraries can provide some domain\u00adspeci.c \nsupport in a general purpose AOP language such as AspectJ, it is likely that some domains will be important \nenough to warrant the creation of domain-speci.c AOP lan\u00adguages. XAspects provides one approach to facilitate \nthe creation and implementation of domain-speci.c languages. Jim Hugunin later says that further into \nthe future, work is needed to determine the right way to enable programmers to extend AspectJ without \noperating on the compiler. XAs\u00adpects o.ers one way to extend AspectJ without operating on the compiler \nand by only relying on the public interface of AspectJ. This is achieved by relying on AspectJ s around \nmethods and Java Re.ection. It remains to be seen how general this approach is. Multi-Dimensional Separation \nof Concerns (MDSC) [28] is the result of Subject-Oriented Programming [12] and Subject-Oriented Design \n[6]. MDSC is a generalization of aspect-oriented programming that deals not only with pro\u00adgramming but \nalso with design and analysis. The Hyper/J tool from IBM that implements MDSC uses hyperslices and hypermodules. \nHyper/J could be simulated in XAspects by using a Hyper/J plug-in that would be allowed to create new \nJava packages. Hyperslices de.ne reusable aspect be\u00adhavior and hypermodules provide the glue code. The \nmulti\u00addimensional concern ideas are useful for designing a system in XAspects. Ossher and Tarr [23] discusses \nintegrating fea\u00adtures with di.erent domain models, a methodology that is also useful for XAspects. The \nGeneric Model Editor (GME) environment [10] is concerned with domain-speci.c modeling. GME uses mul\u00adtiple \nweavers, while XAspects uses a single weaver. Other relevant, but di.erent, tools for domain-speci.c \ncomponent languages are ExCIS [3], JTS [4], and DiSTiL [26]. Java syntax extenders, such as Maya [2], \nare similar to XAspects because they provide a mechanism for compile\u00adtime execution of external code \ngenerators. However, XAs\u00adpects is di.erent than such macro systems because XAspects allows the use of \nAspectJ s aspect weaver. The support of a weaver enables many crosscutting concerns to be both en\u00adcapsulated \nand separated in a way that a macro system can\u00adnot handle. ELIDE [5] is also related to Maya and XAspects: \nELIDE allows user-de.ned modi.ers to be applied to classes, .elds, and methods. The trasformations the \nmodi.ers produce can create new classes or change the members of the class to which the modi.er was applied. \nELIDE s technique of creating a partial order based on dependency requirements may be useful to XAspects \nif a family of plug-ins need to be tightly integrated and share information. XAspects is a limited re.ective \ncompiler. OpenJIT [20] is a compiler that allows for language customization and optimization based on \ncomputational re.ection. XAspects uses re.ection in a principled way by giving access to the binary or \nabstract syntax tree of an intermediate stage. The Concern Manipulation Environment (CME) [33] sup\u00adports \naspect-oriented software developers (end users), tool providers, and researchers. It is a competitor \nto XAspects that is much larger in scale. The rest of the paragraph is quoted with small changes from \n[33]: CME will o.er end users a suite of tools for use in creating, manipulating, and evolving aspect-oriented \nsoftware, across the full software lifecycle. For AOSD tool providers and researchers, it sup\u00adplies a \n.exible, open set of components and frameworks on which to build a wide range of tools and paradigms \nthat support aspect-oriented software development, and to do so much more easily than is possible at \npresent. Moreover, the CME provides a common platform in which di.erent AOSD tools can interoperate and \nintegrate, ultimately providing end-users with a rich environment in which to perform aspect-oriented \nsoftware engineering, and providing other tool builders and researchers with more powerful building blocks \nfrom which to create new tools and paradigms. We believe that the Demeter technology in XAspects will \nbe useful to CME. This includes the meta-model behind XAspects and the AP Library [15, 16] which plays \nan im\u00adportant role in concern composition. 7. FUTURE WORK XAspects provides not only a framework for \ndomain\u00adspeci.c component and aspect languages, it is also a frame\u00adwork for creating new language constructs. \nFor example, the MultiJava language [7] has attractive features that we believe can be entirely implemented \nusing the plug-in archi\u00adtecture. To implement multimethods in XAspects a plug\u00adin will need to generate \nthe multiple dispatch tables on its own. This requirement can be satis.ed by the compile time re.ection \nand AspectJ join-point model capabilities of the system. More aspect languages can be found and modi.ed \nto .t the XAspects framework. Many aspect-oriented solutions have proven useful because they solve concerns \n.t for par\u00adticular domains. Unfortunately, these solutions are not used as often due to the burden of \nintegrating them with other solutions. XAspects allows for these solutions to get used without sacri.cing \nthe use of a general purpose aspect lan\u00adguage. One future project would be to reimplement a subset of \nJava Web Services [36] (JAX*) using XAspects. JAX* uses many sublanguages and some of them are aspectual. \nFor example, JAX* contains JAXB (Java Architecture for XML Binding) and JAXP (Java API for XML Processing). \nIt seems that the two do not work ideally together but the intent is similar: We need schemas and their \ntranslation to Java (this is the purpose of JAXB) and we need a high\u00adlevel language for processing the \nJava objects. JAXP uses XPath as the navigation language and XPath has similar capabilities as traversal \nspeci.cations. An interesting application would be to use XAspects to reengineer the Web Services Pack. \nHow would JAXB, JAXP, JAX-PRC, JAXM, JAXR look like if reimplemented in XAspects? We already have a beginning: \nA subset of JAXB corresponds to the ClassDictionary plug-in and a sub\u00adset of JAXP corresponds (at least \nin intent) to the Traversal plug-in. XAspects needs a more general join point model than As\u00adpectJ. The \ndi.erent aspect languages (and class dictionar\u00adies) touch each other either through a common terminology \nor through an intermediate glue language. Techniques from composing diverse ontologies might be useful \n[30]. The QuO project at BBN [31, 24, 29] uses multiple aspect languages. It would be an interesting \nexercise to reengineer QuO in the context of XAspects. For example, we would need an aspect to express \nregions for certain system mea\u00adsurements to formulate how the application should behave in the di.erent \nregions. Future development of XAspects will be reported on the XAspects home page [1]. 8. ACKNOWLEDGMENTS \nWe would like to thank John Sung and Doug Orleans for the design and development of DAJ (http://daj.sf.net), \nwhich was based on John Sung s Master s thesis [27]. Doug extended the AP Library [22] with an e.cient \nalgorithm for strategy intersection which simpli.ed the conceptual in\u00adterface for DAJ and XAspects. The \ncompilation steps of XAspects were motived by the compilation steps of DAJ. Thanks to Gong Jun who wrote \nthe code generated by the Coordination aspect-language discussed in \u00a73.2. Finally, our thanks go to Krzysztof \nCzarnecki, Sergei Ko\u00adjarski, Joseph Loyall, Therapon Skotiniotis, and the anony\u00admous reviewers who reviewed \nan earlier draft of this paper. Many thanks to Pengcheng Wu for his help with .nalizing the paper. 9. \nREFERENCES [1] XAspects Home Page. http://www.ccs.neu.edu/research/demeter/xaspects. Continuously updated. \n[2] J. Baker and W. C. Hsieh. Maya: Multiple-Dispatch Syntax Extension in Java. In Proceeding of the \nACM SIGPLAN 2002 Conference on Programming language design and implementation, pages 270 281. ACM Press, \n2002. [3] D. Batory, D. Brant, M. Gibson, and M. Nolen. ExCIS: An Integration of Domain-Speci.c Languages \nand Feature-Oriented Programming. www.isis.vanderbilt.edu/sdp, Nov. 2001. [4] D. Batory, B. Lofaso, and \nY. Smaragdakis. JTS: tools for implementing domain-speci.c languages. In Proceedings Fifth International \nConference on Software Reuse, pages 143 153, Victoria, BC, Canada, 2 5 1998. IEEE. [5] A. Bryant, A. \nCatton, K. D. Volder, and G. C. Murphy. Explicit programming. In Proceedings of the 1st international \nconference on Aspect-oriented software development, pages 10 18. ACM Press, 2002. [6] S. Clarke, W. Harrison, \nH. Ossher, and P. Tarr. Subject-oriented design: towards improved alignment of requirements, design, \nand code. In Proceedings of the 1999 ACM SIGPLAN conference on Object-oriented programming, systems, \nlanguages, and applications, pages 325 339. ACM Press, 1999. [7] C. Clifton, G. T. Leavens, C. Chambers, \nand T. Millstein. MultiJava: Modular Open Classes and Symmetric Multiple Dispatch for Java. In Proceedings \nof the conference on Object-oriented programming, systems, languages, and applications, pages 130 145. \nACM Press, 2000. [8] K. Czarnecki and U. Eisenecker. Generative Programming: Methods, Tools and Applications. \nAddison-Wesley, 2000. [9] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns Elements \nof Reusable Object-Oriented Software. Addison-Wesley Publishing Company, New York, NY, 1994. [10] J. \nGray, T. Bapty, S. Neema, and J. Tuck. Handling crosscutting constraints in domain-speci.c modeling. \nCommunications of the ACM, 44(10):87 93, October 2001. [11] J. Hannemann and G. Kiczales. Design Pattern \nImplementation in Java and AspectJ. In Proceedings of the 17th ACM conference on Object-oriented programming, \nsystems, languages, and applications, pages 161 173. ACM Press, 2002. [12] W. Harrison and H. Ossher. \nSubject-oriented programming (A critique of pure objects). In Proceedings OOPSLA 93, ACM SIGPLAN Notices, \npages 411 428, Oct. 1993. Published as Proceedings OOPSLA 93, ACM SIGPLAN Notices, volume 28, number \n10. [13] J. Hugunin. The Next Steps For Aspect-Oriented Programming Languages. www.isis.vanderbilt.edu/sdp, \nNov. 2001. [14] K. Lieberherr, D. H. Lorenz, and P. Wu. A Case for Statically Executable Advice: Checking \nthe Law of Demeter With AspectJ. In M. Aksit, editor, Second International Conference on Aspect-Oriented \nSoftware Development, Boston, 2003. ACM Press. [15] K. J. Lieberherr and B. Patt-Shamir. Traversals of \nObject Structures: Speci.cation and E.cient Implementation. Technical Report NU-CCS-97-15, College of \nComputer Science, Northeastern University, Boston, MA, Sep. 1997. http://www.ccs.neu.edu/research/demeter/AP-Library/. \n[16] K. J. Lieberherr, B. Patt-Shamir, and D. Orleans. Traversals of Object Structures: Speci.cation \nand E.cient Implementation. ACM Trans. Prog. Lang. Syst., 2003. to appear. [17] C. V. Lopes. Graph-based \noptimizations for parameter passing in remote invocations. In L.-F. Cabrera and M. Theimer, editors, \n4th International Workshop on Object Orientation in Operating Systems, pages 179 182, Lund, Sweden, August \n1995. IEEE, Computer Society Press. [18] C. V. Lopes. D: A Language Framework for Distributed Programming. \nPhD thesis, Graduate School of the College of Computer Science, Northeastern University, Boston, MA, \n1997. [19] C. V. Lopes and K. J. Lieberherr. Abstracting process-to-function relations in concurrent \nobject-oriented applications. In R. Pareschi and M. Tokoro, editors, European Conference on Object-Oriented \nProgramming, pages 81 99, Bologna, Italy, 1994. Springer Verlag, Lecture Notes in Computer Science. [20] \nS. Matsuoka, H. Ogawa, K. Shimura, Y. Kimura, K. Hotta, and H. Takagi. OpenJIT A Re.ective Java JIT compiler. \nIn OOPSLA 98, 1998. [21] A. Mendhekar, G. Kiczales, and J. Lamping. RG: A Case-Study for Aspect-Oriented \nProgramming. Technical Report SPL97-009, Xerox Palo Alto Research Center, February 1997. [22] D. Orleans \nand K. Lieberherr. AP Library: The Core Algorithms of AP. Technical report, Northeastern University, \nMay 1999. http://www.ccs.neu.edu/research/demeter/AP-Library. [23] H. Ossher and P. Tarr. Using multidimensional \nseparation of concerns to (re)shape evolving software. Communications of the ACM, 44(10):43 50, October \n2001. [24] R. E. Schantz and D. C. Schmidt. Research Advances in Middleware for Distributed Systems: \nState of the Art. IFIP World Computer Congress, August 2002. [25] C. Simonyi. The death of computer languages. \nTechnical report, Mircosoft Research, 1995. ftp://ftp.research.microsoft.com/pub/tech\u00adreports/Summer95/TR-95-52.doc. \n[26] Y. Smaragdakis and D. Batory. DiSTiL: A transformation library for data structures. In Domain-Speci.c \nLanguages (DSL) Conference, pages 257 270, 1997. [27] J. Sung. Aspectual Concepts. Technical Report NU-CCS-02-06, \nNortheastern University, June 2002. Master s Thesis, http://www.ccs.neu.edu/home/lieber/theses\u00adindex.html. \n[28] P. Tarr, H. Ossher,W.Harrison, and S. M. Sutton. N Degrees of Separation: Multi-Dimensional Separation \nof Concerns. In International Conference on Software Engineering, pages 107 119, Los Angeles, 1999. ACM. \n[29] N. Wang, D. C. Schmidt, A. Gokhale, C. D. Gill, B. Natarajan, C. Rodrigues, J. Loyall, and R. E. \nSchantz. Total Quality of Service Provisioning in Middleware and Applications. The Journal of Microprocessors \nand Microsystems, 26(9 10), March 2003. [30] G. Wiederhold and J. Janninck. Composing diverse ontologies. \nIn Proc. 8 th IFIP working group on databases working conference on database semantics, Rotorua(NZ), \n1999. http://www\u00addb.stanford.edu/SKC/publications/i.p99.html. [31] J. A. Zinky, D. E. Bakken, and R. \nD. Schantz. Architectural Support for Quality of Service for CORBA Objects. Theory and Practice of Systems, \nJohn Wiley and Sons, Inc., 3(1):19 pages, January 1997. [32] The AspectJ website. http://www.eclipse.org/aspectj. \n[33] The Concern Manipulation Environment website. http://www.research.ibm.com/cme. [34] The DAJ website. \nhttp://www.ccs.neu.edu/research/demeter/DAJ. [35] The DemeterJ website. http://www.ccs.neu.edu/research/demeter. \n[36] Java Web Services, Sun Microsystems. http://java.sun.com/webservices. Continuously updated.  \n\t\t\t", "proc_id": "949344", "abstract": "Current general aspect-oriented programming solutions fall short of helping the problem of separation of concerns for several concern domains. Because of this limitation good solutions for these concern domains do not get used and the opportunity to benefit from separation of these concerns is missed. By using XAspects, a plug-in mechanism for domain-specific aspect languages, separation of concerns can be achieved at a level beyond what is possible for object-oriented programming languages. As a result, XAspects allows for certain domain-specific solutions to be used as easily as a new language feature.", "authors": [{"name": "Macneil Shonle", "author_profile_id": "81335497355", "affiliation": "UC San Diego, La Jolla, CA", "person_id": "PP48024038", "email_address": "", "orcid_id": ""}, {"name": "Karl Lieberherr", "author_profile_id": "81452617626", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP40026940", "email_address": "", "orcid_id": ""}, {"name": "Ankit Shah", "author_profile_id": "81538141656", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP14222981", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949349", "year": "2003", "article_id": "949349", "conference": "OOPSLA", "title": "XAspects: an extensible system for domain-specific aspect languages", "url": "http://dl.acm.org/citation.cfm?id=949349"}