{"article_publication_date": "10-26-2003", "fulltext": "\n GME: The Generic Modeling Environment James Davis Institute for Software Integrated Systems, Vanderbilt \nUniversity Box 1829, Station B, Nashville, TN 37235 (615) 343-7530 james.davis@vanderbilt.edu Categories \nand Subject Descriptors D.2.6 [Programming Environments]: Graphical Environments, Integrated Environments \n General Terms Design, Languages. Keywords Model Integrated Computing, domain specific visual languages, \nsystem synthesis, abstract system models. 1. INTRODUCTION The Generic Modeling Environment (GME) is an \narchitecture developed for producing domain-specific design environments. These domain specific environments \nare used to capture specifications in a natural language for the end user and to automatically generate \nor configure target applications in a given domain (i.e. in a particular engineering field). Well known \nexamples include Matlab/Simulink for signal processing and LabView for instrumentation. One of the common \ncharacteristics of many domain specific tools include a visual specification interface. The advantages \nof visual environments have been demonstrated in many different domains. However, the high cost of development \nrestricts their use. Fields with small markets do not typically justify the high cost of developing a \ncustomized visual interface. GME is presented as a solution to this problem, as it is a configurable, \ngraphical modeling environment. GME supports a variety of general modeling principles in the generic \ntool. These general modeling principles are then utilized in creating the domain specific language. By \nmaking GME easily configurable for a wide variety of domains, cost issues are primarily related to the \ndevelopment of the generic environment. GME is based on over fifteen years of research in Model Integrated \nComputing (MIC) at the Institute for Software Integrated Systems at Vanderbilt University. MIC focuses \non the development of domain specific languages and domain specific environments. GME is the architecture \nused to realize domain specific languages and domain specific modeling environments. GME is configured \nusing metamodels to specify the modeling language of the target domain. Metamodels capture the syntax, \nsemantics, and presentation of the domain specific language. What objects exist in the language, how \nthey may be related, and Copyright is held by the author/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, \nCalifornia, USA. ACM 1-58113-751-6/03/0010. how they are presented are all captured in the metamodels. \nVisualization of the different objects and relationships in the language are limited to the set of presentation \nidioms that GME supports. However, many of these limitations are of the visual editor the core component \nof GME could handle other presentation methods. In practice, the set of visual idioms GME supports are \nsufficient for realizing a large set of domain specific languages. GME metamodels are based on the Unified \nModeling Language (UML). UML class diagrams are used to capture the syntax of the domain specific language. \nPresentation/visualization information is captured using a combination of stereotypes and predefined \nattributes of the UML classes and associations. The Object Constraint Language (OCL) is used to compose \nconstraints to impose the static semantics of the target language. The metamodels are used to automatically \nconfigure GME for the specified target domain. It is interesting to note that GME metamodels are constructed \nusing GME. In effect, metamodels define the set of all possible models that can be constructed in the \ntarget modeling paradigm or language. Once models are constructed in GME, a process known as model interpretation \nis used to process the models and to generate applications, data for COTS tools, or configuration for \nthird party tools. The model interpreter is a small application component that is written to work on \nthe domain models. It must be generic in nature to ensure that all models that are legal in the domain \nspecific language can be handled. While developing a model interpreter may be time consuming, it is developed \nonce, usually by an engineer versed in MIC, and is then employed many times by domain experts using the \ndomain specific environment. GME utilizes many object oriented features. In addition to the heavy reliance \non UML in the metamodeling framework, features such as inheritance are available in GME as a domain modeling \ntool. Once an object is created in GME, it effectively becomes a type. It can be subtyped and instantiated \nat will. Whenever modifications occur to the base type, the modifications are automatically enforced \non any subtypes or instances. 2. GME ARCHITECTURE GME has a modular, component-based architecture depicted \nin Figure 1. Currently SQL, XML and a fast, proprietary binary file format are supported as a thin storage \nlayer for model persistence. The Core component implements the two fundamental building blocks of a modeling \nenvironment: objects and relations. Among its services are distributed, multi-user access (i.e. locking) \nand undo/redo. Two components use the services of the Core: the GMeta and the GModel. The GMeta exposes \nthe modeling paradigm, while the GModel implements the GME modeling concepts for the given paradigm. \nThe architecture is reflective: the GModel uses the GMeta component extensively through its public COM \ninterfaces. The GModel component publishes its services through a set of COM interfaces as well. The \nuser interacts with the components at the top of the architecture: the GME Editor, the Model Browser, \nthe Constraint Manager, Interpreters and Add-ons. Add-ons are event-driven model interpreters. The GModel \ncomponent exposes a set of events, such as Object Deleted, Connection Created, Attribute Changed, etc. \nExternal components can register to receive some or all of these events. They are automatically invoked \nby the GModel when the events occur. Add-ons are extremely useful for extending the capabilities of the \nGME Editor. When a particular domain calls for some special operations, these can be supported without \nmodifying the GME itself. A good example for an add-on is the OCL syntax checker integrated into the \nmetamodeling environment. The Constraint Manager can be considered as an interpreter and an add-on at \nthe same time. The user can start it explicitly and it is also invoked automatically when event-driven \nconstraints are present in the given paradigm. Depending on the priority of a constraint, the operation \nthat caused a constraint violation will be aborted. For less serious violations, the Constraint Manager \nonly issues a warning. The GME Editor component has no special privileges in this architecture. Any other \ncomponent (translator, add-on) has the same access rights and uses the same set of COM interfaces to \nthe GME Core. Any operation that can be accomplished through the Editor, can also be done programmatically \nthrough the interfaces. This architecture is very flexible and makes the whole environment easily extensible \nand customizable. A GME Editor component is being developed in Eclipse. One advantage of the GME architecture \nis the ability to extend the architecture with different components to enhance the versatility and usability \nof GME. Model Interpreters can be developed using the GME COM interfaces or using a high level C++ interface. \nThe high level interpreter interface is referred to as the Builder Object Network (BON). The BON is a \nset of C++ classes that hide the complexity of the COM interface from the user. Additionally, the BON \ncan be extended to domain specific classes for use in developing the modeling interpreter. The metamodels \ncan be used to automatically generate the extension to the BON. This not only enables the model interpreter \ndeveloper to utilize the same classes as specified in the metamodel, but also reduces the time and effort \nnecessary to produce an interpreter. Many of the generated BON extensions were required to be manually \ncreated in the past. 3. Example DSDE Figure 2 shows an example GME domain: a system on a chip/platform \ndesign environment. This domain is an integrated, extensible, simulation environment. Data flow models, \nsuch as those shown, are used to specify the processing of the application. Other models represent the \nhardware available. Through the model interpreters, simulations can be generated to evaluate possible \nsystem configurations for performance and power characteristics. The same set of models are used to configure \nmany different types of simulators, thus reducing the designer s effort of producing the simulations. \n 4. REFERENCES [1] Sztipanovits J., Karsai G.: Model-Integrated Computing , Computer, pp. 110-112, April, \n1997. [2] Ledeczi A., et.al.: Composing Domain-Specific Design Environments , Computer, pp. 44-51, November, \n2001. [3] The GME User s Manual, available from http://www.isis.vanderbilt.edu/projects/gme. [4] Ledeczi \nA., Davis J., Neema S., Agrawal A.: Modeling Methodology for Integrated Simulation of Embedded Systems \n, ACM Transactions on Modeling and Computer Simulation, January 2003  \n\t\t\t", "proc_id": "949344", "abstract": "", "authors": [{"name": "James Davis", "author_profile_id": "81100603625", "affiliation": "Vanderbilt University, Nashville, TN", "person_id": "PP15037452", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949360", "year": "2003", "article_id": "949360", "conference": "OOPSLA", "title": "GME: the generic modeling environment", "url": "http://dl.acm.org/citation.cfm?id=949360"}