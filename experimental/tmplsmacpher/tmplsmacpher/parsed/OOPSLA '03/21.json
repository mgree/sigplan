{"article_publication_date": "10-26-2003", "fulltext": "\n Redeveloping a High-Performance Computing FrameWork Scott E. Spetka George O. Ramseyer Richard W. Linderman \nITT Industries and AFRL Information Directorate AFRL Information Directorate SUNY Institute of Technology \n26 Electronics Parkway 26 Electronics Parkway PO Box 3050, Utica, NY 13501 Rome, NY 13441 Rome, NY 13441 \n315-330-2617 315-330-3492 315-330-2208 scott@cs.sunyit.edu George.Ramseyer@rl.af.mil Richard.Linderman@rl.af.mil \n ABSTRACT This paper describes our experience in redeveloping an object\u00adoriented system. Experience working \nwith the system along with new requirements that were introduced as the system matured motivated a significant \nredesign and reimplementation effort. The initial object-oriented design helped to allow extension as \nwell as restructuring of system objects. Experience in integrating new objects into the system and reimplementing \nobjects in different languages drove a refactoring process. The Web interface to the system was reimplemented \nas a Grid portal. Categories and Subject Descriptors Classes and objects, Inheritance, Frameworks, Object-oriented \nProgramming. General Terms Design, Experimentation, Security, Standardization, Reliability.  Keywords \nCorba, COS, CGI, CGICC, Web, distributed, FTP, GLOBUS, JSP, Linux, Refactoring. 1. INTRODUCTION The High-Performance \nComputing FrameWork was initially developed as a system for image processing [1]. The system is an object-oriented \nsystem that is designed for submitting processing requests to high-performance computing (HPC) systems \nand for managing the results. The object-oriented paradigm is well-suited to this application because \nof the dynamic heterogeneous nature of the system. The FrameWork client object interacts with code interface \nobjects for each of the available HPC parallel codes. The codes execute on heterogeneous HPCs (IBM P4, \nLinux PC Cluster, Sky). Codes are written in C, C++, and Fortran. Code interface objects are implemented \nin C++ and Java. The FrameWork client invokes code interface object methods through CORBA, providing \nrobust and extensible operation. Code interface objects use heterogeneous methods (kftp/sftp/ftp) for \ncommunicating requests and responses with HPCs. HPC code launcher agents interact with a variety of scheduling \nsystems on the HPCs to displatch codes for execution. Figure 1 shows the High-Performance Computing FrameWork \narchitecture. Although object-oriented technology helped to address the heterogeneity required by each \nof the system components, the initial implementation of the system failed to exploit some of the opportunities \npresented. Each of the FrameWork components was recently reimplemented. Figure1. HPC FrameWork Architecture \n The client object was converted from a C++ CGI implementation to JSP, using software based on the GLOBUS \nToolkit [2]. The code interface object was refactored to expose common functionality that can be driven \nby code-dependent XML descriptions. The launcher agent object was redesigned to afford additional flexibility \nin developing custom launch capabilities for each of the codes. Each of the FrameWorks components is \ndiscussed further below.  2. The FrameWork Client FrameWork login and session management services, initially \nimplemented in C++ were reimplemented using Java code, based on the GLOBUS Toolkit. Using Java and GLOBUS \nservices facilitates extensions to the system for new developments in Web interface software, based on \nan object-oriented approach. CGICC classes are still used for HTML object display. Other class libraries \nmay prove to be more flexible and may be considered in the future. A display class hierarchy is used \nby the FrameWork client to produce HTML select form elements. In figure 2, the basic display types; gifs, \ncodes, pubs, sql display objects from; filesystem directories, an SQL database, the COS (Common Object \nServices) Naming Service [3], an SQL database, a dynamic publication/subscription system. Each was initially \nimplemented as an independent class. In the redeveloped system, these objects are refactored using Martin's \n[4] Replace Type Code with Subclasses refactoring method and polymorphism to handle the type variant \nbehavior among display objects. Instantiating any of these objects presents the object to the user as \nan HTML selectable list. The FrameWork client instantiates objects to establish network Copyright is \nheld by the author/owner(s). connections to server objects through CORBA and invoke interface OOPSLA \n03, October 26 30, 2003, Anaheim, California, USA. methods shown in that figure 3. We believe that replacing \nCORBA ACM 1-58113-751-6/03/0010. with an alternative Web communication mechanism would be relatively \neasy, because of the code interface object structure Figure 2. FrameWork Client Objects  3. Code Interface \nObjects A code interface object is implemented for each algorithm to request input parameters from the \nFrameWork client object, send results to the client object, send requests for processing to high\u00adperformance \ncomputers, and retrieve results from HPCs. Adding code to handle heterogeneous results for each of the \ncodes that run on the HPCs lead to the use of Martin's Extract Hierarchy refactoring method. After implementing \nseveral classes, it became increasingly difficult to unravel conditional cases for each required set \nof outputs and additional cases were leading to code bloat . As an initial approach, the codeResults \nmethod was developed to produce objects capable of producing form elements for the display of diverse \noutputs. A Perl script generates the code interface base class for each of the code interface objects, \nbased on an XML description of the interface. The next step in the implementation will be to link a generic \nbase class for each code interface object with the codeResult subclass and initialize each of the code \ninterface objects from its XML description. The code interface object is shown in figure 3. Figure 3. \nCode Interface Objects  4. HPC Launch Agent Objects In designing the HPC Launch Agent, we initially \nlooked for common functions needed to invoke parallel program execution on HPCs. We created a template \nobject that could be used for custom development to essentially create a set of similar objects, each \none customized by an expert in the code that was to be executed on the HPC. While launchers at each HPC \nare similar, launchers at different HPCs must accommodate differences in batch input systems that are \noften different for each HPC and possible differences in implementations of the MPI standard [5] for \nparallel program execution. Mpirun can be used to invoke execution of codes when a set of processors \nhas been pre-assigned to the launcher. Differences in mpirun requests mainly reflect the network interface \nused for communication by the parallel processes. These differences can be accommodated in header files \ncompiled with the launcher for each HPC. Submitting job through a batch queue for execution on an HPC \nrequires the launcher to construct a job request and use a command like qsub or llsubmit to request execution. \nBatch files are constructed by the preLaunch method in the launch agent subclass shown in figure 4 below. \nThe postLaunch method in the subclass removes temporary files and performs other code-dependent functions. \nFor example, postLaunch combines the results from each processor into a single result file for one of \nthe codes. Figure 4. Launch Agent Objects  5. Results The goal of the HPC FrameWork was to support access \nto a diverse set of codes operating in an heterogeneous environments supporting different architectures \nand data formats (big/little endian), different batch input systems, implementation languages, operating \nsystems, etc. Although Web development standards helped, such as using an XML interface description, \nnew object hierarchies had to be developed to address specific requirements for access to HPCs, particularly \nwith respect to security mechanisms required. The FrameWork object-oriented design stood up to a significant \nredesign employing current technology for refactoring. We were able to transition the system to support \nthe integration of parallel computing software that was developed at Army, Navy and Air Force research \nlaboratories under a project funded by the High Performance Computing Modernization Office [6]. A Beta \nsoftware demonstration was presented at the HPCMO office in May, 2003. 6. Conclusion Our motivation \nfor redeveloping the HPC FrameWork was the recognition of design deficiencies that resulted in continual \nredevelopment of system components for each code added to the system. A lot of the problems emerged when \nwe were required to integrate eight codes to run under the FrameWork. An analysis of system deficiencies \nled to an improved design and significant savings in implementation effort for the integrated system. \n 7. ACKNOWLEDGMENTS This work is funded by the DOD High Performance Computing Modernization Program (HPCMP \n[8]). 8. REFERENCES [1]Spetka,S., Ramseyer,G., Linderman,R., A FrameWork for High-Performance Image \nExploitation , OOPSLA'02, Seattle, WA, Nov. 4-8, 2002 [2]GLOBUS Toolkit [http://www.globus.org/] [3]CORBA, \nCOS Naming Service [http://www.omg.org] [4]Fowler, Martin, Refactoring: improving the design of existing \ncode , Addison-Wesley, 1999 [5]MPI [http://www.mcs.anl.gov/mpi/] [6]HPCMP, CHSSI [http://hpcmo.hpc.mil/] \n  \n\t\t\t", "proc_id": "949344", "abstract": "This paper describes our experience in redeveloping an object-oriented system. Experience working with the system along with new requirements that were introduced as the system matured motivated a significant redesign and reimplementation effort. The initial object-oriented design helped to allow extension as well as restructuring of system objects. Experience in integrating new objects into the system and reimplementing objects in different languages drove a refactoring process. The Web interface to the system was reimplemented as a Grid portal.", "authors": [{"name": "Scott E. Spetka", "author_profile_id": "81100346923", "affiliation": "ITT Industries and SUNY Institute of Technology, Utica, NY", "person_id": "P643485", "email_address": "", "orcid_id": ""}, {"name": "George O. Ramseyer", "author_profile_id": "81100276531", "affiliation": "AFRL Information Directorate, Rome, NY", "person_id": "P643448", "email_address": "", "orcid_id": ""}, {"name": "Richard W. Linderman", "author_profile_id": "81100228076", "affiliation": "AFRL Information Directorate, Rome, NY", "person_id": "P242432", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949368", "year": "2003", "article_id": "949368", "conference": "OOPSLA", "title": "Redeveloping a high-Performance computing framework", "url": "http://dl.acm.org/citation.cfm?id=949368"}