{"article_publication_date": "10-26-2003", "fulltext": "\n Domain Driven Web Development With WebJinn * Sergei Kojarski David H. Lorenz Northeastern University \nCollege of Computer &#38; Information Science Boston, Massachusetts 02115 USA {kojarski,lorenz}@ccs.neu.edu \nABSTRACT Web application development cuts across the HTTP protocol, the client-side presentation language \n(HTML, XML), the server-side technology (Servlets, JSP, ASP, PHP), and the underlying resource (.les, \ndatabase, information system). Consequently, web develop\u00adment concerns including functionality, presentation, \ncontrol, and structure cross-cut, leading to tangled and scattered code that is hard to develop, maintain, \nand reuse. In this paper we analyze the cause, consequence, and remedy for this crosscutting. We dis\u00adtinguish \nbetween intra-crosscutting that results in code tangling and inter-crosscutting that results in code \nscattering. To resolve inter-crosscutting, we present a new web application development model named XP \nthat introduces extension points as place-holders for structure-dependent code. We present another model \nnamed DDD that incorporates XP into the Model-View-Controller (MVC) model to resolve both intra-and inter-crosscutting. \nWebJinn is a novel domain-driven web development framework that implements the DDD model. WebJinn has \nbeen used to develop web applica\u00adtions at several web sites. Domain driven web development with WebJinn \nbene.ts from a signi.cant improvement in code reuse, adaptability, and maintainability. Categories and \nSubject Descriptors D.2.11 [Software Architectures]: Domain-speci.c architectures, Patterns; D.2.13 [Reusable \nSoftware]: Domain engineering, Reuse models; D.2.2 [Design Tools and Techniques]: Modules and in\u00adterfaces, \nSoftware libraries; H.3.5 [Online Information Services]: Web-based services. General Terms Design, Languages. \nKeywords Web development, Web programming, Web application, Genera\u00adtive programming, Aspect-oriented \nprogramming (AOP), Cross\u00adcutting concerns, Intra-crosscutting, Inter-crosscutting, Tangling, Scattering, \nDynamic pages, Model-view-controller (MVC), JSP, Struts, Reusability, Adaptability. *Supported in part \nby the National Science Foundation (NSF) un\u00adder Grant No. CCR-0098643 and CCR-0204432, and by the Insti\u00adtute \nfor Complex Scienti.c Software at Northeastern University. Copyright is held by the author/owner. OOPSLA \n03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010.  Request  Response Client \nHTTP Server Figure 1: Web application 1. INTRODUCTION A web application is generally an HTTP gateway \nto a certain server-side resource (e.g., a .le, a database, an information system). Request parameters \nare processed by the web server and passed to the web application, which dynamically generates an HTTP \nre\u00adsponse (Figure 1). The process of writing web applications is called web development [8]. A web application \nis typically written in at least two program\u00adming languages. The presentation is described in a client-side \nlan\u00adguage (e.g., HTML or XML). The functionality is speci.ed us\u00ading a server-side language (e.g., Perl, \nPython, ASP, JSP, Java, C, Smalltalk). Since the two sets of languages require distinct skills with completely \ndifferent expertise, web development involves two development groups, namely web designers (presentation \nexperts) and web programmers (functionality experts). 1.1 Web Development Evolution The evolution of \nweb application development models is driven by the desire to modularize crosscutting concerns [18] and \ndecrease the dependency between web designers and web programmers [22]. We identify the following evolutionary \nsteps in web develop\u00adment: J0 .Static page model. In the beginning web pages were static. Static pages \nprescribe an immediate HTTP response with no required preprocessing. The response is written in HTML \nor in some other data presentation languages (such as XML) and does not depend on arguments. J1 .CGI \nscript. Scripts use print-like statements to generate a dynamic response. The presentation code is scattered \nacross the script code and hidden in the print statements. This results in a strong coupling between \npresentation and func\u00adtionality. J2 .Dynamic page model. Dynamic pages reverse the depen\u00addency between \npresentation and functionality. A dynamic page is written in a presentation-like language with the func\u00adtional \npart embedded into the page code via special tags scriplets. Despite the much cleaner look of a dynamic \npage crosscutting model framework intra MVC Struts inter XP WebJinn/XP intra + inter DDD WebJinn/DDD \n 1 2 3 Table 1: Problems, solutions, and implementations 4 5 6 relative to a script .le, the presentation \nand functionality are 7 still tangled. 8 9 J3A .MVC model. More recently, a Model-View-Controller [11] \n10 (MVC) model is being employed in web development. The Apache Struts framework [14] is a well-known \nexample of 11 this web application model. While the MVC model reduces 12 code tangling within individual \npages (intra-crosscutting), it 13 14 does not address a more severe code scattering across pages 15 (inter-crosscutting). \n16 17 1.2 Contribution The contribution of this paper is in introducing two new web 18 19 development \nmodels: 20 21 J3B .XP model. The XP model uses extension points (XP) in order 22 to better control inter-crosscutting \nin web development code. 23 WebJinn/XP is a framework implementing the XP model. 24 25 J4.DDD model. \nThe DDD model incorporates XP into the MVC 26 model to unweave both inter-and intra-crosscutting. WebJin-27 \nn/DDD is a framework implementing the DDD model. 28 29 We propose the DDD model as the next logical step \nin the web 30 development evolutionary path. Tangling and scattering are in-31 herent problems in dynamic \npages. Tangling is caused by intra\u00adcrosscutting; scattering by inter-crosscutting. The DDD model com\u00adbines \nthe MVC and XP web models to disentangle both intra-and inter-crosscutting concerns (Table 1). 1.3 Structure \nof the Paper Section 2 presents a typical web application example, imple\u00admented in the dynamic page model. \nUsing this example we demon\u00adstrate the problem of crosscutting concerns in web development. Section 3 \ndiscusses the causes and consequences of crosscutting. Section 4 presents a solution to inter-crosscutting, \nintroducing the XP model and the WebJinn/XP framework. Section 5 introduces the DDD model and the WebJinn/DDD \nframework, and lists ben\u00ade.ts and limitations of the framework. Section 6 concludes and discusses future \nwork.  2. MOTIVATION Consider a guestbook web application that allows visitors to post messages and \nread messages posted by others. The guestbook can be implemented as a set of dynamic web pages that provide \naccess to a guestbook table on the server-side database system. For example, a simple implementation \nin JSP [4] using MySQL [2, 7] consists of the following three pages:1 select.jsp (Listing 1): This page \nretrieves and displays all the records in the guestbook database table. .We illustrate the guestbook \nexample concretely using JSP pages, but the crosscutting problems shown here are not unique to JSP they \nexist in other dynamic page technologies too. The implemen\u00adtation uses the MySQL DBMS, but any other \nDBMS can be used instead. Listing 1: select.jsp To process a request, the page loads the MySQL JDBC \ndriver (line 3), establishes a connection to the database (lines 4 6), obtains the content of the guestbook \ntable (lines 8 10), and eventually closes the database connection (line 26). The set of messages selected \nfrom the guestbook table is assigned to rs (line 9), a variable of type java.sql.Result\u00adSet.If rs represents \na non-empty set of records, the page re\u00adsponds with the CONTENT view (lines 12 20). The CON-TENT view \nrenders each record in the rs record set as an HTML table row (lines 14 18). The view accesses the rs \nvariable via Java scriplets. If rs contains no messages, then the NO RECORDS view (lines 22 24) is returned \nto the client. In case an exception is thrown during the processing of a request (for example, if the \nJDBC driver was not found or if the JDBC connection was not established properly), the page responds \nwith the SER-VICE NOT AVAILABLE view (lines 28 30). insertForm.jsp (Listing 2): This page displays an \nHTML form that the visitor can .ll in order to add a new entry. The insertForm.jsp page is a piece of \nstatic HTML code that returns an HTML form to the client. Each .eld in the form speci.es one parameter \nof the request. When the user submits the form, the request is sent to the doIn\u00adsert.jsp page, as speci.ed \nby the action attribute of the form tag (line 1). doInsert.jsp (Listing 3): This page obtains the message \ndata from the request parameters and adds the new message into the guestbook table. Listing 2: insertForm.jsp \n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Listing 3: doInsert.jsp 1 2 3 4 5 6 7 8 9 10 11 12 \n13 14 15 16 17 18 19 20 21 22 <%}%> The request processing logic steps include loading the MySQL JDBC \ndriver (line 3), establishing a connection to the database (lines 5 6), constructing and executing an \nSQL insert state\u00adment (lines 8 13), and .nally closing the database connec\u00adtion (line 17). Normally, \nthe page responds with the SUCCESS view (lines 14 16). In case of an exception, caused by a faulty request \nparameter or a server-side failure (e.g., when the driver is not found or the connection cannot be established) \nthe FAIL view (lines 19 21) is returned to the client instead. The structure of the guestbook tableisspeci.edinSQL: \ncreate.sql (Listing 4): The table has four columns: id, name, email,and message.The id column is the \nprimary key. The name and email columns store the visitor s name and email, respectively. The message \ncolumn is a placeholder for guestbook messages. The name and email columns al\u00adlow to store arrays of \ncharacters of variable length with a maximum length of 50 characters. The message column stores textual \ndata and is limited to 64K. Listing 4: create.sql 1 create table guestbook ( 2 int auto_increment primary \nkey, 3 varchar(50), 4 varchar(50), 5 message text) The guestbook example is a simpli.ed version of a \nreal guest\u00adbook application. First, it has just three .elds. A general web appli\u00adcation may have dozens \nof .elds [20]. Second, doInsert.jsp doesn t validate the .elds values. A professional web application \nshould check when a new record is added whether or not the .elds were properly entered. Third, insertForm.jsp \ncontains only static HTML code, and the form is used only for insert. Poten\u00adtially, insertForm.jsp could \nhave also been used as a return form, using dynamic code to highlight any ill-.lled .eld, in case doInsert.jsp \ndetects a form .eld that was improperly .lled. Nevertheless, the guestbook example is very close to a \nreal-life application code and suf.cient for illustrating the typical problems in writing web applications \nin today s popular dynamic page tech\u00adnologies, such as ASP, JSP, PhP, etc. Moreover, the guestbook in\u00adteraction \nwith the server-side database is typical to many similar applications, such as a news server, a repository \nof publications, a photo gallery, and the like. 2.1 Tangled Code The guestbook example highlights four \ntypical application con\u00adcerns, three of which result in tangled code:   2.2 Scattered Code The fourth \nand most fundamental concern results in scattered code: Structure. The structure concern of a web application \nre\u00adlates to any knowledge about structure that is used by the web application to process HTTP requests \nand generate a re\u00adsponse. As a layer between the HTTP and the server-side data and functionality, a web \napplication expects that both the request parameters and the underlying resource satisfy certain structural \nrequirements. This kind of knowledge al\u00adlows web applications to convert HTTP requests into server\u00adside \noperations and, conversely, generate a response re.ect\u00ading the resource state. More speci.cally, the \nstructure con\u00adcern comprises all expressions in the web application code that refer to structural features \nof either the request param\u00adeters or of the underlying resource. Inter-crosscutting Figure 2: Crosscutting \nin web application code  3. CONSEQUENCES OF CROSSCUTTING The guestbook code example reveals two distinct \npatterns of crosscutting concerns, namely intra-crosscutting and inter-crosscut\u00adting. The tangling of \nfunctionality, presentation, and control within a single dynamic page is a result of intra-crosscutting \nof the appli\u00adcation s concerns. The scattering of structure across functionality and presentation and \nacross pages is a result of inter-crosscutting. Figure 2 depicts the relationship between intra-and inter-crosscut\u00adting. \nIntra-crosscutting affects only dynamic pages. Each instance of intra-crosscutting is scoped within a \nsingle dynamic web page and does not affect parallel pages. For example, changes to Page . would not \naffect the intra-crosscutting in pages Page.,...,Pagen, and vise versa. Intra-crosscutting is a shortcoming \nof dynamic pages by design, and depends only upon the speci.c functionality, presentation, and control \ncode within the affected page. Inter-crosscutting, on the other hand, re.ects and depends upon the underlying \nresource structure. Inter-crosscutting affects most of (sometimes all) the application pages, both dynamic \nand static. Structural modi.cations normally affect inter-crosscutting and lead to multiple changes across \nthe application .les. Inter-crosscutting and intra-crosscutting are orthogonal. Intra\u00adcrosscutting deals \nonly with the presentation, functionality, and control concerns, ignoring the structure concern entirely. \nInter\u00adcrosscutting deals with the intersection between the application s structure, functionality, and \npresentation concerns, regardless of whether the functionality and presentation are tangled or not. The \nrest of this section analyzes the consequence and possible remedy for each kind of crosscutting. 3.1 \nIntra-crosscutting Intra-crosscutting is illustrated by the background shades in List\u00adings 1 and 3. The \ncode in select.jsp and doInsert.jsp consists of tangled pieces of presentation, functionality, and con\u00adtrol \ncode. Intra-crosscutting occurs in dynamic pages that contain both func\u00adtionality and presentation code. \nStatic web pages (written entirely in HTML/XML) are not affected by intra-crosscutting since they contain \nonly presentation code. For example, insertForm.jsp (Listing 2) contains only HTML code and thus free \nof intra-crosscut\u00adting. Furthermore, the corresponding concerns in select.jsp and doInsert.jsp are independent \nof each other. The scope of each instance of the three concerns is contained within a single dynamic \npage. Consequently, intra-crosscutting is an individual property of a particular dynamic page. Intra-crosscutting \nresults in a strong coupling between presenta\u00adtion, functionality, and control. This kind of coupling \ndrastically increases the dependency between different development groups resulting in high development \nand maintenance cost. Consider re\u00addesigning the user interface, a common task in both development and \nmaintenance stages. During redesign even the recovering from an occasional typo in the embedded Java \ncode is beyond the abil\u00adity of a web designer. As a result, a web programmer must be involved. Moreover, \ntangled code is more dif.cult to read and un\u00adderstand even for an experienced web developer. Intra-crosscutting \nis a well-known problem in dynamic pages. This problem triggered the application of the MVC design pattern \n[10] to web development. Apache Struts is a web development framework that implements the MVC model. \nThe MVC web model imposes design-level restrictions that allow to achieve a clean sep\u00adaration between \nthe presentation, functional and control concerns. 3.2 Inter-crosscutting Inter-crosscutting is demonstrated \nin the guestbook example code by the highlighted fragments of structure-related code that are scat\u00adtered \nthroughout the application .les (listings 1, 2, 3, and 4). In comparison to intra-crosscutting, inter-crosscutting \nis a more severe problem, for the following reasons. First, the inter-crosscut\u00adting scope cuts across \npage boundaries and can occur in multiple pages. In the guestbook example, expressions related to structural \nelements (name, email,and message) appear in all pages: in-sertForm.jsp, doInsert.jsp,and select.jsp.More \ngenerally, pages interacting with or providing an interface to the same underlying resource must be kept \nin sync with the resource s structure. Consequently, the structure concern cuts across all such pages. \nSecond, inter-crosscutting affects static pages as well as dynamic pages. For example, insertForm.jsp \n(Listing 2) is a static page but contains a set of highlighted structure-related code frag\u00adments. Third, \nthe spread of inter-crosscutting is less regular than intra\u00adcrosscutting. The structure concern can occur \nwithin a page in one, two, or more places, cutting across either functionality, presenta\u00adtion, or both, \nand expressed in different syntactical forms. For ex\u00adample, expressions related to the email .eld occur \ntwice in the presentation code of insertForm.jsp (Listing 2, lines 9 and 10), once in the presentation \ncode, once in the functionality code of select.jsp (Listing 1, lines 10 and 15), and twice in the func\u00adtionality \ncode of doInsert.jsp (Listing 3, lines 9 and 11). Inter-crosscutting reveals a strong dependency of web \napplica\u00adtion code on the structure concern. Structure is intertwined with the functionality and presentation \ncode in a quite complicated manner. The structure concern is a rigid skeleton that cross-cuts multiple \napplication .les coupling the web application to a particular un\u00adderlying resource structure. Having \nsuch a skeleton in the code results in a high application assembly cost, in a high development and maintenance \ncost, and in loss of reuse opportunities. 3.3 High Application Assembly Cost The web application is \na network of physical modules (pages), connected through various available mechanisms (request param\u00adeters, \ncookies, JSP page scope, session or application context at\u00adtributes, etc.) Independent of the particular \ncommunication mecha\u00adnism, the protocol of communication normally relies on the appli\u00adcation s structure \nconcern. For example, the functionality code in doInsert.jsp (List\u00ading 3) and the presentation view speci.ed \nin insertForm.jsp (Listing 2) communicate through HTTP request parameters. The communication protocol \nis speci.ed via three parameters: name, email,and message. For each parameter, a .eld is declared in \nthe HTML form (insertForm.jsp, lines 6, 10, and 14 in List\u00ading 2). The HTTP request is received and read \nin doInsert.jsp (lines 10-12 in Listing 3). Expressions implementing the commu\u00adnication between insertForm.jsp \nand doInsert.jsp rely upon the structure application concern. During the application assembly stage developers \nensure correct and reliable communication between the application parts. Scat\u00adtered structural elements \nhinder the assembly by requiring a com\u00adplex weaving operation (weaving of the structure concern into \nthe application code). Complex weaving increases assembly costs both directly (weaving takes developer \ns time and effort) and indirectly (since weaving is error-prone, additional application testing is re\u00adquired \nto ensure correctness). Moreover, since weaving affects both functionality and presentation code, it \nrequires a collaborative ef\u00adfort of both web designers and web programmers. As a conse\u00adquence, the weaving \nbecomes the bottleneck of the web application assembly stage. 3.4 High Development and Maintenance Cost \nDuring web application development and maintenance, structure changes are a very common requirement. \nUnlike the guestbook example, a typical web application usually has many .elds. The more .elds the more \nlikely the customer would ask for changes in some of them. Changing the existing structure generally \nrequires two opera\u00adtions: weaving and unweaving. The weaving operation is identi\u00adcal to the one performed \nduring application assembly. Unweaving is the opposite of weaving: it requires careful removal of obso\u00adlete \nstructural information from the application code. Even though removing requires less skills than adding, \nthe complexity of the un\u00adweaving operation is close to that of weaving. The developer must go over all \naffected locations in the code and carefully edit them. For example, just removing the email .eld from \nthe guestbook example would require to remove lines 8 11 from insertForm\u00ad.jsp (Listing 2), to edit lines \n10 and 15 in select.jsp (List\u00ading 1), andtoedit line9andtoremove line11in doInsert.jsp (Listing 3). Due \nto inter-crosscutting, the weaving and unweaving operations are expensive, signi.cantly increasing the \napplication development and maintenance cost. 3.5 Loss of Reuse Opportunities When the application code \nis written against a particular struc\u00adture in mind, its reusability is close to impossible. The problem \nof loss of reuse opportunities is particularly acute in web applica\u00adtion development: most web applications \nprovide similar or identi\u00adcal services (records retrieval, record insertion, record update, etc.) and \ndiffer only in structure. Yet, to reuse code, developers need to perform complex weaving and unweaving \noperations, and the overhead quickly out-weights the bene.ts of reuse thus hindering product-line development. \nAs a result, instead of reusing exist\u00ading code, developers often end up writing a new application from \nscratch, spending much time and efforts to recreate very familiar functionality. Despite its obvious \nseverity, no comprehensive solution for the inter-crosscutting problem exists to date. Current web develop\u00adment \ntechnologies and models fail to identify and address inter\u00adcrosscutting, leaving developers to cope alone \nwith the problem. Having no institutional support, advanced developers sometimes build their own ad-hoc \ntools to tackle speci.c cases. Typical ex\u00adamples include generating dynamic pages (e.g., Wizard [25], \nAu\u00adtoWeb [9]) for inserting a record, retrieving records, and updating a record. Ad-hoc solutions may \nsigni.cantly improve development ef.ciency for a speci.c task (e.g., [1]). However, they fail to solve \ninter-crosscutting in general.  4. THE XP MODEL Solving the inter-crosscutting problem is crucial for \nbuilding web applications more ef.ciently. In this section we present an inter\u00admediate web model called \nExtension Point (XP) for localizing the structure concern. The XP model allows web programmers to cre\u00adate \nstructure-free applications that can be adapted to various struc\u00adtural requirements. The WebJinn/XP framework \n(Section 4.2) is an implementation of the XP model. In Section 5 we then build on the XP model in presenting \nthe complete domain-driven web develop\u00adment model and the WebJinn/DDD framework. 4.1 Unweaving Inter-Crosscutting \nAt the code level, the structure concern is represented by a set of structure-dependent code fragments \nscattered across the appli\u00adcation. While scattered, these fragments typically appear in clus\u00adters. Each \nstructure-dependent code fragment belongs to exactly one cluster (some clusters may be singletons). All \nfragments within a cluster implement the same semantic operation. For example, in the guestbook application \nthere are four clusters corresponding to four semantic operations: Construction of the SQL select statement: \nLine 10 in List\u00ading1(select.jsp).  Rendering the guest book messages: Lines 15 17 in List\u00ading1(select.jsp). \n Construction of the HTML-based insert form: Lines 5 6, 9 10, and 13 14 in Listing 2 (insertForm.jsp). \n Construction of the SQL insert statement: Lines 9 12 in List\u00ading3(doInsert.jsp).  The main insight \nbehind the XP model is that a complete sepa\u00adration between application code and inter-crosscutting structure \nis achievable by substituting the structure-dependent clusters with ex\u00adtension points. An extension point \nmarks a hole in the code to be later .lled with structure-dependent fragments. An applica\u00adtion that declares \nextension points in place of structure-dependent clusters becomes structure-free and is called an abstract \nweb appli\u00adcation. The XP model allows to develop abstract applications and struc\u00adture modules separately. \nThe concrete application is compiled from an abstract application and a structure module. We refer to \nthis compiler as the weaving function. The weaving function Wtakes an abstract application Aand a structure \nmodule Sas input and produces the concrete executable application Eby weaving clus\u00adters found in Sinto \nthe corresponding extension points declared in A: W(A,S)E (1) The XP model is illustrated in Figure 3. \nThe .gure shows an abstract application Awith four extension points. The structure module Scontains four \nclusters of code fragments corresponding to the extension points. The executable application Eis assembled \nby weaving the content of Sinto the abstract application A. A  Figure 3: XP model  4.2 The WebJinn/XP \nFramework XP is the abstract model for resolving inter-crosscutting. The WebJinn/XP framework is a concrete \nimplementation of the XP model, providing a precise speci.cation for A, S,and W. To explain the working \nof the WebJinn/XP framework, three ad\u00additional technical terms are needed, namely .eld, template, and \ngroup. Field. At the logical level, Scomprises a set of logical .elds. In the guestbook application, \nfor example, the logical .elds are: name, email,and message. The code fragments scat\u00adtered across the \napplication are the projection of these .elds onto the code level. For example, the email logical .eld \nis dispersed throughout the application code. Furthermore, a logical .eld projects code fragments with \ndifferent syntac\u00adtical forms. For example, the email projections have var\u00adious forms: email, E-mail, \nrs.getString(\"email\"), and <input type=text name=\"email\">. To model this, the WebJinn/XP framework introduces \na field data struc\u00adture with an array of named attributes. Each attribute asso\u00adciates a syntactical form \nwith the logical .eld it represents.  Template. A further study of the code fragments reveals that in \nmost cases projections of different .elds that fall in the same cluster not only implement a similar \nlogical operation, but also have a similar syntactical form. For example, in the construction of the \ninsert form (Listing 2), three .elds are involved, name, email,and message, all of which follow the same \ntemplate [5]:  <tr> <td> display attribute </td> <td> input attribute </td> </tr> Consequently, a \ncluster can be succinctly represented as a pair: ({felds}. ,template)(2) The template is parameterized \nover .eld attributes but spec\u00adi.es no knowledge of concrete structure. As a structure-free abstraction, \nthe template is used in the WebJinn/XP frame\u00adwork to implement an extension point. It speci.es the se\u00admantic \noperation represented by the extension point to be performed for each .eld in the sequence of .elds. \nListing 5: DTD for specifying structure 1 <!ELEMENT ddd:structure (ddd:fields, ddd:groups)> 2 <!ELEMENT \nddd:fields (ddd:field*)> 3 <!ELEMENT ddd:field (ddd:attribute*)> 4 <!ELEMENT ddd:attribute EMPTY> 5 \n<!ELEMENT ddd:groups (ddd:group*)> 6 <!ELEMENT ddd:group (ddd:fieldref*)> 7 <!ELEMENT ddd:fieldref \nEMPTY> 8 <!ATTLIST ddd:field 9 name ID #REQUIRED>  10 <!ATTLIST ddd:attribute  11 name CDATA #REQUIRED \n 12 value CDATA #REQUIRED>  13 <!ATTLIST ddd:group  14 name ID #REQUIRED>  15 <!ATTLIST ddd:fieldref \n 16 name IDREF #REQUIRED>  Group. So far the representation of a cluster contains both a structure-dependent \npart (sequence of .elds) and a structure\u00adfree part (template). To avoid hard-coding structure-dependent \nelements in the abstract application, groups are used. A group denotes a sequence of .elds and is uniquely \nde.ned in the structure module. Each extension point is represented as a pair: (group,template)(3) A \ngroup in an abstract application code is a reference to the group de.ned in the structure module. The \ngroup reference is used for obtaining the .eld set, which is required during application assembly to \nweave the executable code.  4.3 Implementation Details The structure module is speci.ed in an XML .le \nthat conforms to the Document Type De.nition (DTD [17]) shown in Listing 5. A <ddd:structure> (line 1) \ntag is the root of the XML de.nition. It has two children, <ddd:fields> (line 2) and <ddd:groups> (line \n5). The .rst stores a set of .elds speci.ed via <ddd:field> (line 3) tags, and the second contains a \nset of groups de.ned via <ddd:group> (line 6) tags. A set of <ddd:attribute> (line 4) tags, hosted within \nthe body of a corresponding <ddd:field> tag, specify the attributes of a .eld. A group includes .elds \nby reference using a <ddd:fieldref> (line 7) tag. The XML .le structure.xml (Listing 6) de.nes the struc\u00adture-dependent \ncode fragments found in the guestbook s insert\u00adForm.jsp (Listing 2) and doInsert.jsp (Listing 3) pages. \nThe three .elds are in the .eld set: name (lines 4 9), email (lines 10 15), and message (lines 16 21). \nThe four attributes column, request, display,and input are speci.ed for each of the .elds. The group \nset consists of two groups, namely insertFormFields (lines 24 28) and ddd.InsertExtension (lines 29 33). \nEach group includes all the .elds. The WebJinn/XP framework distinguish between textual and func\u00adtional \nextension points. Within presentation code, textual extension points are used. To decouple structure \nand functionality, functional extension points are used. 4.3.1 Textual extension point Textual extension \npoints are declared using XML format. The DTD for a textual extension point declaration is presented \nin List\u00ading 7. The <ddd:extension_point> (lines 1 2) tag declares a textual extension point. The group \nattribute (lines 7 8) of the tag is a reference to a group de.ned in a structure module. A template is \nde.ned within the body of a <ddd:template> (lines 3 4) tag, Listing 6: structure.xml Listing 8: insertForm.jsp \n 35 </ddd:structure> Listing 7: DTD for textual extension point  1 <!ELEMENT ddd:extension_point 2 (ddd:template, \nddd:generated?)> 3 <!ELEMENT ddd:template  4 (#PCDATA | ddd:attribute)*>  5 <!ELEMENT ddd:attribute \nEMPTY>  6 <!ELEMENT ddd:generated ANY>  7 <!ATTLIST ddd:extension_point  8 group CDATA #REQUIRED> \n 9 <!ATTLIST ddd:attribute  10 name CDATA #REQUIRED>   the child of the <ddd:extension_point> tag. \nA template rep\u00adresents a string that includes several <ddd:attribute> (line 5) tags, each one de.ning \na hook. The hooks are replaced with actual values of corresponding .eld attributes when the .eld is weaved \ninto the extension point. The <ddd:generated> (line 6) tag is optional. It doesn t belong to the extension \npoint de.nition and is used as a placeholder for expressions generated by the weaver dur\u00ading application \nassembly. An example of the <ddd:generated> tag is found in Listing 13 (lines 11 24). An example of using \na textual extension point is shown in List\u00ading 8. The extension point (lines 4 11) describes the rendering \nof the insert form in a structure-free manner. Its structure-dependent counterpart is de.ned in insertForm.jsp \n(Listing 2). The ex\u00adtension point is associated with the insertFormFields group (line  14 </form> Listing \n9: Extension.java 1 package edu.neu.ccs.ddd; 2 public interface Extension { 3 void doAction() throws \nException; 4 }  4) by the the group attribute in the <ddd:extension_point> tag. The <ddd:template> \ntag speci.es the template (lines 5 10). The template de.nes two attribute hooks via <ddd:attribute> tags: \ndisplay (line 7) and input (line 8).  4.3.2 Functional extension point Functional extension points \nare de.ned using a speci.c object\u00adoriented framework. In this framework, each extension point has a corresponding \nextension class implementing the edu.neu.ccs\u00ad.ddd.Extension interface. This interface, shown in Listing \n9, de.nes a single void doAction() method (line 3). The extension point itself is speci.ed in the functionality \ncode as a set of call sites targeting the corresponding extension class. Normally, it includes the instantiation \nof the extension class, the initialization of the constructed instance, a call to doAction,and the acquisition \nof the result. The implementation of the doAction method encapsulates all structure-dependent operations \nassociated with the extension point. The structure-independent equivalent of doInsert.jsp (List\u00ading 3) \nis presented in Listing 10. The ddd.InsertExtension class is an extension class for the extension point \n(lines 8 15). The code .rst creates an extension class instance (lines 8 9), cus\u00adtomizes it (lines 10 \n12), invokes doAction (line 13), and acquires the result via prepareStatement (line 15). The last method \ncall returns an instance of java.sql.PreparedStatement that rep\u00adresents a ready-to-execute insert SQL \nquery constructed for a particular guestbook database table. While extension classes decouple structure \nfrom functionality, the problem of inter-crosscutting remains: the structure concern still cross-cuts \nthe extension class code. To unweave the structure concern from the extension class code, the WebJinn/XP \nframework provides a Java API for accessing the application s structure mod\u00adule. The framework forces \nall extension classes to use this API as the only source of structure meta-data. To enforce this implementation \nstrategy for extension classes, the WebJinn/XP framework provides a NormalizedExtension base class (Listing \n11). NormalizedExtension de.nes two im\u00adportant mechanisms. First, it speci.es the relation between the \nex\u00adtension classes and the structure groups (lines 17 18). Each exten\u00adsion class instance is associated \non construction with an API Group object using the class name as the group name. Second, it speci.es \n Listing 11: NormalizedExtension.java 1 public abstract class NormalizedExtension 2 implements Extension \n{ 3 4 public void doAction() throws Exception { 5 Field[] fields = group.getFields(); 6 for (int i=0;i<fields.length;i++) \n7 doFieldAction(fields[i]); 8 } 9 10 protected Group group; 11 12 protected String getGroupName() { \n13 return getClass().getName(); 14 } 15 16 protected NormalizedExtension() { 17 group = MetaDataProvider.getMetaData(). \n18 getGroup(getGroupName()); 19 } 20 21 protected abstract void doFieldAction(Field field) 22 throws \nException; 23 } a structure-dependent operation as a sequence of operations, one per .eld in the group \n(lines 5 7). The doFieldAction(Field field) method is a placeholder for the template to be instantiated \n(executed) for each .eld in the group. The ddd.InsertExtension class (Listing 12) inherits from the class \nNormalizedExtension.An InsertExtension instance is associated, on construction, with the ddd.InsertExtension \ngroup de.ned in the structure.xml .le (Listing 6). Further\u00admore, the doFieldAction method accesses two \n.eld attributes (lines 18 19), namely column and request.The doFieldAction method is called for each \n.eld in the ddd.InsertExtension group. The .eld s attributes are retrieved and stored, and later used \nto con\u00adstruct the SQL insert statement (generateSQL, lines 37 47). Listing 12: InsertExtension.java 1 \npackage ddd; 2 //part of text omitted... 3 4 public class InsertExtension 5 extends NormalizedExtension \n{ 6 7 /..Creates, prepares and returns PreparedStatement ./ 8 public PreparedStatement prepareStatement() \n throws Exception { 9 PreparedStatement result = conn. prepareStatement(generateSQL());  10 for (int \ni=0;i<values.size();i++) 11 result.setString(i+1,(String)values.get(i)); 12 return result; 13 } 14 15 \n/..Saves request parameter value and column name ./ 16 protected void doFieldAction(Field field) 17 throws \nException { 18 String columnName=field.getAttribute(\"column\"); 19 String paramName=field.getAttribute(\"request\"); \n20 columnNames.add(columnName); 21 values.add(request.getParameter(paramName)); 22 } 23 24 /..Set by \nclients via setter methods ./ 25 private String tableName; 26 private Connection conn; 27 private HttpServletRequest \nrequest; 28 29 /..Internal instance variables ./ 30 private ArrayList columnNames=new ArrayList(); 31 \nprivate ArrayList values=new ArrayList(); 32 // ... 33 // Setter methods for tableName, conn and request \n34 // ... 35 36 /..Generates SQL string ./ 37 private String generateSQL() { 38 int count = columnNames.size(); \n39 String columns =(String)columnNames.get(0); 40 String vals = \"?\"; 41 for (int i=1;i<count;i++) { 42 \ncolumns = columns+\",\"+(String)columnNames.get (i); 43 vals = vals + \",?\"; 44 } 45 return \"Insert into \n\"+tableName+ 46 \"(\"+columns+\") values (\"+vals+\")\"; 47 } 48 } The ddd.InsertExtension class is hence structure-free. \nThe structure of the SQL statement to be constructed is not hard-coded. It is obtained using an API at \nrun-time. The WebJinn/XP framework supports dynamic weaving. It al\u00adlows to re-weave the structure module \ninto the abstract application at run-time. The implementations details, however, differ for tex\u00adtual \nand functional extension points.  4.3.3 Weaving into textual extension points Weaving into textual extension \npoints changes the application s source code. The group attribute of an extension point tag asso\u00adciates \nthe textual extension point with a group de.ned in the struc\u00adture module. Once the weaver has both the \nextension point and the group, it combines them by instantiating the extension point template for each \n.eld in the group. Instantiation means replac\u00ading hooks (de.ned via <ddd:attribute> tag) that are found \nin  28 </form> the template with appropriate .eld attribute values. The result of weaving is wrapped \ninto <ddd:generated> start and end tags and is placed into the body of the host extension point tag. \nConsider again the structure module in Listing 6 and the ex\u00adtension point in Listing 8. The <ddd:extension_point> \ntag s group attribute (Listing 8, line 4) instructs the weaver that the ex\u00adtension point should be associated \nwith the insertFormFields group. This group, de.ned in structure.xml (Listing 6, lines 24 28), contains \nthree .elds, namely name, email,and message. The weaver instantiates the template (Listing 8, lines 5 \n10) by re\u00adplacing attribute tags named display and input with the corre\u00adsponding attribute values for \neach of the three .elds. The instan\u00adtiated expressions are wrapped with <ddd:generated> tags and placed \ninto the body of the <ddd:extension_point>.The ex\u00adtension point and the template tags are left in the \ncode to allow re-weaving when the structure changes. The result of the weaving is presented in Listing \n13. Textual extension points are physically located within presenta\u00adtion code. The weaving affects JSP \npages, and since the JSP con\u00adtainer (server) re.ects changes in pages as they occur, the result of weaving \nis immediately visible to clients (on the next request). Hence, weaving into textual extension point \nis dynamic.  4.3.4 Weaving into functional extension points The WebJinn/XP framework provides an implementation \nof the Java API that allows clients to access structure module content at run-time. The weaving algorithm \nfor functional extension points is de.ned in the NormalizedExtension class (Listing 11, lines 17 18). \nUsing the MetaDataProvider.getMetaData static method in the MetaDataProvider class, which exists in the \nJVM on a per-application basis, an extension class obtains a MetaData in\u00adstance for its enclosing web \napplication. The MetaData instance represents a structure module and provides access to its content. \nUsing the MetaData instance, the extension class then obtains the appropriate Group object. Since NormalizedExtension \nis a base class for most (nor\u00admally all) extension classes, weaving structure into functional ex\u00adtension \npoints means setting up the appropriate MetaData object to be returned by the MetaDataProvider.getMetaData \nstatic method. This object is updated either at application start-up or each time the structure is (re)weaved \ninto the application. As a result, dynamic weaving is achieved.  5. THE DDD MODEL AND WEBJINN The DDD \nmodel combines the MVC and XP models to provide a uni.ed solution to both intra-and inter-crosscutting. \nThis section describes the WebJinn/DDD framework that implements the DDD model. The WebJinn/DDD is a \ncombination of Apache Struts [13, 19, 23, 14] and WebJinn/XP. In order to present WebJinn/DDD, we .rst \nbrie.y introduce the basics of the Apache Struts/MVC frame\u00adwork. 5.1 The Apache Struts Framework The \nApache Struts/MVC framework organizes the web applica\u00adtion code in three modules, namely model, view,and \ncontroller. The model modularizes functionality associated with the un\u00adderlying resource. It is external \nto the web application tier and is merely an abstract interface to the underlying resource. The model \nis also used by interactive clients, other than the web application.  The view speci.es the application \ns presentation. It is imple\u00admented as a set of JSP pages, also called presentation views. A presentation \nview contains only HTML or XML code.  The controller consists of two subcomponents: controller servlet \nand a setof action adapters.  The controller servlet implements the application s control. It manages \nthe processing of requests. Upon receipt of an HTTP re\u00adquest, the controller servlet delegates the processing \nto an appro\u00adpriate action class. After the action class completes its processing, the servlet selects \nan appropriate presentation view to render the response. An action class implements the web-tier functionality. \nFirst, it converts request parameters into model terms. Second, it executes one or more model operations. \nThird, it converts the results ob\u00adtained from the model into a form that is appropriate for render\u00ading \nby the presentation views. Communication between the action classes and the presentation views is implemented \non top of the web-tier facilities (Servlet API). The structure concern, however, remains scattered across \nthe view and controller in the Apache Struts framework, inter-cross\u00adcutting the presentation views and \naction adapters. To unweave it, the Apache Struts framework needs to be integrated with the Web\u00adJinn/XP \nframework. An early version of the WebJinn/DDD consisted of two frame\u00adworks, namely WebJinn/MVC and WebJinn/XP.2 \nHowever, to make WebJinn more accessible, in later versions the WebJinn/MVC frame\u00adwork was replaced with \nthe Apache Struts/MVC framework. The WebJinn/XP framework was superimposed over the Apache Struts code \nto provide a complete separation of the four application con\u00adcerns. .The early version of WebJinn was \ndeveloped in 2001 and predated the Apache Struts framework. Web-application  Figure 4: The WebJinn/DDD \nframework  5.2 The WebJinn/DDD Framework In the WebJinn/DDD framework, textual extension points are \ndeclared within the presentation views, and functional extension points within the action classes. The \nintegrated code satis.es both the Apache Struts and the WebJinn/XP framework speci.cations. The WebJinn/DDD \narchitecture is shown in Figure 4. In order to illustrate the working of the WebJinn/DDD frame\u00adwork, \nwe return to doInsert.jsp (Listing 3) and insert\u00adForm.jsp (Listing 2), and present these guestbook pages \nagain in the WebJinn/DDD framework. The presentation of select.jsp (Listing 1) in WebJinn/DDD is omitted. \n5.2.1 Control The control concern of the guestbook application is speci.ed by the struts-config.xml .le. \nstruts-config.xml (Listing 14): This .le customizes the ap\u00ad plication s controller servlet by specifying \ntwo mapping re\u00ad lations: (1) Mapping a physical URI to an action class. The map\u00adping of physical URIs \nto action classes associates in\u00adcoming HTTP requests with appropriate action classes. It is speci.ed \nwithin the action-mappings tag body. Each action tag represents an action class. Mapping between an action \nclass and a physical URI is speci.ed by the path attribute of the action tag. For exam\u00adple, in struts-config.xml \nthe /insert URI is mapped to the ddd.InsertAction class. (2) Mapping a logical URI to a physical URI. \nAction classes de.ne logical states of the request processing result. For example, the insert operation \ncould terminate with either the SUCCESS or FAIL states. These logical states are called logical URIs. \nA logical URI is returned to the controller servlet as the result of the action class execution.  To \nassociate a logical URI with the corresponding pre\u00adsentation view, the controller servlet is provided \nwith a logical-to-physical URI mapping. The mapping is de.ned via forward tags located in the body of \nthe action tag: the name and path attributes of a forward tag denote associated logical and physical \nURIs. The SUCCESS and FAIL logical URIs are mapped in Listing 14 to the physical URIs /insertSUCCESS. \njsp and /insertFAIL.jsp, respectively.  5.2.2 Presentation The presentation concern consists of three \nviews: insertSUC\u00adCESS.jsp, insertFAIL.jsp,and insertForm.jsp. insertSUCCESS.jsp (Listing 15): This view \npresents success\u00adful completion of the message-insertion operation. The view is included into the response \nwhen the ddd.InsertAction action adapter returns the SUCCESS logical URI. insertFAIL.jsp (Listing 16): \nThis view presents message\u00adinsertion failure. The view is returned to the client when the ddd.InsertAction \naction adapter returns the FAIL logical URI. The view insertFAIL.jsp uses an html:errors tag to render \nerrors that occurred in the action class code. This tag is a member of the Apache Struts tag library. \nThe tag library is used to remove Java scriplets from presentation code. The library tags provide an \nXML interface to common pieces of Java functionality that occur within the presentation code. insertForm.jsp: \nIn the application that is based on exten\u00adsion points, this view is identical to the insertForm.jsp code \nshown in Listing 8 except for the .rst and last lines. In the .rst line, form action=\"doInsert.jsp\" is \nsubsti\u00adtuted with html:form action=\"/insert\",and form is replaced with html:form in the last line. These \nchanges are required to represent the HTML form in the Apache Struts format.  5.2.3 Functionality The \nfunctionality concern is speci.ed by the ddd.InsertAction action class. InsertAction.java (Listing 17): \nThe action class is inte\u00adgrated into the WebJinn/XP framework via a functional ex\u00adtension point associated \nwith the ddd.InsertExtension extension class (Listing 10). The ddd.InsertAction class is completely separated \nfrom the structure concern.  5.2.4 Structure Finally, the structure concern is speci.ed in the structure.xml \n.le. structure.xml: The revised structure.xml is similar to the code shown in Listing 6, with the following \nminor changes. The input attribute of the .elds name, email,and message should be respectively changed \nto <html:text property= name />,to <html:text property= email />,and to <html:textarea property= message \n/>. Similar to the case with insertForm.jsp, these changes are required to conform with the Apache Struts \nformat. The WebJinn/DDD framework was used in developing intranet sites as well as a number of commercial \ninternet web sites (e.g., psn.saturn-r.ru, keramika.perm.ru, robi.perm.ru, client.saturn-r.ru, marketing.perm.ru). \nThe list of WebJinn/DDD based applications includes a forum, a guestbook, a news server, a FAQ list, \na catalogue, a user authorization system, a .le catalogue, and many more. We conclude this section with \na list of bene.ts and a couple of limitations of the WebJinn/DDD framework.  5.3 Bene.ts Web development \nwith WebJinn/DDD bene.ts primarily from new opportunities for reuse in the application code and ease \nof adaptability [21]. The WebJinn/DDD framework supports two reuse mechanisms: reuse through composition \nand reuse through spe\u00adcialization. WebJinn/DDD also employs component-based [24, 12] and product-line \n[6, 3] software engineering methods to facilitate rapid development and customization. Reuse through \ncomposition. Most web applications imple\u00adment an identical set of services (e.g., retrieve records, in\u00adsert \nrecord, update record), but their service components are structure-dependent and therefore normally cannot \nbe reused across applications. In the DDD model, however, these com\u00adponents become structure-free and \ninterchangeable. The We\u00adbJinn/DDD framework allows different web applications to be composed from the \nsame library of service components.  Reuse through specialization. Popular web applications (e.g., guestbook, \nforum, news) are in constant demand by new cus\u00adtomers. Despite the identical desired functionality, the \nactual implementations of the same web application that run at dif\u00adferent web sites are mostly different \ndue to the site-speci.c inter-crosscutting. In the DDD model, however, these struc\u00adtural differences \nare customizable. The WebJinn/DDD frame\u00adwork allows the same web base-application to be easily spe\u00adcialized \nfor different clients.  Reusable libraries. WebJinn/DDD employs two libraries (Fig\u00adure 5). Widely used \napplication services are de.ned in a component library. A component is a structure-free service implemented \nas a WebJinn/DDD abstract application. An ap\u00adplication template library speci.es families of common web \napplications. An application template consists of one or more components from the component library. \nAn executable ap\u00adplication is produced from an application template by weav\u00ading in appropriate structure-speci.c \ncode. Once a component is written or an application template is assembled, it is added to the corresponding \nlibrary and is available for future de\u00advelopment. As the libraries grow richer, web application de\u00advelopment \nin WebJinn/DDD is reduced to just de.ning new structure modules. The result is a signi.cant increase \nof the web development productivity.  Adaptability. The bene.t of reuse differs depending on the application \ns size. WebJinn/DDD has proven to be most valu\u00adable for medium-size and enterprise applications. For \nexam\u00adple, the real-estate server psn.saturn-r.ru provides ac\u00adcess to .ve database tables, each managing \ndifferent real\u00adestate data. To access just one of them, 12 services are pro\u00advided: 3 public, 4 user-personalized, \nand 5 administrative. The implementation of these 12 services includes a total of 25 .les. As the application \nfunctionality stabilizes, frequent database structure changes initiated by the customer become the main \nproblem. Initially, the code was written using the WebJinn/MVC framework, and changes in one table (e.g., \nadding or removing a .eld) required up to 2 hours of work. After reorganizing the code and migrating \nto the WebJin-n/DDD framework, structural updates took little effort: less than a minute (just 2 mouse \nclicks) for removing a .eld and about 3-5 minutes of work for adding a .eld. The result is an enormous \nincrease in ef.ciency (24 times faster) in per\u00adforming structure customization tasks. For smaller sized \nap\u00adplications, the bene.t is small but still signi.cant. Even for an application with only 4 to 6 .les, \nstructure modi.cations take about 5 times faster in the WebJinn/DDD framework.   5.4 Limitations The \nimplementation of the WebJinn/DDD framework puts cer\u00adtain limitations on the application code. Restricted \nexpressiveness of template-based extension points. The template representation of a structure-dependent \nopera\u00adtion restricts expressiveness. The instantiated code is made Library of Executable Applications \n  Component-Based Development Product-Line Development E11 E21 1222 3  Ei E1E2 Ej E1 E23 Figure 5: \nWeb development with WebJinn/DDD E3k of a collection of expressions that are weaved separately and independently \nof each other. It becomes dif.cult to weave ar\u00adbitrary complex expressions into extension points. For \nexam\u00adple, consider an extension point describing a where clause of a select SQL query that includes AND, \nOR,and NOT op\u00aderators and is dependent on the request state. Due to the complex form of this expression, \nit is currently impossible to represent it as a template in WebJinn/DDD. However, such complex expressions \nare the exception rather than the rule. Non-optimized run-time performance. The WebJinn/DDD framework \nfacilitates structure customizations during appli\u00adcation code development. Since structure changes are \nfre\u00adquent at that stage, it is important that the application re.ects changes immediately. This reason \nmotivated the implemen\u00adtation of dynamic weaving in WebJinn/DDD. While improving the .exibility property \nof the code, dy\u00adnamic weaving affects run-time performance. The perfor\u00admance penalty may be crucial for \nenterprise servers with a large number of simultaneous users. However, dynamic weav\u00ading only affects \nthe functional part, since weaving into pre\u00adsentation view pages is pseudo-dynamic: the code is weaved \nstatically and refreshed by built-in mechanisms associated with the JSP container.  6. CONCLUSION Crosscutting \nconcerns in web development result in tangling and scattering in the web application code. Intra-crosscutting \ncauses tangling of functionality, presentation, and control code. Inter\u00adcrosscutting causes scattering \nof code fragments that re.ect struc\u00adtural features of either the request parameters or the underlying \nre\u00adsource. While intra-crosscutting can be controlled with the MVC model, all current web development \nmodels, including MVC, fail to address inter-crosscutting. The contribution of this paper is in presenting \nnew web applica\u00adtion development models that solve both forms of crosscutting. The XP model introduces \nextension points as place-holders for structure\u00addependent code. This enables to develop structure-free \nabstract web applications, which can then be tailored to a desired structure. The DDD model integrates \nthe XP model with the MVC model; and the WebJinn/DDD framework implements the DDD model to provide a \nuni.ed domain driven web development solution for both intra-and inter-crosscutting. In WebJinn/DDD, \nit is possible to create reusable web application components and instantiate an exe\u00adcutable application \nfrom templates of assembled components. Web application development with WebJinn/DDD signi.cantly increases \nweb development productivity and reuse. An interesting direction for future work is to consider WebJin-n/DDD \nas an Aspect-Oriented Programming (AOP) [15] tool. The XP model given in Section 4 is essentially a primitive \nAOP lan\u00adguage. In terms of AOP, the abstract application denotes a base program, the structure module \nis an aspect, and the weaving func\u00adtion implements the AOP semantics [16]. J5 .AOP model. An AOP model \nwould be an aspect-oriented extension of DDD that uses join points for extension points and advice for \nstructure-dependent code clusters. A WebJinn/AOP implementation of the AOP model may resolve some of \nthe current limitations in WebJinn/DDD. For example, a better advice model may allow to specify complex \nexpressions to be weaved into the abstract application. The WebJinn/AOP frame\u00adwork may also include a \nstatic weaving mode that would improve performance characteristics of the executable code. From this \nper\u00adspective, WebJinn/DDD is a starting point for a new web domain\u00adspeci.c AOP language. We believe that \nnot only could AOP greatly help web develop\u00aders to write reusable web applications with minimum effort, \nbut designing an aspect-oriented web development framework would improve our understanding of AOP as \nwell. Acknowledgment We thank Jonathan Hendler and the anonymous referees for their valuable comments. \n 7. REFERENCES [1] P. Atzeni, G. Mecca, and P. Merialdo. To weave the web. In International Conference \non Very Large Data Bases, pages 206 215, 1997. [2] D. Axmark, M. Widenius, A. Lentz, P. DuBois, and S. \nHinz. MySQL manual. http: //www.mysql.com/documentation/index.html. [3] D. Batory, C. Johnson, B. Macdonald, \nand D. V. Heeder. Achieving extensibility through product-lines and domain-speci.c languages: a case \nstudy. ACM Transactions on Software Engineering and Methodology (TOSEM), 11(2):191 214, 2002. [4] B.A.Burd. \nJSP: JavaServer Pages. Wiley, 2001. [5] K. Czarnecki and U. Eisenecker. Generative Programming: Methods, \nTools, and Applications. Addison-Wesley, 2000. [6] P. Donohoe, editor. Software Product Lines: Experience \nand Research Directions, volume 576 of Engineering and Computer Science. Kluwer Academic, Boston, 2000. \n[7] P. DuBois. MySQL. Sams Developer s Library, 2n.edition, Jan. 2003. [8] P. Fraternali. Tools and approaches \nfor developing data-intensive web applications: a survey. ACM Computing Surveys, 31(3):227 263, 1999. \n[9] P. Fraternali and P. Paolini. Model-driven development of web applications: the AutoWeb system. ACM \nTransactions on Information Systems, 18(4):323 382, 2000. [10] E. Gamma, R. Helm, R. Johnson, and J. \nVlissides. Design patterns: Abstraction and reuse of object-oriented design. In O. M. Nierstrasz, editor, \nProceedings of the 7th European Conference on Object-Oriented Programming, number 707 in Lecture Notes \nin Computer Science, pages 406 431, Kaiserslautern, Germany, July 26-30 1993. ECOOP 93, Springer Verlag. \n[11] A. Goldberg and D. Robson. Smalltalk-80: The Language and its Implementation. Addison-Wesley, 1983. \n[12] G. T. Heineman and W. T. Councill, editors. Component-Based Software Engineering: Putting the Pieces \nTogether. Addison-Wesley, 2001. [13] T. Husted, E. Burns, and C. R. McClanahan. Struts: User Guide, 2002. \nhttp://jakarta.apache.org/ struts/userGuide/index.html. [14] T. N. Husted, C. Dumoulin, G. Franciscus, \nD. Winterfeldt, and C. R. McClanahan. Struts in Action: Building Web Applications with the Leading Java \nFramework. Manning Publications Company, Nov. 2002. [15] G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, \nC. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-oriented programming. In M. Aks\u00b8it and S. Matsuoka, editors, \nProceedings of the 11th European Conference on Object-Oriented Programming, number 1241 in Lecture Notes \nin Computer Science, pages 220 242, Jyv\u00a8askyl\u00a8a, Finland, June 9-13 1997. ECOOP 97, Springer Verlag. \n[16] R. L\u00a8ammel. A semantical approach to method-call interception. In Proceedings of the 1st International \nConference on Aspect-Oriented Software Development, pages 41 55, Enschede, The Netherlands, Apr. 2002. \nAOSD 2002, ACM Press. [17] A. Layman, E. Jung, E. Maler, H. S. Thompson, J. Paoli, J. Tigue, N. H. Mikula, \nand S. D. Rose. Xml-data, Jan. 1998. http://www.w3.org/TR/1998/NOTE-XML-data. [18] H. Masuhara and G. \nKiczales. Modeling crosscutting in aspect-oriented mechanisms. In L. Cardelli, editor, Proceedings of \nthe 17th European Conference on Object-Oriented Programming, number 2743 in Lecture Notes in Computer \nScience, pages 2 28, Darmstadt, Germany, July21-25 2003. ECOOP 2003, Springer Verlag. [19] L. Maturo. \nUsing Struts. White paper. http://stealthis.athensgroup.com/ presentations/Model_Layer_Framework/ Stuts_Whitepaper.pdf, \n2002. [20] P. Merialdo, P. Atzeni, and G. Mecca. Design and development of data-intensive web sites: \nThe Araneus approach. ACM Transactions on Internet Technology, 3(1):49 92, 2003. [21] D. L. Parnas. Designing \nsoftware for ease of extension and contraction. In Proceedings of the 3rd International Conference on \nSoftware Engineering, pages 264 277, Atlanta, Georgia, May 10-12 1978. ICSE 1978. [22] C. Ruppel and \nJ. Konecny. The role of IS personnel in Web-based systems development: the case of a health care organization. \nIn Proceedings of the 2000 ACM SIGCPR conference on Computer personnel research, pages 130 135, Chicago, \nIllinois, 2000. ACM Press. [23] S. Spielman, editor. The Struts Framework: Practical Guide for Programmers. \nThe Practical Guides Series. Morgan Kaufmann, Oct. 2002. [24] C. Szyperski. Component Software, Beyond \nObject-Oriented Programming. Addison-Wesley, 2nd edition, 2002. With Dominik Gruntz and Stephan Murer. \n[25] V. Turau. A framework for automatic generation of web-based data entry applications based on XML. \nIn Proceedings of the 2002 ACM Symposium on Applied Computing, pages 1121 1126, Madrid, Spain, 2002. \nACM Press.  \n\t\t\t", "proc_id": "949344", "abstract": "Web application development cuts across the HTTP protocol, the client-side presentation language (HTML, XML), the server-side technology (Servlets, JSP, ASP, PHP), and the underlying resource (files, database, information system). Consequently, web development concerns including functionality, presentation, control, and structure cross-cut, leading to tangled and scattered code that is hard to develop, maintain, and reuse. In this paper we analyze the cause, consequence, and remedy for this crosscutting. We distinguish between intra-crosscutting that results in code tangling and inter-crosscutting that results in code scattering. To resolve inter-crosscutting, we present a new web application development model named XP that introduces extension points as place-holders for structure-dependent code. We present another model named DDD that incorporates XP into the Model-View-Controller (MVC) model to resolve both intra- and inter-crosscutting. WebJinn is a novel domain-driven web development framework that implements the DDD model. WebJinn has been used to develop web applications at several web sites. Domain driven web development with WebJinn benefits from a significant improvement in code reuse, adaptability, and maintainability.", "authors": [{"name": "Sergei Kojarski", "author_profile_id": "81100619905", "affiliation": "Northeastern University, Boston, MA", "person_id": "P643486", "email_address": "", "orcid_id": ""}, {"name": "David H. Lorenz", "author_profile_id": "81100540418", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP14187733", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949351", "year": "2003", "article_id": "949351", "conference": "OOPSLA", "title": "Domain driven web development with WebJinn", "url": "http://dl.acm.org/citation.cfm?id=949351"}