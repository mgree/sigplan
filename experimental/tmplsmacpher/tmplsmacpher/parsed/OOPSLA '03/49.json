{"article_publication_date": "10-26-2003", "fulltext": "\n A Framework for Building Language Interpreters Alan Durham Edson Sussumu Arlindo Fl\u00e1vio da * University \nof S ao Paulo S ao Paulo, Brazil Conceic\u00b8 ao S ao Paulo, Brazil sussumu@novum.com.br University of \nS ao Paulo durham@ime.usp.br S ao Paulo, Brazil arlindo@ime.usp.br ABSTRACT This work presents an Object-Oriented \nframework for the implementation of language interpreters in an educational context. We use this framework \nto implement di.erent pro\u00adgramming language paradigms, including interpreters for the Functional, Object-Oriented \nand Logic paradigms. This framework focuses its structure on aiding the comprehension of the similarities \nand di.erences between the implementa\u00adtion of di.erent paradigms. Categories and Subject Descriptors \nK.3.2 [Computers and Education]: Computer and In\u00adformation Science Education; D.1.0 [Programming Tech\u00adniques]: \nGeneral General Terms Languages  Keywords Programming language interpreter, paradigm learning 1. INTRODUCTION \nProgramming languages and paradigms are extremely vari\u00adant. Therefore, teaching a course about Programming \nLan\u00adguages is not an easy task: the students not only have to face di.erent paradigms, but also di.erent \nsyntaxes, which tend to make the task harder. Also, details about the im\u00adplementation of the languages \nare not seen. In 1990, Kamin [7] introduced a novel approach. All paradigms were taught using the same \nsyntax, the syntax of Lisp. Also, source code for a series of interpreters was given, allowing the students \nnot only to see how the languages could be implemented, but also to work on that implementation. We have \nused Kamin s book and interpreters for 4 straight years in Brazil, with very good results. However, the \ncode for Kamin s interpreters was large and complex. Probably most of the complexity was due to the fact \nthat the code was all written in PASCAL using struc\u00adtured programming techniques. The commonality of \nthe dif\u00adferent interpreters was hidden by the imperative style of pro\u00adgramming. This paper presents the \nresult of re-engineering * Supported by CNPq-Brazil, grant 141415/2002-9. Kamin s interpreters into \nan Object-Oriented architecture. As a result we have now a framework for building language interpreters \nin an educational context, making it easy for students to implement new interpreters of pure and mixed \nparadigms. The .nal structure of the framework highlight\u00ading the commonalities and the di.erences among \ndi.erent paradigms, with the goals of making the task of understand\u00ading programming languages easier, \nand of providing an envi\u00adronment for experimentation. Currently the framework in\u00advolves classes to implement \nthe principles of functional lan\u00adguages (including closures and delayed evaluation), Object-Oriented \nlanguages and a logic language. All code is writ\u00adten in Java and uses many Design Patterns [5], which \ncon\u00adtributes to increase clarity, .exibility and modularity. The source code is available at [4]. We \nhave validated the framework by building interpreters for the semantics of languages in di.erent paradigms, \ninclud\u00ading functional language with closures, a functional language with delayed evaluation, a smalltalk-like \nobject-oriented lan\u00adguage and a logic language based on PROLOG. Following Kamin s approach, all these \ninterpreters use the same syntax front-end, that uses lisp-like syntax. In sections 2 and 3 we present \nthe general framework. In section 4 we present the classes used to support functional languages, in section \n5 we present the set of classes used to support object-oriented language implementation and in section \n6 we present classes to support logic language imple\u00admentation. We conclude in section 7 by a quick analysis \nof the results. 2. THE BASIC CLASSES In this section we will describe framework core classes, that are \ndesigned to give standard support to build any in\u00adterpreter. These classes can be divided in three groups: \n lexical and syntactical analysis: the classes that are used to parse the input and produce an abstract \nsyntax tree;  interpreter mechanics: the classes that are used to im\u00adplement the interpreter cycle and \nthe user front-end;  language semantics: the classes used to implement the semantics of the programming \nlanguages to be inter\u00adpreted.  2.1 Lexical and syntactical analysis Copyright is held by the author/owner. \nDelegating lexical and syntactical analysis to separate part OOPSLA 03, October 26 30, 2003, Anaheim, \nCalifornia, USA. ACM 1-58113-751-6/03/0010. of a language implementation system can be considered the \n Interpreter Parser TokenStream Expression parse() getCurrentToken() currentToken expression evaluate() \n  Figure 1: The basic interpreter cycle standard implementation, therefore there is nothing original \nin this approach [1, 2, 8]. Lexical analysis is performed using the classes Token and TokenStream. Token \nis the abstract superclass of all lexical items and TokenStream is the lexical analyzer. Syntactic analysis \nis performed by the ExpressionParser class. The method parse interacts with the concrete sub\u00adclasses \nof Token output using a TokenStream. Like Kamin s set of interpreters, the default syntax accepted by \nthe frame\u00adwork is lisp-like. Therefore the ExpressionParser class has a very straightforward implementation. \nHowever, nothing in the framework precludes the construction of a more general parsing subsystem.  2.2 \nInterpreter mechanics This is probably the group of classes less likely to be ex\u00adtended by the user. \nThese classes implement the basic read\u00adevaluate-print interpreter loop, and the setting of interpreter \ndirectives. The control class is Interpreter. An object of this class is the manager of the system, coordinating \nthe interaction of the various parts. The interpreters work, by default, in an interactive mode: an input \nexpression is read, evaluated, and the result is printed. There are two types of entry: expressions and \ninterpreter directives. Expressions are the language commands, and the directives are requests to the \ninterpreter itself, like quit to .nish execution, or load to input the contents of a .le. To activate \nthe interpreter we create an instance of the class Interpreter andsenditthe run() message. Interpreter \ncreates an ExpressionParser giving a TokenStream as an ar\u00adgument to the constructor. At each round ExpressionParser \nreturns an instance of Expression representing an abstract syntax tree. Interpreter sends the message \nevaluate() to Expression, collecting the resulting value (also an instance of Expression), converting \nit to a string (message toString()) and printing it. Figure 1 illustrates this process. During the initial \nstages of development, one of the prob\u00adlems we faced was how to manage the change in input de\u00advices of \nthe interpreter modularly. However, this actually can be seen as a particular instance of the more general \nFigure 2: Expression hierarchy problem of how to treat modularly the eventual changes in the interpreter \nruntime con.guration. The solution was to create the InterpreterContext, that controls the dynamic con.guration \nof the interpreter. As of now, it implements only input and output policies of the interpreter, allowing \neasy and modular runtime switching of input source and out\u00adput target, by the use of interpreter directives1 \n. Therefore it is possible, for example, to temporarily switch input from the keyboard to a .le, loading \npre-written code in the sys\u00adtem. This separation is in the spirit of the pattern State [5], that models \na class of objects whose behavior changes when their internal state is modi.ed Both Interpreter and InterpreterContext \nimplement the Singleton pattern [5], used to guarantee only one instance of each class exists at any \ngiven time. 2.3 Semantic Analysis In this group we have all the classes responsible for de\u00adscribing \nthe functionality of every item in the abstract syn\u00adtax tree, as well as the classes that maintain the \nruntime state. The Expression class hierarchy implements all lan\u00adguage primitive data type functionality \nand control .ow. The Environment class implement the language runtime en\u00advironment, that is, maintains \nthe state of local and global variables. 2.3.1 Expression Hierarchy The semantic of the language is implemented \nusing the In\u00adterpreter pattern [5]. Therefore, each class implements the runtime semantics of one abstract \nsyntax tree item. The root of these classes is the abstract class Expression.Aside from the Expression \nclass hierarchy we have classes for im\u00adplementing each primitive operation of the language and a set \nof Exception classes to regulate gracious handling of run\u00adtime errors in the interpreter. Figure 2 shows \nthe classes that implement all the ba\u00adsic abstract syntax. This hierarchy is mostly paradigm\u00adindependent \nand is crucial to understand the functioning of the framework. It was designed to maximize code reuse, \nhighlighting the similarities among all language paradigms. Expression has four main subclasses: VariableExpression, \nrepresenting the use of a variable;  ValueExpression, representing any runtime .rst class primitive \nvalue (including, for example, closures and numbers);  1 In fact, Java provides a good set of classes \nfor input and output, creating a single interface for various input/output devices. This class library \nwas used in our framework. ApplicationExpression, roughly equivalent to a state\u00adment, representing an \ninput command;  ListExpression, implementing the Composite pattern  [5] on expressions, used to modularly \nimplement argu\u00adment lists. 2.3.1.1 Variables:. Class VariableExpression is probably the simplest one \nof the framework. Objects of this class represent the use of a variable in the abstract syntax tree. \nEach object contains a variable name that can be looked up dynamically in an Environment. 2.3.1.2 Primitive \nValues:. The class ValueExpression represents all .rst class val\u00adues of the interpreter. The main concrete \nsubclasses are NumberExpression, used to implement integer arithmetic, and AbstractClosure, the root \nclass of closure representation. AbstractClosure has two concrete subclasses: PrimitiveClo\u00adsure (a closure \ndescribing primitive functionality, de.ned by the interpreter), or User Closure (a closure described \nby the interpreter user). One important distinction between clo\u00adsures and the other subclasses of Expression \nis the method apply(), that receives as arguments the current environ\u00adment (the state of the interpreter) \nand an ListExpression, describing the expressions that will evaluate to the argu\u00adments of the closure. \nThe use of dynamic or static scoping is de.ned in the implementation of apply(), in the subclass UserClosure. \nThe implementation of apply in PrimitiveClo\u00adsure is standard, since primitive closures do not have local \nscope. 2.3.1.3 Operations. The class ApplicationExpression models expressions that result in some calculation, \nin particular function calls. Ac\u00adtually, its structure is somewhat similar to the Composite pattern [5] \nof other expressions. The di.erence is that the .rst of the sub-expressions describes a closure (one \nof the concrete subclasses of AbstractClosure). ApplicationExpres\u00adsion evaluates the .rst expression, \ngetting the closure, and sends it the message apply(), that receives as arguments the other expressions \nof the List and the current environment. It is important to note that the other expressions are not evaluated \nat this point, so the argument evaluation policy can be implemented transparently in closure.  2.3.2 \nThe runtime environment The runtime environment is the set of values associated by the names used in \nthe language. We can see the envi\u00adronment as a mapping from names to ValueExpressions. In our framework, \nclosures are also .rst class values, so En\u00advironments represent not only variable values but also the \nmapping of names to functional entities2 . Runtime environments are implemented by the class En\u00advironment. \nThe segregation of the runtime environment into a separate class is very important for the understanding \nof how programming languages work. We can hardly claim any 2This does not mean all languages have to \nimplement clo\u00adsures as .rst class values, as we can have multiple environ\u00adments in a language implementation. \n originality in the separation of the environment into a sep\u00adarate data structure, as this is a very \nstandard architecture [1,2,8]. However, the use of a speci.c abstract data type has an important educational \nvalue, since allows the lan\u00adguage implementor to easily create new forms of managing scopes in a modular \nand dynamic way, separating the com\u00adposition of environments from their implementation (policy from mechanism). \nThe composition of scopes is de.ned in object creation, so scoping policy can be isolated from scop\u00ading \nimplementation. This class presents 6 main methods in its interface: boolean isLocallyBound(Name): checks \nif a name has been bound in the innermost scope. Used to prevent a variable from being declared twice; \n boolean isBound(Name): similar to the previous one, but apply to any of the current active scopes; \n void defineLocalEntry(Name,IntRunTimeValue): adds a new name to the innermost environment. Used to \ncre\u00adate new local bindings;  void defineGlobalEntry(Name,IntRunTimeValue): adds a new name to the outermost \nenvironment. Used to create new global bindings 3;  void setEntryValue(Name, IntRunTimeValue): changes \nthe value associated to a name;  IntRunTimeValue getEntryValue(String): get the value associated to \na name.  Name visibility is always de.ned by how environments are concatenated, so we only need one \nmethod for this4). In our implementation a name used by the interpreter (variable names and tokens) is \nstored only once in the system, using a global hash table associated with class Name. This approach also \nreduces space usage and speeds up equality comparison.  3. BUILDING A NEW INTERPRETER The steps to \nbuild a new interpreter using the framework are: Create a subclass of Token for each new token of the \nlanguage;  Create a new subclass of PrimitiveClosure for each new primitive operation of the language \nthat is not already in the framework;  Create a concrete subclass of ExpressionParser to im\u00adplement \nthe desired syntax in the parse() method. The default implementation parses lisp-like syntax (all four \ninterpreters provided with the framework use this syntax, like in Kamin s work5);  3It may seem strange \nfor the interface to allow the de.ni\u00adtion of both local and global variables, but in the original set \nof interpreters, one of the languages had only global vari\u00adables (even though there were function arguments), \nso this structure seemed more general. 4In the original interpreter these particularities were hidden \nin the implementation code of one speci.c version of the interpreter, making understanding much harder. \n5To illustrate the simplicity of this approach we can say that only minor modi.cations were needed to \nimplement the pseudo-smalltalk and the pseudo-prolog interpreters. Create a subclass of Interpreter and \nde.ne the primi\u00adtive operations to be used by the interpreter.  4. FUNCTIONAL LANGUAGE IMPLEMEN-TATION \nIn this section we describe a set of extra classes that can be used to implement functional languages. \nCurrently, we provide two languages, both described in Kamin s book: a version of Scheme with full closures, \ncons cells, and while loops;  a version of SASL, a side-e.ect-free language with lazy evaluation . \n 4.1 Lazy Evaluation Lazy evaluation means expressions are evaluated only when their value is needed, \nnot when we call a function. This is not a trivial matter, since its functioning is di.erent from macros. \nIn macros, the text of an argument is merely substi\u00adtuted in each occurrence of the argument in the macro \ncode. Therefore each argument is potentially evaluated more than one time. With lazy evaluation, on the \nother hand, argu\u00adments are also not evaluated at call time, but, di.erently, their evaluation occurs \nonly once. This permits a lot of .ex\u00adibility in the language, permitting, for example, the creation of \nin.nite lists [7]. To implement delayed evaluation, a new primitive data type is needed, the thunk , \nimplemented by class Thunk. A thunk serves as a repository for an expression, including the environment \nthat was active at when the expression was speci.ed6 . In fact, thunks are very similar to closures, \nwith two di.erences: .rst, their evaluation accepts no arguments, second, once they are evaluated once, \nthey should not be evaluated again, being replaced by the resulting value. Since the implementation language \nchosen was Java, which does not o.er an operation like Smalltalk s become:7, a thunk has a cache , that \nstarts empty and that stores the computed value once the thunk is evaluated the .rst time. The fact that \nwe have encapsulated the delayed evaluation inside the class Thunk allows insertion of lazy evaluation \nin a way that is transparent to the other components, except Interpreter, which in this case should send \nthe message delayedEval() to every Expression. The default behavior of this method (implemented in class \nExpression) is to create a thunk en\u00adclosing the expression. The classes that rede.ne this method are \nThunk and the primitive values. Thunk proceeds to per\u00adform delayEval() on its expression, saving the \nresult in its cache and returning it. Primitive data types only return themselves.  5. OBJECT ORIENTATION \nThe main di.erences of the implementation of the Object-Oriented paradigm, are the concept of object \nscope and the mechanism for message communication. Our solution to 6One important characteristic of lazy \nevaluation languages is that they have no side e.ects, so values of names do not change for a given environment. \n7Actually, Kamin s original interpreters the evaluation of the thunk caused it to be substituted in the \nenvironment for the resulting value. However, this created a dependency be\u00adtween the implementation of \nEnvironment and the primitive data types o.ered, a less modular approach. Figure 3: Classes for Smalltalk \nImplementation support OO consists basically of three new classes: Abstrac\u00adtObject, Class and Object. \nFigure 3 shows the architecture. AbstractObject is an abstract subclass of ValueExp. Class and Object \nare subclasses of AbstractObject. Class is a tem\u00adplate for object creation and a repository of its functionality, \nencapsulating information about methods and attributes. Object has a runtime environment and a reference \nto its Class. In fact, to create a new class means create an in\u00adstance of class Class and to associate \nit with a name in the global environment of the interpreter. Similarly, to create an object means to \ncreate an instance of Object and to associate it with the instance of Class representing its class. Following \nSmalltalk-80 s architecture, methods are always stored in an instance of class Class. Therefore, an Object \nal\u00adways stores a reference to its associated instance of Class. This centralized approach simplify the \nmechanism and is very dynamic. Methods are implemented by class Method, where a Method has implementation \nsimilar to Closure,ex\u00adcept for one aspect. A Method has a reference to the instance of Class, section \n5.1 shows why. 5.1 Self and Super implementation We have also implemented the mechanisms for self and \nsu\u00adper, that are pseudo-variables referencing the object receive the message, and its superclass, respectively. \nThe mecha\u00adnisms for self is simple, we just add a reference in the object local environment that points \nto an Object instance, in other words, that points to self. Implementing super was more complex, since \nits value de\u00adpends on the hierarchy level where it is being used. For example, given a hierarchy like \na . b . c (that is, c is sub\u00adclass of b and b is subclass of a), super.x must point to a.x when used \nin b and to b.x when used in c. Therefore, static references can not solve the problem, a dynamic reference \nresolution is needed. In our implementation super is totally dynamic. To do this, when a message is sent \nat runtime, we create a reference to super in the environment that is passed to the apply() member function \nof Method.The value of super points, in fact, to a PseudoObject.This PseudoObject is an expression, subclass \nof AbstractObject, that resolves the reference to the correct superclass when is evaluated. 6. LOGIC \nPROGRAMMING In our next paradigm, we tackled the implementation of a Prolog-like logic language interpreter. \nIn Logic Pro\u00adgramming the programmer writes assertions instead of com\u00admands. These assertions establish \nset of constraints on the solution. The language interpreter tries to .nd a solution that satis.es the \nassertions. Logic programming belongs to name value name  Figure 4: Hierarchy of logic Expression \na totally di.erent paradigm than the previous ones, there\u00adfore it was not an easy task to integrate interpreters \nof logic languages into the framework, so most of the classes form a hierarchy that is separate from \nthe other paradigms. It is our perception that this part of the system needs a new refactoring. 6.1 Logic \nExpressions Figure 4 shows the hierarchy of logic Expression that de\u00ad.nes the basic abstract syntax. \nThe primitive data types of a logic program are called terms. The simplest term is the number term, it \nhas an in\u00adteger value in our interpreter. A variable term has a variable name; a variable may be bound \nto another term. Data struc\u00adtures are de.ned by constructors like cons and constants like nil; these \nterms are called functors. A goal represents a constraint among its terms; the nature of the constraint \nis de.ned by a named predicate. In a logic programming program we state a series of as\u00adsertions, called \nclauses. Each clause is composed of a list of goals. Each goal speci.es something to be proved. The .rst \ngoal is called clause head, and the remaining goals are subgoals. A clause states that we satisfy the \nclause head if we satisfy each of the subgoals. Goals can have variables. The result of a logic program \nis a set of substitutions (an association of variables to values) that will make the clause true. In \nall the classes we used the immutable class pattern [3]. An immutable class is simply a class whose instances \ncannot be modi.ed; all the information contained in each instance is provided when the object is created \nand are .xed for the life\u00adtime of the object. When classes are immutable, no method has side-e.ects, \ni.e. no method modi.es the receiving object or its parameters; this is known as the functional approach. \nImmutable classes are easier to design, implement and use than mutable classes; they are less error-prone \nand more secure.  6.2 Substitutions A substitution can be viewed as a mapping from a .nite set of variables \nto terms. Re.ecting that view, we have im\u00adplemented the Substitution class is a subclass of the En\u00advironment \nclass. One important di.erence between Sub\u00adstitution and Environment is that we can compose substi\u00adtutions. \nTherefore the class Substitution implements the method compose, that receives another substitution as \nan argument and modify the receiver to be a composition of both. All subclasses of Term implement the \nmessage unify(Term other), that returns a substitution such that, when applied to the receiver and to \nthe argument, make them equal. If no such substitution exists, the method returns null.The im\u00adplementation \nto be chosen of unify depends on the classes of the receiver and the argument. To implement this mod\u00adularly, \nwe have used the double dispatch technique [6]. Variables occurring in a clause are local to the clause, \ntherefore they are independent of all other variables in the program. To enforce this rule, during uni.cation \nwe rename all variables occurring in the clause to unique names before using them. This is performed \nby the method renameVars(int id). 6.3 Predicates In a logic language, we do not have procedures, we \nhave predicates Predicates are named entities that de.ne some logical constraint on their terms and that \nare invoked to sat\u00adisfy goals. So, we could approach the implementation of the concept of predicate as \nan extension of the implementation of a function or, more speci.cally to our context, of a clo\u00adsure. \nA predicate, instead of a list of commands, has a list of clauses. However, in a logic program, there \nis a feature that hinders this simple view: in a logic program the .ow of con\u00adtrol may backtrack within \nthe subgoals of the clause when some further goal outside the scope of the clause fails, in other words, \nthe processing of a clause may return to a clause even after the .ow of control leaves it. To implement \nback\u00adtracking we use the concept of continuations. Therefore, we created a new abstract class ContinuationClosure,and \nimplemented Predicate as its subclass. A Predicate accepts apply(ListExp args, Environment sigma, Expression \ncont) where args is the list of the goal terms; sigma is the cur\u00adrent substitution and cont is the list \nof the continuation goals (goals that should be satis.ed after the current pred\u00adicate). Therefore, to \nevaluate a GoalList as a query, we simply send the apply message to the predicate of the .rst goal, passing \nthe rest of goals as the continuation: public Expression evaluate(Environment sigma) { Predicate pred \n= Predicate.getInstance( getFirst().getName()); return pred.apply( getFirst().getTermList(), sigma, getRest()); \n} The Predicate class has two subclasses: UserPredicate and PrimitivePredicate. Instances of the .rst \nsubclass are de\u00ad.ned by user-provided clauses, and instances of the second subclass are all Singletons \nde.ned at compile-time. We modi.ed the method UserPredicate::apply to mod\u00adify the current substitution \nin order to unify the goals. To undo the modi.cations performed on substitutions when there is a need \nto backtracking we use the Memento pat\u00adtern. Summarizing, UserPredicate::apply: takes each predicate \nclause in turn, rename its vari\u00adables, and try to unify its head terms with the goal terms. if the uni.cation \nis possible, composes the unifying substitution with the current substitution, concate\u00adnate the clause \nsubgoals to the continuation goals, and evaluate them recursively, passing the current substi\u00adtution \nforward.  if the continuation goals are satis.ed returns a success code, otherwise undo the modi.cations \ndone on the current substitution and try the next predicate clause.  After trying all predicate clauses, \nand none succeeded, re\u00adturns failure. The actual java code is described bellow: public Expression apply \n( ListExp terms, Environment sigma, Expression cont){ Substitution s = (Substitution) sigma; TermList \ntermsEval = (TermList) terms.evaluate(s); int id = s.getVarId(); Substitution.Memento mem = s.getMemento(); \nfor (Iterator i=getClauses().iterator();i.hasNext();){ Clause c = ((Clause) i.next()).renameVars(id); \nSubstitution s1 = termsEval.unify( c.getHead().getTermList()); if (s1 != null) { s.compose(s1); GoalList \ngl = c.getSubGoals().concat( (GoalList) cont); if (((LogicalResult) gl.evaluate(s)). isSatisfied()) return \nLogicalResult.SUCCESS; s.setMemento(mem); } } return LogicalResult.FAILURE; }  7. CONCLUSION This paper \npresented an Object-Oriented framework for building language interpreters. Wehaveused this frame\u00adwork \nto implement interpreters for several paradigms, in\u00adcluding interpreters for imperative paradigm (implementing \nclosures and lazy evaluation), for Object-Oriented paradigm and for logic programming. Our framework \nwas produced by re-engineering the inter\u00adpreters described in Samuel Kamin s book [7], directed to the \nteaching of programming paradigms. The approach of using interpreters as tools for understanding programming \nparadigms has been proven a sound one by 4 years of using the approach. However, the use of independent \ninterpreters written in Pascal tended to make less clear the similari\u00adties and di.erences among the implementation \nof di.erent paradigms. Our initial objective was to build a framework, but based on our experiences, \nwe believe in this framework as a great tool for programming language teaching, specially because of \nthe modular and extensible Object-Oriented ar\u00adchitecture, that clarify the di.erences and similarities \nof pro\u00adgramming paradigms. To use the framework as a tool for programming languages lessons creates a \nsolid understanding of paradigms, espe\u00adcially when students get closer to source codes when trying to \nextend or change interpreter functionality. Also, dur\u00ading the re-engineering of Kamin s work we applied \nseveral Object-Oriented patterns [5, 3], making the framework more easily understood. It is clear at \nthis point that the weak point of our frame\u00adwork is the logic programming interpreter. Its integration \nto the rest of the interpreter is, in our perception, less than ideal. The next step should be a re-engineering \nof this part of the framework, trying to integrate it more into the main components. As other future \nwork, we would like to extend the basic functionality of the interpreters to include .oating\u00adpoint, and \nstring manipulation. For this, we need to imple\u00adment new primitive types, and operations. Also we intend \nto complement the implementation of current interpreters, including syntactic re.nement and implementation \nof new primitive operations. Finally, a possible extension would be amethod compile() in the hierarchy \nof expressions, aiming to implement a compiler in the same structure. In the near future, we intend \nto use the framework and the interpreters in lectures, validating the educational potential and delegating \nto the pupils the development of some of the above improvements. 8. ADDITIONAL AUTHORS Three other students \nfrom the Computer Science depart\u00adment of the University of S ao Paulo, Brazil, have contributed to coding: \nAriane Machado, Jorge del Teglia, and Marcelo Brito dos Santos. 9. REFERENCES [1] A. Aho and J. Ullman. \nThe theory of Parsing, Translation and Compiling. Prentice Hall, 1973. [2] A. W. Appel. Modern compiler \nimplementation in Java. Cambridge University Press, 1999. [3] J. Bloch. E.ective Java Programming Language \nGuide. Addison Wesley, 2001. [4] A. Durham, A. F. da Concei\u00b8c ao, and E. Sussumo. Language interpreter \nframework. http://www.ime.usp.br/~arlindo/lif, 2003. [5] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. \nDesign Patterns: Elements of Reusable Software. Addison Wesley, 1995. [6] A. Goldberg and D. Robson. \nSmalltalk-80, The Language and Its Implementation. Addison Wesley, 1983. [7] S. Kamin. Programming Languages: \nAn Interpreter-based Approach. Addison Wesley, 1988. [8] J.-P. Tremblay and P. G. Sorenson. The theory \nand practice of compiler writing. McGraw-Hill, 1985.  \n\t\t\t", "proc_id": "949344", "abstract": "This work presents an Object-Oriented framework for the implementation of language interpreters in an educational context. We use this framework to implement different programming language paradigms, including interpreters for the Functional, Object-Oriented and Logic paradigms. This framework focuses its structure on aiding the comprehension of the similarities and differences between the implementation of different paradigms.", "authors": [{"name": "Alan Durham", "author_profile_id": "81100346535", "affiliation": "University of S&#227;o Paulo, S&#227;o Paulo, Brazil", "person_id": "P643420", "email_address": "", "orcid_id": ""}, {"name": "Edson Sussumu", "author_profile_id": "81100271536", "affiliation": "University of S&#227;o Paulo, S&#227;o Paulo, Brazil", "person_id": "P643441", "email_address": "", "orcid_id": ""}, {"name": "Arlindo Fl&#225;vio da Concei&#231;&#227;o", "author_profile_id": "81100268325", "affiliation": "University of S&#227;o Paulo, S&#227;o Paulo, Brazil", "person_id": "P643428", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949398", "year": "2003", "article_id": "949398", "conference": "OOPSLA", "title": "A framework for building language interpreters", "url": "http://dl.acm.org/citation.cfm?id=949398"}