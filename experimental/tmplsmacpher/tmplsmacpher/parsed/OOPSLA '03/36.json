{"article_publication_date": "10-26-2003", "fulltext": "\n Aspect-Oriented Implementation Method: Progressive or Non-progressive Approach? * S\u00b4ergio Soares Paulo \nBorba Informatics Center Informatics Center Federal University of Pernambuco Federal University of Pernambuco \nRecife, Pernambuco, Brazil Recife, Pernambuco, Brazil  scbs@cin.ufpe.br phmb@cin.ufpe.br ABSTRACT Object-oriented \nprogramming languages provide e.ective means to achieve better reuse and extensibility levels, which \nin\u00adcreases development productivity. However, the object-oriented paradigm has several limitations, sometimes \nleading to tan\u00adgled code and spread code. For example, business code tan\u00adgled with presentation code \nor data access code, and dis\u00adtribution, concurrency control, and exception handling code spread over \nseveral classes. This decreases readability, and therefore, system maintainability. Some extensions of \nthe object-oriented paradigm try to correct those limitations al\u00adlowing reuse and maintenance in practical \nsituations where the original paradigm does not o.er an adequate support. However, in order to guarantee \nthat those bene.ts will be achieved by those techniques it is necessary to use them to\u00adgether with an \nimplementation method. Our objective is to adapt and to analyze an object-oriented implementation method \nto use aspect-oriented programming in order to im\u00adplement several concerns to a family of object-oriented \nsys\u00adtem. In particular, we are interested in implementing per\u00adsistence, distribution, and concurrency \ncontrol aspects. At the moment we are particularly interested to present some results and get feed back \nabout a performed experiment to identify if and when a progressive approach is better than a non-progressive \none. In a progressive approach, persistence, distribution, and concurrency control are not initially \ncon\u00adsidered in the implementation activities, but are gradually introduced, preserving the application \ns functional require\u00adments. This approach helps in dealing with the inherent complexity of the modern \napplications, through the support to gradual implementations and tests of the intermediate versions of \nthe application. Categories and Subject Descriptors D.1 [Software]: Programming Techniques Aspect-Oriented \nProgramming; D.3.2 [Programming Languages]: Lan\u00adguage Classi.cations AspectJ * Also a.liated to Catholic \nUniversity of Pernambuco, In\u00adformatics and Statistics Department, Recife, Pernambuco, Brazil. Copyright \nis held by the author/owner. OOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. \n General Terms Languages, Standardization, Experimentation Keywords Aspect-oriented programming, separation \nof concerns, As\u00adpectJ, Java, implementation method, progressive implemen\u00adtation 1. INTRODUCTION Usually, \nresearchers and software engineers do not give much attention to implementation methods [1, 6], because \nimplementation mistakes have less impact in project sched\u00adule and development costs than mistakes regarding \nrequire\u00adments and design. However, the e.ort given to requirements and design can be wasted if there \nis not a commitment with the imple\u00admentation activity. This is necessary in order to increase productivity, \nreliability, reuse, and extensibility levels. For example, the maintenance activity usually has the highest \ncost [3, 5], which is inversely proportional to reuse and ex\u00adtensibility. This motivates the continuous \nsearch to increase those levels. Object-oriented programming languages provide e.ective means that help \nto increase productivity, reliability, reuse, and extensibility levels, but has several limitations, \nsome\u00adtimes leading to tangled code and spread code, decreasing readability, and therefore, system maintainability. \nExam\u00adples are, business code tangled with presentation code or data access code, and distribution, concurrency \ncontrol, and exception handling code spread over several classes. To solve these limitations, techniques, \nlike aspect-oriented program\u00adming, aim to increase software modularity in practical situ\u00adations where \nobject-oriented programming does not o.er an adequate support. 2. ASPECT-ORIENTED PROGRAMMING We believe \nthat aspect-oriented programming (AOP) [4], is very promising [9, 11]. AOP tries to solve the ine.ciency \nin capturing some of the important design decisions that a system must implement. This di.culty leads \nthe imple\u00admentation of these design decisions spread through the func\u00adtional code, resulting in tangled \ncode with di.erent concerns. This tangling and scattering code hinders development and maintenance of \nthese systems. AOP increases modularity by separating code that implements speci.c functions and a.ects \ndi.erent parts of the system. These are called cross\u00adcutting concerns. By separating concerns AOP allows \nimplementing a sys\u00adtem separating functional and non-functional requirements. For example, a set of components \nwritten in an object\u00adoriented programming language, such as Java, might im\u00adplement functional requirements. \nOn the other hand, a set of aspects (crosscutting concerns) related to the properties that a.ect system \nbehavior might implement non-functional requirements. Using this approach, non-functional require\u00adments \ncan be easily manipulated without impacting the busi\u00adness code (functional requirements), since they \nare not tan\u00adgled and spread over the system. In this way, AOP allows the development of programs using \nsuch aspects, including isolation, composition and reuse of part of the aspects code. 3. IMPLEMENTATION \nAPPROACHES No matter how good the programming language, an im\u00adplementation method is important to de.ne \nactivities to be executed and the relations between them, including their execution order. Our main goal \nis to de.ne an implemen\u00adtation method using aspect-oriented programming, helping to develop better software \nwith better productivity levels. Our implementation method will guide the implementation of persistence, \ndistribution, and concurrency control con\u00adcerns that conforms to speci.c software architecture. De\u00adspite \nbeing speci.c, the software architecture can be used to implement several kinds of systems. These aspects \ncan be implemented in di.erent ways and in a di.erent order. They might be implemented at the same time \nas the functional requirements are being imple\u00admented. Another idea is to follow a progressive approach, \nwhere persistence, distribution, and concurrency control are not initially considered in the implementation \nactivities, but are gradually introduced, preserving the system s functional requirements. This progressive \napproach helps in decreasing the impact in requirements changes during the system development, since \na great part of the changes might occur before the .nal version of the system is .nished. This is possible \nbecause a completely functional prototype is implemented without persistence, distribution, and concurrency \ncontrol, allowing requirements validation without interference of these non\u00adfunctional requirements and \nwithout the e.ort to imple\u00adment those. At this time the system uses non-persistent data structures, such \nas arrays, vectors, and lists, and is executed in a single-used environment. Moreover, the pro\u00adgressive \napproach helps in dealing with the inherent com\u00adplexity of modern systems, through the support to gradual \nimplementation and tests of the intermediate versions of the system. 3.1 Approaches analysis We performedanexperiment \nwithgraduate students us\u00ading AspectJ [7] and the implementation approaches to iden\u00adtify if and when the \nprogressive approach is better than the non-progressive one. The experiment was carefully designed using \nrecommendations of experts in the empirical area [10, 8, 2]. We divided the students in pairs and randomly \nassigned to a project. There were two kinds of project; both had the same resulting system, however one \nhad to follow one a progressive approach, and the other a non-progressive ap\u00adproach. In the experiment \nexecution they implemented a simple information system with operations to register, change, and retrieve \ninformation. We simulate development prob\u00adlems like requirement changes and modeling problems and we \nalso simulate code generation to support the develop\u00adment. An interesting result of this experiment was \nnew in\u00adterferences between the aspects that were not identi.ed in the previous experiment. In this experiment \nwe collected data in order to evaluate the bene.ts and liabilities to implement a system using a progressive \napproach. Examples of the data collected are implementation time, debugging time, time to correct er\u00adrors \nand requirements changes, number of lines a.ected by changes, and a form to get the anonymous feedback \nabout the experiments from the students. The experiment exe\u00adcution is already .nished, however we had \nsome problems during data collection, which did not allow we to use some of the values. The others values \nshowed that the progressive approach maybe more e.ective in those experiments. How\u00adever, we did not have \nenough groups to provide statistical analysis, we only used data of two groups. Therefore, we are planning \nto run the experiment again taking care of how the data will be collected allowing us to validate this \nprevious experiment.  4. REFERENCES [1] Scott Ambler. Process Patterns-Building Large-Scale Systems \nUsing Object Technology. Cambridge University Press, 1998. [2] Victor Basili, Richard Selby, and David \nHutchens. Experimentation in Software Engineering. IEEE Transactions on Software Engineering, SE-12(7):733 \n743, July 1986. [3] D. Coleman, D. Ahs,B.Lowther,and P. Oman. Using Metrics to Evaluate Software System \nMaintainability. IEEE Computer, 24(8):44 49, August 1994. [4] Tzilla Elrad, Robert E. Filman, and Atef \nBader. Aspect Oriented Programming. Communications of the ACM, 44(10):29 32, October 2001. [5] R. Graddy. \nSuccesfully Applying Software Metrics. IEEE Computer, 27(9):18 25, September 1994. [6] Ivar Jacobson, \nGrady Booch, and James Rumbaugh. The Uni.ed Software Development Process. Addison-Wesley, 1999. [7] \nGregor Kiczales, et. all. Getting Started with AspectJ. Communications of the ACM, 44(10):59 65, October \n2001. [8] Gail Murphy, et. all. Evaluating Emerging Software Development Technologies: Lessons Learned \nfrom Assessing Aspect-Oriented Programming. IEEE Transactions on Software Engineering, 25(4):438 455, \nJuly/August 1999. [9] Gail Murphy, et. all. Does aspect oriented programming work? Communications of \nthe ACM, 44(10):75 77, October 2001. [10] Shari P.eeger. Design and Analysis in Software Engineering. \nSoftware Engineering Notes, 19(4):16 20, October 1994. [11] S\u00b4ergio Soares, Eduardo Laureano, and Paulo \nBorba. Implementing Distribution and Persistence Aspects with AspectJ. In OOPSLA 02, pages 174 190. ACM \nPress, November 2002. SIGPLAN Notices 37(11).  \n\t\t\t", "proc_id": "949344", "abstract": "Object-oriented programming languages provide effective means to achieve better reuse and extensibility levels, which increases development productivity. However, the object-oriented paradigm has several limitations, sometimes leading to tangled code and spread code. For example, business code tangled with presentation code or data access code, and distribution, concurrency control, and exception handling code spread over several classes. This decreases readability, and therefore, system maintainability. Some extensions of the object-oriented paradigm try to correct those limitations allowing reuse and maintenance in practical situations where the original paradigm does not offer an adequate support. However, in order to guarantee that those benefits will be achieved by those techniques it is necessary to use them together with an implementation method. Our objective is to adapt and to analyze an object-oriented implementation method to use aspect-oriented programming in order to implement several concerns to a family of object-oriented system. In particular, we are interested in implementing persistence, distribution, and concurrency control aspects. At the moment we are particularly interested to present some results and get feed back about a performed experiment to identify if and when a progressive approach is better than a non-progressive one. In a progressive approach, persistence, distribution, and concurrency control are not initially considered in the implementation activities, but are gradually introduced, preserving the application's functional requirements. This approach helps in dealing with the inherent complexity of the modern applications, through the support to gradual implementations and tests of the intermediate versions of the application.", "authors": [{"name": "S&#233;rgio Soares", "author_profile_id": "81100162809", "affiliation": "Federal University of Pernambuco, Recife, Pernambuco, Brazil", "person_id": "P643484", "email_address": "", "orcid_id": ""}, {"name": "Paulo Borba", "author_profile_id": "81100549562", "affiliation": "Federal University of Pernambuco, Recife, Pernambuco, Brazil", "person_id": "PP14190912", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949384", "year": "2003", "article_id": "949384", "conference": "OOPSLA", "title": "Aspect-oriented implementation method: progressive or non-progressive approach?", "url": "http://dl.acm.org/citation.cfm?id=949384"}