{"article_publication_date": "10-26-2003", "fulltext": "\n A Demonstration of JPie: An Environment for Live Software Construction in Java Kenneth J. Goldman Computer \nScience and Engineering Washington University St. Louis, Missouri USA (314) 935-7542 kjg@cse.wustl.edu \nABSTRACT JPie is a tightly integrated development environment supporting live object-oriented software \nconstruction in Java. JPie embodies the notion of a dynamic class whose signature and implementation \ncan be modified at run time, with changes taking effect immediately upon existing instances of the class. \nThe result is complete elimination of the edit-compile-test cycle. JPie users create and modify class \ndefinitions through direct manipulation of visual representations of program abstractions. This support \nis provided without modification of the language or run-time system. In this demonstration, we illustrate \ncentral features of JPie through the construction of a sample application. These include dynamic declaration \nof instance variables and methods, dynamic modification of method bodies and threads, dynamic user interface \nconstruction and event handling, and on-the-fly exception handling in JPie s integrated thread-oriented \ndebugger. Categories &#38; Subject Descriptors: D.2.6 [Software Engineering] Programming Environments \n graphical environments, integrated environments, interactive environments. D.1.5 and D.1.7 [Programming \nTechniques] Object-oriented Programming and Visual Programming. General Terms: Design, Human Factors, \nLanguages. Keywords: Live programming, dynamic classes, tightly integrated development environments, \ndirect manipulation. 1 INTRODUCTION This demonstration introduces JPie, a unique programming environment \ndesigned to make the power of object-oriented software development accessible to a wider audience. To \naccomplish this, JPie supports live software development through direct manipulation of graphical representations \nof programming language abstractions. JPie is not a new programming language, but rather a tightly integrated \napproach to programming environments in which the environment is intimately aware of the structure of \nthe software being developed, and therefore can support a high level of interactivity while harnessing \nthe power of an underlying modern type-safe object-oriented language (Java). Screen shots from the demo \nare available on our web site. [1]   jpie@cse.wustl.edu 1.1 Dynamic Classes JPie s interactivity rests \non the notion of a dynamic class, whose signature and implementation can be modified live, even while \ninstances of that class exist in a running program. Dynamic classes fully interoperate with compiled \nclasses. Consequently, JPie users have available the entire Java API (1.4), may create dynamic classes \nextending either dynamic or compiled classes, and can override methods on the fly. Instances of compiled \nclasses may hold type-safe references to instances of dynamic classes, and may call methods on them polymorphically. \nDynamic classes are precompiled so that they may present themselves to the Java Virtual Machine (JVM) \njust as any ordinary type. However, they execute in a semi-interpreted manner using an internal representation \nof the dynamic portions of the class definition. The precompiled class overrides all of its inherited \nmethods, and by default calls the parent method to carry out the computation. However, when the JPie \nuser dynamically overrides a method, the user s implementation, rather than the parent s, is invoked. \nThese capabilities rely extensively on Java s reflection mechanism and are accomplished without modification \nof the language or JVM.  1.2 Direct Manipulation To make software development immediate and tangible, \nJPie provides graphical representations of programming language abstractions. For example, variables \nare shown as capsules whose type and scope are represented visually. JPie programmers manipulate the \ngraphical representations to effect changes in the running program. Many operations, such as variable \nand method declaration and use, are accomplished by drag-and-drop. The graphical representations expose \nthe Java execution model, while the JPie environment maintains program consistency, provides immediate \ntype-checking feedback, and constrains the manipulation of the program to prevent syntax errors. JPie \ns integrated debugger, which uses the same graphical representation, allows logical errors (including \nexceptions) to be handled on the fly. 2 A SAMPLE APPLICATION We illustrate JPie s features through the \nconstruction of a simple freehand drawing program in which a user can create strokes on a canvas with \na mouse. Each stroke begins when the mouse button is pressed and ends when the button is released. Copyright \nis held by the author/owner(s). JPie encourages separation of the data model from the view. In OOPSLA \n03, October 26-30, 2003, Anaheim, California, USA. our sample drawing application, the data model is \nthe collection of ACM 1-58113-751-6/03/0010. shapes to be drawn, and the view contains a panel responsible \nfor actually painting the shapes. To maintain the model, we define a Draw class that will be our main \nprogram. For use in the view, we also define a ShapesPanel class that extends Java s built-in JPanel \nclass and overrides the paint method to draw a collection of shapes. 2.1 The ShapesPanel Class 2.1.1 \nCreating a Subclass JPie s Packages and Classes window provides access to the classes and interfaces \nin the Java API, as well as to user-defined types. To create ShapesPanel as a subclass of JPanel, we \nselect JPanel from Java s swing package, choose Extend JPanel from JPie s File menu, and specify the \nname and package of the new ShapesPanel class. At this point, JPie precompiles the ShapesPanel class \nso it can be treated by the JVM as an actual subclass of JPanel. In the ShapesPanel class window, the \nJPie programmer can manipulate the graphical representation to declare additional instance variables, \nas well as define and override methods and constructors. 2.1.2 Declaring Instance Variables To hold \nthe shapes to be painted, we declare an instance variable of type java.util.Collection by dragging that \ntype from the Packages and Classes window and dropping it onto the Data panel. JPie automatically creates \naccessors and mutators (get and set methods, by the JavaBeans convention) whose names are kept consistent \nwith the instance variable s name. Similarly, we declare a Boolean named modified, to be set true whenever \nthe shapes collection is modified and therefore needs repainting.  2.2 The Draw Class 2.2.1 Constructors \nand Initialization As the main program, we define a Draw class with a linked list of shapes as its data \nmodel. In the constructor, we call a reset method that instantiates a java.awt.geom..GeneralPath to hold \nthe strokes of the user s drawing. We add the GeneralPath to the linked list after assigning it to a \nnew instance variable. 2.2.2 Model/View Separation In the View panel of the Draw class, we specify the \nvisual appearance of its instances. Using drag-and-drop into the view, we create a ShapesPanel component \nfor the drawing and a JButton below it labeled clear. To link the model to the view, we establish a \nproperty connection from the list of the Draw class to the collection of the ShapesPanel. 2.2.3 Creating \nInstances The New instance option in the Instances menu lets us manually instantiate an object of the \nDraw class. In the Instances panel, we can select and view any instance, whether created manually or \nprogrammatically.  2.3 Dynamic Changes Having instantiated the Draw program, we proceed to modify it \nas it runs. We begin with painting and user event handling. 2.3.1 Overriding Methods The ShapesPanel \nclass window provides a summary list of all the methods declared and inherited. Each is represented as \na capsule, showing its return type as an icon and its parameters as labeled slots. To paint the collection \nof shapes on the ShapesPanel, we override the paint method from JPanel by dragging the inherited method \nfrom the summary list and dropping it onto the methods panel. This dynamically modifiable method is then \ncalled polymorphically whenever the window system needs to repaint the component. 2.3.2 Editing a Method \nBody Within the paint method, we dynamically define statements that first call the paint method inherited \nfrom the parent class and then iterate over the shapes collection to paint the shapes. 2.3.3 Adding a \nnew instance variable and method In the Draw class, we declare a new Boolean instance variable and define \na signalModified method that sets the bit to signal the view when the drawing has changed. In the View \npanel, we establish a property connection from the new variable to the ShapesPanel s modified property. \nThen, in the ShapesPanel s setModified method, we call repaint whenever true is assigned. 2.3.4 Event \nHandling On the Events panel, we create event handlers to update the GeneralPath based on user input \nin the ShapesPanel component. We press the record button and demonstrate the desired event (mousePressed \nand mouseDragged). The system registers the listeners immediately. We edit the event handler method bodies \nto update the drawing in response to user actions. An event handler for the clear button is created similarly. \n 2.3.5 Adding a thread The Behaviors panel lets us define threads that begin running immediately. To \ndemonstrate this, we define a behavior that periodically changes the color of the drawing by calling \nsetForeground with a new random color. JPie s thread-oriented debugger lets us observe and modify the \nexecution.   3 CONCLUSION JPie provides live interactive development of Java applications through direct \nmanipulation of graphical representations of programming abstractions. All of this is accomplished without \nmodification of the language or run-time system. Following nearly four years of development, we have \nbegun using JPie to teach a concepts first introduction to computer science [2]. JPie is an ongoing project \n[1]. We invite participation from educators (for classroom use), as well as industry partners.  ACKNOWLEDGMENTS \nWe thank the following students for their contributions to the JPie project: Joel Brandt, Ben Brinkerhoff, \nVanessa Clark, Melanie Cowan, Matt Hampton, Adam Mitz, Jonathan Nye, Sajeeva Pallemulle, and Richard \nSouvenir. We also thank the students in the spring semester of CS123 for valuable feedback. The JPie \nproject is supported in part by a grant from the National Science Foundation. REFERENCES 1. Kenneth \nJ. Goldman et al., JPie: Programming is Easy, http://jpie.cse.wustl.edu, July 2003. 2. Kenneth J. Goldman, \nWashington University CS123: The Computer Science Way of Thinking, http://www.cse.wustl.edu/~kjg/cs123, \nJanuary 2003.   \n\t\t\t", "proc_id": "949344", "abstract": "JPie is a tightly integrated development environment supporting live object-oriented software construction in Java. JPie embodies the notion of a dynamic class whose signature and implementation can be modified at run time, with changes taking effect immediately upon existing instances of the class. The result is complete elimination of the edit-compile-test cycle. JPie users create and modify class definitions through direct manipulation of visual representations of program abstractions. This support is provided without modification of the language or run-time system. In this demonstration, we illustrate central features of JPie through the construction of a sample application. These include dynamic declaration of instance variables and methods, dynamic modification of method bodies and threads, dynamic user interface construction and event handling, and on-the-fly exception handling in JPie's integrated thread-oriented debugger.", "authors": [{"name": "Kenneth J. Goldman", "author_profile_id": "81100026241", "affiliation": "Washington University, St. Louis, Missouri", "person_id": "PP39023820", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949356", "year": "2003", "article_id": "949356", "conference": "OOPSLA", "title": "A demonstration of JPie: an environment for live software construction in Java", "url": "http://dl.acm.org/citation.cfm?id=949356"}