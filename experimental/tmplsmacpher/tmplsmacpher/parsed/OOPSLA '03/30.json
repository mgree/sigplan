{"article_publication_date": "10-26-2003", "fulltext": "\n Static Analysis of Component Systems Using Behavior Protocols * [Extended Abstract] Jiri Adamek Department \nof SW Engineering, Charles University Malostranske namesti 25 Prague 1, Czech Republic adamek@nenya.ms.mff.cuni.cz \nABSTRACT Static analysis of systems allows to discover errors at design time and to avoid run-time error \ndetection techniques that negatively impact performance of the systems. In this paper, we present the \nconsent operator, which allows (i) to capture errors resulting from incorrect composition of software \ncom\u00adponents, (ii) to test conformance of behavior descriptions and (iii) to analyze whether conditions \nof a correct dynamic update are satis.ed. Categories and Subject Descriptors D.2.4 [Software Engineering]: \nSoftware/Program Veri.\u00adcation formal methods General Terms design, veri.cation Keywords software components, \nbehavior protocols 1. INTRODUCTION Behavior protocols, introduced in [6], are a formal method allowing \nto describe communication among software compo\u00adnents. Although developed as a behavior description method \nfor the SOFA project [7, 9], they can be used for arbi\u00adtrary component model satisfying the following \ncharacteris\u00adtics: (i) hierarchically nested components, (ii) communica\u00adtion through well de.ned interfaces, \n(iii) connections among interfaces de.ned outside the component descriptions them\u00adselves. 1.1 Components \nand behavior protocols Components communicate through interfaces.We dis\u00adtinguish between a provides interface, \nde.ned as a set of methods provided by a component, and a requires interface, * The work was partially \nsupported by the Grant Agency of the Czech Republic (project number 102/03/0672). Copyright is held by \nthe author/owner. OOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. \n de.ned as a set of methods required by the component im\u00adplementation. Every requires interface has to \nbe (directly or indirectly) connected to an appropriate provides interface. Acomponent C is de.ned as \na pair: a frame F and an architecture A. F is formed by all (provides and requires) in\u00adterfaces on the \nboundary of C (i.e., the interfaces through which C communicates with the components external to C, forming \nthe environment of C). A is formed by (i) subcom\u00adponents of C (the components nested in C) and (ii) connec\u00adtions \namong interfaces of F and interfaces of C s subcom\u00adponents. A run of a system can be seen as a sequence \nof events.An event can be either emitted or absorbed,e.g. a request (m. for a method m) is emitted by \nthe caller (!m.) and accepted by the callee (?m .). Similarly, m . stands for a response. The symbols \n?m .,!m .,?m .,!m . are called event tokens. The sequence of event tokens describing a run of a system \nis called a trace. A behavior protocol is a regular-like expression upon the set of all event tokens, \nsyntactically generating the set of all possible traces of a system. This set (language) is called the \nbehavior of the system. We de.ne two special kinds of behavior protocols: frame protocols describing \nbehavior of frames and architecture protocols describing behavior of architectures. 1.2 Goals and structure \nof the paper In this paper, we describe the consent operator and its applications in the area of static \nanalysis of component sys\u00adtems. Initially, the operator was proposed to automatically generate architecture \nprotocols, including information about communication errors. Consequently, we invented more ap\u00adplications \nof the operator. Thus, in Sect. 2 we describe the consent operator itself while in Sect. 3, 4 and 5 we \npresent its main applications. In Sect. 6 we shortly present the related work and in Sect. 7 the open \nissues.  2. ADDRESSING COMPOSITION ERRORS Behavior protocols are designed to describe behavior of hierarchically \nnested software components. One of the chal\u00adlenges here is to automatically generate the architecture \npro\u00adtocol for a set of frame protocols and a set of connections among corresponding frames. In [6], the \nproblem is solved using the composition operator: for an event e,behavior of the components emitting \nand absorbing e is synchronized, resulting in an internal event; distinct events on distinct components \nare arbitrarily interleaved; distinct events on the same component respect the original order. In [1, \n2], we de.ne three types of composition errors (er\u00adrors in communication caused by an erroneous composition): \nbad activity a component emits an event which is not ac\u00adcepted by the counterpart, no activity the \ncommunication among components stops, although there exists a compo\u00adnent which is not in an accepting \nstate, divergence the communication never stops. In addition, we de.ne the con\u00adsent operator as an extension \nof the composition operator: in the resulting language, composition errors are captured with erroneous \ntraces. 3. FAULTY ARCHITECTURES In [2], we proposed the concept of inverted frame protocol. Let ProtF \nbe the frame protocol for a component C, ProtA be the architecture protocol for C. While ProtF can be \nseen as an approximation of the behavior of C towards its environment, the inverted frame protocol Prot-1 \n(originat- F ing from ProtF by replacing of emitting events by absorbing events and vice versa) can be \nseen as an approximation of the behavior of the environment towards C. Thus, apply\u00ading the consent operator \nto ProtA and Prot-1 we get the F behavior of C in the context of its environment. Specially, we analyzed \nhow appearance of erroneous traces is in.uenced by the environment (the inverted frame proto\u00adcol). We \nconcluded that faulty architecture (e.g., an archi\u00adtecture whose behavior contains erroneous traces) \nis a rela\u00adtive concept: erroneous traces can be eliminated when the architecture is used within an appropriate \nenvironment. 4. PROTOCOL CONFORMANCE To support top-down design of component systems, the concept of \narchitecture protocol to frame protocol confor\u00admance was introduced in [6], formalizing the notion of \nbe\u00adhavior compatibility between the frame and the architec\u00adture. The exact de.nition of the conformance \nis based on partitioning the set of all events into the set of provisions and the set of requirements. \nNow, we are investigating the possibility to de.ne the conformance relation using the con\u00adsent operator \nand the frame protocol inversion in the fol\u00adlowing way: an architecture protocol ProtA conforms to a \nframe protocol ProtF , if the composition of ProtA and the inverted frame protocol Prot-1 via the consent \nopera- F tor contains no erroneous traces. We have found component architectures, for which this new \nde.nition gives better re\u00adsults than the old one. Here, better results means better consistency with \nthe actual mechanisms of the communica\u00adtion in component systems. 5. DYNAMIC UPDATES In [1, 2], we discuss \nhow behavior protocols can be used to capture dynamic updates replacing the architecture of a component \nat run-time. We show that denoting an update by a special token (an update token)in the frameproto\u00adcol \nof a component brings two bene.ts. First, because the update tokens restrict updates to speci.c points \nof compu\u00adtation only, controlling component state consistency is much simpler. Second, by applying the \nconsent operator to frame protocols containing update tokens we can test if an update of a component \nC is atomic, i.e., if no other component tries to communicate with C during the update. Such a static \nupdate atomicity testing allows to avoid locking and other run-time synchronization techniques which \nhave a negative impact on the performance. 6. RELATED WORK There are many frameworks for describing \nsoftware archi\u00adtectures, ranging from classical ones [3] to the recent work in the ObjectWeb Consortium \n[4]. The idea of describing the behavior of software architectures using formal methods can be found \nin [5]. If compared with the composition oper\u00adators from other behavior description methods, e.g. [8], \nthe main bene.t of the consent operator is that it captures the asymmetry of a procedure call [1]. 7. \nCONCLUSION AND FUTURE WORK Although the concept of the consent operator is clear, there are still many \nopen issues: (1) We have de.ned three types of composition errors bad activity, no activity and divergence. \nAre there any additional types of composition errors? (2) The architecture to frame protocol conformance \nde.ned using the consent operator gives more realistic re\u00adsults than the classic de.nition for certain \narchitectures. Here, the open question is if it is better for all architectures. (3) We have demonstrated \nthat update atomicity can be tested statically. We assume that the update points are de\u00adnoted in a frame \nprotocol by the frame designer. Could such update points be found automatically? (4) The composition \noperator is de.ned for two operands. To obtain the architec\u00adture protocol for an architecture containing \nmore than two frames, the operator has to be applied several times. As it is proved to be associative, \nthe order of the frame protocols in the composition does not in.uence the result. However, does it in.uence \nthe time and memory complexity of the algorithm, which realizes the operator? In addition, a case study \ninvolving a non-trivial compo\u00adnent system should be made as a proof-of-the-concept. 8. REFERENCES [1] \nAdamek J, Plasil F. Behavior Protocols Capturing Errors and Updates. Proceedings of the Second International \nWorkshop on Unanticipated Software Evolution, ETAPS, University of Warsaw, Poland, 2003. [2] Adamek J, \nPlasil F. Behavior Protocols: Tolerating Faulty Architectures and Supporting Dynamic Updates. Tech. Rep. \n02/10, Dept. of Comp. Science, Univ. of New Hampshire, 2002. [3] Allen R. J, Garlan D. A Formal Basis \nFor Architectural Connection. ACM Transactions on Software Engineering and Methodology, Jul. 1997. [4] \nBruneton E, Coupaye T, Stefani J. B. The Fractal Composition Framework. Version 1.0. The ObjectWeb Consortium, \nJun. 2002. [5] Giannakopoulou D, Kramer J, Cheung S. C. Analysing the Behaviour of Distributed Systems \nusing Tracta. Journal of Automated Software Engineering, vol. 6(1), Jan. 1999. [6] Plasil F, Visnovsky \nS. Behavior protocols for Software Components. IEEE Trans. on SW Eng., 28(9), 2002. [7] Plasil F, Balek \nD, Janecek R. SOFA/DCUP Architecture for Component Trading and Dynamic Updating. Proc. of the ICCDS 98, \nAnnapolis, IEEE Comp. Soc. Press, 1998. [8] Roscoe A. W. The Theory and Practice of Concurrency. Prentice-Hall, \n1998. [9] SOFA project, http://sofa.forge.objectweb.org/  \n\t\t\t", "proc_id": "949344", "abstract": "Static analysis of systems allows to discover errors at design time and to avoid run-time error detection techniques that negatively impact performance of the systems. In this paper, we present the consent operator, which allows (i) to capture errors resulting from incorrect composition of software components, (ii) to test conformance of behavior descriptions and (iii) to analyze whether conditions of a correct dynamic update are satisfied.", "authors": [{"name": "Jiri Adamek", "author_profile_id": "81538092056", "affiliation": "Charles University, Czech Republic", "person_id": "P354783", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949378", "year": "2003", "article_id": "949378", "conference": "OOPSLA", "title": "Static analysis of component systems using behavior protocols", "url": "http://dl.acm.org/citation.cfm?id=949378"}