{"article_publication_date": "10-26-2003", "fulltext": "\n An Introduction to Fly: A Smaller Smalltalk Thomas Wrensch and Jonathan Schifman Department of Computer \nScience University of the Pacific Stockton, CA 95211 {twrensch, j_schifman }@uop.edu ABSTRACT Fly is \na lightweight version of the Smalltalk programming environment. Fly attempts to preserve the benefits \nof Smalltalk as a development system while making it feasible to develop applications for embedded systems, \nPDAs, and other limited resource environments. Here we introduce the Fly project and its current and \nexpected results. Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs \nand Features classes and objects. D.3.4 [Programming Languages]: Processors code generation, run-time \nenvironments. General Terms Languages Keywords Fly, Smalltalk, Embedded Systems, Class Libraries, Hosted \nDevelopment. 1. INTRODUCTION Smalltalk is a pure object-oriented programming language with a tightly \nintegrated class library and development environment. The class library and the language s full polymorphic \nnature make it an excellent choice for fast prototyping and application development on workstation level-platforms. \nSmalltalk stores code and data in an image, which typically runs in a virtual machine. Since all Smalltalk \ncode is combined in this image including development tools and supporting libraries it is difficult to \nseparate the development code from the application code. This leads to rather large images for small \napplications. Fly is an attempt to create a smaller Smalltalk. While the major focus is reducing the \nsize of the applications written in Fly, we also feel that a smaller class library will be a benefit \nto novice Smalltalk users, who can be overwhelmed by the large number of classes they must navigate to \nfind those they need. 2. BACKGROUND Smalltalk is a wonderful system for developers. It includes a rich \nclass library, full polymorphism, a really good debugger, and the Copyright is held by the author/owner(s). \nOOPSLA 03, October 26 30, 2003, Anaheim, California, USA. ACM 1-58113-751-6/03/0010. ability to do incremental \ndevelopment and testing. These advantages come at an astonishingly low cost, but they do have a cost \nin both execution time and memory usage. Perhaps the most important cost is the relatively large minimum \napplication size of a Smalltalk program. Even using techniques to remove unused portions of the class \nlibrary, the smallest application is quite large [1]. This is rarely a problem when writing applications \nfor personal computers or workstations. It is a problem when the target execution environment is an embedded \nsystem, Personal Digital Assistant (PDA), or other low-resource device. Another real cost of the large \nclass libraries in traditional Smalltalk systems is the time and effort needed to learn to use the library. \nNovice Smalltalk programmers must spend the majority of their time looking for the classes and methods \nthey need. An extreme example is Squeak, an excellent Smalltalk system that is simply too large. At over \n3,500 classes and 40,000 methods, Squeak is very difficult to easily navigate and understand.  3. APPROACH \n3.1 Writing Smalltalk in Smalltalk The idea of writing Smalltalk in Smalltalk began in the 1970 s with \ncloning techniques to move images to a new virtual machine. More recently the creators of Squeak [4] \nhave refined and extended this idea by writing the virtual machine and primitives in Smalltalk. We intend \nto write nearly all of Fly in Smalltalk. Initially we will use an existing Smalltalk and then, when the \nproject is far enough along, rewrite it in Fly itself. 3.2 Splitting the Image Fly s approach to writing \nSmalltalk in Smalltalk uses two images: a development image and an application image. The development \nimage contains development tools like the compiler, interpreter, and image translators. In our first \niteration the development image is written in Squeak. This situation is illustrated in Figure 1. The \nadvantage of putting the development tools in a separate image is a smaller and less complex class library. \nFly s application image can exclude the development tools and the classes needed to support those tools. \n 3.3 Image Translators The application image can be executed inside the development image for debugging \nand incremental testing. The application image can also be translated to another execution platform using \nan Image Translator. These specifically targeted translators can produce small, fast programs. While \nthere may be many image translators for different execution platforms, the set of primitives used to \naccess the resources of the platform will vary. The portability of a Fly application across these different \nplatforms requires further study.  Figure 1. This figure shows the relationship between the development \nimage, application image, and generated code for different execution platforms.  4. RESULTS Our work \nto date on Fly has focused on creating the initial development environment and writing a base class library. \nThe results of this work are encouraging. The class library is quite small when compared to other Smalltalks, \nwith 29 classes and 170 methods. The idea of the separate development image has also been validated. \nThough it is not yet complete, the development image is adequate to have been used to develop the base \nlibrary and a small application. We have also developed an alternative metaclass system, which is both \neasier for the user to understand, and eliminates the creating of extraneous metaclass objects. One difficulty \nwith a small base library is the need to add classes to support certain types of behavior such as GUI \ninterfaces or the specialized hardware often found on embedded systems. To overcome this we are examining \nmodular class library systems with robust dependency mechanisms. 5. RELATED WORK Tinytalk [5] was an \nearly effort to port Smalltalk to a typical PC. As this work was done in the late 1970 s that meant a \nmaximum of 64K of RAM and very limited secondary storage. Tinytalk used a command-line development system \nso small applications could be created directly on the PC. Perhaps the most successful effort in creating \nSmalltalk for small platforms is Pocket Smalltalk [2], a system for developing Smalltalk for Palm PDAs. \nLike Fly it uses a separate host Smalltalk on a PC, but cannot execute application code in the development \nenvironment. Timothy Budd s Little Smalltalk [3] has a smaller class library and requires less memory \nthan most versions of Smalltalk. Like Tinytalk it uses a command-line interface. 6. CONCLUSION Fly is \nintended for writing applications for execution platforms that could not otherwise be written in Smalltalk. \nIt differs from other Smalltalks by separating the development and application images, using a dramatically \nsmaller class library, a new metaclass system, and the ability to generate code for low-resource platforms. \nResults thus far are promising. The ideas of a very small base class library and a separate development \nimage have been validated. Planned work on Fly will teach us about the level of effort needed to produce \nimage translators, portability issues, and Fly s effectiveness in writing larger applications. 7. ACKNOWLEDGMENTS \nOur thanks to Gene Korienek and Eric Scharf for their help in developing these ideas. We would also like \nto thank the students and faculty of the department for listening to our endless discussions on metaclass \narchitectures and Smalltalk parsers. 8. REFERENCES [1] Ageson, O. and Unger, D. Sifting Out the Gold: \nDelivering Compact Applications from an Exploratory Object-Oriented Programming Environment. Proceedings \nof OOPSLA 94, pp 355-371. ACM Press, New York, NY. 1994. [2] Brault, Andrew. Pocket Smalltalk User s \nGuide. Available at www.pocketsmalltalk.com. 2001. [3] Budd, T. A Little Smalltalk. Addison-Wesley Publishing, \nReading MA. 1987. [4] Ingalls, D., Kaehler, T., Maloney, J., Wallace, S., and Kay, A. Back to the Future: \nThe Story of Squeak, A Practical Smalltalk Written in Itself. Proceedings of OOPSLA 97. ACM Press, New \nYork NY. 1997. [5] McCall, K. and Tesler, L. Tinytalk, a Subset of Smalltalk-76 for 64KB Microcomputers. \nProceedings of the 2nd ACM SIGSMALL Symposium and 1st SIGPC Symposium on Small Systems, pp 197-198. ACM \nPress, New York, NY. 1980.  \n\t\t\t", "proc_id": "949344", "abstract": "Fly is a lightweight version of the Smalltalk programming environment. Fly attempts to preserve the benefits of Smalltalk as a development system while making it feasible to develop applications for embedded systems, PDAs, and other limited resource environments. Here we introduce the Fly project and its current and expected results.", "authors": [{"name": "Thomas Wrensch", "author_profile_id": "81537557856", "affiliation": "University of the Pacific, Stockton, CA", "person_id": "PP39048934", "email_address": "", "orcid_id": ""}, {"name": "Jonathan Schifman", "author_profile_id": "81100561044", "affiliation": "University of the Pacific, Stockton, CA", "person_id": "P643460", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949418", "year": "2003", "article_id": "949418", "conference": "OOPSLA", "title": "An introduction to fly: a smaller smalltalk", "url": "http://dl.acm.org/citation.cfm?id=949418"}