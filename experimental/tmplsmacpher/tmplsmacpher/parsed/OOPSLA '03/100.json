{"article_publication_date": "10-26-2003", "fulltext": "\n Model Consistency in the Object Oriented Software Development Process Gabriela A. P\u00e9rez LIFIA - Laboratorio \nde Investigaci\u00f3n y Formaci\u00f3n en Inform\u00e1tica Avanzada Universidad Nacional de La Plata, Facultad de Inform\u00e1tica \nLa Plata, Argentina, 1900 gperez@sol.info.unlp.edu.ar ABSTRACT Model Refinement is a relationship that \nrelates two elements representing the same concept at different levels of abstraction. In UML, Refinement \nis described in an informal way. To avoid wrong model interpretations, we study a formalization of the \nrefinement relation. This work provides an enhancement to the UML metamodel specification. Categories \nand Subject Descriptors D.2 [Software Engieneering]: Requirements/Specifications, Methodologies (e.g., \nobject-oriented, structured) General Terms Documentation, Design, Standardization, Languages.  Keywords \nObject Oriented Analysis and Design, Unified Process, UML, Use Cases. 1. INTRODUCTION A software development \nprocess, e.g. The Unified Process [5], is a set of activities needed to transform user's requirements \ninto a software system. Modern software development processes are iterative and incremental, they repeat \nover a series of iterations making up the life cycle of a system. Each iteration takes place over time \nand it consists of one pass through the requirements, analysis, design, implementation and test activities, \nbuilding a number of different artifacts (i.e. models). All these artifacts are not independent; they \nare semantically overlapping and together represent the system as a whole. Elements in one artifact have \ntrace dependencies to other artifacts. On the other hand, due to the incremental nature of the process, \neach iteration results in an increment of artifacts built in previous iterations. Model Refinement is \ncarried out in different ways: for example: on the internal dimension (artifact-dimension ), we can restrict \nthe use case specification; On the vertical dimension (activity \u00addimension), analysis models are refinements \nof use case models, but on the other hand, on the horizontal dimension (iteration\u00addimension), models \nbuilt in an iteration are usually refinements of models (of the same kind) built in previous iterations. \n 2. INTERNAL DIMENSION: USE CASE SPECIFICATION Use cases can be specified in a number of ways, generally \nwith natural language structured as a conversation between user and system. This conversation considers \nthe normal action sequence and also alternative sequences. Each sequence represents a possible scenario \nof execution of the use case. Then, the complete description of a use case is composed by an scenario \nsequence. In the UML metamodel, an action sequence is an instance of the ActionSequence metaclass, which \nis subclass of the Action metaclass. This fact generates some conflicting situations, like * An ActionSequence \ncould have arguments * An ActionSequence could have an associated message  As a solution for these \nproblems, we propose a new metamodel where the metaclass Action is sub classified with both CompositeAction \nand SimpleAction subclasses. A CompositeAction will be composed by actions, which could be acceded by \nthe actionSequence association (this schema follows the pattern Composite [2]). On the other hand, underlined \nactions1 can appear in a use case conversation. The meaning of this is it will be refined. It is interesting \nto be able to distinguish both concrete actions (i.e. atomic actions, that will not be refined) and abstract \nactions (i.e. actions that require a refinement). This situation neither is represented in the UML metamodel. \nWe propose to sub classify a SimpleAction in both ConcreteAction and AbstractAction. ConcreteAction will \nbe the superclass of the concrete actions that were defined in the metamodel until now (i.e. CallAction, \nCreateAction, etc.), while an AbstractAction will specify those actions that will be refined. These new \nmetaclasses improve formality of the Use Case metamodel allowing for the definition of the Use Case refinement \nhierarchy, as we will see in next section. 3. HORIZONTAL DIMENSION: COLLABORATION REFINEMENT Collaborations \nas well as use cases can be refined through subordinate collaborations, forming a refinement hierarchy. \nEach subordinate collaboration implements in more detail one part of 1 The notation used for conversation \nis based on [1] Copyright is held by the author/owner(s). OOPSLA 03, October 26 30, 2003, Anaheim, California, \nUSA. ACM 1-58113-751-6/03/0010. the global functionality and can have its own sets of roles and interactions. \nIn order to formally specify the refinement relation between collaborations we define additional well \nformedness rules on the metaclass Collaboration. In the case that a collaboration refines a message, \nwe propose a standard format for such collaboration that allows a formal verification of well formedness \nof the refinement relation. In order to understand this format it is necessary to consider that the sender \nof a message has less importance than the receiver of this message. The sender can be an instance of \nany ClassifierRole, however the receiver of the message is the responsible of the interpretation of that \nmessage. For this reason, we propose that the subordinate collaboration that describes the refinement \nof the original message begins this refinement with an instance of the ClassifierRole that received this \nmessage in the superordinate collaboration. In addition, considering that the only messages that can \nbe refined are those associated with CallActions, (since the other actions are atomic), we propose that \nthe name of each subordinate collaboration will be formed by both the name of the Operation associated \nwith that instance of CallAction (associated to the message), and the name of the base Classifier that \ncontains such operation. In this way, examining the name of a subordinate collaboration we can associate \nit to at least one message in the superordinate collaboration, without ambiguity. On the other hand, \nthe ClassifierRole receiving of a refined message must maintain a relation with the ClassifierRole that \nsends the first message in each thread in the subordinate collaboration. It would be natural that in \nthe refinement, we want to specify in more detail the ClassifierRole in charge of that behavior. The \nClassifierRole (first sender) in the subordinate collaboration should belong to the same generalization \nhierarchy as the original Classifier. In case that this Classifier is an interface the first sender must \nbe a class that implements it.  4. CONSISTENCY CHECKING BETWEEN MODELS IN DIFFERENT DIMENSIONS Since \ndifferent models that are built during the software development process are related to each other along \ndifferent dimensions, it is natural to perceive that interdependencies between dimensions could arise. \nFor example, when a use case is realized by collaboration, it is expected that some specific relations \nhold between their respective subordinated elements, as we can see in the figure below.  UML does not \nspecify any constraint regulating these relationships. We define new well formedness rules -on the Collaboration \nmetaclass- that allow us to verify consistency between two different refinement hierarchies, as follows: \nself.representUseCase implies (self.representedClassifier.hasIncluded implies (self.representedClassifier.include.addition \n-> forAll (subUseCase | self.usedCollaboration-> exists (subcol | subcol.representedClassifier = subUseCase) \n)) ) This rule means that if a superordinate collaboration implements2 a superordinate Use Case, then \nthere must exist a subordinate collaboration implementing each subordinate Use Case.  5. CONCLUSIONS \nIn the UML specification document, several concepts are still described in an ambiguous, informal way. \nIn previous works, we have analyzed other of these concepts ([4] [7] [8]). In this article we analyze \nthe dependency relationship between models known as: Model Refinement . In order to avoid inconsistencies \nand wrong model interpretations, in this article we proposed, in first instance, a formalization of the \nUse Case specification, represented by a conversation between an actor and the system. The Use Case conversation \ndid not have a representation in the UML metamodel. In second instance we proposed to formalize the refinement \nrelations between model elements of the same kind. Finally, on top of these formalizations, we discussed \nrefinement relations between models of different kind (use case models and collaboration models realizing \nthem) In particular, we defined well formedness rules in the OCL language, restricting Use Case specification \nas well as refinement hierarchy of both Use Cases and Collaborations. The rules defined in this work \nform an enhancement of the UML metamodel specification. These rules should be used as a formal foundation \nfor the construction of case tools performing consistency checking of models. Support offered by tools \nwill improve the quality of the software development process.  6. REFERENCES [1] Cockburn, Alistair. \nWriting Effective Use Cases. Addison-Wesley. [2] Gamma, H. Design Patterns. Addison-Wesley, Professional \nComputing Series, 1995. [3] Giandini,R, Pons, C and Baum,G.. An algebra for Use Cases in the UML. OOPSLA\u00b400 \nWorkshop on Behavioral Semantics, Minneapolis, USA, Oct. 2000. [4] Giandini, R., Pons, C., P\u00e9rez,G. Use \nCase Refinements in the OO Software Development Process. Proceedings of CLEI 2002, ISBN 9974-7704-1-6, \nUruguay. Nov. 2002. [5] Jacobson, I..Booch, G Rumbaugh, J., The Unified Software Development Process, \nAddison Wesley. (1999) [6] UML Specification. Version 1.4, Sept. 2001. Page 2-121 2 The attribute representedClassifier \nrepresents the Classifier (Class, Use Case, etc.) that the collaboration is realizing ([6])   \n\t\t\t", "proc_id": "949344", "abstract": "Model Refinement is a relationship that relates two elements representing the same concept at different levels of abstraction. In UML, Refinement is described in an informal way.To avoid wrong model interpretations, we study a formalization of the refinement relation. This work provides an enhancement to the UML metamodel specification.", "authors": [{"name": "Gabriela A. Perez", "author_profile_id": "81100050495", "affiliation": "Universidad Nacional de La Plata, La Plata, Argentina", "person_id": "P643446", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/949344.949454", "year": "2003", "article_id": "949454", "conference": "OOPSLA", "title": "Model consistency in the object oriented software development process", "url": "http://dl.acm.org/citation.cfm?id=949454"}