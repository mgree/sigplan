{"article_publication_date": "10-17-1995", "fulltext": "\n Extending SQL-92 for OODB Access: Design and Implementation Experience Jerry 1iierna.n IBM Sant.a Teresa \nLab 555 Bailey Avcnile San Jose, CA !I5141 email: jkicrnan:l<vnct..ihm.com  Abstract This paper describes \nthe design at~d itnplcment at.ion of a query engine t ha,t provides ext,entl(>d SQL-based access to the \ndata managed by an object,-ori~tlte(l database sys-tem. This query engine allows ext.euded SQL queries \nt,o be embedded in C++ progra.nls or issued interactively from a command line interfa.ce. The language \nsupported by the engine is the comp1et.c SQL-92 select st,at,ement plus object extensions for navigating \nalong paths and embedded struct,ures, querying nc,st ~1 sets, and invok-ing member functions. In addition, \nan object.-oriented SQL view facility is provided. I. sing this virw facilit,y, one can define object-oriented \nvic,ws; one can also definr views that flatten complex OODH sc1icIna.s. allowing di-rect access by existing \ntools designed to provide remot.e access to relational databases. I lic view facility a.lso supports \nthe definit.ion of views t.hat. include reference and set,-valued columns ba.sed on ot.her views, thus \nal-lowing entire view schemas to be created. This paper describes the SQL-92 query and view extensions \nand dis-cusses a number of issues tha.t arose on the way to the implementation that is current.ly running \non t,op of the ObjectStore OODB system. 1 Introduction The integration of object t,echnology and database \nsys-tems ha.s been an active area of rcsea.rch for the past, decade. One important aspect of I Itr itlbcgrat#ion \nof t,hese two technologies is the provision of cficicnt, declara-tive query interfaces for accessing \nand nianipulat ing ob-ject data. Conlpared t,o other aspects of ohjrct-oriented database (OODB) technology. \nSII~II as irlt.rgral.ing pcr-sist#ence into object-orient,ed laliguagos like (:++ a.nd Smalltalk, queries \nwere given rc1a.t ivcly lit,tle attention in the early days of OODB research [Si,o91]. In [Kim93], it \nis pointed out that even t,oday, a number of commer-cial OODB systems are quit,e weak in f,his regard. \nAs the Permission to make digital/hard copy of part or all of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for profit or commercial advantage, \nthe copyright notice, the title of the publication and its date appear, and notice is given that copying \nis by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee. OOPSIA 95 Austin, TX, USA 0 1995 ACM O-89791 \n-703-O/95/001 0...$3.50 Michael J. Carey IRhl Almadcn Research Center 6.50 flarry Road, K55-Bl San .Josr. \nCA 95120 c-mail: carey~@almaden.ibm.com OODR fit,ld has dcvcloped, however, a number of pro-posals for \n001~1~ query languages have appeared in the databa.sc literature, including [CDVSS, Kim89, BCD89, OIIRISX!, \n1X592, KKS92, ADF+93, BMG93]. While proposals out.nunlher actual implement,ations, several of these lang\\lage \ndesigns have indeed heen implementfed as the query int.erfaces for significant commercial OODB produ&#38; \n[BCD89, OHMS92]. The focus of t,his paper is the provision of SQL-based query accrss t.o a C++ based \nOODB system. The com-mercial OODH systems that are generally considered to have lhc best. ot,jcct query \nfacilities, 02 [BCD89] and Ohjcct St or( [011 MS92], each provide their own flavor of ot)jc>ct qltrry \nlnngllagc. OhjectStore s query language is an cxtciision to f hc expression synt,a.x of C++. 02 s query \nlanguage is genrrally more SQL-like, and has been adapted int,o a proposed OODB query language standard \n(ODMG-93) by a consortium of OODB system vendors [ADF+93], but it, differs from SQL in a number of re-spects \n[Kim94]. In contrast t,o ObjectStore, 02, a,nd ODMG-93 query int,erfaces, our goal was to design and \nimplement. an OODB query interface t,hat provides an upward compatible extension to SQL-92 [ISO91]. The \nmotivation for this approach is twofold. First, it en-ables progralnmers familiar with SQL to write OODB \nqueries without learning an ent,irely new language; they must sinlply learn about our object extensions. \nSecond. it enables t hr nlany t,ools that have been built, for rela-t,ional systrlns to access OODB data \nvia interfaces such as ODM [hlic92]. CZ e call t,he resulting query language oo-SQL.? In addit ion to \n00-SQL, anot.her part of our work has hcen lo (lc>sign and implement, an OODB view facility based on \n00-SQL queries and on the use of relational-st,ylr qurry rewrit,r [I IIH92] techniques. One reason for \nproviding such an OODB view facility is to make it pos-sible for different, users or user groups t,o \nhave different perspectives OII the same object data, as with relational views. This has been the primary \nmotivation for various object, virw facility proposals that have appeared in the research literature \n(e.g., [Day89, HZSO, AB91, KKS92]). Anothrr reason, af, Icast, as important as the first, is t,o provide \nadditional support for the second motivation Ohjrc-iSlorc> is a trademark of Object Design, Inc. Prol)crly \npror~onncrtl, t.his becomes oooh, SQL! cited earlier for basing an object query language on SQL- 92: \nHaving an OODB view facility makes it possible to make OODB data, which is usually stored as complex \nnested structures, appear as relat,ional tables for access by legacy relational tools and applications. \nCompared to previous work on object query languages and views, we believe that t,his paper makes several \ncon-tributions that should be of interest t-0 ot.hers working in the area. First, we explain the tliffc,rent. \nways in which 00-SQL ext,ends SQL-92; we have, tripd t.o keep the number of new constructs mininlal in \no&#38;r to remain as close to SQL-92 as possible. Scco11t1. some of t,he ex-tensions arose from a desire \nt.o make 00-SQL an effec-tive embedded object query langua.gr for C++ programs, and we explain how C++ \nprogramming considerat,ions influenced our design. Third, we describe a simple ob-ject view facility \nthat has actually been implemented. Finally, we describe the current. implementation of OO-SQL, including \na heuristic query optimizer, which runs on top of the Object,Store [OhjSI] OODB system. To leverage Object,Store \ns own query facilit.ies as much as possible, our implementa.tion of 00-SQL uses Object-Store queries \nas single collecl.iou filters in order t,o exploit available indexes, but resort,s 1.0 looping and roll \nyour own filters to evalua.te more colllplex prcdicatcs t,lial, are not expressible as OhjectStorc~ qucrics \n(e.g., SQL-92 like predicates). The remainder of this paper is orga.nized as follows. We begin in Section \n2 by briefly reviewing the C++ based data model and query language of ObjectStore. With this background, \nSection 3 t,hen describes the ways that 00-SQL extends SQL-92 in order to enable access to object data. \nThe extensions include support for nav-igation along paths and through embedded structures, querying \nof nested sets, and invocations of C++ mem-ber functions. Section 4 then describes the view facil-ity \nthat 00-SQL provides. The view facility supports the definition of both types and inst,anccs of views; \nOO-SQL view types can include reference a,nd set-valued at-tributes based on ot,her views, so ent.ire \nview schemas can be created if desired. Aft,er this comes Section 5: which discusses how 00-SQL intrracts \nwith C++ appli-cation programs. Having finished t 11c exbernal descrip-tion of 00-SQL, we then t.urn \nto its irnplerr~entabion in Section 6, covering the 00-SQL quci-y processing archi-tecture, the query \nplan interprctrr, and the mot)ivation for and design of the 00-SQL heuristic query optimizer. To provide \na sense of the state of t.he current implementa-tion of 00-SQL, Section 7 present,s a brief performance \nanalysis based on the query component of a standard OODB benchmark. Fina.lly, 00-SQL is compared to im-portant \nrelated work in Section 8, and Section 9 presents our conclusions. 2 A Brief Review of ObjectStore SQL-92 \nis intended for use in mauiprrlat ing rclat,ional tables whose t,uples conl.ain fields of simple data \nt,ypes. In contrast, 00-SQL must ha.ndle a much richer data model, consisting of the C++ t.y~)c system \na.nd the Ob-jectstore extensions to C++. This section provides a whirlwind tour of the ObjectSt,ore dat,a \nmodel in order to motivate the SQL-92 extensions discussed in the re-mainder of the paper. Also, since \n00-SQL is intended to provide a richer query facility for accessing Object-Store dalaha.ses. we briefly \ndiscuss the retrieval power of ObjectStore s native query language. Space precludes a detailed description \nof the data modcling Capabilities provided by ObjectStore. Instead, we rwiw its data model informally \nusing the classi-cal cm~)loyc~c~/dcpart mcnt database example. Figure pfesrn~s an Ohject.St.ore version \nof a schema for this dat ;lt)asc*. Ot)jrct.St.orc ext ensions to C++ are shown in it.alics, while (I++ \nkeywords are in boldface and user-defined identifiers arc shown in plain t,ypeface. Though brief, i.hc \nrxa.mple has been concocted to illustrate a number of t.he feat,ures of the ObjectSt#ore data model that \n00SQL must be capable of handling! including in-heritance, indexed dat.a, relationships, pointers, embed-ded \nclasses, arrays, C-style structs, enumerations, simple types, and met,hods. The class person in Figure \n1 contains only a name data member (of t.ype char*). To make it possible to index collect ions of person \ninstances based on the name data membc~r. Ol),icr(Storc requires the use of the indexable dcclaratiotl. \nMosl. information about employees appears in the class empclass, which is a subclass of person (so name \nis inhcritcd). Most of the data members of empclass should be self-explanatory. Some, like no, sal, and \nemp-code. are of simple data types. The emp-type data member is of an enumeration type. The address member \ndemonstrates the usage of a C-style structure, while birth uses a class representation; note that both \nare embedded structures, not, pointers to structures. The dept data member is a pointer t,o a deptclass \ninstance, and is declared t,o have an inverse relat,ionship with t,he emps member in the class deptclass \n(which holds a set of point.crs to empclass instances).3 The empClass data member pt2dept will store \nthe same information as dept. hut its type is declared to be void *; we will use this data member later \nto demonstrate casting in querirs. l:inally, t,o krcp track of all of the employee objects. l.ltc cxamplr: \ndatabase in Figure 1 includes a t.op-lcvcl collcct.ion called Emp. The class deptclass is treatctl sitnilarly, \nand should be largely self-explanatory. As nlont ionrd iu t)he Introduction, ObjectStore s na-tive query \nIanguagc is an extension of C++ s expression syntax. This was moi.iva.ted by the fact that, ObjectStore \n(OS) queries must be embedded in C++ application pro-grams. OS queries enable programmers to declaratively \nsubset, a given collect,ion of objects; they return a set, of pointers to t.he objects within the collection \nthat sat.-isfy t.he given query predicate. A query predicate is a boolean expression that refers to the \ndat,a members of the object,s contained in the targeted collection or of objects reachable by (point,er-based) \nnavigation starting from f.hc ol).jrc(s in the targeted collection. Because OS Intrrnall,v. Ot),jrrtSt.ore \nimplements pointers and sets t,hat. participak in relationships differently than other point-ers and \nsets. Wr will ignore this implementation distinction throughout the paper. class person t public : char \n class empclass : public person 1 public : int no indesable; float sal ; char emp-code; // A, B, C or \nD enum -Emp-type {MGR, ENGR, SCCY}; -Emp-t ype emp-type ; Address address; Date birth; deptclass *dept \ninrrr~sr_,nc,,nbrt. emps ; void *pt2dept; // lo d(~nlonslratr casting 1; classI deptclass public: int \nno; char name C201 ; os-Set<empClass*> emps inverse-member dept ; ): typedef struct { char *street, \n*city, *zip; } Address; class Date t public : short day, month, year; char *display () ; int compare(Date*) \n; 1; osSet<empClass*> *Emp; // Database root os-Set<deptClass*> *Dept ; // Datahasr root Figure 1: A \nsample OODR schema queries have declarat,ive semant,ics, OhjectStore includes a query optimizer that, \nis able to optimize OS queries (e.g., to take advantage of indicts that Inay exist on the target,ed collection). \nHowever, the cxprcssive power of the OS query language has certain significant limit.a-tions stemming \nfrom the fact that each OS query has a single root, collection. As we will SW ncxl., 00-SQL provides \nfeatures that go well beyond the single collec-tion subsetting power of OS qucrics, as 00-SQL includes \nsupport for queries involving pro,jccl.ion, joins, grouping, aggregation, method invocat,ion, and even \ncomputation (expressions) on the retrieved data..  3 The 00-SQL Language As mentioned in the Introduction, \n00-SQL consists of SQL-92 plus a set of extensions that, support the ma-nipulation of the complex structures \npresent in OODBs. Since OIIC of the nlain ohjcctives at the outset of the OO-SQL rfrort wils to provide \na gat.eway t,hrough which re-la.t ional applications and tools could access ObjectStore databascls, WC \ntried to minimize the number of alter-ations to SQL-92. Rat,her than describing 00-SQL from scra.tch, \nWC will describe it by detailing its extensions and enhancrmcnt.s t.o SQL-92. In each case, we will discuss \nthe impact, on both t,he syntax and semantics of the lan-guage. 3.1 Basic Navigational Queries Like 1110~1. \nother OODB query languages, 00-SQL pro-vides path expressions [Zan83, BCD89, KKS92] for the purpose of \nwriting queries involving a navigational com-poncnt I ;11II cxprf&#38;ons in 00-SQL permit t,raversal \nt.hrough ~~1111~~dd~d classes and structs, pointers and re-lat.ionsllips, at~d Illulti-valued collections. \nThe 00-SQL path syntax is tile same as that proposed for SQL3 [MelX] ) ( w 11c 1 d II ows t,raversal \nthrough embedded struc- I I tures as Ahslract. Dat,a Types (ADTs) using .. (in-stead of , ). AII 00-SQL \npat,h expression can appear anywhere that a column can in SQL-92. The general form of a path expression \nis q,ml..mz..m3.., where q is a quantified variable defined over a collection C, ml is a data member \nor method of the class for instances of C, and so on; a member mi can either be a data member or a method. \nThe path expression as a whole evaluates to the value of the leaf of the expression. As mentioned above, \none use of path expressions is for navigating through embedded classes and C-style struc-tures that define \nmolecular data types. In the schema given in Figure I! the data member birth is of type Date. whicll \nis dcfincd as a class. Thus, the member birth cau he furlhcr subdivided into day, month, and year. Sitllilarly. \nlhc lllclllber address is of type Address, which is tlrfid as a (:-style structure. Path expressions \nin 00-SQL allow queries to t,raverse into the (public) nest*4 n~c~mbers of class definitions. For example, \nthe following query se1cct.s t.he year of birth and zip code of employee nulllher 1: select e.birth..year, \ne.address..zip from Emp e where e.no = 1; Also as mentioned above, pointer (and relationship) dat,a. \nnlcmhcrs can participat,e in 00-SQL path expres-sions as well. When such a pointer member is in an interlllcdiat(> \nposii ion in a pat,h expression, it must be a point(>r lo a class instance, a pointer to a C-style struct \n( or il pointt>r to a. multi-valued collection-based membc~r. 1 11~~following example query selects the \nde-partnlcnt nanl(l of employee number 1: select e.dept. .name from Emp e where e.no = 1;  3.2 Querying \nNested Collections 00-SQL supports access to the elements both of top-level collections (e.g., Dept in \nFigure 1) and nested col-lections (e.g.. the emps dat,a member of a deptclass instance). There are two \nways of referring to the efe-ments of a. nestled collection in 00-SQL -using an EX-plicif quantifier \nor using an lmplicil quant,ifier. In addi-tion, nest,ed collections can a.ppcar in 00-SQL queries anywhere \nthat SQL-92 permits t.hc appearance of a sub-query (i.e., a nested query). 3.2.1 Explicit Quantifkrs \nIn SQL-92, explicit. quantifiers ra~~gr over top-level cof-fections (i.e., relations) and arc tfccfarcd \nin the from clause. 00-SQL adds parent.hf>sc>s for (fccfarit~g quan-tifiers over nested coffect.ions. \nFor c xait~plr, i.fle query fragment from Dept d, (d.emps) e declares a quantifier d to range over the \nroot, collection Dept and then declares a quant,ifier e that ranges over the elements of the embedded \ncollection d. emps. During query evaluation, for each different object, to which d is bound, the set, \nof bindings for e changes. Also, as for top-level collections in SQL-92, mult,iple nested quantifiers \ncan be declared if needed. The query fragment from Dept d, (d.emps) el, (d.emps) e2 declares two (independent,) \nquant,ifers ranging over the embedded collection d. emps. The embedded collection over which a. quantifier \nis defined can be part, of a. pa.th of any dept.h, possibly containing methods and mutt i-valuc~l c1at.a \nmembers, as we wilt see short,fy. The only rcst.rict.ion is t,hat the leaf node of the pat 11 used t,o \ndcfinc il qll;lllt.ificr must, be a multi-valued data member. As a final cxarnpfr, in t.hr following \nquery fragment., t)flc qllairtificr e2 is declared over the set of employees in ei s cf~~partmcnt, a.nd \nsim-ilarly e3 is declared over the set of empfoyccs in e2 s depa.rtment: from Emp el, (ei.dept..emps) \ne2, (e2.dept..emps) e3 For some users, nested quant ifirrs a.re immediat,efy in-tuitive. For ot,hcrs, \nit, helps 1.0 draw a.n analogy be-tween nested quantifiers and tflt concept. of flat,tening [BCD89! ADF+93]. \nFlattening takes a. collection of collections of element,s ant1 returns a rollrct.ioii of efe-ments. \nFor example, flat.lcn ( { { 1.2.3). { 1,5,C,} } ) ret.urns the result { 1,2,3,4,5,6}. I fw dt~cfarat \nion of quant.i-fier e over the nested set, d.emps can br> explained as Aatten(el, e2, . . . , e,) where \nci is t.frc> sci of employees in the ith department. It should bc noted tflat, the dec-laration of nested \nquantifiers does not (by ikeff) cause the removal of duplicates, but, that, duplicate elimination can \nbe performed on the final result. by using select distinct. 3.2.2 Implicit Quantifiers Another way t.o \nrefer to the elements of a nested col-lection in 00-SQL is by writing a pat,h expression that traverses \nthrough a collection-based dat.a member. Path expressions of this form crea.te implicit quantifiers over \neach nested collection in the patI1 expression. For exam-ple, the set of employees in a department is \nmodeled in our example witah the deptclass mcmhcr emps, defined a.s os-Set<empClass*>. The traversal \nthrough emps specified hy t for pat,fi expression d. emps. .no defines an implicit quantifier (I over \nd.emps, and the semantics of no is I. no. Just, as for explicit, quantifiers, the value of the implicit \nquant,ifier q is bound to the value of each instance of d.emps, meaning that the set, of values for Q \nchanges with cacti binding of d. For example, the fof-lowing quc~y selects the department name and employee \nnumbers of t IK enlpfoyees in department 1, yielding as ma.ny rvsuft t upfrs as there are employees in \ndepartment 1: select d.name, d.emps..no from Dept d where d.no = 1; Tflis is c~quivalollt, 1.0 t,hc following \nquery using an explicit quant,ificr: select d.name, e.rio from Dept d, (d.emps) e where d.no = 1; The \nfirst query can be seen as a short,hand form of the second. In general: a pa.th expression t,ha.t traverses \nthrough multiple embedded collections will generat.e muft.ipfe quantifiers, one for each embedded collection. \nHowever, if t,he exact same path expression appears multiple times in a query, it. generat.es only one \n(set of) quantifier(s). For exarr~pfc, consider t,he following query: select d.name, d.emps..no, d.emps..sal \nfrom Dept d where d.no = I; This quc ry has two path expressions that t,raverse the saner nc~stc~tl collrctiorr, \nd. emps. but they are actually t)wo IISCS of tflc same path expression. Thus, only one implicit (1uant \nificr is gcncrat#ed, a.nd it is shared by it,s t,wo uses. This query Ulerefore selects the employee numbers \na.nd safarics of ~IIF cmpfoyees in depart,ment 1. 3.2.3 Nestwl Collections as Subqueries As mentioned \nat. the beginning of this subsection, OO-SQL pcrnlits the use of a multi-valued member in place of a \nSQf,-92 subquery. For example, the following query fragnlc,nt specifies dcpa.rt,ments that have no employees: \nwhere not exists d.emps This fr;rgnlc llt is just a short hand for: where not exists (select f from (d.emps) \nf) OIIC inlport.allt point about 00-SQL s semantics for nested collrctions is tflab, in the context of \nthe not exists c~xarupfc abov?, d. emps evafuat,es to a set, of enl-ployees. ffowcver, in contexts other \nthan t,ha.t, of a sub-query, as we will soon see, d. emps evafuat,es to a pointer t,o bhe nested collection \nof employees. (This is an im-portant feature of 00-SQL when it, is used in embedded C++ programming, \nas will be discussed in more detail in Section 3.6.) This implies that multi-valued data mem-bers have \ndifferent. interpretations depending on where t.hey a.ppear in a query; they can either be interpreted \nas (i) a st t of elements, or (ii) a pointer to a set of el-emenis. fntcrpret.ation (i) is essentially \nan knnest of a nested set.. and provides a useful short. hand for sub-querirs. but we llavc found t,hat \ngeneralizing this seman-tics to all cask is undcsirabfe. 3.3 Null Valuas So deal are far, we wit,h queried \nhave seen complex through o how bject, the 00-SQL structllrcs. use of path c>xltlnds Complex rxprcssions \nSQ L92 &#38;bjccts and/or to nested quantifiers. Interest.ingly, path expressions a.lso have a kind \nof side effect on 00-SQL wit.11 respect to the handling of null values. In an SQL-based re-lational DBMS, \na column of any t.ype nlay assume a null value. SQL-92 handles null values by using a three-valued logic \nin evaluating query predicates. In contrast. the target OODB system for 00-SQL is ObjectStore, which \nis based on C++ and does not) support t,he not,ion of null values for its basic da,ta t.ypes. The only \nthing similar t,o a null value in Object.Store is a null pointer. Despite t,he a.bsence of null valurs \nfor dat,a types other than pointers, path expressions allow null values t,o creep back into the language \nas a possihlr result, value for any dat,a type. This is because WC llavc> adopted the ap-proach taken \nin GEM [Zan83] for handling paths t,liat, traverse through null point.crs if il ['ill COll- IIcxprcssion \ntains a null point.er that, is not t llr> pa1 II s leaf, it crcat.rs a null-valued result,. For cxamplc, \na I)illding for e in ei-ther e.dept . . no = I or e.dept . .no <> 1 will not be included in the result, \nwhen its dept is a null pointer. Given this semant,ic extension, 00SQL ha.ndlos nulls in predicates just \nas SQL-92 dots (i.t., bindings for vari-ables where the specified condition evaluates t,o null are by \ndefault not included in t(hc result).  3.4 Other 00 Features 00-SQL includes feat.ures for tloalit~g \nwit 11 inhorit,ance (e.g., querying collections where f hr> clrn~c~~ts can be of a type or any of it,s \nsubtypes) and with ( ++ Illcthods. 3.4.1 Inheritance Multiple inherit,ance is support r>d in ( ++ and \nin t.he ObjectStore dat,a model. Following the C++ conven-tion, inherited members can be spccificd in \n00-SQL ei-ther implicit,ly, by merely giving the column name of t,he inheritsed member, or explicit.ly, \nby prefixing such mem-bers with the class name where t,hey are defined (fol-lowed by the character pair \n:: ). In t.he example schema of Figure 1, t,he member name is inherit,ed from the class person by the \nempClass class. To reference this member in a query using a. quantifier over empclass, the prefix person: \n: may be added.4 For example, the following query selects the numbers and names of all employees: select \ne.no, e.person::name from Emp e; 3.4.2 Methods In 00-SQL. mct~hods can appar anywhere a dat.a member \ncan appear, including pa1 II c,xprc,ssions. If t IIP met,hod has a.rguments, t hc rnrt Id II~IIIC is \nfollowed by a parent.hesized a,rgument~ list %lortovc,r, t IIC argunlent,s themselves can be expressions, \npossibly including other method calls. Following t,hc (Y++ convcnt,ion, m&#38;hods with no argulnents \nare followed by opening and closing parentheses. As an example of the USC of methods in 4Due to a limitation \nin the current. implrment,at.ion of OO- SQL, this prefix is act.nally not optioual al. the moment. 00-SQL. \nconsitlcr t IIC following query, which selects the birl Iltlil~of c~tll~~loycY~ ilumber 1: select e.birth. \n.display() from Emp e where e.no = I; Recall the schema. for empclass shown in Figure 1. The data member \nbirth is of type Date, which is an embed-ded class inst,ance. The method display returns dates as format,ted \ncharacter strings.  3.5 Type Casting One last. query-related feat-ure of 00-SQL that is worthy of ment,ion, \nsince it, is a rather unusual feature, is the inclusion of support for iype casding. Because 00SQL s \ntarget systcnl is ObjectStore, and because we wanted 00-X)1, to be as broadly applicable as possible \nfor use in qurryillg ObjectStore dat,abases, we decided t,o include this fc,at ui-c>: C asl ing arises \nin 00SQL because of the fact that ObjrctStorc scholnas can use the generic pointer type void* to rc,f(xr \nto any t,ype of pointer in the system. Fur-t.hcrmorc>, whilr t trc clclnent types for multivalued data \nmembers arr usually specified in the schema using tem-plat.es, r.g.> os-Set<empClass*>, it is also possible \nto use non-parametric types for a collection; e.g., a collec-tion C~II be declared simply as os-set. \nWhile templates are obviously much clea.ner due t.o the type informa-tion that they provide at the schema \nlevel, the use of non-parametric collect,ion t.ypes has t,he advantage of re-ducing tllr size of the \nexecutable application programs (due to tllc> way that t.emplates are implemented in most C++ rotllpilcrs). \nFor bett,er or for worse, ObjectStore applical ioIl-writc>rs do use non-parametric types in some cases. \na11d 00-SQL thus provides special support for qucxryirig t l~( tn. In ord(>r lo correctly access and \nmanipulate the ele-mrnts of a collrction, 00-SQL needs t,o somehow obtain t,lie type, of its clcmcnt,s. \nNormally, 00-SQL obtains this inforltlation using an ObjectSt,ore interface called the Mcta Object. Prot,ocol \n[Obj94] (MOP) for this pur-pose. The M 0 F supports t,he run-time extraction of type informat.ion about \ninstances of collections. For non-paramet,ric collect,ions, however, this informat.ion is not, available. \nThe 00-SQL cast, operator can be used t,o specify t hc tvpe of a. member within t,he body of a query, \nthereby providing the necessary type information in such cases. 00-SQL support,s casting (only) for members \nof type void or a noll-parametric collection t,ypes. The cast opcxrator follows the column to be altered \nand spec-ifics t IIC result type in square brackets. As an example of casting. (hr following query uses \ncasting to indicate that lh(, Iyr)c of t.he data member pt2dept in Figure is aclu;lIIy deptClass* rather \nthan void*: select e.no, e.pt2dept[deptClass*]. .no from Emp e ; Obviously, casting is a fca.ture which \nmust, be used care-fully, and only W~IC,II absolutely necessary.  3.6 Navigational Support for C++ As \nmrntioncd rarlier, the design of 00-SQL was influ- enced hot h by the rich data model of ObjectStore \nand by the fact that one of 00-SQL s primary uses was to be a richer query facility, compared to ObjectStore \ns na-tive query langua.ge, for use wit.hin C++ programs. This subsection of the paper briefly covers \nasp&#38;s of OO-SQL that were motivated by it,s role as an embedded query language for C++ a.pplicat \nions. (Srct ion 5 will say more about the C++ embedding ibself, and will a.lso discuss safety issues \nraised by the feat.urcs described here.) 3.6.1 Addresses in Query Rmults 00-SQL allows queries t.o ret.ricve \nthe addresses of the objects/subobjects conl,aincd in an ObjectStore database. This is useful in t#hc \ncont,rxt of embedded C++ programs, because such a.ddresscs can serve as starting points for C++ navigation. \nAs a simple example, the fol-lowing 00-SQL query ret,rieves a. pointer to the birth data member, which \nis an embedded object. of t,ype Date, of employee 1: select e.birth from Emp e where e.no = 1; As mentioned \nearlier, the same is possible with set,s. For example, to get. a pointer t,o 1.11~ sc t of c~t~ployce \n0bject.s in department 1, the following 00-SQL query could be embedded in an ObjectStore application \nprogram: select d.emps from Dept d where d.no = 1; Clearly, such retrieved pointer values are of little \nor no interest for an interactive comma.nd line interface. How-ever, such pointers are valid in a C++ \napplication pro-gram s address space, so they can be extremely useful in that context. 3.6.2 Addresses \nas Collections Allowing queries to retrieve addresses enables C++ programs to formulate queries and t)hen \nnavigate pro-grammatically from the resull.ing object.(s). Ad-dresses are also useful as query inplrts \nfor certain kinds of applicat,ions. In part.icular, if an application queries/na.viga.tes its way t,o \nan objrct l.liat, itself cont.ains a collection, it might then need to qurry the contents of that collect,ion. \nSince this is a ncsi.cd collect.ion, such a query would be be rooted at a part.icular object ra.ther \nthan at a named, top-level collcct,ion. (N-SQL supports such applications by a.llowing a hcxadccimal \naddress to be used in place of a root collect.ion name. To build a tool like a database browser that \nalso supports queries [CHMW95], this feature is very useful. As an example of its use, the following \nquery declares t.he quantifier e as ranging over the collection of elclnent,s of t.ype empclass locat.ed \nat. t,he specified address in the database: select * from 0x40010000[os~Set<empClass*>*] e; Hexadecimal \naddresses must st.ari wit.11 Ox , and arc an- other example of a feature t.hat SIIOIII~ bc rrscd rarcfully \nand sparingly.  4 SQL Views As described in the Introduction, 00-SQL includes an OODB view facility \nfor defining views of ObjectStore databases. Using this facility, it is possible to define a create view \ntype VTEmp on empClass (no, name, sal, deptno) as ( . select e.no, e.person::name, e.sal, e.dept..no \n from this e create view VEmp using VTEmp on Emp Figure 2: Building flat views of object data flat (relational) \nview of an ObjectStore database; t,his is useful for ena.bling relational tools to access data re-siding \nin Ol),jtct,Store. We have used this approach to provide rrlatlonal access to ObjectStore dat,a by writ-ing \nan ODIN: [Mic92] driver that exports flat views to ODB( -cnat)lr>d relational DBMS t,ools. In addition, \none can also tl(,fine att.ernat.ive object-oriented views of an Objrct Stow databasc~ via this facility; \nsuch views are in some rc>spc,cts more complex to handle than relational views. WP discuss 00-SQL s support \nfor both kinds of views in t.his section. 4.1 R.elational Views of Object Data Similar to what relational \nviews provide, an 00-SQL view implement,s an intensional class (i.e., view) which is based upon one or \nmore extensional (i.e., C-t+) classes and/or views. In ObjectStore, several collections can be defined \nover the same class, and these collections need not be disjoint. The 00-SQL view facility respects this \ndistinct ion bel,ween cla.ss and collection. 00-SQL pro-vides t.hc not,ion of a. Gew hype that can be \ndefined and then used t.o create views of multiple collections. The create view type command of 00-SQL \ndefines a new view tvp( . i\\lld the create view command defines an ac-tual VIPW (virtual collect ion) \nbased on a given view type. As an cxalIIpI(~, the sc>qucnce of 00-SQL commands that dcfinc>s 111~ virlual \ncollc:ct,ion VEmp is given in Figure 2. I hc kc>yword this is used in the body of the view type to identify \nt.he specific object instance to which the type is att.arhcad. The view type a.bove hides a number of \nthe members of empclass; it also convert,s the deptclass pointer int,o a. department number via an implicit \njoin. The using key word in VEmp using VTEmp is used to ass0ciat.e a view with a view type, thereby defining \nthe virtual rollect.ion VEmp over the root collection Emp. This relational view can now be used in queries, \nsuch as thr following query which selects the employees in depart nlrni. 1: select * from VEmp e where \ne.deptno = Since Ol).jc~rt.S\\,orr dai.abases consist of user-defined col-lect.ions rat hrr than t*ype \nextents, there is no guarantee that, t tic data of interest. to a relational user will be avail-able \nt.hroug\\r a top-level collection. In such cases, OO-SQL views can be used to simultaneously flatten and \ne1evat.e such data to make it available in a (virtual) top-level collect,ion. create view type VTEmp \non 6mpClass (no int, name character, sal int, dept VTDept*) as select e.no, e.person::name, e.sal, e \n. dept from this e where e.sal > 1000 1 create view VEmp using VTEmp on Emp create view type VTDept on \ndeptclass (no int, name character , emps os-Collection<VTEmp*>) as ( select d.no, d.name, d.emps from \nthis d create view VDept using VTDept on Dept Figure 3: OODBMS views wi1.h tllc~mbcrs based on view types \n 4.2 Object Views of Object Data 00-SQL views can also support, complex, object-oriented views of ObjectStore \ndatabases. In particu-lar, 00-SQL views can have reference-and collection-valued members that are based \non other views instead of just on C++ class t#ypes. As a simple example of this, consider the views presented \nin Figure 3. The member dept of the view VTEmp is a view of t,ype VTDept; simi-larly, t#he member emps \nof t.1~ view VTDept is a view of type VTEmps. Together, t,he views itr the figure provide a closed, alternative \ntries scltcn?n for dealing with the employee/depa.rtmcnt, da.t.ahasc. Only employees wit.li salaries \nof over 1000 appear in t hr view. and ouly some of t,heir attributes are visible in t I)(> virw. I his \nis true of both t,he virtual employee collect ioll VTEmp and t,bc emps collection of each department \nas wrll. Simila.rly, only some of the at.tributes of each department are visible, regardless of whether \nthey are accessed via t,hc VTDept collection or an employee s dept pointer. This kind of view schema \nis similar 1.0 the i+as proposed, e.g., in [HZSO]. A more complete t.rca.t.nlcnt, of 00-SQL s ob-ject \nview support, as well as its relationship to other object view proposals, will be provided in a forthcoming \npaper [CK95].  5 00-SQL and C++ Applications One of the primary motivations for itupl( tn( ut ing OO- \nSQL was t,o provide a. richer qllcry facility for C++ applications t,o use in accessing Ot).jrcl.Storc \ndat.aba.ses. Querying from C++ app1ica.t ion prograIns is support,ed through the 00-SQL Ca.ll Level luterface \n(CLI). This section describes the 00-SQL CLI, including its call in-terface and t,he way t,hat its query \nresults are returned to C++ applicat.ions. Cert ain issues related to the bind-ing of (I++ rnet,hods \nwith the 00-SQL engine are also briefly discussed. 5.1 The 00-SQL CL1 I hc 00-SOI, (rl,l is currently \nvery simple. C++ ap-plic;ttious iuvokc the 00-SQL query engine using the following furlct.ion: os-collection \n*oosql-exec (OS-database *dbi, char *query) ; The fu~~c~ion takes t.wo arguments; the first is the dalabasc \nt.o be queried, and the second is simply the query it.sclf. Paramet.ers can be added to the query us-ing \nC library string subst,itut,ion routines. The function r&#38;urns a collcct,ion of tuples, each of which \nis an in-stance of a system defined type called qes-tuple, that results fro111 (>xcrutiug the query. \nIn brief, each instance of the type qes-tuple is a.n array of constant values. I hc~ valuc~ arc also \nof a system-defined type, called qes-cnst, RII~ can cout.ain data of one of five primitive types: int, \nfloat, double, char *, and void *. At the 00SQL CL1 level, any expression in an 00-SQL projection clause \nresolves to a constant of one of these types. Fiually, the result collection for the oosql-exec call \nis an ordered collection since an ordering of the re-sult, t.uples can be specified using the SQL-92 \norder by clause. A pr0gra.m fragment tha.t illustrates the usage of the 00-SQL CL1 a.nd its result types \nis presented in Fig-ure 4. This program fragment accepts an 00-SQL query, cont.aincd in t,he character \nstring buffer query-string, and prints out the resulting tuples on the terminal screen. I hc Objcct,Store \ncursor c is used to iterate over each cleurc~ut of the result collection. For each column of each ~upl( \n> <null> is printed to signal null values, and ot Ilmwisr t.ho value that is printed depends upon the \n1ypr of the coust ant.. I hc rc-atl(>r has IIO doubt observed that the 00-SQL CL1 is currcnl.ly rather \nprimitive, as are the address-related query features of 00-SQL that were described in Section 3.F. 1%~ \nsimplicity of the CL1 is intentional. It, is silnplr, yet sufficient.ly powerful to get the job done, \nand is pa.rt.icularly useful for those ObjectStore applications where t,be data types of the objects \nin the databa.se arc not known a priori (e.g., applications like [CHMW95]). 0 ur int.ention is for this \nCL1 to provide t.he necessary primit,ives for higher-level (and safer) ap-plicat.ion iutcrfaccs. For \nexample, the current CL1 would provide ii solid basis for implementing an embedded OO-SQL prrc.olnpilrr \nfor C++, thereby providing a higher-Icvel. type-siift> intrrfiict for C++ application program-mers who \nII;~vc> a. priori knowledge of the data types of interest,. Silllilarly. our ODBC driver uses the CL1 \nand t,uple l.ypc>s, but, presents anot,her (standard) set of APIs to usc rs. rtuples = oosql-exec (db, \nquery-string); os-cursor c (*rtuples); for (tup=(qes-tuple*)c.first(); c.moreO; tup=(qes-tuple*)c.nextO) \nC for (i=O; i < tup->nelemO; i++) { if ((*tup) [il ->isNull) tout << <null> ; else switch ((*tup) [il->constType) \n{ case INTEGER: tout << (*tup) Gil->i; break ; . . . 1 tout <<  ; 1 tout << endl; ) Figure 4: An int*eract.ivc \nSQJ, shell  5.2 Methods R.&#38;sited As discussed earlier, 00-SQL includes support for the invocation \nof C++ methods wit.hin queries. Because of the nature of ObjectStore, t,hc cotle t.hat implement~s a \nmethod is statically linked t,o lhc SQL engine. The method code is specified in bhe link st.cp for an \n00-SQL C++ applicat,ion as a .o file t.o be linked with the ap-plicat,ion code. The method musl also \nho registered with the 00-SQL engine via. a syst em call t.hat. gives t,he ex-ternal name of the met,hod \nand a point.or t.o t,hc met hod code. Method arguments for n~cthotls (0 hr registered with 00-SQL must \nbe cxprcssious t11at rcsolvc to one of five types: long, float, double. char *? or pointer. C++ resolves \nmethod selrcl.ion iIt compile t,ime, mak-ing run-time method invoca.tion mcrcl2; a procedure call (except \nfor virtual functions, which Include a point,er dereference as well). In contra.st., SQL queries are \nsub-mitted and evaluated dynamically at. run-t.ime, making it impossible for the SQL engine to use t.he \nbuilt-in method selection features of C++. Inst,ead, t,he SQL engine must itself perform method selection \naccording t,o the t#ype of the receiver, following C++ convenlions. In brief, the SQL engine must simulate \nthe method selection process of C++ in order t o provide the correct semantics for methods appea.ring \nin queries.  6 00-SQL on ObjectStore This section describes the current. itnplcment.at.ion of 00-SQL \non top of t(he ObjcctSt.orc 0OJ)B system. In addition, we are current,ly poriirlg 00-SQJ, t,o run on \nother plat,forms. Figure 5 prcsrt1i.s 1.11~ franlcwork for the implementation, which supports 1lIf: itltcgration \nof the 00-SQL engine with users OODl3 applications. The application issues SQL queritls through the Call \nLevel Interface (CLI) described in t.hc prrvious se&#38;on. The query is then transla.ted into an rxecut \nahle plan. Once translated, the plan is passed to the Query Evaluation Subsystem (QES), which runs it \nagainst, t.he database I Application ICollection Of tuples Data Manager (ObjectStore) I:igurc> 5: SQL \naccess for OODB applications and rot.urns an o&#38;red collection of tuples to the appli-cat,ion. Qurry \nresults can include pointers to objects in the dat.abasc; these pointers a.re simply virtual memory addresses \nin a.n ObjecbStore application [OHMS92], so t,hey must. he valid point.ers in the application program \ns workspace iIJ order to be useable for further C++ based navigat iou and dat.a manipulation. For this \nreason, the 00-SQL qurry processing system is linked to the user s applical ion. I hc rcttlaindor of \nthis sect ion describes the key com-ponent.s of t ho itll1)1f~I~~entat,ion depicted in Figure 5. To bettc,r \nunderstand the motivation for the approach t,aken, recall that, Ob.jectSt,ore (OS) queries are essen-tially \niw extension of t.he C++ expression syntax; they provide Ot)Jcct,St.ore programmers with the ability \nto declarat,ivrly subset, a. given set, of object,s, retturning a set of pointers t,hat refer to those \nobjects that satisfy a programmer-provided predicate. Thus, OS queries per-form a function similar to \nthat of a single t,able filt,er in relational systems; the OS query processor uses in-dices for efficiency \nif they are available. OS queries are roughly as powerful as 00-SQL would be if its from clause was only \npermit ted to mention one top-level col-lection, it.s select list simply returned pointers to ob- ject,s \nsclcctcd from that collection, and its grouping, ag- grc.gat.ion, arlcl support. for (most) methods were \nall dis- abled. III cor~~r;lst.. (W-SQL offers features that go well beyond sul)sc>t,t.itlg a collect,ion; \nthese include projection, join, grolll)iq aud aggregation, a much wider range of twl l~otls. a11(1 oxprcssiolls \nin the select list,. The basic approacll lakcn for t.llr 00-SQL implementat,ion is to use OS qucrics \nwherr possible, to take advantage of the OS query processor s use of indices, supplementing t,hem with \nlhc additional mechanisms needed to support the rest of 00-SQL. This is done because the interfaces to \nObject Starr indexes are not ext,ernalized; they are only accessible t.hrough ObjectStore queries. We \ndescribe the approach in more detail now, describing the 00-SQL query plan language (and interpreter) \nand the 00-SQL query optimizer. 6.1 00-SQL Query Plans To understand the 00-SQL query processing implemcn-tation, \nthe best place to begin is wit.11 t,hr out.put of the query optimizer, i.e., query rxccution plans. OO-SQL \nquery plans are produced in 1 hc form of programs in a small procedural larig~~agf~ ; tlif>y arc siniilar, \nirl structure, to C++ programs wit II rlllbcddcd Object,-Store queries. The advanta.gcs of having at] \nact,ual plan language, complete with a synt.ax, ra.t.licr t.tian a set of main memory plan dat,a struct.urcs, \ninclude: The plan language can be used as a prot.ocol between the query optimizer and t,hc query run-time. \nThis provides a clean separat,ion bet wccn these two func-tions. The plan language is very useful as \nan explain ut,il-ity. For system development,. t.trc pt;111 la~~guage can be used to isolate bugs eit,hrr \nto qur>ry opt.irnixat ion or to the query run-tinle syslc~n. HIIS is facitit.af.cd if the plan is in \nhuman rcadabtc form. The plans can potentially be sad as t.cxt and t.hen submitted for execut.ion without \nt IIC ueed for query compilation and optimizat,ion. There are five types of statements t.hat can appear \nin an 00-SQL query blan: . _ . for all -This statement is an iterator that binds a quantifier qi to each \nelement of a collection, and is used to process all elements of the source collection. nssignmenl -This \nstat,ement. applies a. predicate t.o a collection C to obt,ain a subset si of C, and cor-responds roughly \nto the OS qut ry stat,ement, of Ob-jectStore s C++ based da.t a 111anipula( ion la.nguage. The predicate \nis applied using an OS query, if possi- ble, in order t.o take advant age of 0t)jrctStorc s query processor \nand its use of avaitaI)t(\\ indirrs. Ot.hcrwise, the predicat,e is applied usilig it Qurry I:valuat.ion \nSubsystem (&#38;ES) fili.er l.hat is int crprett>d (out,sidc of Object,St,ore) by 00-SQL s rrrnt.iine \nsyst,em. QES filters are needed when Objcct,Storc querirs cannot apply a. predicate; e.g., a. query with \nan SQL like predicate would have to make use of a QES filt,er. To distinguish these two casrs in query \nplans, OS queries a.ppea.r between [:* and :I , whereas QES filt,ers are bracket,ed with { : and :} . \nAs an ex-ample, the sa.mplc query plan shown in Figure 6 uses OS queries. Assignment stat.emcn&#38; arr \nalso usrd for t hc following set oriented operat,ions: 51n [GMP95]. a similar plan lang~~agr is dcscrib4 \nfor sup-porting pipelined and set-orientc,d si ralr+s for path qnrries. Our language, which was was intlcprntl~n11y \ndeveloped, ad-dresses further issues such as grouping, aggregation, dupli-cate elimination, and subqueries. \nnil -Assigns the set of tuples sd t,o the set of t.uples sj, possibly sorting the set of tuples. In t.he \nexample given in Figure 6, the set of tuples in set. .sa is assigned to the result set SO. (After t hr \nquery plan has finished running, the system ~~xpcct.s t.o find t.he result of the query in SO.) flrstrllct \nAssigns t,he set of distinct tuples in si to it set sj 1 thcr~by eliminating duplicates. /1//707/ Mf~rgc~s \n1.~0 sets of tuples si and sj and assiglis 1tic distinct set of tuples resulting from I IIV ttlr\\rgc \n1,o sk If vnlon all is specified instead of union, the dupticat,e elimination step is omitted. if This \nst.atemcnt, is used to evaluate existential subqucrics that appear in 00-SQL queries. If st.at.rmet1t.s \nare complex and contain other state-mcnts, such as exists. This complexity is due to the fact, t,hat. \nt.he exist,ential predicate can involve multi-ple quantifiers (e.g., when two or more collections are \ngiven in the from clause of the subquery). If state-mcnts have a then clause that is performed unless \nttic conflit ion in the if clause evaluates to false. rr7,st.s I hc rxist.s st.atement is similar to \nthe right, hand sid(> of illI assignment statement, but it is used to cvaluatc an existential predicate \n(i.e., it is used when t Iif: expression returns true or false rather than a set of pointers). Like an \nassignment statement, an exist.s st at.ement involves only single quantifier pred-icates. tampand prlnf \n~ These statements are used t,o build sels of buples (as opposed to sets of pointers t,o ob-jects). Temp \nbuilds a set of intermediate results for grouping and aggregation, whereas print forms the result. tuples \nfor the query and includes a set of la-bets for the result.ing column names. (These labels arc st.ring \nliterals, between double quotes, and give t.hc cotumrl headings for displaying the results.) Print cont.aills \na uurnber of expressions equal to the number of clf~nlc~u1 s in t,hc projection clause of the 00-SQL \nfjiifv-y. I h~r st atcnicnts can have an optional order by cl;lt~sc~ III~I givc>s t.he order in which \nt,uples should appear: this ordr,ring is determined by the grouping CO~IIIIIIIS for Irlllp sets and by \nthe 00-SQL order by cla\\~s~~ for print, sets. In the example in Figure 6. the print. stat,enlcnt. is \nused to insert tuples in set sz. 0 gro7,p This st alement comput,es aggregate func-tions used in projcct,ion \nor having clauses, and builds a result. set, sj from a t,emp set, si over which grouping and aggregatjion \nare to be performed. The grouping colun~r~s are given in t,he order by clause. Sorting may include an \nextra column in cases where dis-t.inct is used in one of the aggregate functions. As an rxamptc of t.his \nlast point, the function count (distinct names) requires that) sorting be orga-nix4 OII names in addit,ion \nto the grouping columns; ttiis fmsurcs that tuples wit,h identical names are contigllous t,o facilitate \nthe task of computing the duplicaicfrec aggrrgate value. It, worrttl not be practical to give one sample \nquery that illustrates all of t,he statements described above, Figure 6: Pta.n grncrat ion select el.no, \ne2.no from Emp el, Emp e2 where el.birth..year = e2.birth..year; Query Plan: begin plan empClass* ql \n; empClass* q2 ; begin for all ql in Emp do begin sl = empClass* Emp 1: ((empClass*) ql)->birth.year \n== birth.year:] ; for all q2 in sl do begin s2 = print ( no ((empClass*) ql)->no, no ((empClass*) q2)->no) \n; end end SO = all ~2; end end plan as it would be a complex 00-SQL query with joins: subqueries, grouping \nand aggrrgat ion, and a. ha.ving clause. Since we do not, have enough space to show each statement separately, \nwe have shown an example of a typical join query in Figure 6 fo illust,rate the general flavor of the \nplan language. The cxampte query shown selects pa.irs of employees who wert born in t,he same year. The \nquery plan starts with lhc declaration of the two quantifiers, q1 and q2, I.hat. part icipak in t.he \nquery. The plan computes the rcsutt of 1.he join query using a pair of nested loops (i.e., by doing a \nncst.cd loop join) over the collection of employees Emp. J:or cacti employee 41, the matching set of \nempto\\;(~(~s s1 is found using a.11 ObjectStore query. Given this plan language, the query evaluat.ion \nsub-syst,em (QES) works by interpreting query plans -pro-grams produced by the query optimizer and expressed \nin this language -on top of the ObjectStore OODB sys-tem. To execute a query plan, QES begins by doing \na pre-execution analysis of the plan in order t.o make the query s execution as efficient as possible. \nThis analy-sis involves using the ObjectSt,ore Met a Object. Prot.ocot (MOP) [Obj94] to gat.her t,he \no%cts of dat.a members in C++ data struct,ures and pre-compiling the ObjectSt,ore queries that, will \nbe used during exrcut,ion. The query plan is then evaluated using OS queries where possible and OS cursors \nfor looping. Wtlrn sorting is rrquircd, it is done by building a temporary Ol).jc>ci,Siore index for \nuse in an ordered iteration. ( l his works well as long as t,he data to be sorted fits in t.ho ava.itable \nmemory, which is the current) operating assumption for 00-SQL query results. Future work is needed to \nbet I.cr handle queries over very large data sets, which could lead to thrashing under t,he current 00-SQL \ninlplcmctll.ation.) 476 The job of I IW 00-SQL query optimizer is to convert a parsc~l 00-SQL query \ninto a query plan expressed in t,hc ~IRII tilllguage t11at was just described. An inter-medintr rrprcscnt.ation \nca.lled OQGM (Object QGM), whicl~ is an adapt.at.iorl of the Query Graph Model of [PHHD L], is used t.o \nfacilitate the query translation and optimization process. The first step in query optimiza-tion is query \nrewrit.e; in t,he current 00-SQL implemen-tation, t.he only type of rewrite performed on the query is \na select rn~r,qe rewrite [PHH92] that merges the query with any views that it involves in order to produce \na single query t.hat only refers to extensional data. (i.e., to stored collect ions inst.ead of views). \nAfter this st,ep, the 00-SQL query optimizer tries to convert the (possibly rewrit.1 en) qurry into an \nefficient plan for computing its answer srt. This job is made somewhat. difficult by the fact that t \nIIV 00SQJ, implementation is outside of Ob-jectStorc>. i.c., t.hat. hot h the optimizer and the runtime \nsyst.cni arc sinlply Ot)jrct,Store applications. The fact that 00-SQL is an ObjectStore application has \nscwwt i111p1icat ~OIK. Traditional relational query op-t,imizcrs (cud to make heavy use of statistical \ninformation (e.g., index rardina1it.y for predicate selectivity estima-t.ion), and ftwy use cost, functions \nto model the detailed behavior of t.he query execution system. In contrast, such statistics are not available \nin our setting. Neither are cost. functions, as there is no way to ask ObjectStore what. t,ht: cost of \nexecut,ing an OS query will be; how-ever, the OhjcctStore MOP does allow an application to inquire about. \nthe presence of ordered and unordered in-dexcs over cottrlct.ions. Thus, the current 00-SQL imple-ment \na1 ~OII IJWS a heurist~ic approach to optimizing OO-SQL quc+s. ( ost#-wise, it, is assumed t,hat OS queries \nwilt b(, ttww dlicicr~r t than QES filters when they are ap-pticabtc, c~sp(~riatty when an appropriate \nindex is avail-able; OS quc,rics are t.hus favored over &#38;ES filters. In addition, SOIIIC reordering \nof query plan steps is done in hopes of maximizing t.he chances of an OS query being able t.o ruse an \nindex and of minimizing the cardinatities of the collections being looped over. To handle 00-SQL join \nqueries, which are imple-mented using nested loops, the query optimizer uses t,he following heurist.ic: \nGiven two independent, quant,ifiers ql and q2, and their joining columns ql.cl = qz.cz, if cl is an indexed \ncolumn, t,hen the nested loops will be or-dered so t.hat quantifier q1 is the inner quantifier of the \nnest,ed loop join. Otherwise, quantifier q2 wilt be chosen as t tic, in tl( r quantifier. In other words, \nthe 00-SQL op-t,imizcr alwaj-s (rips t.o a.rrange for a quantifier with an indcxcd join column t.o be \nthe inner collection of a nested loop join; this provitks indexed access t,o the matching tuptrs. iIls(( \nad of rtquiring repeated scans of the inner cottt!rlioii. Q~~;lt~~iti~rs over ncst.ed collections were \ndiscussed in Sect.iori 3.2. I hcsr quantifiers introduce a partial or-dering atllong quant.ifiers that \nmust be preserved in the Nestrd quant.ifiers introduce a partial ordering among quantifiers, and will \nbe discussed separately. query plan in order to produce correct resu1t.s. For ex-ample, the following \n00-SQL from clause declares two quantifiers, one of which is a nested quantifier: from Dept d, (d.emps) \ne The query plan fragment associakd wit,11 this query frag-ment might be t,he following: for all d in \nDept do begin for all e in d->emps do begin Clearly, the qua.nbifier e must app( ar inside t.he scope \nof the loop over d. The 00-SQL query opt imizrr s reordering heuristics ensurr that tl~p~~~drni qua.ntifiers \nalways appea.r after the quant.ificrs upon which they de-pend. The general algorit,hm for processing \na set, of conjunct,s (and-ed components of t,hc query predicate) cl,. . . I c, appearing in an 00-SQL \nquery is as follows. Before generat,ing the for all loop t,liat. will it,crat.e over each element in \none of the query s soIIrcc collections E, the collection E can be subsetted first by applying one or \nmore conj1rnct.s cj in t-he set. of ronjunct.s t.hat, have not. yet been applied. Each conjunct ci is \nf,xamined t,o deter- mine if the qua.ntifiers that, parl.icipatr in r; arc known. (Known quantifiers \nare t,liosc that. IlilVrbc~r~ previously generated in the p1a.n in addii ion to I IIC qoar~t ilicr /; \nbe- ing examined.) If all quant.ificrs t Itat participak in ci are known, the predicat,e is added t,o \nbhc> set, of conjuncl,s to be applied against the collect ion I: over which qi ranges. When all applicable \nconjuncts for t/i have been added, the resulting predicate p is applied and the subsetted collect,ion \nis assigned to si. The quantifier qi that previ-ously ranged over E now ranges over .si, so t,he for-loop \nthat will be produced for qi will not, range over E, but will range instead over the set, of instances \nof si that satisfy the predicate p over E. This general algorithm is made clear in the example query \nand corresponding query plan given in Figure 7. Notice how Emp is subsetted using an ObjectSlore query \nbefore being looped over, and likewise for Emp-codes in the inner loop. This is because the quantifier \ne is sc-lected as the first quantifier. and tllcx t.hroe conjuncts in the query are t,hen exa.mincd t.o \ntl(x(crnliur which are ap-plicable. The first conjuncl, is I Ilc only one applicable initAly, as the \nother conjuncts i~~volvc~ 111c quant,ificr c which is not, yet, known. I h wllwt ion SI is used t,o subset, \nEmp. Once quant,ificrs e and c are both known, all other conjunctas can he applied in t,lle inner OS \nquery over Emp-codes. The previous algorit,hrn can be rrfined to further im- prove the query s performance. \nThis involves applying predicates as soon as possible, a.nd is achieved using more temporary structures. \nBefore a for-loop is generat.ed, for each quantifier qi t,hat has not brc>n processed and for It is important \nto realize t.lial since OhjeclSlore collec-tions are not type extents. il. is not possil)lr 1.0 rewrite \nthis query [CD921 to il.erate over thr c~xlcr11 of rmployees first; there is no semantic equivalcnl lo \na lypc cxlcnt in the Ob-jectstore data model. This limits t tic, usefulness of Objcct.-Store s inverse \nrelationships when it c omcs to using t.hem to aid in query optimization. select e.no from Emp e, Emp-codes \nc where e.sal < 10 and e.emp-code = c.codes and c.desc = staff sl = Emp [: sal < 10 :I for all e in sl \ndo begin s2 = Emp-codes c: e->emp-code == codes &#38;&#38; strcmp (desc, staff ) == 0 :I for all c in \ns2 do begin . . . Figure 7: Query plan generation sl = Emp [: sal < 10 :I s2 = Emp-codes [: strcmp (desc, \nstaff ) == 0 :I for all e in sl do begin 93 = s2 [: e->emp-code == codes :I for all c in s3 do begin \n. . . Figure 8: Enhanced query plan generation each conjunct, ci t,hat, has not been applied, the conjunct \nci is exa.mined to determine if the quantifiers that par-ticipat.e in ci a.re known. If all quantifiers \nthat partici-pate in ci are known, the predicat,e is applied against the collect,ion si of instances \nover which qi ranges, and the resulting collect,ion is assigned to the new temporary sj. The quantifier \nq, which previously ranged over si now ranges over sj. This enhancement is demonstrated in Figure 8, \nwhich further refines the query plan of Figure 7. The corljllnct c, thab subsets the collection Emp-codes \nby srlect irlg t hr staff code is now applied before the quant ilic>r e is known, and should reduce the \nnumber of inst anws t 11at nocd lo he examined in the scope of the  loop owr .sI Thtx fragrrl~~rltirlg \nof the set of conjuncts Cj, . , Ck -where quarlt ifirr qj is in each conjunct -into multiple OS qucrics \nor QES filters, as detailed above, is per-formed ~~,ltss q, part,icipates in a join and there is an index \non t,hc joining column of qi. The intuition be-hind this cxcept,ion is that, we don t, want to break \nan OS query that will be repeatedly applied in a join loop int,o mull iplr OS queries if doing so will \nend up convert-ing accrws from an indexed scan into a sequential scan. I.e.. oricc an OS query is over \na temporary collection Sir t,he irld(xxc:s that were available over the root, collection E froiu which \ns, was derived are no longer available. For (~xar~~plc, if thcrr is an index over the codes column of \ncollcc~io~~ Emp-codes, the transformation described in Figure 8 wo~~ltl not be applied, and the query \nplan given in Figurr 7 would be used instead.  7 Performance Evaluation To evaluate t,he performance \nof t.he initial 00-SQL im-plementation, we have run a series of performance exper-iment,s using the object \nquery portion of t.he 007 bench-mark [CDN93, CDKN94]. Th e ex I -I )eriments compare the execution times \nfor 00-SQL versions of the t.est,ed 007 queries to those of hand-optimized C++ programs (com-posed of \nOS queries and it.crat.ious using OS cursors) for the same 007 queries. The results. which are intended \nto highlight the performance of 00-SQL (as opposed to that of the underlying OODI~ sysic~11). are presented \nas rat,ios of 00-SQL elapsed t inlcs to I hc corrcspondiug C++ elapsed t.imes. The performance expcrinlcxn1 \ns w< r(\\ co~~d~lcfcd OH an IBM RS/SOOO 560 workst.at ion wit II 256 mcgabyt.es of main memory, running \nAIX 3.2.5. and Object.Storc 3.1 for AIX/xlC. The queries I estcd wcr( 007 queries l-5 and 8; specifications \nof t,hr quf rif s can be found in [CDN93]. Tl w p er, forma,nce results arc shown in I a.ble 1 for the \nsmall and medium 007 dal.abases. Three vari-ants of these da&#38;bases were usc~l: 3 connect,ions per \natomic part,, 6 connections per alomic part. and 9 con-nections per at,omic part. I 1ic iiunibcrs sliowii \nare t.he result of performing mulliple runs of fxf:h t-crsion (OO-SQL vs. C++ program) of CYICII qll(*ry \na11t1 then report-ing the best, number for each vrGoll; (Ilis was donr: be-cause we were nof, a.blc f.0 \ngain RCCf SS lo a cotnplctely isolated machine for doing tht> runs 007 DB Ql 92 Q3 Q4 Q:, Q8 Small 3 \n1.46 1.08 1.19 I .3 3 0.97 1.13 Small Small 6 9 1.44 1.36 1.07 1.13 1.10 1.12 1.37 1.23 1.09 1.03 1.09 \n1.06 Medium 3 I .33 0.94 1.05 1.04 1.13 1.60 Medium G 1.37 0.97 1.19 1.18 0.89 2.38 I Medium 9 1.37 1.03 \n1.10 1.08 0.95 3.01 Table 1: Query elapsed time rat,ios (00-SQL over C++) These performance results \nindicatr Ihat 00-SQL, at. least in most, cases, provides siniilar performance t.0 hand-writt,en C++ programs \nwit11 cnlbcddcd OS queries. This is what, we had hoped, as 1 l~f, SQL opt.imizcr gtner-ates execution \nplans t ha.l. arc built front t 1~1, saine prini-it,ives as t,hosc uscfi in hantl-wril t ( 11 (1++ programs. \nThe imphcat,ion is that t.hc ovc>rhc\\atls due I.0 QISS plan interpret,at,ion, which arc nol prfwil1 in \nt IIC> ronipiled C++ versions of the queries, art in rilosf CRSCS rwson- able and have minimal impac(. \non prrfornlallcc. HOW ever, there are a few cases whr>rc 1 hcrc is a signifi-cant, performance loss from \n00-SQL compared lo hand-optimized/compiled C++ progranls. The 007 query set contains a relatively simple \nsrt. of flucrics, as query per-formance was not. t,he primary focus of t.he benchmark [CDKN94]. Queries \nl-.5 can each bc c,xprcssed with a single OS query. while Quc ry 8 is inlplcmcntsd using an OS query \nembeddrd in a nf~tctl loop. Queries 2-5 showed the closest perforntallcc, rcsulls 1.0 (hose of t,hc hand-writ,t,en \nC++ progranls. Let us examine the results in l ablf> 1 a bit tiiorc carfb- fully to SW what s going on. \nFor Query 1) t,he C:++ pro-gram noticeably outperforms 00-SQL. The reason for this is that. query 1 is \na very short, (exa&#38;ma.t,ch) query t,hat ca.n be implemented in C++ using an Obj&#38;Store pick query \n1.0 select, a single element, from a. set, ra.t.her than having to create a new temporary set. for the \nre-sults oft hc quf:ry. Currently, there is no similar int,erface for 00-%)I, queries. so a more expensive \nsingleton sef. must t)c crc>at.t>d and used to retrieve the result, of Query 1 in t Ilc cas( of 00SQL. \nQuery 4 showed bett,er per-fornlancc, for ( ++ for tire small database sizes, and the rcasoti is as I \nollo4vs. Query 4 retrieves the same number of cIf\\lllc>rlts irrc,spc\\ct iv<> of which of the three dat,abase \nvrrsions is usf~l. It is implemented using a nest.ed OS qucxry i tl t IIf> ( ++ cas( and using a select \ndistinct for t.lir 00-SQL cast. 1 1~ time needed to comput,e t,he dis-linct set of rtsult t,uph s is \nthe same for a.ll dat,abase sizes, and is t hc,rc!fore a lcsscr percentage of the overall elapsed t inlc \nfor t hcj Iargcr database sizes. Query 8 also showed bet,tc,r pf~rforlnarrcc for C++ than for 00-SQL. \nIn this case, t.his is due to the overhead in 00-SQL for creating and ha.ntlling result, tuplcs: OS queries \nreturn collect,ions of pointc,rs to object,s, whereas 00-SQL queries return collect iolrs of inst antes \nof the 00-SQL syst enl-defined tuplr typf . 1 110s. in 00-SQL, a tuple object is created for each rc\\slilt \not),jcct and each such tuple object must. be indivitlllally thloic~l later when t,he query result is \nno longer nf~df~fl: t llis cost is proport.ional t,o the number of t upl~s gcu(~ratcd. For I.he small-sized \ndata.bases. t.he number of I uplrs ret limed by Query 8 is 10,000 t)uplcs, while it is 100.000 t uplrs \nfor the medium-sized databases. The pcrfornlatlcc results show a corresponding increase in the relat \nivc cost, for Query 8 for the medium sizes ov( r the small sizes. Before closing t,his section, it, is \nimport,ant, t,o point out that. W-SQL does have major porfornlancr and pro-gramming efficiency advant.ages \nto offer over C-t+ pro-grams advanta.ges that) these experiments did not, ex-plore. alld that do not. \nappear in t,he above resuIt,s. III C++, coniplf~x queries must, be carefully programmed by the application \ndcvclopcr, and mistakes a.rt likely t,o be exprnsivc> in terms of execution time. In cont.rast,, with \n00-SQI,. 111~ progranimcr can simply express the query tlcclara~iv(~ly and If,1 t IIC system. do the \nrest, just. as in rclat ional applicaiions 8 Re1ate.d Work Ilaving d~~scrib~~d t,hc drsign and implementat,ioo \nof OO- SQL, w now takr a nlorc det.ailcd look ab several part iclllarly rclcvant rxaillples of rclat,ed \nwork t.o com- pare/tout rast t heir languages and implement.at ions with t.hose of 00SQL. Thr 02 qli( \nry language [BCD89, CD921 and it,s deriva- tive, 111(x 01)MG OQL query language [ADF+93], are powerful \nquerying tools for OODBs. The differences br-twecn I~WC> Iallguagc s and 00-SQL are numerous. For cxamplf~. \n02 atid OQL allow querying any data item whcl llf,r or not it is Illulf i-valued: an 02 query can be \nde-Iinc~I ovf r ill) inlf>gcr. 1%~ 00-SQL query languagc can oiily flilq i11ult i-valufY~ dat.a items \n(i.e., elemei1t.s in t.he (/( $8 *i. from cla.use have t,o he mult i-valuml). OQL pat.11 cxprcs- sions \ndo not allow direct I.rawrsal of 1-N relationships, whereas 00-SQL path expression do (r.g., d. emps. \n.no gives the set of employee nunlbcrs in drparl.ment d). Bot,h 02 and OQL include prinlitivcs for crcat,ing \nnew struct,ured objects (i.e., not. just (,upIcs R.S in 00-SQL) as the result of a query. Overall, t \nhc expressive powers of 02 and OQL queries are greater f.han that of OO-SQL queries, and t.he languages \narc arguahly clea.ner, but t,hey are ha.sed on a new query lairguage which is quite different, from SQL-92. \n00-SQL 1)herefore differs in being upward compatible with the SQL-92 standard. Finally, t,he 02 query \noptimizer [(:1)92] relics on a set, of algebraic transformat,iolls, many of which arc 1101.ap-plicable \nto ObjeMtore dat.ahasc,s t111c to the fact that ObjectStore collections arc not. typr c,xtcnts. Also \nrelated to ()()-SQL is (]I(, work done at. 1 1 on ZQL[C++], as reported in [HM(;!)R]. ZQL[C++] is an \nSQL-like la.nguage with a C++ like expression syn-tax. Like 00-SQL, ZQL[C++] support.s queries over collection \ntypes that, include sct,s and lists. Unlike 00-SQL, ZQL[C++] p re d icates must, be built, up from user-defined \nfunctions, whereas 00-SQL permits pred-icates over data members as well. Result, processing in ZQL[C++] \nre quires the use of user-defined data types for handling the projection tlement,s of queries; 00-SQL \nuses it,s generic tuple type for t,his purpose. A cost-based query optimizer was prot,ot.yped for ZQL[C++] \nba.sed on a.n object algebra and a set of algchraic t.rans-formations. The optimizer considers physical \ninforma-tion and evaluat,ion algorithnls I.hili are sensitive t.o t.he data organization, and hash-hased \npointer join mct,hods [SC901 are included in t.h(, opt iinizc\\r s starch space to help reduce queries \nl/O c0st.s. In contrast , 1 he (M-SQL optimizer is currently orient,ctl to cas( s wllerc the dat.a touched \nby a query will fit in iilrmory (as in [OIlMS92])! and it is heurist,ic rather than co&#38;based. On \nthe ot,hcr hand, the OO-SQL implcment.at ion is far more com-plete; the ZQL[C++] lm pl cri1r~rrt~a.tion \nincluded only a partial parser and optinlizer, could handle only a. subset of ZQL[C++] tueries no joins), \n1 (e.g.. value-based and did not, have an execution engine [IiI)!Ki]. Anot.her OODB query language based \non SQL is XSQL [KKS92]. 00-SQL is similar to XSQL in a num-ber of wa.ys, hut, XSQL is morf powrrhil a.nd \nhas some differences as well. XSQL supports path expressions that are similar to those prcseiltt>tl in \nI.his paprr, hut path expressions in XSQL can have sr~lcct ors. For cx-ample, X. Residence. City [ new \nYork ] rest ricls cit.ies to t,he city of New York. In 00-SQL, such prcdi-cates are expressed in a much \nlnorc SQL-92-like syn-tax, e.g., X.Residence.City = new York . A more fundament,al difference is t,hat \nXSQL collapses t,he no-tion of met,a-data and data, adding significant, expressive power to XSQL queries. \nFor exanlple. select X where X. WonNobelPrize selects all insf.anccs in t.he database that, have a member \ncalled WonNobelPrize and whose value is not empty. While inter&#38;ing, such queries are not expressible \nin 00-SQL, and would be problematic in OODB systems (like ObjectStore) whose, database entry points arr \n1101 based on type ext,ents. While less power-ful, 00-SQI, is a n~uch more natural extension of SQL- \n92: RISO, 00SQL has hren fully implemented, whereas XSQr, hits not (to 111c best, of our knowledge). \nLike OO-SQL, XSQI, supports oh.je&#38;oriented views. Space does not, pci-illit a tlct ailed comparison \nof the two view facili-ties, but tt~c rc>lat ionship here is similar: XSQL provides a much richc>r (and \nmuch more complicated) view facility than 00-SQL, one t.hat would be difficult to support on t,op of \nObjrctStore (due to XSQL s t)reat,ment of object identity a11d views). Finally, t.hc query language associated \nwith the AT&#38;T ODE system, ( QL++, is another example of an SQL-basc>d ot).jc>ct query language [DGJ92]. \nCQL++ was dcsignc>d IO wrvfs primarily as an interactive query in-trrfacc>. so applic;r( ioll embedding \nissues were not ad-drcssc4. As a rc>sult , there a.re significant differences be-tween ( ()I,++ and 00-SQL, \ne.g., in how query results (pro.jrci ion lists) and point,ers are handled. In C&#38;L++, class tl(4gners \nprovide display-relat,cd functions for in-vocation whc~ whole ohjccts are selected by a query. There \nare also differences in the details of how the two languages express navigation over nested sets. Finally, \nCQL++ has not. yet. been implementsed (to the best of our knowledge).  9 Conclusion In this paper, we \nha.ve described the design and imple-mentation of 00-SQL. a query language that. provides SQL-basr~l \nilcc<Iss to dat,a managed by the ObjectStore OODH sys;tc,111. 00-SQL is a strictly upward-compatible \next.ension of t hc SQL-92 select statement, and includes featurc*s to support queries that navigate along \npaths, iravc>rsc> n(~stcd colI(>ctions, and use C++ methods. OO-SQL ills0 I~as wvc>rat features that, \nwere added to sup-port its us( from wirhin C++ applications, particularly a.pplications whrrt> a priori \nknowledge of the database schema and query result, t,ypes are not, known at, compila- t.ion t.inlc. In \naddit ion, 00-SQL includes a view facility that can be used to define either relational or object-orieut,ed \nviews of ObjectStore databases. An important, use of this view facitit,y has been to provide existing \nre-lational tools with access to ObjectSt.ore data, e.g., via t,hc Ol>lK: driver t,hat we have written \nfor 00-SQL. A con~plctt~ init.ial implement,at8ion of 00-SQL is cur- rently runlliilg under bot,tl AIX \nand OS/a. Where ap- plicahl(>. t.11~qucrv processor uses ObjectStore queries as single c,oll(>ct ion \nfiltrrs, but it, uses its own query evalua- t.ion Ill( (.llallisII1s WIIC,H presented with 00-SQL queries \nthat involve inorc colirplex predicates, grouping, and ag- gregalioll. A query plan language is used \nas the tar- get for query opt,inlization and as input, to the 00-SQL query evaluation subsystem. The \nquery optimizer it- self uses a set, of heuristics, which we described. to try and mininlize t hr cost, \nof 00-SQL query execution. Ini- tial performance resutt,s are encouraging, indicat,ing t,hat 00-SQL queries \nare generally quite competitive wit,h hand-opt,imized Object Store/C++ programs. Ongoing work on 00SQL \nincludes improving the implementa- tion, porting t.he implementation to other targets besides ObjectStore, \nand ext,ending the, view faci1it.y 1.0 pcrnlit the retrieval of pointers t,o ol).jrct.s of view i,ypcs \n(by gcn-erating C++ wra,pper classes).  Acknowledgements We thank Phil Boyer for being an oa.rly user \nof 00-SQL and having greatly cont.ributcd t.o improving the quality of its implementation. We also thank \nt,he support team at Object Design, Inc., for their assist.ance on various technical issues. References \n[AB91] S. Abiteboul and A. Bonncr. 0bject.s and Views. In Proc. 1991 ACM SIGMOI) Con/., Jlcnvcr, CO, \nJune 1991. [ADF+93] T. Atwood, J. Duhl, G. Frrran, M. Loomis, and D. Wade. Object Query Language. In \nR.G.G. Cattell, editor, Objrcl Dalabasc Standards: ODMG-93 Release 1.1. Morgan-Iiaufmann Pub-lishers, \nInc., 1993. [BCD89] F. Bancilhon, S. Cluet, and C. Delobel. A Query Language for the 02 Object-Oriented \nDatabase System. In Proc. 2nd Int l. Workshop on Database Programmrng Languages, Gleneden Beach, June \n1989. [Berg01 E. Bertino. Optimizat,ion of Queries Using Nested Objects. In Proc. Int 2. Conf. on Extending \nData Base Technology, Venice, Italy, 1990. [BMG93] J. Blakeley, W. McKenna, and G. Graefe. Ex-periences \nBuilding t.hr Open OODB Query Op-timizer. In Proc. 199.7 A C M SIGMOD Conj., Washington, D.C., May 1993. \n[CD921 S. Cluet and C. Delobtrl. A (;cneral Framework for t,he Optimization of Ol),ic~ct-Oricll(.ed Queries. \nIn Proc. 1992 ACM SIG MOD Conf., San J>iego, CA, June 1992. [CDVSS] M. Carey, D. DeWit,t, and S. Va.ndcnberg. \nA Data Mode1 and Query Language for EXODUS. In Proc. 1988 ACM SICMOD Conf.. Chicago, IL, June 1988. [CDN93] \nM. Carey, D. Dewitt, and J. Naught.on. The 007 Benchmark. In Proc. 199.9 A CA! SIGMOD Conf., Washington, \nD.C.. May 199.3. [CDKN94] M. Carey, D. Dewitt., (1. Kant, and .I. Naughton. A Status Report. on t.he \n007 OODHMS Bench-marking Effort.. In Proc. 1394 ACM OOPSLA Conf., Portland, OR, Oclobrr 1994. [CHMW95] \nM. Carey, L. Haas, V. Maganty, and J. Williams. PESTO: An Int,egrat.cd CZur:ry/Hrowser for Ob-ject Databases. \nSubmilfcd for pullicnlion, June 1995. [CK95] M. Carey and 3. Kiernan. 00-SQL Views for Object-Oriented \nDatabases. In preparation. [DGJ92] S. Dar, N. Gehani, and H. Jagadish. CQL++: A SQL for a C++ Based Object.-Oriented \nDBMS. In Proc. Int?. Conf. on Extending Data Base Technology, Vienna, Austria, 1992. [Day891 U. Dayal. \nQueries and Views in an Object-Oriented Data Model. In Proc. 2nd Int I. It;orX~shop Glcnctlrn on Database \nBeach, June Programming 1989. Languages, [GMP!I:,] (:. (iartlarin, F. Machuca, and P. Pucheral. A I~unctional \nExecution Model for Object Languages. In Proc. 1995 A CM SIGMOD San .Jose, CA, May 1995. OFL: Query Conf., \n[IIZ90] S. llciler and S. Zdonik. Object t,he Vision. In Proc. 6th IEEE Conf., Los Angeles, CA, April \nViews: Extending Data Engineering 1990. [ISO91] ISO-ANSI. 9075:1992, Dat,abase 1991. Language SQL ISO/IEC \n[KD95] N. Kabra and D. Dewitt. Orirnl.cd Implementation Optimization. Submitted ary 1995. OPT++: An for \nDatabase for publication, Object-Query Febru- [Kim891 W. Kim. A Model of Queries For Object-Oriented \nI)alabascs. In Proc. 15th VLDB Conf. Amster-dam, The Net.herlands, August 1989. [KKS92] M. Iiifer, W. \nKim, and Y. Sagiv. Querying Object-Oriented Databases. In Proc. 1992 ACM SIGMOD Conf., San Diego, CA, \nJune 1992. [Kim931 W. Kim. Object-Oriented Database Promise, Reality, and Future. In VLDB Conf., Dublin, \nIreland, August Systems: Proc. 19th 1993. [Kim941 W. Kim. posal. ACM Observations SIGMOD on the ODMG-93 \nRecord, 23(l), March Pro-1994. [Mel951 Jim Melton, editor. ISO-ANSI Database Lan,guage SQL (SQL3); WG3 \nDBL YOW-004 and ANSI Working Draft: ISO/IEC SC.21 XSH%94-084. JSO-ANSI, 1995. [Mic92] Microsofl. Programmer \ns 01~ n I)nfnbrr.+-e Conrxectivity rrrfnl I\\.it, 1!)92. Reference, Software Microsoft Develop- [Obj!M] \n0l)jrc.t Jlesign Inc. Reference Manual, 1994. [OHMS!~?] .I. Orcnst.cin, S. Haradhvala, B. Margulies, \nand I). Saka.hara. Query Processing in the Object-Store I)at.abase System. In Proc. 1992 ACM SIG-MOD \nConf., San Diego, CA, June 1992. [PHI192] II. Pirahesh, J. Hellerstein, and W. Hasan. Ex-tcnsibJe/Rule \nBased Query Rewrite Optimiza-tion in St,arburst.. In Proc. 1992 ACM SIGMOD Conf., San Diego, CA, June \n1992. [X190] E. Shckita and M. Carey. A Performance Evalu-ation of Pointer-Based Joins. In Proc. 1990 \nACM SIG MOD Conf., At,lantic City, NJ, May 1990. [St,09 l] M. Sit.onrbraker, et al. Haso Systrm Manifesto. \nInlcrfaccs, I%, December Third-Generation Data Computer Standards &#38; 1991. [Zan83] (y. Zaniolo. Proc. \n198.3 May 1983. The ACM Database SIGMOD Language Conf., San GEM. Jose, In CA,  \n\t\t\t", "proc_id": "217838", "abstract": "This paper describes the design and implementation of a query engine that provides extended SQL-based access to the data managed by an object-oriented database system. This query engine allows extended SQL queries to be embedded in C++ programs or issued interactively as from a command line interface. The language supported by the engine is the complete SQL-92 select statement plus object extensions for navigating along paths and embedded structures, querying nested sets, and invoking member functions. In addition, an object-oriented SQL view facility is provided. Using this view facility, one can define object-oriented views; one can also define views that flatten complex OODB schemas, allowing direct access by existing tools designed to provide remote access to relational databases. The view facility also supports the definition of views that include reference and set-valued columns based on other views, thus allowing entire \"view schemas\" to be created. This paper describes the SQL-92 query and view extensions and discusses a number of issues that arose on the way to the implementation that is currently running on top of the ObjectStore OODB system.", "authors": [{"name": "Jerry Kiernan", "author_profile_id": "81100130974", "affiliation": "IBM Santa Teresa Lab, 555 Bailey Avenue, San Jose, CA", "person_id": "P139071", "email_address": "", "orcid_id": ""}, {"name": "Michael J. Carey", "author_profile_id": "81100229036", "affiliation": "IBM Almaden Research Center, 650 Harry Road, K55-Bl, San Jose, CA", "person_id": "PP14089385", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/217838.217883", "year": "1995", "article_id": "217883", "conference": "OOPSLA", "title": "Extending SQL-92 for OODB access: design and implementation experience", "url": "http://dl.acm.org/citation.cfm?id=217883"}