{"article_publication_date": "10-01-1995", "fulltext": "\n Metamodeling in 00 OOPSLA 95 Workshop summary Hafedh Mili , Francois Pachet2, Ilham Benyahia , Fred \nEddy 1. University of Qukbec at Montrial (Canada), 2. University of Paris VI (France) 3. Institut de \nrecherche d hydro-qukbec (Canada), 4. OMT Consulting Inc. (USA) 1. Introduction The purpose of this workshop \nwas to explore metamodeling concepts in the context of object- oriented software development, from a \nmethodolog- ical perspective, namely: 1) Exploring the additional modeling constructs that are needed \nto model information at several levels of abstraction, 2) Exploring changes to modeling procedures/heuristics \nthat are needed to build object meta-models and integrating them with object models, 3) Exploring the \neffects of such changes on design and implementation (e.g. reflective languages, metaprogramming, etc). \nAs is usual (and healthy) in such events, the papers we received did not fit in exactly with the advertised \nagenda, with its heavy emphasis on methodological (analysis and design) aspects, and the proposed agenda \nwas as much the result of what the organiz- ers wanted discussed as it was a result of what par-ticipants \nwere willing to discuss! That result is shown next. We first attempt to define metamodel-ing in the context \nof object-oriented software engineering, identifying major issues. Next, we dis-cuss each one of those \nissues in some detail.  2. General issues Object-oriented structural modeling uses classes to represent \nthe structure of similar application objects, and associations to represent patterns of connections between \napplication objects. Applications where the representation of objects needs to be queried or oth- erwise \nmanipulated need to explicitly represent the representation of objects [Diaz,1994]; we call the representation \nof the representation of application objects metamodeling. The need for metamodels is more frequent than \none might first think. In relational database modeling, meta-data consists of table descriptors. which \nare system tables (system dictionary) describing the data tables (their columns, domains for the columns, \netc) and integrity constraints, which, by and large, are semi-declarative constructs to be executed dur-ing \ndatabase updates. [l] A typical computer-assisted manufacturing application needs two levels of abstraction: \n1) one level to represent bills of material, e.g., describing the compositions of dif-ferent manufactured \nproducts, 2) a second level to describe actual manufactured products in stock. Bills of material are \nrepresentations of manufac-tured products. However, to the extent that they can be created, consulted, \nand modified, they too need to be represented by a construct that describes their structure; these are \ncalled metaclasses. When not a part of the problem (e.g. a bill of materials and inventory application), \nmetamodeling is part of the solution: metamodehng is an abstrac-tion mechanism in the sense that, much \nlike classification, it enables us to differentiate identity-dependent behavior from state-dependent \nbehavior, hence making some sense of the variations in the world to be modeled. Also, much like classification, \n Addendum to the Proceedings OOPSLA 95 by replacing extensions (explicit occurrences of a given concept) \nby intensions (the definition of the concept itself), metamodeling results into cognitive economy. Finally, \nwhen applied in actual software projects, metamodeling can result in great savings in development effort, \nand in much better reuse potential by going one additional step from component-oriented reuse towards \ngeneration-oriented reuse. For the purposes of 00 software engineering, when we talk about metamodeling, \nwe have to talk about at least three sets of issues: 1) An anthology of metamodeling: what does it mean, \nwhat kinds of metamodeling dimen-sions are there, how many are really needed for practical software engineering, \netc., A process for metamodeling: how to perform 2) metamodeling, how to recognize and/or buiild metamodels \nfrom application/business requirements, etc., and Implementing metamodels and meta- 3) programming: \nhow to represent metamodels at the analysis, design, and implementation lev-els, what additional notational \nconstructs are needed, what kind of support do programming languages need to provide, etc. The position \npapers submitted and the discussion that took place during the workshop focused mostly the first (anthology) \nand third r im pl ementation/support) sets of issues. These are discussed in more detail below. 3. An \nanthology of metamodeling Three dimensions of metamodeling emerged from the papers submitted: 1) Metamodeling \nas the modeling of modeling/representation languages (see e.g. [Artsy., 19951, 2) Metamodeling as the \nmultiple instantiation levels of application knowledge (see e.g. [Odell, 1995a] and [Odell, 1995b]), \nand 106 Austin, 3) Metamodeling as the modeling of information about how to use and manipulate application \nmodels (see e.g. [Anquetil &#38; Vaucher, 19951, and to some extent, some aspects of system described \nby Demphlous [Demphlous &#38; Lebastard, 19951) as computational objects. It was clear to us that all \nthree kinds of information were useful and may be combined in any one appli-cation area. We attempted \nto identify a common framework within which the three dimensions and arbitrary combinations thereof could \nbe studied One way of looking at this considers computer application models as the cross-product of three \nmodels or domains: 1) the business/application domain, call it DA, 2) the computational model, call it \nDC, and 3) the representation model. call it DR. The three dimensions mentioned above correspond to abstraction \nalong one of three domains, where relationship between a model and its meta equivalent is that between \nan instance and a set (or a class). In other words, if the realm (set) of computer application models \nis the cross product DAXDRXDC, then one metamodeling direction might be DA ~2~~ xDC, where 2 is the power \nset of set S. In this first example, we were going meta along the representation/notation language dimension; \nanother might be 204 xDRxDc, i.e. going meta along the application knowledge. We could also iterate several \ntimes along the same dimension. For example, we can go meta-meta along the representation notation/language \ndimen- fQ sion, to get the realm DA x2 XDC. Yet another meta-meta direction might go one step in the \nrepresentation language direction. and one in the application domain direction, yielding the modeling \nrealm 2O x2DR xDC. And so forth. Much of the discussion about the anthology of metamodeling and the above \nformalization benefited from two position papers ([Odell, 1995a] and [Odell, 1995b]) and two presentations \nby Jim Odell. The remainder of the workshop was to go over the three dimensions mentioned above, before \nmoving on to issues of supporting metamodeling. 4. Metamodeling as the modeling of representation languages \n The one dimension that received the most attention is the first one, with various applications thereof, \nincluding maintaining consistency between object models [Sarver, 19951, implementing CASE tools [Sahraoui \net al., 19951, a uniform way of supporting persistence [Demphlous et Lebastard, 19951, data interchange \nbetween tools (e.g. [Odell, 1995a] and [Artsy, 19951. Artsy, who leads a standards group working on establishing \na common data interchange format (CDIF) between tools, gave the introductory talk. The approach taken \nby the standards group consists of expressing the various modeling languages used by the various tools \nand methodologies in a single meta-modeling language, so that correspondences and transformations could \nbe applied between models expressed within (exported by) the various methodologies (tools). He discussed \nsome of the practical issues in finding such a CDIF, including the fact that most methodologies and tools \nhave no formal (or reliable or consistent) description of their semantics. He reported that the group \nhas finished work on data (static) models and that ongoing efforts continue towards bridging dynamic/behavioral \nmodeling notations. Sahraoui described the use of metamodeling for generative programming. METAGEN, a \nsystem developed at the LAFORIA lab of the University of Paris VI, supports generative programming by \nsup-porting the description of analysis/modeling nota-tions, of design notations, and of correspondence \nrules (mappings) between them. Specific application models are input as instances of the user modeling \nlanguage, and the computational model (design model) is output as an instance of the design language \nthrough the triggering of transformations. He described his experiences using METAGEN to replicate a \ndatabase modeling and programming tool called INTERSEM, developed by Prof. Mis-saoui of the Univ. of \nQuCbec, which inputs extended E/R schemas, and generates ObjectStore schemas and access functions. The \ngeneral discussion addressed general issues such as: 1) is there really a (meta-) modeling esperanto, \n2) what kind/family of languages is/are guaranteed to not be outdone by the Booth notation, otherwise \nknown as the APL of design notations, 3) can we avoid having to fall back on GP representa- tion languages \nsuch as logic, 4) how to build exten-sibility in such a language so that new constructs can be introduced \nwithout invalidating earlier specifications. Artsy stressed that the goal of his CDIF group is a best \neffort approach, i.e., they accept loss of information during interchange; they just wish to minimze \nit and understand its nature. 5. Metamodeling of application knowledge The second dimension of metamodeling \nhas received little attention as a subject of study per se in the community, and this was reflected in \nthe sub- missions. Jim Ode11 introduced the notion ofpower-types, which inspired much of the formalization \nof metamodeling discussed earlier. A powertype is to a type what a power set is to set, i.e. a power \ntype is the type (class) whose instances are subtypes (subc-lasses) of another type. We come across powertpes \nvery frequently in 00 modeling, as when we have something to say about term deposit accounts, rather \nthan about a particular kind of term deposit account of a particular customer. Ode11 proposes a way of \nrepresenting types and powertypes in the same class (type, we should say) diagram, helping to clarify \nobject models and to maintain consistency between type and meta-types . Fred Eddy, formerly of GE Corporate \nResearch and Development, described an avionics application in which they were mandated to develop a \nmonitoring and control application that could accommodate variations in aircraft models. He discussed \ntwo alternatives, parameterization and meta-modeling. Parameterization accommodates data differences \nquite handily, but does not account for process differences as easily or as cost-effectively as meta-modeling. \nIn this case, going meta meant: 1) developing a conceptual computational model for the family of applications \nat hand, 2) designing an architecture for simulating and executing such applications, and 3) implementing \nsuch an architec- ture in the form of a development platform/framework. The gains in terms of produc- \ntivity and time-to-release were immeasurable 1 Michael Mohammed, of PanCanadian Petroleum, described \nongoing efforts at PanCanadian to re-engineer its information infrastructure. A corner-stone of that \nstrategy consists of identifying com-monalities between its various information bases and processes. \nMetamodeling was used to package the description of the common information struc-tures and processes. \nA number of issues remain to be addressed with regard to the use of meta-modeling to model dif-ferent \nlevels of abstraction of the application domain. First, from a practical standpoint, how do we distinguish \nbetween a type property/attribute (e.g. Smalltalk s metaclass instance variables) and a property whose \nvalue is shared by the instances of a class (Smalltalk s class variables, C++ s static data members). \nWe also need behavioral metamodeling (a definition and a notation), along the lines of the experiences \nreported by Fred Eddy. It is interesting to note that standardization efforts have so far suc-ceeded \nin developing a meta-level object model, but work continues on behavioral models [Artsy, 19951. 6. Metamodeling \nas a user manual for objects The third dimension of metamodeling corresponds to the concern addressed \nby Anquetil and Vaucher [Anquetil and Vaucher, 19951. In that paper, they i.e., nobody remembers :-) \n look at the problem of expressing usage constraints on reusable components, and more specifically, on \nthe representation of negation or mutual exclusion between classes; while mutual exclusion between sibling \nclasses is represented in some 00 models, it is not general enough to handle unrelated classes. Further, \nexisting 00 languages and library environ-ments do not support such exclusion. Stephane Demphlous, of \nINRIA (France), presented their approach to manage persistence. It is based on a meta-modeling language \nwhich has its own meta-object protocol for managing persistence. Different users using different modeling \nnotations will express their modeling notation in the meta-modeling language, and specialize the persistence \nmeta-object protocol. Other kinds of usage constraints discussed during the workshop have to do with \nthe run-time pro-grammatic behavior of objects. For example, in a distributed environment, we may want \nto say that classes of a given type are remote and that some updates have to be delayed, and/or queued, \nor that some objects shouldn t be loaded into the environ- ment unless they are needed, etc. Such information \ncan be represented and manipulated. Ira Forman raised the distinction between distribution (or any other \nprogrammatic paradigm) as part of the requirements, or as design choices made for perfor- mance or fault-tolerance, \nand wondered whether the distinction made a difference in the way the infor-mation is represented. 7. \nProviding support for metamodel-ing 7.1. Background The most tangible meta-modeling achievements were \nhistorically made by work on reflection in pro- gramming languages, also referred to as computa-tional \nreflection. Historically, work on computa-tional reflection dates back to Brian Smith s seminal 3-Lisp \nsystem, which inspired an entire research branch on reflection in the functional programming community. \nThis work gave then birth to various attempts at computational reflection in 00 languages, mainly Smalltalk \nand CLOS (see the numerous OOPSLA workshops on reflection in 00 languages, and the recent IJCAI workshop \non meta-level architectures in AI). Other attempts at computational reflection were made in the commun-ity \nof logic programming (see e.g. the recent Godel language). These efforts have identified two kinds of \nreflection, structural reflection and behavioral reflection. Structural reflection, which can be defined \nas the ability of a language to provide a complete reification of both the program currently executed \nas well as a complete reification of its abstract data types . Structural reflection is the basis for \na number of metaclass models. The purest (and minimal one, in a canonical sense) one is the ObjVlisp \nmodel. The most practical one is Smalltalk. CLOS is in the middle; in practice, it is the simplest one \nto imple-ment. Behavioral reflection can be defined as the ability of the language to provide a complete \nreification of its own semantics (processor) as well as a complete reification of the data it uses to \nexe-cute the current program . Behavioral reflection is more difficult to implement. Work in 00 behavioral \nreflection showed that in order to give access to the main phases of message interpretation, message \nexecution can be divided in two phases: method lookup and application of messages. Each phase can then \nbe redefined by the user to control message interpretation. In CLOS, this is done via redefinition of \nfunction apply-generic-function. In Smalltalk this is not possible in practice, but the language can \nbe easily extended to do so (see work on ClassTalk (Briot&#38;Cointe). For the purposes of this workshop, \ntwo sets of issues are of interest: 1) implementing meta-models using reflective OOPLs, and 2) implementing \nmeta-models without reflection.  7.2. Metaclasses and metaprogramming: major issues From a practical \nstandpoint, the utility of metaclass models, when they are available, is still prob-lematic. The most \nvisible problem is perhaps the metaclass compatibility problem , raised by N. Gaube (OOPSLA 89). This \nproblem comes from the fact that metaclasses, in reflective 00 models, con-trol their direct instances \n(classes), AND also their 2nd generation instances (instances of their instances), in an implicit way, \nwhich is not sup-ported by the language. Hence, the programmer may define classes which are inconsistent, \nif he/she does not respect these compatibility constraints. With both Pierre Cointe (ClassTalk) and Ira \nForman (SOM) in attendance, we anticipated a shoot out. Fortunately (or unfortunately) Francois Pachet \ns dispassionate and to the point introduction to the topic, drew the battle lines in such a way that \ncon-frontation took place. Ira Forman presented SOM s solution to this problem, based on the notion of \nderived metaclasses , which are dynamically created metaclasses, that ensure compatibility and cooperation \nbetween parent classes; he described a technique for combining before-and after- methods in a systematic \nand semantically meaningtil way. There then followed some discussion about the semantics of metaclasses, \nand of subclassing between metaclasses. Pierre Cointe mentioned the case where one metaclass provides \na self should-NotImplement implementation of a class method, which could be combined with a more constructive \nimplementation of that method from another meta-class. Ira suggested that his approach is meant to work \nin cases of positive attributes (behaviors that classes do have to support), and not in cases involv-ing \ncancellation/negation. Hafedh Mili ventured a set theoretic interpretation of Ira s metaclass com-patibility \nconstraints by treating metaclasses as powersets. OOPSLA 95 Addendum to the Proceedings  7.3. Doing \nwithout metaclasses and metapro-gramming Most of the widely used 00 languages (C++, Eif-fel) do not have \nsupport for metaclass programming. This raises two questions: 1) the question of the adequacy of the \nmetaclass programming to imple-ment metamodels, and 2) When metaclasses are not available, what kind \nof mapping can be done to simulate metaclass programming? In his introductory presentation, Frangois \nPa&#38;et mentioned that experience has shown that, notwith- standing the incompatibility problems mentioned \nabove, metaclass programming is difficult. Further, a fewer languages than we might think actually sup- \nport unrestricted metaclass programming: he rem- inded Smalltalk hawks that Smalltalk supports only one \nlevel of metaclasses, but that real applications may involve several meta-iterations, to which Jim Ode11 \nnodded very forcefully. Franqois mentioned an ongoing effort at the LAFORIA lab (University Paris VI) \nin which a zig zag approach was used to emulate a multi-level meta-architecture: meta- classes delegate \ntheir behavior to regular classes, enabling developers to program an arbitrary number of instantiation \nlevels. He mentioned that, surpris- ingly, they didn t run into as many problems as with languages supporting \nunrestricted metaclasses. Hafedh Mili hypothesized that the reason was that developers had to be explicit \nabout what behavior to carry across meta-class links, since they couldn t rely on built-in mechanisms. \nTodd Blanchard described a C++ implementation in which they emulated metaclass programming. His approach \nis similar in spirit to Franqois s zig zag approach in the sense that, unable to add an addi-tional instantiation \nlevel for active objects to the language, we use low-level object to stand for higher-level ones, and \nprovide programmed (ad-hoc) links between the two. What I really mean is, he represented classes by instances \nof some C++ class called (say) Class, hence, providing support for querying classes, during run-time, \nabout their attributes and their relations to other classes (sorry Todd, I can t remember how you maintained \ncon-sistency between actual C++ classes and their representation, or how you managed dispatching). He \nmentioned the danger of slipping towards developing yet another programming language.  8. General impressions \nWe came out with the impression that: 1) There is widening recognition for the need for metamodeling, \nand for integrating it into modeling methodologies, tools, and program-ming practices, 2) It is far from \nclear that metaclasses (not metaprogramming, which can be done without metaclasses) is the way to support \nmetamodel-ing and metaprogramming, 3) There seems to be precious little investigation into the semantics \nof metaclasses from a type theory perspective, and quiet a few PhD theses can probably be had in this \narea. 9. Bibliography Due to space limitations, we only list outside publi-cations. Workshop submissions \ncan be accessed on-line through the web URL: http://satume.info.uqam.ca/Labo_Recherche/Larc /metamodeling-wshop.html. \nWe should point out that the URL listed in OOPSLA s WEB pages was wrong (our mistake). [Briot &#38; Cointe, \n19891 J.-P. Briot and Pierre Cointe, Programming with explicit metaclasses in Smalltalk80, Proceedings \nof OOPSLA 89, pp. 419-431. [Diaz, 19941 0. Diaz and N. Paton, Extending ODBMSs using metaclasses, ZEEE \nSoftware, vol. 11, no. 3, pp. 40-47, May 1994. [Graube, 19X9] N. Graube, Metaclass compatibil-ity, Proceedings \nof OOPSLA 89, (October 1-6, 1989), pp. 305-316. \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Hafedh Mili", "author_profile_id": "81410594736", "affiliation": "University of Qu&#233;bec at Montr&#233;al, Canada", "person_id": "PP39075977", "email_address": "", "orcid_id": ""}, {"name": "Francois Pachet", "author_profile_id": "81100218356", "affiliation": "University of Paris VI, France", "person_id": "PP37038742", "email_address": "", "orcid_id": ""}, {"name": "Ilham Benyahia", "author_profile_id": "81332489922", "affiliation": "Institut de recherche d'hydro-qu&#233;bec, Canada", "person_id": "PP31072424", "email_address": "", "orcid_id": ""}, {"name": "Fred Eddy", "author_profile_id": "81100159027", "affiliation": "OMT Consulting Inc.", "person_id": "P86554", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260257", "year": "1995", "article_id": "260257", "conference": "OOPSLA", "title": "Metamodeling in OO: OOPSLA'95 workshop summary", "url": "http://dl.acm.org/citation.cfm?id=260257"}