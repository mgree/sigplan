{"article_publication_date": "10-01-1995", "fulltext": "\n WORKSHOP ON OBJECT-ORIENTED LEGACY SYSTEMS AND SOFTWARE EVOLUTION Summary Antero Taivalsaari Roland \nTrauter Nokia Research Center Daimler-Benz Research Center P.O. Box 45 Wilhelm-Runge Strasse 11 002 11 \nHelsinki, FINLAND 89081 Ulm, GERMANY taivalsa@research.nokia.com trauter@dbag.ulm.daimlerbenz.com Eduardo \nCasais Forschungszentrum Informatik Haid-und-Neu-Strasse lo-14 7613 1 Karlsruhe, GERMANY casais@fzi.de \n1. Introduction nized, the utilization of object-oriented technology does not necessarily result in general, \nadaptable The increasing reliance on information technology families of systems. Rather, the indiscriminate \nuse for consumer and industrial goods imposes new re-of object-oriented mechanisms and weaknesses in \nquirements on software flexibility. In domains such object-oriented analysis and design methods are as \ntelecommunications or logistics, many applica-leading to a new generation of systems with their tion \nvariants have to be produced to fulfill the needs own characteristic problems, leaving the industrial \nof widely different markets and categories of cus-users with the challenging task of managing the tomers. \nMoreover, these systems must accommodate evolution of large, long-lived libraries with little numerous \nfunction enhancements and changes in methodological or tool support. customers requirements over time. \nIn general, eco-nomic and other factors make it increasingly impor-Advanced users, who pioneered the \nintroduction of tant to view software development as the process of object-oriented techniques, are already \nfacing these creating families of systems instead of building in-problems. Given the pace at which all \nindustrial and dividual applications. commercial sectors are taking up object-orientation, this issue \nis becoming a central aspect of software Object-oriented programming has often been pro-development in \nthe near future. In a sense, it can be moted as the most effective approach to build inher-said that \nlegions of C++ programmers have been ently flexible software. While the benefits of object- diligently \nat work for the past ten years to develop oriented technology are apparent and widely recog-the legacy \nsystems of tomorrow --with a productiv- ity far exceeding those of the C, Fortran or Cobol coders of \nthe past. Therefore, the re-engineering and evolution of object-oriented software are strategical considerations \nfor companies aiming at maintaining their competitive edge. 2. Workshop motivation and goals To the best \nof our knowledge, this was the first workshop on object-oriented legacy systems. The original motivation \nto organize the workshop was the fact that the organizers have all been involved in large-scale object-oriented \ndevelopment projects in which it has become apparent that although object-oriented programming is generally \na very good way to develop software, in practice there are many problems that arise when object-oriented \nmethods are applied to large-scale projects. In general, reus-ability, flexibility and easier maintenance \nthat are often advertised as natural causes of the utilization of 00 technology do not come for free, \nbut require careful planning and attention from the managers and designers. Also, it has become more \nand more apparent that as object-oriented systems become mature, they will face maintenance and evolution \nproblems similar to those of earlier, non-object-oriented systems. The general goal of the workshop was \nto raise the awareness of the darker side of object-oriented tech-nology, and to create a forum for generating \nand ex-changing ideas for the management and evolution of mature, large-scale object-oriented systems. \nSeveral focus areas had been defined prior to the workshop: -re-engineering first-generation object-oriented \nsystems into reusable frameworks, -problems with existing object-oriented systems: reusability, integration, \ndocumentation, - methodological support for evolutionary, iterative design, - methodological support \nfor framework design,  -development of families of systems and reusable framework architectures, -the \nrole of maintenance in the object-oriented software development process, -class library reorganization \nalgorithms and tools, -software engineering environments for object-oriented software evolution and collaborative \nde-sign, and -version and configuration management issues. We didn t want to limit the workshop to any \nsingle topic. Rather, the idea was to bring together re-searchers and practitioners interested in various \nas-pects in the management and evolution of large-scale object-oriented systems, thereby helping state-of-the-art \nmeet state-of-the-practice. Questions that had been defined as the basis for discussion included the \nfollowing: -Do 00 legacy systems already exist? - What kinds of experiences have the other people had \nregarding the development of large-scale oo systems? - What are the typical characteristics of 00 legacy \nsystems? - What are the best techniques to maintain and evolve large-scale 00 software?  -Is current \nstate-of-the-art enough for solving the problems? -How to make the state-of-the-art in large-scale 00 \nsystem development meet the state-of-the-practice?  3. Approach The half-day workshop was carried out \nin two phases. First, a set of position papers was presented, starting from positions by industrial participants, \nand followed by positions by method/tool providers. Then, a discussion on selected topics followed. \n 4. Summary of presentations Antero Taivalsaari started with some information about the situation at \nNokia, a telecommunication systems manufacturer, which has invested heavily in object-oriented technologies \nin the recent years: In addition to dozens of small-to-moderate-size object-oriented development projects, \nNokia s business units currently have two very large telecommunica-tions network management systems development \nprojects, each consisting of more than 1.5 million lines of C++ code and over 1000 classes. In these \nprojects it has become apparent that the success in managing a large-scale object-oriented project relies \nheavily on the collection of existing experience that can be reused easily. Traditional techniques for \nthe management of object-oriented class libraries proved to be inadequate when the number of classes \ngrew large (> 500 classes). Many of these problems arose from difficulties in visualiz- ing the complex \nrelationships between objects in a large class hierarchy. However, an even bigger problem was class \nlibrary evolution: The ability to build programs incremen-tally using inheritance rather than by editing \nexisting code is potentially dangerous: it directs the pro-grammer to avoid changes in the existing code, \nno matter how poorly designed it later appears to be, easily causing the quality of code to deteriorate \nin the course of time. In large, evolving problem do-mains the consequence are very expensive and error- \nprone class hierarchy reorganizations. Here auto- mated tools for class library evolution would be a \ngreat relief to designers. Finally, the related main research areas of Nokia Research Center were outlined: \n(1) The methodo-logical support for the migration from first-generation 00 systems to second-generation \n00 systems built around framework technology. (2) The design and implementation of practical tools for \nbetter visualization, change management and de-signer collaboration mechanisms. Klaus Krauter, a software \narchitect from Continen-tal Healthcare Systems in Winnipeg, Canada re-ported on the reengineering of \na medium size clini-cal nursing information system. The initial system consists of several hundred thousand \nlines of C++ and C. All their class libraries with only special pur-pose components were built in house. \nNo object ori-ented development methodology was used to de-velop the system. The reengineering process \nin-cluded a migration to another system software plat-form, the use of some core class libraries and \na OOAD method (OMT). They also defined guide-lines for the deliverables required at each stage of the \ndevelopment process. His methodological recommendations for large, continuously evolving application \nsystems were: 1. Full support for the separation of policy and mecha- nism in a class library or component. \n2. Clear identi-fication of what is policy and mechanism. 3. Support the peaceful coexistence of other \nclass libraries or domain components within the same system. 4. Clear identification of what, where, \nand how to ex-tend the class library or domain component. 5. Well defined exception semantics. 6. Well \ndefined and documented set of design rules that can be en-forced by the tools that support the lifecycle. \nHe believes that the above issues can be addressed by defining a meta model for class libraries and components \nand that design patterns are providing the basis for some of the human readable forms of the meta model. \nRoland Trauter presented the situation at the Daimler-Benz group which is today heavily using object \noriented technology. The majority of the group companies were moving to 00 technology in the last two \nor three years. But there are also some companies which started very early with first pilot projects \nin 1989 or 1990. The goal of Daimler-Benz Research Center is to provide a complete me-thodological support \nand 00 reengineering lifecycle that helps adapt existing 00 systems to future needs and thereby save \ninvestments of the past. The problems with existing 00 systems were sum-marized: Existing systems or \nlibraries, or even sys-tems that are still under development are often diffi-cult to modify or to extend. \nAs they represent a considerable investment they cannot be simply thrown away and replaced. The difficulties \nwith these systems are mostly caused by insufficient documentation of the system architecture and / or \na not optimal structure of the system (architecture). Another problem domain was the choice of the pro- \ngramming language or the OOAD tool. Especially companies that started early are often confronted with \nmigration problems. The solutions presented for these problem domains were: (1) A real integration of \nOOAD tools with programming environments to provide the required up-to-date documentation. (2) Really \nuseful OOD methods that deal with the systematic use of existing libraries and frameworks. (3) New visualization \nand aggregation techniques that provide more adequate support for the development or reengineering of \nlarge systems. (4) The integration of useful tech-niques such as design patterns, refactoring tech-niques \nor metrics with OOD methods. (5) The auto-matic information exchange between different OOAD tools on \nbase of an integrated OOAD meta-model as proposed by EIA-CDIF. (6) The reimple-mentation of systems or \nlibraries by semi-automatic extraction of conceptual models from the sourcecode and the following use \nof code generators. Hernan Astudillo from Georgia Institute of Tech-nology in Atlanta provided a contribution \nfrom the academic viewpoint. In his mind the problems with existing 00 systems or libraries have two \nrather or-thogonal aspects: getting better code and using old code in new ways . He advocated the adoption \nof two changes in the current view of legacy sys-tems . First, he described how to separate clearly the \ntwo aspects mentioned above. Second, he pro-posed a slight generalization of the concept of le- gac y \n. He proposed keeping separate class and type hierar-chies, corresponding to the code and model sides \nof a design implementation. The implications of this separation are that (1) type-to-class mappings be-come \nthe interfaces where actual reuse is played, and (2) reorganization mechanisms can be applied to both \nsides separately. The derivation of class sets from a given set of types, or the representation of existing \nclasses as type sets, can be approached ei-ther with reorganization techniques similar to what is already \nin use (such as Casais , Opdyke s or Lie-berherr s work) or with techniques from biological taxonomy. \nIt also becomes possible to separate the issues of optimal implementation (class hierarchies) and optimal \nrepresentation (type hierarchies). He extended the concept of legacy by the inclusion of prototypes built \nin early stages of a project. He recommended to reuse domain classes in the final product and to discard \nthe rest of a prototype. Walter Bischofberger from the Union Bank of Switzerland s Informatics Laboratory \n(UBILAB) in Zurich concentrated on tool support for the evolu-tion of object-oriented systems. He first \nreported on the successful development of the C++ program-ming environment Sniff and its product version \nSNIFF+. He then gave an outlook on their current work on Beyond-Sniff, a platform and a set of tools \nfor cooperative software engineering. He considered browsing, documentation and scal-ability to be very \nimportant aspects for the efficient evolution of object-oriented legacy systems. Legacy systems are usually \nunderdocumented and the do-cumentation frequently does not correspond to the state of the current software \nsystem. Extensive browsing capablities in combination with fuzzy queries could help gaining the important \nunderstand-ing of the system. The knowledge incrementally gained during browsing could be used for docu-menation. \nThe concept of categories was recom-mended for documenting groups of methods and classes. Annotations \nwere regarded as very helpful to append information to any kind of development artifacts such as classes, \nvariables, and projects. As today s typical C++ development environments do not seem to scale very well, \nSniff was designed very carefully with efficiency and scalability in mind, and it scales up to l,OOO,OOO \nlines of code. Beyond-Sniff will provide an even better solution resulting in considerably lower loading \ntimes and RAM requirements for teams. Robert Rock Howard from Tower Technology Corporation in Austin, \nTexas completed the presen-tations with a viewpoint of a tool vendor who is of- ten confronted with the \nreality of object-oriented legacy systems by his customers. He explicitly con-firmed a demand for enhanced \nmethod and tool sup-port, especially in the area of C++ and home brewed C-based 00 systems. Many of these \napplications represent large investments, but are already in diffi- culty due to the natural transitions \nin hardware, op-erating systems, software infrastructure, require-ments and available talent. In his \nmind the evaluation of 00 legacy systems boils down to one question: Is the system compre-hensible? Can \nyou bring a new person into the proj- ect, and, given nothing but readily available project materials, \nexpect the new person to come up to speed on the system. If a system works but cannot be easily reengineered, \nthen it will be part of the problem, not the solution. He regarded computer programs as a source for \ncapturing design informa-tion. Instead of focusing only on static aspects such as class interfaces, static \nrelationships and inheri-tance, he recommended to focus more on the dy-namic interaction of run-time \nobjects. In his opinion, Eiffel can serve as a good notation to explicate de-sign information and bridging \nthe gap between de-sign and implementation. TowerEiffel, for example, can directly interface with C, \nC++ and/or Objective C while adding assertions, exceptions, garbage col-lection, readability, parameterization \nand more. 5. Discussion During the presentations, several interesting ques-tions had emerged, and some \nof these were chosen as starting points for discussion. Below some of the most important discussion topics \nare summarized. The model vs. the code. Characteristic of legacy systems is that they are poorly documented \nand poorly understood. In many situations the only things that are left from the system are the executa-bles \nand the source code. On the basis of these arti-facts alone, the original design ideas are very diffi-cult \nto reconstruct, however, and consequently the level of understanding that is needed for success-fully \nmaintaining and improving the system is diffi- cult to reach. This was recognized as one of the most \ncentral problems underlying all legacy systems. In the discussion, it was noted that object-oriented \nsystems are ideally less subject to the problem of the model vs. the code. After all, object-oriented \npro-gramming languages provide mechanisms that more closely correspond to conceptual modeling princi-ples, \nand therefore an object-oriented program typi-cally better reflects the original conceptual design model \nof the system. Therefore, even in the absence of high-quality documentation, object-oriented sys-tems \nshould (ideally) be easier to maintain than their non-object-oriented counterparts. Nevertheless, it \nwas commonly agreed that the closer distance be-tween the model (design) and the code (implementation) \nshould never be used as an excuse for not preparing good documentation. Rock How-ard summarized this \nby emphasizing that software designers should be taught right from the beginning that the system they \nare developing is not finished until the solutions have been properly communicated to others. This is \nas important in object-oriented software development as it is in software develop-ment in general. Accidental \ncomplexity vs. real complexity. One of the factors that was recognized as central in causing software \nsystems eventually to become legacy sys-tems is the fact that a great deal of the complexity in software \nsystems is purely accidental, i.e., resulting from the use of certain tools, languages, methods and processes, \nrather than being real complexity arising from the problem domain itself. While ob-ject-oriented programming \nis capable of reducing the accidental complexity of a system by providing better support for conceptual \nmodeling, thereby converging the model and the code, there are several mechanisms in object-oriented \nprogramming lan-guages that can actually increase the accidental complexity of a system. For instance, \nthe inappro-priate use of inheritance (e.g., implementation in-heritance) can substantially increase \nthe accidental complexity of a system and make the system harder to understand. Also, things like graphical \nuser inter-face (GUI) implementation may dramatically in-crease the accidental complexity, unless the \ndesign-ers are aware of certain good design practices for GUI development (such as the Model-View-Controller \nparadigm familiar from Smalltalk-80). In general, the use of object-oriented programming it-self does \nnot in any way guarantee that the resulting program would somehow automatically be well-designed and \neasy to maintain. Klaus Krauter recognized patterns as one of the most promising answers to the problem \nof accidental complexity, and proposed that well-known patterns such as those defined by Gamma et al. \ncan assist in making the inner structure of programs more appar-ent and less subject to accidental complexity. \nIn the long run, this could provide substantial help in maintaining and evolving object-oriented systems. \nEvolution vs. revolution. One of the well-known facts in software development is the necessity of change. \nIf a software system is successful, it will have to be changed, while unsuccessful systems will just \nfade away. However, changes to systems can generally be performed in two ways: 1) in an evolu- tionary \nfashion by extending and refining the exist- ing system, and 2) in a revolutionary fashion by re- implementing \nand replacing existing functionality. One issue that had emerged in both Hernan As-tudillo s and Antero \nTaivalsaari s presentations is the fact that it is very difficult to choose between evolu-tion and revolution. \nIn general, it is very difficult to define the appropriate obsolence criteria for de-termining when a \ncertain system or a piece of it has reached such a level of complexity or incomprehen-sibility that it \nshould be replaced with a completely redesigned one. As pointed out by Antero Taivalsaari, object-oriented \nprogramming tends to make the decisions regarding evolution vs. revolution even harder, as OOP provides \nfar better facilities for incremental modification than other programming paradigms. As a result, 00 \ndesigners often have a tendency to keep on extending and refining the class structures even when the \nneed for more substantial redesign has al- ready become obvious. This can lead to extremely costly class \nhierarchy reorganizations later on. The issue of evolution vs. revolution was discussed, but the participants \ndid not foresee any easy solutions to Addendum to the Proceedings OOPSLA the problem. One of the presented \nideas that was to define some kind of a systematic way to measure the maturity index of a class hierarchy, \nbut such met-rics tend to be quite unreliable and can only give general guidelines rather than specific \ninstructions for evolution/revolution. Tool support. In his presentation, Walter Bischof-berger had brought \nup the importance of tools in the management of large-scale object-oriented systems. Many problems in \nsoftware maintenance arise from improper understanding of the system, and better reverse engineering, \nprogram understanding and fil- tering tools could provide substantial help in this. There was a discussion \non the role of tools in help- ing software evolution. Participants agreed that cur-rently there are still \nsome scalability problems per-taining to tool usage. For instance, most graphical programming environments \ndo not really scale up to multi-million line projects, although the need for graphical tools and visualization \nfacilities tends to grow exponentially as the size of the project grows. Also, there is clearly a need \nfor better designer col-laboration tools, as in large-scale projects the de-signers do not necessarily \nreside in the same build-ing, city or even country. It was also mentioned that many of the problems in \nlarge-scale object-oriented systems development arise from management problems, but due to limited time \nthis thread of discussion was not continued further.  6. Summary It was generally agreed by the participants \nthat ob-ject-oriented systems can become legacy systems and that examples of such systems already exist. \nHowever, it seems that object-oriented systems have some important characteristics that make them in-herently \nless subject to becoming legacy systems than their non-object-oriented counterparts. Never-theless, many \nsubstantial obstacles pertaining to the maintenance and evolution exist, and further re- search into \nthese areas is clearly needed. \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Antero Taivalsaari", "author_profile_id": "81100579680", "affiliation": "Nokia Research Center, P.O. Box 45, 00211 Helsinki, Finland", "person_id": "P20223", "email_address": "", "orcid_id": ""}, {"name": "Roland Trauter", "author_profile_id": "81100079773", "affiliation": "Daimler-Benz Research Center, Wilhelm-Runge Strasse 11, 89081 Ulm, Germany", "person_id": "PP14038535", "email_address": "", "orcid_id": ""}, {"name": "Eduardo Casais", "author_profile_id": "81100630914", "affiliation": "Forschungszentrum Informatik, Haid-und-Neu-Strasse 10-14, 76131 Karlsruhe, Germany", "person_id": "P74929", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260276", "year": "1995", "article_id": "260276", "conference": "OOPSLA", "title": "Workshop on object-oriented legacy systems and software evolution", "url": "http://dl.acm.org/citation.cfm?id=260276"}