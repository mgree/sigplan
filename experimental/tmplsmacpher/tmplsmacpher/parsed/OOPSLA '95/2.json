{"article_publication_date": "10-01-1995", "fulltext": "\n Static typing* Bertrand Meyer ISE Inc. 270 Storke Goleta, CA <meyer@eiffel.com>, Every once in a while, \nin the history of science, there arises a problem whose statement is so deceptively simple as to fit \nin a few sentences that a curious adolescent can understand, and whose solution baffles the best minds \nof a generation. It is of such a problem, central to the understanding and use of object-oriented principles, \nthat I propose to present both the statement and a solution. The simplicity of the problem comes from \nthe simplicity of the object-oriented model of computation, introduced almost thirty years ago by Professors \nDahl and Nygaard. If one puts aside the details of an object-oriented language, necessary to write realistic \nsoftware but auxiliary to the basic model, only one kind of event ever occurs during the execution of \nan object-oriented system: routine call. In its general form it may be written, using the syntax of Simula \nand Eiffel, as meaning: execute on the object attached to x the operation J; using the argument arg, \nwith the understanding that in some cases arg stands for several arguments, or no argument at all. Our \nSmalltalk friends would say pass to the object x the message f with argument arg , and use another syntax, \nbut those are differences of style, not substance. At run time, this is what our systems do: calling \nfeatures on objects, passing arguments as necessary. That everything relies on this canonical scheme \naccounts in part for the general feeling of beauty that object-oriented ideas arouse in many people. \n Road Suite 7 93117 (USA) http://www.eiffel.com From the simplicity of the model follows the simplicity \nof the typing problem, whose statement miirrors the structure of the Basic Construct: The typing problem \nWhen, and how, do we know that: tppiicable rvg is an feature corresponding to the object? acceptable \nargument to fand for that The policy known as static typing, which I will argue is the only reasonable \none for professional software development, states that we should answer the when part of the question \nby before we ever think of running the system , and the how part by through mere examination of the software \ntext . Let us make the terminology precise. x will be called an entity; this is a generalization of the \ntraditional notion of variable. f will, in interesting cases, be a routine; Smalltalk would call it a \nmethod, but there is no need for a new term since the older one is well established. At run time the \nvalue of x, if not void, will be attached to a certain object, OBJon the figure. *This article reproduces \nthe text of the author s OOPSLA keynote address. That it is the transcript of a verbal presentation explains \nthat it does not have all the usual trappings of a scientific article and makes generous use of the first \nperson singular. The final part of the speech (general comments about the respective roles of technical \nand methodological work, about OOPSLA, and about the current state of development of Eiffel) has been \nremoved but is available from the author. See also the Web page. Austin, TX October H-19,1995 Listeners \nalready familiar with the issues of typing will perhaps appreciate a preview of the conclusion. It can \nbe expressed in reference to a conjecture that Pierre America from Philips Research Laboratories expressed \nin a panel on the topic at TOOLS EUROPE a few years ago. America stated that three properties are desirable: \nstatic typing, substitutivity, and covariance; his conjecture is that one can achieve at most two of \nthem. The aim of the present work is to disprove the America conjecture and show that we can enjoy static \ntyping and covariance while preserving substitutivity when it is needed and safe. If you do not completely \nunderstand these terms do not worry; they will be explained shortly. Starting now with the basic concepts \nwe must first make sure to avoid any misunderstanding. Beginners with a Smalltalk background sometimes \nconfuse static q@zg with static binding. Two separate questions are involved. Typing, as noted, determines \nwhen to check that the requested routine will be applicable to the requested object; binding determines \nwhat version of the feature to apply if there is more than one candidate. Zower~hnding~ear++ * deferred \n + effected ++ redefined For example in the hypothetical inheritance hierarchy shown on the preceding \nfigure, we might define the feature lower-landingxear only at the level of PLANE, not at the general \nlevel of AIRCRAFT. Then for a call of the form my-aircraft. lower-landingsear two separate questions \narise: when to ascertain that there will be a feature lower-landingsear applicable to the object; and, \nif there is more than one, which one to choose. The first question is the typing question, the second \nis the binding question. Both answers can be dynamic, meaning at execution time, or static, meaning before \nexecution. For safety, flexibility and efficiency, the proper combination is, I believe, the Eiffel one: \nstatic typing and dynamic binding. Static binding, which if I understand properly is the default C++ \npolicy, would mean that we disregard the object type and believe the entity declaration, leading us for \nexample to apply to a Boeing 747-400 the version of a feature, such as lower-Zandingsear, that has been \ndefined for the standard Boeing 747 planes. This does not seem right, so we should choose dynamic binding, \ndefined simply as applying the right feature. Dynamic binding, as many of you know, is crucial in ensuring \nthe decentralized, evolutionary system architectures made possible by the object-oriented method. Except \nwhen it has the same semantics as dynamic binding -and that is a property best left for an optimizing \ncompiler to ascertain -static binding is always wrong; dynamic binding, as in Eiffel and Smalltalk is \nalways the proper policy. (C++ developers can obtain dynamic binding for specific features, but only \nby declaring them explicitly as virtual .) The cost of dynamic binding can be extremely small with a \ngood compiler and a supporting language design (in which, incidentally, static typing will help tremendously, \nas it does for compiling Eiffel). Dynamic binding does not imply dynamic typing. Typing is about something \nelse: when to determine that there will be at least one feature applicable to the object. Dynamic typing, \nas in Smalltalk, means waiting until the execution of the feature call to make that determination. Static \ntyping, as in Eiffel, means performing the check before any execution of the software; typically, this \nwill be part of the verifications made by a compiler. It is hardly necessary to emphasize the importance \nof static typing. Anyone concerned with software reliability knows how much more expensive it is to detect \nerrors late in the lifecycle. This is confirmed quantitatively by Barry Boehm s well-known studies (see \nSoftware Engineering Economics, Prentice Hall, 1981): 1000+ I . Require- Design- Code Develop-- Accep-- \nOpera-- ments tance tion ment test test This insistence that the language should permit static type \nchecking is one of the major differences between Eiffel and Smalltalk, and the Smalltalk policy is one \nof the reasons why I am always skeptical about using Smalltalk for serious industrial developments. After \nall, run time is a little late to find out whether you have a landing gear. For static type checking \nto be possible, the language must be designed accordingly. Here are the basic rules as they exist in \nEiffel, which at first sight seem to allow a compiler, global or incremental, to ascertain type safety. \nSimplifying a little, there are three rules; one applies to declarations, the second to feature calls, \nand the third to attachments, that is to say assignments and argument passing. First, we require that \nevery entity be declared with a certain type:  Declaration rule Every entity must be declared as being \nof a 1 certain type. For example: x: AIRCRAFT; n: INTEGER ; bal: BANK-ACCOUNT Only to the inexperienced \nwill this appear to be constraining. Seasoned software engineers know that software written once is read \nand rewritten many times, and that the small effort of declaring the type of every entity is generously \nrepaid by the readability that such declarations bring to the software text. Next, for what we have called \nthe basic operation of object-oriented computing, we require that any feature call use a feature that \nexists in the base class of the target X: Call rule If a class C contains the call x.f (..*) there must \nbe a feature of name f in the base class of the type of X, and that feature must be available (exported) \nto C. This is easy to determine thanks to the preceding rule, which causes the type of x to be known \nclearly and unambiguously to anyone who reads the class text. The base class of a type defines the applicable \nfeatures. A non-generic class is both a type and its base class, but the distinction is needed when we \nconsider generic classes: LIST [INTEGER] is a type, with LISTas its base class. Finally, we have a rule \nregarding attachment: for any assignment of an expression y to an entity x, the type of y must be compatible \nwith the type of ?c. argument passing, the base class of the type of y must be a descendant of that of \nx. In a classical language such as Pascal or Ada, we would require identical types. Thanks to inheritance \nthe compatibility requirement is more flexible here: the type ofy may be any descendant, in the sense \nof inheritance between the base classes, of the type of x. The same rule applies to the case in which \nx is a formal argument to a routine andy is the corresponding actual argument in a call. The term attachment \ncovers both cases -assignment and actual-to-formal association. In a simple world these rules would suffice. \nThey are easy for a software developer to understand, and easy for a compiler to implement. In particular, \nthe compiler can check them incrementally. One of the achievements of ISE s Eiffel compiler development, \nknown as the Melting Ice technology, has been to show that it is possible to guarantee type checking \nand efficient code generation, as in compiled environments, while avoiding the long edit-compile- link-execute \ncycles traditionally required in such environments; using Eiffel, one can get the fast turnaround that \npeople have come to associate with Lisp and Smalltalk while preserving efficient code generation and \nstatic typing. Even for systems of hundreds of thousands of lines, the time to recompile after changing \na few classes is typically a few seconds, including the time for full type checking. Strangely enough, \none encounters objections to the static typing approach. These objections do not hold on further examination, \nbut they do highlight the set of properties that must be satisfied by a realistic use of static typing. \n First, the type system must have no loopholes. There is no such thing as a little bit statically typed \n(as in the famous a little bit pregnant ). Either the language is statically typed or it is not. The \nC++ approach, where you can still cast- that is to say convert- a value into just about any type, defeats \nin my view the principle of static typing. For one thing, it makes garbage collection, a required component \nof serious object-oriented computing, very difficult if not impossible. Second, a statically typed language \nrequires multiple inheritance. The objection against typing often heard from people with a Smalltalk \nbackground is that it prevents one from looking at objects in different ways. For example an object of \ntype DOCUMENT might need to be transmitted over a network, and so will need the features associated with \nobjects of type MESSAGE.  LABLE_ DOCUME 0 But this is a problem only in languages such as Smalltalk \nthat do not permit multiple inheritance. Multiple inheritance, of course, must be handled properly, with \nmechanisms as in Eiffel for taking care of name clashes, conflicting redefinitions, and potential ambiguities \nin repeated inheritance. I mention this because one still encounters people who have been told that multiple \ninheritance is tricky or dangerous; such views are usually promoted by programmers using languages that \ndo not permit multiple inheritance, and are about as convincing as opinions against sex emanating from \nthe Papal nuncio. Next, static typing requires genericity, so that we can define flexible yet type-wise \nsafe container data structures. For example a list class will be defined as class LIST [G] . . . Genericity \nin some cases, needs to be constrained, allowing us to apply certain operations to entities of a generic \ntype. For example if a generic class VECTOR has an addition operation, it requires an addition also to \nbe available on entities of type G, the generic parameter. This is achieved by associating with G a generic \nconstraint NUMERIC: class VECTOR [G --> NUMERICJ . . . meaning that any actual generic parameter used \nfor VECTOR must be a descendant of this class NUMERIC, which has the required operations such as plus \nand minus . We also need a mechanism of assignment attempt. This makes it possible to check that a certain \nobject, usually obtained from the outside world, for example a database or a network, has the expected \ntype. The assignment attempt x ?= y will assign to x the value of y if it is of a compatible type, but \notherwise will make x void. This instruction (which has been made available to other languages under \nthe name type-safe downcasting) is one of the inventions of which the Eiffel community can be proudest. \nAlso necessary are assertions, associated, as part of the idea of Design by Contract, with classes and \nfeatures. Assertions, directly associated with object-oriented constructs in the form of preconditions, \npostconditions and class invariants, make it possible to describe the semantic constraints which cannot \nbe captured by type specifications. Finally, a realistic object-oriented type system will require two \nmechanisms that will be described in more detail shortly: covariance, which governs how we can redefine \nthe signatures of routines, and anchored declarations, of the form y: like x which avoid endless type \nredeclarations. Ideally, a presentation of typing should stop here. Unfortunately, the combination of \nstatic typing with other requirements of the object-oriented method makes the issues more difficult than \nthey appear at first. The principal problem is what happens when we redefine a feature s type. To accompany \nthe discussion it will be convenient to use the example hierarchy shown here, applying to a high-school \nski team preparing for a trip to a minor-league championship. For brevity and simplicity we use the class \nnames GIRL as an abbreviation for member of the girls ski team and BOY as an abbreviation for member \nof the boys ski team . Some skiers in each team are ranked, that is to say have already recorded good \nresults in earlier championships. This is an important notion: ranked skiers will start first in a slalom, \ngiving them a considerable advantage over the others; after too many competitors have used it, the run \nis much harder to negotiate. (This rule that ranked skiers go first is a way to privilege the already \nprivileged, and may explain why skiing holds such a fascination over the minds of many people: that it \nserves as an apt metaphor for life itself.) This yields two new classes, MNKED_GIRL and RANKED-BOY To \nassign the rooms we may use a parallel hierarchy; some rooms will be reserved for boys only, girls only, \nor ranked girls only. Here is an outline of class SKIER:  class SKIER feature roommate: SKIER; --This \nskier s roommate share (other: SKIER) is --Choose other as roommate. require other I= Void do roommate \n:= other  end . . . end --class SKIER We have two features of interest: the attribute roommate, shown \nin blue; and the procedure share, which makes it possible to assign a certain skier as roommate to the \ncurrent skier. Note the use of Eiffel s assertions: the require precondition stating that attached to \nan object. clause the argu introduces ment must a be A typical call, as in sl, ~2: SKIER; . . . sl . \nshare (~2) will enable us to assign a certain roommate to a certain skier. How does inheritance get \ninto the picture? Assume we want girls to share rooms only with girls, and ranked girls only with other \nranked girls. We will redefine the type of feature roommate, as shown below (in this class text and the \nnext, the redefined elements appear underlined). class GIRL inherit SKIER redefine roommate end  feature \nroommate: GIRL: --This skier s roommate. . . . end --class GIRL We should correspondingly redefine the \nargument to procedure share, so that a more complete version of the class text is: class GIRL inherit \nSKIER redefine roommate, share end  feature roommate: GIRL* --Thzlr s roommate. share (other: GIRL) \nis --Choose other as roommate. require other /= Void do roommate := other end end --class GIRL Addendum \nto the Proceedings OOPSLA The general picture is this: roommate: SKIER share (other: SKIER) roommate \nshare+ + t   fg?F roommate+ + share+ + ++, a B.O.N. notation (see Kim WaldCn and Jean- Marc Nerson, \nSeamless Object-Oriented Software Architecture, Prentice Hall, 1994), means redefined . Since inheritance \nis specialization, the type rules naturally require that if we redefine the result of a feature, here \nroommate, the new type must always be a descendant of the original one. We should correspondingly redefine \nthe type of the argument other of routine share. This is the policy known as covariance, where the co \nindicates that the argument and result vary together. The reverse policy is termed contravariance. I \nbelieve that this terminology was introduced by Luca Cardelli. Strangely enough, some workers in the \nfield have been advocating a contravariant policy. Here it would mean that if we go for example to class \nRANKED-GIRL, where the result of roommate is naturally redefined to be of type RANKED-GIRL, we may for \nthe argument of routine share use type GIRL, or, rather scaringly, SKIER of the most general kind. One \ntype that is never permitted in this case is RANKED-GIRL! Here is what, under various mathematical excuses, \nsome professors have been promoting. No wonder teenage pregnancies are on the rise. As far as I understand, \nby the way, the C++ policy is to bar any type redefinition -novariance as it is sometimes called. If \nthis is indeed the rule I do not think that it is appropriate. 95 Covariance, of course, is not without \nits problems. Before looking at them we should examine a fundamental simplification. It is extremely \ntedious to have to redefine share the way we did in class GIRL. This redefinition only changes the type \nof the argument other; the rest of the routine, assertions and body, is just replicated. Anchored declarations, \nanother Eiffel original, address this problem. In class SKIER we can prepare for such redefinitions by \ndeclaring other as being of type like roommate. This is the only difference with the previous version: \nclass SKIER feature roommate: SKIER; --This skier s roommate. share (other: like roommate) is --Choose \nother as roommate. require other /= Void do roommate := other end . . . end --class SKIER  Such a like \ndeclaration, known as an anchored declaration, means that other is treated in the class itself as having \nthe same type as the anchor, here SKIER; but in any descendant that redefines roommate then other will \nbe considered to have been redefined too. One can say without fear of exaggeration that without anchored \nredeclarations it would be impossible to write realistic typed object-oriented software. But what about \nthe problems of covariance? They are caused by the clash between this concept and polymorphism. Polymorphism \nis what makes it possible to attach to an entity an object of a different type. It is made possible by \nthe attachment rule introduced earlier: in the assignment x := y, the type of y may be a descendant of \nthat of x. But with covariance this may get us into trouble. Assume we have entities sl of type SKIER, \nbl of type BOY and gl of type GIRL; the names should be mnemonic enough: sl: SKIER ; bl: BOY; gl: GIRL \n In creation instructions, marked with double exclamation marks !!, we create two objects of types BOY \nand GIRL and attach them to bl and gl respectively: !! bl ; !! gl; Polymorphism allows us to let sl \nrepresent the same object as bl: sl := bl Then the feature call sl .share (gl) achieves what all of \nus boys always dreamed of in high school, and what all parents fear. A similar problem arises out of \na very important inheritance mechanism: descendant hiding, the ability for a class not to export a feature \nthat was exported by one of its parent. A typical example is a feature add-vertex, which class POLYGON \nexports RECTANGLE hides, because invariant of the class: but its it would descendant violate the class \nRECTANGLE POLYGON inherit export (NONE} end add-vertex feature  invariant vertex-count = 4 end Austin. \nTX October E-19,1995 The invariant is expressed here in Eiffel syntax as vertex-count = 4. Another well-known \nexample, more academic in nature, is a class OSTRlCH that inherits from a class BIRD that was equipped \nwith a routine$y. Clearly OSTRICH should not export that routine. I should note in passing that some \npeople criticize such practices as incompatible with a good use of inheritance. They are wrong. It is \na sign of the limitations of the human ability to comprehend the world -similar perhaps to undecidability \nresults in mathematics and uncertainty results in modern physics -that we cannot come up with operationally \nuseful classifications without keeping room for some exceptions. Descendant hiding is the crucial tool \nproviding such flexibility. Hiding add-vertex from RECTANGLE or fly from OSTRICH is not a sign of sloppy \ndesign; it is the recognition that other inheritance hierarchies that would not require descendant hiding \nwould most likely be more complex and less useful. Like covariance, then, descendant hiding is made necessary \nby the modeling requirements of the object- oriented method. But like with covariance this modeling power \ncauses a conflict with the tricks made possible by polymorphism. An example is trivial to build: p: POLYGON; \nr: RECTANGLE ; . . . !! r ; ,.. p := r ; . . . p . add-vertex (. . .) The simplicity of these examples \nmakes up what we may call the static typing paradox. A student can make up a counter-example showing \na problem with covariance or descendant hiding in a few minutes; yet Eiffel users universally report \nthat they almost never run into such problems in real software development. This is certainly confirmed \nby ISE s own practice, even though the ISE Eiffel environment represents about half a million lines of \nEiffel and about 4000 classes. But of course this does not relieve us from the need to find a theoretical \nand practical solution. The problem was first spotted by several people in 1988 and has been discussed \nseveral times in the literature. William Cook described it in a paper at ECOOP 1989. At TOOLS EUROPE \n1992 in Dortmund, Franz Weber proposed a solution based on adding a generic parameter for each problematic \ntype. In chapter 22 of the book Eiffel: The Language (Prentice Hall, 1992, the current Eiffel language \nreference), a solution was described which is based on determining the set of all possible dynamic types \nfor an entity. So we would for example find out that sl can have BOY among its dynamic types and hence \ndisallow the call sl .share (gl). This approach is theoretically correct but has not been implemented \nsince it requires access to the entire system; so rather than a mechanism to be added to an incremental \ncompiler it is a kind of lint that should be applied to a finished system. Incremental algorithms seem \npossible (an ISE report described one a few years ago), but they have not been fully demonstrated. The \nnew approach that I think is the right one is paradoxical in that it is more pessimistic than the earlier \none. In general, typing is pessimistic. To avoid some possibly failed computations, you disallow some \npossibly successful computations. In Pascal, for example, assigning 0.0 to an integer variable IZ would \nalways work; assigning 1.0 would probably work; assigning 3.67 would probably not work; but assigning \n3.67 -3.67 would actually work. Pascal cuts to the essentials by disallowing, once and for all, any assignment \nof a floating-point value to an integer variable. This is a pessimistic but safe solution. The question \nis how pessimistic we can afford to be. For example we can have a guaranteeably safe language by disallowing \neverything, but this is not very useful. What we need is a pragmatic assessment of whether the type rules \ndisallow anything that is indispensable to real programs. In other words a set of typing rules should \nbe sound and useful. Sound means that every permitted text is safe. Useful means that every desirable \ncomputation can still be expressed (reasonably simply) without a violation of the type rules. I believe \nthat the rules which follow satisfy these two properties of soundness and usefulness. I would need a \nlittle more time to explain the details of the rules here but I will try to give you the gist. The full \nrules may be found on the Web at http://www.eiffel.com. Follow the link to Full type rules for the OOPSLA \ntalk . Workshops to discuss the underlying issues will be held at forthcoming TOOLS conferences (in particular \nat TOOLS EUROPE in Paris, 26-29 February 1996) and the complete discussion will be in the second edition \nof the book Object-Oriented Software Construction. The two basic notions are polymorphic entity and catcall \n. Definition: Polymorphic entity 1 An entity x is polymorphic if it satisfies one of 1 the following \nproperties:  It appears in an assignment x := y where y is of a different type or (recursively) polymorphic. \n It is a formal routine argument.  It is an external function. I I Informally, an entity is polymorphic \nif it can be attached to objects of more than one type. The basic case, the first in the definition, \nis when the entity appears as target of an assignment whose source is of a different type or, recursively, \npolymorphic. We also consider -this is the second case in the definition, and very important although \nvery pessimistic -that any routine argument is polymorphic, because we have no control over the actual \narguments in possible calls; this rule is closely tied to the reusability goal of object-oriented software \nconstruction, where an Eiffel class is intended, eventually, to be included in a library where any client \nsoftware will be able to call it. A call is polymorphic if its target is polymorphic. Next, a routine \nis a CAT (Changing Availability or Type) if in a descendant class some redefinition of the routine makes \na change of one of the two kinds we have seen as potentially troublesome: retyping an argument (covariantly), \nor hiding a previously exported feature. A call is a catcall if some redefinition 28 Austin, of the \ncalled routine would make the invalid because of such a change. I  Definition: Catcall A routine is \na CAT (Changing Availability or Type) if some redefinition changes its export status or the type of one \nof its arguments. A call is a catcall if some redefinition of the routine would make it invalid because \nof a change of export status or argument type. If we look back at our examples we see that they involve \ncatcalls on polymorphic entities, also known as polymorphic catcalls, marked ** below: sl: SKIER ; bl: \nBOY;gI. GIRL ; ... !! bl ; !! gl ; ... sl := bl ; sl .share ( gl) --** p: POLYGON; r: RECTANGLE ; ... \n!! r ; ... p := r ; ... p . add-vertex (...) --** Polymorphic calls are of course permissible; they \nrepresent some of the most powerful mechanisms of the object-oriented method. Catcalls are also desirable; \nthey are, as we saw, necessary to obtain the flexibility and modeling power that can be expected from \nthe approach. TX October E-19,1995 But we cannot have both. If a call is polymorphic, it must not be \na catcall; if it is a catcall, it must not be polymorphic. Polymorphic catcalls will be flagged as invalid. \nIlh  c i61 Polymorphic catcalls are invalid If you remember the America conjecture, we of course do \nnot sacrifice static typing; we do not sacrifice covariance; and we do not sacrifice substitutivity, \nthat is to say polymorphic assignments of a more specialized value to a more general entity, except in \ncases in which they would clash with the other rules. As evidenced by the practical Eiffel experience \nthat was mentioned earlier, such clashes are very rare; they are signs of bad programming practices and \nshould be banned. So this is the type rule: a prohibition of polymorphic catcalls. This rule is similar \nto the one in Ez@Z: The Language but much, much simpler because it is more pessimistic. It is checkable \nincrementally: a violation will be detected either when an invalid call is added or when an invalid redefinition \nis made. It is also checkable in the presence of precompiled libraries whose source is not available \nto users. As a complement it is useful to show the robustness of this solution by giving a technique \nwhich will answer a common problem. Assume that we have two lists of skiers, where the second list includes \nthe roommate choice of each skier at the corresponding position in the first list. We want to perform \nthe corresponding share operations, but only if they are permitted by the type rules, that is to say \ngirls with girls, ranked girls with ranked girls and so on. This problem or similar ones will undoubtedly \narise often. An elegant solution, based on the preceding discussion and assignment attempt, is possible. \nThis solution can be implemented in Eiffel right now; it does not require any language change. We will \npropose to the Nonprofit International Consortium for Eiffel (NICE), the body responsible for Eiffel \nstandardization, to add to class GENERAL a new Addendum to the Proceedings OOPSLA function jitted. GENERAL \nis a part of the Eiffel Library Kernel Standard, the officially approved interoperability basis; every \nEiffel class is a descendant of GENERAL. Here is the functionJitted (the name might change). fitted (other: \nGENERAL): like other is --Current if other is attached to --an object of exactly the same type; void \notherwise. do if other /= Void and then same-type (other) then Result ?= Current  end end Function \n@ted returns the current object, but known through an entity of a type anchored to the argument; if this \nis not possible it returns void. Note the role of assignment attempt. A companion function which examines \nthe types for conformance rather than identity, is easy to write. FunctionJitted gives us a simple solution \nto our problem of matching skiers without violating type rules. Here is the necessary routine match: \nmatch (~1, ~2: SKIER) is --Assign sl to same room as s2 --if permissible. local gender-ascertained-s2: \nlike sl do gender-ascertained-s2 := s2 .jitted (~1); if gender-ascertained-s2 /= Void then sl . share \n(gender-ascertained-s2) else Report that matching is impossible for sl and ~2 end end For a skier s2 \nwe define a version gender-ascertained-s2 which has a type anchored to sl. I find this technique very \nelegant and I hope you will too. And of course parents concerned with what happens during the school \ntrip should breathe a sigh of relief. 95 29  \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Bertrand Meyer", "author_profile_id": "81100570511", "affiliation": "ISE Inc., 270 Storke Road Suite 7, Goleta, CA", "person_id": "PP31088914", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260214", "year": "1995", "article_id": "260214", "conference": "OOPSLA", "title": "Static typing", "url": "http://dl.acm.org/citation.cfm?id=260214"}