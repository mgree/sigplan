{"article_publication_date": "10-01-1995", "fulltext": "\n Idiomatic design Andrew Koenig AT&#38;T Bell Laboratories Murray Hill, New Jersey 07974 Overview A \ndisturbing trend in software engineering is to advocate some particular kind of solution without even \nlooking at the nature of the problem. This trend goes the wrong way: well-designed solutions should take \ninto account not only the problem but also how the solution will be used, constraints that might exist \non the implementation, available languages, and even culture. Suit the action to the word, the word to \nthe action -Shakespeare  Introduction I cringe when I hear people talk about object-oriented design, \nbecause so rarely do they do so in the context of a specific problem. Design is part of a solution, not \na problem, so without mentioning a problem, the phrase object-oriented design is putting the solution \nfirst. Shouldn t the problem dictate the solution instead of the other way around? Indeed, a good design \nwill usually grow not just out of the problem but out of other things as well. We will call those things \nthe context of the problem and a design that takes context into account an idiomatic design. Here we \nuse idiomatic differently than the way the programming community uses the similar word idiom. The American \nHeritage Dictionary gives its primary definition of idiomatic as peculiar to or characteristic of a given \nlanguage and defines idiom as a speech form or expression peculiar to itself grammatically, or one that \ncannot be understood from the individual meanings of its elements. Programmers have come to treat as \nprimary the secondary definition of idiom: a specialized vocabulary or jargon used by a group of people. \nWhat we call a programming idiom might more accurately be called a programming cliche were it not for \nthe pejorative connotation of cliche. So we use idiom as an idiom-or at least idiomatically. Culture \nand context Idiomatic design is design that fits its context, language, and community. Most of us have \na pretty good idea of what it takes to fit a context or language, but what does it mean to fit the community? \nI recently learned about a telling example that appeared on an Internet mailing list devoted to Danish \nlanguage and culture. Someone asked: What is the Danish national bird? Within a few hours, replies had \ncome in from all over. Although the people who supplied the answers could not have talked to each other, \na mere two answers accounted for all the responses: . the herring; and . the rotisserie chicken. The \nnotion of a national bird is utterly alien to the Danish way of thinking, but the notion of enjoying \na good meal is not. Nor is the idea of giving a snappy answer to a silly question. Just as culture shapes \nour viewpoints, context should shape our thinking about software design. Programs are not only written \nbut read-and usually not just by their authors. Moreover, useful programs inevitably change to solve \nnew problems, which are also partly determined by context. Moreover, that context also includes tools \nused for implementation.  Examples We are often told to design first and only then to think about implementation, \nbut that advice can be too idealistic to be useful in practice. Designs that may initially seem independent \nof implementation may, on deeper inspection, depend on implementation characteristics that lie beneath \nthe surface. Sometimes these subterranean characteristics leak through into design so heavily that we \ncannot help but notice. Hardware constraints For example, system designers do not always have the ability \nto choose without restriction what hardware they will use. Instead they may have to take what is already \nthere or what fits within constraints imposed from outside. Even if the designers can afford to buy whatever \nhardware they want, the people who will use what they produce may not be so lucky. IBM 1620 loader One \nof the first original programs I ever wrote was a machine language loader for the IBM 1620. By today \ns standards, that computer was ridiculously small and slow: 60,000 decimal digits of main memory and \nabout a million digits of disk space. Instructions were twelve digits each, which meant that only six \nfull instructions could fit on an 80-column punched card. The loader read machine-language programs from \npunched cards into memory. To use it, one would punch the program into cards in some format, put a copy \nof the loader at the beginning of the deck, put the whole thing into the card reader, and press the RESET \nand LOAD buttons. Since a copy of the loader would precede every program, it was important for the loader \nitself to fit on as few cards as possible. That meant keeping the instruction count down-even to the \nextent of choosing a design that could be implemented in fewer instructions. The hardware constrained \nnot only the loader s implementation but also its design. Addendum to the Proceedings OOPSLA  Library \ncirculation system A few years later I got a close look at how the Columbia University library kept track \nof its books. That library is spread out all over campus, with books on particular subjects kept in the \nbuilding that houses the relevant school or departments. That raised the obvious question: how could \na library patron tell if a wanted book was on the shelf when that shelf was at the other end of campus? \nThe library administrators solved this problem with a paper circulation list. Every day they would print \nall the books they had on loan, where other copies might be found, and so on. That was about a hundred \nthousand lines of text, which took an hour and a half on a printer that could handle a thousand lines \na minute-usually while I was waiting for one of my own jobs to print. After printing the list, the library \nstaff would send a copy to six locations around campus. Why six? That was how many copies they could \nprint clearly with carbon paper. Had printers been much faster, the library could have afforded to print \nmultiple individual copies instead of using carbon-paper forms. Had printers been much slower, a daily \ncirculation list would be out of the question. This design of this particular circulation system therefore \ntook its particular form because its output device fell with a fairly narrow range of performance.  \nSoftware constraints Software choices can constrain design as much as hardware choices. One thinks of \nsoftware as being easy to change, but that is often not true in practice. Most computers can run only \none operating system at a time, for example, and choice of operating system can greatly constrain design. \nMoreover, although a particular piece of software may be available in principle, there may be pragmatic \nreasons not to use it. Student registration In 1976 I wrote the student registration system for the \nJohn Jay College of Criminal Justice, which is the part of the City University of New York that educates \nmost of the cops in the city. I wrote the system in APL, which is not exactly the first language that \njumps to mind when thinking about 95 15 student registration systems. I picked it for purely contextual \nreasons: It was to be a multi-user interactive system with enough clerks to handle 14,000 students during \n(one) registration week each semester. That meant I needed to start with a system that would handle a \nbunch of terminals simultaneously. The available hardware was an IBM mainframe, period. The university \nwas not about to install any new computers just for registering students at a single one of their schools. \nAt the time, only two systems were available on that machine that would support multiple interactive \nterminals: CICS and APL. Everything I had heard about CICS argued that a CICS project would not be a \none-person affair. Moreover, I was already thoroughly familiar APL. That clinched the decision.  Simulation \nIn southern Sweden stands the largest windmill I have ever seen. It has only two blades, but each one \nis well over a hundred feet long. I am told that when the windmill was first built, someone got the sign \nwrong in one of the equations for the control circuits. They discovered this when they first hooked it \nup to the power grid, at which time the windmill very briefly became a 35megawatt fan. Out of this experience \ngrew a desire to simulate such systems before building them. This desire bore fruit at the Lund Institute \nof Technology, where members of the Department of Automatic Control decided to build a software system \nfor simulating things like wind power plant controllers. The authors started with a desire for that system \nto be as widely used as possible. They did a hardware survey, which revealed that most of their likely \nused Sun workstations equipped with the X window system. Next they found that at the time there was one \nsoftware tool, called Interviews, that ran on the Sun and could greatly simplify application development \nunder X. Interviews, in turn, was written in C++, so they wrote their system in C++. Again the context \ndictated the choice of programming language. The specific merits or demerits of the language had nothing \nto do with it. Instead, what forced the decision was which user community had produced the most useful \ntools for their purposes. Editing the C++ standard One thing that occupies much of my time is working \non the evolving Cc+ standard. That standard takes the form of a document that at present is slightly \nmore than seven hundred pages long and is substantially changed three times a year. That is too much \nwork for one person to do alone. Fortunately I get lots of help from other committee members. I send \ncopies of the document all over the world by electronic mail and get back changes the same way. I read \nthose changes, add my own to them, and combine it all to form the next version of the document. Many \npeople might consider ancient the software tools I use for that purpose: trof f, dif f, patch, and an \nassortment of shell scripts and Awk programs. There is probably something out there that in principle \ncould make my life much easier: maybe something combining a WYSIWYG (What You See Is What You Get) text \neditor, a difference engine, a database, and various networking tools. But any effort to introduce such \na tool would meet with pragmatic resistance: it might be too expensive; it might not run on the machines \nsome of my collaborators use; it might be too much work to convert the existing trof f text; I might \nnot be able to get working some of the tools that massage the text to produce the grammar appendix automatically; \nand so on. This last problem is often underrated. WYSIWYG editors can be wonderful to use, but when you \nwant one to do something a little beyond the capabilities designed into it, the result can be a nuisance. \nThen WYSIWYG becomes WYSIAYG (What You See Is All You Get).  Theory vs. practice Another kind of feedback \nfrom implementation to design happens when abstractions break down. Most notions of good design rely \non some kind of abstraction, which means that abstraction failure can complicate design and not just \nimplementation. Two kinds of abstraction failure often constrain design, One is so widespread that just \nmentioning it is enough, namely the problem of writing computationally accurate programs. To convince \nyourself that this is a problem, try adding the three values 1030, -103 , and 1. On most computers, the \nresult will depend on the order in which you add them. Then think about how you might write a program \nto do something as simple as adding n numbers to obtain the most accurate result possible. Of course, \nthere is a field that has dealt with such problems for many years, namely numerical analysis. More recently, \nhowever, another kind of abstraction failure has become important, namely that the machine itself might \nnot work as expected. Programs that can deal with this kind of abstraction failure are usually called \nfault tolerant; the need for fault tolerance can permeate both implementation and design. Newspaper publication \nI read an article many years ago, so long ago that I do not remember for sure where or when it appeared. \nIt might have been Computing Surveys. The article described a system for typesetting a newspaper and \nsaid that the entire system was based on two assumptions: . It is inconceivable that for any reason \nwhatsoever the newspaper should ever fail to be produced. . The presses start rolling at a predetermined \nabsolute time, no matter what. This, of course imposed severe design constraints to ensure that various \nkinds of failures did not jeopardize the newspaper or its schedule. What if the machine room catches \nfire? There had better be another one somewhere else to use as a backup. The database had better be designed \nso that if it crashes, it does so in a way that does not lose news stories. And so on. Most of these \nthings were cases where the kinds of abstractions we prize as software engineers simply don t account \nfor the complexity of the environment in which the system must operate. Switching systems An even more \nextreme example of how abstraction failure complicates design is telephone switching systems. Such systems \nhave reliability requirements that few others ever face. Three minutes a year of down time from all causes \ncombined is a typical requirement. To achieve that reliability, about nine-tenths of the code in a typical \nswitching system is devoted to error recovery. All hardware is assumed untrustworthy, even the processor \nitself. There are audit routines for each data structure that check constantly whether that data structure \nhas become corrupted and rebuild it if so. This attention to error conditions complicates every aspect \nof the system enormously, but that is the only way known so far to achieve the required reliability. \n Operating system effects Most programs do not communicate directly with the underlying hardware. Instead \nthey use an operating system as an intermediary. Sometimes an operating system will make particular things \neasy or hard to an extent that influences the design of the applications that use it. An obvious example \nof this is windowing operating systems. The structure of such systems dominates all kinds of application \nprograms. But there were other examples long before such systems came onto the scene. For example, the \nUnix system acquired pipes fairly early in its history. By making it easy to connect one process to another, \npipes encouraged in its application programs a kind of modularity that had been foreign until then. People \nstarted writing application programs with an eye toward being able to use their output directly as input \nto other programs. A whole style of programming grew up that surely would not have come about otherwise. \n Programming language effects It is not just operating systems that act as intermediaries between designers \nand the machines they use. Programming languages impose their own view as well. It is true that all nontrivial \nprogramming languages are equivalent, in the sense that they are all Turing complete. But that is just \ntheory. In practice, every language makes some Addendum to the Proceedings OOPSLA 95 things easy and \nothers difficult. A design that ignores this fact will have an uphill battle all the way. Static vs. \ndynamic typing One of the least subtle language characteristics to affect design is whether the language \nis strongly typed at compile time. This effect is particularly easy to notice when dealing with containersaata \nstructures that hold collections of values. Languages with strong static typing usually include the type \nof container elements as part of the type of the container. Thus C++ has container types like list<string> \nand ML has container types like string list. In contrast, dynamically typed languages like Lisp and Smalltalk \nwill have types like list; it is not the compiler s concern what types of values the user puts in such \na container. There are two world views at odds here. The dynamic view simplifies the program: there are \nno extraneous types to worry about. Moreover, the dynamic vies is more flexible: the compiler will never \nrefuse to compile your program just because you are doing something that might be dangerous. But the \nstatic view has advantages too. Tracking types during compilation can avoid a lot of run-time overhead, \nmake it possible to specify interfaces more completely, and detect errors earlier. Moreover, static typing \noften causes less trouble for programmers than it might seem at first: much run-time polymorphism is \nreally compile-time polymorphism in disguise. Whether or not element types appear as part of container \ntypes will surely affect design. In a language where they do appear, the designer will have to think \nabout them constantly to avoid specifying things in the design that fail to compile. If they do not appear, \nthe designer will still have to think about them constantly, because otherwise the design will result \nin an implementation that will compile but then fail to run. What will differ between the two kinds of \nlanguages is where in the design that thought becomes evident and what kind of design influence it will \nhave. Traversals As a more subtle example of language affecting design, consider how one might traverse \na container-that is, access all the container s elements in some predetermined order. There are several \npossible approaches; which one is best in a particular language depends on which one best fits that language \ns abstract machine. For example, one possibility is to use a callback function. This is a function that \none passes as an argument to the traversal program. The traversal program then calls the function for \neach element of the container. Handling callback functions smoothly pretty much requires a language that \nsupports nested functions. Smalltalk, Lisp, and Pascal support this approach well. Because C and C++ \ndo not support nested functions, they handle callback functions much less well. For example, we would \nlike to be able to write something like this in C: { int sum = 0; void accum(int n) { sum += n; } for-each(container, \naccum); 1  Unfortunately, without nested functions, the only way to do that is if sum is a global variable. \nFor this reason, C++ libraries typically adopt one of two approaches. One approach is to define objects \nthat act like functions. Naturally enough, such things are calledfunction objects. By using function \nobjects instead of callback functions, it is possible to avoid global variables at the cost of having \nto define the objects. This approach fits the C++ abstract machine somewhat better but is still usually \nless than ideal. It is possible to obtain a much better fit to the C++ abstract machine through a completely \ndifferent approach to container traversals. The idea is to define an abstract datatype called an iterator \nthat represents a place in a container. Then one writes a loop that uses an iterator to access the container \nelements, along these lines: for (iter i = cont.first(); !i.eof(); i.advance()) // .. .  This works \nwell in many contexts. However, it has the disadvantage that the call to i . eof ( ) makes it impossible \nto use a built-in type as an iterator. That means that built-in arrays must be handled differently from \nuser-defined container types. The fit to the C++ abstract machine is still not quite right. We can make \nthe fit even better by defining iterators that are conceptually compatible with pointers to array elements. \nThis leads to separate iterators for the beginning and end of a range: for (iter = i cont.begin(); i \n!= cont.end(); ++i) { // ...  That makes it possible for the test for the end of a container to be compatible \nwith the built-in ! = operator on pointers rather than a call to a function of a kind that pointers do \nnot support. Because this last approach fits the C++ abstract machine so well, we can write a single \ntemplate function that will work both for built-in arrays and user-defined container types with iterators: \ntemplate<class It, class X> It find (It begin, It end, X x) while (begin != end &#38;&#38; *begin != \nx ++begin; return begin; The compatibility between the iterator type and the underlying abstract machine \nmakes it all work.  Other language viewpoints Different languages yield different best designs. Each \nlanguage has its advantages and disadvantages. In addition to the typing and abstract machine issues, \nhere are some other comparisons one might make between programming languages. Do you want your language \nto be . interactive or packagable? . portable or integrated? . open or supported? Here I have deliberately \nchosen words that are slanted towards the particular viewpoint that word expresses. Each of these issues \nis a source of controversy in some part of the programming community, partly because advocates of one \nextreme do not (or cannot) consider the alternatives. There are more general decisions as well. Do we \nwant our programs to be 0 iterative or recursive? . object-oriented or functional? These and other language \naspects can all influence design. Moreover, we can debate any of them endlessly. Fortunately, we don \nt have to.  Summary Every problem has a context, which can include . community and culture; . implementation \nconstraints; . language and system; and probably other things too. A good design will take its context \ninto account. If the culture demands it, that may mean, for example, using object-oriented techniques \nwhere they don t really apply or not using them in a case that seems to cry out for them. It may mean \nchoosing a programming language without regard for its usual advantages or disadvantages. It may mean \nusing a set of tools that some people may find cumbersome or outdated, It may call for all kinds of things \nthat may seem nonsensical when viewed in isolation. But software systems do not exist in isolation. They \nwould not be systems if they did. Any useful system must take its context into account. Unless we can \nanswer the question Good for what? we cannot say whether or not a design is good. OOPSLA 95 Addendum \nto the Proceedings  \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Andrew Koenig", "author_profile_id": "81100327529", "affiliation": "AT&T Bell Laboratories, Murray Hill, New Jersey", "person_id": "P18072", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260210", "year": "1995", "article_id": "260210", "conference": "OOPSLA", "title": "Idiomatic design", "url": "http://dl.acm.org/citation.cfm?id=260210"}