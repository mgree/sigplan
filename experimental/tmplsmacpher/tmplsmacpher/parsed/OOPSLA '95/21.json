{"article_publication_date": "10-01-1995", "fulltext": "\n Workshop Summary: Patterns for Decision Making in Architectural Design Reported by: Gerard Meszaros \nWorkshop Organizers: Bruce Anderson, Gerard Meszaros e-mail: bruce~anderson@uk.ibm.com, gerard@osgcorp.com \nAbstract This contribution describes the OOPSLA-95 workshop entitled Patterns in Architectural Decision \nMaking. In Part 1, we describe the process we followed during the workshop. In Part 2, we describe some \nof the key work-products of the workshop including an overview of the common process the workshop participants \nfollow, as well as a number of common Architecture Patterns discovered in the participants submissions. \n 1. WorkShop Summary 1.1 Goals &#38; Objectives The primary goal of this workshop was to find out how \nsoftware system architects make decisions as they go about architecting a system. We hoped to capture \nwhat we learned in the form of a pattern language. In the course of learning and recording this information, \nwe hoped to meet interesting people and have fun. All of these objectives were achieved! We were very \npleased with both the quality and quantity of architectural patterns captured by the group during the \nworkshop. The participants expressed a keen interest in continuing the work at OOPSLA 96 and in the interim \nvia the Internet. 1.2 Workshop Prerequisites Prospective participants were asked to submit a description \nof experiences they had had while architecting systems and/or a description of how they make decisions \nwhile architecting systems. Contributions in the form of a pattern language were especially welcomed. \nRoughly half the submissions received were in the form of a pattern language. 1.3 Workshop Participants \nBruce Anderson IBM EMEA Object Technology Practice William Beshilas SHL Systemhouse Lmrie Boyd American \nManagement Systems Richard Demers Shamrock Computer Resources Jim Doble Bell Northern Research Chi-Hoi \nDuong AT&#38;T Wayne Hay-thorn Asha Keddy Clemson University Peter Long Gerard Meszaros Object Systems \nGroup Tom Mowbray Mitre Corporation Tom O Rourke Trecom Business Systems Joe Yoder U of Illinois Urbana-Champagne \n 2. Workshop Description 2.1 Background Patterns are a means to capture the knowledge and experience \nof experts for (re)use by those less expert. The patterns movement has taken a somewhat different approach \nto the subject of figuring out how to do something. Rather than speculate on what might work (and perhaps \ntry it out) and then write papers about it, pattern practitioners go out into the real world looking \nfor what has already worked. What they discover is captured in a relatively new literary form known as \npatterns. When the organizers of this workshop wanted to make some progress capturing how software systems \nshould be architected, patterns seemed an obvious choice. We invited practicing system architects to \njoin us at OOPSLA to discuss how they did their work so we could go about capturing common practices \nand learn from each other. This workshop is the latest is a series of OOPSLA workshops (dating back to \n1991) related to software architecture. While the earlier workshops can claim to have spawned the patterns \nmovement , this is the first in the series with an explicit objective of capturing patterns. 2.2 Mutual \nIntroductions The workshop started off with mutual introductions. Everyone paired off with someone they \ndidn t know and interviewed them for 5 minutes. After exchanging roles, we went around the group and \ntook turns interviewing each other. Our group had a diverse background with the only real common theme \nbeing that everyone was working on and interested in software architecture. 2.3 Questions about Architecture \nWe next spent some time brainstorming a list of Pressing Questions related to software architecture. \nThese questions are included later in this report. 2.4 Roles and Responsibilities of Architects Breaking \ninto two subgroups, we discussed the roles and responsibilities of software architects. Many of the people \nin the workshop played many roles back at work. By sifting through the myriad responsibilities, we isolated \nthe set of responsibilities which went with the role of Software System Architect from the responsibilities \nof the other roles many of us played. These other roles included: Project Manager, Quality Assurance \nPrime, Lead Implementer (AKA Technical Lead), Facilitator, Arbitrator, Negotiator, 00 Zealot, and Architecture \nChampion. Despite the highly varied backgrounds of the workshop participants, there appeared to be a \ncommon architecting process which emerged once the terminology was understood and the various other roles \nremoved. This common process consists of classifying decisions that must be made into a number of categories \nand ensuring that they are made at the right time by the right person. These categories are reproduced \nin the Workshop Results section of this report. While the workshop participants were of like mind on \nmany issues, there were strong differences of opinion with regards to the role of the architect in the \nimplementation of the system. The group was about equally split between those who felt that the architect \nshould transfer implementation responsibility to the teams who would build instances of the architecture, \nand those who felt that the architect should participate in the implementation of at least one of the \nsystems. Some of this difference in opinion could be attributed to the differences in perspective between \nthe participants who have architected medium to large systems, and those who have designed *very* large \nsystems. 2.5 Pattern Mining from Submissions The bulk of the workshop was spent mining patterns from \nthe submissions. We did this by breaking into pairs such that there was at least one person with pattern \nwriting experience in each pair. The pairs were assigned a submission (not their own) to mine for patterns. \nWe (the pairs) would read through the submission looking for patterns we recognized and had successfully \nused ourselves. This ensured that all patterns recorded had been used at least twice . Some groups were \nfocused on technical patterns (those found in architectures) while others concentrated on process patterns \n(those used while designing architectures). As part of this report, we have included some of the patterns \nin full, as well as the names of some of the other patterns. Next, we reviewed the patterns discovered \nby each pair of architects. We posted each pairs output on the wall and then did a guided tour with each \npair explaining their patterns to the rest of the group. We were all amazed by the amount of experience \nand wisdom we had managed to capture in less than one day s work! Once again, the general reaction was \nYes! I use that pattern all the time! The final activity of the workshop was the creation of a poster \ndescribing the workshop. Our poster consisted of a description of our workshop plus the patterns we felt \nmost strongly about. At the Poster Session, we answered a number of questions regarding our patterns; \nwe also had people asking to be sent copies of the material in whatever form we were willing. At least \none viewer exclaimed: Please send it ASAP; I need it to do my job!  3. Workshop Results 3.1 Responsibilities \nof Architects The following responsibilities were pretty much common to all the architects in the workshop: \n. Architecture Definition . Architecture Evolution . Domain analysis . Technical Leadership &#38; \nVision . Quality Assurance . Architecture Validation and above all, . Architecture Evangelism  3.2 \nQuestions about Architecture The following question were raised but not necessarily answered by the group. \nThey are provided as food for thought and to frame the outputs of the workshop. Is sequence logical to \nphysical? How to plan for evolution? How to work with incomplete information? How do we do architecture \nwork in parallel pieces? What s the incentive for getting involved? How do we know the architecture is \ncomplete? In terms of coverage and detail. What guarantees does an architecture make about non-functional \nrequirement? How many developer should I (the architect) involve in the architecture work? What are the \nlevels of architect? How much detail? . Do you need object technology to do good architecture? Are \nthere useful generic software architecture (across domains)? Do architects have responsibilities for \nthe team other than technical ones? What are the patterns that allow for change? How do we make sure \nthe architecture gets used? How do we know a pattern language is OK? How do we make patterns learnable \nand useable? What is the root of great design? . How do you hand off an architecture so the implementators \nown it? 3.3 The Architecting Process The following describes at a high level the process which the workshop \nparticipants each follow when architecting systems. It is important to ensure that the decisions are \nmade in the order presented to prevent pre-mature lock-in of more detailed decisions. Good iterative \nsystem development results in continual re-evaluation of the decisions as more information becomes available, \nand different parts of the system may have different degrees of decision making completed. There must \nalso be continual feedback between Modellers, Architects and Implementors on the appropriateness of the \ndecisions made within their decision-making scope. Domain Modeling Decisions: These are decisions relating \nto how the problem domain dictions and what are the key concepts that must be included in the domain \nmodel. If it has not been done by a Domain Modeller, it is up to the Architect to ensure that a Domain \nModel exists. Attribution of Responsibilities to Domain Objects The Use Cases are examined for responsibilities \nwhich the system must perform. Decisions relating to which Object should carry out specific responsibilities \nfall into this category. These decisions should be made by the architect, not the Domain Modeller. Flexibility \nand Future Proofing Decisions: Based on an understanding of the business and some intelligent guesses \nat what the future might hold, a number of flexibility points (or Loci of Change) are identified. Conscious \ndecisions are then made whether or not each kind of flexibility should be handled by the architecture. \nThose which need to be supported are handled by building the right hooks into the architecture. In object \nsystems, this is typically done by using the appropriate Design Patterns such as Observer, Strategy, \nChain of Responsibility. These responsibility for these decisions falls squarely onto the shoulders of \nthe architect. Legacy Interworking Decisions: Up until this point, the computing environment in which \nthe system is to execute has been ignored. This makes the architecture highly reusable across implementations. \nIt is, however, time to map the logical architecture defined thus far into a target processing environment \nconsisting of new and legacy software. The existing componentry is evaluated for fit into the architecture. \nWhere possible, the fit is improved through the use of Design Patterns such as Adapter and Bridge. Where \nlegacy applications cannot provide direct software inter-working, it may be necessary to treat them as \nseparate processes. The decisions are of great architectural importance and should not be left for the \nimplementors. Distribution Decisions: Where the problem domain is inherently distributed or the solution \nmust be executed on multiple processors for reliability, capacity or legacy interworking reasons, a number \nof decisions must be made when mapping the logical architecture into possible processing contexts. A \nnumber of patterns can be applied here, including RPC, two-tier Client/Server, Broker [Siemans96] (including \nCORBA and Three-Tier Client/Server), and Half-Object Plus Protocol IpLoP (AKA HOPP). There are a number \nof trade-offs involved. The more efficient solutions (such as RPC and two-tier Client/Server) tie the \napplication implementation very closely to a particular solution while the more general solutions ( Broker \nand HOPP) hide the specific mechanisms used from the applications allowing easier evolution in the future. \nAn architect should make all decisions related to the distribution of the system and should consciously \ntake such factors into consideration. Implementation Decisions: The actual programming languages and \ntechniques used to implement the architecture are left to the implementer. While the architect must be \nreasonably certain that a particular architectural concept can be implemented, the architect should not \nmake the decision as to how it will be implemented (unless also wearing an implementer hat .)  3.4 A \nPattern Language for the Process of Architecting We have included here a subset of the patterns that \nwere discovered during the workshop. Due to space limitations, only a few of our favorites are included \nin their entirety. For the remainder, only a brief abstract is included. what makes something a Pattern? \n For a description to be a pattern description, it must include a few mandatory elements: Problem Statement \nContext in which it is to be solved Forces which need to be resolved The solution for this context Together, \nthese elements describe not only the solution to a problem, but the circumstances in which it should \nbe used and why it is appropriate in those circumstances. Additional optional elements including examples, \nimplementation details and sample code (especially for Design patterns) round out a fully developed pattern. \n Organizational Patterns: Organization Mimics Architecture Since a system will resemble the organization \nwhich built it, design the organization to resemble the architecture you would like it to implement. \nJim Coplien mentions this in his organizational patterns [pLoP94].  Team of Architects In a large system, \nthere are too many decisions to be made for a single person. Hierarchy of Architects A single person \nshould still be accountable for all the decisions made by a Team of Architects.  Architect Roles Architects \non a Team need to understand their roles, whether SubDomain based (i.e. User Interface, Persistence, \netc.) or technology based (i.e. Object Architect vs. Implementation Architect.)  Decisions made at Appropriate \nLevels As in Snooker, what is left (decisions yet to be made) is just as important as what is taken (decisions \nalready made.)  Process Patterns: Encapsulate Implementation Define interfaces that hide as much of \nthe implementation as possible. This allows teams to work in parallel Design for Change It is as important \nto design for anticipable changes as it is for currently required functionality. Encapsulate Expected \nChange Minimize the impact of future changes on the rest of the system Divide &#38; Conquer Divide a \nDomain into a number of smaller domains, translating Domain Use Cases into SubDomain Use Ci-iSeS. Recursive \nDecomposition Keep subdividing Objects (and their responsibilities) into smaller and smaller objects \nuntil they are small enough to implement in your choice of environment. Pearl Diving Problem: An architecture \nmust be implementable. Context: An Architect designing an Architecture that will be implemented by others. \nForces: An architecture that cannot be implemented has no value. An architect must see the full breadth \nof the system; this is where they add value over that provided by implementors. Someone concentrating \non the implementation details is likely to overlook the broader issues. Solution: Compare the Architect \nwith a Pearl Diver. The diver s main objective is to stay alive. He collects pearls so he can eat. To \nbe successful at collecting pearls, the diver must breath regularly which can only be done on the surface. \nThe architect should work predominantly at the level of architecture (the surface.) Every once in a while, \nthe architect may encounter something they are unfamiliar with. Is it a Pearl or a rock? (Will it work? \nIs it implementable? The architect must ensure that there is at least one possible implementation of \nthe architecture.) Like the pearl diver who sees something on the ocean floor, architects must take a \ndeep breath and dive down to investigate. Sometimes they will find something, other times not, but like \nthe pearl diver, architects cannot stay down for very long without compromising their main objective. \n Incremental Development Complex systems that work have typically evolved from simple systems that worked. \n(Grady Booth) Continuous Improvement Start with an obvious solution and improve it over time until it \nis an elegant solution. Simple is Beautiful AKA: Simplify, Simplify, Simplify A simpler system is easier \nto build, use, maintain and will perform better (fewer defects, less memory, fewer MIPS.) Proof of Concept \nValidate the Architecture through a Proof of Concept (Architecture Prototype.) Derive Responsibilities \nfrom Use Cases Discover the responsibilities of the System by examining the use cases. Attribute Responsibilities \nto Objects All the Responsibilities discovered in the Use Cases must be assigned to exactly one object. \n  Modeling Patterns One Object or Two Keep asking whether the object in question is truly a single object, \nor is it two (or more) closely related ones. (Just because twins often hang out together does not justify \ntreating them as a single person.) Domain Glossary Capture definitions of all terms in domain in a glossary \nto prevent accidental miscommunication.  Architecture &#38; Flexibility patterns Strategy Objectify \nan algorithm behind an interface so that it can be easily replaced when it is superseded by changes in \npolicy. Chain of Responsibility Allow unanticipated handlers of events to be added to the system after \nthe fact. Separate UI from Application Logic The user interface (HI) is very likely to change over the \nlifetime of the application. Several UIs may need to be supported at the same time.  Distribution Patterns: \nArchitecture First; Distribute Later Get the architecture of the system sorted out before figuring out \nhow to distribute it. Objects Live at Home Objects should be located as close to the hardware they control \nor represent. Homeless Objects Live with Their Best Friends Objects unrelated to hardware should be located \nclose to the objects/processes with which they have the highest affinity. Proxy An object which is a \nstand-in for an object in another address space or processor. Broker An object which acts as a go-between \nto hide distribution of objects. Half Object Plus Protocol An object which has been replicated into two \nor more address spaces to reduce the performance impact of distribution.  Legacy Interaction Patterns: \n Wrapper Make a legacy system look like an object. Bridge Provide a bridge (a two-way adapter) between \ntwo incompatible systems or objects.  Implementation Patterns: Different Objects for Different Lifetimes \nThings which are not created and destroyed together are not the same object. Architecture Captured in \nFrameworks Make compliance to the architecture the path of least resistance by providing easily reusable \nimplementations in the form of frameworks. Budget Performance Component developers need to know how \nmuch memory and processing power their component can consume and how much latency it can introduce. \n 4. Summary We found that there was remarkable congruence in what we all did in our respective roles \nas system architects. The kinds and ordering of decisions was very similar. We all believed that it was \nas important to not make certain kinds of decisions as it was to make others. The architect should concentrate \non defining the high level components and how they relate and should leave the implementation decisions \nto the designers and programmers. It is sufficient to ensure that at least one reasonable implementation \nexists, beyond that, the architect should keep their noses out of the implementation. Having said that, \nwe all believed that it was important to collect feedback on the architecture (from the implementors) \nonce the implementation was under way. 5. Future Plans Many of the group expressed interest in continuing \nto work together in the development of our pattern language. This will be carried out over the Internet. \nIt is hoped that we will be able to submit portions of the language to PLOP-96 and make the patterns \navailable on the patterns site at UIUC. We also plan to have a follow-on workshop at OOPSLA 96 to continue \nthe work. 6. Acknowledgments We would like to thank the organizers of OOPSLA 95 for giving us the chance \nto meet and work together. Special thanks to Bill Beshilas who translated reams of hard-copy workshop \nresults into electronic form. 7. References [ Siemans961 Patterns-oriented Software Architecture Frank \nBuschmann et al, to be published by John Wiley &#38;Sons in 1996. ISBN O-471-95869-7. [pLoP94] Pattern \nLanguages of Program Design edited by James Coplien and Doug Schmidt published by Addison-Wesley. ISBN \nO-201-60734-4 [GHJV94] Design Patterns: Elements of Reusable Object- Oriented Software. Erich Gamma, \nRichard Helm, Ralph Johnson, John Vlissides published by Addison-Wesley. ISBN O-201-63361-2.  \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Gerard Meszaros", "author_profile_id": "81100335374", "affiliation": "", "person_id": "PP31089054", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260267", "year": "1995", "article_id": "260267", "conference": "OOPSLA", "title": "Patterns for decision making in architectural design: workshop summary", "url": "http://dl.acm.org/citation.cfm?id=260267"}