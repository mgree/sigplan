{"article_publication_date": "10-01-1995", "fulltext": "\n Applying Object-Oriented Software Engineering Methods to the Development of Call Center Software: A \nCase Study Jeff L. Burgett jebu @aol.com Abstract In an event to improve the quality and productivity \nof the software development process, the Voice/Data Integration Group embarked on a program to introduce \nObject-Oriented Software Engineering Methods into the development of a large call center application. \nThis paper provides an analysis of the experience as it applies to project management, requirements, \ndevelopment, and quality assurance. The key lessons learned during the development and the maintenance \nof this production system are summarized.  Introduction In the second quarter of 1993 a grass roots \nefforts had begun to integrate C++ into our call center product. By the first quarter of 1994 a business \ndecision was made to introduce the Object-Oriented Software Engineering (OOSE) method into the group \non selected projects. Management s perception was that the group maintained good customer satisfaction \nand a high level of productivity, however metrics had never been applied and this perception had never \nbeen quantified. A three year plan was initiated that would enable us to quantify key aspects of customer \nsatisfaction and productivity as it applied to our software development and maintenance process. The \nobjective for the first year was to migrate to a more formal, repeatable software development process \nthat would meet or exceed our current level of quality and productivity. The plan for the second year \nis to apply metrics to quantify where we are in terms of software quality. The third year plan calls \nfor using these metrics to direct the improvement of our software development and maintenance process. \nThis paper outlines the path taken in order to achieve this goal of migrating to OOSE methods in  Sheryl \nJ. Adam sjadam@aol.com the first year and its impact on the software life cycle to date. Project Background \nThe selected project was a call center application that would support several hundred agents using client-server, \ncomputer-telephony, and voice response unit (automated agent) technologies integrated by a single midrange \ncomputer. The client/server software for the agents was implemented by an external development organization. \nThe client/server software for the automated agents and call management application code was written \nin C++ and the persistent data was maintained in a relational database management system. Two lab demonstrations \nwere provided prior to the first field a release. Over the course of the year there were a total of three \nmajor field releases. The project was selected because it was anticipated that the requirements would \nbe volatile throughout the software life cycle. We felt that the more formal development process would \nhelp us manage the change better and that this advantage would more than offset the learning curve required \nif a conservative migration to the new OOSE method was implemented. This assumption proved to be sound \nsince more than 80 percent of the requirements were either deleted, added or changed during the development \nof the first release. Project Management In the daily management of the project we found that our migration \nto OOSE enhanced our ability to estimate and track projects. However, this approach complicated project \nstaffing. Estimating and Tracking Projects We set milestones at points within the following phases of \nthe development process: . Requirements . Analysis . Design . Implementation . Test The OOSE approach \nforced us to identify task with a granularity of use cases in the requirements phase and abstract control, \ninterface, and entity objects in the analysis phase. In the past we allocated a very small percentage \nof the development process to requirements gathering and would not allocate time to a formal analysis \nphase. Requirements and analysis modeling are often delayed until they are subconsciously performed in \ndesign or code where the lower level of abstraction makes it more difficult and error prone. Emphasis \nwas placed on the requirements and analysis phases and well defined objectives and deliverables were \nassigned. By assigning a set of concrete objectives to each person in the design and implementation phase \nit was easier to track the project progress than assigning processes to one or several people. Generally \nobjects where smaller and had better defined boundaries than a process divided among several people. \nBy adding this new level granularity to our project planning we were able to: . estimate releases with \nhigher degree of accuracy; a define and track to more accurate schedule during the initial and ongoing \nproject planning; and a manage customer expectation better by defining areas that were deviating from \nthe budget or schedule. It was not until the second production release that we were able to effectively \nuse these new skills in planning and tracking, however they have been effective on subsequent releases \nand projects.  Staffing Issues In order to better manage system complexity we divided the system into \nfour subsystems (agent workstation, list manager, call manager, and automated agent). Three of the subsystems \nwere staffed with internal developers and the fourth (agent workstation) was developed by and internal \ndevelopment organization. The largest two subsystems, list manager (approximately 200,000 lines of code) \nand parts of the call manager, used an object-oriented approach to development. The staffing issues became \nmore complex in the following ways when we introduced object-oriented approach. . It was difficult \nfor the developers with a strong relational database background to design based on objects instead of \ndatabase tables. . There was not CASE tool support until the fourth production release when we used the \nObjectory CASE tool. This required us to plan for the additional effort required to document our models \nin a word processor with graphics capabilities. . The team members needed to be self motivated and willing \nto learn new abstract concepts. The relational database table versus object design debates were the most \npainful part of our initial migration to object-oriented technology. We developed an approach that integrated \nthe two technologies using persistent administrator objects. Although documenting the models in a word \nprocessor required extra effort up front we feel that the extra effort was more than recovered by a reduction \nin the overall testing and debugging effort. However, we have subsequently found that even with the learning \ncurve required, the Ojectory CASE tool allows for much higher productivity than modeling systems with \na word processor. We were fortunate to have a team of approximately 30 self motivated people that consistently \nattended short in-house training classes and studied the object-oriented analysis, design, and programming \nmaterial (see reference). This was key to the success of the project.  Requirements Collection The migration \nto OOSE methods started at the end of the requirements gathering process. the existing requirements documentation \nwas incomplete and ambiguous in many areas. By the first release approximately 82% of the initial requirements \nhad changed or been replaced. These changes were due primarily to us more accurately defining the initial \nrequirements instead of the customer adding functionality. To resolve these problems we; . mapped our \nrequirements into use cases; . developed use cases with a scenario section and numbered line item requirement \nsection; and . added a full time requirements analysis position to the team. We chose the use case approach \nbecause we felt it would help us understand the requirements better and help us manage the change in \nrequirements level system decomposition. Initially the customer did not like this new format. however, \nas we went through requirements reviews the simple approach of the use cases changed their perception. \n Although the use cases helped in the understanding of the systems, we still had problems with the ambiguity. \nTo resolve this problem we divided each use cases into two sections. The first section contained a typical \nscenario description of the actor requirements. The second section contained numbered actor requirements \nin the order presented in the scenario. Each bulleted line item was atomic (smallest unit of work) from \nthe actor s perspective. The scenario section resolved our clarity problem and our atomic line item approach \nresolved our ambiguity problem. We chose not to use the uses and extends relationships between use cases \nbecause they did not add to the simplicity of the model and were confusing to the requirements team. \n A full time requirements analyst was added to the team primarily because of the additional work generated \nby the atomic line item approach as well as the dynamic nature of the requirements. In addition this \nperson coordinated change order documentation and updated the requirements model when new requirements \nwere submitted. We have since added requirements analysts to other projects in the group using use cases \nas their requirement modeling approach.  Development Methodology There were two milestones over the \ncourse of the project where significant methodology transition occurred. after the second lab demonstration \nand after the first major production release Prior to the second lab demonstration we had very little \nobject-oriented analysis and design experience on the team, therefore we needed a methodology that was \nsimple and would help us become productive quickly. We developed the analysis model using the Booth object \nmodeling approach because clouds were more interesting than rectangles and the class associations (is-a, \nhas-a, uses-a) used were easy to understand. The design was modeled using the Coad-Yourdon Object-Oriented \nDesign approach because the notation was simple and easy to read and we had a tape that Peter Coad handed \nout at OOPSLA 92 that the team had watched. As an extension to the Coad- Yourdon design model, we used \nthe OOSE (i.e. Jacobson) interaction diagrams. This approach allowed us to achieve our development goal \nof utilizing abstraction, encapsulation, and hierarchies in the analysis and design in order to minimize \nthe impact of the changing requirements. However, it did not help us with traceability (i.e. maintainability) \nand scaleability. After the second lab demonstration we transitioned our requirements document to a use \ncase model approach to better managing requirements. OOSE robustness models were introduced as a replacement \nfor the Booth object model in order to better model the abstraction of the system. We also transitioned \nfrom the Coad-Yourdon design model to the OOSE design model and extended the notation of the OOSE design \nmodel to provide traceability from each robustness model object to a set of concrete objects (including \nthe persistent administrator objects). This transition to the OOSE models provided us with the traceability \nand scaleability we needed to manage a rapidly growing system. During the analysis and design phase of \nthe first production release we encountered two significant problems: . the ability to model concurrent \nprocesses; and a the ability to precisely define and model the interfaces between subsystems early in \nthe development process. After the first release we partially resolved these problems by utilizing concepts \nfrom OOSE and RDD (Responsibility Driven Design). Austin, TX October 15-19, 1995 Our processes closely \nresembled the service packages in the OOSE method, therefore we adopted the service package notation \nto represent our process. We modeled the IPC (inter process communication) queues for the processes as \nconcrete objects in the design model. However, we still did not have a good way model concurrent processes. \nIn order to precisely define and model the interfaces between subsystems we used the concept of client-server \ncontracts from BDD using OOSE notation. We modeled the client subsystem as an actor and the server as \nthe target subsystem with it s associated interface object in the robustness model. The use cases provided \nthe list of requests that the actor could make of the subsystem. Interaction diagrams model this interaction \nand provided a tool for teams to drive this interaction down to level of messages, arguments, and argument \ntypes. Although these messages sometimes changed as the rest of the system went through the design phase, \nit provided a sound base from which the subsystem teams could communicate. As a result of this approach, \nthe contract was documented in the interface object description and the actor/interface object interaction \ndiagram. This not only provided the basis for a modeling contract but for a legal contract as well. \nQuality Assurance The transition to OOSE methods precipitated the following changes in our approach to \nquality assurance. . the implementation of traceability from use cases through test plans; and significant \nreduction in the time to develop test cases. During the development of the first release, the Quality \nAssurance (QA) group did not join the project until the coding phase. As a consequence of the lack of \ninitial involvement by QA and the lack of traceability from design to the test cases, test plan development \nwas a lengthy and difficult process. We found in subsequent releases that by breaking the use cases down \nto numbered, testable, atomic line items that we could trace the requirements through to the test cases. \n By using the atomic line items in the use cases the test plan developers needed only to identify how \nto test the line items instead of deciphering testable features from ambiguous text in the use case scenarios. \nThis reduced our test plan development time by greater than 50%. Lessons Learned The following are the \nkey lessons we learned from our successes and obstacles: requirements analysis is key to developing quality \nsoftware and should be staffed as permanent position on a project team; . Object-oriented projects \nare easier to estimate and track than our structured projects because the division of labor is better \ndefined as objects; Using a CASE tool to support requirements, analysis, design, and test modeling is \nan effective way to increase project team productivity and is far superior to word processor support; \nDividing each use case into separate scenario and numbered, atomic requirements sections provides a understandable \nyet unambiguous requirements document and a sections provides a understandable yet unambiguous requirements \ndocument and a solid basis for test plans; With the exception of concurrent process modeling, the Object-Oriented \nSoftware Engineering approach to system development is effective throughout the software development \nlife cycle; and The client-server contract approach is an effective way to model interacting systems \ndeveloped by separate development teams. We believe these lessons are not unique to our environment \nor industry. Summary A formal software development process was successfully implemented. It was perceived \nby management that the project exceeded the level of quality and productivity that existed at the beginning \nof the project. By continually adjusting our process to take advantage of the lessons we have seen an \nimprovement in numerous areas of our software development process. Acknowledgments We would like to \nthank Vann Perry for his sponsorship of this project and valuable comments on this paper and the outstanding \nefforts of the developers and quality assurance project team members. References Booth, G. (1994). Object-Oriented \nAnalysis and Design with Applications. Redwood City, CA: Benjamin/Cummings. Coad, P. and Yourdon, E. \n(1991). Object-Oriented Design. Englewood Cliffs, NJ: Prentice-Hall. DeMarco, T. (1982). Controlling \nSoftware Projects: Management, Measurement &#38; Estimation. New York, NY: Yourdon Press. Jacodson, I. \nChristersson, M., Jonsson, P., &#38; Overgaard, G. (1992). Object-Oriented Software Engineering: A Use \nCase Driven Approach. Reading, MA: Addison-Wesley. Shlaer, S. and Mellor, S. (November/December 1993). \nA Deeper Look at Managing the Work on a Project. Journal of Object-Oriented Programming vol. 6(3). Wirfs-Brock, \nR., and Wilkerson, B. (1990). Designing Object-Oriented So&#38;are. Englewood Cliffs, NJ: Prentice-Hall \n \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Jeff L. Burgett", "author_profile_id": "81100046515", "affiliation": "", "person_id": "P137206", "email_address": "", "orcid_id": ""}, {"name": "Sheryl J. Adam", "author_profile_id": "81100597094", "affiliation": "", "person_id": "P263492", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260240", "year": "1995", "article_id": "260240", "conference": "OOPSLA", "title": "Applying Object-Oriented Software Engineering Methods to the development of call center software: a case study", "url": "http://dl.acm.org/citation.cfm?id=260240"}