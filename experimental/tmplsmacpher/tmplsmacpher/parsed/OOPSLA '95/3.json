{"article_publication_date": "10-01-1995", "fulltext": "\n What Should We Teach? Adele Goldberg Chairman, PamPlace-Digitalk, Inc. Object-oriented technology offered \nyet another way to explicitly support, through languages and their tool environments, long discussed \nstrategies to help structure large software systems. But object- oriented technologies of the 80s challenged \nthe system builders of the 90s in profound ways: system structure would be more visible; team structure \nand management would be a more critical project success factor; and retraining experienced personnel \ncurriculum and development tools for a new course designed to meet these-challenges. The Dilemma In the \nlast forty years, software engineering has gone from oxymoron to a subject worthy of serious study, albeit \none laden with common sense. Much of software engineering seems to be about designing and using programming \nlanguages, because we understand them better than many of the other elements of software, and because \nlanguages have elegant, aesthetic properties. Each system we build is in fact a problem-specific language, \nand therefore the study of languages teaches us much of what we need to know about the design of these \nsystems. Recently we have focused on reuse-what reuse is, how to design for reuse, and how to select \nwhat we should harvest for reuse. We have recognized the need to understand the organizational aspects \nof a reuse program, and the new tools required to make reuse culturally acceptable, if only because we \nare able to show that reusing is less costly in the long run than not reusing. Reuse has become the gold \ncoin of software engineering. But software engineering has a dirty word in its vocabulary as well, and \nit is legacy. Good software engineering creates software that will last and will continue to be changeable \nin the face of evolving problem or situation needs. Measures of system goodness revolve around this \nwould be required. This paper proposes a on software engineering practices especially simple notion: \nwe expect what we create to have to be changed. Indeed, urban computer legend says that a system never \nwords we use to describe robust, understandable, architected. These labels touched, still rots. The \ngoodness include and well are all related to whether the system can be changed in a controlled and predictable \nmanner. A legacy system is one that is not easily changeable-at least not within the acceptable cost \nconstraints set for making the proposed changes. By implication, legacy means strategic and valuable-we \ncannot live without it even though we cannot grow with it. This definition makes legacy synonymous with \nmillstone. And now for the dilemma. We are readying ourselves to enter the twenty-first century with \na new generation of students who are growing up assuming computers, computing, communicating globally, \naccessing information globally, three-dimensional visualization, and virtual reality, are all natural \nparts of a person s life. Yet, as we plan university and college courses of study, and even corporate \ntraining programs, we are still teaching dirty words. We are still teaching how to build legacy systems, \nindeed we are still building legacy systems, and this despite a serious body of work that offers direction \nto the contrary. In particular, we are teaching data structures, algorithms, and clever coding, rather \nthan ease of understanding and maintenance that comes from good architectural design. Austin, TX October \nE-19,1995 But we cannot have both. If a call is polymorphic, it must not be a catcall; if it is a catcall, \nit must not be polymorphic. Polymorphic catcalls will be flagged as invalid. ~ Polymorphic catcalls are \ninvalid If you remember the America conjecture, we of course do not sacrifice static typing; we do not \nsacrifice covariance; and we do not sacrifice substitutivity, that is to say polymorphic assignments \nof a more specialized value to a more general entity, except in cases in which they would clash with \nthe other rules. As evidenced by the practical Eiffel experience that was mentioned earlier, such clashes \nare very rare; they are signs of bad programming practices and should be banned. So this is the type \nrule: a prohibition of polymorphic catcalls. This rule is similar to the one in Ezyfel: The Language \nbut much, much simpler because it is more pessimistic. It is checkable incrementally: a violation will \nbe detected either when an invalid call is added or when an invalid redefinition is made. It is also \ncheckable in the presence of precompiled libraries whose source is not available to users. As a complement \nit is useful to show the robustness of this solution by giving a technique which will answer a common \nproblem. Assume that we have two lists of skiers, where the second list includes the roommate choice \nof each skier at the corresponding position in the first list. We want to perform the corresponding share \noperations, but only if they are permitted by the type rules, that is to say girls with girls, ranked \ngirls with ranked girls and so on. This problem or similar ones will undoubtedly arise often, An elegant \nsolution, based on the preceding discussion and assignment attempt, is possible. This solution can be \nimplemented in Eiffel right now; it does not require any language change. We will propose to the Nonprofit \nInternational Consortium for Eiffel (NICE), the body responsible for Eiffel standardization, to add to \nclass GENERAL a new Addendum to the Proceedings OOPSLA function jitted. GENERAL is a part of the Eiffel \nLibrary Kernel Standard, the officially approved interoperability basis; every Eiffel class is a descendant \nof GENERAL. Here is the function,fitted (the name might change). fitted (other: GENERAL): like other \nis --Current if other is attached to an object of exactly the same --type; void otherwise. do if other \n/= Void and then same_type (other) then Result ?= Current  end end Function fitted returns the current \nobject, but known through an entity of a type anchored to the argument; if this is not possible it returns \nvoid. Note the role of assignment attempt. A companion function which examines the types for conformance \nrather than identity, is easy to write. Function jitted gives us a simple solution to our problem of \nmatching skiers without violating type rules. Here is the necessary routine match: match (sl, ~2: SKIER) \nis --Assign sl to same room as s2 --if permissible.  local gender-ascertained-s2: like s I do gender-ascertained-s2 \n:= s2 .Jitted (~1); if gender-ascertained-s2 /= Void then sl . share (gender-ascertained-s2) else Report \nthat matching is /impossible for sl and ~2 end end For a skier s2 we define a version gender-ascertained-s2 \nwhich has a type anchored to sl. I find this technique very elegant and I hope you will too. And of course \nparents concerned with what happens during the school trip should breathe a sigh of relief. 95 29  \nWhat Should We Teach? Adele Goldberg Chairman, PamPlace-Digitalk, Inc. Object-oriented technology offered \nyet another way to explicitly support, through languages and their tool environments, long discussed \nstrategies to help structure large software systems. But object- oriented technologies of the 80s challenged \nthe system builders of the 90s in profound ways: system structure would be more visible; team structure \nand management would be a more critical project success factor; and retraining experienced personnel \ncurriculum and development tools for a new course designed to meet these challenges. The Dilemma In the \nlast forty years, software engineering has gone from oxymoron to a subject worthy of serious study, albeit \none laden with common sense. Much of software engineering seems to be about designing and using programming \nlanguages, because we understand them better than many of the other elements of software, and because \nlanguages have elegant, aesthetic properties. Each system we build is in fact a problem-specific language, \nand therefore the study of languages teaches us much of what we need to know about the design of these \nsystems. Recently we have focused on reuse-what reuse is, how to design for reuse, and how to select \nwhat we should harvest for reuse. We have recognized the need to understand the organizational aspects \nof a reuse program, and the new tools required to make reuse culturally acceptable, if only because we \nare able to show that reusing is less costly in the long run than not reusing. Reuse has become the gold \ncoin of software engineering. But software engineering has a dirty word in its vocabulary as well, and \nit is legacy. Good software engineering creates software that will last and will continue to be changeable \nin the face of evolving problem or situation needs. Measures of system goodness revolve around this would \nbe required. This paper proposes a on software engineering practices especially simple notion: we expect \nwhat we create to have to be changed. Indeed, urban computer legend says that a system never words we \nuse to describe robust, understandable, architected. These labels touched, still rots. The goodness \ninclude and well are all related to whether the system can be changed in a controlled and predictable \nmanner. A legacy system is one that is not easily changeable-at least not within the acceptable cost \nconstraints set for making the proposed changes. By implication, legacy means strategic and valuable-we \ncannot live without it even though we cannot grow with it. This definition makes legacy synonymous with \nmillstone. And now for the dilemma. We are readying ourselves to enter the twenty-first century with \na new generation of students who are growing up assuming computers, computing, communicating globally, \naccessing information globally, three-dimensional visualization, and virtual reality, are all natural \nparts of a person s life. Yet, as we plan university and college courses of study, and even corporate \ntraining programs, we are still teaching dirty words. We are still teaching how to build legacy systems, \nindeed we are still building legacy systems, and this despite a serious body of work that offers direction \nto the contrary. In particular, we are teaching data structures, algorithms, and clever coding, rather \nthan ease of understanding and maintenance that comes from good architectural design. Austin, TX October \n1519,1995 Object-oriented technology offered yet another way to explicitly support, through languages \nand their tool environments, long discussed strategies to help structure large software systems. But \nobject-oriented technologies of the 80s challenged the system builders of the 90s in profound ways: system \nstructure, understood in terms of objects and their relationships, would be more visible; team structure \nand management, to support the ability to coordinate independent object development, would be a more \ncritical project success factor; and retraining experienced personnel to new languages and tools would \nbe required. The First Challenge: Visible System Structure Good system design bases the structure of \nthe system on the structure of the problem to be modeled. But both theoretically and academically, we \ndid not know how to explain concisely how to uncover that structure so that it is expressed at a level \nat which both the people involved in the problem situation and those in its computerization would speak \nthe same language. Hence the flurry of work on analysis and its relation to design, which remains unsatisfactory \nand therefore still worthy of research and development. This first challenge was met by emphasizing object \nbehavior analysis as a technique for extracting a model of the problem in terms of roles and responsibilities \nthat could then be mapped to an appropriate system model under the constraints set by deployment goals, \nand under the growing knowledge of object design techniques or patterns. The Second Challenge: Similarity \nbetween System and Team Structures There is and was agreement that the structure of a system reflects \nthe structure of the team that creates it, that is, the inversion of the Baushaus cliche that form follows \nfunction (here we note that function follows form). Obtaining well-designed modular systems, with good \ncommunication among the independent parts, demands similarly structured and managed teams. The introduction \nof object-oriented technology seemed to permit an abandonment of clear team structure and process. Of \ncourse, no such permission was intended. The high demand for mentoring and other consulting services \npoints out that there is a skills gap that needs filling, and a considerable cost associated with not \nhaving dealt early enough to develop one s own software engineering resources. The second challenge will \nbe met when well-managed teams document their work progress, and collect the historical evidence needed \nto report on what transpired. Once we have actually taken the time to instrument our projects so as to \ngather historical data, we can offer better techniques for allocating resources, and for estimating and \ncontrolling costs in future projects. What data do we collect? The cost of building a system is a function \nof the complexity of the problem, the availability of existing solutions that can be reused, and the \nculture in which the system will be built. The often higher cost of maintenance is a function of the \nculture in which maintenance takes place, the number of kinds of system parts and their interactions \nthat have to change, and the number of parts and interactions affected by such change, since these have \nto be retested. These factors suggest what baseline information has to exist in order to estimate costs \nand resources realistically. The Third Challenge: Re-Training A third challenge in the commercialization \nof object-oriented technology is the (re-)training of software engineers. The massive infrastructure \nof existing or new educational institutes and training organizations, and the availability from such \nsources as the Carnegie-Mellon Software Engineering Institute of recommended college-level curricula, \nshould have met this challenge. But there continues to be a mismatch between what we teach and what we \nneed to learn. With some exceptions, current classroom modes of teaching emphasize individual performance \nand reward clever coding. Assignments to create software solutions are carried out with little need for \na well-defined, and certainly not a well- written, lifecycle process (despite Watts Humphrey s valiant \nefforts to the contrary). Individualism is driven both by the grading system and the teacher s work load \nin creating a sufficiently large team-driven project, doable in a short period of time, while the students \ntake several other courses. In other words, we teach programming-the bottom up stuff-and not how to see \nand manage the big picture. The result is that our students become professionals who create systems that \ngrow and grow, from the bottom up, and often out of control, until they are labeled legacies. Clearly, \nprogramming topics are important, especially when taught as a way to think abstractly, but in conjunction \nwith the pragmatics and aesthetics of system building, not in isolation. I do not know that our situation \nis quite deserving of a chapter in Barbara Tuchman s book of historical interpretation, The March ofFolly, \nin which she documents time and again the human inclination to do things wrong even when the direst of \nconsequences are known. But it appears that we are training folks wrong and building things wrong, even \nwhen we know better. This thinking lead us to work out a curriculum focused on teaching system building \nat the introductory level, as an overview to the in-depth studies and practices that every developer \nneeds to understand.  Basis for a Software Engineering Curriculum Our initial foray into a curriculum \nwas to examine the nature of systems and then how object technology could serve as an enabler for building \nthese systems. The work was done with Richard Gabriel. We noted that there are a number of contrasting \nideas to keep in perspective. Programming is not the same as system building for several fundamental \nreasons. Programming is single purposed. Programs have single entry -points. You run a program, get a \nresult, and then you and the program are done. Programs are best viewed top down, and sometimes inside \nout. They are linear, or at best they have some looping control that ultimately takes control back to \nthe top level. Programmers should be able to report, at any point of control and as a result of prior \nand current execution of instructions, what is the current state of the system executing the program, \nwho (that is, which part of the program) is in control, and when or under what circumstances that part \ntakes control. Good programmers have a clear understanding of the environment in which evaluation takes \nplace. They know who knows what when. So do system builders, although the answers differ in magnitude. \nIndeed, system builders have to manage a large number of kinds of communicating parts whose communications \ncreate different capabilities. Systems are multiple purposed, or have a complex single purpose. They \nrespond to events rather than to inputs. Systems have multiple entry points, the various entry points \ncan take you to common parts, and once you enter a system, you rarely return to the same or to a common \npoint of entry. System parts are each a center of a universe, acting independently, although making use \nof functionality provided by other parts. Probably the most significant difference-which is why issues \nof reliance and robustness are so closely associated with system building rather than programming-a system \nis expected to run indefinitely. Our goal is to create stable systems: systems that are robust under \nchange, are designed to be modified, and whose parts are sufficiently independent and well-defined that \nthe impact of a broken part can be isolated. As we said earlier, a legacy system is one that is brittle \nunder change. We expect the students to learn about and understand how to identify the boundaries of \na system and to recognize when change requests affect the boundaries. The complexity of a system may \nchange when the system boundaries change Austin. TX October 1519,199s since after all, the problem has \nchanged. The key to good system design is not to add unnecessary complexity. When a problem has inherent \ncomplexity, the system will reflect this complexity. Knowing the system boundaries and recognizing when \nthey change is of course the key to intelligent maintenance, in the sense that making a change is done \nwith the knowledge of how a change request modifies the statement of the problem and therefore of the \ncorresponding solution. This knowledge will point out any requirements change so we can work forward \nto eliminate unnecessary system parts and interactions, and therefore prune systems safely. The extent \nto which the boundary is changed incrementally or fundamentally tells us the extent of the maintenance \neffort. This distinction between stable systems and legacy systems describes two kinds of software products. \nA software engineering program should proscribe processes and resources that lead to different kinds \nof products. We generally agree that our goal is repeatable processes. This goal is not easily attainable \nas it implies that we can write down a description of what we did and then control ourselves so as to \ndo it again, preferably under the same circumstances or modified appropriately to fit the change in circumstances. \nIt would be better to claim that stable systems are built using reportable processes. Then we can note \nthat the process that says, just sit down and start coding, molding the result much as you would mold \nclay-is not reportable with any further detail, and presumes a small team of one or two people who like \neach other. Repeatable and reportable processes offer opportunities to compare and contrast-we learn \nover time which process activities make sense for our organization, in what order, and how to measure \nour progress. Processes require resources: tools and people mostly, and time and money, of course. A \nfocus on programming (teaching or doing) leads us to measure the performance of individuals, whereas \na Addendum to the Proceedings OOPSLA focus on system building (teaching or doing) emphasizes performance \nof the team and evaluating individuals in their roles as team members. Working alone, the individual \nprogrammer has to understand the entirety of the software being created. Individuals are rewarded for \nspeed, cleverness, features, and trendiness. Given a team of one, all information is immediately shared-all \ndecisions are immediately known. Indeed, the manager is respected. Hence communication and leadership \nroles are not daily issues. A larger team consists of many different roles, each carried out by people \nof differing skills levels. Teams are measured by their plans and control techniques, their development \nstrategies and architectures, and their approaches to quality assurance. To be successful, team members \nmust communicate. They must share decisions, and know what to expect from one another. They have to set \nclear contracts that state precisely what each part of the system will do and how the parts will be integrated, \nin advance of initiating product development. Test suites can and should be developed before the product \nsoftware. Team members must continually negotiate any changes to parts contracts. The manager s role \nis to lead by setting up clear channels of communication. The software engineering curriculum must introduce \nthese requirements for processes and resources, as well as how to measure the quality of resources, processes, \nand products. It should teach a culture of reuse and team work.  LearningWorks Learning Works is our \nproposed sandbox and curriculum for teaching software engineering. It is both a toolset in which curriculum \ncan be accessed and explored, and a specific curriculum about system building. The purpose of LearningWorks \nis to provide a context in which to explore fundamental ideas of computing and system construction, making \nuse of the Smalltalk language and libraries of selected objects, although, in truth, the reliance on \nSmalltalk is not necessary. Any language that supports object modeling with dynamic binding would likely \nsuffice. The basic tools for LearningWorks are intended for beginning users who will either study on \ntheir own or with a group in a classroom setting, or on their own or with a group in a distance learning \nsituation. We have designed the toolset with an authoring tool so that others can provide their own \ncurriculum or examples. The first completed prototype was provided to the Open University in the United \nKingdom for use with their new first-year programming course. A generally available prototype is scheduled \nfor Spring 1996. The work is being done with Steve Abell, with help from David Leibs and Tim Rowledge. \nAn earlier prototype was done with Glenn Krasner and Tim Rowledge, in cooperation with Susan Weber, then \na Computer Science professor at Mills College in Oakland, CA. Learning Books All information and activities \nof LearningWorks are accessible from a learning book. On-line learning books provide the only way in \nwhich courseware activities-projects and software development assignments-are carried out. You read a \nbook by selecting sections and, within a section, by selecting a page. Fig 1. Example Learning Book Activity \nPage grow shrink show hide I I Book pages contain activities or applications that you interact with \nin order to explore various topics of a course of study. A set of pages can represent a special simulated \nworld that the learner explores as a way to understand basic concepts and techniques. We call these rehearsal \nworlds in deference to the notion that they are specially devised to provide a context in which the learners \ncan explore or rehearse what the curriculum purports to teach As shown in figure 1, you access sections \nby selecting a section tab and selecting a section from the menu. Pages are labeled. The labels show \nas tabs at the top portion of the book. You change pages as you would expect, by selecting the tab of \nthe desired page. Book commands load and save, versioning the books if there are user-defined changes, \ninsert copies of the current page, detach pages, and inspect elements of a page. This book structure, \nbesides playing on commonly used computer metaphors and corresponding to the page-turning style of the \nWorld Wide Web, allows us to define name scope by something physical and visible. When authoring a new \nbook, we define names in the context of the book by including, that is importing, definitions of classes \nand variables from other books. We define names in the context of a section as part of the implementation \nof section themes. And we define names in the context of a page by allowing the author and the learner \nto declare local page variables. We portray context as defined by a hierarchy of book relationships, \nbut we allow any book to extend or close off access to definitions so as to permit the author to control \nwhat aspects of the language and library are accessible (visible) to the learner. There are four kinds \nof learning books: course, project, system, and inspector books. Each has a different purpose. Course \nBook Defines the course plan and objectives, and provides access to related curriculum materials, i.e., \nproject books. Austin, TX October 1519,199s Project Book Defines a simulated world in specifically for \nuse within the current book, and to which the learner explores define criteria for successful completion \nof book curriculum topics. activities. System Book Defines the base Smalltalk language definitions available \nto the learner. Course and project books can provide extensions to definitions and add new ones. Inspector \nBook Displays the structure of objects and applications. Whenever use of an activity page changes the \nvalues of an inspected object s properties, the changes are reflected in an inspector book. An example \nis shown in figure 2. Fig 2. An Inspector Book Object Structure Page i -1 joe is a box. Send joe a message \nby selectina an item from the menu. turnRight turnLeft forward Class backward grow shrink show hide \nDo ft RMel  color Types of Pages Tool pages provide support for defining Smalltalk objects, browsing \nexisting objects, inspecting the structure of objects, or debugging a sequence of messages to ask objects \nto perform various tasks. Information pages are either specification pages or activity pages. A specification \npage defines which objects will be available in the context of using a particular learning book, whereas \nan activity page contains rehearsal worlds. Specification pages are used to define software to be imported \nand made visible to the learner, to define software created  Section Themes Pages within a section can \nshare a common theme which displays as a subview that is visually repeated across all the pages and whose \nstate is remembered across pages. Section themes are important to our goal of simplifying access to aspects \nof software information, as the theme provides a context that can be shared among pages. So for example, \na section theme can support an indexed query of available class definitions, with the current selection \nretained as pages are turned. Figure 3 shows two development tools pages, with a multilevel browser as \nthe theme. of blue is IBox 1 1 blue  Curriculum Outline Having briefly covered the toolset, let us \nreturn to the question, what should we teach? We want to teach the four essential aspects of software \nconstruction: systems, components, architecture, and frameworks. We teach that a system is a set of communicating \nparts or components that fit together according to some well-founded semantics for the purpose of the \nsystem. A part or component is understood to be a systems building block that is well-defined by its \nexternal interface. An architecture is a  Addendum to the Proceedings OOPSLA 95 Fig 3. Two Tools Pages \nUseful in Browsing ( Variables ) 0 v REMEMBER 0 REMEMBER IUI 1 I I I I I I I 41 jb Instance MessageI-Class \nMessage -1 Instance Variables Class Variables I starring: aBox and: aBox I movie I Create a new instance \nof the class BoxMovie whose Refers to a graphical image the shape of a box that takes star is aBox and \ncostar is aBox2. a role in the defined animation ( movie ). movie := super new. movie star: aBox1. movie \ncostar: aBox2. *movie 1 specification of a set of components and a demonstrate delegation as well as \ndependency communications pattern or protocol among them relations. to achieve certain behavior. And \nfinally, a 4. Parts hierarchical relationships: a world of framework is a customizable system. Vehicles \nand related objects whose hierarchical Our course content will be delivered as six project relationships \ncan be explored, determining books: whether behaviors appropriate to the objects can be minimally specified. \n1. Parts communication: a world of Turtles and Sprites (graphical beasts) in which the learner can 5. \nParts relationships: a world of Street explore message sequencing strategies, with the intersections \nand Traffic control devices with fun outcome of generated line drawings and which the learner can explore \nand modify the simple animations as was done in teaching Logo relationships among objects that allow \nfor years ago. planning city traffic flow. 2. Parts behavior specification: a world of Boxes 6. Observing \nbehavior and mapping behavior to and other Visual Shapes in which the learner can object definitions: \ndone by having the learner explore and modify the behavior of boxes and working in a group to specialize \na framework, box-like shapes for making drawings and either a group from a regular classroom, special \nanimations. tutoring center, or created from participants who meet on the Internet. 3. Parts behavior \ndelegation: a world of Clients and Servers in which objects (clients) are The challenge in the choice \nof framework is to composed with simple behaviors that rely on other support a group project that can \nbe completed, objects (servers) to carry out aspects of the even if individual team members fail to deliver \nbehaviors. This example is intended to their components. This challenge is easily met in  our object-oriented \nworlds because we can Austin, TX October 1519,1995 robustly execute partial systems. Hence we can create \na default framework that is simply quiescent, awaiting specialization by the addition of sub-team components. \nWe plan a City Simulation framework, in which sub-teams create city services such as hotels, restaurants, \nfast-food stores, banks, clothing stores, car repair, car wash, etceteras. The framework must support \nthe ability to schedule people to come to the city to seek a series of services, and to handle exceptions \nwhen unprovided services are requested. The team leader assigns roles of: framework specializer, service \nintegrator, negotiator between service naming decisions. It is possible to incorporate the street intersection \nand traffic control from earlier lessons. We will provide the initial object models for the components \n(since our learners are not being taught analysis). The models will be given in the form of the roles \nand responsibilities of many possible service components, so that the learner subteams can implement \nthese as objects. Pedagogically it is important that roles-to-object relationships be many-to-one, one-to-many, \nand not just one-to-one. The division or object mappings is to be part of the first exercise in system \npartitioning. The source of these roles and responsibilities can be studied as a next course.   Team \nDevelopment in the Context of the Learning Books That leaves the final problem. How do the learners use \nthe books to create or to carry out the city simulation assignment, so that good system engineering practices \nare carried out? The team works together to create its Course Book, which is the development plan. The \nfirst pages state goals and objectives, the includes or import specification page identifies the base \nprogramming language and library of reusable assets, while the completion criteria page specifies the \ninitial test suite for interfaces of the highest- level partitioning of system events. The team works \ntogether to make sure it understands and agrees on the goals and objectives, and criteria for success. \nWhen choosing the high-level partitioning, the team creates a project book for each partition and specifies \non the includes page the Course book and the specification of those other project books from which additional \ncapability will be imported. The export or definitions specification page for each project book states \nwhich system parts will be (or are) created in this book, thereby defining clear ownership of the solution. \nA standard version control process for books on the shelves might suffice for declaring that someone \nis working on a book. Other project books can extend these definitions through specification on their \ndefinitions pages as a way to rehearse whether the extensions should be recommended. Whenever the team \nmanager sees overlap of effort, the overlap is moved to a separate project book and assigned as a new \npartition. The release manager owns a Results Project Book, that imports all the Course and Project Books \nassigned to subteams, and containing the integration test on its completion criteria page. Do this recursively, \nand you have a team structure patterned after the system structure, documented by test suites and both \npurpose and implementation documentation. Add the idea that analyses can be done independently to determine \nthe partitioning, and you can tie results to goals, objectives, and roles/ responsibilities that come \nfrom documented analyses. Good software engineering practices are therefore intended to be implicit in \nthe use of the learning books, although we do not make a fuss of these practices as unusual or additive, \nbut rather fundamental to working on software development.  Reference Humphrey, W. S., A Discipline \nfor SofhYare Engineering, Addison-Wesley: Reading, MA, 1995. Tuchman, Barbara W., The March of Folly, \nAlfred A Knopf: NY, 1984. Addendum to the Proceedings OOPSLA 95 \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Adele Goldberg", "author_profile_id": "81332501028", "affiliation": "Chairman, ParcPlace-Digitalk, Inc.", "person_id": "PP14172630", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260218", "year": "1995", "article_id": "260218", "conference": "OOPSLA", "title": "What should we teach?", "url": "http://dl.acm.org/citation.cfm?id=260218"}