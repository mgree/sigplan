{"article_publication_date": "10-01-1995", "fulltext": "\n Objects and Relational Databases Jen- Yao Chung, Yi-Jing Lin IBM Thomas J. Watson Research Center, P.O. \nBox 704 Yorktown Heights, NY 10598, USA Daniel T. Chang IBM Database Technology Institute 555 Bailey \nAvenue, San Jose, CA 95150, USA Abstract The goal of the Object and Relational Databases workshop was \nto discuss current issues and future prospects in this field. We brought together re-searchers, architects, \ndevelopers, and users who have experience in adapting of relational database systems for objects, who \nhave encountered techni-cal issues in so doing, and who have visions what the future holds for relation \ndatabase systems: ex-tended relational, relational object, object rela-tional, or object-oriented? The \nworkshop was held on October 16, 1995, Monday, Austin, Texas. The position papers can be obtained from \nthe work-shop homepage URL: http://pertsserver.cs.uiuc.edu/members/ jychung/oopsla95-aorkshop.html  \nWorkshop Organizers Daniel T. Chang Co-Chair IBM dtchangQvnet.ibm.com Jen-Yao Chung Co-Chair IBM Research \njychungQwatson.ibm.com Tai-Yi Huang Homepage Editor Univ. of Illinois thuang@lcs.uiuc.edu Yi-Jing Lin \nProceedings Editor IBM Research yjlQwatson.ibm.com 1 Introduction Relational database systems have dominated \nthe data management scene since their first appearance I5 years , ago. The relational database technology \nis by now a ma- ture technology, and many relational database products exist today. Most business database \napplications are relational database applications, and there is a tremen-dous amount of business data \nresiding in relational data-bases. The success of relational database systems can be attributed to a \nnumber of factors. The relational model is easy to understand and has a theoretical foundation. The SQL \nis a declarative, integrated database language. The architecture encompasses the full range of function- \nality: data definition, data manipulation, query, data control, transaction management, etc. Moreover, \nthe schema catalog uses the same relational model to rep- resent metadata information. Relational database \nsystems, however, are facing an unprecedented challenge because of the onslaught of object-oriented technology. \nThe object model gives users a more natural and flexible way to model complex data structures, like those \nused in multimedia, com-pound document and computer-aided design applica-tions. Object-oriented programming \nalso helps software engineering by promoting encapsulation and software reuse. Consequently, almost every \nprogramming lan-guage is adding object extensions, from C++ to Object Basic to Object Cobol. Distributed \ncomputing is also going object-oriented. If adapted well to objects, relational database sys-tems can \ntransform and elevate themselves to a new level of dominance: becoming the predominant stores of not \njust data but also objects. Adapted poorly, re-lational database systems may become ad hoc, rigid, restricted \nand forever be labeled as legacy . 2 Existing Approaches A number of approaches have been undertaken \nby ven-dors, clients and researchers to adapt relational data-base systems for objects. These include: \n. adding object eztensions to the relational model One of the most significant and comprehensive ef-fort \nis the development of SQL3 by the ANSI X3H2 Working Group. . adding object layers on top of relational \ndatabases This can be done within a relational DBMS or as an add-on facility/product. . adding object \ngateways to relational databases An example will be an object-oriented database to relational database \ngateway. Austin, TX October 1519,1995 . building object middleWaTeS foT access to relational databases \n This may be based on the OMG Object Services Specifications, which include Persistent Object Ser-vice, \nObject Query Service and Object Transaction Service. The last three approaches require a mapping layer \nwhich maps the object model to the relational model and vice versa. Each of them may be used in conjunc-tion \nwith the first approach. There can be significant advantages to these ap-proaches, which essentially \nprovide object-relational or object-oriented access to relational databases: . The underlying database \nsystem can support tra- ditional business applications through the standard relational interface and \nsupport advanced multime- dia or compound document applications through the object-oriented interface. \n . Existing data in relational databases can be reused, through tuple-to-object translations, by new \nad- vanced applications via the object-oriented inter- face. . The numerous advantages, such as parallel \nquery processing, of existing relational database technol- ogy continue to be exploitable by both old \nand new applications.  3 Technical Issues Significant technical issues, however, have been encoun-tered \nin the above approaches. Among these are: . data model . schema mapping . query language and processing \n0 performance . theory As an example, performance is a major consider-ations in storing persistent objects \nin relational data-bases. There will be significant overhead if fine-grain ob-jects are merely translated \nto tuples because navigation through object links will cause expensive join operations in the database. \nAs another example, schema mapping involving object identity and relationships among ob-jects are major \nchallenges. 4 Topics of Interests This workshop focused on the following topics: . object extensions/interfaces \nto the relational model (particularly SQL3) . object-oriented extensions of data definition lan- guages \nand data manipulation languages  Addendum to the Proceedings OOPSLA . object layers on top of relational \ndatabases (e.g., HP s Odapter) . object gateways to relational databases (e.g., ODI s ObjectStore gateway \nto relational databases) . object middleware or multidatabase for access to relational databases (e.g., \nbased on OMG Object Services) . standards for relational DBMSs as persistent ob-ject servers (e.g., operating \nin the CORBA envi-ronment) . SQL for query on objects (what extensions are re-quired?) . experiences \nwith system integration of relational and object model (what will be the unified model?) . impedance \nmismatch between object-oriented pro-gramming languages and relational database sys-tems (what s the \nprospects, is this going to get bet-ter or worse?) . theory of objects and relations . manifestos (the \nfirst, the second, the third, or the fourth?)  5 Present at ion Summaries This section gives brief summaries \nof the presentations. The presentations are group into four categories: data access, persistence, class \nlibraries and applications, and databases. The summaries were summarized and pro- vided by presenters. \n 5.1 Object-Relational Data Access and Mapping . Utilizing Relational Databases in Object-Oriented Systems, \nby Dad Peterson, EMA Services Developers should utilize relational database man-agement systems to support \nobject-oriented imple-mentations by using a services-centric approach which use stored procedures in \nthe RDBMS. This is contrary to the more popular approach of us-ing the RDBMS as an object repository \nwhich usu-ally raises many complex data mapping issues. In-stead, the RDBMS should be treated as a collec-tion \nof services and datasets with well-defined en-try points for these services. In a sense, the data is \ncontained within objects in the RDBMS and is accessible by sending messages (requests for ser-vice) to \nthese RDBMS procedures. This focus de-emphasizes the data (persistence) aspects of the problem and instead \nemphasizes an interface be-tween the relational and object worlds based on the service being provided. \nThe efforts of the software designer needs to shift to analysis of what belongs in the relational side \nverses the object side of the 95 165 solution. This analysis needs to consider what data is already \npresent in the existing RDBMS and, as a result, what services are implied by its presence there. Quite \noften this will result in the need to im-plement additional programming to the relational side to provide \nthe service for the object side. The Danger of Design Theory vs. Practice, by Ken Auer, Knowledge Systems \nThis presentation discussed the real difficulty of the issues of mapping objects to relational data-base \non a large scale that may not be apparent during high-level design. We illustrated our point by presenting \nsome experiences we had with clients where applications were centered around a large, complex database. \nAlthough there are many ways to interface between object-oriented languages and an RDBMS, we have found \nthat the most effective way is to build a database broker layer. However, many people try to oversimplify \nthe complexity of building an efficient broker layer which will scale well. Making a decision to develop \na broker layer is a good one. Building a good broker layer is not triv-ial. Even a well-built broker \nlayer will not totally shield you from the problems of trying to store com-plex hierarchical data in \nflat relational databases in an efficient manner.  Object-Relational Modeling and Implemen- tation, \nby Catherine Herring, ALCOA Our Object to Relational Mapping is very simple. Except for a few administrative \ntables, each table represents a class. The class to table mapping is horizontal rather than the more \nusual vertical map-ping. So all attributes whether inherited or local to a class are stored in one table. \nAll objects have unique ids. Attributes with objects as values, store the ids of those objects. Our meta-model \nincludes a set of fundamental relationships held between objects such as Part-Of, Kind-Of, and Sequence. \nThey are also classes and therefore are stored in corresponding tables. The programmers interface to \nthe database is written in Visual Basic and in-cludes calls such as GetObjectsQuery, MakeClass, MakeObjectInClass, \nGetAttributeValues, etc. In addition, API includes functions that traverse the fundamental relationships \ndescribed above. Ob-jects are represented in memory in only one generic structure we call a Referent, \nrather than duplicat-ing the object model in corresponding class struc-tures as is done with C++ interfaces \nto Object Models. An object s attribute values are retrieved only when asked. The values are returned \nin arrays of Referents, the same memory structure used for objects. The memory structure has a tag indicat-ing \nwhether the value is a pointer or a literal value. Because of this generic memory structure, the ap-plication \ncan create classes dynamically. We have not been completely successful in mapping true ob-jects to true \nrelational models. Because of our very small databases we are able to avoid solving some of the problems. \nFor example, multiple valued at-tributes can not be normalized into separate tables without adding a \nlot of indirection that our sim-ple class-table mapping would require. So we have prejoined multiple \nvalued attributes into their class table. Also, we do not implement object behav-ior. Instead we model \nprocesses as classes. They are used for declaring the domain information and are not executable operations. \nOur current solu-tion is good for our decision support application in which users will browse and store \ndomain descrip-tions rather than execute high volume transactions. We could not have used a solution \nthat did not al-low dynamic class creation. . Integration of Relational and Object Mod- els, by Sai Guniuri, \nBurlington Northern &#38;dTOad In today s development world (especially in For-tune 500 companies), object \noriented applications and relational databases are the norm and will con-tinue to be for a long time. \nThe complex and chang-ing needs of users require taking an object oriented application development approach. \nIn order to use the sheer bulk of legacy data in relational data-bases, it is required to integrate object-oriented \nand relational models. If the mainframe target environ-ment is COBOL/DB2, this integration requires to \nhave objects instantiated in some form in the main-frame environment to execute business logic and to \nretrieve persistent attributes from IBM DB2. Af-ter generating the object model, object interaction graphs, \nand then class definitions for an applica-tion See the position for the recommended steps to implement \nobject-oriented design in the main-frame (COBOL/DB2) environment. 5.2 Object-Relational Persistence \n. Issues in Making Objects Persistent in Re- lational Databases, by David Parkhill and Bill Friedman, \nIBM Current attempts at extensions to relational data-bases management systems (RDBMS) to accommo-date \nobjects are inadequate to meet the needs of enterprise object applications. Rather, time and energy should \nbe spent on creating object oriented database management systems (OODBs) that have the essential robustness \nfeatures of relational sys-tems while providing direct language and struc-tural support for objects. \nThese features include concurrency control and recovery, query language support and high performance \ntransaction process-ing for business applications. This perspective is supported by our experience in \nthe construction of more than half a dozen commercial applications for Fortune 500 clients using object-oriented \ndesign and programming techniques in conjunction with a relational database manager as a persistence \nmech- anism. . Object Persistence: the Application Pro-  grammer Perspective, by Peter Heinckiens and \n Ghislain Hoffman, U. of Ghent, Belgium The choice between 00 databases and relational systems is a topic \nof much debate. This topic is indeed important when looking at it from a data-base administrator s point \nof view. However, to the software developer, idealy it should be of no con-cern at all. All he is interested \nin, is to make his objects persistent, and this regardless of the tech-nology used. It could be network, \nrelational, ob-ject oriented, but it could e.g. also be an object request broker. A very important advantage \nob-ject databases offer to the software developer, is the absence of the impedance mismatch between the \napplication and the persistent storage. How-ever, this is not so much a property of the ODBMS as such, \nbut of the 00 view it offers on the data-base. In this regard, we could picture the ob-ject database \nas consisting out of two parts, firstly the database technology itself, concerned with the physical storage \nof thi-data. The second part is an impedance mismatch (I.M.) resolver that maps the transient objects \nonto the physical database. In most other storage technologies (including re-lational databases), on \nthe other hand, only the first part is present, while the I.M. resolver is miss- ing. This means that \nfrom a software developer s point of view, we should concentrate on developing I.M. resolvers, and this \nregardless of the database technology underneath. In this way, applications will be able to use the full \nbenefit 00 has to offer, without having to commit themselves to a single database system, technology \nor even layout. This approach will not only accommodate future tech-nologies, but will also allow companies \nto continue to use legacy systems, in this way protecting a huge investment and allowing for a smooth \nmigration to modern technologies . SCOOP, an 00 persistence architecture that implements the above-mentioned \nprinciples, was presented. It was also shown how it allows to almost completely hide the fact that a \ndatabase is involved at all, meaning that to the pro-grammer there is no fundamental difference any-more \nbetween transient and persistent objects. Automated Mapping and Object Persistence to Relational Databases, \nby Hubert &#38;LmeTstoT-fer and Josef Altmann, Johannes Kepler U., Aus- tria In various industrial project \nwe have seen the neces-sity for the coexistence and collaboration of object- oriented technology and \nrelational databases. I presented two collaborating subprojects that are dealing with the issue of mapping \nobjects to re-lational databases. The first subproject is part of an object-oriented fourth-generation \nsystem which offers generic front-end-functionality for a (rela-tional) database. A structural object \nmodel, which offers the possibility to define object types with attributes of complex domains and inheritance, \nis the starting point for a generic mapping strat-egy to a relational database. All necessary meta-information \nfor the organization of the relational structure and the foreign key dependencies can be set up when \nstarting an application with an attached object model. The aim for the second project is to provide a \ntool that can store and share arbitrary existing objects in a relational database without requiring any \nchanges in the class defin-ition or coding of additional methods. Thus the user does not need to deal \nwith some form of rela- tional model and is able to use the provided storage and retrieval mechanism \nimmediately for an object-oriented application. 9 Some Generic Correspondences to Define Object Databases \non Top of Relational Data-bases, by Franck &#38;bastard, INRIA, France The author has defined generic \ncorrespondences be-tween relational concepts and some of the object concepts that are common to most \nobject mod-els. They allow to translate relational data into complex objects and conversely. This presentation \npresents them and show how they can be utilized in relational reengineering for example. The pre-sentation \nends by presenting the benefits of this approach, which is validated throughout the DRI-VER system that \nuses these correspondences to de- fine an OODBMS on a RDBMS.   5.3 Class Libraries and Applications \nThe Relational Object Class Library, by Tony Kerz, Pratt &#38; Whitney Aircraft The presentation described \na C++ class li-brary/framework which allows the definition of classes that have persistent behavior against \na stan- dard relational database. The details of the per-sistence mechanism are hidden from the clients \nof these classes, but transaction management and concurrency control are exposed. The system is currently \nbeing referred to as the Relational Ob-ject Class Library (ROCL). The persistent behav-ior provided by \nROCL includes creating, fetching, updating and deleting objects. ROCL also provides the ability to define \nrelationships between classes. A powerful feature of the system is the ability to traverse relationships \nin the specification of search criteria. DBTools.h++: A class library to bridge re-lational and object \ntechnology, by Allan VeT-meulen, Rogue Wave Software Tuples and objects are different sorts of abstrac-.tions \nthat can be used to model entities. They are useful in different contexts. Often, it is useful to model \nthe same entities with both. This means that we need a bridge tool to map from one ab-straction to the \nother. DBTools.h++ is a C++ class library that enables this mapping to be done in a simple, policy free \nway. Reflections on Object-Relational Applica- tions, by Paul Turner and Arthur Keller, Persis- tence \nSOft/StanfOTd U. This presentation presents some practical insights, hints, and guidelines for building \nobject-relational applications with C-t+, Persistence, and RDBMS. Architectural, modeling, and database \nissues are the primary issues covered. The insights presented are the feedback collected from the Persistence \ncus-tomer base. Odapter: An Object-Relational System, by Rafiul Ahad, HP Odapter is a mature Object-Relational \nsystem that is meant for the development of scalable and highly-available enterprise business object \nservers. It has capabilities not only to support the creation of new server-based business objects, but \nalso to encap-sulate existing data and related procedures into enterprise business objects. Odapter is \nshipped with a set of tools that support seamless access to enterprise business objects from both C++ \nand Smalltalk programs.  5.4 Object-Relational Systems and Databases . Comments on Merging Objects with \nRela- tional Databases, by Frank Manola, GTE Lab. The presentation made several points concerning the \nproblem of merging object and relational con-cepts in the same database. First, a clear concept of what \nis desired from a proposed merger is nec-essary. Work such as the ongoing efforts on the SQL3 and ODMG-93 \nspecifications can provide im-portance guidance here. Second, a solid theoretical foundation is essential \nin providing the basis for query optimization and view facilities, as well as for sound language design. \nHowever, the relational foundations require careful extensions to deal ad-equately with objects. Simply \nadding objects as a new data type without dealing with all aspects of the resulting mixture of concepts \ncan create a model with peculiar features, as illustrated by ear-lier versions of SQLJ. Third, a smooth \nmerger of object and relational concepts will be hard to achieve if the differences in viewpoint taken \nby the two models are not thoroughly understood. Fourth, there is a lot of theoretical work on, for example, \nobject algebras and calculi, and object logics, that can be applied to the problem. A list of references \nis provided in the position paper. Finally, some practical steps are being taken to merge the models, \nspecifically, joint work by the ANSI SQL committee and ODMG on merging their standards. Some of this \nwork was discussed at the Objects and Data-base Standards panel at the conference. . OORL: A Declarative \nand Object-Oriented Database Language, by .&#38;nest Rotterdam, U. of Amsterdam, Netherlands 168 Austin, \nTX OORL is a Database language that is currently being developed. OORL will be both declarative and Object-Oriented. \nOORL will be an Object Oriented extension of RL, a database language in which relations can be defined \nby means of ta-bles, equations, inequalities and Horn clauses. For querying and updating relations that \nare in part defined by means of equations or inequalitities, a constraint solver is used. In OORL relations \ncan contain objects. Objects can contain relations and attributes. Attributes and relations of a particu-lar \nclass can be related by means of constraints, that is relations that should hold. Attributes of classes \nor relations can be of different storage types: data, virtual and object. A typing mechanism is de- veloped \nfor OORL classes such that polymorphism will be possible for relations. SQL3 Object Extensions, by Linda \nDeMichiel, IBM SQL3 is the name given to the new draft of the ANSI/IS0 standard for the database language \nSQL. SQL3 is a completely upwardly compatible extension of the current international standard for SQL, \nSQL92, and is likely to become an interna-tional standard replacing SQL92 in 1997 or 1998. One of the \nmost important areas that SQL3 ad-dresses is the need to increase the semantic content of the data stored \nin relational databases. This is accomplished by allowing users to define new data types and functions \nto represent the objects in their application domains. Instances of these data types can be stored as \nthe values of columns in tables, manipulated through host variables, and passed as arguments and returned \nas results of functions. The object-oriented extensions of SQLs include user-defined abstract data types \nsupport-ing subtyping, multiple inheritance, encapsulation, and object-identity; function overloading; \nand dy-namically dispatched user-defined functions. Object Integration Server, by John Petrie, ON-TOS \nONTOS Object Integration Server (01s) supports mappings between application objects and one or more databases. \nONTOS 01s provides an effec-tive means to enable object-oriented application development for users who \nneed to accommodate some combination of RDBMS, pre-relational, and ODBMS data environments. Data mappings \nare stored in a common repository, enabling reuse and ease of maintenance. ONTOS 01s includes a vi-sual \nschema mapper for capturing existing data-base schemas and creating mappings between the object model \nand the database. ONTOS 01s sup-ports flexible mapping options, allowing objects to be defined in ways \nthat are more than simply a lit- eral translation of the underlying database schema into object-oriented \nsyntax. The programming en-vironment supports a C++ API and connection to October 15-19, 1995 Oracle, \nSybase, and ONTOS DB, or to other data environments through the Custom 01s.   Conclusion In this workshop \nwe discussed issues in integrating rela-tional databases with object-oriented systems. We be-lieve the \nworkshop was a success the attendance if was any indication. Thanks to the presenters, we covered most \nof our interests. Thanks to the participants, we had very productive interactions between the audience \nand presenters. The only complaint we received was that the presenters wished to have more time to present \nand discuss their work. We are looking forward to seeing everyone again in a future workshop. Acknowledgments \nWe would like to thank Dr. Qianshan David He for his help in preparing the workshop proposal. We would \nalso like to thank all of the participants for their valuable contributions to the workshop. References \nThe position papers from this workshop are available at the workshop homepage: http://pertsserver.cs.uiuc.edu/members/ \njychung/oopsla95-workshop.html  Participants We would like to thank the following people for partic- \nipating in the workshop. Ken Auer Knowledge Systems kauerOksccary.com Peter van Emde Boas U. of Amsterdam, \nNetherlands Peter&#38;fwi.uva.nl Ruey-Juin Chang Tony Cocchi Linda DeMichiel Stephane Demphlous Bill \nFriedman Sai Gunturi Peter Heinckiens Catherine Herring Shyh-Mei Ho Tony Kerz Franck Lebastard Joe Leslie \nAshok Malhotra Frank Manola David Peterson John Petrie Ernest Rotterdam Hurbert Rumerstorfer Hartmut \nSchreiber Paul Turner Allan Vermeulen Mike Wright Citicorp ruey-juin.chang@citicorp.com IBM tonyQwatson.ibm.com \nIBM LGDQALMADEN INRIA, France Stephane.Demphlous@inria.fr IBM wmmf@vnet.ibm.com Burlington Northern Railroad \nSai-V-GunturiQsmtp.bnr.com U. of Ghent. Belnium Peter.%inckien&#38;ug.ac.be ALCOA herringxa@atc.alcoa.com \nIBM SMHOOvnet.ibm.com Pratt &#38; Whitney Aircraft kerzalOpweh.com INRIA, France Franck.LebastardQsophia.inria.fr \nONTOS, Inc. leslieOontos.com IBM malhotraQvnet.ibm.com GTE Lab. fm02agte.com EMA Services dpetersoOema-inc.com \nONTO S, Inc. John-PetrieOontos.com U. of Amsterdam, Netherlands ernest@fwi.uva.nl Johannes Kepler U., \nAustria rumerstorferOswe.uni-linz.ac.at FZI schreiberQfzi.de Persistence Software turnerQpersistence.com \nRogue Wave Software alvQroguewave.com IBM mwrightQwatson.ibm.com \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Jen-Yao Chung", "author_profile_id": "81100293137", "affiliation": "IBM Thomas J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP35040749", "email_address": "", "orcid_id": ""}, {"name": "Yi-Jing Lin", "author_profile_id": "81100224382", "affiliation": "IBM Thomas J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP39033342", "email_address": "", "orcid_id": ""}, {"name": "Daniel T. Chang", "author_profile_id": "81541853656", "affiliation": "IBM Database Technology Institute, 555 Bailey Avenue, San Jose, CA", "person_id": "PP311512800", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260273", "year": "1995", "article_id": "260273", "conference": "OOPSLA", "title": "Object and relational databases", "url": "http://dl.acm.org/citation.cfm?id=260273"}