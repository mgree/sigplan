{"article_publication_date": "10-01-1995", "fulltext": "\n Report on the Workshop on Object-Oriented Real-Time Systems Workshop Co-Organizers Bob Wilhelm John \nGilbert Objective Control Objective Software rwilhelm@acm.org gilbert@acm.org Abstract The Workshop \non Object-Oriented Real-Time Systems has been conduced each year at OOPSLA since 1988 with a variety \nof formats. In this year s workshop, participants submitted position papers on a broad range of subjects, \nbut were all asked to show the relevance of their work to three critical issues in 00 real-time systems: \ndealing with time constraints; the roles of reactive versus scheduled behavior; and appropriate models \nof concurrent behavior. All position papers were presented and discussed during the workshop, followed \nby a round-table discussion of the state of the art regarding the three focus issues. Workshop Focus \nParticipants in the Object-Oriented Real-Time Systems Workshop were requested to focus on three issues \nof prime importance to developers of real-time systems (the utorkshop issues): Issue I: Dealing with \ntime constraints in object-oriented real-time systems. The essential difference between real-time and \nnon-real-time systems systems support the applications within constraints. How are specified and enforced \nis that real-time execution of specified time these constraints in an object- oriented system? What support \nis required from languages and operating systems? Issue 2: Issue 3: Position Mohamed Fayad University \nof Nevada, Reno fayad@cs.unr.edu Reactive behavior models versus scheduled behavior models in object-oriented \nreal-time systems. The object model is particularly adept at representing reactive systems; that is, \nsystems which respond on demand to random events. Many traditional (non-object-oriented) systems depend \nupon the distribution of work among relatively rigid periodically scheduled tasks to achieve predictable \nreal-time behavior. There appear to be important roles for both of these paradigms (and perhaps others) \nin real-time applications. How can object-oriented systems combine them most effectively? Concurrent \nbehavior models for object-oriented real-time systems. Most real-world concurrent programming developed \nto concurrency, real-time systems exhibit behavior. Various models have been emulate or support ranging \nfrom communicating concurrent processes, each supporting a collection of ordinary passive objects, to \nsystems of independent concurrent active objects (actors). We would like to catalog these and assess \nthe current state of the art in their application. papers were solicited from all workshop participants. \nThe ground rules were that position papers could discuss any subject relevant to object-oriented real-time \nsystems, but that the discussion in the workshop would revolve around the workshop issues listed above, \nand participants would be expected to discuss how their work related to one or more of those issues. \n Position Papers Position papers were presented throughout the morning and first half of the afternoon. \nTime was allowed for questions, answers, and brief discussion following each position paper. Brief comments \non each presentation are offered here. Readers are invited to contact the authors directly for copies \nof their position papers. Those authors in attendance at the workshop are listed in italics. Authors: \nMaher Awad, Jurgen Ziegler, &#38; Juha Kuusela Affiliation: Nokia Research Center Paper: Object-Oriented \nDevelopment of Real-Time Systems with OCTOPUS OCTOPUS is an object-oriented method for developing real-time \nsystems developed by the authors at Nokia Research Center. It builds on the popular OMT and Fusion methods, \naugmenting them to deal with the special problems of real-time applications. Being based upon popular \ngeneral purpose methods, it claims the ability to use readily available CASE tools which provide facilities \nfor users to add new notations. The OCTOPUS method defines structural, functional, and dynamic models \nat system, subsystem, class, and object levels. It defines phases for requirements specification; architecture \ndefinition; subsystem analysis, design, and implementation; and mapping components to threads, processes, \nand hardware components. It supports the specification and enforcement of time constraints (workshop \nissue l), mapping event threads to objects synchronously or asynchronously (workshop issue 2), and various \nmappings of threads to objects to support concurrent behavior (workshop issue 3). Author: Ray Buhr Affiliation: \nCarleton University Paper: Issues in Bringing Object- Orientation and Real-Time Together This presentation \ndiscussed the contributions of Use- Case Maps (formerly TimeThreads) in bringing the areas of object \norientation and real time together. Many techniques for design are oriented toward either high level \nrequirements or low level design issues. Use Case Maps focus on end-to-end behavior of systems, incorporating \nnotions of paths, responsibilities, and couplings between paths, all of which may be mapped onto various \nstructural models of systems. With respect to time constraints (workshop issue l), Buhr points out that \nreal-time constraints usually have to do with end-to-end response times, which are easily lost in the \nshuffle with conventional object models, but captured explicitly by Use Case Maps. Similarly, Use Case \nMaps help clarify the appropriate choice of scheduled vs. reactive behavior (workshop issue 2), which \nis difficult to derive from object models themselves. Finally, Use Case Maps have formal graphical semantics \nfor concurrency (workshop issue 3), and take a broad view of object models, including not only problem \ndomain objects, but concepts such as layers, processes, subsystems, and so on. Authors: Eran Gery and \nMichael Hirsch Affiliation: i-Logix Israel Ltd. Paper: A Moderate OORT Concurrency Model Primarily focusing \non effective models for concurrent behavior in OORT systems (workshop issue 3), this paper makes the \ncase that the currently prominent models for concurrency exist near two extremes of a continuum. Traditional \ntask-based models usually support only a small number of statically allocated tasks with little relationship \nto the Austin, TX October 1519,199s object model. The (usually many) passive objects executing in a single \ntask enjoy efficient communication, but no concurrency with each other. At the opposite end of the spectrum \nare the actor-based (active object) models with a proliferation of concurrent micro-tasks employing a \nsomewhat less efficient message-passing communication. The authors moderate concurrency proposal comprises \na blend of a moderate number of active objects, combined with passive objects encapsulated within the \nactive objects, protected objects (similar to Hoare s monitors) which can be shared between active objects, \nand events as first class objects (which support subclassing) to support communication. Author: Bill \nFoster Affiliation: Bell Northern Research Paper: Current Work Combining Reactive and Scheduled Behavior \nat BNR Foster s presentation described project experience at Bell-Northern Research employing a combination \nof conventional 00 design methods (OMT supported by Paradigm Plus) and the ROOM methodology (actor model \nsupported by ObjecTime). The project itself is distributed, with design teams in Research Triangle Park, \nNC, USA, and Ottawa, Ont., CA taking responsibility for major subsystems. The project undergoes continuous \nintegration using the ObjecTime toolset. Most of the system is reactive in nature (workshop issue 2), \nand employs preemptive multithreading in the operating system underlying the ObjecTime virtual machine \nlayer which supports the message passing actor model. Thus there are two levels of granularity of concurrency \n(workshop issue 3). Author: Bran Selic Affiliation: ObjecTime Ltd. Paper: Periodic Tasks in ROOM ROOM \n(Real-time Object-Oriented Modeling) is an object-oriented modeling language based on an event-driven \nparadigm. This paper describes a simple extension to) to add a simple form of scheduled behavior to the \nfundamentally reactive model of ROOM (workshop issue 2). In ROOM, priorities are associated with events \n(messages), not tasks, and timing is provided by system services which generate timeout events which \nare queued and scheduled like any other message. Currently ROOM timers can be described by T: (T, A, \nP, X), where T is a time duration, A is the destination of the event (a state machine, P is the priority \nof the event, and X is optional data which may be delivered with the timeout message. The extension proposed \nis a periodic timer, T,: (T, D, C, A, P, X), where T is now the period of the timer, D is the deadline, \nand C is the maximum expected processing time required to handle the timeout event. It is intended that \nthis mechanism should make it possible to implement scheduling policies such as rate monotonic, deadline \nmonotonic, and earliest deadline first, separating the scheduling of periodic timing events from all \nother nonperiodic events. Author: Leonor Barroca Affiliation: The Open University Paper: Specifying Reactive \nSystems Behavior Harel s Statecharts are a very popular means for expressing behavior in reactive real-time \nsystems. This paper discussed an extension to statecharts, Timed Statecharts, and the automatic translation \nof timed statecharts into a set of axioms expressed in a temporal logic (RTL) to permit reasoning about \nthe properties, including safety, associated with the timing constraints. Most timing requirements can \nbe expressed in terms of bounds on the difference between the occurrence of two events. The work adopts \nthe usual view that time elapses in states and state transitions are instantaneous. The approach encourages \nconsideration of timing constraints in real-time systems as early as possible in the development. It \nis particularly attractive because it combines the use of a popular visual formalism (statecharts) with \na mathematical formalism (RTL). Authors: Wouter Loosen, Stijn Bijnens Joosen, Johan Van Oeyen, Pierre \nVerbaeten, and John Perram Affiliation: K. U. Leuven and LCAM Odense Paper: Distributed and Real-Time \nProgramming using a Concurrent Object-Oriented Language: a status report CORRELATE is a concurrent object-oriented \nresearch language which combines a base-level application model which models the real world problem domain \nusing concurrent, distributed objects, with a meta-level object architecture which schedules the execution \nof the base-level object model. Each base-level object is associated with an individual meta-level object \nwhich controls its execution. There is also a hierarchy of schedulers available in the meta-level. CORRELATE \nobjects are abstract state machines which exhibit both reactive behavior and autonomous behavior not \ntriggered by external stimuli. CORRELATE supports both synchronous and asynchronous message passing, \nexplicitly selected by the programmer. In addition to the conventional form of directed message, CORRELATE \nsupports a novel form of pattern-based communication, whereby the message sender can specify a set of \nobjects to receive the message based upon a set of properties (values of attributes). It also supports \nsynchronization conditions for time-constrained operations, with preconditions and postactions. Ongoing \nresearch includes the identification of appropriate language constructs for time constraints (workshop \nissue I), and case studies, such as a robotic system. Authors: Christer Eriksson, Mikael Gustafsson, \nJan Gustafsson, Jukka Make-Turja, Henrik Thane, Kristian Sandstriim, and Ellus Brorson Affiliation: Malardalen \nUniversity Paper: RealTimeTalk: a Fram ework for Object-Oriented Hard and Soft Real-Time Systems RealTimeTalk \nis a framework for developing distributed real-time applications, supporting both soft and hard real-time \nconstraints. It consists of an application model, a system architecture, and a language. The application \nmodel is based on a hierarchical decomposition using predefined objects to represent modes (of operation), \nmode transitions, use-cases (somewhat different from Jacobson s) and schedulable objects. The language \nsyntax and semantics are based on Smalltalk with some restrictions to enforce determinism (workshop issue \n1). The language includes a type inference system which produces more efficient code and eliminates run-time \nchecks while freeing the programmer from having to declare types. RealTimeTalk separates the HRT and \nSRT parts of behavior (workshop issue 2) by duplicating part of the state-space of an object and providing \nan atomic commit operation to synchronize them. Author: I/ham Benyahia Affiliation: Institut de recherche \nd Hydro-Quebec Paper: An Object-Oriented Real-Time Management System for Complex Applications This presentation \ndealt with a real-time event management approach for complex systems such as electrical distribution, \nlarge-scale communications systems, and aerospace monitoring systems. The objectives are to guarantee \nresponse times in the face of component failures (workshop issue 1). In this work, actions and the nondeterminstic \nevents which trigger them are both treated as objects. When an event occurs, the context of the system \nand its environment are verified, and the event communicates with an appropriate set of actions. An events \nmanager interacts with the operational system under management through sensors and effecters. The events \nmanager uses both a knowledge base and procedural elements to process the events. The structure of the \nevents manager system is considered to be generic, independent of the system under management. Its major \nmodules are an evaluator, which assesses an event before executing actions; a scheduler, which ranks \nand reorders actions according to conditions; and an executor, which carries out the actions. Authors: \nTai-Yi Kuan, Win-Bin See and Sao-Jie Chen Affiliation: National Taiwan University Paper: An Object-Oriented \nReal-Time Framework and Development Environment This presentation described an object-oriented real-time \nsystem framework and development environment for periodic task real-time systems (workshop issue 2). \nThe basic premise is that correctness in a real-time system is primarily dependent on its timing behavior, \nthe requirements for which are imposed by the process it controls. The framework supports three system \ntask scheduling methods which have proven theoretically sound and practically useful: cyclic scheduling, \nrate monotonic scheduling, and earliest deadtime scheduling. The framework includes a scheduler object, \na task map object, and one or more application task objects. Task scheduling is done statically and verified \nbefore run-time. The development environment performs these functions, and also provides statistical \ninformation at run-time. Limits are placed on the use of polymorphism and dynamic creation of objects \nto realize more nearly deterministic behavior and assure correct performance. Discussion of the Workshop \nIssues Following the presentation and discussion of the position papers, a general discussion was conducted \non each of the three workshop theme issues. During these discussions we listed a set of assertions and \nobservations made by the workshop participants. What follows is basically a summary of those observations. \nAlthough it would be going too far to say that there was consensus on each these observations, there \nwas enough discussion to conclude that each was accepted as a plausible assessment of the state of the \nart of 00 real-time systems. In the following paragraphs, we simply paraphrase the list of observations \nmade from the discussion. Issue 1 -Dealing with Time Constraints Analysis and design method have the \nresponsibility for specifying time constraints in real-time systems. Current methods for specifying time \nconstraints during design are often ad hoc, and the methods for assessing the implications of design \ndecisions on time constraints are weak. Timing constraints should be expressed as early as possible in \nthe analysis or design process. Formal analysis tools are needed for time constraints. Rate Monotonic \nAnalysis and other scheduling algorithms are good and useful tools for building hard real-time systems. \nHowever, most of the tools available for formally dealing with scheduling and time constraints are most \napplicable only very late in the design process --that is, too close to implementation. We need to identify \nspecific places in models to specify time constraints. Methods for object decomposition should propagate \nand decompose time constraints. We want methods to capture the temporal implications of architectural \npatterns, including: Use-Cases (including autonomous activities as well as interactions with external) \nappear to provide a useful framework within which to express time constraints. They also form a basis \nfor traceability from requirements to design and back. Reusable components should also make it easier \nto consistently estimate/analyze real-time burden. . structural design patterns . behavioral design patterns \n. class hierarchies. We need to model the responsibilities of both implementation domain entities and \nproblem domain entities in meeting time constraints.  Issue 2 -Reactive vs. Scheduled Behavior Models \nThis problem is considered more nearly solved than the others considered in this workshop. It is generally \naccepted that both reactive and scheduled behavior models have value and can coexist in the same system. \nThe balance of their usage in a given application depends upon the nature of the problem. Complete analysis \nand design methods for real-time systems should support both reactive and scheduled models of behavior, \nand, furthermore, should provide means for determining problem decompositions and methods for mapping \nthese two models of behavior to the resulting object model which will lead to good implementations. \nIssue 3 -Concurrent Behavior Models in OORT Systems Perhaps because it was so late in the day, this discussion \nseemed to lead to a list of questions rather than answers. Among the questions and issues identified \nfor further research were: 1) What are the units of concurrency? Are they objects? Do they belong at \nthe same level of abstraction as application domain objects? 2) To what extent are entities used to model \nthe application problem orthogonal to the entities used to provide or model concurrency? 3) When is concurrency \nintroduced into the model? 4) How is concurrency described? (Some of the tools currently employed are \nUse-Case Maps and Statecharts). 5) What is the proper role of passive objects in models incorporating \nboth active and passive objects?  \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Bob Wilhelm", "author_profile_id": "81100325265", "affiliation": "Objective Control", "person_id": "P31363", "email_address": "", "orcid_id": ""}, {"name": "John Gilbert", "author_profile_id": "81332500772", "affiliation": "Objective Software", "person_id": "PP14190972", "email_address": "", "orcid_id": ""}, {"name": "Mohamed Fayad", "author_profile_id": "81339498936", "affiliation": "University of Nevada, Reno", "person_id": "PP31077568", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260282", "year": "1995", "article_id": "260282", "conference": "OOPSLA", "title": "Object-oriented real-time systems: report on the workshop", "url": "http://dl.acm.org/citation.cfm?id=260282"}