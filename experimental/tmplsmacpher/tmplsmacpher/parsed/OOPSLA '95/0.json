{"article_publication_date": "10-01-1995", "fulltext": "\n Why C++ is not just an Object-Oriented Programming Language Bjarne Stroustrup AT&#38;T Bell Laboratories \nMurray Hill, New Jersey 07974 ABSTRACT C++ directly supports a variety of programming styles. In this, \nC++ deliber- ately differs from languages designed to support a single way of writing pro-grams. This \npaper briefly presents key programming styles directly supported by C++ and argues that the support for \nmultiple styles is one of its major strengths. The styles presented include: traditional C-style, concrete \nclasses, abstract classes, traditional class hierarchies, abstract classes and class hierarchies, and \ngeneric programming. To provide a context for this overview, I discuss criteria for a reasonable and \nuseful definition of object-oriented programming. 1 Introduction There are many tools and techniques \nthat can help in our effort to build useful, economical, and maintain- able systems. To complete ambitious \nand complex projects, we rely on a wide variety of techniques and tools that must work together. The \ntitle of this paper singles out a programming language?. However, the real topic is programming, or if \nyou prefer a longer formulation, the design and implementation of systems. A programming lan-guage is \njust one of the means by which we try to achieve our goals. The definition of object-oriented program-ming \nis no longer a popular topic of discussion at major conferences. A practical definition of t This paper \nis primarily based on an invited talk with the same clearly affected by its origins as a relatively short \ntalk. I would but I did not have the time to do either. object-oriented programming, object-oriented \nanalysis,  object-oriented design,  object- oriented technology, etc., is, however, a burning issue \nfor people who want to turn the oft-repeated promises made for techniques and languages called object-oriented \ninto reality in everyday projects. It has become a practical rather than academic topic of discussion. \nWhat is object-oriented technol- ogy?, what benefits can be expected from it? at what risks?, how do \nthose techniques, benefits, and risks compare with those associated with altema- tives? A systems builder \ntrying to explain to an accoun- tant why money should be spent for tools supporting object-oriented techniques \nneeds more than a state-ment to the effect that object-oriented is great or that really great techniques \nare really object-oriented. You simply cannot ask someone to bet their company s future on vague promises \nphased in ill-defined terms. Nor is a well-polished and logi-cally coherent semi-mathematical treatment \nof the title given at OOPSLA 95 in Austin Texas. The style of this paper is have preferred this paper \nto be either much longer or much shorter, subject of direct practical use. We need to define object-oriented \nto be some- thing specific so that we can point out specific bene-fits and risks associated with its \nuse. We must also be specific about what is nor object-oriented, and what benefits and lack of benefits \nwe can expect from various non-object-oriented techniques. Consequently, this paper starts out discussing \nwhat makes a good definition of object-oriented. Next, I present a range of useful techniques which may \nor may not be object oriented and discuss their advantages and disadvantages. 2 Defining Object-oriented \nTo be useful and intellectually honest, a definition of object-oriented must [I] not be a mere synonym \nfor good, [2] not exclude most accepted meanings, [3] have a firm historical basis, [4] exclude something. \nNot everything good is object-oriented, and not everything object-oriented is good. I think I can support \nboth claims from experience. I have seen examples of the latter often enough: it is not uncom-mon to \nfind programs that apply techniques usually deemed object-oriented extensively or even exclu-sively, \nyet are hard to comprehend, hard to maintain, and perform abysmally. Such examples occur in every programming \nlanguage. But then, of course, some people respond that just proves that the pro- gram wasn t truly object-oriented. \nTo which the answer must be that either the term has become meaningless or there must be something good \nbeyond what is called object-oriented. On the other hand, when we define object-oriented, we must not \nbe too exclusive. Object-oriented programming is a broad intellectual disci-pline, not the mere use of \nspecific language features. Attempts to define object-oriented to mean what I m selling are not uncommon, \nbut are fun- damentally sleazy. Any definition of object-oriented should be historically reasonable. \nWords are only useful for communication, really only mean something, if we agree on a meaning for them. \nThere are several plausible, logically coherent, and mutually contradictory definitions of object oriented \n in use. However, the mainstream usage stems directly from the ideas pioneered by programming language \nSimula and the design techniques it was developed to support. The communities of programmers and designers \ncentered around languages such as C++, CLOS, Eiffel, Object Pascal, and Smalltalk have contributed much \nto this tradition. A meaningful definition of any concept must exclude something.  3 A Broad Definition \nof Object-oriented Given these general criteria for a definition of object-oriented you can find several \nplausible candidates, and several communities have their own definitions. However, I suggest we stick \nto the tradi- tional definition of object-oriented used within broad communities of programmers. A language \nor tech-nique is object-oriented if and only if it directly sup-ports: [l] Abstraction -providing some \nform of classes and objects. [2]Inheritance -providing the ability to build new abstractions out of existing \nones. [3] Run-time polymorphism -providing some form of run-time binding. This definition includes all \nmajor languages com-monly referred to as object-oriented: Ada95, Beta, C++, CLOS, Eiffel, Simula, Smalltalk, \nand many other languages fit this definition. Classical pro-gramming languages without classes, such \nas C, For- tran4, and Pascal, are excluded. Languages that lack direct support for inheritance or run-time \nbinding, such as Ada88 and ML are also excluded. ML is a good example of something that is good but not \nobject-oriented. I like ML; it is an interest-ing, innovative, and powerful language, but it is functional \nrather than object-oriented and its poly-morphism is resolved at compile time rather than at run-time. \nThus, saying that ML isn t object-oriented is not a criticism, it s an observation about defini-tions \nand the nature of ML. Techniques and tools are object-oriented if and only if they support the use of \nobject-oriented pro-gramming. For example, a design method is object- oriented if its regular and proper \nuse leads to Austin, TX October 1%19,199s programs that exploit abstraction, inheritance, and polymorphism \nwhere appropriate. I strongly prefer design methods that directly and naturally support the use of at \nleast one of the major object-oriented languages supporting in ways that exploit its features in an idiomatic \nway. For example, it is often possible to simplify application code by hiding objects with different \nrep-resentations and different implementation details behind a common abstract interface (see $6.4 and \n36.6). Conversely, the implementation of related concepts can often be greatly simplified by exploit- \ning commonality through inheritance (see $6.5 and $6.6). A major purpose of design methods and the CASE \ntools that commonly support them is to make design simpler, more regular, and more predictable. Thus, \nto earn the label object-oriented, a design method must regularly and predictably help the dis- covery \nof commonality that can be exploited in these ways. Ideally, an object-oriented design method must strongly \nencourage the expression of this com-monality using the most appropriate facilities in one or more of \nthe languages supporting object-oriented programming. Minimally, the method and its sup-porting tools \nmust not be a hindrance to the use of object-oriented facilities in the programming lan-guage used to \nimplement the design. Much confu-sion arise because not every design method that claims to be object-oriented \ndoes that. Please remember that I m looking for a practical understanding of the notion of object-oriented \nrather than a formal definition. A formal definition is useful, indeed it may be essential. However, \nto be relevant, a formal definition must match a coherent view of what the formal definition is meant \nto spec- ify precisely. 4 Purity There has been much debate about purity, in the context of languages \nsupporting object-oriented pro-gramming. In my opinion, much of that discussion is confused by the -often \nunstated -assumption that not only does object-oriented imply good, but also by the further assumption \nthat only object-oriented features are good. Consequently, it is -wrongly -assumed that a language that \nprovides features deemed non-object-oriented must be worse than a language that does not. People who \nlike a language to support classes as part of a hierar- chy only and functions/methods attached to one \nspe-cific class only often call such a language a pure object-oriented language. If we don t like the \nidea of restricting the definition of classes and functions that way we can call such a language just \nan object-oriented programming language. I prefer to have more facilities available than can be provided \nby methods defined on classes within a single hierarchy. A lot of good design goes beyond that relatively \nnarrow domain. Incidentally, I have come to dislike the adjective hybrid as used to distinguish pure \nobject-oriented systems from others. Too often, hybrid is used in a prejudicial manner. If I must apply \na descriptive label, I use the phrase multi-paradigm language to describe C++. 4.1 Use of Language \nFeatures Even when all the features required to support object-oriented programming are available, you \ndon t need to use them all the time. Some classes just don t belong in a hierarchy and some functions \ndon t belong to any particular object. The key to maintainable, efficient, and evolvable programs isn \nt particular language features. It is the ability to develop concepts needed for a solution and to express \nthem clearly in a program. Language fea-tures exist to make such expression simple and direct. Object-oriented \nprogramming can be done in a language lacking one or more of the features required to directly support \nobject-oriented program-ming. However, doing so is unnecessarily difficult, very difficult to support \nwith tools, and often pro-hibitively expensive. Furthermore, there are things that can t be expressed \ndirectly using only the pure object- oriented constructs mentioned above. For example, some entities \nbelong together, but their relationships are not hierarchal. Some entities simply do not obey the rules \nof a particular object-oriented language. Some things that you build in an object-oriented world are \nmanipulated from the outside so that it is difficult to make guarantees about the way they are used. \n  5 C++ Design Ideals I felt the need for facilities outside what is conven- tionally called object-oriented, \nso I supplied some in C++. However, C++ isn t meant to be everything to everybody. No one programming \nlanguage and no one view of how to write programs is sufficient for everything. Constraints-based programming, \nlogic programming, functional programming, and various forms of concurrent programming are exam- ples \nof good and useful styles of programming not supported by C++. No single language can support every style. \nHowever, a variety of styles can be supported within the framework of a single language. Where this can \nbe done, signifcant benefits arise from sharing a common type system, a common toolset, etc. These technical \nadvantages translate into important practi-cal benefits such as enabling groups with moderately differing \nneeds to share a language rather than hav-ing to apply a number of specialized languages. C++ was designed \nto support a range of styles that I considered fundamentally good and useful. Whether they were object-oriented, \nand in which sense of the word, was either irrelevant or a minor concern: [l] Abstraction -the ability \nto represent concepts directly in a program and hide incidental details behind well-defined interfaces \n-is the key to every flexible and comprehensible sys-tem of any significant size. [2] Encapsulation -the \nability to provide guaran-tees that an abstraction is used only according to its specification -is crucial \nto defend abstractions against corruption. [3] Polymorphism -the ability to provide the same interface \nto objects with differing imple-mentations -is crucial to simplify code using abstractions. [4]Inheritance \n-the ability to compose new abstractions from existing one -is one of the most powerful ways of constructing \nuseful abstractions. [5] Genericity -the ability to parameterize types and functions by types and values \n-is essen- tial for expressing type-safe containers and a powerful tool for expressing general 4 Austin, \n algorithms. [6] Coexistence with other languages and systems -essential for functioning in real-world \nexe-cution environments. [7] Run-time compactness and speed -essential for classical systems programming. \n[8] Static type safety -an integral property of languages of the family to which C++ belongs and valuable \nboth for guaranteeing properties of a design and for providing run-time and space efficiency. These \nfacilities and general properties can be sup- ported in several alternative ways. For example, one programming \nlanguage may support a facility in its core language where another supports it in a library. Similarly, \na facility provided by a run-time mecha- nism in one language may be provided by a compile-time mechanism \nin another. The requirement for coexistence is essential for any language claiming to be general-purpose. \nLook-ing at the world from the perspective of a given pro-gramming language, we find that almost every \nreal-life system contain parts that are written in others languages and designed according to principles \nfor-eign to that language. To be general-purpose, a lan- guage must somehow take the unpredictable, ugly, \nand constantly changing demands of program frag-ments written in other languages into account. To be \ngenuinely general purpose, a language must possess facilities that allow it to share data with program \nfragments written in other languages, to invoke code fragments written in other languages, and have code \ninvoked by code written in other lan-guages. For example, systems relying on callbacks can be rather \nugly to program, but not being able to use such systems in a direct and idiomatic way would be crippling \nfor a language as a tool for real- world programming. In many languages, a common use of foreign code \nis exactly to violate the lan-guages rules: to do things that can t be done -or can t be done efficiently \n-in the language itself. Alternatively, access to facilities in the outside world could be carefully \nfitted into the framework of the object-oriented programming language through special facilities in the \nrun-time environ-ment or in libraries. However, accessing facilities in the manner they were meant to \nbe used is often TX October 15-19,199s easier and less awkward than to fit them into our lan- guage \nframework. A general mechanism for access-ing foreign code also leads to more extensible systems than \na requirement to fit each individual foreign facility into the language framework. Over the years, we \nhave seen spectacular improvements both in hardware performance and in compilation techniques. However, \nrun-time effi-ciency and compact representation is still absolutely essential to many people. Static \ntype safety is an essential part in my view of both design and implementation (see, for example [Stroustrup, \n19911). The guarantees provided and the discipline of design imposed have been found extremely valuable \nby many people working in a wide range of application areas. Static type check-ing is of course not a \npanacea, but it is something I would not attempt major projects without. The fundamental ideal of C++ \nis actually the fun- damental ideal for a lot of languages: Represent concepts and relationships between \nconcepts directly and affordably. Naturally, there are many ways of approaching this ideal. It is worth \nremembering that all of the lan- guages usually mentioned in a discussion of practi- cal use of object-oriented \ntechniques are suitable vehicles for good design. A rational discussion of languages is one of relative \nmerits, applicability to specific problem areas, and personal preferences, rather than one of absolutes. \nRepresenting concepts directly is a restatement and possibly a generalization of ideas relating to data \nabstraction and information hiding. Representing hierachical relationships is the traditional key to \nobject-oriented programming. There are, however, clean and useful relationships that are not hierarchi- \ncal yet can still be represented directly in a program (for example, see $6.3 and $6.7). Being more concerned \nwith producing good soft- ware than with finding the most elegant expression of ideas in the abstract, \nI insist on affordability. Affordability is a multi-facetted issue that involves not only run-time efficiency, \nbut also availability of suitable hardware, availability of designers and pro- grammers comfortable with \nnew techniques, etc.  6 Programming Style and Language Features I will now give examples of programming \nstyles and language features supporting them. Some are com-monly referred to as object-oriented, some \nare not, but that doesn t prevent me from recommending them in some contexts. 6.1 Conventional Notation \nThere are aspects of conventional code and conven-tional notation that I would like to see maintained \neven in a strictly object-oriented overall design. Being able to say plain square root of two, sqrt (2 \n) is nice, and so is the ability to write x+y* z and know that it means add x to the product of y and \nz. We have about 400 years of experience with such notation and it is deeply ingrained in our technical \nculture. 6.2 Concrete Types Very simple concepts, such as integers, floating point numbers, complex \nnumbers, points, lines, pairs, dates, disk locations, bed characters, error messages, currency, are usually \nnot considered suit- able topics for discussion in academic articles or at conferences. These are usually \nconsidered too sim- ple to merit discussion. However, the mundane is often statistically more significant \nthan the sophisti- cated. Provided they can be implemented in a way that is simple, elegant, efficient \nand flexible enough, I consider such simple concepts excellent candidates for independent proper types \n-as opposed to pre- senting them to users as plain data structures or as parts of a larger class hierarchy. \nConsequently, part of a design effort should focus on these little abstrac- tions. These very concrete \ntypes should be designed carefully and supported well. To illustrate why, I ll contrast this approach \nto the use of a plain data structure and to the use of class hierarchies. To make this discussion concrete, \nI ll use the example of a date. 6.2.1 Structures and Functions The simplest way of presenting a date \nin a program is simply to specify its data layout. For example: struct date ( / / representation 1; \n Given that, programmers can do anything at all with dates. That anything at all is the strength and \nweakness of this idea. Naturally, a standard set of functions is usually provided to manipulate a structure \nsuch as date. However, such a set of functions is rarely complete, and even when it is, programmers find \nreasons to manipulate dates directly. Consequently, it is usually not possible to change the definition \nof date after the initial release of the software; it is simply too difficult to track down every use \nof a date and modify it use to the new definition. The reason that the set of functions is rarely com-plete \nis that there is no incentive to make it so. A programmer can always write new functions access-ing the \ndate structure, and the dominant culture encourages the programmer to do so. Writing a new function that \nis just right for the job, carries no overhead, and relies on no potentially untrustworthy code is often \nconsidered better than improving a standard and general-purpose set of access functions and using it. \nOften, it is also far easier. This trend is typically reinforced by poor documentation. 6.2.2 A Concrete \nClass A simple Date type can remedy most of the prob- lems related to using a data structure directly. \nCon- sider: class Date { public: / / public interface, consisting / / of non-virtual functions private: \n / / representation and other / / implementation details 1; Such a Date type will provide [l] constructors \nspecifying how objects of the type are to be initialized; [2] functions for examining a Date; these functions \nwill be explicitly declared not to modify the value of the object; [3] functions for manipulating Dates \nwithout actually having to know the details of the rep- resentation or fiddle with the intricacies of \nthe implementation. In addition, Dates can be freely copied. This set of member functions supplied as \nmem-bers of Date should be those that provide a basic semantics for a Date and also requires direct access \nto the representation of Date to be implemented. The set of member functions should be almost minimal; \nmany operations that users would find con-venient can be supplied separately (see $6.3). I dis- like \nclasses with dozens or even hundreds of mem-ber functions. Such a class does not represent a well-thought-out \nconcept; it s a glorified data struc-ture produced by somebody who couldn t decide on what was really \nwanted. The member functions are declared non-virtual to ensure that there is no time or space overheads \ninvolved in using this Date, and to ensure that the semantics of Date cannot be modified later. Simi-larly, \nthe representation of Date is declared private to prevent access by any function not explicitly mentioned \nin the class itself. The representation of a concrete type should be compact. Sometimes millions of objects \nof such classes exist, and even with modem memory sizes space overheads can be a burden. If nothing else, \nreading and writing objects with bloated representa-tions can be a nuisance. The use of concrete types \nmust be fast. In my world at least, programmers are prone to represent something as plain data structure \nout of fear of over- heads supposedly associated with abstractions. There are no time or space overheads \nassociated with the Date class as defined above. The size is identical to that of the plain date structure, \nand inlining is done for simple member functions to make these as fast as the code a programmer would \nwrite accessing a plain structure directly. Often, it is important that simple concrete types, such as \nDate, be layout-compatible with simple data structures, such as date, as used in traditional languages. \nThis allows simple exchange or sharing of information with code written in traditional Austin, TX October \n15-19, 1995 languages. This can be a major convenience if your operating system, your database, or your \nhigh-performance numeric library is written in a tradi-tional language and requires manipulation of data \nof a specific layout. The Date class is very simple and very basic. It requires no elaborate framework, \nno class hierar-chies, no clever dispatcher to mediate access, etc. It doesn t affect the overall structure \nof a program much; it just provides a lot of help at the detailed programming level -below the level \nof detail of interest to most managers and to many designers. If such types are that simple, why bother \nspend-ing time on them? [l] The concepts best represented by such simple types are common; most applications \ncan use a few dozen or a few hundred such types. Thus, any benefits we get from a single con-crete type, \nwe get many times over. [2] The problems relating to lack of encapsulation of plain structures ($6.2.1) \nare eliminated. [3] The replication of effort writing simple access functions is eliminated. [4] Making \na concrete type the subject of a con-scious design effort typically results in a bet-ter thought out, \nmore comprehensive, and bet-ter documented concept. In principle, this could equally well be done for \nthe plain struc-ture approach, but in practice that typically doesn t happen. [5] Writing the basic functions \nof a concrete type is not difficult, but it is not trivial either. For example, adding a year to a date \nrequires us to handle leap years. By relying on common access functions, we eventually achieve an implementation \nthat has been better thought out and has fewer errors. [6] Since more of the implementation is docu-mented \nand shared, user code becomes more uniform. Thus, code written by others become easier to comprehend. \n These are classical reuse benefits and I don t think we should decline them just because they are easy \nto obtain. 6.2.3 Re-using Concrete Types For many concrete types, derivation doesn t make sense. Consider, \nderiving a new class from Date: class MyDate : public Date { I/ .. 1; Is it ever valid for MyDate to \nbe used as a plain Date? Well, that depends on what MyDate is, but in my experience it is rare to find \na concrete type that makes a good base class without modification. Derivation from a concrete type is \nalmost always a mistake. A concrete type is a self-contained entity that can t easily added to in a way \nthat makes sense. A concrete type is re-used unmodified in the same way as built-in types such as int \nare. For example: class Date-and-time { public: // . . private: Date d; Time t; I; This form of \nuse (reuse?) is usually simple, effec-tive, and efficient. Maybe it was a mistake not to design Date \ntobe easy to modify through derivation? It is sometimes asserted that every class should be open to modifica-tion \nby overriding and by access from derived class member functions. This view leads to a variant of Date \nalong these lines: class Date2 { public: / / public inter$ace, consisting / / primarily of virtual functions \nprotected: / / representation and other / / implementation details I; Here, the functions are declared \nvirtual, meaning that a class derived from Date2 (inthe style of MyDate above) can provideits own versions. \nTo make it possible to write such overriding functions easily and efficiently, the representation is \ndeclared protected. A protected memberofaclassis accessible not just to the classes own members, but \nalso to the member functions of derived classes. This achieves the objective of making Date2 arbitrarily \nmallable by derivation, yet keeping its user interface unchanged. However, there are costs: [l] Efficiency \nof basic operations -a C++ virtual function call is a fraction slower than an ordi-nary function call, \nvirtual functions cannot be inlined as often as non-virtual functions, and a class with virtual functions \ntypically incurs a one word space overhead. [2] Need to use free store -the aim of Date2 is to allow \nobjects of different classes derived from Date2 to be used interchangeably. Because the sizes of these \nderived classes dif-fer, the obvious thing to do is to allocate them on the free store and access them \nthrough pointers or references. Thus, the use of gen-uine local variables dramatically decreases. [3]Inconvenience \nto users -to benefit from the polymorphism provided by the virtual func-tions, accesses to Date2s must \nbe through pointers or references. Naturally, these costs are not always significant, and as we will \nsee in $6.4 the behavior of a class defined in this way is often exactly what we want. However, for a \nsimple concrete type, such as Date2, the costs are unnecessary and can be significant. Please note that \nthe costs are fundamental; differ-ent languages present the facilities differently, but every language \nthat provides run-time polymor-phism incur these costs in some way or other. Finally, a well-designed \nconcrete type is often the ideal representation for a more mallable type. For example: class Date3 { \npublic: / / public interface, consisting / / primarily of virtual functions protected: Date d; 1;  \n 6.3 Namespaces Class hierarchies express (hierarchical) relationships, but not every relationship in \na program can or should be expressed as a hierarchical relationship between classes. For example, if \na class is intented for use 8 Austin, only in the context of another class it can be declared a member \nof that class exactly the way a function can be: class Date { public: enum Month {  jan, feb, mar, \napr, may, jun, jul, aug, sep, act, nov, dec I; // . . 1; Date: :Month m = Date: :nov;  More generally, \nC++ provides namespaces for grouping declarations [Stroustrnp, 19941. For exam-ple, many operations on \nDates shouldn t be mem-bers of class Date because they don t need direct access to the representation \nof a Date. Providing such functions as non-member functions leads to a cleaner Date class, but we would \nstill like to make the association between the functions and the class explicit: namespace Chrono { \n/ / facilities for dealing with time: enum Month { // . . I; class Date { // .. 1; int diff(Date a, \nDate b); boo1 leapyear(int y); Date next-weekday(Date d); Date next-saturday(Date d); // . . 1  A namespace \nis not a module; it is not an object. A namespace is a general scope mechanism to support a variety of \ntechniques related to modularity. Not incidentally, namespaces provides a way of avoiding TX October \n1519,199s name clashes in software composed out of libraries from different suppliers. For example: \nnamespace LibA { class String C / / A-style string I; // ... namespace LibB I class String 1 / / B-style \nstring I; // ... LibA::String sl = \"Nicholas\"; LibB: :String s2 = \"Annemarie\";   6.4 Abstract Classes \nIt is possibleto completely disassociate implementa-tion and interface. For example, we might imple-ment \na set using either an array or a list in such a way that the two kinds of sets can be used inter-changeably: \nclass set { // ... I;  class v-set : public set, private vector { // .. 1; class l-set : public set, \nprivate list I // .. 1; or graphically: vector set list Y i* \\ &#38;..d i -set - I use the dotted lines \nto show that private inheri-tance is an implementation issue that does not affect the interface of the \nderived class. Importantly, a common interface (here, set) can be provided long after the design and \nimplementation of implementation classes (here, vet tor and 1 ist).I find that when people design things, \nthey typically first invent something fairly concrete. They design an array, they invent a list, and \nonly later do they discover an abstraction that covers both in a given context. Using abstract classes \nas shown above, we use (re-use?) vector and 1 is t without the foresight (and cost) necessary to design \nthem as part of a common hierarchy. As a matter of fact, you can do this late abstrac-tion several times. \nSay, I want to represent the notion of something you could read from. This is a very different abstraction \nfrom set, yet I can pro-vide such an interface to arbitrary sets as well as for lists, vectors, files, \nand input streams much in the way I provided set as an interface to vet t or and list. Late abstraction \nusing abstract classes allows us to provide different implementations of a concept even when there is \nno significant similarity between the implementations.  6.5 Classical Hierarchies Sometimes we do have \nsufficient foresight to design a classical hierarchy. More importantly, sometimes the various implementations \nof a concept have a high degree of commonality so that there is signifi-cantbenefit in organizing these \nimplementations into a hierarchy. For example, consider a class hierarchy that one might find in an application \nrelying on a windows system: window ival dial ival slider Presumably, the implementations of the application \nclasses ival-dial and ival-slider are greatly facilitated by code and data provided by the system classes \nwindow, dial, and slider. That is, you build your code incremently and your interfaces incrementally. \n 6.6 Hierarchies and Abstract Classes A classical hierarchy is a nice way of providing a variety of \nrelated concepts and a nice way of mini- mizing the effort of building their implementations. However, \nyou do get the classes in the hierarchy tightly coupled. If anything significant in a base class changes, \nall of the derived classes must change (or at least be recompiled) to match. In particular, any significant \nchange to system classes at the base of a hierarchy, such as window, will affect application classes, \nsuch as ival-dial. Worse, the choice of a foundation library representing sys-tem resources determines \nthe structure of the appli-cation class hierarchy and permeates the application code. There are quite \na few ways of dealing with this. For example, some languages have a solution (at its associated costs) \nmandated, and some implementa-tions of C++ allow major changes to base classes without requiring re-compilation \nof derived classes. However, here I ll show a solution using abstract classes to make dependencies explicit. \nLogically, it closely parallels the way the abstract class set was used to insulate users from the details \nof vectors and lists. Here, an application hierarchy ival box ival d2-b slider is written independently \nof implementation details and then later tied into an implementation hierarchy without affecting the \nusers of the application hierar- chy: BB window fi/ \\ BB-&#38;al -dial BB-iva;-slider This expresses \nthe design in such a way that the application code becomes independent of any change in the implementation \nhierarchy. I have used the BB prefix for realism; suppliers of major libraries invariably prepend some \nidentifying 10 Austin, initials. In the future, I expect namespaces ($6.3) to be used instead. The declaration \nof a class that ties an application class to the implementation hierarchy will look something like this: \nclass BB-ival-slider : public ival-slider, protected BB-slider { public: / / functions overriding ival-slider \n/ / functions as needed to implement / / the application concepts protected: / / functions overriding \nBB-sl ider / / and BB-window functions as / / required to conform to user / / inteface standards private: \n / / representation and other / / implementation details 1; This structure assumes that details of what \nis to be displayed by a windows system is expressed by overriding virtual functions in the BB-windows \nhierarchy. This may not be the ideal organization of a user interface system, but it is not uncommon. \nI use protected members and protected inheri-tance to allow classes derived from BB-ival-slider to use \ninformation about its implementation. 6.7 Generic Programming A major theme in the C++ community over \nthe last few years has been the development of techniques exploiting the template mechanism. 6.7.1 Parameterization \nIndependent concepts should be independently rep-resented and should be combined only when needed. Where \nthis principle is violated, you either bun-dle unrelated concepts together or create unnecessary dependencies \nin the implementation of classes and functions. In particular, fitting weakly related class into a single \nhierarchy can be a source of unneces-sary and problem-causing dependencies. Consider the concepts of \nsorting, character, string, and collating sequence. A sort algorithm is independent from the concept \nof a character. The TX October 1519,199s concept of a string is independent of any particular kind of \na character. Finally, the collating sequence which you use when you sort strings of characters is independent \nof these other three concepts. This independence can be expressed directly. Here is a string parameterized \nby the kind of charac- ters contained so that we can make strings of both built-in and user-defined character \ntypes: templateiclass C> class string { // ... I; class Jchar I / / Japanese characters I; string<char> \nsl, s2; stringcunsigned char> usl, us2; string<Jchar> jsl, js2;  Independently, we can define the \nnotion of a collat- ing sequence and a string comparison function: template<class C> class std-co11 \n{ public: boo1 eq(C a, C b) { return a==b; ] boo1 lt(C a, C b) { return a<b; } I; template< class \nc, class Co11 = std-coll<C> > int cmp( string-X>&#38; sl, string<C>&#38; s2 1 { / / compare s \n1 with s 2 // using Co11 ::eqandColl::lt / / to do character comparisons 1 The cmp template function \ntakes two template argu-ments: - the type of characters in the strings, and - the collator supplying \nthe character compari- son operations. The ability to pass operations as template parameters is a very \npowerful expressive mechanism. It is also important for efficiency. For example, it is trivial for a \ncompiler to inline all uses of eq ( ) and 1 t ( 1 . This can be a significant advantage compared to C \nwhere operations can only be passed as pointers to functions so that function call overheads are incurred. \nThe second template paramenter has a default so we need only specify it if we want a non-standard collating \nsequence. The first template parameter can usually be deduced For example: from the arguments to cmp \n( 1. cmp(sl,s2); cmp(jsl,js2); cmp(usl,us2) cmp<char,no_case>(s l,s2); Here, no-case is a collator It \n( ) not to be case sensitive. defining eq ( ) and Typically, the string class, the cmp ( ) func-tion, \nthe collator classes, and the character classes will be written by different people. Only the final user \nputs all of the independently developed pieces together. This style of design relying on templates and \nadditional template arguments (in this example, Coil) to express policies, is the basis of much of the \nC++ standard library. The result is exceptional flexibility and unsurpBssed run-time efficiency.  6.7.2 \nContainers and Algorithms I want to have algorithms written once and used for objects of many different \ntypes. I want these algo-rithms to run as fast as functions written for a single argument type. I want \nthis to be compile-time checked so that I can be more confident of my code. I don t want to be forced \nto fit my types into a hier- archy simply to be able to use them for the generic algorithms. The containers \nand algorithms in the C++ stan-dard library use a variant of the philosophy of keep- ing independent \nconcepts separate. Much of the library is based on the notion of a of sequence. Examples of sequences \nare arrays, sets, lists, maps, files. A sequence has a beginning and an end. The end is one beyond \nthe last element of the sequence. Positions in a sequence are represented by iterators. begin end V \nV xxx --> ... . -> xxx -> 0  Given an iterator for an element of a sequence, we can get to the next \nelement using the ++ (increment) operator. Given an iterator for an element, we can access the element \nitself using the * (dereference) operator. Given this simple notion, a surprising number of useful algorithms \ncan be expressed. For example, this template function writes all elements of a con- tainer to output: \ntemplate<class C> void print(C&#38; s) { c: : iterator p=s.begin(); while ( p!=s.end() ) { tout \n<< \"p; // output p++; // next The C++ standard library containers and algorithms are primarily the work \nof Alex Stepanov. A surpris- ing number of containers and algorithms can be expressed using just a few \nkinds of iterators. Impor-tantly, the resulting generic algorithms are efficient even compared to hand-crafted \nassembly code. For example, the C++ standard library algorithm, sort ( ) is for many simple and realistic \nexamples several times faster than the C standard library qsort ( ) function. For more information about \nthe C++ standard library and the principles underlying its design see [Koenig,19951 [Stepanov,l994]. \nClosing Remarks Are the various facilities presented above object-oriented or not? Which ones? Using \nwhat definition of object-oriented? In most contexts, I think these are the wrong questions. What matters \nis what ideas you can express clearly, how easily you can combine soft- ware from different sources, \nand how efficient and maintainable the resulting programs are. In other words, how you support good programming \ntech- niques and good design techniques matters more than labels and buzz words. The fundamental idea \nis simply to improve design and programming through abstraction. You want to hide details, you want \nto exploit any com- monality in a system, and you want to make this affordable. I would like to encourage \nyou not to make object-oriented a meaningless term. The notion of object-oriented is too frequently \ndebased - by equating it with good, - by equating it with a single language, or  -by accepting everything \nas object-oriented. I have argued that there are -and must be -useful techniques beyond object-oriented \nprogramming and design. However, to avoid being totally misunder-stood, I would like to emphasize that \nI wouldn t attempt a serious project using a programming lan-guage that didn t at least support the classical \nnotion of object-oriented programming. In addition to facilities that support object-oriented programming, \nwant -and C++ provides -features that go beyond those in their support for direct expression of con-cepts \nand relationships. Several of the themes related to C++ program-ming style in this paper have been developed \nfurther in [Koenig,l995b]. The design and evolution of C++, including its most recent features, is discussed \nin [Stroustrup, 19941. 8 Acknowledgements Thanks to the OOPSLA 95 program committee for inviting me to \ngive the talk upon which this paper is based, and especially to May Loomis for encourag-ing me to get \nthis paper written, Carolyn Heaps transcribed the audio tape of my talk to produce the first draft of \nthis paper. Tim Griffin and Christos Polyzois made many constructive comments. Austin, TX October E-19,1995 \n 9 References [Koenig,19951 Andrew Koenig (editor): Draft Proposed International Standard for Informa-tion \nSystems -Programming Language C++. ANSI Standards Secretariat. CBEMA, 1250 Eye Street NW, Suite 200, \nWashington DC20005 USA. 1995. [Koenig, 1995b] Andrew Koenig and Bjame Stroustrup: A Foundation for Native \nC++ Styles. Software -Practice &#38; Experience. To appear 1995. [Stepanov,l994] Alexander Stepanov and \nMeng Lee: The Standard Template Library. IS0 Programming language C++ project. Dot No: X3J16/94-0095, \nWG21/N0482. May 1994. [Stroustmp, 199 l] Bjame Stroustrup: The C++ Programming Language. Addison-Wesley. \n1991. [Stroustmp,l994] Bjame Stroustrup: The Design and Evolution of C-+ +. Addison-Wesley. 1994.  \n  \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Bjarne Stroustrup", "author_profile_id": "81100106139", "affiliation": "AT&T Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP37023764", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260207", "year": "1995", "article_id": "260207", "conference": "OOPSLA", "title": "Why C++ is not just an object-oriented programming language", "url": "http://dl.acm.org/citation.cfm?id=260207"}