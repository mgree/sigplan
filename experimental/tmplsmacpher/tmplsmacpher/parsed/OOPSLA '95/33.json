{"article_publication_date": "10-01-1995", "fulltext": "\n Design and Construction of Large-scale Components: Main Insights of OOPSLA 95 Workshop 10 Co-Chair: \nGeorge Brown Intel Corporation george_w_brown@ccm.ch.intel.com Co-Chair: Brad Kain Quoin, Inc. The main \ninsights from this workshop centered on the expectations for realizing large-scale systems built of software \ncomponents. A secondary consideration was that the implementations were compliant with the OMG Architecture. \nIt was generally accepted that a pre-requisite for large-scale components is a common infrastructure \nfor sharing components in a distributed environment. Within this context, a distinction should be made \nbetween small and large components. The component model definition was assumed to be distinct from an \nobject model. There was recognition of the need for heterogeneous component interaction and integration. \nCurrent IDL was considered insufficient to express both the semantics of components and the configuration \nsyntax associated with components within components as part of a good model. Components should be a consequence \nof usage, not just top down analysis/design. Since system development through component assembly was \nconsidered important, robustness, reliability and testing should be taken more seriously (for components). \nComponents should provide: coupling, cohesion, sufficiency, completeness, ownership. Componentized frameworks \nwith both service and customization APIs will most likely help in the deployment and acceptance of component \nsoftware. On the other hand, it was agreed that no one is likely to be able to support a truly heterogeneous \nenvironment. Business differentiaters will always exist for frameworks and software components, and will \nlimit generality. There was general agreement that new cost models are needed. If efforts to promote \nsoftware component technology are successful, we will be faced with how to do pricing. It was emphasized \nthat bits and atoms are different and our models for selling products may not apply. For example, one \npossibility is that software components are given away free, and payback of components occurs through \nintegration services. There needs to be better understanding of break-even cost factors of component \nreuse. Clearly, if you only share a component with one other, then building the component may not be \ncost justified due to maintenance cost, etc. Because of the uncertainty in cost factors, it was asserted \nthat development organizations should at least consider the cost and risk of not enabling software components \n. Space limitations made it impossible to include summaries of all of the fine papers from this workshop, \nbut the following few reflect the high quality of the contributions that stimulated discussion. Our workshop \nparticipants are committed to similar goals as the BOMSIG and expect to continue collaboration in order \nto influence the definition of common abstractions for business concepts and to gamer support for business \nobjects in a distributed environment through infrastructure that tills the gap between Corba / COSS and \napplications. Austin, TX October 1519,199s Excerpts from: Andersen s Component-Based Software Engineering \nApproach Dr. Colin T. Scott Andersen Consulting Our view of a component is that it represents a domain \nabstraction (i.e. carries out a function in the domain). Consequently the interaction between components \ntakes place at a business or domain level. Thus the interfaces of components and the components themselves \nmust represent or support business abstractions. A domain component is closest to the standard cluster \nor module concept. It is a logically associated set of classes and their instances along with the operations \nnecessary to manage their lifecycle. A process component represents a business process or high-level \ndomain function. It tends to act as a coordinator between domain components. Process components are made \nup of partially ordered sets of activities. We prefer to view these processes as being described by an \nevent-driven model rather than the more typical workflow model. Finally a rule component supports the \ndefinition and execution of business rules. These rules are also event- driven. These basic component \ntypes can be combined. Often a set of rules only apply to a specific sub-domain. Logically related components \ncan be grouped together into a single larger component which offers the interfaces of the constituent \nsub-components. Factorization: We wish to make our component factorization more flexible. Often the division \nof a system into components produces rigidity and fragility at the component boundaries. A poorly-designed \ncomponent interface has a profound effect on the other components in the system and it cannot be easily \nchanged. By viewing components as molecular rather than atomic, we can regroup the constituent atoms \nwith less effect on other parts of the system. Component specification: It is clear that the existing \nstandard component specification language (IDL) is inadequate at both the syntactic and semantic levels. \nIgnoring the syntactic problems, IDL offers no support for semantic information. At the heart of any \ndomain-specific software architecture there must be a standardized structure and vocabulary that is effective \nin that domain. We have developed a component specification language that supports semantic-based extensions \nto IDL Variability: We view components as evolving over time and requiring tailoring as they are incorporated \ninto different systems. We have extended the notions of meta-object protocols to meta-protocols for components. \nEach component provides a meta-interface which allows disciplined access to implementation details. For \nexample, in a process component, it is possible to redefine the order of the activities that make up \nthe process without rebuilding the component or having knowledge of the internal architecture of the \ncomponent.  Component implementation: We have found that developers frequently assume a correspondence \nbetween a component and a node on the network. We have deliberately chosen to break that coupling. We \nprefer to visualize a component as potentially having its own internal distribution architecture. All \nthat is required of such a component is that it has at least one node which connects to the inter-component \ntechnical architecture. This node implements or delegats to its associates the tinctionality supported \nby the component. Component integration: Within the component concept there may be a mismatch between \nthe services required and those provided by others. A component must define the interfaces it supports \n(provided interfaces) and the behaviors it requires.  Excerpts from: Obstacles to Component Development \nto be Explored Lorrie Boyd Frank Armour Monica Sood American Management Systems  At AMS, our experience \nin developing several large scale object oriented business systems tells us that the major obstacle to \ndeveloping and reusing components is human behavior. Both programmers and their managers are often believe \nthat development through reuse is more immediate work for them, and thus resist doing it. There are many \ncauses of this behavior. They include lack of information, fear of asking for help, and desire to work \nindependently. We are interested in pursuing a behavioral model to affect organizational change. What \nare the cultural barriers to developing components? What are the steps to be taken to achieve behavior \nmodification and cause teams of developers to change and design and reuse with components? How do you \nmeasure this organizational change? Areas we are interested in to achieve this behavior modification \ninclude: . Component assessment. That is, how do you determine the legal, competitive, technical and \nbusiness risks and advantages of component use? Managing organizational change. How do we affect change \nin an organization to encourage component development and use? . Component libraries. How do we inventory, \ncatalog, retrieve, evaluate and support corporate component libraries? . Component value. How do we \ndetermine incentives and recognition? Component facilitation. What is the role of the component support \nconsultant? . Component awareness. How do we market and publicize component development, existence and \nreuse? Component Assessment Based on experience, AMS has initiated a component program to assess the \nfeasibility of reusing developed components. Managing Organizational Change AMS has developed a behavioral \nmodel for organizational change in component development and reuse, considering changing team dynamics, \nmanagement incentives and individual motivators. Component Libraries Component libraries require identifying \nand cataloging assets, presenting flexible retrieval choices, and providing a means of evaluation of \ncomponent value. Component Value AMS is developing award calculations based on the development of components \nwhich might be reused, considering how teams change when value is derived through component use rather \nthan through individually developed programs. Component Facilitation The effective development and use \nof components is dependent on people more than technology. Support must be provided Austin, TX Octohrr \nE-19, 1995 in analysis and technical implementation of the component, in overall affects of the component \nacross the project, and in training and mentoring. Component Awareness Marketing matters in deployment \nof component development just as it matters in any new approach. It is important to publicize the use \nof components.  Excerpts from: Object-Oriented Components for Large Scale Solutions Jack Grimes and \nMike Potel Taligent, Inc. Software development is becoming too expensive for the creation of high function \napplications and systems. Further, these solutions must adapt to changing environmental conditions so \nthat they continue to meet their requirements. Large software systems have several problems which components \ncan solve. One is the uncoupling of application and system development in both time (functional evolution) \nand space (geography). What is necessary is agreement and standardization of the interfaces. Another \nimportant problem is scale-the construction of applications and systems for complex problems. By breaking \nlarger problems down into many smaller ones, components help with the scale problem. Applications and \nsystems that support external components define an interface that is open (publicly available), so that \ndevelopers can implement functionality independently from interface design. The keys are the independence \nof development efforts, the potential separation in time of the development, and the factoring of problems \ninto subproblems. Objects are not necessary in order to build components, but objects fit nicely since \nthey provide fine granularity for the hiding data structures. This is why there is the close association \nbetween objects and components. Using objects simply makes component interfaces easier to understand \nand components easier to create. bbject-orientation means more than encapsulation. For complex system \nconstruction from components, the level of abstraction provided by encapsulation is not enough. There \nis still a problem with the granularity of the components used. To simplify the development, certainly \nat the level of component assembly, one wants to use fewer, larger components. This fits well with the \nuse of visual builders. However, to increase the generality of the solutions created, one wants more, \nsmaller components. Larger components are less likely to deliver the needed functionality without customization. \n00 frameworks address both issues by allowing developers to modify existing components at various levels \nof granularity, by providing two interfaces-an external, calling interface (like object libraries provide), \nand levels of internal, be called interfaces. Why should the granularity of functionality seen from the \noutside be the same as that available to the developer? The developer needs more flexibility than that \nprovided by a black box. A paradigm shift is occurring. Analogous to the paradigm shift in databa se \ntechnology 20 years ago when relational databases were first introduced, the use of 00 technology for \ncomponent construction is in its early days. Infrastructure changes are necessary, long term. When component \nsoftware is the norm, several changes will be needed. Software licensing will become more of an issue. \nLots of components means that automated ways of tracking usage and royalties become more important. At \nsome point the cost of licensing a component must be less than the cost of a postal stamp. We believe \nthat object-oriented, framework-based components are the preferred construction technology for developing \nsoftware solutions. Component software will fundamentally change the underlying programming systems used \ntoday. Object-oriented frameworks will facilitate the development of much more advanced and interoperable, \nbut smaller, programs. These programs will be customized repeatedly over time to met changing needs. \n Excerpts from: Obstacles to Component Based Construction Gordon Sheppard American Management Systems \n This position paper discusses some of the obstacles to component based development experienced at AMS \nthat must be overcome in order to achieve widespread usage. Tool support for Component and Application \nDeliverv The first generation of tools that support construction from components should improve component \ndelivery and environment integration, which is crucial to the development of larger applications. Presently, \nthe visual programming tools require too much low-level design and development for large scale integration \nor application integration. Without easy ways to segment applications into components that can be delivered \nand upgraded separately, delivering components becomes too complex. Application developers and users \nneed to minimize the upgrade efforts of large applications through incremental upgrades with tools that \nprovide an easy mechanism to package and deliver set of components and incorporate incremental upgrades \nwithout impact. Need for Grav Box Components 200 Austin, Components are traditionally thought of as black \nbox entities wherein a developer uses a component via communication through its Application Programming \nInterface (API) designed and developed to provide certain functions to the outside world. Because designers \ncannot accurately predict all the reasonable uses for their components, the APIs for those components \nmay not be very reuseml in a new application. White box frameworks introduce other risks. Because the \nwhite box exposes the implementation of the component, applications can use all the features of the component \nbut become more brittle. Gray box components allow part of the component s configuration and behavior \nto be specified. Further defining gray, box components and the rules for their specification would be \nan excellent area for further research. Model for Pricing Creating an appropriate model of payment for \ncomponents used in applications could be a significant obstacle to component based construction. A well \ntested component may be critical but is typically undervalued by the user. Per use pricing reflects a \ncomponent s value within an application, but is difficult to implement in the context of a component. \nComponents are typically priced and licensed based on the number of developers (development pricing) \nor the number of end users (runtime pricing). The number of components that can be used to construct \nan application is effectively limited by the administrative burden the organization can carry. Lack of \nManufacturing; Mentality Component based reuse requires a manufacturing mentality on the part of TX October \nM-19,1995 component consumers. Before inclusion in an application, components must be tested to determine \nthat they perform as expected (within tolerances). Many of the organizations attempting to build component \nbased applications are not prepared for the level of component and integration testing they must undertake \nalong with component based construction. Just recognizing the need for education in this area can be \nan obstacle itself.  Excerpts from: Integration Obstacles to Component-Based Architectures Dale Skeen \nVitria Technology, Inc Component architectures promise a world where enterprises are free to mix and \nmatch components from a wide variety of vendors, with each component decision being made strictly on \nhow well component fuls an enterprise need. Small component providers and large component providers will \nbe able to play on a level technical, fostering competitiveness and with it innovation. Today, the state \nof the art is a far cry from the ideal. The lack of interoperability among providers severely limits \ncustomer choices, often to so-called integrated suites of components. As is often the case, different \nparts of the enterprise standardize on different incompatible components utilizing incompatible information \nmodels and technology, creating roadblocks to sharing information across the enterprise. Certainly, most \napplications today would benefit from a modernization of existing systems and a rationalization of models \nused. But this would only temporarily solve the integration problems. As business evolves, business models \nwill necessarily diverge; as technological underpinnings evolve, components will necessarily diverge. \nIt is neither possible nor desirable to attempt to evolve the multitudinous components of a large system \nin a lock-step fashion. Subdivisions of an organization need to be empowered with the capability to define \nlocalizations, to evolve at different rates, and to innovate in business and technology. Hence, diversity \nin component technology, in modeling technology, and in the core, abstract business models themselves \nbecomes a necessity, not just an artifact of poor planning and implementation. A more complete classification \nof integration-related problems is as follows:  Component Integration Problems 1. Legacy A. Legacy systems \nproprietary models, formats, and communications; little support for general-purpose access to their data \nor their models II. Differences in Communication Semantics A. A diversity of communication protocols, \ne.g., CORBA, DCE, COMIOLE, mail lII.Differences in Data Representation. A. A diversity of data representations \nand formats; differing type systems and data representations IV.Differences in Model types A. A diversity \nof model types. V. Differences in Meta-data Representation. A. A diversity of representations even for \nsimilar models expressed in the same model type. VLDifferences in Concrete Models. A. Software components \nfrom multiple vendors leads to semantic differences in concrete models of the same underlying abstractions. \nVKDifferences in Abstract Models. A. Different underlying abstractions The underlying business abstractions \nmust evolve. VIII.Meta-data Management. A. No common tools and systematic methods to manage to models \nand meta-information. IX.Meta-data Change Propagation. A. No way to propagate notifications of meta-information \nchanges to affected components X. Referential semantics. A. Lack of a common way to reference data and \nservices through the enterprise Technical Challenges Component-to-component integration, because of \nits pivotal role in future architectures, demands special focus. Component integration issues stand in \n contrast to most integration efforts today, which are heavily skewed toward problems of decision-support \nand information browsing by human users. The proper reference architecture would be a common framework \nwith rigorously defined integration elements and components. It would also define how these elements \nand components could be combined to accomplish integration objectives. Participants OOPSLA 95 Workshop \n10 Design and Construction of Large-Scale Components Ken Auer Knowledge Systems Corporation 4001 Weston \nPkwy Cary, NC 27.513 kauer@ksccary.com Lorrie Boyd, Monica Sood, Frank Armour American Management Systems \nlorrie~boyd@mail.amsinc.com monica-sood@mail.amsinc.com frank-armour@:mail.amsinc.com Roosevelt Bynum. \nJr. IBM rbynum(@carvm3.vnet.ibm.com Chen Chen Xerox Corporation 70 1 S. Aviation Blvd, ESAE-23 1 El Segundo, \nCA 90245 cchen@cpl O.es.xerox.com Brad Cox George Mason University Fairfax VA 22020 bcox@,gmu.edu http:llweb.gmu.eduibcox \nFred A. Cummings EDS Mail Stop: 402 5555 New King Street Troy, MI 48098 Dr. Mike Gilbert Micro Focus \nLtd. mhg@mfltd.co.uk Jeff Gray jgray@vuse.vanderbiIt.edu Jack Grimes Mike Potel Taligent, Inc. jack_grimes@taligent.com \nmikegotel@taligent. Gerard Meszaros BNR, Canada PO Box 35 I 1, Station C, Ottawa, Ontario Canada KIY \n4H7 gerard@bnr.ca Jari Koistinen Ericssson Inc. 5757 Plaza Drive, Cypress, CA, 90630 euajak@ebu.ericsson.se \nAnders Kristensen Hewlett-Packard Laboratories Filton Road Stoke Gifford BS I2 642, England ak@hplb.hpl.hp.com \nDr. Cohn T. Scott Andersen Consulting 69 West Washington Street Chicago, Illinois 60602 Tel: 3 12-507-8024 \ncolin.t.scott@ac.com Gordon Sheapard Senior Principal American Management Systems 4050 Legato Road Fairfax, \nVA 22033 gordon-sheppard@mail.amsinc.com Dr. Dale Skeen Vitria Technology, Inc. 575 High Street, Suite \n200 Palo Alto, CA 94301 skeen@vitria.com Austin, TX October 15-19, 1995  \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "George Brown", "author_profile_id": "81100012854", "affiliation": "Intel Corporation", "person_id": "P95287", "email_address": "", "orcid_id": ""}, {"name": "Brad Kain", "author_profile_id": "81332507529", "affiliation": "Quoin, Inc.", "person_id": "P31900", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260281", "year": "1995", "article_id": "260281", "conference": "OOPSLA", "title": "Design and construction of large-scale components: main insights of OOPSLA'95 workshop 10", "url": "http://dl.acm.org/citation.cfm?id=260281"}