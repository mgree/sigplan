{"article_publication_date": "10-01-1995", "fulltext": "\n Workshop on Adaptable and Adaptive Software Organizers: Karl Lieberherr, Northeastern University, Boston, \nMA, USA John Lamping, Xerox PARC, Palo Alto, CA, USA Cristina Lopes, Xerox PARC, Palo Alto, CA, USA Jiirgen \nBijrstler, Ume&#38; University, Ume&#38; Sweden Vladimir Bacvanski, ICON Computing Inc., Austin, TX, \nUSA Cun Xiao, IBM, Mountain View, CA, USA  Report by: Karl Lieberherr The submitted position papers \nare available from URL http://www.ccs.neu.edu/research/demeter/adaptable-systems/ 1 Overview tions and \nmay be criticized by: Any program is adapt- This workshop started with an electronic prepara-able or \nadaptive. However, it was clear from the dis-tion by email and WWW where a number of limi-cussions that \nmaking programs easier to change is an tations to adaptability and a few solutions were dis-important \ngoal although it is hard to measure the ease cussed. of changeability. The workshop had about 35 attendees, \nand the dis-cussions were stimulating and showed a broad range Abstract problem of experience of the \nparticipants. In the morning we worked in one group with a few presentations and plenty of discussions \nwhich crystallized in a few key issues of adaptability. To increase individual partic-ipation, the group \ndecided to split for lunch and the afternoon (until 3.30 pm) into four subgroups which addressed the \nkey issues. The subgroups gathered again and reported on their findings to the full work- &#38;ncrete \nproblem shop. The results of the workshop were presented at the OOPSLA poster session. Figure 1: Polya \ns Inventor s paradox  2 Topics of discussion We give a brief definition of the terms used in the One \ntheme which came up several times and which title of the workshop. A program is called adaptable if is \nbelieved to help with software adaptability, is it can be easily changed. A program is called adaptive \nPolya s Inventor s Paradox (PIP). For example, the if it changes its behavior automatically according \nto Patterns and Culture subgroup in the afternoon, its context. Those are flexible definitions everybody \nused essentially one view graph describing PIP to sum- could agree with; however they allow many interpreta- \nmarize their findings. PIP was formulated in the for-ties by the mathematician George Polya in his book: \nHow to solve it [Po149]. Polya s book is a very fine problem solving book for students of mathematics \nwhich turns out also to be useful in many other disci-plines, specifically software development. The \nadvice of PIP is that to solve a concrete problem (CP) it is often better to generalize the problem to \na more ab-stract problem (AP), to solve the abstract problem and then to map the solution from AP to \nCP by cus-tomization (see figure 1; this figure was used several times throughout the workshop). Why \nis PIP called inventor s paradox? We have to invent a suitable generalization of the concrete prob-lem. \nThis often amounts to identifying the concrete problem and finding out what is really the hard part or \nthe important part of the problem formulation. It turns out, and this is particularly true for software \ndevelopment tasks, that the problem formulation is cluttered with lots of unimportant details; the role \nof the inventor is to filter out what is important. John Lamping pointed out that in the case of soft- \nware, sometimes the invention part is not that dish-cult. The programmer often already has an under-standing \nof their program at the abstract level, and would like to be able to express it at that level. But existing \nmethodologies force them to express programs at a more concrete, less adaptable, level. Why is PIP called \ninventor s parudoz? The paradox is that although we solve a more general problem and find a solution \nwhich is useful in a larger set of con-texts, the solution becomes easier. We can use the so-lution not \nonly for our concrete problem but for many others as well. The mapping from the solution to the abstract \nproblem to the solution of the concrete prob-lem is usually straightforward since it just involves to \nundo the invention which we made earlier. At least three different uses of the PIP framework were given \nduring the workshop. The Patterns and Culture subgroup used PIP to describe the design pattern work. \nThe patterns are used to solve the abstract problems. The invention consists in identi-fying the appropriate \npatterns. Roger Burkhart was pointing out that his work on generic abstractions also fits into PIP (see \nBurkhart s position paper). The work on adaptive software at Northeastern University (see Palsberg s \nand Seiter s position paper or the book [Lie96]) can also be explained in terms of PIP. Prop-agation \npatterns are used to solve the abstract prob-lems. The invention consists in identifying the appro-priate \npartial class structures. Summary of presentations The first presentation was by Arindam Banerji on \nissues in evolving commercial operating systems. Ex-tending commercial operating systems is extremely \ndifficult because of large programs, non-modular code, many contributors, backward compatibility restric-tions \netc. The fundamental enabling mechanism to improve adaptability is scaffolding to integrate ex-tensible \nsubsystems. This approach is used in sys-tems like Apertos, SPIN, Exokernel, Flux, VINO and Scout/Choices. \nIt is critical to identify the desired degree of adapt- ability. In many situations, the desired degree \nof adaptability is affected by performance constraints or requirements of backward compatibility. In \nturn, the degree of adaptability has a great impact on the pro gramming infrastructure that is chosen. \nSafety and integrity of an adapted (or extended) system must be guaranteed. Although, there are some \napproaches to ensuring safety, such as safe languages, much work re-mains to be done. Roger Burkhart \ntalked about create-phase proto-cols for object customization (see his position pa-per). During email \ndiscussions prior to the workshop, Burkhart identified five limitations to adaptability: Lack of dynamic \nstructure within software imple-mentation to respond to varying needs, and the need for all this structure \nto be manually gener-ated. Insufficient abstraction in design languages to ex-press functionality of \nsoftware independent of its internal structure. Lack of explicit mechanisms for users of software to \ncommunicate their particular usage (e.g., cus-tomizations and restrictions) of generalized facil-ities \nand interfaces. Need for software to present multiple views to its various users under separate interfaces \ndesigned for each use, and yet still maintain coordinated state and interaction. Lack of generic, machine-processable \nrepresenta-tions of both designs and implementations by which to generate and process evolving struc-tures \n. Points two and three are again related to PIP. Maybe, we cannot express functionality independent \nof the internal structure of the software but loosely coupled to the internal structure of the software. \nA solution based on PIP is described in [Lie96]. Dave Wile talked about architecture-based excep-tion \nhandling and embryonic programming. His point of view is nicely summarized by two sentences from his \nposition paper: Program reuse is severely limited by today s programming language constructs because \n far too many conceptually irrelevant deci- sions must be made just to write down any- thing. A lot more \ndetail must be allowed to be implicit in programming languages before they can express truly adaptable \nalgorithms. Wile proposes the use of stylized components where the stylization is done by the style \nof the software ar-chitecture used. We can see here again an application of PIP: A program is not developed \nfor one specific architecture but for an entire family of architectures. A specific customization is \ngiven by choosing an archi-tectural style. This approach has the advantage that the programmer does not \nprewire a specific architec-ture. This relates to embryonic programming in that the same generic program \n(embryo) may grow into many different contexts of growth. Margaret Davis talked about Designing for \nAdap- tation Is a Barrier to Domain-Specific Reuse . Davis made an important observation by noticing \nthat the complexity of adaptable code does not bode well for its maintenance and evolution. By heavily \nparame-terizing code or by using other techniques which in-crease the code complexity to achieve adaptability, \nwe might eventually have diminishing returns because of the growth in code complexity. In Davis experience \nbased on a Navy/STARS demonstration project, it was not easy to create adapt-able software. The adaptable \nform created based on domain analysis tended to be longer than the non-adaptable form. Maybe, by applying \nPIP in an ap-propriate way, this problem can be solved by making the adaptable form of the software actually \nsimpler than the non-adaptable form. Carine Lucas presented her list of inhibitors to adaptability. One \nof the key items was: . One of the main problems in adaptive software is to find a good wcay to describe \nthe constraints to which adaptations should comply. The art is in finding the right balance between constraints \nthat are easily understood and expressed and con-straints that capture enough of the semantics of possible \nadaptations. Different kinds of adaptability result in different kinds of constraints. For example, \nadaptability with respect to class structures or lower level implementations can be expressed by succinct \nsubgraph specifications. The idea is to apply PIP by not writing a program for a specific class structure \nbut for an entire family of class structures which are constrained by succinct subgraph specifications. \nLucas was pointing out that we need different forms of adaptability mechanisms and that we can never \nforesee all possible kinds of adaptations. As a pos-sible solution, Lucas recommended constraint meta-programming. \nGerard Meszaros talked about adaptability in telecommunication system software. He talked about how to \nteach people to deal with adaptability and the importance of traceability between specifications and \nimplementations. Meszaros stressed that the architec-ture is a more valuable reusable asset than the \nimple-mentation. He praised the usefulness of design pat-terns to address adaptability. Gregor Kiczales \ngave a brief presentation on meta-object protocols and adaptability. He offered the fol-lowing ways to \nmake software adaptable: replaceable subcomputations Passing functions as arguments falls in this cate- \ngory. commit to less Kiczales was referring to the work on adaptive software [Lie96]. When you write \nbehavior, you commit to less object structure, for example. edit the program, edit the language Meta \nobject-protocols are a technology that can support edit the program and edit the lan- guage . MOP s work \nby representing programs as objects. The final presentation before the subgroup meet-ings started was \nby Shigeru Chiba on his meta pro-gramming work with C++ (see the conference pro-ceedings and position \npaper). After the subgroup presentations, the workshop concluded with a presentation by Jens Palsberg \non his work on a type system for adaptive programs based on the theory developed in [PXL95]. The main \nidea is that the type of an adaptive program is a set of class graphs which act as specializers for the \nadaptive program. An important question is whether a given adaptive program has a non-empty type, i.e., \nit is ty- pable. Some preliminary progress was reported on the solution to this question. Palsberg concluded \nthe workshop by asking partic-ipants to choose one element from each of the follow-ing pairs which describe \napproaches to adaptability: (foreseen, unforeseen),(coarse, fine-grained), (short-lived, long-lived), \n(algorithmic, interactive), (high-level, low-level).  4 Workgroup reports In the afternoon we had the \nfollowing work group reports: Adaptability and performance presented by John Lamping . Efficiency relies \non cross-module interactions. Top performance crucially depends on a module s being tuned to the particular \ncontext it is used in. It must avoid doing work not needed by the particular context, such as locking \noverhead when there is no actual concurrency; it must choose algorithms suited to its pattern of use, \nsuch as cache replacement strategies; it must precompute computations that are static given the context, \nsuch as object graph structures. Since the context of a module is determined by the other modules that \nit interacts with, all of these performance techniques depend on exploit-ing cross-module interactions. \nAdaptability is not something that a module can do by itself. . Don t pay for variability you don t \nuse and be able to say how much you will use. There is a cost for adaptability, such as runtime dispatches. \nThe cost can be well worth pay-ing when adaptation results. But any particu-lar use of an adaptable system \nwill typically en-gage only some of its adaptability mechanisms. An adaptable system should be designed \nso that the cost for a particular adaptation mechanism is only paid when that mechanism is engaged; there \nshould be no cost for unused potential adaptation. . Different techniques may be needed for fast adap-tation \nversus slow adaptation. Adaptation can happen at many time scales: as part of component assembly, at \nstartup, or dy-namically during execution. Different techniques are appropriate for different time scales. \nLonger time scales can utilize more programmer inter-action in the adaptation and can involve very expensive \nadaptation mechanisms. Shorter time scales require lighter weight adaptation mecha-nisms and leave less \nopportunity for programmer interaction.  Types and adaptability presented by Jack Wileden The group \ndiscussed the important role of con-straints in software adaptability. A constraint is an 152 Austin, \nn-ary predicate on software descriptions. Types are a special kind of constraints. Constraints facilitate \nadaptability by limiting the range of alternatives or generality permitted (anticipated) and by document-ing \nlimitations and assumptions. The goal is to max-imize flexibility while imposing necessary limits. In \n1992, Kiczaies and Lamping [KL92] wrote: The problem then is how to say enough about the internal workings \nof the [class] library that the user can write replacement modules, without saying so much that the implementor \nhas no room to work. This quote also expresses the tension between flexibility and necessary limitations \nin the context of an adaptable class library. There will probably be a hierarchy of constraints (types, \ncontracts, . ..) that corresponds to the hierar-chy of descriptions they consider (classes, frameworks, \narchitectures, . ..). This poses the following questions: . Where best to impose constraints? As high \nas possible (which is most limiting) or as low as pos-sible (leaving more opportunity for exploitation). \n. How can constraint consistency across levels be maintained? Design methods should use constraints \nto support adaptability. A meta-object form for constraints is viewed as an ideal representation. Several \ntools were considered for working with adaptability constraints: Browsers, checkers and constraint-based \nquerying. A number of models and notations for specifying adaptability constraints already exist, see \nfor exam-ple [Lie96]. After the presentation Peter Wegner made the re-mark that a distinction should \nbe made between inter-actional and computational constraints. Mehmet Ak-sit noted that constraints can \nbe useful at the design level as well as at the programming or other levels.  Approaches to unforeseen \nchanges presented by Harold Ossher One of the key issues discussed was how we can deal with unforeseen \nchanges which may come from end users who request a change, from external interface changes, or from \narchitecture changes. The nature of the change may be: more perfor-mance; different function, structure \nor state; inclusion of third party software. The group split approaches to unforeseen changes into two \nsubcategories. The proactive approach tries to write software in a more adaptable form and the re-active \napproach tries to automate or perform manually the adaptation when it happens. TX October H-19,1995 0 \npro-active The pro-active approach can be split further with respect to the level of omniscience, in \nother words, the level of planning look-ahead which is needed. - high level The following approaches \nwere considered to require relatively high omniscience to achieve the desired adaptability: domain analysis, \nrobustness analysis, design pat- terns, template programming, MOP for lan- guage design. - low level \nThe following approaches are considered to require less omniscience: adaptive program-ming [Lie961 and, \nsubject-oriented program-ming [H093, OKH+95]. In the case of adap- tive programming the reason is that \nin the structure-shy programming approach based on succinct subgraph specifications, the class structure \nor low-level implementation can be changed dramatically without requiring changes to the adaptive program. \nThe reactive approaches are: . re-active -refactoring [OJ90] This approach involves the automatic or \nsemi-automatic reorgani-zation of the program based on requirement changes or based on the need to make \nthe program easier to maintain. -tweaking - rewriting from scratch Recent work on a both re-active \nand a pro-active ap-proach to automating the evolution of object-oriented systems is in [HS96].  Patterns \nand culture presented by Gerard Mestaros Figure 1 about Polya s inventor s paradox was used for most \nof the report. The move from the concrete problem to the abstract problem requires the discovery of appropriate \ndesign patterns. The problem is then solved at the abstract level using those design patterns and the \nsolution is mapped back into the concrete do-main by applying the design patterns.  5 Conclusion The \nworkshop brought together a very stimulat-ing group of professionals both from industry and academia. \nThere are many approaches to improve adaptability of software. From the discussions at the workshop it \nbecame clear that Polya s Inventor s Para-dox is a useful unifying principle suitable to explain many \nof those solutions from architecture-based ap-proaches via adaptive and structure-shy programming to \ndesign pattern-based approaches.  References [HO931 William Harrison and Harold Ossher. Subject-oriented \nprogramming (A critique of pure objects). In Proceedings OOPSLA 93, ACM SIGPLAN Notices, pages 411- 428, \nOctober 1993. Published as Proceed- ings OOPSLA 93, ACM SIGPLAN No tices, volume 28, number 10. [HS96] \nWalter L. Hiirsch and Linda M. Seiter. f\\u-tomating the evolution of object-oriented systems. In International \nSymposium on Object Technologies for Advanced Soft-ware, Kanazawa, Japan, March 1996. Springer Verlag, \nLecture Notes in Com-puter Science. To Appear. [KL92] Gregor Kiczales and John Lamping. Is-sues in the \ndesign and documentation of class libraries. In Object-Oriented Pro-gramming Systems, Languages and dp-plications \nConference, in Special Issue of SIGPLAN Notices, pages 435-451, 1 ari-couver, Canada, 1992. ACM. [Lie961 \nKarl J. Lieberherr. Adaptive ObIect-Oriented Software: The Demeter Melhod with Propagation Patterns. \nPWS Publish-ing Company, Boston, 1996. [OJ90] William F. Opdyke and Ralph E. John-son. Refactoring: An \naid in designing ap-plication frameworks and evo lving object-oriented systems. In Proceedings of the \nSymposium on Object-Oriented Program-ming emphasizing Practical Applications (SOOPA), pages 145-160, \nPoughkeepsie, NY, September 1990. ACM. [OKH+95] Harold 0 ssh er, Matthew Kaplan, William Harrison, Alexander \nKatz, and Vincent Kruskal. Subject-oriented composition rules. In Proceedings OOPSLA 95, ACM SIGPLAN \nNotices, pages 235-250, ber 1995. Published as Proceedings SLA 93, ACM SIGPLAN Notices, 30, number 10. \nOcto-OOP-volume [PO1491 George Polya. How to University Press, 1949. solve it. Princeton [PXL95] Jens \nPalsberg, Cun Xiao, and Karl Lieber-herr. Efficient implementation of adaptive software. ACM Transactions \non Program-ming Languages and Systems, 17(2):264-292, March 1995.  \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Karl Lieberherr", "author_profile_id": "81452617626", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP40026940", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260270", "year": "1995", "article_id": "260270", "conference": "OOPSLA", "title": "Workshop on adaptable and adaptive software", "url": "http://dl.acm.org/citation.cfm?id=260270"}