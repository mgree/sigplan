{"article_publication_date": "10-01-1995", "fulltext": "\n The Navigation Toolkit Project Revisited Stephen W. Strom Rockwell Space Operations Company, Houston, \nTexas strom@acm.org Willium F. Rich Intelligent Medical Systems, Alpine, Texas 73062.1465@compuserve.com \n Matthew T. Verona Unisys, Houston, Texas 102013.2605@compuserve.com Abstract report is a follow-on \nto The Navigation Toolkit, which was presented at OOPSLA 94. The Navigation Toolkit was the first fully \nobject-oriented project within our company. and was completed in May 1994. But its impact since then \nhas been enormous. Its success was used as the primary hard data point for selling a much larger follow-on \nproject to NASA. The basic Toolkit architecture has been selected as the architecture for all future \nsystems, but changes will clearly be needed to expand into new domains. The Navigation Toolkit itself \ncontinued on in a somewhat independent some capability over ability to model any and lost others (such \ntethered satellites and lost capabilities have M&#38;M mode. Users gained existing tools (such as the \nnumber of space vehicles) as the ability to model other, similar forces). The resulted in user frustration, \n and the new capabilities have not yet been exploited. Another influence on the evolution of the Toolkit \nis the continued slow-down in the aerospace business. This is leading our company to seek new business \nopportunities, and improved flexibility in software could be a key to success in this area. 1. Scaling \nup is hard to do The Toolkit was built with a 7person. mostly highly experienced team. As reported in \nour original experience report, despite the introduction of new technology, etc., the team performed \nnearly as promised, achieving an overall productivity rate of 300 SLOG/Person Month and low defect density \nrates. The success of the Toolkit (and an object-based C predecessor, built by the same team) was the \nprimary hard data point used to sell the Reusable Object Software Environment, or ROSE, to NASA. ROSE \nis a proposed major rewrite of most of the design and analysis software used for space shuttle trajectory \noperations. Rockwell management was concerned that the kind of software development organization which \nproved successful for Toolkit development would not scale up to the full ROSE project. In particular, \nmanagement felt it could not count on the availability of highly skilled developers and chose instead \nto rely on minimally-skilled developers (90 days of training). It also needed to work under an accelerated \ndevelopment schedule, meaning it needed a larger development team. Current address: TRW Systems Integration \nGroup, Rosslyn, Virginia 2Current address: McDonnell Douglas Aerospace -Houston Division Addendum to \nthe Proceedings OOPSLA 95 A raw size comparison of the two projects is and a different process. A comparison \nof the contained in the following table: methodology and process of the two projects is contained in \nthe following table: Nav Toolkit ROSE actual s proposals Nav Toolkit ROSE actual s proposals Code 30 \n700 produced [mplementa- c++ c+t (KSLOC) tion language Code 150 2500 replaced (KSLOC)  cost (staff 8 \n150 years) Duration 1.5 4 (calendar years) ROSE s team goals were equally ambitious: Nav Toolkit ROSE \nactuals proposals Average team 6 38 size OOD Booth OMT methodology development bottom-up top-down strategy \nLife cycle model strategies: iteration incremental evolutionary I I packaging fixed stage fixed stage \nprogression additive transforma- tional team chief architect self-directed organi za- team tion Productivity \n312 389 (SLOUstaff month) Domain 13 <l programming experience (median years) It was felt that the low \nskill level could be more than compensated for by the use of CASE tools As a test, 20,000 lines of Toolkit \nfollow-on work were transferred to a 15-20 person ROSE development team. The results were disappointing. \nROSE productivity and SLOC reductions were both an order of magnitude below the proposal. Discussions \nwith ROSE team members make it likely that one of the major problems was the difficulty in assimilating \nthe existing 30,000 lines of Toolkit code, which were written in a compact, bottom-up style and assumed \nthat the user was both a domain and C++ expert. This assimilation time had not been factored into cost \nand schedule estimates. (One ROSE manager had expected the transition should require no more than an \nhour- Austin, TX October 1519, 1995 long lecture.) Clearly, reusable is not an inherent property of \nsoftware. There is also now general agreement that process alone is not enough, that the development \nteam requires substantial domain expertise, as well. 2. What happened to the team? Five out of seven \nmembers of the Toolkit development team have left the company, including the system architect and the \nproject manager, resulting in a combined loss of 75 years of navigation and software engineering experience, \nand including the company s senior object-oriented designers (one with 9 years experience) and C++ programmers \n(one with over 5 years of experience). Interviews with members who have left indicate that lack of recognition \nof, and respect for, their expertise was the prime motive for their departure. Second to that was the \nexpected frustration of dealing with ROSE s large, flat team structure. One of the people interviewed \nmentioned politics as a third factor. All agreed that though other, personal, reasons played a role in \ntheir decision to leave, respect and recognition from RSOC management would have influenced the outcome. \n 3. What is happening to the Toolkit? In three respects, the Toolkit project easily met or exceeded our \noriginal requirements: . Reduction in lines of code. Cost and schedule. Reliability As regards the last \npoint, the defect rate in the reusable components is a spectacular 0.2 defects per KSLOC. Weattribute \nthis, of course, primarily to the quality of the development personnel! But our methodology introduced \na triple redundancy (familiar to NASA) that greatly reduced errors: Formal specification of interfaces. \nModeling. Careful unit testing. Nevertheless, the Toolkit architecture has some worrisome aspects: . \n While they are efficient enough, the Toolkit components miss by a factor of 2 or 3 the most optimal \nperformance (demonstrated by tightly coded prototypes in C++). . The current architecture is not flexible \nenough to handle radically different kinds of space missions. These requirements exceed those of our \ncurrent customer and of ROSE. Nevertheless, without government or company funding, we are developing \na completely new system (informally dubbed Toolkit -The Next Generation ), which includes refactoring \nof original Toolkit functionality using design patterns and the Standard Template Library (STL). We are \nalso incorporating ANSI/ALU standards and taxonomies into the new architecture. This time, to try to \ninsure maximum efficiency and flexibility, we are introducing design goals which far exceed those of \nany current space missions. We are developing e.rtreme test cases. These include . Models of Ringworlds \nand Dyson spheres in order to assure the ability to model almost any kind of gravitating object. . Modeling \nof the impact of comet Shoemaker-Levy 9 on Jupiter in order to test our impact predictor and propagator \nclasses with near-parabolic (Jovicentric) orbits. Particle models of Galaxy formation involving thousands \nor tens of thousands of objects in order to insure efficiency. . A simple model of the Hubble space \ntelescope in order to validate our measurement models, which rely on refraction correction from the domain \nof geometric optics.  4. Rapid prototyping Our confidence in the benefits of rapid prototyping has \nnot been shaken by the passage of a year (Rich and Strom 1994). We still see it as an essential technique \nfor verification of the integrity of the architecture. Our first prototype was written in CLOS. It embodied \nthe primary abstractions of classical mechanics (Hestenes, 1986) as they interacted to perform the most \nbasic capability required by the users, integration of a single, orbiting object around a central body. \nThis prototype was translated into C++ and became the core of the Toolkit. From that point on, we abandoned \nCLOS and attempted to create prototypes directly in C++. It was not until nearly a year later, however, \nthat our next effort, a prototype least squares estimator, was completed. High on the list of reasons \nfor this delay is the language C++ itself. Hindsight shows that it is not a language that facilitates \nrapid prototyping. Wenow advocate spending up to 10% of the total development budget on rapid prototyping \nin a very high-level language. There are several advantages to such languages, all of which enable the \nanalyst to think of objects at a level that is closer to the problem domain. Automatic memory management \nprovides protection from the subtle bugs caused by dangling pointers. With dynamic linking, models can \nbe built piece by piece, usually from the bottom up; functions and classes can be redefined without resorting \nto a full recompilation, often without halting the execution of the program. Dynamic typing permits all \nvariables to be treated identically, whether or not they are the same type; language syntax is thus less \ncomplex and code can be reused even when the types of variables change as the model evolves. We advise \nusing a high-level language that is reasonably efficient; the performance of the model should not mislead \nabout the performance of the final system. This excludes many formal specification languages which can \nbe interpreted but which will run orders of magnitude slower than a production system. CLOS and Smalltalk \nare excellent modeling languages. After trying both of these, we now tend to prefer Dylan, Apple s new \nObject Oriented Dynamic Language. We chose Dylan over CLOS because of its readability and simplicity. \nWe prefer it to Smalltalk because of the use of generic functions and multiple polymorphism, which are \nfrequently more natural for scientific and engineering work; its support of multiple inheritance, which \nis essential for our style of development; and its macro system. In addition, with its CLOS-like optional \nvariable typing as well as sealed classes, it could be efficient enough to be chosen as the implementation \nlanguage. By no means does this exhaust the candidates for modeling languages. A primary criterion for \nchoosing a language is the facility one has within the language. (Sun s Java is a good example of a promising \nlanguage that emerged too late for us to evaluate, but which is quickly becoming the dominant object-oriented \nscripting language, winning out over weaker niche languages such as Python.) There is, of course. a price \none pays for prototyping in a high-level language; a prototype in a language other than the chosen implementation \nlanguage will never uncover all architectural inconsistencies. This is because there is no language independent \narchitecture. An Austin, TX October 15-19,1995 architecture that is perfectly consistent in one language \nmay not even be implementable in another (Rich and Strom 1994). Nevertheless, the high level prototype \nwill provide an overall vision of the architecture. If the design in the chosen implementation language \nis flexible, it can tolerate radical change as the architecture evolves. And we have learned that C++ \nis more powerful than we realized and is able to implement designs we never dreamed possible (see next \nsection). 5. Language C-t-+ has evolved much more rapidly than we could have predicted. When we began \nthe Toolkit, multiple inheritance was a relatively new feature of C++ and poorly supported by most compilers. \nThis was one of the factors involved in our use of CLOS and Macintosh Common Lisp, which provided a rock-solid \nimplementation of the concepts we wished to carry into our design as C++ compilers improved. But after \na few short years, the original Toolkit architecture looks quaint, as it does not use of the following: \nTemplates. . Exceptions. STL containers. Generic programming. We have also learned more about the use \nof 0-t, including incorporating double method dispatch into our standard set of programming techniques. \nDouble dispatch has obviated most of our need to reify functions. The gap between programming styles \nin C++ and CLOS or Dylan is now much smaller. Our original vector dot product was written in CLOS like \nthis (expressed in Dylan syntax): define method add (a :: <vector>, b :: <vector>) map(\\+, a, b) end \nmethod;  The original Toolkit C++ implementation of the equivalent operation, defined on our own N-vector \nclass, was implemented using a standard looping operation. However, the new operator, defined on an STL \nvector class, looks like this: :emplate <class T> rector<T>&#38; operator+=(vectorCS x, const vector<D&#38; \ny) ( transform(x.begin(), x.end(), y.begin(), x.begin(), plus--=-0);  return x; 5 I Aside from syntactical \ndifferences and the use of the name transform for what Lisp and Dylan call map, the code is nearly identical. \n  6. Process and methodology We are defining/refining/documenting our process and methodology. Of particular \nnote, we are documenting a life cycle according to IEEE standard 1074, Developing Life Cycle Processes. \nWe have dubbed the macro life cycle we use the punctuated equilibria model, after Gould and Eldredge \ns model of evolution (Gould and Eldrege 1972), because it advocates rather large, fundamental changes \nin software at intervals (driven by technology changes, requirements changes, etc.), separated by slower \nperiods of mostly bug-fix change. The traditional model of how software evolution should proceed is described \nby the following paraphrase of Gould and Eldredge 1972: . New programming systems are created by the \ntransformation of old programming systems into their modified descendants. The transformation of programming \nsystems occurs slowly and methodically. . All interrelated programs are modified simultaneously. . \n Nearly all developers are involved in the transformation. . All users continuously upgrade to the latest \nand greatest version of the programming system. The punctuated equilibria model of software evolution, \nby contrast, posits a markedly different version of history (again paraphrased from Gould and Efdredge \n1972): New programming systems arise by divergence from the old programming system. New programming systems \nare developed rapidly. Only relatively small parts of the old system are cannibalized, primarily algorithm \nreuse with little preservation of interfaces. The new programming system is created by a very smatl team \nof developers. The new programming system suddenly replaces the old, usually first among isolated groups \nof users. At the micro level, we continue to advocate Meyer s cluster model and incremental development. \nWe have identified several weaknesses in the process we described in our original experience report. \nWe are using the improved process in the Toolkit redesign, and will show how it improves the resulting \nproduct.  7. Acknowledgments A very small part of this work was performed under NASA contract NAS 9- \n18000. 8. References Eldredge, Niles and Stephen Jay Gould. 1972. Punctuated equilibria: An alternative \nto phyletic gradualism. First published in Models in Paleobiology, T. J. M. Schopf, editor, 1972. Reprinted \nin Eldrege 1985. Eldredge, Niles. 1985. Time flames: The Evolution of Punctuated Equilibria. Princeton: \nPrinceton University Press.  Hutt, Andrew T.F. 1994. Object Analysis und Design: Comparison of Methods. \nNew York: Wiley. Hestenes, David, 1986. New Foundations jtir Classical Mechanics. Dordrecht: Kluwer. \nRich, W. F. and Stephen W. Strom. 1994. The Navigation Toolkit, Addendum to the Proceedings Of the Conference \non Object-Oriented Programming Systems, Languages, and Applicutions, October, 1994 Stepanov, Alexander, \nand Meng Lee. 1994. The Standard Template Library. Palo Alto: Hewlett-Packard. More information is available \nat Strom s homepage: http://info.acm.orq/-strom/hornepaqe.html October 1519,1995  \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Stephen W. Strom", "author_profile_id": "81100300686", "affiliation": "TRW Systems Integration Group, Rosslyn, Virginia and Rockwell Space Operations Company, Houston, Texas", "person_id": "P268900", "email_address": "", "orcid_id": ""}, {"name": "William F. Rich", "author_profile_id": "81100311153", "affiliation": "Intelligent Medica Systems, Alpine, Texas", "person_id": "P299850", "email_address": "", "orcid_id": ""}, {"name": "Matthew T. Verona", "author_profile_id": "81332533731", "affiliation": "Unisys, Houston, Texas and McDonnell Douglas Aerospace, Houston Division", "person_id": "P194706", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260234", "year": "1995", "article_id": "260234", "conference": "OOPSLA", "title": "The Navigation Toolkit project revisited", "url": "http://dl.acm.org/citation.cfm?id=260234"}