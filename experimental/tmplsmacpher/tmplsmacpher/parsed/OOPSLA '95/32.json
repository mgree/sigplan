{"article_publication_date": "10-01-1995", "fulltext": "\n Building Large Distributed Software Systems Using Objects Ashutosh Tiwary Boeing Information and Support \nServices, I?O. Box 24346, MS 7L-40, Seattle, WA 98124. tiwury@atc.boeing.com Rajendra K. Raj Information \nTechnology Department, Morgan Stanley, 750 7th Avenue, New York, NY 10019. rkr@ms.com Douglas S. Lea \nDepartment of Computer Science, SUNY, Oswego, NY 13126. dl@g.oswego.edu Christopher J. Bosch Advanced \nInformation Technologies Center, The MITRE Corporation. 7525 Colshire Drive, McLean, VA 22102. cbosch@mirre,org \n Abstract Large product or service organizations have attempted or are attempting to build large scale \ndistributed software systems using objects. This paper summarizes the current conclusions of a workshop \non building such systems, as viewed from the perspective of practitioners and researchers in this area. \nThe participants concluded that although objects do help in managing the complexity in building such \nlarge systems, current object technology does not address many of the critical issues,  1.0 Introduction \nLarge product and service organizations such as automobile, aerospace, telecommunication, defense, and \nfinancial industries need very large and highly-responsive software systems to support a variety of complex \nprocesses. A majority of such applications are distributed over multiple machines and geographical location. \nThey also inter-operate with other applications and legacy systems. Such systems also gradually evolve \nover time. Many organizations have taken or are planning to take the leap to object technology for constructing \nthe next generation of such applications. The structure and design of large scalable distributed object \nsystems differs from small ones in several key ways. Large scale systems usually avoid keeping global \nsystem state; they attempt to preclude global operations and synchronizations such as global checkpoints \nand globally synchronized clock; and they avoid global communications such as message broadcasts. The \nworkshop goal was to work toward a common understanding of the major issues in constructing large practical \nsoftware systems using objects. Such large scale systems are characterized by: (a) large numbers of classes \nand objects, (b) highly complex object interactions, (c) large numbers of users and machines, (d) distributed, \nheterogeneous execution environments, (e) high performance and reliability, and (f) large scale needs \nfor evolution and maintenance.  Our participants were required to be practitioners with experience in \nbuilding large systems or researchers who are actively investigating such systems. They were asked to \nsubmit position papers on their understanding, usage, and concerns with the architecture, development, \nand use of such large software systems. The major participants were: Mehmet Aksit, University of Twente \nSteve Armstrong, Open University, U.K. Frank Armour, American Management Systems Umesh Bellur, TCSI Corporation \nWalter R. Bischofberger, Union Bank of Switzerland Lorrie Boyd, American Management Systems Patricia \nCarando, IBM Open Systems Center John Daniels, Object Designers Limited, U.K. John Dilley, Hewlett-Packard \nLaboratories Guiseppe Menga, Politecnico di Torino, Italy Craig Oddy, The Bank of Nova Scotia Thomas \nSarver, Consultant with Burlington Northern Yen-Ping Shan, IBM Corporation Monica Sood, American Management \nSystems Ventakesh Swaminathan, TCSI Corporation Yang Wang, IBM Corporation Note that this list includes \nsome people who jointly submitted position papers, but did not actually participate in the workshop sessions. \nThe workshop provided an opportunity for the participants to exchange ideas and experiences, and focus \non creating a shared understanding of the issues. Some of the key issues of interest were: Architecture \nand Distribution: The exploration of system structuring issues such as client/server and peer-to-peer \nmodels, interface definition mechanisms and languages, the interaction between mechanisms for software \ncreation (via inheritance or composition) and distribution, and the performance and software engineering \nimpact of distribution transparency. Reliubility: The impact of replication on techniques for recovery \nand fault-tolerance. Persistence: The interaction between distribution mechanisms (such as CORBA) and \npersistence services (such as relational and object-oriented databases systems, some of which have their \nown distribution mechanism). Management: The management of the development process (issues such as concurrent \ndefinition and development support across multiple organizations and development frameworks to support \nthis) and management issues of the deployed system (e.g., system administration, configuration and monitoring \nmechanisms). Communication paradigms: The paradigms useful for large scale distributed object systems \nincluding asynchronous versus synchronous communication, multicast, broadcast, and event notification. \nScalability and Performance: The division of responsibility between the application and infrastructure \nfor issues such as naming, addressing, sharing, concurrency, clustering, caching and coherence that impact \nperformance and scalability. Suitability of current commercial technologies: The interesting technologies \nincluded CORBA products, DCE, ISIS, Teknekron, and OODBs to support large scale distributed object applications. \n The participants submitted position papers that covered several of these categories. The workshop was \nstructured as follows. In the morning, four selected representative position papers were presented by \nthe authors and discussed. In the afternoon session, three broad topics were identified, and the workshop \nattendees broke up into three groups to discuss these topics. Their findings are summarized in the next \nthree sections. 2.0 Architecture and System Structure This group explored the impact of the architecture \nand system structure for large scale distributed object systems on the desired features such as reliability, \nmaintainability, and manageability. The discussions of the group were patterned after John Dilley s position \npaper and presentation. Dilley s paper discussed an on-going project in which he has been exploring the \ndesign, construction, and deployment of object-oriented large-scale widely-distributed real-time systems. \nHe summarized the key issues in building such systems with the acronym DRAMS, which stands for enamism, \nEeliability, availability, manageability and Scalability. Since there was insufficient time to discuss \nall of these issues in detail, the group focused primarily on dynamism and briefly touched upon the other \nissues. The group described dynamism as the flexibility with which a system adjusts itself to its environment. \nThe dynamism of a system can be viewed from the perspective of each key issue discussed in the previous \nsection. For example, how easily can a system be reconfigured to increase reliability and availability? \nIn general, the group felt that objects provide flexibility and finer grained control over the structure \nof large scale distributed applications, thus leading to more dynamic systems. The group discussed the \nimpact and contributions of the Object Request Broker (ORB) technology and the World Wide Web (WWW) technology \nin the construction of large scale distributed applications. Since the WWW model does not depend or support \na global state or any means of global synchronization, it seemed to provide part of the solution for \nconstructing a highly dynamic and decentralized software system. The contributions of the ORB technology \nwere not as clear; it was difficult to reach consensus on the degree of ORB support for dynamism. Object \ntechnology simplifies the development and deployment of software components to end-users and provides \nflexibility and rapid turn around for the development process. These components are available to end-users \nthrough multiple channels like the component vendor, a component VAR or via a local development team \nwith in-house extensions. One of the major problems with dynamism in software development is the version \nskew or the pedigree problem. This occurs because each of the different channels have different development \nthroughput and latencies. This results in the end-user getting incompatible versions of the same or different \nsoftware component through different channels. While the group discussed this problem in the context \nof software development, it is important to note that the same problems exist for coherency and consistency \nof objects in a distributed environment. Many of the problems identified above can be addressed through \na combination of human interaction and a suitable management infrastructure. As the size and complexity \nof the distributed application increases, there is greater reliance on a robust and scalable management \ninfrastructure. There was a strong sense within the group that the operation of large distributed systems \nmust be managed by as few system administrators as feasible. In particular, this means greater support \nfor remote management and self management. A framework for versioning and configuration management is \nneeded to support the management of the development process. For scalability, the group felt that the \nlevel of consistency supported in the application is the major trade-off. Sacrificing consistency in \nlimited, well-controlled, and well-understood settings appeared to be a reasonable approach to scalability. \nThe group discussed the separation between policies and mechanisms for implementing and using objects, \nclasses, operating systems, networks and machines. The trade-offs with availability were also explored \nbriefly. Some approaches based on views/read-only replicas and object versioning were sketched out as \nways toward possible scaling solutions. This group felt that it was difficult to quantify some of the \nissues in the limited time available and many of these topics are worthy of a full-day workshop.  3.0 \nSystem Structure and Design The two major issues investigated by this group were how the design of a \ncentralized object-oriented system can be mapped onto a distributed environment and how a distributed \nsystem can be structured to permit scaling to larger configurations. 3.1 Support for distribution in \nthe modeling process The group felt that the construction of a conceptual object model for any application \nmust be first undertaken without any consideration for distribution or persistence. Such a model would \ndescribe a centralized, single-node and single-user operation of the application. At some point in the \nmodeling process, the notion of distribution needs to be introduced. To support the various characteristics \nof a distributed system (such as location, concurrency, and coherence), it may become necessary to create \nnew abstractions or modify existing ones, and change the object model. For example, when a large object \nhas significant amount of concurrent accesses to different parts of the object, the concurrency bottleneck \nmay be reduced by partitioning this object into several objects. In turn, this may require adjustments \nto other parts of the object model. This is thought to be an iterative process. To summarize, modeling \nwithout concern for distribution is important BUT there comes a point where distribution affects the \nmodel. Every object in the object model does not need to be considered for distribution. It is important \nto select a granularity for distribution of objects that is well matched to the performance and scalability \ncharacteristics of the object management infrastructure. Objects that are contained within other objects \nand short-lived objects do not need to be considered for distribution. Using the granularity of distribution \nand object life-cycle information, objects irrelevant to distribution or persistence may be filtered \nout of the modeling process. Another important question in the design of such systems is the issue of \nclustering and object location. We want to cluster those objects together that are used at the same time. \nSome large scale applications provide implementation of business processes that have natural points at \nwhich objects move between locations. Application usage scenarios from real users and functional specijications \ncan be to derive clusters and distribution points.  3.2 Support for distributed objects in the large \nMany of the key difficulties in building large scale distributed software systems are also present in \ndistributed object-oriented systems. Designers of such systems need to be concerned with issues such \nas locality, caching, coherence, clustering, access granularity, latency, and throughput. Part of this \ninformation can be obtained by examining some key properties of the application. Examples of such measurable \nproperties include object size distribution, degree of coupling between the different sub-systems, the \nexpected response time, and the degree of consistency required (instantaneous, periodic or eventual). \nThe group started the development of a decision tree that could help the designer match an application \nto a suitable object management infrastructure based on these characterizations of the application. When \nthis investigation is complete, we will report on this separately.  3.3 Interaction between persistence \nand distribution Current object management infrastructures and object- oriented databases both provide \na mechanism for distribution of objects. The former provides efficient mechanisms for function shipping \nwhile the latter is focused on data shipping. Real large scale applications use a combination of these \ntwo approaches. Distribution and persistence are separate and orthogonal services, but a single flexible \nand ej$cient infrastructure is needed for function and data shipping.  4.0 Suitability of Commercial \nProducts This group explored the issues of using commercial technology in building large scale distributed \nobject systems. Most of the available products can be organized into three categories: object-oriented \ndatabases, language independent object management technology, typically based on the OMG object request \nbroker model; and programming languages with support for distribution, For each of these categories, \nthe group assessed the suitability of commercial products for the development of large, distributed software \nsystems. The advantages and shortcomings of these technologies are discussed below. Where these products \nwere determined to be unsuitable, an attempt was made to identify areas of desired functionality. 4.1 \nOODB-based management systems The group agreed that current commercial ODBMSs were not suitable for the \ndevelopment of large, distributed systems. Some key reasons cited for taking this position were (a) objects \nare replicated only from the server to the client for caching on the client side; there is no support \nfor peer-to-peer replication (b) their transaction mechanisms are not integrated with CORBA transaction \nservices; this increases software complexity and does not enable transactions against multiple databases \n(c) they only provide support for data shipping and (d) there are very few and commercial products adhering \nto the ODMG standards.  4.2 ORB-based management systems The group was split in its opinion on whether \nor not ORBS were suited for the development of large, distributed systems. Those taking the position \nthat ORBS were unsuitable cited the following reasons: (a) ORB interoperability problems, (b) lack of \nmanagement tools to support a large environment, and (c) lack of sufficient experience base in building \nlarge scale object systems using ORBS or any other technology. Others in the group felt that current \nORB interoperability problems did not justify taking the position that ORBS were not suitable for the \ndevelopment of large, distributed systems. This was because (a) there are no interoperability problems \nwith the current technology if you choose to work with a single vendor s product and (b) as vendor s \nproducts evolve to adhere to new CORBA standards, interoperability will not be dn issue even when ORB \nproducts from multiple vendors are used. The entire group shared a desire to see more in the way of standard \nservices and tools to help develop, operate and maintain large, distributed systems that use ORBS. Change \nmanagement and service (quality) management tools were the most desired tools. 4.3 Programming Languages \nthat support distribution The group noted that systems and languages designed for distribution (e.g., \nDistributed Smalltalk) ease the development of large, distributed software systems because: the large \namount of mechanisms built into the language reduces the complexity of developing such systems. programmers \ncontinue to use a language that they are already familiar with. and they only have to learn a few more \nconcepts. integration of distribution with the language makes it easy to support tools like distributed \ngarbage collection and remote debugging tools. As with ODBMSs and ORBS, the lack of standards for programming \nlanguages supporting distribution was considered to be a major limitation. Availability of skilled programmers \nin these languages is also an important issue.  5.0 Conclusions At the conclusion of the workshop, \nthe participants felt that more was known about techniques that do not work as opposed to those that \ndo work in building large scale distributed object systems. They felt that building large scale distributed \nsystems is hard and most of these difficulties cannot be ignored when building such systems with objects. \nObject modelling provides hierarchical support for managing complexity and this helps in dealing with \nsome of the complexity issues of large distributed systems. Support for encapsulation provided by objects \nsimplify the construction of portable object management infrastructures to manage the complexity of such \nsystems. \n\t\t\t", "proc_id": "260094", "abstract": "", "authors": [{"name": "Ashutosh Tiwary", "author_profile_id": "81100338692", "affiliation": "Boeing Information and Support Services, P.O. Box 24346, MS 7L-40, Seattle, WA", "person_id": "P22601", "email_address": "", "orcid_id": ""}, {"name": "Rajendra K. Raj", "author_profile_id": "81100590340", "affiliation": "Information Technology Department, Morgan Stanley, 750 7th Avenue, New York, NY", "person_id": "P238036", "email_address": "", "orcid_id": ""}, {"name": "Douglas S. Lea", "author_profile_id": "81100271749", "affiliation": "Department of Computer Science, SUNY, Oswego, NY", "person_id": "P69831", "email_address": "", "orcid_id": ""}, {"name": "Christopher J. Bosch", "author_profile_id": "81100389544", "affiliation": "Advanced Information Technologies Center, The MITRE Corporation, 7525 Colshire Drive, McLean, VA", "person_id": "P47502", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260094.260279", "year": "1995", "article_id": "260279", "conference": "OOPSLA", "title": "Building large distributed software systems using objects", "url": "http://dl.acm.org/citation.cfm?id=260279"}