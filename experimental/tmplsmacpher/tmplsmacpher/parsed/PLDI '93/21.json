{"article_publication_date": "06-01-1993", "fulltext": "\n Implementing Type Classes John Peterson and Mark Jones Department of Computer Science, Yale University, \nP.O. Box 2158 Yale Station, New Haven, CT 06520-2158, USA. Electronic mail: peterson-johnOcs. yale. edq \nj ones-markQcs. yale. edu Abstract We describe the implementation of a type checker for the functional \nprogramming language Haakell that supports the use of type classes. This extenda the type system of ML \nto support overloading (ad-hoc polymorphism) and cau be used to implement features such as equality types \nand numeric overloading in a simple and general way. The theory of type classes is well understood, but \nthe prac\u00adtical issues involved in the implementation of such systems have not received a great deal of \nattention. In addition to the basic type checking algorithm, an implementation of type classes also requires \nsome form of program transforma\u00adtion, In all current Haakell compilers this takes the form of dictionary \nconversion, using functions as hidden parauu\u00adetere to overloaded values. We present efficient techniques \nfor type checking and dictionary conversion. A number of optimization and extensiona to the basic type \nclass system are also described. Introduction In the study of programming languages, the term overloading \nis used to describe the abfity of a single symbol to have different interpretations as determined by \nthe con\u00adtext in which it appeara. Standard examples of this include the use of+ to represent both addition \nof integera and addi\u00adtion of floating point quantities, or the use of== to compare both character values \nand pointera. In each case, the in\u00adtended meaning of the overloaded symbol can be determined from the \ntypea of the arguments to which it is applied. One common approach is to completely resolve overloading \nat compile time. The compiler instaUa type specific mean\u00adings for all overloaded symbols, baaed either \non type in\u00adformation attached to operanda (the usual case) or some more general overloading resolution \nmechanism. A signif\u00adicant &#38;awback to this approach is that overloaded opera tiona cannot be abstracted \nwhile retaining their overloaded nature. A more dynamic approach to overloading which preserves the abUity \nto abstract overloaded definitions is found in ob- Permission to copy without fee all or part of this \nmateriall is granted provided that the copies are not made or distributed for direct commercial advantage, \nthe ACM copyright notice and ithe title of the publication and its data appear, and notice is given that \ncopying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, \nrequires a fee and/or specific permission. ACM-S IGPLAN-PLDl-6/93 /Albuquerque, N.M. @ 1993 ACM 0.89791 \n-59&#38;4 /93/ooo6/0227... $505O ject oriented languages. Here, resolution of overloaded oper\u00ad ations \noccurs at run time. There are two particular problems to be dealt with: How do we determine which interpretation \nof an over\u00adloaded operator should be used in any particular sit\u00aduation? There are many examples for which \nthe ap\u00adpropriate overloading cannot be determined at compile time. For example, in a program that uses \nthe func\u00adtion double = %,x + x to double both integer and floating point values, there is no way to fix \nany single interpretation for the + symbol.  How do we emure that overloaded values are only ever used \nwith appropriate arguments? For example, it would probably not make sense to try to add two char\u00adacter \nvalues. Aa a result, we must also ensure that the double function is never applied to a character value. \n  Standard ML uses two different approaches to overlx The type of each arithmetic operator such as \n+ must be uniquely determined from ita context, possibly by in\u00adserting an explicit type declaration. \nThis compile time resolution of overloaded operatora is not able to pre\u00adserve the full overloading of \n+ in the double fuuction, one specific implementation of + must be chosen.  Standard ML introduces a \nnotion of equality typea to deal with the typing of the equaht y function. This is undesirable because \nit forces the programmer to ac\u00adcept a particular structural definition of equality -one which tests for \nequality of representation rather than equality of represented value. In addition, Appel [1] reports \nthat Equality typea add significant complex\u00adity to the language and its implementation .  An alternative \napproach to the treatment of overloading was introduced by Wadler and Blot t [11] baaed on the notion \nof a type class and ia intended to provide a uniform and gen\u00aderal framework for solving exactly these \nkinds of problems. Type classes are most widely known for their use in the func\u00adtional programming language \nHaakell [6] where they are used mostly to deal with standard primitive functions such as + and ==. In \naddition, we have also found that type classes can be useful in more specific application areaa where \nthey can help to produce clear and modular programs [7 J. We should also mention that there doea not \nappear to be any signif\u00adicant reason why the use of type classes should be limited to non-strict, purely \nfunctional languages: in principle, any language baaed on the basic Hmdley/Milner/Damas type system could \nbe extended to support the use of type classes. This paper is meant to serve as a practical guide for \nthe im\u00adplementation of type classes. Previous work in this area has concentrated on the typing rules \nand has culminated in a set of syntax-directed typing derivationa which are the basis for our type checker. \nHere we will use the typing rules to create a concrete algorithm which both type checks and transforms \nthe program. We hope to reveal the essential simplicity of both the theory and implementation of type \nclasses. Our concerns are type checking programs efficiently, generating the best possible code from \nthe type checker, and introduc\u00ading a number of simple extensions to type classes which can be incorporated \ninto our basic framework. This work is the result of our experience implementing type classes in both \nthe Yale Haskell compiler and the Gofer interpreter. 2 Type classes -a summary We begin by summarizing \nthe main features of a system of type classes for a very simple and well known example the definition \nof an equality operator, written as ==, that is: . Polymorphic: use of the operator is not restricted \nto values of any single type. overloaded: the interpretation of equality is deter\u00admined by the types \nof its arguments. extensible: the definition of equality can be extended to include new datatypes. Our \nexample programs will be written using the concrete syntax of Haskell with explanatory comments where \nneces\u00adsary. Further details may be found in [6]. We will also use the following terms while describing \nthe class system: method A primitive overloaded operator such as == will be called a method. Methods \nare found in expressions. class A group of related methods is packaged into a class. Each class has a \nname which is used in the type lan\u00adguage. data type Type classes use the same sort of data types used \nby the ML type system. A type constructor names a data type in the type language while data constructors \ncreate values in the expression language. instance An instance binds a data type to operations which \nimplement the methods of a specified class for that type. The basic idea is to define a set of types \nEq, known as a type class in Haakell, that contains precisely those types for which a suitable definition \nof equality has been given using an inst ante declaration. The definition of the class Eq is as follows: \nclass Eq a where (==) :: a-> a-> Bool The first line introduces a name for the class and indicates that \nthe type variable a will be used to represent an arbitrary inst ante of the class in the following part \nof the definition. (In the general case, we use an expression of the form C t to represent the assertion \nthat the type t is an instance of the class C.) The remaining part of the declaration lists a collection \nof method functiom which are associated with the class. In this particular example, there is only a single \nmethod function, written as an infix operator, ==. The type signature a -> a -> Bool indicates that, \nfor each instance a of Eq, the == symbol behaves like a function that takes two arguments of type a and \nreturns a value of type Boo1. A class declaration may also define a set of superclasses for a given class. \nThe use of superclasses does not significantly complicate this type system and will be discussed later. \nUsing the notation of Haekell, the full type of == is written as (Eq a) => a -> a -> Bool. Note the convention \nthat all free variables in a type expression are implicitly bound by a universal quantifier at the outermost \nlevel. Thus == is polymorphic in a, but the choice of types for a is restricted to instances of Eq. Type \nclass constraints like this are often described as the contezt part of a type. Even before we have defined \na single instance of the class, we can use the == operator, either indirectly or directly, to define \nother values. The restriction to instances of Eq is reflect ed in the types assigned to these values. \nFor example: member :: Eq a => a -> [a] -> Bool member x [] = False member x (y: ys) = x==y I I member \nx ys The first line of this definition gives the type of member. Note that, in Haskell, [al represents \nthe type of lists of values of type a. As in the basic ML type system, user supplied type signatures \nare not actually required since they can be inferred automatically by the type system. We provide such \nsignatures in our examples as documentation. The second and third lines are typical of the way that functions \nare defied in Haskell. In this example there are two equations, using pattern matching on the left hand \nside to distinguish between the two cases when the list argument to rseriber is empty, [], or non-empty, \nwritten (y: ys ) where y and YS are the head and tail, respectively, of the list. The types which are \nmembers of a class are defied by a collection of instance declarations which may be distributed throughout \nthe program, typically in different program mod\u00adules where new datat ypes are introduced. For built-in \ntypes, the definition of equality may well be provided by a primitive function: instance Eq Int where \n(==) = prinEqInt More generally, we can define instances of the class I@ for any built-in and user-defied \nalgebraic data types as in the following definition of equalit y on lists: instance Eq a => Eq [a] uhere \n[1 = H =True (x: X8) == (y: ys) = X==y M Xs==ys =. = False (The underscore character -in the last line \nis used as a wildcard; it indicates that, if neither of the &#38;et two cases can be applied, the the \nequality test will produce a result of False. ) The expression Eq a => Eq [a] in the first line indicates \nthat the definition of equality on lists depends on the definition of equality used for the elements \nheld in the list: if a is an instance of Eq, then so is [a]. The set of types defined by a finite collection \nof instance declarations may be infinite (but recursively enumerable). For example, the definitions given \nabove describe the equal\u00adit y operator for integers, lists of integers, lists of lists of integers and \nso forth. Implementing Overloading One standard technique used in the implementation of run\u00adtime overloading \nis to attach some kind of tag to the con\u00adcrete representation of each object. Overloaded functions such \nas the equality operator described above can be implem\u00adented by inspecting the tags of their arguments \nand dis\u00adpatching the appropriate function based on the tag value. Many schemes exist for the encoding \nof tags to make the tag dispatch efficient. This is essentially the method used to deal with the equality \nfunction in Standard ML of New Jersey [2]. One of the benefits of static type checking is that it provides \na compile-time check which ensures that the the equality function will never be applied to an object \nfor which there is no corresponding definition of equality. Unfortunately, the use of tags as described \nabove has a num\u00adber of drawbacks. It can complicate data representation and may not be well suited to \nthe underlying hardware. Perhaps more significantly, there are some forms of overloading that cannot \nbe implemented using this approach. In particular, it is not possible to implement functions where the \nover\u00adloading is defined by the returned type. A simple example of this is the read function used in Haskell \nto parse a string as a value of any type that is an instance of the Text class, the set of readable (and \nprintable) types. An elegant way to avoid these problems is to separate ob\u00adjects from their tags, treating \ntags as data objects in tlheir own right. For example, we can implement read as a func\u00adtion that takes \nan extra argument which gives the tag of the result value. This amounts to passing type information around \nat run-time but this is only necessary when over\u00adloaded functions are actually involved. This is potentially \nmore efficient than uniformly tagging every data object re\u00adgardless how it will be used. Using this approach, \nthe nenber function in the previous section might be implemented by translating the original definition \nto: rnernber :: (a -> a -> Bool) -> a -> [a] -> Boo]. rnernber > eq x [] = False menberp eq x (y:ys) \n= eq x y I I member eq x ya In other words, the implementation of member is simply pa\u00adrametrized by \nthe appropriate definition of equality. The tag in this case is the equality function itself. In this \nexample, we could evaluate =eaber 2 [1,2,3] by rewriting it as rnernber primEqInt 2 [1,2,3] and evalu\u00adating \nthat expression instead. For a more interesting ex\u00adample, if xs is a list of lists of integers, then \nwe could evaluate nernber [I] xs in a similar way, rewriting it as member > (eqList primEqInt) [11 XS, \nwhere: eqList :: (a -> a[;> Bool) -> [a] -> [a] -> Bool eqList eq [1 = True eqList eq (X:XS) (y:ys) = \neq x y &#38;&#38; eqList eq xs ys eqList eq -_ = False The definition of eqList can be obtained directly \nfrom the instance declaration on lists in Section 2 in much the same way as the definition of nenber \nwas obtained from that of member. Type classes do not require a particular defi\u00adnition of equality for \na data type; any function of the ap propriate type can by supplied by the user to check equal\u00adit y. As \na convenience, Haskell allows the programmer to use derived instances for some of the standard classes \nlike Eq, automatically generating appropriate instance definitions. Note that this feature is not itself \npart of the underlying type system. One of our goals in the remainder of this paper is to describe how \nthese translations can be obtained automatically as part of the type checking process. 4 Static Analysis \nBefore type checking, the compiler must assemble the com\u00adponents of the static type environment. The \ndata type, class, and instance declarations (all top-level declarations in Haskell) must be collected \nand processed. One comtraint on these declarations is that instances must be unique: only one instance \ndeclaration for a particular combination of data type and class is allowed. This ensures that the meaning \nof overloaded operations with respect to parameter data types is consistent throughout the program. In \nthe previous section we described how the member func\u00adtion can be implemented by parametenzing its definition \nwith respect to an implementation of the == method. In the general case, a class may have several different \nmethods and it is sensible to parametrize the definitions of overloaded functions using dictionar~ values; \ntuples containing imple\u00admentations for each of the methods for a particular instance of a class. Static \nanalysis generates a dictionary for each instance dec\u00adlaration and these dictionaries themselves may \nbe over\u00adloaded. When a dictionary contains overloaded functions, as manifested in the context component \nof an instance dec\u00adlaration, it will reference further subdictionaries when con\u00adstructed. A dictionary \ncontaining eqList would need to be overloaded to provide the eq argument to eqList. In our implementation, \nthis captured dictionary is stored by par\u00adtially applying eqList to just the eq argument when the dictionary \ncontaining eqList is created. Each instance can be converted to a 4tuple containing the data type, the \nclass, a dictionary, and the context associated with the instance. A definition is inserted into the \nprogram which binds the dictionary value, a tuple of method func\u00adtions, to a variable, the dictionary \nvariable. The instance cent ext can be represented by a list of class constraints, one class constraint \nfor each argument to the data type defied by the instance. A class constraint is the (possibly empty) \nlist of classes which must apply to the constituent type. The instance declaration for list equality \nwould create this dictionary: d-Eq-List = eqList and the declaration itself would be represented by: \n(List ,Eq,d-Eq-List, [ llqll ) where List is the name of the list type data constructor. Since this \nclass has only one method a tuple is not need~ normally a dictionary would be tuple containing a defini\u00adtion \nfor each method. The context indicates that the first arwyt to the List type constructor must be in the \nEq Dispatching a method requires selection of the appropriate function from a dictionary. Selector fimctions \nwhich retreive a method from a dictionary are also defined as the static type environment is processed. \n(In the previous example no selectors are needed since there is no tuple in the dictionary.) These simply \nextract a component of a dictionary tuple, a constant time operation since each member function is located \nat a specific place in the dictionary. Dictionaries are only used where overloading cannot be resolved \nat compile time. When the type associated with a method is known at compile type the type specific version \nof the method is called directly without using the dictionary. Type Inference We will separate the issues \nof type inference, in which each program expression is assigned a (possibly overloaded) type, and dictionary \nconversion, in which the program code is transformed to explicitly extract method functions from dic\u00ad \ntionaries. The use and implementation of ML style type inference is well documented and we will not repeat \nthis here (see [4] for example). Instead, we concentrate e on the relatively minor changes that are needed \nto extend ML style type inference with support for type classes. As in ordinary ML typechecking, type \nvariables and unifi\u00adcation play a central role. Type variables are initially un\u00adbound, corresponding \nto unknown types. As t ype checking proceeds, various constraints on the values that can be as\u00adsigned \nto type variables are exposed, for example by ensuring that the argument type of a given function is \nthe same as the type of the value to which it is actually applied. These con\u00adstraints are solved by instantiating \nunbound type variables to more accurate types. Type classes require an additional field in each uninetantiated \ntype variable: the context, a set (represented by a list) of classes. Unification is affected in a very \nsimple way: when a type variable is instantiated, its class constraints must be passed on to the instantiated \nvalue. If this is another type variable, its context is augmented, using set union, by the context of \nthe instantiate ed variable. When a context is passed on to a type constructor context reduction is required. \nCon\u00adtext reduction uses the instance declarations in the static type environment to propagate all class \nconstraints to type variables, The type constructor being reduced by context reduction must be an instance \nof the reducing claas. If not, type checking fails with an error that an attempt has been made to use \nan overloaded operator at a type that is not an in\u00adstance of the corresponding class. If an instance \ndeclaration is found linking the data type and the class, the context of the instance declaration propagates \nto the type constructor . mWments. ThIS Process continues until contexts have been propagated exclusively \nto type variables. As an example, consider the unification of Eq a => a, a type variable with an Eq context, \nand the type [Integer]. The type variable is instantiated to [Integer]. Before context reduction, the \nresulting type is Eq [Integer] => [Integer]. The instance declaration for class Eq over the list data \ntype exists (otherwiee a type error occurs) and propagates the context Eq to the argu\u00adment to the list \ntype constructor. This leads to the type EqInt eger => [Integer]. Now we can see that the pro\u00adgram must \nalso include an instance declaration that makes Integer an instance of the class &#38;q. Assuming that \nthis is true, and since the Integer type constructor does not take any arguments, no further constraints \ncan exist leaving only [Int egerl as the resulting type. Note, however, that the unification would have \nfailed if the required instance deck rations were not found in the static type environment. By a similar \nprocess, unification of ~ a => a and Cbl would yield the type Eq b => [b]. Here, contexts remain attached \nto the resulting type variables. The following code implements type variable instantiation in the presence \nof type classes. Each type variable has a value field which is either null (uninstantiated) or contains \nan in\u00adstantiated type. The context field is a list of classes attached to uninstantiated type variables. \nThe f indInstanceContext function searches the static type environment for an instance with the selected \nclass and data type. If not is found this function signals a type error. It returns a list of contexts, \none for each argument to the data type. instant iateTyvar (tyvar, type) t yvar. value := type propagateClasses \n(tyvar. context ,t ype) propagateClasses (classes, type) if tyvar(type) then type. context := union \n(classes, type. context) else for each c in classes propagateClassTycon (c, type ) propagateClassTycon \n(cla8s, type) s = f indInstanceContext (type. tycon, class) for each classSet in s, t ypeArg in t ycon, \nergs propagateClasses (classSet, typeArg) One other minor change to ML type inference is required. When \na letrec is typechecked all variables defined by the Ietrec share a common context. This will be discussed \nin Section 8.3. It is worth emphasizing that context reduction is the only significant change to the \nML type inference process necee\u00adsary to infer correct t ypings for Haskell programs involving type classes. \nOn the other hand, dictionary conversion, as described in the following section (or some similar process), \nmust be carried out to implement overloading in the final executable version of the type checked program. \n6 Dictionary Conversion Dictionary conversion aflects the generated code in two ways. First, overloaded \ndefinitions receive additional param\u00adet er variables to bind dictionaries. Second, a reference to an \noverloaded definition must be passed dictionaries. Thus the t ypechecker needs only two basic changes: \nwhen reference to an overloaded definition (which is usually a function but may be of any type) is type \nchecked the hidden dictionary parameters must be inserted. When a definition (either at the top level \nor in a local definition using a let or letrec) The relation between a type signature and dictionary \npa\u00adrameters is simple: each element of the context corre\u00adsponds to a dictionary passed into or recirwed \nby an cwer\u00adloaded definition. For example, a function with the type is typed hidden dictionary arguments \nare inserted to bind any necessary dictionaries needed to resolve the overloading at run time. (Eq a, \nText b) => a -> b would require two dictionaries, one for the class Eq and another for Text. The ordering \nof a context is arbitrary; dictionaries can be passed in any order so long as the same ordering is used \nconsistently. Adding dictionary passing rode to the program during the code walk performed by the standard \nML typechecker is per\u00adhaps the essential implementation issue addressed here. The type associated with \nan expression may change due to uni\u00adfication as the type checker proceeds. Since types only sta\u00adblize \nat generalization the appropriate dictionaries needed to resolve overloading cannot be determined until \nthe entire expression being generalized has already been walked over. To avoid a second pass over the \ncode after generalization, we will hold onto the necessary bits of unresolvable code using placeholders. \nA placeholder captures a type and an object to be resolved based on that type. During generalization, \nplaceholders are replaced by the required type-dependent code. 6.1 Inserting Placeholders Placeholders \nare inserted when the type checker encounters either an overloaded variable, a method, or a letrec bound \nvariable. Slightly different forms of placeholder are used in each case. Overloaded variables are rewritten \nas an application to placeholders that will ultimately be replaced by the dic\u00adtionaries implied by the \nvariable s context. The fresh type variables associated with the variable are cap\u00adtured in the placeholders. \nFor example, if f has type (Nw a, Text b) => a -> b, the type checker will fist freshly instantiate the \ntype variables in f, yielding a typ\u00ading of (lhm t 1,Text t2) => t 1 -> t2. This fresh instan\u00adtiation \nof type variables is part of ordinary ML style type checking. The value f will be rewritten as an application: \nf <Nun, t 1> <Text ,t2>. The <object, type> notation will be used to represent placeholders. These placeholders \nbecome additional ar~ments to f which will be placed ahead of any other arguments. The classes Text and \nNu which appear in the placeholders indicate that the placeholder must resolve to an expression yielding \na dictionary for that class. Method functions are converted directly to placeholders. The type variable \nin the placeholder corresponds tc) the type variable which defines the class in the class declar\u00adation. \nFor example, the == method in class Eq would be typechecked by freshly instantiating its type, yield\u00ading \nEq t 1 => t i -> t 1 -> Bool, and returning the place\u00ad holder c == , t 1>. Since the object in the placeholder \nis a method, it will be resolved to either a specific implement a\u00adtion of the method if the type variable \nbecomes instantiated to a concrete type or code to select a == function from an Eq dictionary. Recursively \ndefined variables cannot be converted until their example, in a simple recursive definition such as member, \nthe recursive call to member becomes a placeholder until its type is generalized. After generalization, \nit is treated as an ordinary overloaded variable. 6.2 Inserting Dictionary Parameters Once a definition \nhas been typed, any context associated with the type variables in the definition is used to generate \ndictionary parameter variables which will bind the dictio\u00adnaries needed to resolve the overloading. This \noccurs during the generalization portion of type inference. Generalization gathers all uninstantitiated \ntype variables in the type of a definition and creates a new dictionary variable for every element of \nevery context in these type variables. A lambda which binds the dictionaries is wrapped around the body \nof the definition and a parameter environment is created. This environment is used to resolve placeholders \ncreated during t ypechecking of the definition. This environment maps a pair containing a class and type \nvariable onto a dictionary parameter variable. As a simple example, if the inferred type of f is (Num \nt 1, Text t2) => t 1 -> t2, then the definition of f is changed to f = \\dl d2 -> f where f is the original \ndefinition of f. This creates the following parameter envi\u00adronment: [(( Num, tl) ,dl) , (( Text, t2) \n,d2)l.  6.3 Resolving Placeholders At generalization, placeholders inserted into a definition can be \nresolved. A list of all placeholders, updated as each new placeholder is created, can be used to avoid \nwalking through the code in search of placeholders. After dictionary param\u00adeters have been inserted, \neach placeholder is examined. For placeholders associated with either methods or classes, the type associated \nwith the placeholder determines how it will be resolved. There are four possibilities: 1. The type is \na type variable in the parameter envi\u00adronment. In this case, the mapping defines a vari\u00adable which will \ncarry the dictionary at run-time. A class placeholder is resolved to the dictionary param\u00adeter variable; \na method placeholder requires a selector function to be applied to the dictionary variable. 2< The type \nhas been instantiated to a type construc\u00adtor. An instance declaration associated with this type supplies \neither the method itself for a method place\u00adholder or a dictionary variable for a class placeholder. \nSince dictionaries or methods themselves maybe over\u00adloaded the type checker may need to recursively gener\u00adate \nplaceholders to resolve this additional overloading. 3< The type variable may still be bound in an outer \ntype environment. The processing of the placeholder must be deferred to the outer declaration. 4, If \nnone of the above conditions hold. an ambiiruitv has been detected. The ambiguity may be res&#38;&#38;l \nby some language specific mechanism or simply signal a type error. type is known. References to such \nvariables encountered Placeholders associated with recursive calls can be resolved before they are generalized \nare simply replaced by a place\u00ad in two different ways. The simplest way is to generate an holder until \nthe correct context has been determined. For overloaded variable reference which is no different than \nfor other overloaded variables. This can only be done after gen\u00aderalization since the context of the \nrecursive call is unknown until this time. However, since any dictionaries passed to a recursive call \nremain unchanged from the original entry to the function, the need to pass dictionaries to inuer recursive \ncalls can be eliminated by using an inner entry point where the dictionaries have already been bound. \nAn example of this is shown in section 7. Examples We will illustrate the operation of our type checker \nwith a couple of examples, each of which consists of three code trees. The first code tree shows freshly \ninstantiated type variables (the ti ) and inserted placeholders. The rules for instantiating type variables \nand the type templates are the same as for ML type checking. The second tree shows the result of unification. \nTypes are unified pairwise along the lines in the diagrams. Finally, the result of generalization and \nplaceholder resolution will be shown. The actual type checker performs unification continuously instead \nof after all type variables have been instatuate~ these steps are sepa\u00adrated here for clarity. Rather \nthan write the context associated with a type vari\u00adable each time it is mentioned all type variable cent \next in\u00adformation will be shown at the side. The following function f uses a method, +, and a recursive \ncall to itself. class NUSI a where (+) :: a ->a->a f=\\x ->x+fx Type variable instantiation and placeholder \ninsertion pro\u00adduce the following expression tree. The @ nodes are curried applications. latrec f = \\x \ne xe <f,t,> x After unification, this becomes: htrea f = % e   + + /h <+,~> x e <f,p x The type in \nthe placeholder associated with + is part of the parameter environment. This indicates that a dictionary \npassed into f will contain the implementation of + appr~ priate for the parameter x. At execution time, \nthe sel+ function will retrieve this addition function from the dictio\u00adnary. This is the simplest translation \nin which the recursive call paases the dictionary d unchanged. A better choice would have been to create \nan inner entry to f after d is bound and use this for the recursive call to avoid passing d repeatedly. \nletmc f = \\d I \\x e /l\\ ex @ /\\ /\\ 801+d ex /\\ fd The next example uses a previously defined overloaded \nfunc\u00adtion, lengt~ with type [a] -> Int. The necessary class and instance declarations are included. We \nwill use the con\u00advention that dictionaries are named d-claw-type. class Text a where print :: a -> String \ninstance (Text a, Text b) => Text (a, b) vhere print = print-tuple2 instance Text Int irhere . . . . \ninstance Text a => Text [a] where . . . . g = \\x -> print (x,lengthx) After placeholder insertion and \ntype variable instantiation: let g= CcmtexCText ~ @ t5+String / \\ (ter b) *rint,&#38;> 2-tupl* x larlgth \n[431 9 x After unification, this becomes: let g= [$]+String I Context Text% \\x String I e ( [$], Int) \n+String /\\ ( [%1, Int) Cprint, ( [ts] , Int) > 2-tuplm Int /\\x length [%1 I [%1 x The placeholder is \nresolved to a specific printer for 2-tuPles. As this function is overloaded, further placeholder resolution \nis required for the types associated with the tuple compo\u00adnents. let g= I \\d I \\x I /\\ 2-tup19 /[\\ \n,, print-tuple2 @ d-Tut-Int x hngth /\\ I d-Teut-Liet d I x 8 Extensions This implementation of type \nclasses can be extended in a number of ways to both improve the generated code and increase the expressiveness \nof the type system. 8.1 Using a Class Hierarchy In a Haskell class declaration, a set of classes may \nbe de\u00adclared as superclasses of the defined class, For example, in the declaration: class Text a => Mum \na where ... class Text is a superclass of MUX. This implies that all datatypes declared to be in class \nMUB must also be declared to be in Text. This superclass relation allows a type such as (Nr.m a, Text \na) => a to be abbreviated as Nu a => a. Within the type checker, superclasses require few changes. When \nclass sets for type variables are constructed, contexts implied by the superclass relation can be removed. \nThis compacts the class sets and requires fewer dictionary pa\u00adrameters. Superclasses also require that \ndictionaries contain all superclass dictionaries. During dictionary conversion, a dictionary may not \nbe directly available if the associated class has been absorbed as a superclass. In this case, the dictionary \nor method must be fetched from an embedded superclass dictionary. Dictionary representation alTects the \nspeed of method selection. Deeply nested dictionaries can be avoided by flattening dictionaries to include \nall methods in both the associated class and in all superclasses at the top level of the structure. This \nslows down dictionary construc\u00adtion but speeds up selection operations. The effect of this tradeofl in \nreal programs is not yet known. Optimizations Class declarations may supply a default method to be used \nwhen an inst ante declaration does not provide an imple\u00admentation of a method in the class. This requires \nonly that this definition bound to a variable for use during dictionary construction. This variable in \nplaced into any dictionary in which the method in unspecified by the instance declaration. which avoid \ndictionary construction make flat tening more definition may contain: attractive. class Foo a where 8.2 \nDefault Method Declarations ml:: Bar m2::a->a b=>a->b  8.3 Typing Recursive Definitions So far we have \nassumed that the letrec construct binds only one variable. Mutually recursive definitions can be under\u00adstood \nas a tupling of functions. Mutually recursive functions f and g could be defined as follows: letrec (f \n,g) = (f body, gbody) in . . . Here there is only a single recursive value, the tuple. Notice that the \ncontext off and g are combined by this translation. Although mutually recursive functions are not actually \nim\u00adplemented as tuples, they are type checked in this manner. All functions defined by a single letrec \nshare a common con\u00adtext. This may create ambiguous functions when the type of a letrec bound variable \ndoes not contain the full context of the letrec. Such a function can be called within the Ietrec but \nnot from outside. This is not an error in itself but the compiler provides a warning about such functions. \n While it is easy for a single recursive function to use a local entry point to avoid passing dictionaries \nto recursive calls, this is harder to do for more than one function. It is simplest to paes all dictionaries \nto each recursive call within the le\u00adtree. Otherwise, all outside entries into the recursive group of \nfunctions needs to be funneled through a single lambda binding all dictionaries and then some sort of \nswitch is re\u00adquired to enter the proper function. Other approaches may be possible but this does not \nseem to be a critical perfor\u00admance issue. 8.4 Reducing Constant Dictionaries Another source of inefficiency \nare local functions which are inferred to have an overloaded type but are used at only one overloading. \nThese can be detected during optimization or during type inference. During type inference, this involves \nsaving the type variables crest ed by freshly instantiation of the signature as it is referenced. If \nall of these variables are instantiated to the same concrete type the dictionary can be reduced to a \nconstant, Flow analysis of the dictionaries can accomplish this same task and is perhaps superior since \noptimization may remove some function calls which would prevent a dictionary from being marked invariant. \n 8.5 Overloaded Methods Heakell allows method functions to be overloaded in more than the type variable \ndefined by class. For example, a class Here, ml contains an extra overloading. A dictionary for this \nclass should have a type (Bar b => T -> b,Y -> T) for some type T in the class Foo. That is, the first \ncom\u00adponent should be an overloaded function with Bar in the cent ext while the second component is independent \nof Bar. Unfortunately, this type signature is not valid since the con\u00adtext will float outside the tuple. \nIn implementation terms, the tuple will attempt to bind a dictionary for Bar when the dictionary is constructed \ninstead of simply placing a function which binds a Bar dictionary inside the tuple. This requires the \nimplementation of such dictionaries to go outside the at andard type class system when generating such \ndictionar\u00adies. The cleanest solution to this problem would probably involve existential types. The Yale \ncompiler avoids this issue using an internal construct similar to a type cast. 8.6 User Supplied Signatures \nUser supplied type signatures are a very necessary part of the type system. They can be used to avoid \nunwanted over\u00adloading and are essential for efficiency. Unlike the ML type system, user supplied signatures \nhave a significant impact on the generated code, possibly replacing higher order func\u00adtion calls (method \nselectors) with direct calls to instance functions. While there are numerous ways of implementing these \nsig\u00adnatures, our system does this in a very clean way using read\u00adonly type variables. Type variables \nin signatures are marked as read-only to prevent type instantiation from violating the signatures. A \nread-only type variable cannot be instantiated or have its context augmented. Another use of user-supplied \nsignatures is to fix the ordering of dictionaries during dictionary conversion. Haskell uses interface \nfiles to support separate compilation. These in\u00adterfaces provide the signature of each definition in \na mod\u00adule. These interface signatures define a specific ordering on the dictionaries passed to resolve \noverloading; at the im\u00adplementation level the types (Foo a, Bar b) => a -> b and (Bar b, FOO a) => a \n-> b are different in a very important way. The compiler must be aware of any interface for the module \nbeing compiled and use that signature to determine the dictionary ordering during generalization. 8.7 \nThe Monomorphism Restriction The Haskell report [6] imposes a constraint known as the monomor-phism restriction \non the generalization of over\u00adloaded variables. This is intended to avoid problems with the loss of laziness \nthat can occur when an overloaded vari\u00adable is translated to a function with one or more dictionary parameters. \nExplicit type signatures can be used to avoid the monomorphism restriction in those cases where over\u00adloading \nwould otherwise be restricted. Regardless of how the monomorphism issue is treated, it has a very simple \nim\u00adplementation. When this restriction applies to a variable, type variables in its context must not \nbe generalized: they must remain in the type environment to avoid fresh instan\u00adtiation while the body \nof the defining let expression is type checked.  8.8 Avoiding Unnecessary Dictionary Construction Overloaded \ndictionaries not actually constants but are dy\u00adnamicly constructed. The algorithm presented here may \nrepeatedly reconstruct identical copies of overloaded dictio\u00adnaries if the underlying implementation \nis not fully-lazy. To illustrate how this problem can occur, consider the fol\u00adlowing implementation of \nthe equality on lists in essentially the same form given by [11]: eqList d [] [1 = True eqList d (X:XS) \n(y:ys) = eq d x y k&#38; eq (eqDList d) xs ys eqList d . -= False The eqDList function conetmcts a dictionary \nfor equality on lists of type [a] given a dictionary d for equality on values of type a. The eq function \ndenotes the selector which extracts the method for == from a corresponding dictionary. As it is writ \nten, many implementations of this definition will rep,eat the construction of the dictionary eqDList \nd at each step of the recursion. One simple way to avoid this is to rewrite the definition in the form: \neqList d = let eql = eq (eqDList d) eqa =eq d e [1 [1 = True e (x:xs) (y:ys) = eqa x y &#38;&#38; eql \nX8 ys e-= False in e As a further example of the same thing, consider a func\u00adtion doOne of type C a \n-> a -> Bool for some class C and suppose that the definition of this function requires the con\u00adstruction \nof a dictionary value. Note that this fact may well be hidden from the compilation system if the deikition \nof doOne appears in an external module. Now suppose that we define a function doList [] = [1 doList (x: \nXS) = doOne x : doList xs A naive implementation of do List might use the definition doList d [] = [1 \ndoList d (X:XS) = doOne d x : doList d xs Any attempt to evaluate the complete list produced by an application \nof this function will repeat the construction of the redex doOne d (and hence repeat the dictionary (con\u00adstruction \nin doOne) for each element in the argument list. Happily, the same observation also makes the solution \nto this problem quite obvious; we need to abstract not just the dictionaries involved but aIso the application \nof overloaded operators to dictionaries, giving the translation: doList d = doList iihere doList $ [] \n= [1 doList (X:XS) = doOne x : doList xs doOne = do One d An additional benefit of this is that the garbage \ncollector can reclaim the storage used for dictionary values as soon as the implementations of the required \nmethods have been extracted from it. Note that these problems will not occur in an implemen\u00adtation that \nsupports full lazkess. Indeed, in each of the examples above, the improved translation can be obtained \nfrom the original version using a translation to fully-lazy form as described in [9]. 9 Performance Issues \n How do type classes affect the compiler? Our observation is that they increase compilation time only \nslightly. A minor increase in the cost of unification and the placement and resolution of placeholders \nmake up the majority of the extra processing required for type classes. As far as program execution is \nconcerned, type classes have two costs: the extra level of indirection when dispatching a method function \nand the time and space required to prop agate dictionaries through overloaded functions. The cost of \ninstance function dispatch is actually quite small since this requires only a reference to a tuple element \nfollowed by a function cafL For all but the simplest method functions this should be negligible. The \ncost of dictionary creation and propagation is harder to pin down. P~sing and storing extra arguments \nto overloaded functions will incur slightly more function call overhead. Ordy overloaded dictionaries \nconsume a non-constant amount of space. However, for code which does not use overloaded functiom (but \nstill may use method functions) the class system adds no overhead at all since the specific instance \nfunctions are called directly. In the case of a lazy language such as Haskell the overhead of overloaded \nfunctions may be greater since overloading is im\u00adplemented using higher order functions. Higher order \nfunc\u00adtions may be much more expensive in Haskell than ML since it is much harder to apply strictness \nor uncurrying optimiza\u00adtion. This is very noticable for very simple functions such as basic arithmetic \noperatom but for more complex functions, such as in the 1/0 system, the overhead of overloading is not \nnoticable. It is possible to completely eliminate dynamic method diw patch within an overloaded function \nat specific overloadings by creating type specific clones of overloaded function. This could be implemented \nin a more general partial evaluation context or be controlled through program annotations. 10 Conclusions \nand Related Work While type classes are a relatively new addition to type the\u00adory, we argue that they \nshould no longer be considered ex\u00adotic or experimental. Type classes provide an elegant solu\u00adtion to \na number of serious language design problems and should be considered as an important tool in programming \nlanguage construction. Type classes provide a simple and regular framework by which a program can be \nparametri\u00adzed. They do not provide the expressiveness of, for example, the ML module system where the \nparameterization is ex\u00adplicit. On the other hand, they are particularly convenient for some applications \nbecause the code needed to support overloading is handled automatically by the compiler. We have shown \nan implementation of type classes which is relatively simple, requiring only a few extensions to the \nbasic ML type checking algorithms. The addition of type classes does not severely impact either compiler \nor program performance. The basis for a translation from the Haskell syntax for declaring and using type \nclasses was set out by Wadler and Blot t [11] and some results from an early implemen\u00adtation baeed directly \non these ideas have been presented by Hammond and Blott [5]. Further ideas, mostly at a fairly abstract \nlevel, were presented in the static semantics for Haskell [10] and also, concentrating on the problems \nof re\u00adpeated dictionary construction, in [8]. Some of the tech\u00adniques used to improve the performance \nof Haskell overload\u00ading in the Chalmers Haskell compiler are described in [3]. In summary, experience \nwith the use and development of Haskell systems has done much to reduce the costs of type class overloading. \n11 Acknowledgments This work was supported by grants from DARPA, contract number Noo01491-J-4043, and \nfrom NSF, contract number CCR-9104987. Reference [1] A.W. Appel. A critique of Standard ML. Princeton \nUni\u00adversity CS-TR-36492, February 1992. [2] A.W. Appel. Compiling with continuations. Cambridge University \nPress, 1992. [3] L. Augustsson. Implementing Haskell overloading. To appear in Conference on Functional \nProgramming Lan\u00adguages and Computer Architecture, Copenhagen, Den\u00admark, June 1993. [4] L. Damaa and R. \nMher. Principal type schemes for functional programs. In 8th Annual ACM Symposium on principles of Programming \nlanguages, 1982. [5] K. Hammond and S. Blott. Implementing Haskell type classes. Proceedings of the 1989 \nGlasgow Workshop on Functional Programming, Fraserburgh, Scotland. Workshops in computing series, Springer \nVerlag. [6] P. Hudak, S.L. Peyton Jones and P, Wadler (eds.). Re\u00adport on the programming language Haskell, \nversion 1.2. ACM SIGPLAN notices, 27, 5, May 1992. [7] M.P. Jones. Computing with lattices: An application \nof type classes. Journal of Functional Programming, Vol\u00adume 2, Part 4, October 1992. [8] M.P. Jones. \nQualified types: Theory and Practice. D. Phil. Thesis. Programming Research Group, Oxford University \nComputing Laboratory. July 1992. [9] S.L. Peyton Jones and D. Lester. A modular fully-lazy lambda lifter \nin Haskell. Sofiware -Practice and Expe\u00adrience, 21(5), May 1991. [10] S.L. Peyton Jones and P. Wadler. \nA static semantics for Haskell (draft). Manuscript, Department of Computing Science, University of Glasgow, \nFebmary 1992. [11] P. Wadler and S. Blott. How to make ad-hoc polymor\u00adphism less ad-hoc. In ACM Principles \nof Progmmming Languages, 1989.  \n\t\t\t", "proc_id": "155090", "abstract": "<p>We describe the implementation of a type checker for the functional programming language Haskell that supports the use of <italic>type classes</italic>. This extends the type system of ML to support overloading (ad-hoc polymorphism) and can be used to implement features such as equality types and numeric overloading in a simple and general way.</p><p>The theory of type classes is well understood, but the practical issues involved in the implementation of such systems have not received a great deal of attention. In addition to the basic type checking algorithm, an implmenentation of type classes also requires some form of program transformation. In all current Haskell compilers this takes the form of dictionary conversion, using functions as hidden parameters to overloaded values. We present efficient techniques for type checking and dictionary conversion. A number of optimizations and extensions to the basic type class sytems are also described.</p>", "authors": [{"name": "John Peterson", "author_profile_id": "81100505832", "affiliation": "", "person_id": "PP31092258", "email_address": "", "orcid_id": ""}, {"name": "Mark Jones", "author_profile_id": "81100557950", "affiliation": "", "person_id": "PP31083227", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/155090.155112", "year": "1993", "article_id": "155112", "conference": "PLDI", "title": "Implementing type classes", "url": "http://dl.acm.org/citation.cfm?id=155112"}