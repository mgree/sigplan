{"article_publication_date": "06-01-1993", "fulltext": "\n Programmable Syntax Macros Daniel Weise Roger Crew Microsoft Research Laboratory Abstract Lisp has shown \nthat a programmable syntax macro system acts as an adjunct to the compiler that gives the programmer \nimportant and powerful abstraction facilities not provided by the language. Unlike simple token substitution \nmacros, such as are provided by CPP (the C preprocessor), syntax macros operate on Abstract Syntax Trees \n(A STS). Programmable syntax macro systems have not yet been developed for syn\u00adtactically rich languages \nsuch as C because rich concrete syn\u00adtax requires the manual construction of syntactically valid program \nfragments, which is a tedious, difficult, and error prone process. Also, using two languages, one for \nwriting the program, and one for writing macros, is another source of complexity. This research solves \nthese problems by having the macro language be a minimal extension of the program\u00adming language, by introducing \nexplicit code template oper\u00adators into the macro language, and by using a type system to guarantee, at \nmacro definkion time, that all macros and macro functions only produce syntactically valid program fragments. \nThe code template operators make the language context sensitive, which requires changes to the parser. \nThe parser must perform type analysis in order to parse macro definitions, or to parse user code that \ninvokes macros. 1 Introduction Macros are a meta-programming construct that trans\u00adforms programs into \nprograms. Macro languages are the world s second oldest programming language, having been invented immediately \nafter symbolic assembly language. Macro languages provided abstraction facilities that assem\u00adbly language \nlacked, such as procedure call and return, advanced control statements, and data-structuring facili\u00ad \nties. The additional programming abstraction provided by a macro system has the advantage of incurring \nno runtime penalty (although it does incur compile-time penalty). Thirty to forty years later, macro \nlanguages retain the same important use: providing abstraction facilities that a given language lacks. \nFor example, a powerful syntax macro Permission to copy without fee all or part of this material is granted \nprovided that the copies are not made or distributed for direct commercial advantage, tha ACM copyright \nnotice and the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, raquires a fea and/or \nspecific permission. ACM-S lGPLAN-PLDl-6/93 /Albuquerque, N.M. a 1993 ACM 0-89791-598-4193/0006101 56...$1.50 \n facility for C can seamlessly extend C to provide exception handling, a simple object system, (atomic \nresource alloca\u00adtion and deallocation, and new control statements. Syntax Macros S@az Macros operate \nduring parsing. Their actual param\u00adeters, which are abstract syntax trees (ASTS), are discovered by the \nparser. Macros produce ASTS that replace the code of the macro invocation in downstream compiler operations. \nSyntax macros declare the type of AST they return. This in\u00adformation is used by the parser to ensure \nmacro invocations only occur where their return type is expected. For example, syntax macros that return \nstatements can only occur where statements are allowed by the grammar. Syntax macros were independently \nintroduced by Cheatham [4] and Leavenworth [9] in the middle 60 s. They proposed that the actual parameters \nto macro invocations be found by a parser, and that the syntactic type of a macros return result be part \nof a macro definition. Vidart s PhD thesis [14] cleaned up many problems with syntax macros by makhg \nthe leap to transformations on trees, rather than on token streams. His macro system was substitution \nbased, that is, macro bodies are ASTS whose leaves are formal pa\u00adrameters that are replaced at invocation \ntime with actual parameters. Our use of the term Syntax Macro refers to Vidart s use of the term. W. \nR. Campbell [3] proposed a paper extension to Vidart s work that extended it towards programmability, \nbut in an ud hoc fashion. No implementa\u00adtion was reported for Campbell s extension. The major advantages \nof syntax macros are syrztactzc safety, encapsulation, and syntactic abstraction. Syntactic safety guarantees \nthat a macro user will never see a syntax error introduced by the use of a macro. Because transforma\u00adtions \nare specified in terms of syntactic constituents that the parser isolates, and because the type system \nof the base lan\u00adguage can guarantee the construction of syntactically valid program fragments, users \nwill only see syntax errors in terms of code they themselves write. Encapsulation refers to non-interference \nof syntactic constituents. In a token based macro system, a substitu\u00ad tion can yield a syntactically \nvalid program that produces the wrong result because of unintended interference. For example, consider \na macro with two formal parameters, A and B, whose body includes the expression A * B. If A and B were \nbound to x + y and m + n, respectively, then, in a token based macro system, the expansion contains the \nstring x+y*m+n,whoseparseisx+(y*m)+n,which is not the intended (x + y) * (rn + n). CPP macro writers \n are encouraged to use parentheses liberally to avoid this well known problem. In a syntactic framework, \nsuch interference is impossible because substitution is performed at the tree level. The macro writer \ndoes not need to be aware of unin\u00adtended conflict. Syntactic Abstraction refers to the ability to add \nnew elements to existing syntactic domains, and to introduce new concrete syntax for the new elements. \nA syntax macro sys\u00adtem literally adds to existing syntactic domains. (At least one macro system [10] \nalso allows the construction of mew syntactic domains. ) Programmable Syntax Macros Macro systems differ \nin the power of their transformaticmal engine (Figure 1). The weakest macro system are template based \nsystems, the most powerful macro systems sport a complete programming language. A programmable syntax \nmacro system allows the macro writer to act as a compiler writer. It can be viewed aa a portable mechanism \nfor ex\u00adtending the compiler itself. (This will become truer when the syntax macro system is extended \ninto a semantic macro system, that is, one with access to a program s static sem~an\u00adtic information.) \nThe problem of constmcting a powerful and simple pro\u00adgrammable syntax macro facility for syntactically \nrich lkm\u00adguages has remained open. The fundamental problems to be solved in delivering a programmable \nsyntax macro system for a language such as C are: to have the macro language be an extended version of \nthe base language, to guarantee syntac\u00adtic correctness of macro produced code, and to provide the convenience \nand simplicity of the substitution model where needed. This research solves these problems by making \nthe macro language be an extension of the base language, by us\u00ading the C type system to ensure syntactic \ncorrectness when macros and macro functions are defined, and by introducing code template operators to \nachieve the effect of subst itu\u00adtion where needed by the macro writer. The presence of code template \noperators make the language context sensi\u00adtive, which requires changes to the parser. The parser mmst \nperform type analysis to parse macro definitions, or to parse user code that invokes macros. Also, the \nparser must be fully re-entrant. As an example of the type of code that must be written when a programmable \nmacro (or other meta-programming) system lacks code templates or other code substitution fa~cil\u00adities, \nconsider a simple macro that abstracts away resource allocation and deallocation. Suppose that some window \nsystem required certain painting operations to be brack\u00adeted with BeginPaint and EndPaint statements \nthat aUo\u00adcate then deallocate a painting resource (these examples are based upon the Windows API). Without \nmacros, an id\u00adiomatic code fragment is: BeginPaint (hOC, &#38;ps) ; <Stint 1>; ... <strntn>; EndPaint \n(hOC, &#38;ps) ; We d like to capture this idiom in a macro called Painting, whose use would appear as: \nPaint ing { <stlllt 1> ; ... <stmtn>; 1 In a straightforward meta-programming system, a func\u00adtion for \nproducing the above code given the statement {<strstl> . . . <stmttn> } might be (where @stint is a type \nspecifier for the AST statement type): Qstmt paint.f unct ion (@trot s) { return ( crest e-compound-stat \nement ( create_ declaration_list () , create-statement-list ( create-function-call ( create_ id( BeginPaint \n) , create-argument-list ( create_ id( hDC ) , create-address-of (create_ id( ps )) ) ) , s, create-f \nunction-call ( , create-id( EudPaint ) , create-argnment.list ( create-id( hDC ) , create-address-of \n(create-id ( ps ) ) ) ) ) ) ) ; } This style of code plagues meta-programming systems. For example, \nthe meta-programming system of [2] heavily uses this style of coding. We solved the problem of concisely \ngenerating syntacti\u00adcally valid program fragments in a programmable system by adding explicit template \noperators to the macro lan\u00adguage that provide the convenience of substitution seman\u00adtics. These template \noperators automatically construct the above style of code from a code template. For example, us\u00ading the \ntemplate operator backquote (( ), the above function is written @stint paint-f unction (~stmt s) { return \n(C{ BeginPaint(hDC, kps) ; $s ; EndPaint(hDC, kps) ;})} where $s means to substitute the value of s. \nIn general, the prefix operator $ causes evaluation of the expression it prefixes; it is not restricted \nto just the substitution of iden\u00adtifiers. (Our code template mechanism was modeled after Lisp s [12].) \nWe have designed, and have mostly implemented, a pro\u00adgrammable macro system for C that has the following \nat\u00adtributes: 1. It is fully programmable, the macro language is Cplus an extended type system plus additional \nprimitive func\u00adtions. 2. Macros manipulate Abstract Syntax Trees. 3. Its rich pattern language specifies \nthe concrete syntax and the syntactic types of actual parameters for macro invocations. 4. Macros declare \nthe syntactic types they return. 5. Full type checking during macro processing guarantees syntactically \nvalid transformations. 6. Code templates are supported through the use of back\u00adquote forms.  Programmability/Macro \nBasis Character Token Syntax Semantic Full Programming Language GPM [13] 360 Assembler MS2 Maddox Lisp, \nScheme [6] Repetition &#38; Conditional Bliss [15] M5 Repetition Hygienic Macros [8] Substitution Pre-ANSI \nCPP ANSI CPP Cheatham Vidart Figure 1: Two Dimensional Categorization of Macro Systems. Our macro system \nis MS2 (Meta Syntactic Macro System). Chamcter Macros operate at the character level. They transform \nstreams of characters into streams of characters. We count pre-ANSI CPP as character based because many \nof them were. Token Macros operate on the tokenized representation of a program. They operate after (or \nin conjunction with) the tokenizer. Token baaed macro systems are simple to implement. Most assembler \nmacro languages and the well known CPP [1] are token based. Semantic Macros are an extension of syntax \nmacros that have access to, and can make decisions based upon, semantic information maintained by the \nstatic semantic analyzer. Semantic macros are the most powerful method for extending a language. 7. Non-local \ntransformations are possible, and are a pow\u00aderful tool. This paper has 5 sections. The macro language \nis pre\u00adsent ed in Section 2. Section 3 discuss implementation issues for the language. The fourth section \npresents many uses and examples of programmable syntax macros. The last section provides implementation \nstatus, related research, directions for future research, and conclusions.  2 The Macro Language The \nmacro language is C extended with AST types and op\u00aderations on ASTS. We call the part of a program that \ndefines macros and macro variables the meta-program. The meta\u00adprogram is fully run during macroexpansion, \nNone of it exists at runtime (except possibly as part of debugging in\u00adformation). Meta-programming constructs \nand regular pro\u00adgrams that invoke macros can either be located in separate files, or mixed together into \nthe same file, as is done now with CPP. The macro language adds two new top-/eueL declarations to the \ngrammar of C: meta-declarations and macro\u00addefinitions. These top-level declarations, which are pref\u00adaced \nby the keywords rQet adecl and syntax, respectively, declare elements of the meta-progam that define \nmacro transformations. Our syntactic descriptions follow the con\u00adventions of [5]. Non-terminals of the \noriginal C language appear in italic type. Non-terminals in our extensions to C appear in boldface type. \nAll concrete tokens appear in typewriter type. Alternatives in a production are listed on separate lines, \nThe only meta notation within an alter\u00adnative is for repetition, which is represented as three dots (.. \n.), and which indicate that the previous item may appear one or more times. The macro languages add the \nfollowing seven meta-tokens to C: (1, {1, l}, $$, $, ::, and Q. The syntactic clauses we present are \nmeant to augment the syn\u00adtax rules given in [5]. That is, the reader should assume that the syntax clauses \nof [5] are part of our syntactic definition of the macro language. Our rules either replace, or add to, \nthis base set of rules. top-level-declaration: declaration function-definition meta-declaration macro-definition \nmeta-declaration: metadecl declaration macro-definition: syntax macro-header compound-statement macro-header: \nast-specifier declaratory { I pattern I } Macro definitions have two parts, a header and a body (compound \nstatement). The header specifies the syntactic type of the AST returned by invocations of the macro, \nthe name of the macro, and the macro pattern used for invoca\u00adtion. Pointer and function declaratory are \nnot meaningful in this context. The macro pattern specifies concrete syntax and the required AST types \nof the actual parameters. The macro pattern guides the parser when it discovers the invo\u00adcation of a \nmacro. The compound statement is the macro body, the value it returns is the result of the macro invoca\u00adtion. \npattern: pattern-element . . . pattern-element: token $$ pspec :: identifier pspec: ast-specifier + pspec \nlist of 1 or more + \\ token pspec list of 1 or more + separator  * pspec list of O or more * \\ token \npspec list of O or more + separator ? pspec optional element ? token pspec optional preamble + element \n pattern tuple The pattern parser used to parse macro invocations re\u00adquires that detecting the end \nof a repetition or the presence of an optional element require only one token lookaheacl. It will report \nan error in the specification of a pattern if the end of a repetition cannot be uniquely determined by \none token lookahead. If the ? token pspec clause is used in the pattern, then the token indicates whether \nthe opti,~nal pspec is present, if the token is present in the invocation, then the pspec must be present. \nThe optional elements are for constructing statements such as loops that accept, for example, optional \nstep or uhile clauses. Example macro headera will be presented after we provide the syntax for ast-specifier. \nThe AST Type Language The type language for ASTS haa as primitives id, stint, decl, exp, num, and type-apec. \ntype-specifier: Q ast-specifier ast-specifier: decl stint id exp num t ype.spec The combining types on \nasts are tuples and lists. We overload C syntax for declaring tuples and lists: strut ture declarations \ndefine tuples, and array declarations define lists. For example, the declaration @id id-list [] defines \nid-l. ist to be a list of identifiers. Every macro pattern has an assoc\u00adiated type: the repetition patterns \nproduce lists and ~pat\u00adterns produce tuples. The C operators on arrays and structs are overloaded to \noperate on lists and tuples. For exam\u00adple, *id-list is the equivalent of the Lisp instruction (car id.1 \nist ), and id_l ist + 1 corresponds to cdr. It is ill{egal to take the address of either a scalar or \nstructured ast value, Additional Primitive Functions The macro language includes primitive functions \non ASTS, such as length. There are also functions for creating new identifiers, such as gensym ( ) and \nconcat-ids ( idl, id2 ). The additional functions add no conceptual novelty to the macro system. We also \nhave predefied member names for extracting components of ASTS such as stint 1->declarat ions and declarat \nion3->type-apec. We were not willing to add pattern-matching binding mechanisms, such as ML or mod\u00adern \nfunctional languages have. While pattern matching would add to the clarity of the macro language, we \ncur\u00adrently believe that such extra syntactic mechanism should be provided by macros, and not by us. The \nmacro language should be C, with as few syntactic extensions as possible. The only excursion from this \nprinciple is the presence of anonymous functions. As an experiment, the mi~cro language includes anonymous \nfunctions that may only be passed downwards. Anonymous functions are written as ( I declaration-lid eqwession). \nThese functions return the value computed by the express~o n without needing a return statement. Because \nmacros perform many list manipula\u00ad tions, anonymous functions are very useful. Future research will indicate \nwhether anonymous functions must remain a special element in the macro language. Example Macro Headers \nAs an example, consider the macro that implements the Paint ing abstraction shown in an earlier example. \nThe syn\u00adtax specifier says that the actual ~arameter of the macro is expected to be a statement. There \nare no buzz tokens. The macro definition is: syntax stint painting { I $$stmt: :body } {return ( {BeginPaint \n(hDC, .kps ) ; $body ; EndPaint (hDC, kps) ;}) ; } As another example of a macro-header, consider a macro \nthat mimics enum, but also automatically provides functions for reading and writing elements of the enumerated \ntype. An invocation of the macro might be new_enum color {red, blue, green}; The header for such a macro \nis: syntax decl new.enum [1 {1 $$id::name { $$+\\, id::ids 1; 1} The macro neu.enum returns a list of \ndeclarations. The macro-pattern +\\, id matches 1 or more repetitions of iden\u00adtifiers separated by commas. \nIf the macro parser cannot find such a repetition, an informative error message is returned to the user. \nThe pattern contains concrete syntax (e.g., the comma separator) which does not appear in the AST (a \nlist of identifiers) returned by the parser and then bound to ids. Also, the trailing semicolon is part \nof the syntax of the macro, which makes the syntax for new-enum consistent with the syntax for other \ntop level declarations in C. The macro returns a list of top level declarations, rather than a single \ndeclaration. It returns a list of declarations because it needs to return a enum declaration, along with \ntwo function declarations, one for reading elements of the new type, and one for writing elements of \nthe new type. Template Operators A key innovation of this research is the incorporation of Lisp s backquote \noperator for explicitly declaring code tem\u00adplates in a syntactically rich language. In a CPP style macro, \nthe body of the macro is the template, and substitution hap\u00adpens to an~ token that matches either a formal \nparameter or a #clef ined keyword. In this research, the body of a macro is a C compound statement. An \nexplicit code template mecha\u00adnism, along with an explicit %nquoting (substitution) op\u00aderator are used \nto achieve substitution macro semantics. We use the backquote character, , to introduce code templates, \nand use dollar sign, $, for the unquoting operator. The back\u00adquote operator is a prefix operator, much \nas the token ! is, and is therefore in the class of t~nary-e.rpre.ssz on.s. unary-expression: postjix-expression \npredecrement-express ion backquote-exp-expression backquote-stmt-expression backquote-decl-expression \nbackquote-pattern-expression The backquote operator returns an AST. This AST may have placehokiers embedded \nin it. The first token after the backquote determines the syntactic type of the AST that backquote will \nreturn. The open brace, { , signifies that a statement follows, the open parenthesis, ( , signifies an \nexpression, and an open bracket, [ , signifies a top-level declaration. There is a also a general form \nof backquote that accepts a pattern that determines the AST(S) to parse. backquote-exp-expression: ( \nexpression ) backquote-stmt-expression: { statement} backquote-decl-expression: [ top-level-declaration \n1 backquote-pattern-expression: {1 pspec :: template-specajied-sy ntax I ) The first three backquote \nforms are convenient shorthand notation for expressions, ~tatements, and declarations that could have \nbeen specified by the general backquote form (e.g., {l exp :: expression I }). Dollar sign, $ , introduces \na ,new syntactic domain: placeholder. Dollar sign precedes either an identifier or a par\u00adenthised expression. \nPlaceholders may only appear within backquote expressions. A placeholder signifies that its argu\u00adment \nis to be evaluated, and the results to be placed within the code (AST) being constructed by the backquote \nopera\u00adtor. placeholder: $ identifier $ ( expression ) Many primitive syntactic classes are extended to \ninclude placeholders as valid alternatives. For example, placeholders can stand in for statements, expressions, \ndeclarations, and identifiers. When backquote expressions are evaluated during macro expansion, placeholders \nmust expand to AST of the expected type. For example, placeholders that stand in for statements must \nexpand to statement ASTS. That they will do so is ensured by the static type checker when the backquote \nis parsed. (However, nested backquote causes special prob\u00ad lems. Some of the code it creates cannot be \nanalysed until the first level of expansion occurs, so not all checking can occur when nested backquote \nexpressions are parsed.) Macros and macro functions produce ASTS. Most impor\u00ad tantly, code templates \nalso produce ASTS, and placeholders return ASTS. Therefore, our macro system differs from most others \nbecause the macro writer may ignore issues of con\u00ad crete syntax when specifying the code a macro is to \nproduce. This distinction arises when manipulating lists of items that contain concrete separators that \nirrelevant to the abstract syntax. For example, the separator character for the init\u00ad deciarators of \na deciaratzon is the comma character. Suppose that the macro writer has a list of identifiers, say, (red \nblue green), bound to meta-variable ids, and wishes to produce the top level declaration emun color red, \nblue, green; The concrete syntax for this declaration includes the sepa\u00ad rator commas. The macro writer \nneed not be aware of this concrete syntax, and can simply write the template [enum color $ids; ] Some \nmacro systems that allow for repetition and list han\u00ad dling (e. g., the Bliss macro system) have a set \nof special case rules for ensuring that the correct separators appear in the produced code. Because our \nsyntax macro system explicitly constructs ASTS, and not concrete code, these extraneous concerns vanish. \nHowever, the macro writer does need to be aware of the C abstract syntax used by the macro system. We \nthink that making the macro writer be aware of abstract syntax is a fair price to pay for simplifying \nthe transforma\u00ad tional language.  3 The Parser Macros and template operators make the grammar context \nsensitive. The presence of placeholders in templates force the parser to employ semantic analysis (t. \ne., type analysis and checking) that determines the type of AST returned by a placeholder when it is \nevaluated. This AST type infor\u00ad mation guides the parsing of templates. The presence of macro invocations \nalso require parse-time semantic analysis for correct parsing of code that contains macro invocations \nand for checking that macros of a given type only appear where they are allowed. Our parser is a hand-written \nrecur\u00ad sive descent parser at the declaration and statement levels, but a bottom-up precedence parser \nat the expression level. Parsing Macro Headers When a macro keyword is encountered, the parser interprets \nthe macro s pattern to guide the parse of the invocation. The specifier indicates where and which tokens \nare to be found, as well as the required syntactic constituents of the macro invocation. This process \nis a relatively small part of compiling a program. However, even this process could be accelerated by \na routine that compiled a parse routine for each macro s pattern. This specialized routine would be associated \nwith the macro keyword ancl called when needed Parsing Code Templates ( Backquot e) The AST denoted by \na code template must be uniquely de\u00ad termined by information available at macro definition time. It cannot \ndepend on information available only when the macro is invoked. This restriction allows macro expansion \nto be implemented very efficiently. The presence of placeholders in templates force the parser to employ \nsemantic analysis of the metacode containing the backquot e and the placeholder expression. At any given \npoint during a parse, the parser may be faced with optional constructs and several alternative constructs. \nNormally, the parser uses concrete tokens such as identifiers and punctu\u00adation to thread through the \nmaze of possible parses. These tokens are not in the templates because they won t be /sup\u00adplied until \na macro is invoked. For example, consider the source code temp,late Cint $y; I in a context where a \ndeclaration is expected. There are several possible parses depending on the AST type that y wilt be bound \nto, as shown in Figure 2. As another example of parses being dependent upon the AST type returned by \nplaceholder expressions, con\u00adsider the difficult ies of parsing compound statements, which have no explicit \nmarkers that separate declara\u00adtions from statements. For example, the code template {int x; $phl $ph2 \nreturn(x) ; } has four different possi\u00adbles parses depending upon the types of phl and ph2 (Fig\u00adure 3). \nWe help the parser disambiguate potential parses by care\u00adful design of the token stream that the parser \nreads from. We introduce a new type of token that we call a placeholder to\u00adken. Upon discovering a $ \ntoken, the tokenizer co-routines with the parser to parse the placeholder expression in the semantic \ncontext at entry to the containing backquote ex\u00adpression; performs AST type analysis on the expression \nto determine the type of AST it will return when run; and then wraps the expression and its type into \na placeholder token. The different routines of the parser perform looka\u00adhead on the token stream to see \nif the AST they are to parse is represented by the next token. For example, if the routine parse-statement \nfinds a placeholder token on the head of token stream that has type stint, then the routine returns the \nplaceholder token aa the result of its parse. If it doesn t find such a token, it operates normally. \nThe AST type analysis performed by semantic anal:yser is germane. It knows the declared types of meta-variables \n(both globals and parameters of macros and rneta-functions) and the types returned by primitive operations \non ASTS. It uses this information to determine the type returned by a placeholder expression. Parsing \nMacro Invocations When the parser encounters a macro keyword, it parses the invocation according the \nmacro s pattern, packages up the macro with its actual parameters for later expansion, then uses the \ndeclared type of the macro to decide how to continue the parse. In principle, macro invocations should \nbe allowed to appear wherever placeholders are allowed. Our system, however, currently only allows macro \ninvocations where ei\u00adther declarations, statements, or expressions are expected. statement: expression-statement \nnull-statement placeholder macro-invocation primary-expression: name literal parenthised-expression \nplaceholder macro-invocation declaration: declaration-specifiers initialized-declurcitor-[ist ; placeholder \nmacro-invocation macro-invocation: macro-keyword syntax-specified-by-macro-t rrnpiate Dealing with Context \nSensitivity C is not a context free language. Due to t ypedef, the parse of a program fragment depends \nupon the context that the fragment appears in, For example, the fragment f oo *i; should be parsed as \na declaration if f 00 has been made type specifier via t ypedef, otherwise the fragment should be parsed \nas an expression statement. The existence of syntac\u00adtic macro delcarations introduces further context \nsensitivity. Our parser is forced to parse program fragments indepen\u00addently of the context those fragments \nwill appear in. (We aren t completely happy wit h this approach, and are exam\u00adining alt ematives. ) Such \nfragments appear within backquote expressions insi,~ of macro bodies, and in the actual param\u00adeters to \nmacro revocations. This design choice limits the expressiveness of macros, and leads to some non-intuitive \nresults. Macros that produce typedefs, use macro-defined typedefs, or are parameterized over t ypedef \ned names must be used carefully. Otherwise, a name will be parsed as if it were a normal identifier, \ninsteacl of as a type-9pecifier. Thk design choice also prevents a macro from setting up context in which \nits actual arguments are to be parsed within. For example, consider a looping macro that wants the special \nkeyword exit to have meaning only within its actual arguments. The clean solution is to have the looping \nmacro set up a special exit macro that only has effect dur\u00ading the parsing of its actuals. However, the \nlooping macro s arguments are parsed with no knowledge of the invoking macro, other than its template. \nTherefore the exit macro must be global, and invocations of it can t know whether they occur within the \narguments to the looping macro. To get around thk problem, we must add linguistic constructs to the macro \nlanguage that would allow an invoked macro to set up a parsing context for its arguments. Macro Expansion \nBecause the macro language is C extended with AST datatypes and a few new primitive functions, macro \nexpan\u00adsion is simply a matter of running a C program on the parsed arguments of a macro invocation. The \nease of debugging macros depends upon the quality of the clebugger provided by the C programming environment \nbeing used. The present implementation uses an embedded interpreter for a subset of the C language to \nexecute meta-code. We chose this solution for simplicity. Macros perform fairly sim\u00ad ple and routine \nactions where speed is not of tremendous import ante, so an interpretive approach suffices. The alter\u00adnative \napproach, using fully compiled C routines, would re\u00adquire that the parser be able to dynamically link \nin compiled C functions. This is certainly possible, but taking the speed\u00adiest approach for executing \nmacros was beyond the scope of AST type of y Parse init-declarat or O (declaration (int) y init-declarator \n(declaration (int) (y!) declaratory (declaration (int) init-declarator y ) identifier (declaration (int) \n((init-decf~ator (direct-decl~~~c!r y) ( )))) - Figure 2: The different parse trees for the source code \ntemplate [int $y; 1 depending upon the AST type of the metavariable y. A node of the tree and its children \nis written (node-name child I . . . chlldn). List, elements in the tree are written within parentheses. \n phl ph2 Parse decl decl (c-s (decl-list ((decl Lint x ) phl ph2)) (shut-list ((r-s (exp (id x)))))) \ndecl stint (c-s (decl-list ((decl int x ) phi)) (stint-list (ph2 (r-s (exp (id x)))))) stint stint (c-s \n(decl-list ((decl int x ) )) stint-list (phi ph2 (r-s (exp id x ) ) stint decl Syntactically Illegal \nProgram Figure 3: Parses of the code template { int x; $phl $ph2 return(x) ;}. For conciseness, we \nhave abbreviated compound-statement as c-s, return-statement as r-s, statement as stint, identzjler as \nad, expression as ezp, and decla\u00adration as decl. this research. A production system might well opt for \na fully compiled approach, rat her than an interpreted approach. 4 Uses of Macros A programmable syntax \nmacro system offers many advan\u00adtages. First, it provides a framework upon which special purpose preprocessors \ncan be built. Many software projects, especially in the database field, extend a language to incor\u00adporate \ndomain specific data types and statements. The first task of these projects is to write a preprocessor, \na task that would be trivial if a suitable macro facility were available. Second, macros form the basis \nof an extremely low over\u00adhead virtual machine. The literature from the 1960 s and 1970 s is rife with \npapers that propose the use of powerful macro languages to solve the software portability y problem. \nAlthough we now have a common system programming lan\u00adguage (C) to solve portability problems at the hardware \nar\u00adchitectwe level, in the 90 s the divergence of OS API s (Unix SVR4, BSD, SUNOS, MAC/OS, DOS, W/NT) \n1 present new and difficult portability problems. There are two solutions to this problem: implement \na common virtual machine as an interpreter, which incurs a large performance penalty, or im\u00adplement a \ncommon virtual machine as a series of macros in a programmable macro language, which has other problems, \nbut at least can be very low overhead. New control constructs, such as specialized looping con\u00adstructs, \nand domain dependent control constructs are eas\u00adily implemented in a programmable syntax macro system, \nSpecialized control constructs raise the abstract program\u00adming level. For example, resource allocation/deallocation \nis a common idiom of the form: Grab a resource, use the re\u00ad source, release the resource. The Paint ing \nmacro displayed earlier had this structure. A simple macro can capture the allocate/use/deallocate idiom. \n1Some of these names are trademarks of their respective owners. We now present examples of macros we \nhave written. Be\u00ad cause of space restrictions, we focus on what can be done with macros, rather than \nthe actual mechanisms (i. e., macro definitions). The simpler macros can be implemented with CPP, though \nnot as cleanly, abstractly, or safely as with syntax macros. Dynamic Binding Dynamic binding is very \nimportant in many applications. One of the most important applications of dynamic bind\u00ading is the declaration \nand use of exception handlers, which are, ipso fact o, dynamically bound entities. Macros offer a simple \nand clean mechanism for declaring dynamic binding. For example, the following macro defines a new statement \ntype that modifies an integer variable, executes code, then unmodified the variable. syntax stint dynzurdc. \nbind { I {$$type_spec: :type $$id: :name = $$exp: : init} $@stmt: :body I } {Oid newname = gensymo ; \nreturn ( {$type $newname = name; $name = $init; $body ; $name = $newname; } ) } An invocation of this \nmacro might appear as dynamic-bind {int printlength = 10} {print .class-structure (gym-class) ; } (In \na semantic macro system, which has full access to the static semantic analyzer of the base language, \nthe type of name would be available to the macro system. In this case, the macro user wouldn t need to \ndeclare the type of name. ) Exception Handling We now implement an exception handling system using syn\u00adtax \nmacros. This is a simple system, where the catch tags body then clesn.up is executed. If athrow does \noccur, the execution of body is terminated, cleanup is run, then the throw continues unwinding the stack \nuntil itreaches thename it matches. The macro unwind-protect is a very important, part of an exception \nhandling system when writing interac\u00adtive programs where the user may asynchronously abort + computation. \nWe now show these macros ill action. myenum error-types {division-by-zero, fi.le.closed, using_unixl; \nint foo(a,b,c) int a, b; int *c; {int z, *y; z =a+b; catch division_by_zero {printf( k , You lose, divisionby \nzero. );) {*c = frob(z, a);} unwind_protect @.tart_faucet_r mmingo; } @top-ru nning_faucet ();3 return(z) \n;1 The macro unwind-protect is especially important for maintaining the allocate/deallocate invariant, \ncliscussecl ear\u00adlier. Consider again the Painting macro. It shoulcl LLSe unwind-protect to ensure the \ndeallocation of the painting structure: syntax stint Painting {1 $$stmt::body 1} {return ( {BeginPaint(hDC, \n%Ps); Unwind_protect $body {EndPaint(hDc, %PS) ;}});} The user of the Painting macro need not Iw aware \nof this behavior, it s just part of the abstraction. Readers and Writers for EnunlerntedTypes C does \nnot provide routines for reading or writing elements of user defined types. Syntax macros can automatically \nprovide such routines. In this example we consider a reader and a writer for enumerated types. A macro \nsuch as myenum could be defined to have the same effect as enum, ancl also write extra code. as shown \nbelow. p myenum fruit {apple, banana, kiwi}; expands into emus fruit {apple,banana,kiwi} ; 2We have not \nyet addressed the issue of rlleta-le\\,el llarllespaces. The artifice of using the name myenum rather \nthall the more logical enum is to avoid name clashes. A better method would make explicit the notion \nthat a macm package exte]lrls laagaage N into language N + 1, and allow code templates t{., declare whether \nthe identifiers they employ refer to language N or t,, language N+ 1. We could then name the macro enum, \nand have its use of enum refer to the language being extended, rather than to the language being defined, \nThis problem is independent {,f standard name capture problems addressed by hygienic a]ar)() >ystems. \nare identifiers. The exception system could be complex by writing more complex macros, but ple is about \nusing macros, not about a powerful system. An exception system needs three items: 1. A method for establishing \na handler.  2. A method for invoking a handler, 3. A method for carefully unwinding  We have invented \nthree new statements, LULWind.prot ect: syntax stntt throw {1 $$exp::value {if (simple-expression(value)) \nreturn ( {if (exception-ptr== NULL) error( No handler for Xd , else longjmp(exception-ptr,$value) else \nreturn( <int the-value = $value; made more the exam\u00adexception . catch, and if (exception.ptr == NULL) \nerror( No handler for Xd , the-value) ; the stack throw, ; 1} $value); ;}); else longjmp(exception-ptr, \n syntax stntt catch {1 $$exp::tag { $$stmt::handler II {return( {int *old_exception-ptr int jmp-buf[2]; \nint result; result = setjump(jmp-buf); the_value) ;});} } { $$stmt::body } = exception-ptr; if (result \n== O) {exception-ptr= else {exception-ptr if (result $handler sYntaX stint unwind-protect {1 { $$stmt::body \n} { {return( {int *old-exception-ptr= int jmp-buf[2]; jmp-buf; $bodyl = old-excepti.on-ptr == $tag) else \nthrou result;}}) } $$stmt::cleanup } 1} exception-ptr; int result = setjump(jmp.buf) ; if (result = O) \n{exception-ptr= jmp-buf; $body} exception-ptr = old-except ion-ptr; $cleanup; if (result != O) throw \nresult;});} (Note, these examples ignore the problem of ture caused by the introduction of new names \nmatch names in substituted code. This problem having afunction gensymto create names that variable cap\u00adthat \nmight is solved by cannot ap\u00ad pear inusercode, but theextra work would have needlessly complicated the \nexamples. We briefly discuss inadvertent name capture in the last section.) The catch statement establishes \na handler called name during the execution of its body. If, during execution, a throw statement is executed \nthat throws name, then the execution of body exits, and handler is run in its place. That is, the exception \nsystem has termination semantics. Unwind-protect is a statement that ensures cleen-up isex\u00adecuted even \nwhen a throw statement throws out of the exe\u00adcutionofits body. Ifnothrow occurs during the executionof \nint read-fruito {char sIIOO]; void print.fruit(int arg) {switch (arg) {case apple: printf( k , apple \n); case banana: printf( %( , banana ) ; case kiwi: printf( ~s , kiwi ) ;}} getline(s, 100); if (!strcmp(s, \napple )) return(apple); if (!strcmp(s, banana )) return(benana); if (!strcmp(s, kiui )) return(kivi);} \nThemacro itself is (where thefunction mapappliesafunc\u00adtion parameter to each element of its second parameter \nto return anew list): syntax decl rnyenum[] {1 $$id::name{ $$+id, ::ids}; II ~return(list( [enum $name \n$ids;], [$(symbolconc( print_ ,name))(arg) {switch (arg) $(map((l @id id; {case $id: printf( ik , $(pstring(id))) \n;}), ids))}], [$(symbolconc( read- ,name))() {char s[1OOI; getline(s,100) ; $(map((l Qid id; {if (!strcmp(s,$(pstring(id)))) \nreturn($id) ;}) , ids) ) }1 ));} Generalizations of this example are quite useful. Persis\u00adtence code, \nRPC code, dialog boxes, etc., canbe automat\u00adically created when data is declared. The problem of auto\u00admatically \nconstructing such routine code hmbeen addressed before in the meta-programming literature. For example, \n[2] presents a meta-program for automatically constructing reading and writing functions for Pascal enumerated \ntypes. Because that system didn t have code templates, the code for doing so is rather bulky and unwieldy. \nBy using code templates, we achieve a similar effect with far less code that is far more readable. Code \nRearrangement Frequently code must appear in one place in a program when it would be conceptually simpler \nto distribute the code throughout the program. For example, in programs that are not object oriented, \nlarge dispatch routines are still com\u00admon. Such code is more perspicuous when each datatype says how \nit relates to the dispatch, rather than have the in\u00adformation only intheone large dispatch routine. Conversely, \nfrequently codeis spread througha program that wouldbe better placedin oneor two routines. Many GUI s \nforce the programmer sprinlderesponses to different events for a given state of the system throughout \nher code. It would be more perspicuous to write the code in one place, and have it aw somatically dktributed \nthroughout the code. The example we are about to show modularizes the con\u00adstruction of a dispatch table \nin a non-object oriented lan\u00adguage. Thedispatch procedure will reside inoneplace in the final code, but \nwe will write the code in a distributed fashion. We will achieve this effect by writing macros that accumulate \nthe code fragments together, and then use a macro to glue them together andemit afull blown window procedure. \nThe concrete dispatch procedure we ll discusses the main window processing loop in a Windows based application. \nWe ll use three macros for writing distributed code that is collected into one large dispatch routine \n(we present just, the macro-headers): syntax decl new_window_proc {1 $$id: :proc.name default $$id::default_proc_name; \n1} syntax stint vindoii-proc-dispatch {1 ( $$id::proc-name, $$id::message_name ) $stmt::body 1} syntax \nstint emit_window_proc {1 $$id::proc_name ; 1} The macro new-window-proc establishes a new window procedure \nwith name procname. The default procedure to be called when this procedure doesn t handle a message is \ndefault-procname. This procedure will collect code frag\u00adments created by repeated calls to window-proc-dispatch. \nThe macro window-proc-dispatch takes the name ofawin\u00addow procedure, the name of a message, and a statement. \nIt associates themessage name and the statement with the window procedure. The macro emit_window_proc \ncauses to appearinitsplace in theprogram the window procedure that was accumulated via window-proc-dispatches \nthat named the window procedure. As a simple example, the program new_window_proc wproc default DefWindowProc; \nwindow_proc_dispatch(wproc, W-DESTROY) {KillTimer(hHnd, idTimer); PostQuitt4essage(0)} window_proc_dispatch(wproc, \nWH_CREATE) {idTimer= SetTirner(hWnd, 77, 5000, (TIFIERPROC) NULL);} emit_window_proc vproc; produces \nthe program int wproc(HUND hWnd, UNIT message, WPARAM WParam, LPARAtl lParam) {switch (message) { default: \n{ return(DefWindowProc(hWnd, message, wParam, lParam)); break; } case WH_CREATE: { idTimer = SetTimer(hWnd, \n77, 5000, (T1rnEfLpROC) FJuLL); break; } case lW_DESTROY: { Ki.llTimer(hWnd, idTimer) ; PostQuit14essage \n(0); break; }} return(NULL); }  The three macros use a global meta-variable to commu\u00adnicate. Beside \nthe three macro definitions, there is also metacode for declaring this metavariable, which holds the \nmethods for the different window procedures defined by the macros. metadecl struct w.proc {Qid name; \nmethod-table *mtp; u-procs *next;}; metadecl struct u-proc *proc-list = NULL; Space prevents us from \npresenting the full macro defini\u00adtions. The macro nev.windou.proc adds an empty method table toproc.list, \nthe macro vindow_proc_dispatch adds a method to a method table, in proc.list, and the macro emit_window-proc \nproduces a C function based on the con\u00adtents of the method table of the window procedure to be produced. \n 5 Related and Future Research The system is currently undergoing revision. Except for the last macroexample, \nallmacrosshown inthispaperworked in the previous implementation. Once the re-implementation is complete, \nwe will conduct large scale experiments with the macro system. Besides the systems already mentioned \n[14, 3, 4, 9], there s current work on new macro systems for syntactically rich languages. Todd Jonker \n[7] is working on hygienic macro technology for syntactically rich languages. William Mad\u00addox at Berkeley \nis investigating extensions of his Master s thesis [10] that give macros semantic abilities. Dain Sam\u00adples \nhas recently announced M5 [11], another token-based macro system. It is a very general macro processor \nthat can be programmed to understand the lexical conventions of different languages (e.g., C, C++, Ada, \nand Tex). In the Lisp community, Hygienic Macros [8] and syn\u00adtactic abstractions have been proposed for \nmaking macros easier and cleaner to write. Such macro systems automat\u00adically avoid unanticipated capture \nof free variables. Early hygienic macro system were substitution based and had sup\u00adport for repetition. \nMore recent research [6] has given hy\u00adgienic macro systems complete programming power. We feel that hygienic \nmacro systems are very important, and are considering methods for making our system be hygienic and referentially \ntransparent. In a sense, this research has brought C up to 1970 s Lisp macro technology. More re\u00adsearch \nis required to take it into the 90 s. Another goal is the implementation of semantic macros, which are \nan extension of syntax macros where the macro processor does static semantic analysis (e.g,, type checking). \nSemantic macros will have two new important powers. First, they conditionalize their operation based \non runtime types returned by the expressions they manipulate. This will al\u00adlow, among other things, a \nform of object oriented dispatch at compile time. It will also simplify the invention of new binding \nforms, which need access to the runtime type of val\u00adues they will be manipulating. Second, the macro \nwriter will do all relevant type checking in the macro itself, and not wait for type errors to be found \nby downstream type checking. This would make macros be completely self contained, and ensure that programmers \nwouldn t end up having to track down type errors in code they didn t write, as is the case for syntax \nmacros. We have shown that a programmable macro system can be very simple and very powerful. The major \ncontribution of this paper is the introduction of explicit code template oper\u00adators and AST datatypes \ninto an existing language to could a powerful macro system for that language. Such an approach can be \nused for any language as long as the parser can be modified to perform type checking during the parse. \nAn important advantage of this approach is that a new macro language with its own special syntax, operators, \nstatements, and functions does not have to be invented, as has been historically done. Acknowledgements \nThe authors would like to thank Bjarne Steensgaard, who read and commented on drafts of this paper, and \nthe anonymous referees.  References [1] ANSI Standard on C, X3.159-1989, ANSI, NY, 1990. [2] Cameron, \nR. D., Software reuse with metaprogram\u00adming systems, Proceedings of the Fifth Annual Pacific Northwest \nSoftware Quality Conference, OR, pp. 223\u00ad32, 1987 [3] Campbell, W. R., A compiler definition facility \nbased on the Syntactic Macro, Computer Journal 21(1), pp. 35-41, 1975 [4] Cheatham, T. E., The introduction \nof definitional fa\u00adcilities into higher level programming languages, pp. 623-637, Proc. AFIPS (Fall Joint \nComputer Confer\u00adence, 29), 1966 [5] Harbison, S., and Steele, G., C, A Reference Manual, Third Edition, \nPrentice Hall, 1991 [6] Hieb, R., Dybvig, R. K., Bruggeman, C., Syntactic ab\u00adstraction in Scheme, University \nof Indiana Computer Science Technical Report 355, 18 pages, June 1992 (Re\u00advised July 1992). [7] Jonker, \nTodd, Personal Communication, 1992 [8] Kohlbecker, Eugene, Friedman, Daniel P., Felleisen, Matthlas, \nDuba, Bruce, Hygienic macro expansion, Proceedings of the 1986 ACM Conference on Lisp and Functional \nProgramming, pp. 151-161, ACM Press, NY, 1986 [9] Leavenworth, B. M., Syntax Macros and Extended Translation, \nCACM 9(11), pp. 790-793, 1966 [10] Maddox, William, Semantical/y-Sensitzue Macropro\u00adcessing Report No. \nUCB/CSD 89/545, (Master s The\u00adsis), 82 pages, University of California, Berkeley, 1989. [11] Samples, \nDain, M5, Electronic Announcement on comp.compilers newsgroup, 1992 [12] Steele, G., Common Lisp, The \nLanguage, Digital Press, 1984. [13] Strachey, C., A general purpose macrogenerator, Computer Journal, \n8(3), pp. 225-241, 1965 [14] Vidart, J., Extensions syntaxiques clans une contexte LL(I), University \nof Grenoble, Th ese pour obtenir le grade de Docteur de troisi eme cycle, 1974 [15] Bliss-n Programmer \ns Manual, CMU Department of Computer Science, 1974. \n\t\t\t", "proc_id": "155090", "abstract": "<p>Lisp has shown that a programmable syntax macro system acts as an adjunct to the compiler that gives the programmer important and powerful abstraction facilities not provided by the language. Unlike simple token substitution macros, such as are provided by CPP (the C preprocessor), syntax macros operate on Abstract Syntax Trees (ASTs). Programmable syntax macro systems have not yet been developed for syntactically rich languages such as C because rich concrete syntax requires the manual construction of syntactically valid program fragments, which is a tedious, difficult, and error prone process. Also, using two languages, one for writing the program, and one for writing macros, is another source of complexity. This research solves these problems by having the macro language be a  minimal extension of the programming language, by introducing explicit code template operators into the macro language, and by using a type system to guarantee, at macro definition time, that all macros and macro functions only produce syntactically valid program fragments. The code template operators make the language context sensitive, which requires changes to the parser. The parser must perform type analysis in order to parse macro definitions, or to parse user code that invokes macros.</p>", "authors": [{"name": "Daniel Weise", "author_profile_id": "81100605135", "affiliation": "", "person_id": "PP31099253", "email_address": "", "orcid_id": ""}, {"name": "Roger Crew", "author_profile_id": "81100204295", "affiliation": "", "person_id": "P247809", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/155090.155105", "year": "1993", "article_id": "155105", "conference": "PLDI", "title": "Programmable syntax macros", "url": "http://dl.acm.org/citation.cfm?id=155105"}