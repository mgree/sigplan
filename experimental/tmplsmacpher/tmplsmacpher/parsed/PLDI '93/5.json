{"article_publication_date": "06-01-1993", "fulltext": "\n Interprocedural Modification Side Effect Analysis With Pointer Aliasing William Landi Siemens Corporate \nResearching 755 College Rd. East Princeton-, NJ 08540 blsndi~scr. sie~ens .com Abstract We present anew \ninterprocedural modification sideef\u00adfects algorithm for C programs, that can discern side effects through \ngeneral-purpose pointer usage. Ours is the first complete design and implementation ofsuch an algorithm. \nPreliminary performance findings sup\u00adport the practicality of the technique, which is based on our previous \napproximation algorithm for pointer aliases [LR92]. Each indirect store through a pointer variable is \nfound, on average, to correspond to a store into 1.2 locations. This indicates that our program\u00ad point-specific \npointer aliaaing information is quite pre\u00ad cise when used to determine the effects of these stores, 1 \nIntroduction Accurate compile-time calculation of possible interpro\u00ad cedural side effects is crucial \nfor aggressive compiler optimization [ASU86], practical dependence analysis in programs with procedure \ncalls [Ban88, BC86, W0189], data-flow based testing [RW82, OW91], incremental se\u00ad mantic change analysis \nof software [Ryd89], interpro\u00ad cedural clef-use relations [PRL91, PLR92] and effective static interprocedural \nprogram slicing [HRB88, 0084, Ven91, Wei84]. These are key problems in parallel and sequential programming \nenvironments; the utility of *The research reported here was support ed, in part, by Siemens Corporate \nResearch and NSF grants CISE-CCR-92\u00ad08632 and CCR-9023628 2/5. Permission to oopy without fee all or \npart of this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Machinary. To copy otherwise, \nor to republish, requires a fee and/or specific permission. ACM-S lGPLAN-PLDl-6/93 /Albuquerque, N.M. \no 1993 ACM 0-89791 -598 -4/93 /0006 /0056 . ..$1 .50 Barbara G. Ryder Sean Zhang Department of Computer \nScience Rutgers University, New Brunswick, NJ 08903 rydertics. rutgers. edu xxzhsngOcs .rutgers. edu \n tools to solve these problems is directly dependent on the accuracy of the data flow information available \nto them. We need an eficient method to report program\u00ad point-specific data flow information for these \napplica\u00adtions. Existing techniques for FORTRAN cannot sup\u00adply this information; they only handle call-by-reference \ninduced aliasing and are insufficient for languages with general-purpose pointer usage. Interprocedural \nmodification side effects were first handled by Allen for acyclic call multigraphs [A1174, Spi71]. Later, \nBarth explored the use of relations to capture side effects in recursive programs [Bar78]. Banning [Ban79] \nfirst noted the decomposition of the problem for FORTRAN (and other languages where aliasing is imposed \nonly by call-by-reference parameter passing); he separated out two flow insensitive cal\u00adculations on \nthe call Multigraph: one for side effects and a separate one for aliases. Cooper and Kennedy [CO085, \nCK84, CK87] further decomposed the problem into side effects on global variables and side effects ac\u00adcomplished \nthrough parameter passing. Burke showed that these two subproblems on globals and formals can be solved \nby a similar problem decomposition [Bur90]. Chbi, Burke, and Carini mention a modification side effects \nalgorithm for languages with pointers based on 1we SaY~ inkewrocedm~ data flow problem is flow sen\u00adsitive \nif it requires propagation of information across calls and through paths in the procedures being called. \nAn interproce. dural problem is jfow insensitive if it can be solved solely by propagation on call graphs, \nusing summary information for each procedure[Ca188, Bur90]. their pointer aliasing calculation [CBC93]; \nit is diffi\u00adcult to compare our work to theirs, because they give no description of their algorithm. \nIn this paper, we present the first design and im\u00adplementation of an interprocedural modification side \neffects algorithm for languages with general-purpose pointers (e.g., C); this is the first such algorithm \nto use program-point-specific aliasing information. our algorithm reports program-point-specific possible \nmod\u00adification side effects (i.e., MOD); our results are more precise than information derivable using \nthe same alias summary for all statements of a procedure. Our algo\u00adrithm is based on an initial interprocedural \npass that computes a flow sensitive approximation of prograLm\u00adpoint-specific pointer-induced aliases \n[LR92]. These are used to gather procedure summary modification information, with 8ubsequent flow insensitive \npropags tion of modifications through the program call Multi\u00adgraph. Finally, call site modification information \nis cal\u00adculated using the results of the procedure side effects summary. We have implemented our MOD algorithm \nas a ba,ck\u00adend analysis on our pointer aliasing implementation [LR92]. Initial experiments have been \nrun with eleven of the programs which appeared in [LR92] and one more. Measurements of average and maximum \nnum\u00adber of side effects found per assignment through deref\u00aderence (i.e., *p=), per procedure and per \ncall site have been made, as well as calculations of analysis times and the relative extra cost imposed \nby using our conditional analysis technique [LR91, LR92]. Most importantly, our results over the twelve \npro\u00adgrams show that on average 1.2 locations are assigned values per assignment statement through a derefer\u00adenced \npointer variable (e.g., *p= ), indicating that often there is only one alias for such a variable at a \npro\u00adgram point. Also, on average, less than 8% of all the visible variables at each such assignment are \nassigned values; this result indicates that our pointer aliaaing is very precise, because we are not \noverestimating the effects of the assignments by reporting many spurious aliases. This paper is organized \nas follows. Section 2 dis\u00adcusses our pointer aliasing algorithm and presents our decomposition of the \nmodification side effects problem. Section 3 reports our empirical results in detail. Sec\u00adtion 4 summarizes \nthe contributions of this work. Ap\u00adpendix A presents a comparison of our MOD decompo\u00adsition for C to \nthat for FORTRAN. Appendix B gives an example of our analysis. 2 Flow Sensitive Interprocedural Analysis \n2.1 Realizable Interprocedural Paths. Iterative data flow analysis is a fixed point calculation for re\u00adcursive \nequations defined on a graph representing a program, that safely approximates the meet over all paths \nsolution [Hec77] for the graph. For interprocedu\u00adral data flow, not all paths in the obvious graph rep\u00adresentation \ncorrespond to real program executions. A realizable path is a path on which every procedure re\u00adturns \nto the call site which invoked it [LR92]. Paths on which a procedure does not return to the call site \nwhich invoked it, are unrealizable and can never happen in an actual execution2. A fundamental problem \nof interpro\u00adcedural analysis is how to restrict the propagation of data flow information to realizable \npaths. Jones and Muchnick[JM82] give a general approach for handling this problem. They associate with \neach data flow fact, an abstraction of the run-time stack on paths on which the fact is created. This \nabstraction, created by a call, is associated with data flow facts in the called procedure; it is used \nat procedure exit to determine to which call site(s), the data flow informa\u00adtion should be propagated. \nOur condiiiomzl aliasing approach [LR91, LR92] can be seen as an application of this idea. The data flow \nfact that z and y are aliased 2We do not allow setjump or longjump in programs analyzed. at program point \nnis represented by an unordered pair (x,y)atn. Ourencoding of therun-time stack is the set of reaching \naliases3 (RAs) that exists at entry of procedure p containing n when p is invoked. The RAs can be used \nto determine to which call sites, aliases at the exit of a called procedure should be propagated. In \n[LR92], we safely restricted the size of the reaching alias sets to one, yielding a compact and effective \nencoding of the run-time stack. Use of this encoding yields a pre\u00adcise solution for aliasing in the presence \nof one level of dereferencing; for multiple levels of dereferencing, this yields a safe approximate solution \nfor aliasing [LR9 I]. Choi et. al. use the last call site encountered as their encoding of the run-time \nstack in their flow sensitive aliasing algorithm [C BC93, CB]. They also describe an algorithm variant \nthat uses alias sets of unrestricted size, called source alias sets, aa its encoding. We are jointly \nstudying the precision and complexity effects of our two approaches and hope to compare algorithm performance \nin practice [MLR+93]. 2.2 Pointer-in duced Aliasing. Our MOD solu\u00ad tion procedure requires the results \nof our pointer alias\u00ad ing approximation algorithm. Therefore, in what fol\u00adlows, we give a brief overview \nof the algorithm, de\u00adscribed in detail in [LR92]. Intraprocedurally, aliases induced by a reaching alias \nat a procedure entry, are associated with that reach\u00ading alias. Aliases that are created regardless of \nany reaching aliases, could legitimately be associated with any reaching alias, but for practicality, \nwe only as\u00adsociate them with a special reaching alias, ~. We use Caiias(n, RA) to represent the set of \naliases at program point n under the condition that the alias RA reaches the entry of the procedure containing \nn [LR92]4. The intraprocedural propagation of aliases through pointer assignment statements is conceptually \n3Reaching aliases were referred to by the term assumed aliases in [LR92]. 4We used may-holds to represent \nconditional aliasing infor\u00admation in [LR92]. Culias(n, RA) = {PA I ma~-holds(n, RA, PA)}. similar to \nthe single level pointer aliasing algorithm in Chapter 10 of [ASU86] with extensions to handle mul\u00adtiple \nlevel pointers. Interprocedurally, a call to procedure Q, CU~zQ, cre\u00ad ates reaching aliases at the entry \nof Q. We use Reach(caliQ, RA) to denote the set of reaching aliases , induced by both the parameter bindings \nand the aliases associated with RA at the call (i.e., aliases in cdkJ(Cd?Q, RA)). The special reaching \nalias # and reaching aliases created solely by the parameter bindings are included in the set Reach(ca~~Q, \n~). At the exit of Q, aliases associated with reaching alias RA , are propagated to any call site CdlQ, \nwhere RA E Reach(caliQ, RA), and, thereafter are asso\u00adciated with RA in the procedure containing that \ncall site. The actual algorithm includes details of name space mappings between the calling and called \nproce\u00addures [LR92]; for brevity, we omit them here. 2.3 Decomposition of the MOD problem. We are solving \nfor modification side effects to fixed\u00adlocations at program points. Fixed-locations are ei\u00adther user-defined \nvariables or heap storage creation site names/field accesses. For example, in C syntax x and x.f are \ntied-locations whereas *p and p >f are not. We have named each dynamic allocation site, similar to [RM88]. \nEach dynamically allocated fixed-location is identified by the site that created it. Therefore, while \nwe cannot distinguish between two fied-locations cre\u00adst ed at the same site, we can distinguish those \ncre\u00adated at different sites. The side effects reported are differentiated by fixed-location type: global, \nlocal, dynamically-created, and non-visible (within that pro\u00adcedure). The non.visibles are local variables \nof other procedures or an earlier instantiation of the current procedure [LR92]. In solving for modification \nside effects, we decom\u00adpose the MOD problem into subproblems that are in\u00addividually easier to solve than \nthe monolithic prob\u00adlem. We first solve the conditional aliasing problem side effects which can occur, \ngiven a specific reaching alias condition at procedure entry, and (ii.) CMOD, a set of conditionally \nmodified locations at each pro\u00adgram point corresponding to a specific reaching alias. (i.e., AHAS). Given \nthe results of this alias analy\u00ad sis, we calculate the two related problems (i.) PM(2D, a procedure-level \nsummary of conditional modification CMOD solutions can then be used to derive MOD in\u00adformation for program \npoints, while PMOD solutions can be used to derive a procedure-level summary of modification side effects. \nOur decomposition of the MOD problem is pictured in Figure 1, where P is a procedure, RA is a reaching \nalias and n is a program point. ALIAS is our solution to the conditional aliasing problem. DIRMOD(n) \nis the left hand side of the assignment at program point n. At an assignment n, CondLMOD widens DIRMOD(n) \nto include the effects of aliasing. CondIMOD(P, HA) summarizes CondLMOD information for each reach\u00ading \nalias RA over all assignment statements in proce\u00addure P. PMOD for P is formed from local CondIMOD information \nand PMOD information propagated from procedures called by P, thus calculating both direct and indirect \nside effects of P. CMOD at a call site is constructed from PMOD of the called procedure, and at an assignment, \nfrom CondLMOD of that state\u00adment. Finally, MOD at a statement is constructed from CMOD by summarizing \nover all reaching aliases. A comparison of our MOD decomposition for C to that for FORTRAN is given in \nAppendix A. 2.4 Data Flow Equations. In these discussions, we make several assumptions: assignment is \nsynonymous with value-setting statemen$ Thus, scanf is considered an assign\u00adment.  all variable names \nare unique; This allows us to ignore the issue of name hiding which can easily be accommodated by appending \nvariable names with the function and file in which they are defined<  call-by-value parameter passing \nas in C is used; Call-by-reference parameter passing can be trans\u00adformed into call-by-value by adding \nan additional level of indirection[LRZ93].  MOD(n) MOD(P) CMOD(n, RA) ~/ PMOD(P, RA) I COW?IMOD(P, \n&#38;i) CondLMOD(n, RA) /\\ ALA4s DIRMOD(n) Figure 1: Decomposition of the MOD problem on bottom data \nflow information is computed (i.e., information at a statement incorporates the effects of that statement). \nour modification side effects sets are associated with our encoding of the run-time stack, reach\u00ading \naliases, to restrict our attention to realizable paths; however, our MOD algorithm is indepen\u00addent of \nthe choice of run-time stack abstraction. P~edecessom(n) represents the set of predecessors of n in the \nprogram, trivial, reflexive aliases (e.g., < *p,*p> ) are as\u00adsociated with the special reaching alias \n# at all programs points; This assumption simplifies the equation for CondLMOD. In the actual implemen\u00adtation, \nwe do not store these trivial aliases. DIRMOD(n) was defined above as visible, direct side effects at \na statement; therefore, it requires no data flow equation. CondLMOD(n,RA) is the set of fixed-locations \nmodified by the assignment at n be\u00adcause of aliases that occur at any of the predecessors of n when RA \nreaches the entry of the procedure con\u00adtaining n. CondLMOD is specified by equation (1) in Figure 2. \nIf DIRMOD(n) is a fixed-location, it is in CondLMOD(n,g5) because reflexive aliases are associ\u00adated with \nthe special reaching alias 4. For a procedure P and each reaching alias RA, CondIMOD(P,RA) contains the \nfixed-locations mod\u00adified by assignments in procedure P. CondIMOD(P, RA) = U CondLMOD(n, RA) n an assign\u00adment \nin P obj2 = DIRMOD (n) and CondLMOD(n, RA) = objl (objl, obj2) E Calias(pred, RA) (1) u pred E Predecessors \nand objl is a fixed-location {} PMOD(P, RA) = CondIMOD(P, RA) U (J @caHQ(pMoD(Q,RA ))) (2) dlQ in Pand \nRA E Reach(callQ, RA) CondLMOD(n, RA) if n is an assignment U b.(PMOD(Q, RA )) if n is a call of Q CMOD(n, \nRA) = (3) RA G Reach(n,RA) { otherwise Figure 2: Data Flow Equations for CondLMOD, PMOD and CMOD PMOD(P,RA) \nis the set of fixed-locations modified Both are obtained by considering all reaching aliases by procedure \nP, including the effects of calls from for P. within P, considering only aliases conditional on reach- \nMOD(n) = CMOD(n, RA) ing alias RA. The PMOD sets for a procedure summa-u reaching alias RA for P rize \nits modification side effects for a given reaching MOD(P) = PMOD (P, RA) alias. They are specified by \nequation (2) in Figure 2, u reaching aliaa RA for P which can be solved iteratively. In the equation, \nca~[Q is a call site in P at which P calls Q. Reach(caizQ, RA) In Appendix B, we show PMOD and CMOD solu\u00adrepresents \nthe set of reaching aliases at the entry of tions for an example program. Q induced by the parameter \nbindings at the call and 2.5 Precision and Safety. The precision and aliases in Cd~Us(ca/~Q, RA). The \nfunction bcallQ, sPe-safety of our MOD calculation depends upon the pre\u00ad cific to Cfd/Q, maps names from \nthe called procedure cision and safety of the underlying alias analysis. We (Q) to the calling procedure \n(P) according to scoping address the issue of safety in [LRZ93], and address the rules [CK87] and only \nreturns fixed-locations. Specif-issue of empirically measured precision in Section 3. ically, bcalrq \nfactors out all local variables of Q (in-2.6 Worst-case complexity. We give a detailed cluding formal \nparameters of Q), maps global fixed-analysis of the worst-case complexity of our MOD al\u00adlocations (global \nvariables and dynamic storage loca-gorithm in [LRZ93]. In brief, given the following defi\u00ad tions) to \nthemselves, and maps non-visibles in Q to nitions: their corresponding fixed-locations in P, which are \nei\u00ad lVaJia$ is the total number of conditional aliases in ther locals of P or non.visibles in P [LR92]. \nthe program. ~o~~ign is the number of assignments in the pro- With the PMOD solutions, the modification \nside ef\u00ad gram. fects for calls and assignments are specified by equa-. lVfjzed is the number of fixed-locations. \nNICFG is number of nodes in our representation of tion (3) in Figure 2. Finally, MOD(n) summarizes the \nprogram. This is roughly equivalent to number the effects over all executions of n in procedure P and \nof program points. MOD(P) summarizes the effects over all calls of P. Nproc is the number of procedures \nin the program. e Cunion is the cost Of the union operation over sets of fixed-locations [~(~fixed)]. \n Afc.lr is the maximum number of calls for any one procedure.  h!fPred is the maximum number of predecessors \nof any assignment.  it4RA is the maximum number of reaching aliases at the entry of any procedure. \n the worst-case time complexity for our MOD calcula\u00adtion is: ~... * M.a~t * MiA * N~ized+0(NNa8.+gn * \nMRA * Mpred * Cunion+ Nalia8 + NICFG * MRA * C.nio. ) As for most static analyses, the worst-case time \nhas little correlation with the observed behavior of the al\u00adgorithm in practice. In the next section, \nwe give some empirical timing results.  Empirical Results We have implemented our MOD decomposition \nand have empirical results for eleven of the programs ana\u00adlyzed in [LR92] plus compile~, a compiler for \na subset of Pascal. Our implementation is written in C and analyzes a reduced version of C that excludes: \nunion types, castings, pointers to functions, exception han\u00addling, setjump and longjump. The first two \nof these omissions are not theoretically difficult to handle, but complicate the implementation and must \nbe addressed before we can study a broader base of programs. We al\u00ad low arrays and pointer arithmetic; \nhowever, we simply treat arrays as aggregates. The programs we have analyzed and their sizes i~re in \nFigure 3. In this, and all subsequent figures, the programs are sorted by size in lines of code. We have \nseparated out the assignments that are through a deref\u00ad erence (t hru-deref), meaning the location assigned \nis determined by a pointer (e.g., the assignment *p = 5;). We have done this because these assignments \nhave non-trivial MOD solutions, whereas other assignments 5The only casting we handle is simple casting \nfor p = malloco. (e.g., i = O;) have trivial solutions. In Figure 3, we also present the time required \non a Sun Sparcstation 10 for the MOD calculation, the alias calculation, and a simple compile with no \noptimizations enabled. The reported MOD times do not include the alias times, so the total analysis time \nis the sum of these two columns. In all cases, the MOD times are less than that for a compile and, in \nmost cases, are orders of magnitude smaller than the alias times. The total analysis time for the smaller \nprograms is about the time of a com\u00adpile, but for larger programs it is not. These results are encouraging, \nbut we need to improve the efficiency of our alias analysis on larger programs. In Figure 4, we give \nsummary statistics for the MOD solution for t hru-deref assignment statements. These statistics are subdivided \nwith respect to the type of fixed-locations being modified. There are five types: glo: MOD information \nfor global variables. b dyn: MOD information for dynamic storage loca\u00adtions. 10C: MOD information for \nlocal variables of the enclosing procedure.  nv: (nonvisible) MOD information for local vari\u00adables of \nother procedures or of an earlier recur\u00adsive instantiation of the enclosing procedure. In our implementation \n[LR92], for efficiency we use one placeholder to represent all non-visible fixed\u00adlocations within a procedure. \n tot: MOD information for all fixed-locations.  We give three different summary statistics. Aver\u00ad age/assign \n(Maximum/assign) is the average (max\u00ad imum) number of fixed-locations modified by assign\u00ad ment statements. \nAverage percent /assign is more complicated. We define the number of fixed-locations potentially modified \nby an assignment as the sum OE number of globals in the program  number of dynamic allocation sites \n number of locals in the enclosing procedure  c number of locals of other procedures6accessible through \nglobals and formals at the entry of the enclosing procedure plus locals of earlier recursive instontiations \nof this procedure program lines of number of number of number of assigns MOD time aliaa time compile \ntime code procedures calls all thru-deref (see) (see) (see) allroots 188 8 20 96 33 0.01 0.23 0.79 diffh \n268 16 51 117 19 0.09 0.78 1.54 fixoutput 458 8 14 133 90 0.05 0.39 0.79 U1 541 19 73 262 42 0.20 2.70 \n1.29 lex315 776 19 104 179 54 0.18 1.05 1.29 pokerd 1130 28 87 384 104 0.32 13.87 2.59 loader 1539 33 \n86 330 119 0.38 15.13 2.75 cliff 1782 45 166 764 232 0.86 12.74 8.48 football 2354 61 265 1070 267 0.88 \n3.78 8.92 compiler 2360 40 363 373 72 0.82 1.38 4.17 assembler 3361 55 256 691 290 1.72 84.54 5.63 simulator \n4663 102 413 872 274 0.88 20.72 7.94 Figure 3: Program size and analysis time Average/assign Average \npercent/assign Maximum/assign program glo dyn Ioc nv tot glo dyn 10C nv tot glo dyn 10C nv tot allroots \n0.9 0.1 0.0 0.0 1.0 13% 9% o% o% 8% 1 1 1 0 1 difFh 0.7 0.2 0.2 0.0 1.1 4% 16% 3% o% 5% 1 1 1 0 2 fixoutput \n0.8 0.1 0.1 0.0 1.0 6% 4% 3% o% 5% 1 2 1 0 2 U1 0.6 0.0 0.4 0.0 1.0 2% o% 11% o% 2% 1 0 1 0 1 lex315 \n0.8 0.3 0.0 0.0 1.1 6% 9% o% o% 6% 1 2 1 0 2 pokerd 0.5 0.2 0.2 0.2 1.1 2% 1% 4% 8% 2% 1 3 1 3 3 loader \n0.6 0.2 0.0 0.5 1.4 3% 1% <1% 10% 3% 1 2 1 9 9 cliff 0.7 0.3 0.1 0.0 1.1 1% 1% 1% o% 1% 2 2 1 0 2 football \n1.0 0.0 0.0 0.0 1!0 1% o% <1% <1% 1% 3 0 1 1 3 compiler 1.0 0.0 0.0 0!0 1.0 2% o% 1% o% 2% 1 0 1 0 1 \nassembler 0.6 0.2 0.1 0.6 1.4 2% <1% <1% 11% 2% 2 1 2 9 9 simulator 0.6 0.2 0.0 0.6 1.4 2% 1% <1% 15% \n2% 1 2 1 13 13 Figure 4: MOD statistics for thru-deref assignment statements Then percent /assign is \nsimply the number of fixed\u00adlocations modified, divided by the number of poten\u00adtially modified locations \nof the appropriate type per assignment. The average percent /assign is the aver\u00adage of percent/assign \nover all assignments. For some assignments the number of possible locals and the num\u00adber of non.visibles \nare zero; in these cases, we use O% as the percent/assign. The results in Figure 4 are extremely encouraging. \nAny executable assignment in a normally terminating program will modify at least one fixed-location. \nThus, one is a lower bound of tot for average/assign. The values in totcolumn of average/assign are all \nclose to one with a maximum value of 1.4. This indicates that our algorithm is highly precise. In this \nSection 3.1, we present additional empirical evidence on the preci\u00adsion of our calculation. Average percent/assign \nin\u00addicates how much more precision is obtained from our MOD calculation in comparison to using -the worst-case \nassumption that all fixed-locations are modified, The tot column runs from l% to 8% indicating that our \nMOD calculation is yielding far more accuracy than the worst-case assumption and therefore is worth per\u00adforming. \nMaximum/assign is interesting, but cannot easily be used to justify the quality of our calculation. We \nhave investigated the high values in tot column of maximum/assign for loader, assembler, and simula\u00adtor \nby hand checking the solutions at the assignment that generated the maximum. Our algorithm found no spurious \nmodifications for these statements. Figure 5 and Figure 6 have the same structure as l ig\u00adures 4 and \nare also encouraging; however, it is harder to get a good lower bound on how many fixed-locations are \nmodified in these cases. We think the numbers re\u00adported are surprisingly small. In Figure 5, modified \nlocals of the called procedure are not counted in the totals for a call site as those locations do not \nexist be\u00adfore nor after the call. It seems likely that a procedure would modify all of its locals and \nthus you would ex\u00adpect average percent/procedure for Ioc to be 100% in Figure 6. We do not see this value \nbecause some pro\u00adcedures do not have any locals; these procedures intr\u00adoducea O% into the average calculation. \nThe high values in tot column of maximum/procedure in Figure 6 are expected because procedure main of \neach program will directly or indirectly modify every location in the program, except locals of other \nprocedures. 3.1 Empirically Measured Precision. We have empirically bounded the precision of our calculation \nin a similar manner as we did in [LR92]. There we explained the two sources of imprecision in the alias\u00ading \ncalculation: k-limiting, resulting from the necessity for approximation to handle a priori unboundable \ndy\u00adnamic data structures and control j?ow, resulting from safe assumptions about the actual execution \npaths with which aliases are associated. Our empirical measure\u00adments give a worst-case estimate of the \nlatter type of approximation; there is no viable way of measuring the former. All pointer aliasing algorithms \nmust use some k-limiting approximation. We associate with each fixed-location in the MOD solution either \nyes or maybe with the following inter\u00adpretation: MAYBE at MAYBE at MAYBE at program assigns calls procs \nallroots o% o% o% difi o% o% o% fixoutmlt o% o% o% U1 o% o% o% lex315 o% o% o% pokerd <1% 2% 2% loader \n<1% 2% 1% cliff <1% <1% 1% football o% o% o% compiler o% o% o% assembler 3% i 2% 3% simulator 3% 1 15% \n9% Figure 7: Percent maylws in the MOD solutions (a,yes) G MOD(X) implies that X definitely mod\u00ad ifies \na on some execution. (a,maybe) c MOD(X) implies that X mayor may not modify a, but for safety we assume \nX modifies a. The details of how to compute the MOD solutions with this added requirement are in [LRZ93]. \nWe give the percentage of maylm in our MOD solutions in Fig\u00adure 7. The percentage of fixed-locations \nspuriously re\u00adported as modified due to control-flow approximations for all assignments, calls, and procedures, \ncan be at most the percentage of maybes reported. Finally, we have empirical evidence that by associ\u00adating \nreaching aliases (RA) with CMOD and PMOD, we are not incurring much unnecessary work in our algorithm \n[L RZ93]. This would be possible, if some as\u00adsignment (or call or procedure) modifies the same fixed\u00adlocation \nunder many different reaching aliases. To solve the MOD problem, we are only interested in which fixed-locations \nare possibly modified, not in which con\u00additions lead to their possible modification. To verify that our \napproach does not involve duplicate effort, we computed the ratio of the CMOD and PMOD solution size \nto the MOD solution size. For the twelve programs in this paper, the maximum ratio is 1.04, which indi\u00adcates \nthat little redundant work is being performed. The ratios for these programs appear in [LRZ93]. Average/call \nAverage percent /call Maximum/call program glo dyll 10C nv tot glo dyn 10C nv tot glo dyn 10C nv tot \nallroots 0.9 0.2 0.0 0.0 1.2 14% 25% o% o% 11% 2 1 0 0 3 diflh 2.4 0.5 0.0 0.0 2.9 15% 47% o% o% 14% \n9 1 0 0 10 fixoutput 6.1 2.5 0.0 0.0 8.6 43% 83% o% o% 46% 10 3 0 0 13 U1 2.5 0.0 0.0 0.0 2.5 6% o% o% \no% 6% 31 0 0 0 31 lex315 3.4 1.7 0.0 0.0 5.1 22% 58% o% o% 28% 9 3 0 0 12 pokerd 1.6 0.6 0.2 0.0 2.4 \n5% 5% 2% o% 5% 23 13 1 0 36 loader 1.2 1.6 0.6 0.1 3.5 7% 8% 13% 4% 8% 11 19 3 1 30 cliff 2.3 1.3 0.0 \n0.0 3.6 3% 4% o% o% 3% 58 36 0 0 94 football 3.6 0.0 0.0 0.0 3.6 5% o% <1% o% 4% 67 0 1 0 67 compiler \n12.8 0.0 0.0 0.0 12.8 25% o% o% o% 24% 45 0 0 0 45 assembler 2.6 2.1 0.3 0.2 5.2 8% 9% 6% 5% 8% 24 24 \n5 5 48 simulator 1.7 0.4 0.2 0.1 2.4 5% 3% 7% 5% 4% 24 16 2 3 40 Figure 5: MOD statistics for procedure \ncalls Average/procedure Average percent/procedure Maximum/procedure program glo dyn 10C nv tot glo dyn \n10C nv tot glo dyn 10C nv tot allroots 2.2 0.6 2.8 0.0 5.6 32% 63% 75% o% 52% 7 1 6 0 8 diflh 3.6 0.5 \n1.8 0.0 5.9 23% 50% 50% o% 30% 16 1 7 0 17 fixoutput 7.0 2.4 0.8 0.0 10.2 50% 79% 25% o% 56% 14 3 4 0 \n17 U1 8.9 0.0 1.2 0.0 10.1 22% o% 42% o% 24% 40 0 5 0 40 lex315 4.6 1.7 1,5 0.0 7.9 31% 58% 26% o% 40% \n15 3 16 0 18 pokerd 4.7 2.3 3.2 0.4 10.6 15% 18 % 79% 38% 22% 31 13 12 3 44 loader 2.7 3.7 2.5 1.0 9.9 \n16% 20% 58% 74% 23% 17 19 18 9 48 cliff 7.1 4.5 3.0 0.0 14.5 10% 12% 76% o% 13% 71 36 11 0 107 football \n7.4 0.0 2.9 0.0 10.3 9% o% 69% 10% 12% 81 0 36 1 81 compiler 24.2 0.0 1.1 0.0 25.2 47% o% 63% o% 48% \n52 0 4 (1 52 assembler 6.3 5.6 2.7 1.6 16.3 19% 23% 69% 48% 25% 33 24 13 15 60 simulator 3.6 1.4 1.9 \n0.8 7.7 10% 9% 79% 81% 14% 36 16 7 24 52 Figure6: MODstatistics for procedures  Conclusions We have \npresented the design and implementation of a new interprocedural side effects algorithm for languages \nthat allow general-purpose pointer usage [e.g., C). Our algorithm is based on our condi\u00adtional analysis \napproach, that already has been used successfully in the approximation of pointer-induced aliases [LR92] \nand int erprocedural reaching definitions [PRL91, PLR92]. Preliminary results from our pro\u00adtotype implementation \nindicate that our algorithm is practical, efficient and quite accurate. Future work in\u00adcludes broadening \nthe class of C programs handled by our prototype, making our algorithms incremental, and scaling up to \nhandle large C systems. Acknowledgments We thank our colleagues at Siemens Corporate Research for their \nhelp with the front end, pit. We also thank Don Smith and the ref\u00aderees for insightful comments on this \npaper. References [Al174] F. E. Allen. Interprocedural data flow analysis. Proceedings of 1974 IFIP \nCongress, pages 398 402, Amsterdam, Holland, 1974. Institute of Electrical and Electronics Engineers, \nInc., North Holland Pub. Iishing Company. In [ASU86] A. V. Aho, Principles, 1986. R. Sethi, Techniques, \nand J. and D. Unman. Compilers: Tools. Addison-Wesley, [Ban79] J. Bannin g. An procedm-e calls ference \nRecord efficient way to find the side effects and the aliases of variables. In Con. of the Sixth Annual \nA CM Symposium of [Ban88] [Bar78] [BC86] [Bur90] [Cdaa] [CB] [CBC93] [CK84] [CK87] [CO085] [Hec77] [HRB88] \n[JM82] [LR91] [LR92] on Principles of Programming Languages, pages 29 41, January 1979. Utpal Banerjee. \nDependence Analysis for Supercom. putkg. Kluwer Academic Publishers, Norwell, MA, 1988. J. M. Barth. \nA practical interprocedural data fiow analysis aIgorithm. Communications of the A C M, 21(9):724 736, \n1978. M. Burke and R. Cytron. Interprocedural depen\u00addence analysis and parallelization. In Proceedings \nof the ACM SIGPLAN Symposium on Compiler Con\u00adstruction, pages 162 175, June 1986. SIGPLAN No\u00adtices, Vol \n21, No 6. M. Burke. An interval-based approach to exhaustive and increment al int erproceduml data flow \nanalysis. ACM Transactions on Programming Languages and Systems, 12(3):341-395, July 1990. D. Callahan. \nThe programs mnrnary graph and flow\u00adsensitive int erprocedural data flow analysis. In Pro\u00adceedings of \nthe SIGPLAN 788 Conference on F ro\u00adgramming Language Design and Implementation, pages 47 56, June 1988. \nJong-Deok Choi and Michael Burke. personal COD munication. Jong-Deok Choi, Michael Burke, and Paul Carini. \nEfficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. In \nCon. ference Record of the Twentieth Annual A CM Sym. posium on Principles of Programming Languages, \npages 232 245, January 1993. K. Cooper and K. Kennedy. Efficient computation of flow insensitive int \nerprocedurzl summary informa\u00adtion. In Proceedings of the ACM SIGPLAN Sym\u00adposium on Compiler Construction, \npages 247 258, June 1984. SIGPLAN Notices, Vol 19, No 6. K. Cooper and K. Kennedy. Complexity of interpro\u00adcednral \nside-effect analysis. Computer Science De\u00adpartment Technical Report TR87-61, Rice Univer. sity, October \n1987. K. Cooper. Analyzing aliases of reference formal parametem. In Conference Record of the Twelfth \nAnnual ACM Symposium on Principles of Program\u00adming Languages, pages 281 290, January 1985, M. S. He&#38;t. \nFlow Analysis of Computer Programs. Elsevier North-Holland, 1977. Susan Horwitz, Thomas Reps, and David \nBinlkley. InterProcedural slicing using dependence graphs. In Proceedings of the SIGPLAN 88 Conference \non Pro\u00adgramming Language Design and Implementation, pages 35 46, June 1988. N. D. Jones and S. S. Muchnick. \nA flexible approach to interprocedural data flow analysis aud programs with recursive data structures. \nIn Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, pages \n66 74, January 1982. W. Landi and B. G. Ryder. Pointer-induced aliasing: A problem classification. In \nConference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, pages \n93 lo3, January 1991. W. Landi and B. G. Ryder. A szfe approximation al\u00adgorithm for interprocedumd pointer \naliasing. In Pro\u00adceedings of the SIGPLAN 9.8 Conference on Pro\u00adgramming Language Design and Implementation, \npages 235 248, June 1992. [LRZ93] W. Landi, B. G. Ryder, and S. Zhrmg. Interproce\u00addural modification \nside effect analysis with pointer aliasing. Technical Report LCSRTR201, Labor&#38; tory for Computer \nScience Research Technical Re. port, March 1993. This report supersedes LCSR TR195 and is an expansion \nof our ACM SIGPLAN PLDI 93 paper. [MLR+93] Thomas J. Marlowe, William Landi, Barbara G. Ryder, Jong-Deok \nChoi, Michael Burke, and Paul Carini. A cost-precision comparison of two flow sen\u00adsitive int erprocedural \nalgorithms for pointer-induced aliasing. Technical report, Laboratory for Computer Science Research Technical \nReport, March 1993. in preparation. [0084] K. J. Ottenstein and L. M. Ottenstein. The pro\u00adgram dependence \ngraph in a software development environment. In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering \nSymposium on Practical Software Development Environments, pages 177 184, May 1984. [OW91] T. J. Ostrand \nand E. Weyuker. Data flow based test adequecy analysis for languages with pointers. In Proceedings of \nthe 1991 Symposium on Software Testing, Analysis and Verification (TAV4), October 1991. Victoria, B. \nC., Canada. [PLR92] H. D. Pande, W. Landi, and B. G. Ryder. InterPro. cednral defuse associations in \nthe presence of single level pointers. Laboratory for Computer Science Re. search Technical Report LCSIVTR-193, \nDepartment of Computer Science, Rutgers University, 1992. be. ing revised for journal publication. [PRL91] \nH. Pande, B. G. Ryder, and W. Landi. InterPro. cedural clef-use associations for C programs. In Pro\u00adceedings \nof the ACM SIGSOFT Conference on Test\u00ading, Analysis and Validation, pages 139-153, Octo\u00adber 1991. [RM88] \nC. Ruggieri and T. Murtagh. Lifetime analysis of dy\u00adnamically allocated objects. In Conference Record \nof the Fifteenth Annual ACM Symposium on Principles of Programming Languages, pages 285 293, January \n1988. [RW82] S. Ftapps and E. Weyuker. Data flow analysis tech\u00adniques for program test data selection. \nIn Proceedings of the Sixth International Conference on Software Engineering, pages 272 278, September \n1982. [Ryd89] B. G. Ryder. Ismnx Incremental software mainte\u00adnance manager. In Proceedings of the IEEE \nCom\u00adputer Society Conference on Software Maintenance, pages 142 164, October 1989. [Spi71] T. Spilhnan. \nExposing side effects in a PL-I optimiz. ing compiler. In Proceedings of IFIPS Conference, pages TA 3 \n56:TA 3-62, 1971. [Ven91] G. A. Venkatesh. The semantic approach to pro\u00adgram slicing. In Proceedings \nof the SIGPLAN 9 I Conference on Programming Language Design and Implementation, pages 107-119, June \n1991. [Wei84] Mark Weiser. Program slicing. IEEE Transac. tiom on Softwmc Engineering, SE-10(4) :352 \n357, Jtiy 1984. [W0189] Michael Wolfe. Optimizing Supercompilers for Su. percomputers. The MIT Press, \nCambridge, MA, 1989. MOD Decomposition MOD Decomposition for C for FORTRAN[CK87] n is either an assignment \nor a call. s is a statement. P is a procedure. P is a procedure. RA is a reaching ahs. LMOD(S) ., CondLiUOD(n, \nRA) the set of variables modified by an n is an assignment. execution of s, excludlng any the set of \nfixed-locations modified by an execution of procedure calls in s n considering abases that are associated \nwith RA and hold on entry n. IMOD(P) CondIMOD(P, RA) the set of variables modified by an the set of fixed-locations \nmodified by an invocation of invocation of P, excluding any P, considering only assignments in P and \naliases procedure calls in P associated wi;h RA in P IMOD+(P) Cond.IMOD+(P, RA)(see[LRZ93]) the set of \nvariables either modified the set of fixed-locations either modified dhectly in directly in P or modified \nas reference P or modified as non.visibles in procedures called by P, formals in procedures called in \nP considering only aliases associated with RA in P GMOD(P) PMOD (P, RA) the set of variables modified \nby an the set of fixed-locations modified by an invocation of invocation of P, includlng procedure P, \nconsidering both assignments and procedure calls in P, calls in P and ignoring any fllases in P and aliases \nassociated with RA in P DMOD(S) C MOD (n, RA) the set of variables modified by an n is either an assignment \nor a call. execution of s, includlng procedure the set of fixed-locations modified by an execution of \ncalls in s and ignoring any aEases n, considering aliases that are associated with RA in the procedure \ncontaining s and hold on ;ntrv n. and Darameter bindinm if n is a call MOD(s) MOD(n) the set of variables \nmodified by an n is either an assignment or a call. an execution of s, considering all the set of fixed-locations \nmodified by an execution of fllases in the procedure containing s n, considering all possible alhses \ntrue on entry n in the procedure containing n Figure 8: Comparison of MOD decompositions for FORTRAN \nand C A Comparison with the MOD Decomposition for FORTRAN Our decomposition of the MOD problem for C \nis similar in structure to the original decomposition for FORTRAN by Banning [Ban79], in the sense that \nboth calculate local side effects in each procedure first, and then set up data flow equations on call \ngraphs to com\u00adput e procedure-level side effects (i.e., a flow insensitive interprocedural calculation). \nThe two decompositions are also similar in what is included in the MOD sets. In FORTRAN programs, variables \nare the only fixed-locations and therefore var\u00adious MOD sets in the decomposition for FORTRAN include \njust variable names. In C, pointer variables and dynamic allocation are allowed. Although simple variable \nnames (e.g., p) still represent fixed-locations, names with dereferences (e.g., *p) can potentially de\u00adnote \ndifferent locations during execution and thus are not considered fixed-locations. lVe handle dynamic \nal\u00adlocations by naming each site so that dynamically allo\u00adcated locations are identified by the sites \ncreating them. The MOD sets in our decomposition include variable names and names for dynamic allocation \nsites. The two decompositions differ in their treatment of aliases. In the FORTRAN decomposition, aliases \nare computed at procedure calls. This is possible because for FORTRAN programs, only procedure calls \ncan cre\u00adate aliases and aliases created by a call hold throughout execution of the procedure being called. \nIn our MOD decomposition for C, aliases are computed at pointer assignments and procedure calls, because \naliases vary intraprocedurally. An alias at a program point is asso\u00adciated with a reaching alias for \nthe procedure contain\u00ading that program point. These reaching aliases differ\u00adentiate side effects caused \nby different calls of the same procedure. In Figure 8, we compare various MOD sets defined in our MOD \ndecomposition for C and those in the de\u00ad composition for FORTRAN as presented in [C K87].  B An Example \nWe show the results of our analysis for the example Int x,y,k; R(b) int b; { if (*b) { b= &#38;k; b=s \no;} b++; } maino { R(&#38;x); R(&#38;y); } Figure 9: An example program and its ICFG Alias Solutions \nfor R : : s: e > Reaching Alias PMOD Solutions for R Reaching Alias PMOD Solutions for main {k, b} 4 \n4 {x, k,y} <*b,x> {x} <*b,y> II {Y} J Reaching CMOD Solutions for R Reaching CMOD Solutions for main \nAlias nT ns ng nlo nll nlz Alias nl nz ns nd ns n6 1 {b} {k} {k} # 4 {x, } {y, } <*b,x> {x} 1 <*b,y> \nIII I I{yjl 1 Figure 10: Aliases, PMOD and CMOD solutions for the example program program in Figure 9. \nThe program is represented in an intermediate form called ICFG [L R92]. Both main and R are analyzed \nwith reaching alias ~ at their entries. The first call to R makes the alias <*b,x> reach the entry of \nR. The second call to R creates the alias <*b, y> at the entry. R is analyzed for each of these aliases. \nThere are no aliases in main, The alias solution for R is shown in Figure 10. The PMOD and CMOD solutions \ncomputed according to our decomposition are also shown in the same figure. Empty entries in these tables \nmean either no alias or no side effect.  \n\t\t\t", "proc_id": "155090", "abstract": "<p>We present a new interprocedural modification side effects algorithm for C programs, that can discern side effects through general-purpose pointer usage. Ours is the first complete design and implementation of such an algorithm. Preliminary performance findings support the practicality of the technique, which is based on our previous approximation algorithm for pointer aliases [LR92]. Each indirect store through a pointer variable is found, on average, to correspond to a store into 1.2 locations. This indicates that our program-point-specific pointer aliasing information is quite precise when used to determine the effects of these stores.</p>", "authors": [{"name": "William Landi", "author_profile_id": "81452618010", "affiliation": "", "person_id": "PP31085958", "email_address": "", "orcid_id": ""}, {"name": "Barbara G. Ryder", "author_profile_id": "81100632248", "affiliation": "", "person_id": "PP14217204", "email_address": "", "orcid_id": ""}, {"name": "Sean Zhang", "author_profile_id": "81332537677", "affiliation": "", "person_id": "PP31101379", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/155090.155096", "year": "1993", "article_id": "155096", "conference": "PLDI", "title": "Interprocedural modification side effect analysis with pointer aliasing", "url": "http://dl.acm.org/citation.cfm?id=155096"}