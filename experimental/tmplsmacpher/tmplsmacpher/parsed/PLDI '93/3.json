{"article_publication_date": "06-01-1993", "fulltext": "\n Efficient Accommodation of May-Alias Information in SSA Form Ron Cytron* Washington University St. Louis, \nMissouri 63130 Abstract We present an algorithm for incrementally including may-alias information into \nStatic Single Assignment form by computing a sequence of increasingly precise (and correspondingly larger) \npartial SSA forms. Our experiments show significant speedup of our method over exhaustive use of may-alias \ninformation, as op\u00adtimization problems converge well before most may\u00adatiaaes are needed. 1 Introduction \nConsider the source program and its Static Single Assign\u00adment form (SSA) representation [CFR+91] shown \nin Fig\u00adure 1. The storage referenced by a program P is logically partitioned into disjoint storage names, \nwhich correspond approximately to the variable names in P. The store and load instructions of P are statically \nlabeled as distinct def and use sites, respectively. For example, step I contributes one use (of the \npointer p) and one def (of location *p). In SSA form, the storage names for P are augmented so that the \nsame storage name never appears twice amen the def sites. For example, the clefs of u at step I and 3 \nare renamed to U1 at step I and U2 at I, which are regarded as distinct storage names. A @-function represents \nthe merge of distinct names, and the value returned by the ~-function is itself retained as a distinct \nname. For example, step I combines the aforementioned renames of u. As a result, each use can be associated \n(renamed to correspond with a unique d clef. The u of step I is renamed to U3 at II Moreover, any potential \nmodification of a storage name v is represented explicitly in SSA form. Where uncertainty exists concerning \na dereferenced pointer p s effect on w at step S, we write d s *p-v and say that *P may alias v at S. \nGenerally, we define the set May Alias(p, S) to contain those names potentially aliased with *p at S. \nFor example, if the pointer p contains the address of v at step I, then the value of v is changed as \nof that step; otherwise the value of v is unchanged. The IsAliaso function is inserted into a program \nP to represent this duahty. The predicate at step ~ determines if the alias *Currently on leave from \nIBM T.J. Watson Research Labs; e-mail: cytron@cs.wustl. edu. tThis work w~ supported by the National \nScience Foundation, Grant CDA-9123643; e-mail: gershbei@cs.oberlin. edu Permission to copy without fee \nall or part of this material is granted provided that the copies are not made or distributed for direct \ncommercial advantage, the ACM copyright notice and the title of the publication and its date appear, \nand notice is given that copying is by permission of the Association for Computing Machinery. To copy \notherwise, or to republish, requires a fee end/or specific permission. ACM-S lGPLAN-PLDl-6/93 /Albuquerque, \nN.M. e 1993 ACM 0-89791 -598 -4/931000610036 . ..$1 .50 Reid Gershbeint Oberlin College Oberlin, Ohio \n44074 Source Program Full SSA Representation 71+3 V( )+3 if (b) then if (b) then U+-?j e.~ U1 + r@ em \nelse else Function IsAlias(w, c) : value if(w=z)then e 12 El W-WI +-*UJ -+= 13 I else ansz+-*x -=Iml \ntl anss+-ansz) I fj(ansl, return (anss) Figure 1. Example. holds, and be returned. steps ~ and ~ cause \nthe appropriate value to then If storing we write th rough a pointer c ertainly modifies v at S, s *p%v \nand say that *p must alias v at S. Correspondingly, we define the set MwstA/ias(p, S) to contain those \nnames certainly aliased with *P at S. If v 6 MustAlzas(p, ~), then step I should be replaced by the assignment \nv * * p . If v is unaffected by step 6, then no assignment to v would be necessary at step 7. + Transformation \nof source programs into Static Single Assignment (SSA) form [CFR+91] results in more efficient and effective \nprogram optimization [WZ91, AWZ88]. !3 ith\u00adout SSA form, each program optimization would require special-case \ntreatment of constructs that yield implicit stor\u00adage references. The results of applying constant propagation \nbased on SSA form [WZ91] to our example are dependent on the program s 55A form, which is in turn dependent \non the alias information associated with storage assignments. With 1 representing non-constant , the \nfollowing table illustrates the effects of alias information at step I on subsequent uses of v: Alias \nInfo at~ Useofwat ~ Useofvat~ +-v 1L *pEv 6 J\u00ad 1 Otherwise 3 3 J While SSA offers a unified treatment \nof all storage references, the introduction of IsAliaso assignments can expand the program representation \nsize by a factor of [V 1, where worst-case may-aliasing conditions prevail on a set of variables V. The \nuse of languages whose alias behavior is sufficiently restricted [Bod90] can lessen the impact of explicit \nalias representation, as can recent advances in obtaining high-quality may-alias information [Lan92, \nLR92, CBC93]. However, the number of aliased expressions per node can grow quite large: the make. c program \nserves as a worst-case in [Lan92], with 675 may-alias relations per node on average, and one node containing \nsome 2000 relations. Research is underway to determine how relations translate into effects on storage \nnames [Lan93], but currently the impact of so many alias relations on SSA form cannot be quantified. \nOur experiments show that the amount of alias in\u00adformation represented in SSA form can far exceed the \namount of such information necessary for solving a given optimization problem: our algorithm typically \nstops well short of computing full SSA form, without compromising the effectiveness of program optimization \nwhile dramatically improving its efficiency. An earlier method for accom\u00admodating ahas information in \nSSA form [CWZ90] giiins efficiency by directly propagating information to affected program sites. Our \napproach is complementary, since we avoid incorporating the bulk of may-tilas information; an actual \noptimization problem motivates and terminates the search for aEas information. In the following sections \nwe outline our approach (!3ec\u00adtion 2), present our algorithm (Section 3) and correctness proofs (Section \n4), and describe the results of our experi\u00adments (Section 5). Approach Essentially, our method constructs \na sequence of approxi\u00admating, partial SSA forms of increasingly sharper precision and correspondingly \nlarger size: SSAO, SSA1, . . . . SSAn, SSA~+l, . . . SSAcc The limit of this sequence, SSA~, is full \nSSA form. Suppose an optimization based on SSA form were applied to each element of this sequence. We \ndefine the corresponding solution sequence as SolnO, Solnl, ..., Solnn, Solnn+l,.. Solrk Since the explicit \nrepresentation of may-alias informa\u00adtion is primarily responsible for size excesses in SSA form, we carefully \ntitrate may-alias information into our sequence of SSA forms. However, must-alias information is introduced \ninitially (into SSAO ) for the following reasons: Although they supply very strong information, must\u00adaliases \nof pointer dereferences are all too rare in pro\u00adgrams. We expect relatively little growth in program \nsize for representing such information.  As discussed in Section 3.1, incremental update of the optimization \nsolution between partial SSA forms is easily accomplished if the optimization solution in SSAt+l cannot \nbe better (in the sense of the data flOW  lattice) than the solution for SSA,. This requirement precludes \narbitrary injection of must-alias information into our sequence. Partial form SSAO therefore contains \nall must-alias informa\u00adtion, but no information due to may aliases, while SSAX contains all such information. \nWe define SSAn as the earliest element of the partial SSA form sequence whose precision suffices for \nsolving the optimization problem: Q = min (Soln, = Solnm ) 1 We say that, with respect to a given data \nflow solution obtained using SSA form, convergence is reached at approx\u00adimation SSAn. A diagram of our \napproach is shown in Figure 2. Because we expect SSAQ to be much smaller than Figure 2. Diagram of our \napproach. SS A~, we expect a corresponding reduction in the time taken for program optimization. The \nabove diagram raises the following questions, which we answer in the ensuing sections of this paper: \n1.Must the solution for constant propagation be com\u00ad puted from scratch , as we move from SSA, to SSA,+l? \n 2. Must SSA,+l be generated from scrat cl] ? 3. When is SSAn achieved? 4. Which may-alias information \nshould be included in moving from SSA, to SSA;+l? 5. How efficient is our incremental approach compared \nto solving the optimization problem using SSA~ ?  We assume that a program P is represented by the \nfollowing structures: Flow graph: The nodes of this directed graph represent executable text and the \nedges represent potential trans\u00adfer of control between the nodes. Operations within a node are assumed \nto be totally ordered, particularly those that reference storage. Storage names: Storage for P is partitioned \ninto a set of static sto~age names. Where the structure of dynam\u00adically allocated objects cannot be analyzed \nat greater precision [LH88, CWZ90, HN90], a single name (such as heap ) suffices to represent all such \nobjects. References: Each reference (re/) T represents a store ( de~) or load (use) instruction of F \n. To simplify the dis\u00adcussion, we assume that all references to storage are through a primary or dereferenced \nidentifier (such as v or *p); temporary names can be inserted into the source program to support this \nassumption. We extend our earlier notation for aliases by allowing May A2zas(r) and MwtAIzas(T) to represent \nthe sets of symbols may-and must-fllased for reference r, respectively. The following notation is also \nuseful: DefSztes is the set of all def sites in P. Symbol(r) represents the textual string associated \nwith reference ~. As discussed above, such strings are limited to primary and dereferenced identifiers. \nllde~(u) is the unique def of Symbol(u) for use u in SSA form, where Symbol(u) is a primary (non\u00addereferenced) \nidentifier; for a use u of a derefer\u00adenced identifier, Symbol(u) = 1. In moving from one partial SSA \nform to another, Rdet(u) may change for any given use u. Lde~(u) is the def appearing as the target of \nan assignment statement involving u. Essentially, the def .Ldej(u) is dependent on the value of u. 1(u) \nis the number z of the SSA form in which u is introduced, O < i ~ 0. Node(r) is the flow graph node containing \nr. FirstDef(X) is the first def site in node X. Our algorithm assumes that each node begins with a def \nsite; if node X otherwise lacks an initial def site, then an empty def site d (Symbol(d) = 1) can be \ninserted at the beginning of node X with empty may-and must-alias sets. LastDef(X) is the last def site \nin node X. DornDef(r) is the def site that immediately dominates reference r. Note that r may be a def \nsite or use site, and Symbol(r) may be a different symbol than Syrnbol(DornDe f (r)). Within a node, \nDornDef(r) is simply the def site that occurs just prior to reference r among the references in Node(r). \nWhere none exists within Node(r), then node idom(Node(~)) is consulted, where idorn(X) is the node immediately \ndominat\u00ading X in the flow graph [LT79]. Since each node is assumed to have at least one def site, DomDef(r) \nis well-defined. Aliases: As discussed above, two lists of storage names are associated with each reference \nr, representing May Alias(r) and MustAlias(r). Because we ex\u00adpect MustAlias(r) to be a rather small set, \nthese symbols can be elaborated directly at the reference without compromising the asymptotic behavior \nof our approach. On the other hand, worst-case assumptions for May Alias(r) result in relatively large \n(O(\\Vl )) sets, which if stored directly at each reference, would cause the program representation to \nsuffer the 0( IVI ) growth that we seek to avoid. Since we don t expect the May Aliaso sets to change \ndrastically from reference to reference, we construct a global set of may-alias re\u00adlations, where each \nrelation is a subset of the program s storage names. We then encode May Alias(r) as the the name (i.e., \nindex) of the appropriate subset of storage names. @functions: SSA form introduces a @-function for variable \nv at node Z if multiple definitions of v reach Z. If Z has k predecessors, Yl, YQ,. . . . Y~, then the \n@-function is of the form VZ=O(VY1, VY2, . . .. VYL) where WY, represents the name for v transmitted \nby node Y,. The above O-function introduces one def and k uses of w into the program representation. \nIn the traditional SSA representation [CFR+91], each use of v in the q5-function is associated with node \nZ, where the ~-function textually appears. In a departure convenient for our algorithm, we instead associate \neach use VY, with node Y,. While the ~-function appears at node Z, its uses (arguments) are actually \nassociated with the predecessors of Z. For example, in Figure 1, the uses vo and VI appearing in the \n~-function at statement 10 are actually associated with (the end of) statements 0 5 and I, respectively. \nThroughout this paper, we assume that programs are com\u00adprised of a single procedure, and we concentrate \nprimarily on the effects of may-alias information on the quality and speed of program optimization. The \neffects of procedure calls on storage names, while outside the scope of this paper, can be treated analogously. \nOur algorithm as presented does not attempt to discover constants for any use u for which Symbol(u) = \n1; in our setting, such uses correspond to the storage associated with a dereferenced pointer (but not \nthe pointer itself). Although our approach is easily generalized to handle such cases, we concentrate \ninstead on the impact of may-alias information on constant propagation for readily identified uses those \nfor which constant propagation has traditionally been successful. 3 Algorithm In this section, we describe \nhow to incrementalize an SSA-based optimization problem to accommodate IsAIzaso functions missin~ from \nSSA, but present in SSA, +l. We then describe how to compute SSA,+l from SSA, by including relevant may-alias \ninformation. The algorithm is shown in Figure 3. The main proce\u00addure contains the interaction of constant \npropagation with the computed sequence of partial SSA forms. The incre\u00admentalized constant propagator \n(described in Section 3.1) is invoked on: Form, which represents the current partial SSA form, and DList, \nwhich represents those definition sites that have changed since the previous invocation of IncCPropo. \nand returns: Soln, which contains the constant value attributed to each definition site (where L represents \nnon-constant), and UList, which contains a list of suspicious uses: incorpora\u00adtion of additional may-alias \ninformation could adversely affect their solution. The following properties, formally proven in Section \n4, are essential to our algorithm s performance: 1. For each use u c ULzst, Updateo discovers the defini\u00adtion \nd that would reach u in SSAX if such information is necessary for convergence of constant propagation. \n 2. When IncCPropo returns an empty UList, constmlt, propagation convergence has been achieved. 3.1 \nIncrementalizing the Optimization A generally incremental constant propagation algorithm must address \narbitrary modifications of a program, including those that substantially alter program flow or the contents \n of the associated flow graph s nodes. We shall see that the changes introduced by step ~ are of three \nrestrictive forms: Algorithm[l] Constant Propagation Function Update(Form, SuspiciousUses) : [ Form, \nDLtst ] foreach (d G DefSites) do DList i-\u00ad1 Visited(d) +- O Od foreach u G SuspiciousUses do VisitStamp \n-0 I Ldef(ti) # 1 or 1(u) = O Form DList +-SSAO(Prog) + De fSites em if (3 (d Symbol(u) E May Alias(d)) \n)t en [ Soln, UList ] + IncCProp(Form, DLzst) + ~~ Snoop ( DomDef(u), while (UList # 0) do VisitStamp \n--VisitStamp + 1 [Form, DList ] +--Update(Form, UList) -+=~g * ~~ NewDef + Rdef(u), Rdef(u) ) [ Soln, \nUList ] +- IncCProp ( Form, DList e Qq if (NewDef Rdef(u) # -L) then + NewDef ) ti fi od od end end \nFunction Snoop(StartDef, StopDef, Rdef) : Def In the following, r represents any super\u00adscripted reference. \nd + StartDef while (d # StopDef) do CreateIsAlias(d, Rdef ): inserts the Visited(d) +--VisitStamp statement \nif (Symbol(d) = Symbol(Rdef)) then DList +-DList U{d} dl = IsAlias(ul, U2) return (d) after def d, with \nfi if (Symbol(Rdef) 6 May Alias(d)) then Symbol(d ) = Symbol(Rdef ) NewDef -CreateIsAlias(d, Rdef) Symbol(u \n) = Symbol(d)DList -DList U { NewDef } return (NewDef) Symbol(u2) = Symbol(Rdef) fi Rdef(ul) = d if \n(d = FirstRef(node(d))) then Rdef(u2) = Rdef IDef +-1 DomDef(r) = d, T # U2 foreach (m 6 Preds(node(d))) \ndo if (Visited(LastRef (m)) # VisitStamp) then DomDef (u2) = DomDef(d) Node(r) = Node(d) Snoop ( LastRef(m), \nLastRef(idom(node( d))), CreatePhi(d, Rdef, m, IDef): inserts IDef -\u00adthe statementRdef ) dl=@(ul,. ... \nuk) fi at the beginning of node Node(d) if (IDef # 1) then with indegree k, setting NewDef * CreatePhz(d, \nRdef, m, .lDef ) DList +-DList U { NewDef } DomDef(d) = d return (NewDef) Symbol(r) = Symbol(Rdef) ti \nNode(dl) = Node(d) od ti Node(u ) = Pred i of Node(d) d +--DomDef(d) DomDef (u ) = LastDef (Node(u ))od \nreturn (J_) Rdef i# m end Rdef(u ) = IDef i= m{ Figure 3. Algorithm. 1. When v E MayAlias(d) is accommodated \nat step ~, a statement of the form v = IsAlias(Syrnbol( d), v) is inserted into Node(d) by step ~. 2. \nInsertion of a definition for v at node X may introduce a ~-function for v at node Z, where X dominates \nsome predecessor Y% of Z, but X doesn t strictly dominate Z. If Z has k predecessors, then a statement \nof the form v=q5(vl, w2, . . . Ivk) is inserted at the beginning of node Z by step ~. 1 As discussed \nearlier, each use v is actually associated with predecessor Y, of Z. 3. The SSA name associated with \na use u. maintained as Rdei(u), changes at step ~ because of a def inserted by either of the above modifications. \nThe above modifications occur in response to accommoda\u00adtion of may-alias information. We prove in Section \n4 that such modifications cannot better the data flow solution for any variable at any node. Thus, an \nincremental con\u00adstant propagator can assimilate the definitions provided by step ~ without restarting \nany of its computations. In summary, an SSA-based constant propagator [WZ91] is incrementalized by: Exposing \nits definition worklist: Step ~ provides the initial set of definitions, and a new list is developed \neach time step ~ executes; Flagging its suspicious uses: Any use u can be returned to Updateo as suspicious, \nin which case Updateo will invoke Snoopo to incorporate relevant may-alias information. The correctness \nand termination conditions for our al\u00adgorithm place the following demands on the incrementalized constant \npropagator: 1. Any use u whose constant propagation solution is non\u00ad1 must be marked suspicious during \nsome round of constant propagation. Our algorithm then investigates may-aliases if u is an original use \n(1(u) = O) or if u participates in an IsAliaso or @ function whose target is non-l. 2. A use u is flamzed \nsuspicious at most once. By  .\u00admaintaining a single bit with each use, the constant propagator can remember \nwhether it has ever flagged a given use as suspicious, and avoid repeatedly placing the same use on UList. \n3.2 Update and Snoop The Updateo procedure shown in Figure 3 considers each suspicious use u at step \n~, and finds (through Snoopo) the definition of Symbol(u associated with u in SSAX. However, the predicate \nat 20 eliminates pursuit of may\u00adalias information for uses at IsAlzaso or O functions, where the target \nof the function has already been determined to be 1. For other uses where a suitable definition is found, \nstep ~ appropriately modifies Rdef(u). b lWe use superscripts to represent the t-th argument of the @function, \nas subscripts might connote a name for the z-th argument. Though absent from our initial implementation, \nwe soon discovered the value of step ~, which determines if any may-aliases are associated with Symbol(u). \nThis step precludes from consideration those uses whose reaching definition in SSA~ was correctly determined \nin SSAO. The formidable predicate at step ~ is easily established by maintaining a single bit with each \nstorage name, indicating whether the symbol is mentioned in any of the program s may-alias relations. \nIn any partial SSA form, Rdej(u) contains the defini\u00adtion of Symbol(u) whose name is currently associated \nwith u, and AJode(l?def(u)) necessarily dominates node(u). Any change in Rdej(u) must occur because some \ndefinition of Symbol(u) intercedes between u and Rdej(u) as addi\u00adtional may-alias information is accommodated. \nIn Figure 3, such a definition might be introduced by Snoopo as the target of an lsAliaso function (at \nstep ~), or as the target of a related ~-function (introduced by step ~). Definition 1 Consider two definitions \nd and D, of poten\u00adtiaJJy differing storage names, such that D dominates d. We define DomStretch(d, D) \nas the list of dominating definition sites from d to D, excluding D: (d, DomDef(d), DomDef (DomDef (d)), \n. . . . A) where DomDef(A) = D. Thus, Snoopo is invoked at step ~ to process clefs in DomStretch(DomDef \n(u), Rdef(u)). The function Snoopo proceeds up the dominator tree in search of alias information that \ndirectly (via IsAliaso) or indirectly (via a #-function) induces a definition of Symbol(Rdef) symbol \nbetween StaTtDef and StopDef (excluding StopDe f ). Although the function is invoked recursively, each \ninvocation returns the appropriate def in DomStretch (or J_ if none exists). The Vtsztedo attribute makes \ncertain that no def is visited twice per suspicious use. As step I iterates over each def site d G DomStretch(StartDef, \nStopDef) one of the following conditions concludes the search: 1.A def of Symbol(Rdef) is encountered \nin the current SSA form. Because the search excludes Rdef, d domi\u00adnates the suspicious use u, and d is \nstrictly dominated by Rdef; the next partial SSA form must reflect that Rdef(u) = d. Snoopo therefore \nadds d to the constant propagator worklist (because its set of reached uses changes), and returns d; \nstep ~ then updates Rdef (u). 2. A def is encountered whose may-aliases included Symbol(Rdef). Step ~ \ninserts the appropriate defi\u00adnition of Symbol (Rdef) through an IsAliaso function, step ~ adds the new \ndef to the constant propagator worklist, and Srzoopo returns this new clef. 3. A recursive invocation \nof Snoopo from step ~ has established a def that requires insertion of a @function. Step ~ creates the \nappropriate r$function, step ~ adds the new def to the worklist, and Snoopo returns the new clef.  In \ntraditional SSA form, this property would be true only for ordinary uses. Because we push @-uses into \npredecessors of the @-function, this property is true for all uses in our representation. SSAO SSA1 \nVO+3 VO+3 @@-j +~ *+3 *T+3 if (b) then if (b) then *q+3 *q*3 em else else *t*7 *t 4-7 9+6 *p +--6 *.$+3 \n*B *. 5+-3 VI +--IsAtzas(s, &#38;vo) em fi ti v~ + @(vo,VI) en Null + %~ Null +-\u00adc+v~ -em C*VZ SSA2 \nSSA3 = SSASI vot3 +~ VO+3 W+3 *Q *1 t-3 if (b) then v5 -~sAZiU(T, 8WO) en *q*3 if (b) then vs + IsAlias(q, \n&#38;vo) em *q+3 else V3 + IsAlias(q, &#38;v5) *t+-7 em else *p+6 *t +-7 V4 +--IsAlias(p, &#38;vo) em \n*p-6 *3 +-3 V4 +-IsAlias(p, &#38;vo) VI + lSAliaS(S, &#38;V4) *3 +-.3 -em fi VI + IsAlias(s, &#38;v4) \nV2 + 4(V3, VI) em fi Null + v? + rj(v3, Vl) C4-V.2 em Null +\u00ad ce..-v~ Figure 4. Example. 3.3 Example \ndate the new clefs VI and vz, but each is found to be the constant 3. However, three suspicious uses \nare added to We illustrate the workings of our algorithm using the the SSA the two v ~ UList for next \npartial form: uses of at example shown in Figure 4. The SSAO program is a slight (actually associated \nwith predecessors ~ and ~) and the variant of our early example in Figure 1. Each dereferenced use at \n~. pointer serves as a may-alias for v only. 1. Processin the use at ~ (not shown-associated withIn the \ninitial round of constant propagation, the use the ~ at 42 ) invokes Snoopo on DorrzStretch(~l, ~]) bof \nvo at ~ is found to be 3, since its reaching definition and so no work is done. at ~ has that value. \nAs a result, the use of v at ~ is flagged as suspicious by the constant propagator and 2. Processing \nthe use at ~ (not shown-associated with placed on UList. Recalling that a def site is inserted at the \nthe @at I ) invokes Snoopo on DomStretch(~, ~]), beginning of nodes that otherwise lack an initial def \nsite, and the IsAizaso at ~ is added, with the use of v Snoopo is called on DornStretch 37, I ). Because \n~ changed at ~. is the first def in its node, step 30 explores predecessors @ of ~. Accordin ly, Snoopo \nis called recursively for 3. Processing the use at ~ introduces the Is.-ilia.so Dorm$tretch(m, d35 ). \nStatement ~ is then discovered as at ~, which changes the use of v at I . a may-alias for v , adding \nthe IsAlzaso at ~ and, upon When constant propagation is again executed, the definition return from recursion, \nthe @ at ~. The suspicious use of v at ~ becomes d-, which makes the definition at ~ become at ~ is renamed \nv~ its reaching definition in SSAX. 1, which makes the definition at ~ become -L, which makes The next \nround of constant propagation will accommo-the use of v at ~ J_. 41 Because the result of the IsAliaso \nat ~ is 1, the argument wo need not be marked suspicious, even though its value is non-l. Step ~ precludes \nincorporation of may\u00adalias information that could affect ~. Accommodation (i.e., explicit representation) \nof the may-alias for v at ~ is actually unnecessary with respect to constant propagation for the program \ns executable uses; we return to this issue in Section 6. However, our algorithm as iven would continue, \ncreating SSAS by finding the use at 45 to be reached by the IsAlias inserted at ~. In b b a subsequent \nround, the use of vo at 51 is ratified, and so SSAZ is our SSAn. Constant propagation then returns an \nempty list of suspicious uses, so the solution has converged. We emphasize that the above example is \nintended to illustrate our algorithm s execution rather than its perfor\u00ad mance. While the example required \nelaboration of all may\u00ad aliases for v, our experiments indicate that converg ence occurs much faster \nin practice. 4 Analysis In this section we offer proof of our algorithm s correctness, and we analyze \nits worst-case performance. We extend the notation of Section 2 by subscripting a structure to reflect \nits value at a particular partial SSA form. For example, Rde f, (u) refers to the def that reaches use \nu in SSA,. Although the details of data flow analysis [Mar89] are beyond the scope of this paper, we \nrequire some notation to describe the nature of incrementally obtained solutions. We write Soln, (T) \nto denote the solution obtained by constant propagation for a given ref r for SSA,. In comparing two \nsolutions a and b, we write a ~ b if the solution a can be no better than the solution b. The meet of \ntwo solutions a and b is written a A b. For describing the construction of partial SSA forms, we borrow \nthe following notation [CFR+91]: X z Y for X dominates Y X >> Y for X strictly dominates Y idorn(Z) for \nthe immediate dominator of Z DF (X) for the dominance frontier of X DF+ (X) for the iterated dominance \nfrontier of X 4.1 Correctness Our proofs are divided into three groups, each concluding with a theorem \nthat we summarize here: Theorem 1: Constant propagation need not be restarted between SSA forms. Theorem \n2: In processing a suspicious use u to create SSA,, our algorithm determines Rde f,(u) = Rde fw (u). \nTheorem 3: Our algorithm terminates with the correct solution. Lemma 1 If Rdef, (u) # Rdef,.l(u) then \ndefd = Rdef, (u) first appears in SSA, I i >0, such that the text associated with d is one of the following \nforms: 1. Symbol(d) = IsAlias(ptr, Symbol(d)) 2. Symbol(d) = q5(Symbol(d),..., Symbol(d))  Proof: Follows \nfrom the descriptions of Create~sA~iaso and CreatePhio in Figure 3 and the observation that clefs are \nintroduced only by those procedures. I Lemma 2 Rdej, (u) # Rdef,.-l(u) * Soln, (u) < Soln,-l(u) Proof: \nBy Lemma 1, any change to Rdef(u) must occur by introduction of an associated Is Aliaso or @ function. \nIn either case, the data flow solution is obtained by a meet that includes at least Soln, 1 (Role f, \n1(u)). The proof follows from a~b~aAb~a u Lemma 3 For any def d Proof: Follows from Lemma 2 and the observation \nthat Soln(d) depends only on the solutions of uses that contribute to the computation of d. I Theorem \n1 Constant propagation need not restart be\u00adtween SSA, _ 1 and SSA,. Proof: Follows from Lemmas 1, 2, \nand 3. l Lemma 4 For any use u and any partial SSA form SSA, Rdef,(u) ~ DomStretch(DomDef (u), FzrstDef \n(Entry)) Proof (by contradiction): Suppose Rde f, (u) exists on a path from Entry to Node(u) but does \nnot dominate Node(u). Then 3 X 6 Dom%r etch(DomDef (u), FiTstDef(~ntr y)) I X ~ DF+(Node(Rdef,(u)) But \nthis implies a @function at X for Symbol(u). By inspection, our al orithm would have placed such a @ \nd function at step 33 and Rde f, (u) would have been set to the target of this #-function by step ~. \nThe lemma holds even for uses of a @-function, since we associate such uses with the corresponding predecessors \nof the ~-node. I Lemma 5 SSA, contains a qifunction for v at node Y if and only if ( Node(d) = X YE DF(.Y) \n3 d 6 DefSites, \\ Symbol(d) = v idom(l ) ~ X{ Proof: Follows from inspection of our algorithm Corollary \n1 SSA, contains a ~-function only if SS,4 ~ would contain a d-function. Proof: See [CFR+91]. Lemma 6 \nIf Rdef, (u) # RdefX (u) then Rdef, (u) >> Rdefy (u) and RdefX(u) is the target of an IsAliaso or @ function. \nProof: Follows from Lemmas 4 and 1. I Theorem 2 As invoked on use u at step ~, Snoopo finds RdefW(u). \n Proof: Given SSA,, Snoopo traverses 4.3 Performance A = Dom%!retch(DomDef,( u), .f?def,(u)) in the \nloop at I . By Lemma 4, Rdefm(u) occurs in A. By Lemma 6, Rde f~ (u) occurs earlier in A than Rde f, \n(u). Since Snoopo checks for may-aliases and #-functions along A, the def returned to ~ is Rde fm (u). \nI Lemma 7 Consider the set of uses that participate in the computation of some def d: RetUses = {u ILdef \n(u) = d} Soln~ (d) can be determined in SSA, for def d if either: 3 u c ReKJses I So/n,(u) = 1 V u c \nRelUses Soln, (u) = Solnw (u) Lemma 8 Solnw (u) can be determined in SSA, for use u if Rdef,(u) = Rdefw(u) \nand Soln, (Rde~,(u)) = Solnw(Rdef~(u)) Theorem 3 SSA, = SSAn when the following conditions hold: 1. \nAny use u such that 1(u) = O and Soln, (u) # 1 has Rdef,(u) = Rdefw(u) 2. Any use u such that I(u) >0 \nhas either Rdef, (u) = Rdef~(u) or else Soln(Ldef(u)) = 1. 3. For each def d, Sotn, (d) = Soln~ (d). \n  Proof: For (l), observe that if Soln, (u) = J_, then by Lemma 2, future partial SSA forms cannot improve \nupon the solution. For (2), observe that any use u in a IsAliaso or @function whose solution is 1 yields \nSoln(Lde f (u)) =: J-. For (3), there is no partial SSA form past SSAW. The proof then follows from Lemmas \n7 and 8. I Corollary 2 When UList becomes empty, SSA, = SSAS] 4.2 Completeness Each element in our sequence \nof partial SSA forms is partial in two senses: 1. Each may lack the full IsAlzaso information present \nin SSAca . Correspondingly, certain @functions may also be absent. 2. Each may contain a use u such \nthat Rde f, (u) is mrt\u00adof-date. In response to inserting new definitions, our algorithm does not update \nevery affected use.  The first point should be expected, since we wish to avoid the space (and associated \ntime) expense of computing full SSA form. The second point is necessary for our time bounds, in that \nwe desire performance related to the amount of change necessary to accommodate freshly-incorporated may-alias \ninformation. If our algorithms spent time de\u00ad termining the reaching definition of every use affected \nby Snoopo, then the resulting partial SSA form would be more complete, but we could not guarantee the \nusefulness of such work. We therefore wait until a use appears on the suspicious UList before we determine \nits reaching definition. Our algorithm s worst-case performance is easily analyzed, though the result \nis not enlightening in an incremental setting. Let U be the number of suspicious uses identified durin \nthe optimization problem (including all iterations of loop 17). In the worst-case, every edge in the \nflow graph (at step 30 ) must be considered. Our algorithm s performance B is thus 0( U17), where II \nis the number of edges in the flow graph. The term U is a function of the number of uses in the original \nSSAO text, as well as the number of IsAliaso and @ functions inserted by our algorithm. As should be \nnoted from the example presented in Figure 4, further investigation of suspicious uses occurs only when \nincorporation of may-alias information does not sufficient ly degrade the opt imizat ion solution. It \ns very unlikely that may-aliases of a name are all assigned the same constant value. We hypothesize that \nprograms contain either: a great deal of may-aliases, in which case the optimiza\u00adtion problem converges \nquickly to 1 around such aliases; or, scant may-alias information, which can be included with a small \nn-umber of iterations of our algorithm (the loop at step ~). While our experience with the algorithm \nindicates very good performance in practice (Section 5), the asymp\u00adtotic performance can be improved \nby introducing path\u00adcompression [Tar75] into Snoopo. As an associated expense, space would have to be \nallocated to maintain such infornla\u00adtion per-variable, or the UList would have to be sorted by symbol \nname. 5 Experiment We performed the following experiment on 139 Fortran programs taken from the Perfect \n[BCK+88] (Ocean, Spice, QCD) benchmark suite and from the Eispack [SBD+76] and Linpack [DBMS79] subroutine \nlibrary. Since Fortrau (77) has no pointer dereferencing capability, we randomly associated may-alias \ninformation with each program using the following two parameters: AliasRatio R: the probability that \na given definition site is may-aliased with any symbols. AliasWidth W: the probability that a given symbol \nis included in a definition site s may-aliases. The pair (R, W) can then model a wide variety of alias \nbehavior: (0,0) no definition site has any may-aliases. With this setting, the exhaustive algorithm should \noutperform our incremental algorithm. (1,1) each definition site is may-aliased with every symbol. With \nthis setting, our incremental algorithm should outperform the exhaustive algorithm. (.25,.5) on average, \none out of four definition sites has may-aliases; when this occurs, half of the symbols are involved, \non average. * 12 * * * * lo ** * * * * * 8 6 * 4 * 2 * o I A lJO 2A0 3;0 4A0 5A0 6/)0 7A0 8;0 9J0 \nlJOO 1/00 Figure 5. Plot of speedup vs. program size for (R, W) = (.25, .5). The following table shows \nthe median speedup of our does not require restarting a data flow problem based on method over the exhaustive \nmethod: that information. Thus, data flow optimizations based on Alias Ratio Alias Width SSA form should \nbe easily incrementalized in the style by 25% 50% 100% which we incrementalized constant propagation. \no% 1.0 In developing optimization algorithms for programs 25% 2.6 I 4.3 I 8.1 with pointers, one must \neither special-case the behavior of 50% 3.4 ] 6.0 11.6 pointers, or else fully and accurately model the \neffects of pointer dereferencing. While the latter approach allows for100% II 5.2 I 9.9 20.7 a cleaner \noptimization algorithms including the results of Figure 5 plots the speedups we obtained when, on sophisticated \n(may-) alias analysis representing all effects average, one-fourth of a procedure s definition sites \nalias one-of all stores through pointers can significantly increase half of the variable names. Program \nsize is measured by the the size of a program s representation. Processing that number of nodes in the \nassociated flow graph. Our method representation will necessarily incur greater expense during shows \nsignificant speedup, especially on the larger programs. each phase of optimization. Our experiments show \nthat accommodating may\u00ad e In the no-aliasing situation, the exhaustive algorithm alias information incrementally \ncan significantly improve did outperform the incremental, though the median was optimization-time performance \nwhile still allowing optimiza\u00ad 1.0. The only significant cases were two programs of tion to be formulated \nwithout special-cases for pointers. 20 or fewer statements, where our speedup was 0.7, Even where may-aliases \nare rare, our incremental algorithm but these programs took scant time anyway. For one does not perform \npoorly when compared with its exhaustive program of 132 statements, our speedup was 0.86. For counterpart. \nall others, we were close to 1.0. We suggest the following approaches to further research on this problem: \nIn the completely-aliased situation, the space require\u00adments for exhaustive SSA exceeded the 156M virtual \n In Section 3, we required the constant propagator to storage capacity of the host machine for 12 programs. \n3 place any use u on UList if Soln(u) # 1 and u In our best showing, we obtained a speedup of 60 for \nwas not previously placed on UList. If the IsAlzaso three programs of 128 to 263 flow graph nodes (none \nof and q5 functions serve only to transport data flow these aborted). information to the program s original \nclefs and uses, then these functions can be eliminated prior to code 6 Conclusions and open questions \n generation [CFR+91]. In such cases, constant propaga-This paper specifically addresses incorporation \nof may-alias tion need not be suspicious about uses in an IsAliaso or information for constant propagation \nin SSA form. However, @ function unless such uses are required to validate the the mechanism by which \nthe optimization was coupled to our data flow solution at an ordinary program use. Thus, algorithm involves \nthe definition and use sites of a partial the conditions under which the constant propagator SSA form. \nAny optimization based on SSA form (value must flag a suspicious use can be restricted beyond those numbering, \ncode motion, etc. ) must be concerned with the given in Section 3. interaction between definitions and \nuses, The introduction of monotonic information into a subsequent partial SSA form Our work to date \naddresses only flat name spaces, so we hope to extend the work to accommodate informa\u00adtion developed \nfor structure references [LH88, CWZ90, 3Timings for these 12 runs were taken at the abort point. HN90]. \nour algorithm may be suitable for including information similar to may-aliases incrementally into sparse \ndata flow evaluation graphs [CCF91]. Our experiments are based on simulated (probabilistic) may-a.has \npatterns. We would like to try our algorithm in a system that actually analyzes c programs for may\u00adabases. \nAcknowledgements We are grateful to Barbara Ryder and Bill Landi for inspiring this work through their \nambitious alias analysis, and we thank them for many enlightening conversations during our work on this \nproblem. We thank the PTRAN and RISC compiler groups at IBM Research for their help and comments at the \nearly stages of this work, particularly Fran Allen, Jonathan Brezin, Paul Carini, Jong Choi, Marty Hopkins, \nDan Prener, and Edith Schonberg. We thank Ron Loui, administrator of the SURA NSF-funded program at Washington \nUniversity, for sponsoring Reid Gershbein s work on this topic. We thank Will Gillett, Vivek Sarkar, \nand Mark Wegman for their careful reading of this paper and for their helpful comments. The final formulation \nof this paper was guided by suggestions from the program committee members, and we are grateful for their \ndirection. References [AWZ88] B. Alpern, M. N. Wegman, and F. K. Zadeck. Detecting equality of values \nin programs. Conf. Rec. Fifteenth ACM Symp. on Principles of Pro\u00adgramming Languages, pages 1-11, January \n1988. [BCK+88] M. Berry, D. Chen, P. Koss, D. Kuck, S. Lo, Y. Pang, R. Roloff, A. Sameh, E. Clementi, \nS. Chin, D. Schneider, G. Fox, P. Messina, D. Walker, C. Hsiung, J. Schwarzmeier, K. Lue, S. Orszag, \nF. Seidl, O. Johnson, G. Swanson, R. Goodrum, and J. Martin. The perfect club benchmarks: Effective performance \nevaluation of supercomputers the performance evaluation club (perfect ). Technicrd report, U. of Ill \nCenter for Supercomputing Research and Development, November 1988. [Bod90] F. Bodin. Preliminary report \n-Data structure analysis in C programs. Indiana University, Bloomington, March 1990. [CBC93] Jong-Deok \nChoi, Michael Burke, and Paul Carini. Efficient flow-sensitive interprocedural computation of pointer-induced \naliases and side effects. Confenmce Record of the Twentieth An\u00adnual ACM SIGA CT SIGPLA N Symposium on \nPrinciples of Programming Languages, January 1993. [CCF91] J. Choi, R. Cytron, and J. Ferrante. Auto\u00admatic \nconstruction of sparse data flow evaluation graphs. Conf. Rec. Eighteenth ACM Symp. on Principles of \nProgramming Languages, pages 55 66, January 1991. [CFR+91] Ron Cytron, Jeanne Ferrante, Barry K. Rosen, \nMark N. Wegman, and F. Kenneth ZadLeck. Efficiently computing static single assignment form and the control \ndependence graph. ACM Transactions on Programming Languages and Systems, October 1991. [CWZ90] D. R. \nChase, M. Wegman, and F. K. Zadeck. Analysis of pointers and structures. Proc. SIGPLAN 90 Symp. on Compiler \nConstruction, [DBMS79] [HN90] [Lan92] [Lan93] [LH88] [LR92] [LT79] [Mar89] [SBD+76] [Tar75] [WZ91] pages \n296 310, June 1990. Published as SIG-PLAN Notices Vol. 25, No. 6. J. J. Dongarra, J. R. Bunch, C. B. \nMoler, and G. W. Stewart. Linpack Users Guide. SIAM Press, 1979. L. J. Hendren and A. Nicolau. Parallelizing \nprograms with recursive data structures. IEEE Trans. on Parallel and Distributed Systems, 1(1):35-47, \n1990. William A. Landi. Interprocedural Aliasing in the Presence of Pointers. PhD thesis, Rutgers, The \nState University of New Jersey, 1992. William A. Landi. personal communication, 1993. J. R. Larus and \nP. N. Hilfinger. Detect\u00ading conflicts between structure accesses. Proc. SIGPLAN 88 Symp. on Compiler \nConstruction, pages 21-34, July 1988. Published as SIGPLAN Notices Vol. 23, No. 7. William Landi and \nBarbara G. Ryder. A safe ap\u00adproximate algorithm for interprocedural pointer aliasing. Proceedings of \nthe ACM SIGPLA N 92 Conference on Programming Language De.ngn and Implementation, pages 235 248, June \n1992. T. Lengauer and Robert Tarjan. A fast al\u00adgorithm for finding dominators in a flowgraph. TOPLAS, \nJuly 1979. Thomas J. Marlowe. Data Flow Analysis and Incremental Iteration. PhD thesis, Rutgers Uni\u00adversity, \nOctober 1989. B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, Y. Ikebe, V. C. Klema, and C. B. \nMoler. Matrix Eigensystem Routines -Eispack Guide. Springer-Verlag, 1976. Robert Tarjan. Efficiency of \na good but not linear set union algorithm. JA CM, 22:215-225, 1975. M. N. Wegman and F. K. Zadeck. Constant \npropagation with conditional branches. ACM Trans. on Programming Languages and Systems, 13(2):181-210, \nApril 1991. \n\t\t\t", "proc_id": "155090", "abstract": "<p>We present an algorithm for incrementally including may-alias information into Static Single Assignment form by computing a sequence of increasingly precise (and correspondingly larger) partial SSA forms. Our experiments show significant speedup of our method over exhaustive use of may-alias information, as optimization problems converge well before most may-aliases are needed.</p>", "authors": [{"name": "Ron Cytron", "author_profile_id": "81100565597", "affiliation": "", "person_id": "P248647", "email_address": "", "orcid_id": ""}, {"name": "Reid Gershbein", "author_profile_id": "81100660401", "affiliation": "", "person_id": "P240369", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/155090.155094", "year": "1993", "article_id": "155094", "conference": "PLDI", "title": "Efficient accommodation of may-alias information in SSA form", "url": "http://dl.acm.org/citation.cfm?id=155094"}