{"article_publication_date": "06-01-1993", "fulltext": "\n Guardians in a Generation-Based Garbage Collector R. Kent Dybvig, Carl Bruggeman, and David Eby Indiima \nUniversity Computer Science Department Lindley Hall 215 Bloomin@on, Indiana 47405 { dyb,bruggema, deby} \nt?cs.indiana. edu Abstract This paper describes a new language feature that allows dynamically allocated \nobjects to be saved from deallo\u00adcation by an automatic storage management system~ so that clean-up or \nother actions can be performed using the data stored within the objects. The program has full control \nover the timing of clean-up actions, which eliminates several potential problems and often elim\u00adinates \nthe need for critical sections in code that in\u00adteracts with clean-up actions. Our implementation is generation-friendly \nin the sense that the additional overhead within a generation-based garbage collector is proportional \nto the work already done there, and the overhead within the mutator is proportional to the num\u00adber of \nclean-up actions actually performed. Introduction Many programming systems, such as Scheme, Comnnon \nLisp, ML, and Prolog, support dynamic allocation i>nd automatic deallocation of objects. Within these \nsys\u00adtems, some form of storage manager takes responsi\u00adbility for handling both requests to allocate new \nob\u00adjects and automatic deallocation of objects that are no longer needed. Most current automatic storage \nman\u00adagers employ a garbage collector [8] to deallocate un\u00adneeded objects, although some also employ reference \ncounting mechanisms [2]. Automatic storage management is useful for several reasons. First, it simplifies \nthe programmer s job, elim\u00ad inating the burden of freeing 1 Although the ideas presented to reference \ncounting systems, we based systems. Permission to copy without fee granted provided that the copies \ndirect commercial advantage, the dynamically-allocated ob\u00ad in this paper can be extended limit our discussion \nto cOllector\u00ad all or part of this material is are not made or distributed for ACM copyright notice and \nl,he title of the publication and its date appear, and notica ia given that copying is by permission \nof tha Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. ACM-SIG PLAN-PLDl-6/93/Albuquerque, N.M. 01993 ACM 0-89791 -598 -41931000610207 \n. . ..$1 .50 jects and the need to decide which part of a possibly complex system age. Second, it ing \nof objects. proportional to tem rather than is responsible for freeing shared stor\u00adcan be more efficient \nthan explicit free-Modern garbage collectors run in time the amount of data retained in the sys\u00adthe amount \nfreed; in most cases, this results in far less overhead than explicit freeing, which is proportional \nto the amount of data freed. Third, it eliminates the possibility of storage leaks. Finally, most importantly, \nit eliminates the possibility of dangling ref\u00aderences, i.e., references to deallocated storage. This \nis especially important in systems that purport to guar\u00adantee the type safety of all memory references. \nThe collector considers an object to be unneeded when no pointers to the object remain, i.e., when the \nobject is no longer accessible from within the rest of the program, conventionally called the mwtator. \nIn most cases, this is ideal; if an object is inaccessible, how could any part of the mutator still need \nthe storage associated with it, or more particularly, the information contained wit hin that storage? \nIn fact, however, there are cases in which the object or the information cent ained within the object \nmay still be needed or may at least be use\u00adful. Often, these cases concern the need to clean Up or deallocate \nsome resource (perhaps external) associated with the object. For example, files in Scheme are represented \nby ports. Ports encapsulate a file identifier, used to perform op\u00ad erating system requests for buffer \ncontaining unread or other items of information Because of exceptions and not be closed explicitly by \nprimitive 1/0 operations, a unwritten data, and various relating to the file or buffer. nonlocal exits, \na port may a user program before the last reference to it is dropped. This can tie up system resources \nand may result in data associated with output ports remaining unwritten until the system exits. It is \nimportant, therefore, for a Scheme implementation to arrange to flush unwritten data and close a port \nwhen the port becomes inaccessible. Scheme programs that employ external library rou\u00adtines must often \ncope with external resources required by those routines, in particular, with external memory managed \nwith the Unix malloc and free procedures or their equivalent. In order to simplify deallocation of external \nmemory, a Scheme header can be created for each block of storage, and a clean-up action associated with \nthe Scheme header could then be used to free the storage. Similar mechanisms can be used to free other \nexternal resources, such as temporary files and subpro\u00ad cesses. A different but related problem arises \nin the manage\u00ad ment of hash tables. Hash tables provide a convenient and efficient way of attaching values \nto a set of keys, where each key is an arbitrary Scheme object. Hash tables can be used to represent \nsymbol tables and to support shared structure detection during the printing of directed acyclic and cyclic \ngraph structures. While a hash table must retain both the key and value as long as some possibility exists \nfor the value to be accessed through the key in the table, the key/value association should be dropped \nfrom the table whenever the key be\u00ad comes inaccessible outside of the table. Weak pairs, which are discussed \nin the following section, can be used to construct the hash table in such a way that the keys are dropped \nautomatically by the collector, but they do not support removal of the values associated with dropped \nkeys without a periodic scan of the entire ta\u00ad ble. Sometimes it is useful to maintain an internal free \nlist of objects that are expensive to allocate or initial\u00adize. Support for automatically returning such \nobjects to the free list when they would otherwise be reclaimed can lead to a simpler, more efficient, \nand more robust implementation. This might be true, for example, of a set of large objects (such as a \nset of bit maps represent\u00ading graphical displays) whose structure and/or contents remain fixed once they \nare initialized. In order to save the cost of rebuilding or reinitializing new storage loca\u00adtions, it \nmay be less time consuming to reuse a freed object if one exists. These problems all have in common the \nneed for an object to be saved from destruction once it becomes inaccessible so that jinalization2 actions \ninvolving the object can be performed. Essentially, we would like to extend the benefits derived from \nautomatic storage management, as described above, to external resources and higher level internal storage \nmanagement. There are four important issues to consider in the design of a finalization mechanism: When \ndoes finalization occur? If finalization is done by the collector, then all access to structures shared \nby the mutator and finalization routines must be done within a critical section because the collector \nmay interrupt the mutator at any point. ZFOlloWi~g t~adition~ usage, we use the term finz&#38;zation \neven though the actions may not really be final. For example, if the mutator is updating a hash ta\u00adble \nwhen a garbage collection occurs (with the table in an inconsistent state), restructuring the hash ta\u00adble \nat the end of the collection to remove unneeded bindings would corrupt the table. @ In what order are \nobjects finalized? For cyclic or shared structures it may be important to finalize related objects in \na particular order. * Is the full range of language features available to finalization routines? For \nexample, can allocation be done? Can another collection occur? What hap\u00adpens if a a finalization routine \nsignals an error? e Is the object being finalized available to the final\u00adization routine? If so, can \nit be let loose into the system again? Can objects being finalized be re\u00adregistered for finalization? \nThere is a fifth issue to consider for generation-based garbage collectors, which segregate objects bb.sed \non their ages and scan older objects less frequently than newer objects [9]. A generation-friendly finalization \nmechanism must insure that the overhead for finaliza\u00adtion is (at worst) proportional to the amount of \nwork already done by the collector. Among other things, this means that there should be no additional \noverhead for older objects that are not being collected during a par\u00adticular collection cycle. Furthermore, \noverhead in the mutator should be proportional to the number of ob\u00ad jects for which clean-up actions \nare actually performed; it does no good to eliminate the overhead of scanning older objects in the collector \nif the mut ator must do so. In particular, scanning through an entire hash table, as described above, \nin order to eliminate the values for keys that have disappeared is unacceptable. The ideal answers to \nthe first two questions above, when does finalization occur and in what order , de\u00adpend on the particular \napplication. This led us to design a mechanism that gives the program complete control over when and \nin what order finalization occurs. The guardian mechanism that resulted also permits unre\u00adstricted access \nto all language features and makes the object available to the finalization routine without re\u00adstrictions. \nGuardians provide a means to protect objects from destruction by the garbage collector. A guardian is \nan object with which objects can be registered for preser\u00advation and from which objects actually saved \nfrom de\u00adstruction can be retrieved, one at a time, at the con\u00advenience of the program. New guardians \nare created dynamically using make-guardian, the single new prim\u00adit ive required by this mechanism. An \nobject may be registered with rdore than one guardian or registered multiple times with a guardian. Finalization \nof a group of objects can be canceled by simply dropping all refer\u00adences to the guardian. We have added \nguardians to our generation-based col\u00adlector. The cost for handling guardians in both the col\u00adlector \nand mutator is very small, and there is no over\u00adhead forolder objects except when they are subject to \ncollection. The collector also supports weak pairs (men\u00adtioned above and described in the following section), \nwhich complement the guardian mechanism. The remainder of this paper is organized as follc)ws: Section \n2 discusses existing mechanisms. Section 3 de\u00adscribes the guardian mechanism and gives examlples of its \nuse, Section 4 discusses the implementation of guardians and weak pairs within the framework of a generation-based \ngarbage collector. Section 5 summar\u00adizes the paper and presents a somewhat more general interface to \nthe same basic mechanism. Background Guardians are related to the weak sets3 provided by the T language \n[11]. A weak set is a data structure contain\u00ading a set of objects. Operations are provided to add new \nobjects, remove objects, and retrieve a list of the objects in the set. Weak sets are so-called since \nthey maintain weak ) pointers to the objects in their sets. A weak pointer to an object is treated like \na normal pointer by the garbage collector as long as nonweak pointers to the object exist. If only weak \npointers to an object exist, however, the pointers are broken and the object is released. As a result, \nan object that is not accessible except by way of one or more weak sets is ultimately discarded and removed \nfrom the weak sets to which it belonged. MultiScheme [10] provides a similar, more primitive feature, \nweak pairs. Weak pairs are like normal pairs except that the car (data) field of the pair is a weak pointer. \nThe cdr (link) field is a normal pointer. MIT Scheme and recent versions of T support a weak hashing \nfeature that provides a form of weak pointer. The primitive hash accepts an object and returns an in\u00adteger \nthat is unique to that object, i.e., the same integer is never returned for a different object. The primitive \nunhash accepts an integer and returns the associated ob\u00adject, if the object has not be reclaimed by the \ngarbage collector. If the object has been reclaimed, unhash re\u00adturns false. The integer can be used as \na weak pointer to the object. Weak sets, weak pointers, and weak hashing are es\u00adsentially equivalent \nfor our purposes; each allows the program to maintain a pointer to an object that is ul\u00adtimately broken \nonce the object becomes otherwise in\u00adaccessible. Any data contained within the object, how\u00adever, is lost \nwhen the pointer is broken. In spite of 3we~ sets were origin~y called pop~ations. this, weak pointers \ncan be employed to solve the sorts of problems described in the preceding section if we are willing to \nintroduce an extra level of indirection. Instead of maintaining a pointer directly to the data, the pro\u00adgram \ncan maintain a weak pointer to an object header containing a nonweak pointer to the data. If a sepa\u00adrate \nnonweak pointer to the data is maintained, then when the weak pointer to the header is broken the data \nneeded to perform the clean-up action is still available. There are several problems with this solution. \nThe extra level of indirection causes additional complexity since any part of a program that might receive \nthe ob\u00adject must know about the indirection and adjust for it. For this reason, it is inherently unsafe, \nsince it is pos\u00adsible for some part of a program to keep a pointer to the data itself even after the \nheader haa been dropped. This problem is addressed by Atkins [1], who proposes the use of a forwarding \nobject that causes the indirec\u00adtion to be performed automatically. Also, the overhead caused by the extra \nlevel of indirection is unacceptable in some cases. In the case of ports, for example, it significantly \nincreases the cost of reading or writing a character, since these operations otherwise involve only two \nor three memory references. Finally, if a list of weak pointers is maintained (say to the set of objects \nin a large hash table or to a set of externally allocated objects), the entire list must be traversed \nto find the pointers that have been broken, even if none or only a few of the elements have been dropped \nby the collec\u00adtor. This is especially undesirable in a system with a generation-bssed collector, since \nsome or all of the ele\u00adments may be located in older generations not recently subject to collection. \nA number of Lisp and Scheme systems contain a prim\u00aditive finalization mechanism that is not made available \nto the user but is used internally by the runtime system. MultiScheme, T, and Chez Scheme (among others) \nuse such a mechanism to finalize files. Chez Scheme also supports the elimination of unnecessary oblist \nentries, as proposed by Friedman and Wise [6]. Dickey [3] haa proposed a user-level mechanism that allows \na program to register objects for finalization. The procedure register-for-finalization accepts two ar\u00adguments: \nan object and a thunk (zero-arity procedure). The thunk is invoked automatically during garbage col\u00adlection \nif the object has been reclaimed. If implemented properly, this mechanism can eliminate the overhead \nof searching through a list of weak pointers. Since the ob\u00adject itself is not preserved, however, this \nsolution suffers from the other problems associated with weak pointers. In addition, the thunk is not \npermitted to cause heap allocation since it is invoked as part of the garbage col\u00adlection process and \nmust not cause another garbage col\u00adlection. This is an unfortunate restriction, both because it eliminates \na useful set of tools and because it forces the programmer to be aware of all sources of aHoca\u00adtion, \nsome of which may not be obvious. Furthermore, since garbage collection scanhappen at arbitrary times, \nthe programmer has no control over when the actions are invoked. Errors that occur within the thunk are \nproblematic as well; since they must not be allowed to prevent the invocation of other finalization t \nhunks, er\u00adror signals must be suppressed or somehow delayed until all finalization is complete. A discussion \nof various finalization mechanisms found in other languages and operating systems such aa ob\u00adject destructors \nin C++, final actions for modules in Euclid, and finalization actions for limited types in Ada 9X, can \nbe found in [7]. None of the mechanisms de\u00adscribed there, however, provide a general solution to the \nproblems mentioned in Section 1. Guardians Guardians are created using the zero-arity primitive make-guardian: \n(make-guardian) -+ (guardian) A guardian is represented by a procedure that encap\u00ad sulates a group of \nobjects registered for preservation. When a guardian is created, the group of registered ob\u00adjects is \nempty. An object is registered with a guardian by passing the object as an argument to the guardian: \n> (define G (make-guardian)) > (define z (cons a b)) > (Gz) The group of registered objects associated \nwith a guardian is logically subdivided into two disjoint sub\u00adgroups: a subgroup that we shall refer \nto as accessible objects, and one that we shall refer to as inaccessible objects. Inaccessible objects \nare objects that have been proven to be inaccessible (except through the guardian mechanism itself ), \nand accessible objects are objects that have not been proven so. The word proven is important here; it \nmay be that some objects in the ac\u00adcessible group are indeed inaccessible, but that this has not yet \nbeen proven. Depending upon the implemen\u00adtation, this proof may not be made in some cases until long \nafter the object actually becomes inaccessible. Objects registered with a guardian are initially placed \nin the accessible group, and are moved into the inacces\u00adsible group at some point after they become inacces\u00adsible. \nObjects in the inaccessible group are retrieved by invoking the guardian without arguments. If there \nare no objects in the inaccessible group, false (#f,) is returned. Continuing the above example: > (G) \n#f > (set! z #f) ~~G) (a .b) > (G) #f The initial call to G returns #f since the pair bound to x is \nthe only object registered with G, and the pair is still accessible through that binding. At some point \nafter this binding is nullified, however, the object shifts into the inaccessible group and is therefore \nreturned by the later call to G. Although an object returned from a guardian has been proven otherwise \ninaccessible, it has not yet been reclaimed by the storage management system and will not be reclaimed \nuntil after the last reference to it within or outside of the guardian system has been dropped. In fact, \nobjects that have been retrieved from a guardian have no special status in this or in any other regard. \nThis feature circumvents the problems associ\u00adated with finalization of shared or cyclic objects. A shared \nor cyclic structure consisting of inaccessible ob\u00adjects is preserved in its entirety and each piece registered \nfor preservation with any guardian is placed in the in\u00adaccessible set for that guardian. The programmer \nthen has complete control over the order in which pieces of the structure are processed. An object may \nbe registered with a guardian more than once, in which case it is retrievable more than once: > (define \nG (make-guardian)) > (define z (cons a b)) > (Gz) > (Gz) > (set! z #f) >(G) (a .b) > (G) (a. b) It may \nalso be registered with more than one guardian: > (define G (make-guardian)) > (define H (make-guardian)) \n> (define z (cons a b)) > (Gz) > (H z) > (set! z #f) >~G) (a .b) > (H)  (a .b)  One can even register \none guardian with another: > (define G (make-guardian)) > (define H (rnde-gwrdh)) > (define z (cons a \nb)) > (G H) > (H c) > (set! z #f) > (set! H #f) ,.. > ((G)) (a. b) (Of course, the last expression is \ndangerous, since there is no guarantee that (G) will not return #f.) At what point does an inaccessible \nobject become available for retrieval from a guardian? In general, the storage management system responsible \nfor reclaiming the storage from inaccessible objects is also responsi\u00adble for moving otherwise inaccessible \nobjects from the accessible group to the inaccessible group. In a system such as ours that employs a \ngarbage collector to reclaim inaccessible objects, the garbage collector mai~tains a list of registered \nobjects with their associated guardiims. This list is traversed after collection and any objects that \nhave not been marked or forwarded are forwarded at that time (saved from destruction) and placed iinto \nthe inaccessible group. The example below demonstrates how guardians may be used in Scheme to ensure \nthat dropped ports are closed. New guarded open operations are defined in terms of the existing operations \n(open-input-file and open-output-file), and a new exit procedure is defined in terms of the existing \nexit procedure, (define port-guardian (make-guardian)) (define close-dropped-ports (lambda () (let ([p \n(port-guardian)]) (if p (begin (if (output-port? p) (begin (flush-output-port p) (close-output-port p)) \n(close-input-port p)) (close-dropped-ports)))))) (define guarded-open-input-jile (lambda (pathname) \n(close-dropped-ports) (let ([p (open-input-file pathnarne)]) (port-guardian p) P))) (define guarded-open-ouiput-fiie \n(lambda (pathname) (close-dropped-ports) (let ([p (open-output-file pathname)]) (port-guardian p) P))) \n(define guarded-ezit (lambda () (close-dropped-ports ) (exit))) - In this implementation, dropped ports \nare closed when\u00adever an open operation is performed or upon exit from the system. In many Scheme and \nLisp systems it is pos\u00adsible to cause the garbage collection handler to perform arbitrary actions after \ncollection completes (with the caveats mentioned in Section 1); in such systems it may make sense to \ncause close-dropped-ports to be invoked after collection instead. In Chez Scheme, a program does this \nby installing a new collect-request handler: (collect-request-handler (lambda () (collect) (close-dropped-ports))) \n Guardians are also useful in conjunction with weak pairs. Weak pairs are like normal pairs except that \nthe car field of a weak pair is a weak pointer, as described in Section 2. Weak pairs are created using \nweak-cons and manipulated using normal list processing opera\u00adtions, car, cdr, pair?, map, etc.4 The existence \nof a weak pointer to an object in the car field of a weak pair does not prevent the object from being \ntransferred from the accessible list of a guardian to the inaccessible list, and the weak pointer is \nnot broken when such a transfer is made. Figure 1 contains a simple hash table implementation that demonstrates \nhow guardians and weak pairs can be used together to allow removal of useless entries. Sup\u00adport for removing \nuseless entries is entirely contained within the shaded areas of the figure. When a key/value pair is \nadded to the table, key is registered with a guardian associated with the hash table. This guardian is \nchecked for keys to remove each time the hash-table access procedure is called. Since the key/value pair \nis a weak pair, the pointer to key is weak and does not prevent key from being transferred to the inaccessible \nlist of the guardian. Many Scheme and Lisp systems provide eq hash ta\u00adbles. Eq hash tables permit arbitrary \nobjects to be used as keys with fast hashing based on the virtual memory address (the name eq comes from \nthe name of the ad\u00address equality predicate eq?). Since an object may be 4 some S&#38;eme ad Lisp systems \nhave a distinct weak-pair tYPe and related operations such as weak-car and weak-cdr. (define make-gtiarded-hash-table \n(lambda (hash size) (let ([g (mdwgwwdia~)] [v (make-vector size ())]) (lambda (key vaiue) (leJytol? ([z \n(g)]) [let [[h (hsh key siw)]) (M ([bucket (Veetar-ref U A]]) (vector-set! m h (remq (assq z 6UCJW$ bucket)) \n(ioop (g)))))) (let ([h (hash key size)]) (let ([bucket (vectm-ref v h)]) (le;,J~ (assq key bucket)]) \n. (cdr a) (le:g(~weuk-cons key vaiue)]) (vector-set! v h (cons a bucket)) value))))))))) Figure 1. make-guarded-hash-table \naccepts a hash procedure and a table size and returns a hash-table access procedure. The access procedure \naccepts a key and a value. If the key is already present in the table, the existing value is returned; \notherwise, the key is added to the table along with the value provided. Sometime after akeybecomes inaccessible \nitis returned by the guardian g, and the corresponding key-value pair is removed from the table. The \ndefinition of an unguarded hash table is obtained by deleting the shaded areas. moved during a garbage \ncollection, however, its address and hence its hash value may change. This problem is often solved by \nrehashing such tables after a collection or, more commonly, after a lookup has failed following a collection. \nIn a generation-based collector much of this work is wasted for keys that are no longer forwarded during \nevery collection because they have survived long enough to have advanced to older generations. One solution \nto this problem is to use a transport guardian that returns an object when it has been moved (transported) \nrather than when it has become inaccessible. The system could then rehash only those objects that have \nbeen moved since the last rehash. A useful conservative form of transport guardian may be implemented \nin terms of ordinary guardians and weak pairs. A conservative transport guardian returns all objects \nthat have moved but may also ret urn some objects that have not moved. The code for implementing conservative \ntransport guardians is given below. The approach is to allocate a fresh marker that is guaranteed to \nbe no older than the object to be guarded (since the marker is newly al\u00adlocated), register the marker \nwith a guardian, and drop the reference to the marker so that it will be returned by the guardian after \nany collection to which the marker has been subjected. When the marker is returned by the guardian, the \nobject may also have been subject to the same collection and thus is returned by the tran~ port guardian. \nSince the same marker is re-registered with the guardian each time it is returned, it will grad\u00adually \nage along with the object providing the desired generation-friendly behavior. In order to prevent the \ntransport guardian from holding onto an otherwise in\u00ad accessible object, the marker is a weak-pair whose \ncar field contains the object. (define make-transport-guardian (lambda () (let ([g (make-guardian)]) \n(case-lambda [(z) (g (weak-cons z *))] [() (let ioop ([m (9)1) (and m (if (car m) (begin (g m) (car m)) \n(loop (g)))))])))) 4 Implementation Adding guardians and weak pointers to our generation\u00adbased garbage \ncollector was surprisingly ~traightfor\u00adward. This sect ion describes briefly the basic collection  empty \ntconc tconc with one element v ml p+m Object Figure don t 2. An empty care values; tconc neither and \na tconc with one collector nor rnutator element are references shown above. such cells. Empty cells represent \n algorithm and the modifications necessary to incorpo\u00adrate guardians and weak pointers. The number of \ngenerations and the promotion and tenure strategies supported by the collector are under programmer control. \nIn order to simplify the discussion, however, we assume a fixed number of generations O through n (O \nbeing youngest) with the following simple promotion and tenure strategy: New objects are placed in generation \nO.  Objects in generations less than or equal to g that survive a collection of generation g, g < n \nare placed in generation g + 1.  Objects that survive a collection of generation n are placed in generation \nn.  Generation O is collected each time there is a collec\u00adtion; older generations are collected less \nfrequently (the older the generation, the less frequently it is collected).  When a generation is collected, \nall younger gener\u00adations are collected as well.  The generation into which objects are copied during \na particular collection is referred to as the target genera\u00adtion. The collector performs a stop-and-copy \ncollection from the generations being collected into the target gen\u00aderation. The actual guardian interface \ndescribed in Section 3 is a packaging of a lower-level interface. In the low-level interface, the garbage \ncollector maintains a prot ect ed last of object/guardian pairs for each generation, Each time an object \nis registered with a guardian, a new pair (Of the object and guardian) is added to the protected list \nfor generation O. After a collection of generation g, each element in the protected list of each generation \ni, i ~ g is visited (the protected lists themselves are not forwarded during collection). If the object \nhas been forwarded, it must be accessible (via a nonweak pointer) outside of the protected list, and \nthe object/guardian pair is placed in the protected list of the target generation. If not, it is placed \nin the inaccessible group of the guardian and dropped from the protected list. In either case, both the \nelement and the guardian are forwarded. Although guardians are procedures at the user level, internally \nthey are represented as a form of queue called a tconc (the name comes from an old Lisp construct of \nthe same name). A tconc consists of a list and a header; the header is an ordinary pair whose car field \npoints to the first cell in the list and whose cdr field points to the last cell in the list (see Figure \n2). In our mechanism, the tconc representing a guardian holds the list of inac\u00adcessible objects; the \ngarbage collector adds elements to the end of this list while the mutator removes elements from the front \nof the list. We have chosen to use the tconc representation and designed the protocols for manipulating \nthe tconc so that critical sections are unnecessary in both the mu\u00adtator and collector (see Figures 3 \nand 4). Since the collector cannot be interrupted by the mutator in our current implement ation, we do \nnot presently rely on the fact that the collector does not require critical sections; however, since \nthe collector can interrupt the mutator at any point, we do avoid the need for a critical section in \nthe guardian code that returns inaccessible objects to the mutator. An empty tconc is one in which both \nfields of the header point to the same pair; what the fields of this pair contain is unimportant. The \nmutator is permit\u00adted to manipulate the car field of the header; it is also allowed to compare the car \nfield with the cdr field to determine if the tconc contains any elements. The col\u00adlector is permitted \nto manipulate the cdr field of the header and the pair to which the cdr field points. In order to avoid \nthe need for critical sections, the collec\u00ad  after before m --~ Object ObjectOb~ect Figure 3. The \ncollector adds new elements to the tconc by modifying the car field of the old last pair in the list \nto point to the new element and the cdr fields of both the old last pair and the header to point to a \nnew last pair. Emboldened objects and pointers represent updated or new pieces, and the dashed pointer \nrepresents the final update. before after Object Object Object Object Figure 4. The mutator retrieves \nelements from the tconc by modifying the car field of the header to point to the second pair in the list. \ntor adjusts the cdr field of the header last so that the provided by the collector module, simply adds \nits argu\u00admutator does not see that there is a new element until ment to the protected list for generation \nO. the element is fully installed. (define make-guardianIn Figure 4, the pair that had been pointing \nto the (lambda ()first element is shown (after the operation) with don t (let ([k (let ([z (cons #f ())]) \n(cons z z))])care values in its car and cdr fields. Semantically, (case-lambdait is not necessary to \nremove the pointers that had [() (and (not (q? (car tc) (cdr tc)))been contained there. However, since \nthe pair is some\u00ad(let ([z (car #c)])times in an older generation than the objects to which (let ([-g \n(car z)])it points, maintaining these pointers after they are no (set-car! tc (cdr z))longer needed may \nresult in unnecessary storage reten\u00ad(set-car! z #f)tion. (set-cdr! z #f) The Scheme code that packages \nup the tconc struc-Y)))] ture is shown below. The syntactic form case-lambda, [(obj) (instali-guardian \n(cons obj tc))])))) a multi-interface, multi-body version of lambda [5], is used to construct the procedure \nrepresenting the The portion of the collection algorithm that handles guardian. The tconc structure \nis created outside of the protected lists is described in pseudo-code below. It case-lambda and is visible \ninside via the name tc. The follows the algorithm as sketched above, but is compli\u00adprocedure install-guardian, \nwhich is an internal routine cated somewhat by the need to discard pairs from the protected lists when \nthe corresponding guardian (tconc) is itself no longer accessible. Otherwise, all objects reg\u00adistered \nat the time the guardian is dropped can be re\u00adclaimed only after they have all become inaccessible. penal-hold-list \n:= penal-final-list := empty For each generation i from O to g For each (obj . -tconc) pair in pro-tected[i] \nIf forwarded? (obj) move (obj . tconc) to penal-hold-list Else move (obj . tconc) to penal-final-list \nEnd For protected[i] := empty End For Loop final-list := empty For each (obj . tconc) pair in penal-final-list \nIf forwarded? (tconc) move (obj . tconc) to final-list End For If empty ?(final-list) Exit Loop For each \n(obj . tconc) pair in final-list forward(obj) tconc := get-fwd-addr(tconc) add obj to the tconc  End \nFor kleene-sweep(g) End Loop For each (obj . tconc) pair in penal-hold-list If forwarded? (tconc) tconc \n:= get-fwd-addr(tconc) ob j := get-fwd-addr(obj) move (obj . tconc) to protected[target-generation] \nEnd If End For In the code above the predicate forwarded? (obj) is true when obj has been forwarded during \nthis collection or when it resides in a generation older than those being collected. Similarly, get-fwd-addr(obj) \nreturns either the forwarding address of obj or the address of obj it\u00adself. The procedure kleene-sweep \n(g) iterative y sweeps copied objects until there are no newly copied objects to sweep. The first block \nof code separates accessible objects from inaccessible objects, placing the former (along with their \ntconcs) onto the penal-hold-list and the latter onto the penal-final-list. The second block of code iterates \nover the ob j/t cone pairs in pend-jinal-list; if the t cone is accessible, obj is forwarded and added \nto the tconc. If the tconc is not accessible, it may become accessible during the sweeping phase (if \npointed to from within one of the objs) and is therefore left on pend-jinal-list for the next iteration. \nThe third block moves each obj/t cone pair whose tconc has survived from penal-hold-list to the protected \nlist of the target generation. Weak pairs are supported as follows. Chez Scheme employs a segmented memory \nsystem in which the heap is structured as a set of segments (each currently 4K bytes in size). Each segment \nbelongs to a specific space and generation; the space and generation to which each segment belongs is \nmaintained in a segment information table with one entry per segment. The segments that comprise a space \nor generation are generally not con\u00adtiguous. This arrangement haa many benefits, including the ability \nto segregate objects based on their charac\u00adteristics, such as whether they are mutable or whether they \ncontain pointers [4]. We use this ability in the im\u00adplementation of weak pairs, which are always placed \nin a distinct weak-pair space. When pairs found in the weak-pair space are traced during the normal garbage \ncollection, they are treated like normal pairs except that the car field is not touched. A second pass \nthrough the weak-pair space is made after garbage collection; dur\u00ading this second pass, if the object \npointed to by the car field of a weak pair has been forwarded, the new address is placed in the car field \nof the weak pair. Otherwise, #f is placed in the car field. The second paas through the weak-pair space \noccurs after the garbage collector has handled the protected lists (including the forward\u00ading which is \ndone there), so if the car field of a weak pair points to an object that has been salvaged, the object \nwill still be in the car field after collection. Only when there are no pointers outside of the weak-pair \nspace is the car field set to #f. 5 Conclusions In this paper we have described guardians, which are \nentities that abstract the process of saving objects from destruction by the garbage collector in order \nthat clean\u00adup actions can be performed using the data stored within the objects. The program retains \nfull control over when clean-up actions are performed, eliminating the need for some critical sections, \nrestrictions on the use of allocation within the clean-up actions, and prob\u00adlems with the order in which \npieces of shared or cyclic structures are processed. Unlike many previous mech\u00adanisms, the guardian mechanism \nactually preserves the object; most other mechanisms either discard the ob\u00adject and leave behind a flag \nor discard the object and automatically invoke some clean-up action associated with the object. Several \nproblems with other mecha\u00ad nisms are avoided in this manner. The guardian mech\u00ad anism, by itself or in \ncombination with weak pairs, can be used to solve a variety of problems, from closing dropped ports to \nremoving unused entries from hash tables. Our implementation is generation-friendly in the sense that \nthe additional overhead within the generation-based garbage collector is proportional to the work already \ndone there, and the overhead within the mutator is proportional to the number of clean-up actions actually \nperformed. We have considered a slightly more general guardian interface, in which the guardian accepts \nan (agent ) in addition to the object when an object is registered for preservation. Rather than returning \nthe object when it becomes inaccessible, the guardian returns the agent. Since the agent can be the object \nitself, this subsumes the simpler interface. The primary benefit of this change is that it allows objects \nto be discarded if something less than the object is needed to perform the finalization, although the \nagent might actually contain more than just what is contained within the object or something altogether \ndifferent. We have not yet deter\u00admined the full impact of this change on the collector. For the applications \nwe have examined, we have found that neither weak pairs nor guardians satisfactorily re\u00adplaces the other. \nOn the contrary, we have found that not only are both mechanisms useful but that they both work well \ntogether, as evidenced by the ease with which guarded hash tables and transport guardians are imple\u00admented. \n[6] [7] [8] [9] [10] [11] Although we have designed and implemented the guardian mechanism for use in \nScheme, there is nothing about the mechanism that is particular to the Scheme language. Adapting the \nmechanism to other languages and collection strategies should be straightforward. Acknowledgements: We \nwish to thank David Wise for providing comments on an earlier draft of this paper and Mike Ashley for \nan insight that led to a simpler transport guardian implementation. References [1] Martin Object\u00adof York, \nC. Atkins. Oriented 1989. Implementation Systems. PhD Techniques for thesis, University [2] G. E. Collins. \nA method for erasure of lists. Communications 3(12):655-657, December 1960. overlapping of the and ACM, \n[3] Ken Dickey. private communication. [4] R. Kent Dybvig, David Eby, and Carl Bruggeman. Flexible and \nefficient storage management using segmented heap. in preparation. a [5] R. Kent Dybvig and Robert Hieb. \nto procedures with variable arity. bolic Computation, 3(3):229-244, A new approach Lisp and Sym-September \n1990. Daniel P. Friedman and David S. Wise. Garbage collecting a heap which includes a scatter table. \nIn\u00adformation Processing Letters, 5(6), December 1976.  Barry Hayes. Finalization in the collector interface. \nIn Proceedings of the International Workshop on Memory Management IWMM92, pages 277-298, St. Malo, France, \nSeptember 1992. Springer-Verlag. Donald E. Knuth. The Art of Computer Pro\u00ad gramming, Volume I: Fundamental \nAlgorithms. Addison-Wesley, Reading, Mass., second edition, 1973.  Henry Lieberman and Carl Hewitt. \nA real-time garbage collector based on the lifetimes of objects. Communications of the ACM, 26(6):419-429, \nJune 1983. James S. Miller. MultiScheme: A Parallel Process\u00ading System Based on MIT Scheme. PhD thesis, \nMassachusetts Institute of Technology, September 1987. Jonathan A. Rees, Norman I. Adams, and James \nR. Meehan. The T Manual, fourth edition, September 1988.  \n\t\t\t", "proc_id": "155090", "abstract": "<p>This paper describes a new language feature that allows dynamically allocated objects to be saved from deallocation by an automatic storage management system so that clean-up or other actions can be performed using the data stored within the objects. The program has full control over the timing of clean-up actions, which eliminates several potential problems and often  eliminates the need for critical sections in code that interacts with clean-up actions. Our implementation is &#8220;generation-friendly&#8221; in the sense that the additional overhead within a generation-based garbage collector is proportional to the work already done there, and the overhead within the mutator is proportional to the number of clean-up actions actually performed.</p>", "authors": [{"name": "R. Kent Dybvig", "author_profile_id": "81100181541", "affiliation": "", "person_id": "PP14073331", "email_address": "", "orcid_id": ""}, {"name": "Carl Bruggeman", "author_profile_id": "81100269459", "affiliation": "", "person_id": "P40685", "email_address": "", "orcid_id": ""}, {"name": "David Eby", "author_profile_id": "81100072984", "affiliation": "", "person_id": "P61354", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/155090.155110", "year": "1993", "article_id": "155110", "conference": "PLDI", "title": "Guardians in a generation-based garbage collector", "url": "http://dl.acm.org/citation.cfm?id=155110"}