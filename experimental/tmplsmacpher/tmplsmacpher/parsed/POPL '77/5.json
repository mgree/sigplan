{"article_publication_date": "01-01-1977", "fulltext": "\n GENERALIZED CONMON SUBEXPRESSIONS IN VERY HIGH LEVEL LANGUAGES* Permission to make digital or hard copies \nof part or all of this work or personal or classroom use is granted without fee provided that copies \nare not made or distributed for profit or commercial advantage and that copies bear this notice and the \nfull citation on the first page. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee.&#38;#169; 1977 ACM 0-12345-678-9 $5.00 Amelia \nC. Fong Department of Computer Science University of Torcinto Toronto, Ontario Canada N5S IA? Abstract \nWe propose a new optimization technique applicable to set-oriented languages, which we shall call general \ncommon subexpression elimina\u00adt ion. It involves the computation of the IAVAIL(n) function for all nodes \nn in a flow graph, where IAVAIL(n) is the set of expres\u00adsions such that along every path leading to n, \nthere will be found a computation of the ex\u00ad pression followed by only incidental assignments (i.e. A= \nA U {x} or A= A -{x}) to its operands and that the number of such assignments is bounded, Independent \nof the path taken. We shall try to justify our definitions and demonstrate the usefulness of this technique \nby several examples. We shall ahow that this optimization problem does not fit into the semilattice\u00adtheoretic \nmodel for global program optimization [Ki, KU, GW], and that the standard iterative algorithm for such \npfoblems does not work in ~ this case. We then give several theorems which allow the problem to be solved \nfor reducible flow graphs. The formulae given in the theorems are in such a form that an efficient algorithm \ncan be found by adapting an algorithm given in [u]. The resulting algorithm takes O(e log e) steps of \nan extended type, where bit vector operations are regarded as one step, and e ia the number of edges \nof the flow graph. It takes O(n log n) extended stepa for a program flow graph of n nodes. 1. Introduction \nOne of the most important techniques in global code optimization is the detection of common subexpressions \n[Al, A2, AU, CS, C, u]. An expression such as A * B is available at a point p in a program if every sequence \nof branches which the program may take to p causes A * B to have been computed after the last compu\u00adtation \nof A or B, If we determine the set of available expressions at entrance to the nodes of a flow graph, \nthen we know which expressions have already been computed prior to each node. Thus we may be able to \neliminate the redundant computation of some expressions with each node. This optimization can be applied \nto set\u00adtheoretic languages such aa SETL. *Work partially supported by NSF grant DCR-74\u00ad15255 while the \nauthor is at Princeton Univ. Let us take as an example the following program. n: X=(AUB)flC nl: Y= m: \nZ=D-(AUB) The program may appear in an intermediate language, as in the following, where T] and T2 are \ntemporaries. n: T1=AUB x =Tlnc m: T2 =AUB z =D -T2 The expression A U B is considered to be avail\u00adable \non entering node m, so that it need not be recomputed. The computation of A U B can be eliminated. We \nsee that since both T] and T2 compute the same expression having the same value, we can eliminate T2 \nand replace it by T1. This is usually called common subexpression elimina\u00adtion in the literature. Thus \nthe following pro\u00adgram is obtained. n: T1=AUB x=Tlnc m: Z =D-T1 Now consider the following program: n! \nx=(AuE)nc nl: A=AU{x} m: Z=D-(AUB) The expression A U B is considered killed whenever any of its operands \nis redefined, so A U B is no longer available on entering m and hence has to be computed from the values \nof its operands A and B. However if we notice that 48 since A is only changed slightly at nl, A U,B at \nm can be computed much more easily by modify\u00ading its value at n. We modify the program as follows: n: \nT1=AUB X=TIUC T1 =T1 U{x] A=AU{x) nf: . m: ZD -Tl In this case, the correct value of A U B is available \nin T1 on entering m. Hence we have replaced computing the union of two arbitrary acts by the addition \nof an element. Thus, an order of magnitude improvement in the computation time of A U B at m is achieved. \nWe shall demonstrate the usefulness of this optimization by yet another example. Consider Dijkstra s \nalgorithm for finding the shortest paths for a single source. The follow\u00ading is one version of the algorithm \ntaken from [AHu]. We assume that the existential quantifier also has the side effect of storing the existing \nvalue into the control variable, as in [E]. w s = {v~}; DIvI)] = O; for v c V-S do D[v] = d(vo,v); . \nwhile V-S # @ do if~wlD[w] = MIN(DIx]: x c V-S) then Q!2@!l S=su{w}; for v c V-S do D[v] = MIN(DIv], \nD[w] + d(w,v)); end end end The program in an intermediate program might look like the following, \nwhere T1,... ,TI+ are temporaries. begin 1. s = {Vfjl; 2. D[vO] = O; 3. T1=V-S; 4. for v E T1 do D[V] \n= d(vo,v);  5. T2=V-S; 6. while T2 #$do  w  7. T3=V-S; 8. if~wlD[w] = MIN(DIx]: x c T3) then  \n *  9. S=su {w};  10. T4=V-S; 11, ~vcT4~  D[v] = MIN(DIv], D[w] + d(w,v)); end end  end  Figure \n1.  After analyaing for possible common subex\u00adpression elimination, we find that statement 5 in Fig.1 \ncan be eliminated; statements 7 and 10, which appear in a loop and take time proportional to the size \nof V plus the size of S can both be eliminated, replaced by the addition of state\u00adment 8 in Fig.2, which \ntakes only unit time. Also, one temporary T1 is necessary; the temporaries Tz, T3 and T4, each using \nas much space as T1 can all be eliminated. The modified program is as follows: !?fQ!l 1. s = {VI)}; \n2. D[vO] = O; 3. TI=V-S; 4. for v E Tl do D[v] = d(vo,v);  5. while T1 # $do  begin  6. if~wlD[w] \n= MIN(DIx]: X E !fl) ~ begin   49 7. S=su {w}; 8. T1 T1 -{W}; 9. for vin T1do  D[v] = MIN(DIv}, \nD[w] + d(w,v)); end end end Figure 2. In the remaining part of this paper we shall concentrate on \nfinding the set of expressions at each node for which this optimization is appli\u00adcable. In Section 2 \nwe shall give the basic definitions and attempt to justify them. In Section 3 we explain why the semilattice \ntheo\u00adretic model fails to encompass our problem. We then give several theorems which allow us to solve \nthe problem efficiently for reducible flow graphs. Section 4 outlines the algorithm adapted from [U], \nconcentrating on the details which are different from that given in [U]. The paper is concluded by a \nbrief discussion on some implications of this optimization and a summary. 2. The Flow Graph Model We \nassume a set-oriented language such as SETL [S]. The operations whfch we assume can be done in unit time \nare: (1) arithmetic on integers (2) insertion of an element into a set. (3) deletion of an element \nfrom a set (4) selection of some member from a set (5) testing whether an atom fs in a set.  These \nassumptions are valid, at least in an expected time sense, if one uses a hash table representation for \nsets, such as in [S], with elements which are sets represented by pointers to their values. We take it \nas a corollary to (4) that a set may be tested for emptiness in unit time. It is assumed further that \nwe are presented a Program as a flow graph, consisting of three\u00adaddress statements, e.g. , A=BUC, but \nnot A = B U [C n D], which would appear as: T=C[lD A=BUT We shall use the usual model for a program \nbeing subjected to code improvement. Definition: A flow graph is a triple G = (N, E, no), where (1) N \nis a finite set of nodes. (2) E is a subset of N X N called edges. The edge (n1,n2) enters node n2 and \nleaves node nl. We say nl is a predecessor of n2, and n2 is a successor of nl. The presence of edge (nl,nz) \nmeans that after execution of the instruction(s) represented by nl, it is possible that control will \npass to that represented by ~. (3) no in N is the initial ~, the place where all computations begin. \n (4) We say there is a -in G1 fromnl to ~,  if there is a sequence of nodes n1,n2,. ..,nk such that \n(ni, is in E for lsi<k. The i+l) path length of n~,...,~ is k-1. We require that there be a path from \nno to every node in the flow graph. Definition: Call an assignment incidental if it is of theform A=AU{x} \nor A=A-{x}. Note that an incidental assignment takes only unit time, as assumed in our model. Let us \nexamine a slight variation of the example given in Section 1. n: Tl=AUB i I +3 nl : A=AU{x} m: T2=AUB \n If we perform the optimization described in\u00adformally in the previous section, the modified program looka \nlike: Ix =Tlnc 9I J T =T1 U{X} A =AU{X} m: z =D-T1 It is easy to see that in order to have the correct \nvalue of A lJ B (in Tl) onreachLng node m, T1 may have to be updated an arbitrary number of times as \nthe loop indicated in the above figure may be executed an arbitrary number of times. Hence it is not \nclear that this optimiza\u00adtion is worthwhile in this case. In fact, it might even hurt the running time \nof the program. If we desire that an order of magnitude improve\u00adment in the computation of an expression \nw at node n be achieved in this manner, we should require that there are at most a bounded number of \n50 incidental assignments to any operand of w in any path from the last computation of w to n, independent \nof the path taken. This ia the motivation for the boundedness requirement in the definitiona to follow. \nWe asaume that associated with certain flow grapha are computations (E, G, K, IG, IK) where: (1) Z is \nthe aet of expressions computed by the flow graph. (2) G ia a mapping from N to 2X. If an ex\u00adpreeaion \nw = A 0 B is in G(n), then we imagine that w is generated i.e., computed within the block represented \nby n, and that neither A nor B is aubaequently defined or read into within the block. (3) K is a mapping \nfrom N to 2X. We interpret K(n) as the set of expressions which are killed in block n. Informally expression \nA 6 B is killed if either A or B are defined or read into within the block n. (4) IG is a mapping from \nN to 2Z. We in\u00adterpret IG(n) as the set of expressions A 6 B generated in block n, such that if A or \nB is subsequently killed , it is only by incidental assignments. Zz  (5) IK is a mapping from N to \n. We in\u00adterpret IK(n) as the set of expressions which ara only incidentally killed in block n. In\u00adformally \nexpression A 8 B is incidentally killed if either A or B are defined in block n, and they are defined \nonly by incidental asaignmenta. Note that by definition, IK(n) is a subset of K(n) and G(n) is a subset \nof IG(n).  Let F = (N, E, no) be a flow graph with computation (Z, G, K, IG, IK). Definition: For n \nin N, define AVAIL(n) to . be the aet of expressions w for which in every path in F from nk to n, say \nno,nl,.. .,nk, where n = n, there ia some i~k for which w k is in G(ni) and w is not in K(nj) for i<j<k, \nDefinition: For n in N, define IAVAIL(n) to be the set of expressions w for which there exists a positive \ninteger c such that for every path in F from no to n, say no,n ,...,nk where = n, (1) there is some i, \ni<k for which k w is in IG(ni) and w is not in K(nj) -IK(nj) for i<j<k, and (2) the number of nodes nx, \ni<x<k such that w is in IK(nx) is not greater than c. Note that by definition, AVAIL(n) is a subset of \nIAVAIL(n) for all nodes n.  3. Computation of IAVAIL We shall begin this section by briefly ex\u00adplaining \nwhy for this global data flow analysis problem, the relevant information desired, namely IAVAIL(n) for \nall nodes n in the flow graph, cannot be modeled by the semilattice-theoretic model [Ki, KU, GW] at least \nin the only natural choice of semilattice. The problem arises from the requirement that if w is in IAVAIL(n), \nthen for any path leading to n, the number of incidental assignments to any operand of w after the last \ncomputation of w m,lst be bounded, independent of the path taken. Consider the following example from \n[R]. Let Go be the graph as shown in Fig. 3(a). Let w be an expression in G(nO) and in IK(nl). By definition \nof IAVAIL, w iS not in IAVAILGo(n2). Now consider Gc for C>O> aa shown in Fig.3(b), where each nl ~ for \n@jSC is a copyof the node nl in Go. Tie w is in IAVAILC (nz,o) for all c. Now consider the c semilattice \nL of finite sets of expressions, which is the natural one here. The function fl from L to L associated \nwith nl in GO must be the same as the function associated with l,j in Gc for all j, O~j~c. Let S be \nthe l,j set of expressions generated in no. If this problem fits the semilattice framework, then flc(S) \ncontains w for all c because hWAILG (nz,o) contains w for all c Ut hen to n2in GO, for eve~y path p \nfrom n fp(S) contains w, contradicting the assumption that w is not in IAVAIL (n2). i!LGo no no ..+nl \nl,C n- Jo-G n2,1 n2 n2,0 8 Figure 3(b)Figure 3(a) Hence the semilattice model does not reflect the interaction \nof relevant information desired in our problem. Also the standard iterative algo\u00ad rithm as appears in \n[Ki, KU) does not work here. However, we have been able to solve the problem We shall efficiently for \nreducible flow graphs. now give the theorems which allow us to do so. Our algorithm is based on the \nfact that re\u00adducible flow graph can be built from regions, which are subgraphs with a single header node \nwhich dominates all nodes in the region. (A node n dominates node m if every path from che initial node \nof the flow graph to node M goes through n. ) Moreover, the reducible flow graph can be built from regions \nof a single node by the following two constructions. Tl: Given a region R2 such that there .\u00adare some \nedges that go from nodes in RJ. to the header of R2, form RI by including $hose edges. T2: Given regions \nRz and R3, such that all predecessors of the header of R+ are in R7, form RI from the-union of R- > and \nR3 plus the edges from R~ to the header of R3; the header of RZ becomes the header of RI. See [U] for \ndetails. The Algorithm works by computing the follow\u00ading five quantities for each region R= (N, E, nl). \n(1) GENR(n) (2) TRANSR(n) (3) IGENR(n) (4) IGUTR(n) (5) ITRANSR(n)  GENR(n) is the set of expresaicms \nw for which every path l  Lk rem 1 o n lying wholly within R includes a node .ti for which G(Li) contains \nw and K(lj) does not contain w if i ~j. TRANSR(n) is the set of expressions w for which no path !ZI,. \n..,fk from n] to n lying wholly within R includes a node i such that w is in K(9.i) and w is not in \nG(!Zj) for j > i. Note that GENR(n) is a subset of TRANS (n) for all nodes n. R IGENR(n) is the set of \nexpressions w for which there exists a positive integer c such that every path to n l  Lk rem 1 lying \nwholly within R, (1) include. a node i for which w is in IG(Li) and w is not in K(Lj) -IK(!2.) for \nI<j<k, and (2) the number J of nodes E i<xsk for which w is in IK(!ZX) x is not greater than c. Note \nthat GENR(n) is a subset of IGENR(n) for all regions R and for all nodes in R. ITRANSR(n) is the set \nof expressions w for which (1) no path ~l,. ..,tk from nl to n lying within R includes a node such that \n9 i w is in K(ti) -IK(!i) and w is not in IG(Lj) for spree j > i, and (2) there exists a positive integer \nc such that for a~~ patha .Z],[2,... ,Lk from nl to n, if q is the largest integer lSqS.k such that w \nis in IG(~q), the number of nodes Lx; q<xSk for which w is in IK(tx) is not greater than c. If there \nexists no such integer q, then the number of nodes Q l=xsk for which w is in IK(lk) is x not greater \nthan c. Note that by definition, TRANSR(n) is a subset of ITRANSR(n). GENR(n) is a subset of TRANSR(n), \nand IGENR(n) is a subset of ITRANSR(n) for all regions R and for all nodes n in R. IGUTR(n) is the set \nof expressions w for which there exists a positive integer c such that for every path p = L ,... ,L 1k \nfrom the header nl of R to n lying entirely in R, one of the following is true: (1) There is no node \nI x in the path for which w is in K(LX), or (2) p includes a node for which w  i is in IG(li) and w \nis not in K(Lj)-IK(L ) for j>i, and the j number of nodes L i<x~k for which x w is in IK(LX) is not greater \nthan c. Note that by definition, IGENR(n) U TRANSR(n) is a subset of IGUTR(n) and IGUTR(n) is a subset \nof ITRANSR(n) for all regions R and for all nodes n in R. The following two theorems allow us to compute \nthe five quantities recursively for larger and larger regions. The formulae given in the two theorems \nare in such a form that an efficient algorithm can be found by adapting an algorithm from [u]. Theorem \n1: Let RL = (N, El, n~) be a region formed by transformation T1 from region R2 =(N, Ez, n~). That is, \nEl consists of E2 and those edges represented by the edges elimina\u00ad ted. Then for all n in N, (1) GENRl \n(n) = GENR,(n) :  (2) TRANSRl (n) = GENR2 (n) U [T fl IRMtSR, (n)] .  (3) IGENR, (n) = IGENRa (n) \n(4) rGUTRl(n) = IGENR2(n) U [A nIGUTR,(n)] (5) ITRANSRl (n) = IGENR2(n) U [A f) ITRANSR, (n)] where \nT is the intersection of TRANSR2(m) taken over all m such that (m, nl) is in  El -E2, and A is the intersection \nof IGUTR2(m) over the same m s. Proof: (1) and (2) can be found in [U]. (3) and (4) follow from the definition \nof IGENR(n) and IGUTR(n) and are straightforward. (5) is less intuitive and we shall sketch the argument \nfor it. We shall show that the left hand side is a subset of the right hand side and vice versa. First \nwe want to prove that IGENR2(n) U [A il ITRANSR,(n)] is a subset of ITRANSRl (n). We shall prove-that \nif w is not in ITRANSRl (n), it is not in IGEN (n) and not in R2 [A () ITRANSR2 (n)]. There are two cases \nto consider. (1) w is not in ITRANSR (n) because it vio\u00ad lates condition (1) in the definition of ITRANS. \nThat is, there exists a path from n) to n in RI, say !tI,... ,ik where for some q, w is in K(tq) -IK(lq), \nand w is not in T.G(L ) for j qsjsk. We can find a sequence of indices jl,...jr for some rzl so that \n1P is nl if and only if p is one of jl,... ,jr. Then the paths j  j ~+1-1; or lSi<r and are each withtn \nR2, and for each i, jr - Lk the edge (L. .,I?ji) is in E~ -E2. Now Iq J ~-1 must be in one of these paths. \nIf ?, is in the q last path, w is not in ITRANSR2(n), hence not in IGENR2(n). Therefore w is not in IGENR2(n) \nU [A n ITRANSR2(n)]. If Iq is not in the last one, then w is not in A, and not in IGENR2(n), hence not \nin IGENR2(n) U (A (1 ITRANSR2(n)]. We have shown that if w is not in ITRANSxl(n). it is not in IGEN R2 \nU [A 11 ITRANSR2(n)]. Hence the latter is a subset of ITRANSRl (n). (2) Suppose w is not in ITRANSR, \n(n) because condition (2) in the definition of ITRANS iS violated. (We assume now condition (1) is not \nviolated). That is, given an integer c, there exists a path ~.l, . . ..~k from n~ to n such that (a) \nif q is the largest integer, lsqsk such that w is in IG(lq). then the number of nodes 1 ~, q~xs.k for \nwhich w is in IK(IX) is greater than c. (b) if no such q exists, then the number of nodes Lx ISXSIC for \nwhich w is > in IK(IX) is greater than c. We can find a sequence of indices jl,. ..jr for some ral so \nthat t is nl if and only P if P iS one of jlj... )jro Then the paths Lj,. ... fji+l -l; for l~izr and \nI.. ,...,lk are 3 each within R2, and for each i, the edge of is in El -E2. We shall consider (~ji+) \ncases (a) and (b) separately. (a) Lq must be in one of these paths. If 9. q is the last path, w is not \nin ITRANSR2(n), hence not in IGENR2(n). Therefore w is not in IGENR2(n) U [A () ITRANSR2(n)]. If Iq is \nnot in the last one, then w is not in A, and not in IGENR2(n), hence not in IGENR2(n) U [A fl ITRANSR2(n)]. \nTherefore IGENR2(n) U [A [1 ITRANSR9] is a subset of ITRANSRl (n). . (b) If no such q exists, w is not \nin IGENR2(n). Let y be the smallest integer l~yslc for which w is in IK(LY). If Ey is in the last path, \nw is not in ITRANSR2(n). If y is not in the laat path, w is not in A. Hence w is not in IGEN U [A (1 \nITRANSR2(n)]. R2 To prove the converse, suppose w is not in IGENR2 (n) and not in [A fl ITRANSR2 (n)]. \nwe shall prove that w is not in ITRANSR1 (n). If w is not in ITRANS (n), it is surely not R2 in ITRANS \n(n). If w is in ITRANS (n), it is R1 R2 not in A and thus not in IGUTR7(m) for some m such that (m, n]) \nis in El -E;. Since w iS not in I(XJT (m), there are two cases to consider: R2 (1) We can construct a \npath in RI by going from nl to m in such away that w is in K(y) for some node y in that path, then from \nm to and thence to in such a way that nl n w is not generated . If w is in It(y) \u00adIK(y) , clearly w is \nnot in ITRANSRi (n). Hence we may assume w is in IK(Y). Let the path from ni to m constructed above be \ndenoted by p. Then (p)q, nl,... ,n for q~l are all paths in Proof: The proof ia similar to that of Theorem \n1 RI from nl to n. Since w is in IK(Y) for some y in p, and w is not generated, there\u00adfore given any \ninteger c, the path (p)q, nl,...n, where q>c, is a path from nl to n in RI such that the number of nodes \nx for which w is in IK(x) is greater than C. Hence w is not in lTRANSRl(n). (2) If we cannot construct \na path as in case (l), then by definition of IGUTR2(m), there exists a path in IZ2 from n to m, say l \n Lk such that for any integer c, if y is the largest integer lsyQc such that w is in IG(LY), the number \nof nodes t X* Ya* for which w is in IK(LX) ia greater than c. We can construct the following path from \nnl to n in RI. It con\u00adsists of the path p followed by nl, then onto n in such a way that w is not generated \n. This is possible because w is not in IGEN (n). R2 The number of nodes x in this path for which w is \nin IK(x) after the last generation of w is greater than c. Since this can be constructed for any integer \nc, w is not in ITRANSRl (n). We have shown that if w is not in IGENR2(n) and not in [A n ITRANSR2(n)], \nit is not in ITRANSRl(n). Hence ITRANSRl(n) is a subset of IGENR2(n) U [A n ITRANSR2(n)]. n Theorem \n2: Let R1 = (Nl,El,n ) be region formed by transformation T2 ?rom regions R2 = (N2~E2,n2) and R3 = (N3,E3,n3). \nThen for all nin N2, (1) GENRl(n) = TRANSR2(n) (2) TRANSRl (n) =TRANSR2(n) (3) IGENRl(n) = 1GENR2(n) \n (4) IGUT% (n) = IGUTR2(n) (5) ITRANSRl(n) = ITRANSR2(n)  For all n in N3, (6) GENRl (n) = GENR3(n) \nU [r (l TRANSR3(n)] (7) TRANSRl(n) = GENR3(n) U [T nTRANSR3 (n)] (8) IGENRl (n) = IGENR3(n) U [Ir 11 \nITRANSR3(n)] (9) IGUTRl (n) = IGEN U [A n IGUTR3(n)] R3  (10) ITlbiNSRl (n) = IGENR3(n) U [1 n ITRANSR3(n)] \n where r is the intersection of GEN (m) over all Rz m such that (m, n3) is in E1-E2-E~. Ir is the intersection \nof IGEN (m), A is the inter\u00adsection of IGUT (m), TR2is the intersection of R2 TRANS (m) and 1 is the \nintersection of R2 ITRANSR2(m) over the same m s, and we omit it. c1 The following theorem is essential \nand follows from the definitions of IAVAIL and IGEN. Theorem 3: Let F = (N, E, no) be a reducible flow \ngraph and hence a region. Then IVAIL(nO) =+ and for n # no. IAVAIL(n) is the intersection over all predecessors \nm of n, of IGENF(m). Proof: By definitions. El From Theorem 3, we can obtain the IAVAIL function if \nwe can compute IGEN for the entire graph, which turned out to be difficult to compute directly. However, \nwe can compute IGEN, IGUT and ITRANS together, starting with regions of one node, and proceeding to larger \nand larger regions. Theorems 1 and 2 give us inefficient but workable method for doing this. We shall \ndiscuss how it can be made efficient in the next section. If the AVAIL function is also desired, GEN \nand TRANS for the entire flow graph can also be computed by the same algorithm. The AVAIL function can \nbe easily computed from GENF(n) for all nodes n In F. [u] 4. Efficient Implementation of GEN, IGEN, IGUT, \nTRANS, ITRANS In the last section, we have given two theorems which allow us to compute GEN, IGEN, IGUT, \nTRANS, ITRANS. It turns out that the formulae are in such a form that they can be computed efficiently \nby adapting an algorithm from [u]. In this section, we shall outline the algorithm, concentrating only \non the detaila which are different from those given in [u]. We shall construct a tree representing each \nregion. The tree w%ll have a leaf representing each node in the region and with the following properties: \n(1) No interior node of the tree will have more than three direct descendants. (2) If an interior node \nhas heigh h (the longest path from the node to a leaf is h), then it has  at least 2h-1 descendant leaves. \n(3) All patha from a node to its descendant leaves have the same length. The edges of the tree will be \nlabeled by 5\u00adtuples of sets of expressions. It will be arranged that if the tree represents region R, \nthen GENR(n), IGENR(n), IGUTR(n), TRANSR(n), ITRANSR(n) can be computed by following the path from the \nleaf for n to the root as follows. ALGORITRM 1: to [rk, Let Irk, [r], Ak, Irl, Tk, Al, Ik] T], 1: be \nthe ,. ..] labels of the edges ? [ $,O,Z,E,ZI proceeding n. Let toward G i, IG i, the root IU i, from \nthe T i and I i leaf for node be defined by the following computation: (1) G 0 = IG 0 = $, IU O =T o \n= 1 0 = X, the [A1,Bl,CJ,D1,El] set of all expressions. (2) For l<is.k~ compute G i = G i_l U (Gi 11 \nT i-l) , IG i Ill i = = IG IG ~-1 i-1 U = (Iri(l I i_l), ( ~nIu i-l), i = G ~-1 U (Ti (l T i-l) and \nI i = IG i-1 = (Iifl I i-l) Then G k = GENR(n), IG k = IGENR(n), IU k = IGUTR(n), T k = TRANSR(n) and \nI k = ITRANSR(n). where Ai = ~ ~ i = Ii i Ci = ll i i =G ~ i = IGi U(~f)Ti), U (Ir () Ii), U (A (} Ai), \nU(T[l Ti), U (I (1 Ii) for l~isk). A basic manipulation of edge labels is given in the next lemma and \nexhibited in Fig.2. We refer to it as stripping of an edge (to, t o). Lemma 1: Let to, t . be nodes of \na tree with edges and labels as in Fig.4(a). If the labels of those .edges are changed to those in Fig.4(b), \nthen the same GEN, IGEN, IGUT, TRANS, ITRANS functions as before are computed for all the leaves of the \ntree by Algorithm 1. Proof: The lemma follows by straightforward algebraic manipulation. D to Fig. 4(b) \nNote that an edge with label [$,$,X,Z,Z.] has no effect on the calculation of Algorithm 1. That is, if \n[ri>Iri>Ai,Ti,Ii] is [$,O,Z,E,~] and G ~ ~ is a subset of T i_l and IG i_l is a subset of both I i 1 \nand IU ~ ~, then G = G i i-l lG i = lG ;l l i = lu;i-l i = i-1 and l i = I i-1 We shall now implement \nthe relations given Theorems 1 and 2. Sets of expressions will be represented by bit vectors. The manipulations \nare described in the next algorithm. in ? [r,I1 ,A,T,I] ALGORITRM 2: The algorithm for initialization, \ntrees for regions block, the second by application of consists i.e., consisting and third T1 and of three \nparts, one the construction of of a single basic for region constructed T2 respectively. (1) Initialization: \nFig.4(a) For the initial regions consisting of node n, take two nodes r and t. Make r and label the single \nedge (r,t) by [G(n). [Z-K(n)] UIG(n), [X-K(n)] UG(n), [Z -(K(n)-IK(n))] U IG(n)]. a single the root IG(n), \n(2) Application of Tl: Suppose region RX tion of T1 from region the quantities computed in tree for region \nRI by is created R2. Let Theorem 1. the following by an applica-T and A be Create the steps. 55 (a) \nCreate a new node r whose lone son is the root r of the tree for R1. Label edge (r,r ) by [$,o,A,T,A]. \n (b) Strip the edge (r,r ). (c) Delete r and the edge (r,r ); r is the root for RI. (3) Application \nof T2:  Suppose R is created by T2 from regions R1 and R2, where the node representing R1 is the lone \npredecessor of the node representing R2. Let r, Ir, A, T and I be the quantities mentioned in Theorem \n2. Create the tree for region R by the following steps. (a) Create a new node r whose lone aon is the \nroot r of the tree for r2. Label the edge (r,r ) by [1 ,Ir,A,T,I]. (b) Strip the edge (r,r ). (c) Delete \nr and the edge (r,r ). (d) Merge the resulting tree with root r and the tree for R1. The resulting tree \nis the tree for region R.  The merger algorithm is rather complicated, but is identical in spirit to \nthat in [U]. We omit the details. We shall now outline the complete algorithm for computation of IGEN, \nIGUT and ITRANS for the entire flow graph. Once we have this, the computation of IAVAIL is easily done \nin O(e) steps, where e ia the number of edges, by Theorem 3. If the AVAIL function is also desired, GEN \nand TRANS for the entire flow graph can also be computed by the same algorithm. ALGORITHM 3: Let F = \n(N,E,nO) be a reducible flow graph with computation (.Z,G,K,IG,IK). (1) Use the algorithm of [HU] or \n[T] to construct a parae r of F. (2) Create treea for the initial regions, each consisting of a single \nnode, using step (1) of Algorithm 2. (3) FO11OW the steps of i? in order. If the step createa a region \nby using Tl, do 3(a). If the step creates a region by using T2, do 3(b). (a) Create the tree for the \nnew region using step (2) of Algorithm 2. The quan\u00ad tities T and A mentioned can be computed using Algorithm \n1. (b) Create the tree for the new region using step (3) of Algorithm 2. Uae Algorithm 1 to compute \nthe quantities I , Ir, A, T, 1.  (4) After step (3) is completed, we have the tree for the entire flow \ngraph F. Compute IGENF(n) for each node n in N. (5) Compute IAVAIL(n) for all nodes n in N according \nto Theorem 3. The above algorithm requires O(e log e) extended steps (where bit vector operatons are \nregarded as one step, as in [U]), when applied to a flow graph with e edges and n nodea. The proof can \nbe found in [u]. On a program flow graph of n nodes, where the number of edges e ia Sn, Algorithm 3 requires \nO(n log n) extended steps. 5. Discussion and Summary We shall briefly discuss some implications of this \noptimization. In the examples given in Section 1, the common subexpressions found are ex\u00adpressions created \ntemporarily in the process of computing other expressions, i.e. they are assigned to system variables; \nsc that by identify\u00ading them, two temporary variables, say T1 and T2 ~Y be pointing to the same value. \nNow if T1 iS dead at the time T2 is to be created, we can use the same name, i.e. TI and hence the same \nvalue (possibly with slight modification), as ia the case in the examples in Section 1. Now consider \nthe example below: N: X=AUB m: Y=AUB By identifying the two expressions A U B at nodes n and m, we will \nalso be identifying the program variables X and Y. If X is dead on reaching m, there would be no problem. \nIf not, then the fact that X and Y are now point\u00ading to the same value must be recorded. It is possible \nthat a different copy of this value may have to be made at a later time, in which case the saving due \nto common subexpreesion elimination amounts merely to copying A U B instead of com\u00adputing the union, \nobtaining maybe a constant speedup. Now consider the case illustrated by the following piece of code: \nN: X=AUB m: Y=AUB If X is dead on reaching m; X can be modified into Y. If not, and if X and Y are only \ndifferent by {x}, an idea similar to one from [FU], where a new set-valued variable A is introduced to \nrecord the difference between slightly different acts, may be used. We shall not go into details here. \nWe merely want to point out that performing common subexpresaion elimination in set-theoretic languagea \nmay cause different variables to be sharing the same representation of certain value. This should be \ndealt with aa the general problem of dealing with assignment statement such as X = Y, and deciding whether \na new copy should be made or whether they can share the same repreaentation. 56 In summary, we have \nproposed a new optimiza-[GW] S.L. Graham and M. Wegman, A Fast and tion technique for set-~heoretic languagea. \nWe Usually Linear Algorithm for Global Flow Analysis~ have illustrated its use by examples and shown \nProc. 2nd ACM Sym posium on Principles of . that the problem does not fit the semilattice Programming \nLanguages, J=., 1975. c theoretic model, and that the standard iterative algorithm does not work here. \nWe have stated [HU] J.E. Hopcroft and J.D. Unman, An n log n several theorems which allow the problem \nto be Algorithm for Reduction of Flow Graphs, 6th solved for reducible flow graphs, Moreover, the A~, \nPrinceton Conference G Information ~ences usual available expressions computed, namely the and Systems, \n1972. . AVAIL(n) function, can be obtained at the same time when the IAVAIL(n) function is calculated, \n[Kl] G.A. Kildall, Global Expression Optimiza\u00adby slightly modifying Algorithm 3. Yhe entire tion During \nCompilation, Proc. of ACM CXonf. On . . algorithm takes O(e log e) extended steps for a Principles of \nProgramming Languagea, pp. 194-206, flow graph of e edges, and takes O(n log n) October 197~ extended \nsteps for a program flow graph of n nodes. [KU] J.B. Kam and J.D. Unman, Global Optimiza\u00adtion Problems \nand Iterative Algorithms, ~, Acknowledgements Jan., 1976. ) The author wishes to thank Professor [R] \nB.K. Rosen, Private Communication. Jeffrey D. Unman for his helpful comments and Dr. Barry K. Rosen for \npointing out an error [T] R.E. Tarjan, rTesting Flow Graph Reduci\u00ad in an earlier draft of this paper. \nThe author bility, Proc. 5th ACM Symp osium on Theory of would also like to thank J. Wood for her careful \nComputing, Play, 1973. typing of this paper. Bibliography [U] J.D. Elimination Unman, Fast of Common \nAlgorithms Subexpressions, for the Acts [Al] F.E. Allen, Program Optimization, in Informatica, 2:4, \n1973, pp. 191-213. Annual Review in . Automatic P~, Vol. 5, Pergamon, 1969, pp. 239-307. [A2] F.E. \nAllen and J. Cocke, A Catalogue of Optimizing transformations, in Design and Optimization of Compilers \n(R. Rustin, ed~, Prentice Hall~1972, pp. 1-30. [AHU] A.V. Aho, J.E. Hopcroft and J.D. Unman, The Design \nand Analysis of Computer Algorithms, Addison-Wes~, 1974. [AU] A.V. Aho and J.D. Unman, The Theory of \nParsing, Translation @ Compili~ Vol. II: Compiling, Prentice Hall, 1973. [C] J. Cocke, Global Common \nSubexpression Elimination, SIGPLAN Notices, Vol. 5, no. 7, pp 20-24, July 1970. [CS] J. Cocke and J.T. \nSchwartz, Progra~in~ Languages and Their Compilers, Courant Institute,~w=, 1971. [E] J. Earley, High \nLevel Operations in automatic programming, Proc. SIGPLAN Sym posium on Very High Level Languages, March, \n1974. [FKU] A.C. Fong, J.B. Kam and J.D. Unman, Application of Lattice Algebra to Loop Optimization, \nProc. 2nd ACM ~. on Principles of Programming Languages~Jan. , 1975. [FU] A.C. Fong and J.D. Unman, Induction \nVariables in Very High Level Languages, Proc. 3rd ACM ~. on Principles of Programming  Languages, Jan= \n1976. \n\t\t\t", "proc_id": "512950", "abstract": "We propose a new optimization technique applicable to set-oriented languages, which we shall call general common subexpression elimination. It involves the computation of the IAVAIL(n) function for all nodes n in a flow graph, where IAVAIL(n) is the set of expressions such that along every path leading to n, there will be found a computation of the expression followed by only incidental assignments (i.e. A = A &#8746; {x} or A = A - {x}) to its operands and that the number of such assignments is bounded, independent of the path taken. We shall try to justify our definitions and demonstrate the usefulness of this technique by several examples. We shall show that this optimization problem does not fit into the semilattice-theoretic model for global program optimization [Ki, KU, GW], and that the standard iterative algorithm for such problems does not work in this case. We then give several theorems which allow the problem to be solved for reducible flow graphs. The formulae given in the theorems are in such a form that an efficient algorithm can be found by adapting an algorithm given in [U]. The resulting algorithm takes 0(e log e) steps of an extended type, where bit vector operations are regarded as one step, and e is the number of edges of the flow graph. It takes 0(n log n) extended steps for a program flow graph of n nodes.", "authors": [{"name": "Amelia C. Fong", "author_profile_id": "81546348156", "affiliation": "University of Toronto, Toronto, Ontario, Canada", "person_id": "PP309810200", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512956", "year": "1977", "article_id": "512956", "conference": "POPL", "title": "Generalized common subexpressions in very high level languages", "url": "http://dl.acm.org/citation.cfm?id=512956"}