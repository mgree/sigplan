{"article_publication_date": "01-01-1977", "fulltext": "\n PROGRAMMING LANGUAGE CONSTRUCTS FOR WRICH IT IS IMPOSSIBLE TO OBTAIN GOOD HOARE-LIKE AXIOM SYSTEMS Permission \nto make digital or hard copies of part or all of this work or personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; 1977 \nACM 0-12345-678-9 $5.00 Edmund Melson Clarke, Jr.t Duke University Durham, N. C. 27706 Abstract Hoare \nlike deduction systems for establishing partial correctness of programs may fail to be complete because \nof (a) incompleteness of the assertion language relative to the underlying interpretation or (b) inability \nof the assertion language to express the invariants of loops. S. Cook has shown that if there is a complete \nproof system for the assertion language (e.g. all true statements of the assertion language) and if the \nassertion language satisfies a certain natural expressibility condition, then sound and complete axiom \nsystems for a fairly large subset of Algol may be devised. We exhibit programming language constructs \nfor which it is impossible to obtain sound and complete sets of Hoare like axioms even in this special \nsense of Cook s. These constructs include (i) recursive procedures with procedure parameters in a programming \nlanguage which uses static scope of identifiers and (ii) coroutines in a language which allows parameterless \nrecursive procedures. Modifications of these constructs for which it is possible to obtain sound and \ncomplete systems of axioms are also discussed. 1.1 Background. Many different formalisms have been proposed \nlanguage, then for any (sound) Hoare like axiom for proving Algol like programs correct. Of system there \nwill be assertions {P! S {Q} which are these the most widely referenced is the axiomatic true but not \nprovable within the system. The approach of C.A.R. Hoare [H069]. The formulas question is whether this \nincompleteness reflects in Hoare s system are triples of the form some inherent complexity of the programming \nlanguage {P} S {Q} where S is a statement in the program-constructs or whether it is due entirely to \nthe ming language and P and Q are predicates in the incompleteness of the assertion language. For language \nof the first order predicate calculus example, when dealing with the integers, for any (the assertion \nlanguage). The partial correct-consistent axiomatizable proof system there will be ness formula {P] S \n{Q} is true iff whenever P predicates which are true of the integers but not holds for the initial values \nof the program provable within the system. How can we talk about variables and S is executed, then either \nS will the completeness of a Hoare like axiom system inde fail to terminate or Q will be satisfied by \nthe pendently of its assertion language? final values of the program variables. A One way of answering \nthis question was proposed typical rule of inference is by S. Cook [C075]. He gives a Hoare like axiom \nsystem for a subset of Algol including the while {PKb} s {P} statement and non recursive procedures. \nHe then {P} while b do S {PA-b} proves that if the~e is a complete proof system for the assertion language \n(e.g. all true statements of The axioms and inference rules are designed to the assertion language) and \nif the assertion lan capture the meanings of the individual state-guage satisfies a certain natural expressibility \nment of the programming language. Proofs of condition, then every true partial correctness correctness \nfor programs are constructed by assertion will be provable. Gorelick [G075] extends using these axioms \ntogether with a proof system Cook s work to recursive procedures. Similar cOm for the assertion language. \npleteness results are given by deBakker and Meertens What is a good Hoare like axiom system? [DE73] and \nby Manna [MA70]. One property a good system should have is soundness ([H074], [D076]). A deduction system \nis sound if every theorem is indeed true. Another 1.2 New Results of This Paper. property is completeness \n[c075], which means that Modern programming languages use constructs every true statement is provable. \nFrom the Godel which are considerably more complicated than the incompleteness theorem we see that if \nthe deduc while statement, and one might wonder how well tion system fot the assertion language is axiom \nHoare s axiomatic approach can be extended to handle atizable and if a sufficiently rich interpretation \nmore complicated statements. In this paper we will (such as n,lmber theory) is used for the assertion \nbe interested in the question of whether there are tA large portion of this research was completed while \nthe author was a graduate student at Cornell University with the support of an IB14 Research Fellowship. \nprogramming languages for which it is impossible to obtain a good (i.e. sound and complete) Hoare like \naxiom system. This question is of obvious importance in the design of programming languages whose programs \ncan be naturally proved correct. We first consider the problem of obtaining a sound and complete system \nof axioms for an Algol\u00adlike programming language which allows procedures as parameters in procedure calls. \nWe prove that in general it is impossible to obtain such a system of axioms even if we disallow calls \nof the form Call P(. ..,P, ...) . (Calls of this form are necessary if one wants to directly simulate \nthe lambda calculus by parameter passing.) We then consider restrictions to the programming language \nwhich allow one to obtain a good axiom system. The incompleteness result is obtained for a block-structured \nprogramming language with the fol\u00adlowing features: (i) procedures as parameters of procedure calls (ii) \nrecursion  (iii) static scope (iv) global variables (v) internal procedures All these features are found \nin Algol 60 [NA63] and, in fact, in Pascal [W173]. We also show that a sound and complete axiom system \ncan be obtained by modifying any one of the above features. Thu S if we change from static scope to dynamic \nscope, a complete set of axioms may be obtained for (i) procedures with procedure parameters, (ii) recur \nsion, (iv) global variables, and (v) internal procedures as parameters; or if we disallow in ternal procedures \nas parameters, a complete system may be obtained for (i) procedures with procedure parameters, (ii) recursion, \n(iii) static scope, and (iv) global variables. As far as we know, this is the first axiomatic treatment \nof procedure parameters. An independent source of incompleteness is the coroutine construct. If procedures \nare not recur\u00adsive, there is a simple method for proving correct ness of coroutines based on the addition \nof aux\u00adiliary variables [ow76]. .If, however, procedures are recursive, we show that no such simple method \ncan give completeness. These observations gen eralize to languages with parallelism and recur sion. Additional \nprogramming language constructs for which it is impossible to obtain good axioms are discussed in Section \n8. 1.3 Outline of Paper. The development of these results is divided into two parts the first dealing \nwith procedures as parameters and the second with the coroutine construct. In Section 2 a formal description \nis given for a programming language with static scope, global variables, and procedures with procedure \nparameters. This is followed by a discussion of Cook s expressibility condition. Modifications necessary \nto handle dynamic scope are also discuss ed. In Section 3 we prove that it is impossible to obtain a \nsound and complete axiom system for this language. In Sections L, 5, and 6 we discuss re\u00adstrictions sufficient \nto insure that good Hoare\u00ad like axioms can be found. Sections 8 and 9 are devoted to completeness and \nincompleteness results for the coroutine construct and follow the same outline as was used in the first \npart of the paper. The paper concludes with a discussion of the results and remaining open problems. \n2. A Simple Programming Language and its Semantics. As in [C075] we distinguish two logical sys\u00adtems \ninvolved in discussions of program correct ness the assertion language L in which predicates describing \na program s behavio~ are described and the expression language L in which the terms forming the right \nhand S1 2 es of assignment state ments and (quantifier free) boolean expressions of conditionals and \nwhile statements are specified. Both L and LE are first order languages with equall + y is an extension \nof L . In general the variabfl~ fi~ LB are called progra~ identifiers PROG_ID and are or ered by the \npositive integers. The variables of LA are called variable idenfifers VARID . An interpretation I for \nLA consists of a set D (the domain of the interpretation) and an assign\u00adment of functions on D to the \nfunction symbols of We will use the notation III for the cardinal A ity of the domain of I. Once an interpretation \nI has been specified, meanings may be assigned to the variable free terms and closed formulas of L ~. \nLE) Let I be an interpretation with domain A program state is an ordered list of pairs of the form: (vl.dl) \n(v2.d2) . . . (vn.dn) where each v. is a variable identifier and each d. 1 is an element of D. Thus a \nprogram state is similar to the association list used in the defini\u00adtion of Lisp. If s is a program state \nand v is a variable identifer than s(v) is the value associ\u00adated with the first occurrence of v in s. \nSimilar ly, ADD(sYd)is the program state obtained by adding the pair (v.d) to the head of list s, and \nDROP(S,V) is the program state obtained from s by deleting the first pair which contains v. VAR(S) is \nthe set of all variable identifiers appearing in s. If t is a term of LA with variables x 1 2 . . ..x \nand s is a program state, then we w1ll use the n~tation t(s) to mean S(xl), . ..s(xn) t I  xn Likewise \nwe may define P(s) where P is a formula ofL. It is frequently convenient to identify a form~la P with \nthe set of all program states which make P true, ie. ~th the set {slIIP(s)]=true}. If this identification \nis madq then false will correspond to the empty state set and true will correspond to the set of all \nprogram states. We consider a simple programming language which allows assignment, procedure call, while, \ncompound and block statements. Procedure declara\u00ad tions have the form q:proc(=:~); K end where q is the \nname of the procedure, = is the list of formal variable parameters, ~ is the list of formal procedure \nparameters, and K is the body of the procedure. A procedure call has the form call q(a:~) where ~ is \nthe list of actual variable parameters and ~ is the list of actual procedure parameters. To simplify \nthe treatment of parame\u00ad ters we restrict the entries in Z to be simple program identifiers. We further \nrequire that procedure names be declared before they appear in procedure calls. An environment e is \na finite set of procedure declarations which does not contain two different declarations with the same \nname. If m is a proce dure declaration, then ADD[e,n] is the environment obtained from e by first deleting \nall procedure declarations which have the same name as IT, and then adding ~. If S is a statement and \ne is an environment, then GLOBAL(S,e) is the set of variables which are global to S or to some proce \ndure in e. Meanings of statements are specified by a meaning function M=M whaich associates with a I \nstatement S, state s, and environment e a new state s . Intuitively s is the state resulting if S is \nexecuted with initial state s and initial environ\u00adment e. The definition of M is given operationally \nin a rather non-standard manner which makes exten sive use of renaming. This type of definition allows \nstatic scope of identifiers without the introduction of closures to handle procedures. The definition \nof M[S](e,s) is by cases on ~: (1) S is begin new x; B end --+ DROP(M[begin B xl end] (e,s ), X1) x \nwhere i is the index of the first program identi. fier not appearing in S, e, or VAR(S) and s = ADD(s,xl,ao) \n. (a. is a special domain element which is used as the initial value of program identifiers. ) (2) S \nis begin q:proc(=:~); K end; B end --+ M[begin B ql end] (e .s) 7 where i is the index of the first \nprocedure identifier not occuring in B or e and e,=ADD(e,,,qi:prOC (~:~) ; K ~ end ). q (3) S is begin \nBl; B2 end --+ M[begin B2 end] (e,MIB1] e,s)) (4) S is begin end --+s ,Vx:=t!v--+sv (5) Sis wheze s \n=ADD(DROP(S,X), x, I[t(s) ) (6) S is b~B1,B2 --+ MIB1](e,s) if scb M[B21(e,s) otherwise { (7) S is b*B \n--+ M[b*B](e,M[B] (e,s)) if scb s otherwise { (8) S is call q(=:~) --+ M[K ~ P](e,s) .. XP If q:proc(=:~); \nK end ~e, ( length (~)=length(=), and length (~)=limgth @) undefined otherwise [ Sometimes it will be \neasier to work with computation sequences than with the definition of M directly. A computation sequence \nC of the form C=(So,e,o,so). . .(Si,ei,si) . . . gives the st~~ement, environment and program state \nduring the i step in the computation of M[501feo,SO). Since the rules for generating com putatlon sequences \nmay be obtained in a straight forward manner from the definition of M, they will not be included here. \nThe meaning function M may be easily modified to give dynamic scope of identifiers. With dynamic scope \nwhen an identifi~ is referenced, the most recently declared active copy of the identifier is used. This \nwill occur with our model if we omit the renaming of variables which is used in clauses (1) and (2) in \nthe definition of M. Thus, for example, M[begin new x; B end] (e~s)=M[begin B endl(e,s ) where s =ADD(s,x,ao). \nUnless explicitly stated we will always assume static scope of identifiers in this paper. Partial correctness \nassertions will have the form {P} S {Q}/e where S is a program statemen~ P and Q are formulas of LA, \nand e is an environment. 2.1 Definition: {P} S {Q}/e is true with respect to I (1= }S {01/e iff  ., \n. V s,s [s~P~LOBAL(S,e)~VAR(s)AMIS] (e,s)=s --cQ]Q]. If ~ is a set of partial correctness assertions \nand every assertion in r is true with respect to I, then we writel=lr. To discuss the completeness of \nan axiom system independently of its assertion language we introduce Cook s notion of expressibility. \n2.2 Definition: L is expressive with respect to L= and I iff for al! S, Q, e there is a formula of L: \nwhich expresses the weakest precondition wp(s,e,Q)={s lMISl(e,s) is undefined or M[S](e,s)cQ} Note that \nwe could have alternatively used the strongest post condition SP(S,e,P)={MISl (e,s)ls~p}.) If LA is \nexpressive with respect to LE and I, then invariants of while loops and recursive proce dures will be \nexpressible by formulas of LA.. ~,t every choice of L , L , and I gives expresslblllty Cook demonstratesAthi~ \nin the case where the assertion and expression languages are both the language of Presburger Arithmetic. \nWand [WA76] gives another example of the same phenomenon. More realistic choices of L , L , and I do \ngive expressibility. IfL, and~na~e both the full language of number th~ory and I is an interpretation \nin which the symbols of number theory rece+tie their usual meanings, then L is expressive with respect \nto LE and I. Also , ifAthe domain of I is finite, expressibility is assured: 2.3 Lemma: If L A, LE are \nfirst order languages with equality and the domain of I is finite, then LA is expressive with respect \nto LE and I. If H is a Hoare like axiom system and T is a proof system for the assertion language LA \n(relative to I), then a proof in the system (H,T) will consist of a sequence of partial correctness assertions \n{P] S {Q}/e and fOrmulas Of LA each Of which is either an axiom (of H or T) or follows from previous \nformulas by a rule of inference (of H or T). If {P} A {Q}/e occurs as a line in such a proof, then we \nwrite F *T{P} S {Q}/e. In a similar manner, we may define r ~TA where r x and A are sets of partial \ncorrectness assertions. 2.4 Definition: A Hoare-like axiom system H for a programming language PL is \nsound and complete (in the sense of Cook) iff for all LA, LE, and I, s~h that (a) ~ is expressive with \nrepect to L E and I and (b) T is a complete proof system for L A with respect to I, F1{P} S {Q}/e<=>EH, \nT{P] S {Q}/e. 3. Recursive Procedures with Procedure Parameters. In this section we prove: 3.1 Theorem: \nIt is impossible to obtain a system of Hoare-like axioms H which is sound and complete in the sense of \nCook for a programming language which allows: (i) procedures as parameters of procedure calls (ii) recursion \n (iii) static scope (iv) global variables (v) internal procedures Remark: In section 4 we show that \nit is possible to obtain a sound, complete system of Hoare like axioms by modifying any one of the above \nfeatures. To obtain the incompleteness result, only proce dure identifiers are needed as parameters of \nprocedure calls. The incompleteness proof allows, in addition, variable parameters which are passed by \ndirect syntactic sufistitution. In order to prove the theorem we need the following lemma. 3.2 Lemma: \nThe Halting Problem is undecidable for programs in a programming language with features (i) -(v) above \nfor all finite inter\u00adpretations I with 11122. The proof of the lemma uses a modification of a result \nof Jones and Muchnick [J075]. Note that the lemma is not true for flowchart schemes or while schemes. \nIn each of these cases if III<CO the program may be viewed as a finite state machine and we may test \nfor termination (at least theoretically) by watching the execution sequence of the program to see if \nany program state is repeated. In the case of recursion one might expect that the program could be viewed \nas a type of pushdown automaton (for which the Halting Problem is decidable). This is not the case if \nwe allow procedures as parameters. The static scope rule, which says that procedure calls are elabo rated \nin the environment of the procedure call, allows the program to access values normally buried in the \nruntime stack without first popping the top of the stack. Formally, we show that it is possible to simulate \na queue machine which has three types of instructions, A) Enqueue x add the value of x to the rear of \nthe queue, B) Dequeue x -remove the front entry from the queue and place in x, and C) If x=y then go \nto L--conditional branch. Since the Halting Problem for queue machines is undecidable, the desired result \nfollows. The queue is represented by the successive activations of a recursive procedure sire with the \nqueue entries being maintained as values of the variable top which is local to sire . Thus an addition \nto the rear of the queue may be accomplished by having sire call itself recur sively. Deletions from \nthe front of the queue are more complicated. Sire also contains a local procedure up which is passed \nas a parameter during the recursive call which takes place when an entry is added to the rear of the \nqueue. In delet\u00ading an entry from the front of the queue, this parameter is used to return control to \nprevious activations of sire and inspect the values of top local to those activations. The first entry \nin the queue will be indicated by marking (e.g. negating) the appropriate copy of top . Suppose that \nthe queue machine program to be simulated is given by Q=l:INST1; . ..K.INSTk then the simulation program \n(in the language of Section 2) has the form sim:proc(:back); begin new top, dummy, progress; <declaration \nof local procedure up> progress:=l; while progress=l do begin if prog counter=l then INST1 else if p~og \ncounter=2 then INST2 else if prog counter=K then INSTk else null end; end; end sire; prog counter:=l; \ncall sim(:loop) ; The variable prog counter serves as an instruction counter for the p~~gram being simulated; \ninitially it is 1. The variable progress is used to indicate when control should be returned to the previous \nactivation of the procedure sire . The procedure loop diverges for all values of its parameters; it will \nbe called when an attempt is made to remove an entry from the empty queue. Declarations for prog counter \n, loop , and the program variables for ~he queue machine are omitted from the outline of the simulation \nprogram. The appropriate encoding for queue machine instructions is given by cases: (A) If INSTj is j: \nenqueue A then replace by: begin If prog counter=l then top:= A else top:=A; prog co;nter:=prog counter+l; \ncall-sim(:up); prOgress:=O; end Note that we are assuming that the first instruction in any queue program \nwill be an enqueue instruc tion. Also, statements of the form prog counter:= prog counter+l may be eliminated \nby intr~ducing a fixed number of new variables to hold the binary representation of prog counter . (B) \nIf INSTj is ?:deq~eue x then replace by: begin call back (x:dummy); *:= X; prog counter :=prog counter+l; \nend If the queue is not empty, b=ck will correspond to the local procedure up declared in the previous \nactivation of sire . On r~turn from the call on back the first parameter x will contain the value of \ntop in the first activation of Tsim . The second parameter of back ( up ) is only used when back ia called \nfrom within up (see Clescriprion of up below). (C) If INSTj is If Xp=x then go to n replace by: m begin \nIf X X thenppr~g counter:=n; else prog counter:=prog counter+l; end Finally, we must describe the procedure \n up which is used by sim in determining the value of the first element in the queue and deleting that \nelement: up:Proc (front_of_queue, first:) If top < 0 then be~in. front of queue:=top; first~=l~ end; \nelse begin call back (end of queue, first); If first=l th=n ~egin top:=-top; first:=O; end; end; end \nup; After a call on UP , the parameter front of queue will contain the value of top in ~he first activation \nof sire . The parameter first is used in marking the queue element which will hence forth be first in \nthe queue. This completes the description of the simula tion program. We now return to the proof of the \ntheorem. Suppose that there were a sound, complete Hoare-like axiom system H for programs of the type \ndescribed at the beginning of this section. Thus for all LA, LE, and I, if (a) T is a complete proof \nsystem for LA and I, and (b) LA is expres sive relative to L and I, then ~l{P} s {Q}/E ~=> ~H,T{p} s \n{Q}/E. This leads to a contradiction. Choose I to be a finite interpretation with III> 2. Observe that \nI may be chosen in a particularly simple manner; in fact, there is a decision procedure for the truth \nof formulas in L * relative to I. Note also that LA is expressive relative to LE and I; this was shown \nby the Iemrna in Section 2 since I is finite. Thus both hypothesis (a) and (b) are satisfied. From the \ndefinition of partial correctness, we see that {true} S {false]/$ holds iff S diverges for the initial \nvalues of its global variables. By the lemma above, we conclude that the set of programs S such that \n~l{true} S {false}/@ holds is not recursively enumerable. On the ocher hand since }I{truel S {falsel/O~> \n~H,T{true} S {false} /o, we can enumerate those programs S such that ~l{true} S{ false} /@hOlds (simply \nenumerate all possible proofs and use the decision proce\u00addure for T to check applications of the rule \nof consequence) . This, however, is a contradiction. The reader should note that the incompleteness result \nabove holds even if procedure calls of the form call P(. ..) ..) are disallowed. If such calls are allowed, \nthen the incompleteness result may be obtained without the use of explicit recursion i.e. for a language \nwith features (i), (iii), (iv), and (v) only. 4.1 Completeness Results. In order to obtain a sound and \ncomplete proof system we must first restrict the programming lan\u00adguage of Section 2 so that sharing is \nnot allowed; we require that whenever a procedure call of the form call q(=:~) is executed in environment \ne, all of the variables in = are distinct and no para meter in = is global to the declaration of q or \nto any procedure in e which may be activated indirectly by the call on q. A formal definition of sharing \nis given in [D075]. Once sharing has been disallowed a good axiom system may be obtained modifying any \none of the five features of Theorem 3.1. These results are summarized in Figure 1 at the end of the paper, \nNote that in the description of language 3, we must also disallow self application in procedure calls \n(e.g. calls of the form call P(. ..) ).) ). This restriction may be enforced by requiring that actual \nprocedure parameters be either formal proce\u00addure parameters or names of procedures with no pro cedure \nformal parameters. Such a restriction is unnecessary for languages 4, 5, or 6. In order to establish \nthe completeness results of Figure 1, sound and complete axiom systems must be given for languages (2)-(6). \nDue to space limi\u00adtations, we will only consider language 5 in this paper. However, similar axiom systems \nmay be given for languages 2, 3, 4, and 6. 4.2 The Range of a Statement. Consider the following program \nsegment: F:proc(y:p); If y>l then begin y:=y 2; call p(y:F); end; else y:=O end F; G:proc(w:q); z:=z+w; \ncall q(w:G); end G; Call F(x:G); Observe that the only procedure calls which can occur during the execution \nof the program segment are call F(x:G) and call G(x:F) . In general, let So be a statement and e. an \nenvironment; the range of% with respect to e is the set of pairs 4 <call qi(=:~), e,> for which there \nis a valid 1 computation sequence of the form: (So,eo,so), ..., (call qi(=:~),ei,si), . . . If static \nscope of identifiers is used, the range of a statement S with respect to environment e oo may be infinite. \nThis is because of the renaming at block entry which occurs in clauses (1) and (2) in the definition \nof M. If, however, dynamic scope is used, then the range of a statement (with respect to a particular \nenvironment) must be finite; in fact, there is a simple algorithm for computing the range of a statement. \nThe range of S with respect to environment e is given by RANGE(S,e,$) where the definition of RANGE(S,e,~) \nis given by cases on S: (1) S? bcgin new x; A cnd ---r RANGE(begin A end,e,m)  (2) S~ begin q:proc(j:~); \nL end; A end --+ RANGE(begin A end,e ,n) where e =add(e, q:proc(j:;); L end)  (3) S~ begin Al; A2 end \n--+ RANGE(begin A2 end, e, RANGE(A1,e,n)) (4) S= begin end --+m (5) S= z:=e --Hr  (6) S= b--+Al, \nA%ANGE(A2,e, RANGE(A1,e, n)), n)) (7) S= b*A --WANGE(A,e,n) (8) S= call q(a:P) --+  T, if <call q(~:~),e>en \nRANGE(K ~ ~,e,n ) where n =nu{<c~l! q(=:~),e>} and q:proc(=:~); K end ce, otherwise. [ This same property \nof dynamic scope provides a simple algorithm for determining if the execution of a statement S in environment \ne will result in sharing.  4.3 Cood Axioms for Dynamic Scope. The axioms and rules of inference in the \nproof system DS for language 5 (dynamic socpe of identi\u00adfiers) may be grouped into three classes: axioms \nfor block structure B1-B3, axioms for recursive procedures with procedure parameters R1-R6, and standard \naxhoms for assignment, conditional, while, and consequence H1-H4. Axioms for Block Structure: (El) {U&#38; \nAx=aO} begin A end {V<}/e x {U} begin new x; A end {~}/e where i is the index of the first program identi\u00adfier \nnot appearing in A, E, U, or V. (B2a) {U} begin A end {V}/eu{q:proc(~;~); K end} {U} begin q:proc(x:p); \nK end; A end {v}/e (B2b) {U} A {V}/el {U} A {V}/e2 provided that e1~e2 and e2 does not contain the declarations \nof two different procedures with the same name. (B3a) {U] A {V}/e {U} begin A end {V}/e (B3b) {U} Al \n{V}/e, {V} begin A2 end {W}/e {U} begin Al; A2 end {W}/e Axioms for Recursive Procedures with Procedure \nParameters: The first axiom R1 is an induction axiom which allows proofs to be constructed using induction \non depth of recursion. (R] ) {Uo}call FO(~O:?O){VO}/eO, ,.. ,{Un]call Fn(~n:Pn){Vn}/en ~ {UO}KO(~O) {VO}/e \n~,...,{Un}Kn(~n){Vne/e n {UO]call FO(zO:PO){VO}/eO,...,{Un}call Fn(~:?n]{Vn}/en Axioms R2 R6 enable an \ninduction hypothesis to be adapted to a specific procedure call. Before stating these axioms we define \nwhat it means for a variable to be inactive with respect to a procedure call. 4.3.1 Definition: Let procedure \nq have declara\u00adtion q:proc(x:p); K end . A variable y is active with respect to call q(~:~) in environment \ne, if y is either global to K ~ ~ or is active with ~; izespect to a call on a procedure in e from within \nK~~. If y is not active with respect to =. XP call q(=:~) then y is said to be inactive (with respect \nto the particular call). Similarly a term of the assertion language is inactive if it contains only inactive \nvariables. A substitution u is inactive with respect to call q(a:P) provided that it is a substitution \nof inactive terms for inactive variables. (R2) {U} call q(i:~) {V}/e {Uu} call q(~:P) {Vu} /e provided \na is inactive with respect to call q(~:~) and e. (R3) {U(rO)} call q(;:~) {V(ZO)} /e {IrO U(rO)} call \nq(=:~) {~~ V (rO)}/e 0 provided that rO is inactive with respect to call q(~:~) and e. (R4) {U} call \nq(~:~) {Vi/e {UAT} call q(=:~) {VAT}/e provided that no variable which occurs free in T is active in \ncall q(ii:~) . (R5) {U} call q(=:~) {V}/e {U~} call q(a:P) {Vj}/e Gx provided that no variable free \nin U or V occurs in ~ but not in the corresponding position of ~. (~ is the list of formal parameters \nof q. This axiom will not be sound if sharing is allowed.) (R6) {true} call q(=:~) {false}/{q:prOc(~:~);K \nsnd} provided_that length (=)#length (=) or length (~)# length (P). Standard Axioms for Assignment, Conditional, \nWhile, and Consequence. These axioms (H1 H4) are widely discussed in the literature and will not be stated \nhere. We illustrate the use of the above axioms by two examples. The first example illustrates dynamic \nscope of identifiers. The second example shows how procedure parameters may be handled. Example 1: We \nprove {true] begin new x; g:proc; z:=x; end; X:=l; begin new x; x:=2; call g; end; end; {z=2}/o Let e \nbe the environment {q:proc; Z:=x; end}. (1) {x=2AY=1} Z:=X {Z=2}/@ H1 (2) {X=2AY=1} call q {z=2]/e \nR1  (3) {y=l} begin x:=2; call q; end {z=2]/e Hl, B3 {x=1} begin new x; x:=2; call q; end {z=2}/e B1 \n (4) (5) {true} begin x:=1;   begin new x; x:=2; call q; end; end {z=2}/e I B3 Hl, (6) {true} begin \nnew x; q:proc; z:=x; end; X:=l; bQgin new x; x:=2; call q; end; end {z=2}/@ B1,B21 Note that if static \nscope were used instead of dynamic scope the correct post condition would be { Z=l} . Example 2: We prove \n{X=2XO+1A Z=()} F:proc(y:p); If y>l then begin y:=y-2; call p(y:F); end; else y:=O; end F; G:proc(w:q); \n~:=z+w; call q(w:G); end G; call F(x:G): {.?=xo2}/@ Let e be the environment containing the declara \ntions of F and G. Let Kl(p) and K2(q) be the bodies of procedures F and G respectively. Si&#38;ce the \nrange of call F(x:G) with respect to e consists of <call G(x:F), e> and <call F(x:G), e> it is sufficient \nto determine the effects of call G(x:F) and call F(x:G) when executed in environment e. We assume: (1) \n{y=2yo+l A Z=zo} call F(y:G) {Z=Zo+yo 2} /e and (2) {w=2wo+l A Z=zo} call G(w:F) {z=zo+(wo+l)2}/e. \n Using these assumptions it is straightforward to prove: -(3) {y=2yo+1 A Z=zo} K1(G) {z=zo+yo2}/e and \n(4) {W=2WO+1 A Z=zo} K2(F) {z=zo+(wo+l)2]/e By axiom Rl, we obtain (5) l{y=2yO+l A Z=zo} call F(Y:G) \n{z=zo+yo2 ]/e and (6) t{w=2wo+l A Z=zo} call G(w:F) {z=zo+(wo+l)2 }/e. By axiom R5 and line 5 (7) L \n{X=2wo+1 A .=ZO } call F(x:G) {Z=Z 0+W0 2 }/e By axiom R2 with the inactive substitution of O for Z. \nand X. for Wo, we get (8) . }{x=2xo+l A z=O] call F(x:G) {z=xO }/e Line 8 together with two applications \nof B2 gives the desired result. 5. Soundness. In this section we outline a proof that the axiom system \nDS for programs with dynamic scope of variables is eound. We show that if T is a sound proof system for \nthe true formulas of the assertion language LA then >D~,T{P} A {Qiie implies ~l{P} A {Q}/e. The argument \nuses induction on the structure of proofs; we show that each instance of an axiom is true and that if \nall of the hypothesis of a rule of inference are true, the conclusion will be true also. The only difficult \ncase is rule of inference RI for procedure calls. We assume that the hypothesis [Uo}call,Fo(~o:~o){Vo}/e \n,.. ,{Un}call Fn(=n:~n}{Vn}/en o \\{Uo} K(Po){Vo}/eo,..., {Un} Kn(Fn){Vn}/en of R1 is true and prove \nthat ~l{Ui] call F(=i:Pi){Vi}/ei must hold for lsi<n. Without loss of generality we also assume that \nthe proof used to obtain {Uo} K(Po){Vo}/eo ,.. .,{Unl K(Pn){Vn}/e n from {Uo}call Fo(20:Po){Vo}/eo,..,@n}call \nFn(~n:Pn) Vn}/e n does not involve any additional applications of the axiom for procedure calls. To \nsimplify the proof we introduce a modif: ed meaning function M.. Mj[S](e,s) is defined in J exactly \nthe same manner as M[S](e,s) if S is not a procedure call. For procedure calls we have Mj[call F(=:~)](e,s)=M \nj_l[K~~](e,s) if j>O, .. : F:proc(=:~); K end ~e, leng~hp(=)=length (~), and length (~)=length (~). \nMj[call F(~:~)](e,s) is undefined otherwise. Thus Mj agrees with M on statements for which the maximum \ndepth of procedure call does not exceed j-1. We also extend the definition of partial correctness given \nin Section 2. We write ~j{P] S {Q}/e iff Vs,s [scPAGLOBAL(S,e~VAR(s) AMj[S](e,s)=s +s cQ] In the following \nlemma we state without proof some of the properties of M.. J 5.1 Lemma: Properties of M.: (a) ~O{U} \ncall F(~:~){V}/~ for all U, F, V, e. (b) Suppose that ~ ~ A where ~ and A are sets of partial correctness \nof the form {P} A {Q}/e and the formulas of A are obtained from those in r without use of axiom R1. Then~j \nr implies ~j A.  (c) If ~j{U} K~~ {V}/e holds and the first  XP procedure in e with name F has declaration \nF:proc(~:~); K end , then ~ j+ {~}call F(~:~){V}/e must hold also. (d) If M[S](e,s)=s then there is \na k>O such that j~k implies M:[S](e,s)=s . 1 The proofs of-(a), (c), and (d) follow directly from the \ndefinitions of M.. The proof of (b) is 3 straightforward, since use of axiom R1 for proce\u00addure calls \nhas been disallowed. We return to the soundness proof for RI. By part (a) of the lemma \\O{Ui} call \nFi(=i:~i){Vi}/ei, Isi<n By the hypothesis of R1 and part (b) of the lemma, we see that ~j{Ui} call \nFi(~ i:Fi){Vi}/ei, l<i<n implies ~J{Ui] Ki(Pi){Vi}/ei, l<i<n. By part (c) of the lemma,   }j{ui} call \nFi(Zi:~i){Vi}/ei, l<i<n implies ~j+l{Ui}call Fi(=i:~i){Vi]/ei, l<i<n. (b) Hence, by induction we have \nfor all j20 \\{F~=FoAu&#38;}Fo(ao:~o){Sp(call Fo(~o:Fo), eo, call \\3{Ui} call Fi(<i:~i){Vi}/ei, lsisn. \nLet scUi and suppose that s =M[call Fi(=i:~i)](e,s) then there is a k>O such that j>k implies M<[call \nF~(=X:~, )](e, s)=s . Since till Fit=i :Fi){Vi}/e, we conclude that $j{Ui] Thus ~l{Ui} call Fi(=i:~i){Vi}/ei \nholds for l<isn and the proof of soundness is complete for RI. We leave the proof of soundness for the \nother,axioms and rules of inference to the interested reader. 6. Completeness. In this section we outline \na proof that the axiom system DS is complete in the sense of Cook. Let T be a complete proof system for \nthe true formulas of the assertion language LA. Assame also that the assertion language LA is expressive \nwith respect to the expression language L and E interpretation 1. We prove that F1{U} S {V}/e implies~5 \n~{Ul S {v}/e. The proof uses induction on ~he structure of the statement S and is a generalization of \nthe completeness proof for recursive procedures with out procedure parameters given in [G075]. Due to \nthe length of the proof we will only consider the case where S is a procedure call; other cases will \nbe left to the reader. Assume that {Uo} call Fo(=o:~o){Vo}/eO is true. We show that {Uo} call F(~O:~o){Vo}/eo \nis provable. Let call F1(=l:~l) , .,., call Fn(~n:~n) be the procedure calls in the range of call Fo(~o:~O) \nand let e be the i environment corresponding to call Fi(~i:Pi) . We assume that Fi has declaration F:proc,(=i:Fi); \nKi end g that ii is the list of variables which are active in call Fi(~ i:Pi) , and that ~, is the list \nof variables which are L active in call Fi(~i:~i) . Finally, we choose :. to be a list of new variables \nwhich are 1 inactive in call Fi(=i:~i) . We will show that {ri=ci}call Fi(~i:Pi){Sp(call Fi(~i:~i),ei,{~i=~i})~/ei \n-. /.1 is provable for all i, IsiSn. From this result it follows that {Uo}call FO(~o:~o){Vo}/eo is also \nprovable. To see that this part of the argument is correct. observe that by axiom R5 and properties of \n5P. o {;~.~o})AU&#38;}/eo by axiom R4. 6 (c) }{E~o[~~=~(U~l} call Fo(30:P~{I ~o[SP(call o (~o:Fo),eo, \n{E~=;o})AU&#38;l] }/e. r by axiom R3. (d) }I=OISP(call Fo(~O:~o),eo,{=~=~~ )AujQl --+ r; SP(call FO(~o:~o),eo,Uo) \nby properties of SP since the variables of ~. are are inactive in call Fo(~o:~o) and (e) t{LJo} call \nFo(=o:Po){SP(call Fo(~o:Po), eo, Uo)]/eO by rule of consequence. (f) tSP(call F o (~ o:PO),eo,UO)--+V \nsince o ~{Uo] call Fo(30:Po){Vo}/eo and SP(call Fo(~o:~o),eo,Uo) is the strongest post condition corresponding \nto U and call Fo(~o:~o) ~ ,. o (g) \\{LJo} call Fo(=o:~o){Vo}/eo by (e), (f), and the rule of consequence. \nIt is still necessary to prove 7.1. To shorten notation, let Ti={ii=~i} and Wi={Sp(call Fi(=i:~i),ei, \n{~i=~i})}. We shOw that {To]call Fo(Zo:~o){Wo}/eo, ..,{Tn}call Fn(=n:~n){Wn}/e \\{ To}Ko(Po){Wo}/eo,..., \n{Tn}Kn(Pn){Wnenen 7.2 The proof of 7.1 will then follow by the axiom RI for procedure calls. Proof of \n7.2 is by induction on the structure of Ki using an induction hypothesis which is some what more general \nthan what we need to prove. 7.3 Lemma: Let K be a statement and let T and W be predicates such that ~ \n{T} K {W}/e and such that the rangeof K with respect to e is included in <call Fo(=o:~o),eo>, . . ..<call \nFn(=n:~n),en>, then {To}call Fo(~o:~o){Wo]/eo,..,{Tn}call Fn(=n:~n){Wn}/er l-{T} K {W}/e Proof: Proof \nis by induction on the structure of K. We will only consider the case where K is a proce dure declaration \ni.e. K~ begin q:proc(=:~);L end; S end . If ~ {T} K {W}/e then we must alsO have ~{T} K {W}/e where \nK = begin S end and e = add(e, q:proc (=:~);L end ). Note that the range of K with respect to e is included \nwithin the ange of K with respect to e. By the induction hypothesis we have that {To}call Fo(~o:~o){Wo]/eo, \n..,{Tn]call Fn (=n:~n){Wn]/e n l-{T}K {W}/e . By axiom B2, we see that {To}call Fo(~o:Po){Wo}/eo, . . \n..{Tn}call Fn(=n:~n){Wn}/en t{T} K {W}/e . Other cases in the proof of lemma 7.3 are left to the interested \nreader. Note that once lemma 7.3 has been established, 7.2 follows from the observation that ~ {Ti} Ki(~i){Wi}/e. \nl<i<n. 1 7. Coroutines. A coroutine has the form coroutine: Ql, Q2 end . ~1 is the main routine; execution \nbegins in Q1 and also terminates in Q1 (this requirement satisfies the axiom for coroutines). Otherwise \nQ1 and Q2 behave in identical manners. If an exit statement is encountered in Q1, the next statement \nto be executed will be the statement following the last resume statement executed in Q2. Similarly, execution \nof a resume statement in Qcauses 2 execution to be restarted following the last exit statement executed \nin QIf the exit (resume)1 statement occurs within a call on a recursive procedure, then execution must \nbe restarted in the correct activation of the procedure. A formal operational specification of the semantics \nfor coroutines is given in [cK76]. If recursive procedures are disallowed, a sound and complete axiom \nsystem may be obtained for the programming language of Section 2 with the addition of the coroutine construct. \nSuch a system, based on the addition of auxiliary vari ables, is described in [CK76a]. The axiom for \nbhe coroutine statement is similar to the one used by Clint [CL73]. However, the strategy used to obtain \ncompleteness is different from that advocated by Clint; auxiliary variables represent program counters \n(and therefore have bounded magnitude) rather than arliitrary stacks. 7.1 Theorem: There is a Hoare like \naxiom system H for the programming language described above, including the coroutine construct but requiring \nthat procedures be non recursive, which is both sound and complete in the sense of Cook. 8. Coroutines \nand Recursion.  We show that it is impossible to obtain a sound complete system of Hoare like axioms \nfor a programming language allowing both coroutines and recursion provided that we do not assume a stronger \ntype of expressibility than that defined in Section 2. (We will argue in Section 9 that the notion of \nexpressibility introduced in Section 2 is the natural one. We will also examine the consequences of adopting \na stronger notion of expressibility.) Let L be the c,r programming language with the features described \nin Sections 2 and 7 including both parameterless recursive procedures and the coroutine statement. 8.1 \nLemma: The Halting problem for programs in the language L is undecidable for all finite c,r interpretations \nI with 11122. Proof : We will show how to simulate a two stack machine by means of.a program in the language \nL c,r. Since the Halting problem is undecidable for two stack machines, the desired result will follow. \nThe simulation program will be a coroutine with one of its component routines controlling each of the \ntwo stacks. Each stack is represented by the successive activations of a recursive procedure local to \none of the routines. Thus , stack entries are maintained by a variable top local to the recursive procedure, \ndeletio,n from a stack is equivalent to a procedure return, and additions to a stack are accomplished \nby recursive calls of the procedure. The simulation routine is given in outline form below: Prog counter:=l; \nCoro;tine begin stack l:proc; new top, progress; progress:=l; while progress=l do; if prog counte r=l \nthen INST1 else if prOg counter=2 then INST2 else . if piog counter=K then INSTK else NULL; end; end \nstack 1; call stack_l~ end , begin stack 2:proc; new top, progress; progress:=l; while progress=l do \n if prog counter=l then INST~ else if prog counter=2 then INST~ else . if piog counter=K then INST~ else \nnull; end end stack 2; call stack_2~ end; end; where INST ,. , . INST , INST*vl INST~ are 1 K 1 ... \nencodikgs of the program for the two stack machine being simulated. Thus, for example, in the procedure \nSTACK 1 we have the following cases: (1) if INSTj i= PUSH X ON STACK_l, INSTj will be begin top=x; prog \ncounter :=prog counter+l; call stack_l; end; (2) If INSTj is POP X FROM STACK 1, INSTj will be begin \nprog counter:=prog counter+l; X:=top; progress:=O; end; (3) If INST. is PUSH X ON STACK_2 or POP X FROM \nSTACK 2: INSTj will simply be begin exit; end; A similar encoding INST* .INST~ for the copy of 1 .. the \nprogram within procedure stack 2 may be given. 8.2 Theorem: It is impossible to obtain a system of Hoare \nlike axioms H for the programming language L which is sound and complete in the sense of c,r Cook. The \nproof is similar to the proof of Theorem .-,. -.,\u00adLwi>j .-. LooK, S.A. . . Axlomatlc . .\u00adand interpretative \n3.1 and will be omitted. Semantics for an Algol Fragment. Techni\u00ad cal Report 79, Computer Science Dept., \nUniversity of Toronto, 1975 (to be 9. Dicussion of Results and Open Problems. published in SCICOMP). \nA number of open problems are suggested by the above results. An obvious question is whether [DE73] deBakker, \nJ.W. and L.G.L.Th. Meertens. On there are other ways of restricting the program the Completeness of \nthe Inductive Asser\u00ad ming language of Section 2 so that a sound and tion Method. Mathematical Centre, \nDec. complete set of axioms can be obtained. For 1973. example, from Section 4 we know that such an axiom \nsystem could be obtained simply by disallow [D074] Donahue, James. Mathematical Semantics as ing global \nvariables. Suppose that global vari\u00ad a Complementary Definition for Axioma\u00ad ables were restricted to \nbe read only instead of tically Defined Programming Language entirely disallowed, would it then be possible \nto Constructs, in Donahue et al. , Three obtain a sound and complete axiom system? Automata Approaches \nto Reliable Software: Language theoretic considerations merely show that the type Design, Dyadic Specification, \nof incompleteness argument used in this paper is Complementary Semantics. Technical Report not applicable. \nCSRG-45, Computer Systems Research Group, In the case of coroutines and recursion the University of Toronto, \nDec. 1974. most important question seems to be whether a stronger form of expressibility might give [G075] \nGorelick, G. A Complete Axiomatic System completeness. The result of Section 7 seems to for Proving Assertions \nabout Recursive require that any such notion of expressibility be and Non recursive Programs. Technical \npowerful enough to allow assertions about the Report No. 75, Computer Science Dept., status of the runtime \nstack(s ). Clint [CL73] University of Toronto, Jan. 1975. suggests the use of stack-valued auxiliary \nvari ables to prove properties of coroutines which [H0691 Hoare, C.A.R. An Axiomatic Approach to involve \nrecursion. It seems likely that a nbtion Computer Programming. CACM~, 10 of expressibility which allowed \nsuch variables (October 1969), pp. 322-329. would give completeness. However, the use of such auxiliary \nvariables appears counter to the spirit [H071] Hoare, C.A.R. Procedures and Parameters: An of high level \nprogramming languages. If a proof Axiomatic Approach. Symposium ~ of a recursive program can involve \nthe use of Semantics of Algorithmic Languages, E. stack valued variables, why not simply replace Engeler, \nE=, Springer Verlag, Berlin, the recursive procedures themselves by stack pp. 102-116, 1971. operations? \nThe purpose of recursion in program\u00ad ming languages is to free the programmer from [H074] Hoare, C.A.R. \nand P.E. Lauer. Consistent the details of implementing recursive constructs. and Complementary Formal \nTheories of Finally we note that the technique of Sections the Semantics of Programming Languages. 6 \nand 8 may be applied to a number of other Acts Informatica, Vol. 3, pp. 135-154, programming language \nfeatures including (a) call 1974. by name with functions and global variables, (b) unrestricted pointer \nvariables with retention, [J074] Jones, N.D. and S.S Muchnick. Even Simple (c) unrestricted pointer variables \nwith recursion, Programs Are Hard to Analyze. TR-74-6, and (d) label variables with retention. Al 1 Computer \nScience Department, University these features present difficulties with respect of Kansas, November 1974 \n(to be published to program proofs, and (one might argue) should in JACM). be avoided in the design of \nprogramming languages suitable for program verification. References [cK76] Clarke, Jr., E. M. Programming \nLanguage Constructs for Which it is Impossible to Obtain Good Hoare like Axioms. Technical Report No. \n76 287, Computer Science Department, Cornell lJniv., August 1976. [CK76a] Clarke, Jr., E. M. Pathological \nInteraction of Programming Language Features. Tech nical Report CS 1976 15, Computer Science Dept., Duke \nUniversity, Sept. 1976. [CL75] Clint, M. Program Proving: Coroutines. Acts Informatica, Vol. 2, pp. 50 \n63, 1973. Language 1 Language 2 Language 3 Language 4 Language 5 Language 6 (1) procedures procedure \nwith parameters inc. no proce dure pa rameters inc. inc. inc. inc. (2) (3) recursion global variables \ninc. inc. inc. inc. no recur\u00adsion, no self ap plication inc. inc. global variables disallowed inc. inc. \n.. inc. inc. (4) static scope inc. @c. inc. inc. dynamic scope inc. (5) internal procedures inc. inc. \ninc. inc. inc. internal procedures not allowed Sound and Hoare like system? Complete axiom no yes yes \nyes yes yes Figure 1 THEOREM SUMMARY  \n\t\t\t", "proc_id": "512950", "abstract": "Hoare-like deduction systems for establishing partial correctness of programs may fail to be complete because of (a) incompleteness of the assertion language relative to the underlying interpretation or (b) inability of the assertion language to express the invariants of loops. S. Cook has shown that if there is a complete proof system for the assertion language (e.g. all true statements of the assertion language) and if the assertion language satisfies a certain natural expressibility condition, then sound and complete axiom systems for a fairly large subset of Algol may be devised. We exhibit programming language constructs for which it is impossible to obtain sound and complete sets of Hoare-like axioms even in this special sense of Cook's. These constructs include (i) recursive procedures with procedure parameters in a programming language which uses static scope of identifiers and (ii) coroutines in a language which allows parameterless recursive procedures. Modifications of these constructs for which it is possible to obtain sound and complete systems of axioms are also discussed.", "authors": [{"name": "Edmund Melson Clarke", "author_profile_id": "81100393517", "affiliation": "Duke University Durham, N. C.", "person_id": "P74802", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512952", "year": "1977", "article_id": "512952", "conference": "POPL", "title": "Programming language constructs for which it is impossible to obtain good hoare-like axiom systems", "url": "http://dl.acm.org/citation.cfm?id=512952"}