{"article_publication_date": "01-01-1977", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1977 ACM 0-12345-678-9 $5.00 ELIMINATION OF SINGLE PRODUCTIONS FROM LR PARSERS IN CONJUNCTION WITH THE \nUSE OF DEFAULT REDUCTIONS (Extended Abstract) Eljas Soisalon-Soininen Department of Computer Science, \nUniversity of Helsinki To610nkatu 11, SF-OO1O Helsinki 10, Finland 1. INTRODUCTION One of the most attractive \ntechniques in opti\u00admizing LR parsers is to eliminate reductions by semantically insignificant productions \nof the form A + X (single productions), where X is a nonter\u00adminal or a terminal; such a modification \ncan lead to substantial savings in both space and time. Therefore, much effort has been devoted to the \nde\u00advelopment of methods for eliminating reductions by single productions from LR parsers (Aho and Unman \n[1973a,1973bl, Anderson, Eve and Horning[1973], Pager[1973a,1974], Demers[1974,1975], Backhouse [1976], \nJoliat[1976], Koskimies[1976], LaLonde [19761, Soisalon-Soininen[1976]). Anderson, Eve and Horning[1973] \nhave described a method by which all reductions by single produc\u00adtions can be eliminated from LR parsers, \nbut their method may produce a considerable increase in the number of states in the parser. On the other \nhand, with the techniques of Aho and Ullman[1973b] and Demers[1975] no increase in the number of states \ncan occur, but the elimination of reductions by single productions is guaranteed only if no two single \nproductions have the same left hand side. Pager[1973a,1974] has extended the method ofAho and Ullman[1973b] \nso that all reductions by single productions are eliminated. LaLonde[1976] and Backhouse[1976] consider \nversions of the method of Pager, and Joliat[1976] considers a method which is essentially that given \nby Anderson, Eve and Horning[1973] as a suggestion for simplifying their general technique. In Anderson, \nEve and Horning[19731 the elimin\u00adation of reductions by single productions is per\u00adformed during the construction \nof the LR parser, whereas in Wo and Ullman[1973b] and in Pager [1973a,19741 reductions by single productions \nare eliminated after construction of the parser. Demers [1975] considers versions of Mo and Unman s method \nsuch that elimination can be performed both during and after construction of the parser, and LaLonde[1976] \ndescribes a version of Pager s method by which reductions by single productions can be eliminated during \nparser construction. Except the method of Anderson, Eve and Horning [19731 all the above techniques rely \nheavily on the fact that in LR parsing certain error entries can never be consulted. However, dependence \nupon these don t care entries leads to some difficulties in the practical use of the techniques. First, \nthey may not be applicable for all types of LR parsers: the method of Pager[1973a,1974] produces a parser \nwhich accepts exactly the strings in the language in the case of canonical (Knuth[1965]) and SLR (DeRemer[19711) \nparsers but may produce a parser which accepts erroneous strings in the case of LALR parsers (used e.g. \nby LaLonde[1971], .Johnson[1975], Joliat[1975]) and generalizations of them (Pager [1973b,19751, Soisalon-Soininen[1975]). \nFurthermore, certain other parser optimizations may decrease the number of don t care entries, and these \noptimiza\u00adtion need special treatment if they are to be applied in conjunction with the elimination of \nre\u00adductions by single productions. One well known method for optimizing LR parsers, which is extreme\u00ad \nly useful &#38;pecially in list representation of LR parsers and which may decrease the number of don \nt care entries is the use of default reductions (if one or more reduce actions are possible in some state \nthen one of these reduce actions is chosen for the default reduction which is performed instead of reporting \nerror; see Pager[1973a], Aho and Johnson[1974], Horning[1974], Aho[1976]). The problem in the use of \ndefault reductions in conjunction with the elimination of reductions by single productions is discussed \nin Pager[1973a] and a method is given there to solve the problem. The basis of the solution is to apply \nfirst the algo\u00adrithm for eliminating reductions by single produc\u00adtions and then to check every potential \ndefault re\u00adduction in order to decide whether it can be used or not. Hence, in the optimized parser all \nreduc\u00adtions by single productions are eliminated, but the use of default reductions can be limited. (Pager \n[1973a] has found that in the case of some practi\u00adcal grammars almost all of potential default reduc\u00adtions \ncan be used.) In the present paper we consider another ap\u00adproach to the problem. In our method the elimin\u00adation \nprocess itself corresponds to the technique of Pager[1973a,1974 , but the elimination is carried out \nonly if it does not affect the appli\u00adcability of default reductions. The main motivation of this approach \nis the fact that it leads to a method for eliminat: ng reductions by single produc\u00adtions which is applicable \nfor any type of LRparser, including LALR parsers and generalizations of them. The rest of the present \npaper is organized as follows. Section 2 contains some terminology and a brief review of the theory of \nLR parsing. In sec\u00adtion 3 we c6nsider the method of Pager[1973a,1974] in a form similar to that given \nby LaLonde[1976] and show by an example that the method may produce invalid parsers in the case of the \nLALR construc\u00adtion. Finally, our method for eliminating reduc\u00adtions by single productions in conjunction \nwith the use of default reductions is given in section 4. 2. BACKGROUND In this section we shall briefly \nreview the basic notions of grmars and LR parsing following Aho and Ullman[197Z,1975a,1973bl and Aho[19761. \nA (contezt-j%ee) grma~ is a four-tuple G = (N,x,P,S), where N and z are finite disjoint sets of nonterminal \nand terminal symbols, respect\u00adively, P is a finite set of productions of the form A+awhere AisinNanda \nin (Nux)*, andSinN is the start symbo2. We shall assume that the pro\u00adductions are numbered 1,2,. ..,p \nin some order. By convention (i) A, B and C denote nonterminals in N, (ii) a, b, c andd denote terminals \nin X,  (iii) X, Y and Z denote nonterminals or ter\u00adminals, (iv) terminal strings, i.e. strings in E* \nare represented by u,v,... ,z , whereas strings in (NUX)* are represented bya,~,y, . . ..mj (v) the empty \nstring is denoted by e. If A+ a is a production in P, then for all ~ and y we write BAY + @y and say \nthat BAY directly derives bcry. If y is in z*, then this derivation is said to be rightmost, and we write \n~AY ~ DXY. The relations +*, derities, and 7*, derives rightmost, denote the reflexive and transitive \nclosures of * and ~ , respectively, whereas -+ and ~+ denote the transitive closures of a and ~. The \nLanguage defined by G, denoted L(G), is the set {w I S +* w}. We assume that every symbol X in NUX is \nuseful in the sense that for each X there is some derivation of the form S ** aXB -* w, and we also assume \nthat A -+ A for no nonterminal A. A right sentential form of G is a string a such that S 7* a. If S ?* \naAw~ aBw, then a prefix of a~ is said to be a viable p~efiz of G. Let S = YO,Y1, . . ..Yn = w be a sequence \nof right sentential forms such that for O s i < n, Yi = aiAiwi, =.aiPiWi and Ai -Di is produc\u00ad y.1+1 \ntion pi of G. In this sequence we say that yi+l is reduced to yi using the production Ai + Bi. The se\u00adquence \nof productions pn_1pn_2. ..p1po which can be used to reduce w to S is called a right parse of w according \nto G. That is, a right parse is the re\u00adverse of the sequence of productions used in a rightmost derivation. \nA (right) parser or parsing a2gorithm for G is a function that maps a sentence in L(G) into a right parse \nand a string not in L(G) into an error message. Let Ial denote the length of the string a, and let Z*k \ndenote the set of strings w in X* such that Iwl < k. We define FIRSTk(a) to be the set of all w in X*k \nsuch that either a ** w or Iwl = k and a ** wx for some x. Similarly, we define FOLLOWk(a) to be the \nset of all w in X*k such that s +* Bwy and w is in FIRSTk(y). The LR(k) parsing algorithm is based on \na set of LR(k) tables each of which is a pair of functions T = (f,g) such that: (i) f, the parsing action \nfunction, maps Lookahead strings, i.e. strings in E*k, to the ac\u00adtions ~h.i&#38;t, emok, atctpt, and \nfieduc~ i, where i is the number of a production in P. (ii) g, thegoto function, maps the set NUZ to \nthe set of tables and the word error.  We shall now consider techniques for construc\u00adting sets of LR(k) \ntables. Let G = (N,z,P,S) be a grammar. If S is a sym\u00adbol not inNUZ, we say that G = (Nu{S },X, Pu{S \n+ S},S ) is the augmented gramnar for G. An LR(k) item for G is a pair [A+ a..~,u], where A + a~ is a \nproduction in the augmented grammar G and u is a string in 2*k. The item [A + a.~,u] is said to be valid \nfor a viable prefix y if there exists a derivation S 7* bAw ~ ba~w in G such that Y = ba andu = FIRSTk(W). \nLet I be a set of LR(k) items. The eZosure of I is defined to be the least set I satisfying: (i) IgI \n; (ii) if [A-a.BR,u] is in I , then [B+ .Y,v] is in I for all B+y in P and all vinFIRSTk(Ru). The function \nGOTO(I,X) is defined as follows. Let I be a set of items and let I be the set of items {[A + aX.D,u] \nI [A + o..XB,U] is in I}. Then the set GOTO(I,X) is the closure of I . We can extend the function GOTO \nto strings in (NUX)* in the obvious way, viz. (i) GOTO(I, e) = I (ii) GOTO(I,aX) = GOTO(GOTO(I,a) ,X). \n To construct sets of LR(k) tables for a given grammar G we first construct a collection of sets of \nLR(k) items. A2go~ithm 1 (Construct the canonical collection). The canonical collection C of sets ofLR(k) \nitems for a grammar G can be computed as follows. 1. Let 10 be the closure of the set {[S + .S,el}, \nwhere S +S is the starting produc\u00adtion of the augmented grammar G . 10 is called the initial set of items. \n2. Let C initiallybe the set {l.}; then apply step 3 until no new sets of items can be addedto C. 3. \nFor each set of items 1 and for each X in Nuz, compute I = GOTO(I,X). Add I to C if I is non-empty and \nnot already in C. 0  Let I be a set of LR(k) items. We define CORE(I) to be the set {[A+ a.~1 I [A+ \na.B,u] is in I}. The LALR(k) collection of sets of items for a grammar G is that which is produced by \nAlgorithm 1 if step 3 is replaced by the following: 3 . For each set of items I currently in C and for \neach X inNUZ, compute I = GOTO(I,X). If I is non-empty and CORE(I ) # CORE(J) for all J cur\u00adrently in \nC, add I to C. If CORE(I ) = CORE(J) for some J in C, replace J in C by JUI . Finally, we consider the \nSLR(k) method for con\u00adstructing a collection of sets of LR(k) items. Algorithm 2 (Construct the SLR(k) \ncollection). The SLR(k) collection of sets of items for a gram\u00admar G can be computed as follows. 1. \nUsing Algorithm 1 construct C, the canonical collection of sets of LR(0) items for G. 2. For each set \nI in C replace every item of the form [A+ a.~,el by the items [A+ a.i3,u] for all u in Follow. The resulting \ncollection of sets of LR(k) items is the SLR(k) collection. 0  LR(k) tables can be constructed by the \nfollow\u00ading algorithm. A2gorithm 3 (Construct an LR(k) table from a set of LR(k) items). The algorithm \nconstructs an LR(k) table T = (f,g) from a set of LR(k) items I in a collection C. The parsing action \nfunction f is con\u00adstructed as follows: 1. If [A+a.. ,ul is in I, andA+a isnot S + S, then f(u) = heducc \ni, where i is the number of production A + a. 2. If [A+ a.a~,u], where a is a terminal sym\u00adbol, is in \nI, then f(v) = Jhi&#38;t for all v in FIRSTk(a~u). d.z If [S -+S.,e] is in I, then f(e) is accept. 4. \nf(u) = wok otherwise. If f(u) is not uniquely defined for some u in Z*k, then a parsing action conflict \nis generated by I and no table is produced for I. The goto function g is constructed as follows. 5. If \nGOTO(I,X) is not empty, then there are two cases to consider. (~) If the collection C con\u00adtains only \nsets of items such that CORE(J) # CORE(J ) for anyJ andJ in C, J # J , then g(X) is the name of the table \nconstructed from a set of items I in C such that CORE(I ) = CORE(GOTO(I,X)) . [B+d.,a/b] 16: (b) Otherwise, \ng(X) is the name of the table ton\u00ad[S+ Aa.,e] 17: strutted from GOTO(I, X). [S+ Bb.,e] 6. If GOTO(I,X) \nis empty, then g(x) = UZAOJL. 0 18: [S+aA.b,e] The table constructed from the initial set of 19: items \nis called the initial table. [A+ B.,b] 110: If no parsing action conflict occurs, then the [A+c. ,b] \n111:  set of LR(k) tables constructed from the canonical [B+d. ,b] collection of sets of LR(k) items \nfor a grammar G 112: will be called theeanoniea2 setofLR(k) tables for G [S +aAb. ,el 113: and the grammar \nG will be called an LR(k) grmar. Since CORE(Ii) = CORE(Ij) only if i = 5 and Similarly, if no parsing \naction conflict occurs, j = 11 or i = 6 and j = 12, the LALR(l) collection then the set of LR(k) tables \nconstructed from the of sets of items for G contains the following sets LALR(k) collection (SLR(k) collection) \nof sets of 1 of items: J items for a grammar G will be called the LALR(k) o = 10 1 = 11 2 = 12 J3 = \n13 J4=I ~,J5=15uI ~1, J6 = 16U112, J7 = 17, set (SLR(k) set) of tab2es for G and the grammar G will be \ncalled an LALR(k) grammar (SLR(k) grmar). 8 = 18 9 = 19 1O = 110 11 = 113 Since FOLLOW,(S) = {e} and \nFOLLOW,(A) = Example 1. Consider the grammar G1 with productions FOLLOW1(B) = {a,;}, the SLR(l) collec~ion \nof sets (1) S+Aa of items for G. is: (2) S+Bb [S -+ .S,e]  (3) S+aAb o: [S+ .Aa,e]  (4) A+B [S+ .Bb,e] \n (5) A+c [S+ .aAb,e]  (6) B+d  1 [A+ .B,a/b] We first list the canonical collection of sets of [A-+ \n.c,a/b] LR(l) items for G1. The notation [B+ .d,a/b] [A+o..13,al/a2/.../aml is short for the items [S \n+ S.,e] [A+ a.~,all, . . ..[A+a.i3.aml. 1: [S +A.a,e] 2:[S + .S,e] 10: [S+ B.b,e] [S+ .Aa,e] 3: [A \n+ B.,a/b] [S+ .Bb,e] [S-+ .aAb,e] [S +a.Ab,e] K4 : [A+ .B,a] [A+ .B,a/b] [A+ .c,a] [A+ .c,a/b] [B+ \n.d,a/b] [A+ .d,a/b] [S + S.je] [A+c.,a/b] 11:  5: [S +A.a,e] [B+d.,a/b] 2: 6: 13: [S A B.b,e] K7 \n: [s + Aa.,e] [A+ B.,a] [S +Bb.,e] 8: [S + a.Ab,e] 14: [S+aA.b,e] 9: [A+ .B,b] [A+B.,a/b] [A+ .c,b] \nlo: [B+ .d,b] [S +aflb.,e] 11: [A+ c.,a] 15: The canonical set of LR(l) tables for G1 con\u00adstructed \nfrom the canonical collection of sets of LR(l) items is shown in Fig. 1, and the set of LALR(l) tables \nconstructed from the LALR(l) collec\u00adtion is shown in Fig. 2. (Throughout this paper LR(k) tables are \nshown as rows, with columns for the arguments of f and g. The following code is used for table entries: \nblank = emok, a = acctpk, s = bll.i~t, i = ,Vzduct i.) An attempt to construct the set of SLR(l) tables \nfrom the SLR(l) collection of sets of items leads to a parsing action conflict because of the set of \nitems K3. n Corresponding to the function GOTO(I,a), where I is a set of LR(k) items, we define for each \nLR(k) table T the function Goto(T,a) as follows. (i) Goto(T,e) = T (ii) If T = (f,g), then Goto(T,X) \n= g(X) for allXinNUX. (iii) Goto(T, aX) = Goto(Goto(T, a), X), if Goto(T,a) # ettoh; otherwise Goto(T,oX) \n= wok. If TO is the initial table in the canonical, LALR(k), or SLR(k) set of LR(k) tables for a gram\u00admar \nG and Y is a viable prefix of G, then it is well known that the set of LR(k) items correspond\u00ading to \nthe table Goto(TO,y) contains all those items which are valid for the the viable prefix Y. On the other \nhand, every string y such that Goto(TO,y) # QWLO L is a viable prefix of the gmn\u00admar G. In the case of \nthe canonical set of LR(k) tables every item in the set of LR(k) items corre\u00adsponding to a table Goto(TO,Y) \nis valid for the viable prefix y. The preceding example shows that this need not be true for the LALR(k) \nset of tables, since the set of items J5 corresponding to Goto(RO,ac) contains the item [A + c.,al which \nis not valid for the viable prefix ac. However, [A+ c.,al is valid for the viable prefix c for which \nGoto(RO,c) = Goto(~O,,ac). In fact, for the LALR(k) set of tables every item in the set of LR(k) items \ncorresponding to a table Goto(TO,Y) is ,. valid for some viable prefix Y such that Goto(TO,y ) = Goto(TO,y). \nFinally, for the SLR(k) set of tables this need not be true, but neverthe\u00adless every item in the set \nof LR(k) items corre\u00adsponding to a table Goto(TO,Y) is valid for some viable prefix of the grammar G. \naction goto abed e SABabcd To s Ss Tl T2T3Tq T5T6 Tl s rr~ T2 T3 4s 8 Ss T T4 T9 lo 11 T12 5 T5 T6 66 \nT7 T8 T9s T13 4 Tlo 5 Tll 6 T12 3 T13 Figure 1. Canonical set of tables. action goto abcde SABabcd R. \ns Ss RI R2 R3 R4 5 6 Rl a R2 s R7 R3 4s R8 Rti Ss R9 Rlo R5 R6 R5 55 R6 66 R7 1 8 2 R9 s % o 4 Rll \n3 $%gura 2. LALR(l) set of tables. We shall now give a formal specification of the LR(k) parsing algorithm. \nLet U be a set of LR(k) tables for a grammar G = (N,z,P,S). We define the LR(k) parser using U by specifying \nthe action of the parser, and the in\u00aditial and accepting configurations. A configuration of the LR(k) \nparser for G is a triple (TOT1 . . .Tm , w, IT), where TO, Tl,..., Tm are inu and T is the initial table, \nw is in z*, and ~ is o a sequence of production numbers. The action of the LR(k) parser is the relation \n~ defined on con\u00adfigurations as follows. Let (ToT1. ..Tm, w, 11) be a configuration such that Ti = (fi,gi) \nfor O s i s m, and let u = FIRSTk(w). 1. If fro(u) = .Ati&#38;t, w = aw , and g(a) = T, then (ToT1. ..Tm, \nw> ~) 1-(ToT1. ..TmT, w , n). 2. If fro(u) = fi~duct i, and production i is A+ o., where lal = r, then \n(TOT1. . .Tm, w, n) \\ (ToT1. ..Tm_rT> w, Iii), where T is ~_r(A). 3. If fro(u) is e,ttofi or uccapl, \nthen there is no configuration C such that (TOT1...Tm, w, n) ~ c. h initial configu~ation of the parser \nis a configuration of the form (TO, W, e). A confi~r\u00ad ation (TOT1, e, n) is said to be an accepting \ncon\u00ad figuration if T1 = (f,g) and f(e) = accept. Let \\*be the reflexive transitive closure of f. If (To, \nw, e) }* (TOT1, e, H), where (TOT1, e, ~) is an accepting configuration, we say that the LR(k) parser \naccepts the string w and outputs the pro\u00ad duction sequence H. If U is the canonical, LALR(k), or SLR(k) \nset of LR(k) tables for G, then the LR(k) parser for G using U accepts a string w and outputs the right \nparse of w if and only if w is in L(G). If (To, W, e) E* (ToT1. ..Tm, w , n), where (ToT1. ..Tm, w , \nH) is not an accepting con\u00ad figuration, and there is no configuration C such that (ToT1. ..Tm, w , n) \nl--C, then we say that the configuration (ToT1. ..Tm , w , n) is the error indi\u00ad catio~z and the string \nw is the error indication string for w. In order to use default reductions as de\u00ad scribed e.g. in Aho \nand Johnson[1974] the follow\u00ad ing modification of LR(k) tables must be possible. Let U be a set of LR(k) \ntables for a grammar G. For each T = (fjg) in U having one or more reduce actions do the following. \n1. Select one production, say i, such that f(u) Laducz i for some U. 2. For each lookahead string v \nsuch that f(v) = ttiok replace f(v) by fiacluca i.  tie say that the resulting set of tables, de\u00adnoted \nUd, has been constructed from U for the use of def a?{Lt reductions. It is well known that if U is the \ncanonical, LALR(k), or SLR(k) set of LR(k) tables for G, then the LR(k) parser using Ud ac\u00adcepts a string \nw and outputs the right parse ~ of w if and only if the LR(k) parser using U does so. In addition, for \nstrings not in L(G) the error de\u00adtection point with regard to the input string is unchanged if U is used \ninstead of U, i.e. when d using Ud a string w is the error indication string for a string w not in L(G) \nif and only if w is the error indication string for w when using u.  3. MOTIVATION We shall now describe \nthe method of Pager [1973a,1974] for constructing a set of LR(k) tables for a gramnar G so that the \nLR(k) parser using this set of tables does not make reductions by single productions, i.e. productions \nof the form A+ X where X is a terminal or a nonteminal. Thus, when accepting a string w, the LR(k) parser \noutputs a production sequence which can be ob\u00adtained from the right parse of w by deleting the numbers \nof single productions. Our definition of Pager s method is similar to that given by LaLonde [1976]. We \nmoilify the definition of the closure of a set of LR(k) items and the definition of the function GOTO, \nand use these modified forms in\u00adstead of the closure and the GOTO function in the algorithms for constructing \ncollections of sets of LR(k) items. Let G = (N,l,P,S) be a grammar, let I be a set of LR(k) items for \nG, and let Ps be some set of single productions in P. The Ps-free closure of is defined to be the set \nof all those LR(k) items which (i) are included in the closure of I and (ii) are not of the form [A+ \n.X,u] such that A + X is a production in Ps. In order to define the modified GOTO function, denoted by \nGOTO , we need the following definition: for each X in NUZ ~, if Ps contains aproduc\u00ad tion X+ Y for some \nY [ CHAIN(X) = {X} U{A\\Aderives Xby single productions in P s I otherwise If we assume that in the definition \nof the GOTO function the P~-free closure is used instead of the closure, then we can define the function \nGOTO (I,X) for each set of LR(k) items I and each symbol X in NUZ as follows. GOTO (I,X) = ZECH!IN(Y) \nOTO(l z) where Y is a symbol such that CHAIN(Y) contains the symbol X. (Note that such a symbol Y always \nexists but need not be unique.) If the Ps-free closure and the function GOTO are used instead of the \nclosure and the GOTO func\u00adtion in the algorithms for constructing a collec\u00adtion of sets of LR(k) items, \nthen the LR(k) parser using the corresponding set of tables will not make reductions by single productions \nin Ps. How\u00adever, the LR(k) parser using the set of tables constructed from the modified LALR(k) collection \nof sets of items for a grammar G may accept strings not in L(G). To see this consider the grammar G1 \nof Example 1: (1) S+Aa (2) S+Bb (3) S+aAb (4) A+B (5) A+c [6) B+d   If Ps = {A + B}, then the collection \nof sets of items obtained by the LALR(l) construction using the Ps-free closure and the function GOTO \nis: [S + .S,e] 10: [S+ .Aa,e] [S+ .Bb,e] [S+ .aAb,e] [A+ .c,a] [B+ .d,a/b] 11: [S + S.,e] [S +A.a,el \n12: [S + B.b,e] [S + a.Ab,el 13: [A+ .c,b] [B+ .d,b] 14: [A+c.,a/b] [B +d.,a/b] ls: [S +Aa.,e] 16: \n[S+ Bb.,e] 17: [S + aA.b,el 18: [S+aAb. ,e] 19: The set of LR(l) tables constructed from this col\u00adlection \nof sets of items is shown in Fig.3. action goto abcde SABabcd  To s Ss TI T2 T2 T3 T4 T5 T1 a T2 Ss \n 6 7 T3 Ss 8 8 T4 5 T4 55 T5 66 T6 1 T7 2 T8 s T9 T 3 3 F-igztre 3. Set of LALR(l) tables without \nreductions by single productions in Ps . Evidently the string cb is not in L(G1), yet it is accepted \nby the LR(l) parser for G1 using the set of tables in Fig. 3: (To, cb, e) 1-(TOT4, b, e) &#38; (TOT2, \nb, 5)  l-(T0T~T~>e%52) 5) I-(T~T~>e> On the other hand, if a set of LR(l) tables U for G1 has been \nconstructed from the collection of sets of items obtained by the canonical construc\u00adtion using the Ps-free \nclosure and the functiori GOTO , then the LR(l) parser for G1 using U accepts exactly the strings in \nL(G1). However, the LR(l) parser for G1 using a set of tables constructed from U for the use of default \nreductions will accept the string cb. 4. ELIMINATING REDUCTIONS BY SINGLE PRODUCTIONS IN CONJUNCTION \nWITH THE USE OF DEFAULT REDUCTIONS In this section we present a modification of the method of Pager[1973a,1974] \nand LaLonde[19761 for eliminating reductions by single productions. The advantage of the modification \nis that the use of default reductions will not cause the parser to accept erroneous strings. This implies \nfurther that our method will produce also in the case of the LALR(k) construction a parser which accepts \nexactly the strings in the language. The basis of our method for eliminating reduc\u00adtions by single productions \nis to modify further the definition of the closure of a set of LR(k) items. Instead of the Ps-free closure \nwe define another modification which excludes from the clo\u00adsure only those items of the form [A + .X,ul \nthe elimination of which does not affect the applica\u00adbility of default reductions. We shall restrict \nourselves in this section to the case k = 1. Let G = (N,z,P,S) be a gramnar. We first define a set DC(I,A) \n(default-correct don t care) for each set of LR(l) items I and for each A in N. To do this we use an \nauxiliary set H(I,aX) which is de\u00adfined for each aX in (NU.Z)* and contains only ter\u00adminal symbols of \nG. A terminal b is in H(I,aX), if for each BY in (NUX)*, such that X + BY is a pro\u00adduction of G, one \nof the following three conditions is met: (i) GOTOII,aBYb) is non-empty. (ii) GOTO(I,CXL3) = GOTO(I,Y) \nfor some prefix Y of ao, Iyl < ICX!31. (iii) BY # e andb is in H(I, aBY). We define the set DC(I,A) \nto be H(I,A). Exump2e 2. Consider the grmar G1 of Example 1. For the initial set of LR(l) items 10 for \nG1 the set DC(IO,A) is emPtY, since A + c is a production of G1 and GOTO(IO,ch) = @ for each terminal \nsym\u00adbol h. 0 Example 3. Consider the grammar G2 with productions s-l BaA s-l B A+ dS B+ b  The canonical \ncollection of sets of LR(l) items for this grammar is: l.: [S + .S,e-] [S+ .BaA,e] [S+ .B,e] [B+ .b,a/e] \n [S + S.je] 11: [S +B.aA,e] 12: [S +B.,el [B +b.,a/e] 13: [S + Ba.A,e] 14: [A+ .dS,e] [S+ BaA.,e] 15: \n[A+d.S,e] 16: [S+ .BaA,e] [S+ .B,e] [B+ .b,a/e] [A-dS. ,e]17: The terminal a is in DC(IO,S), since \nGOTO(IO,Ba) = 14 is not empty and a is in H(IO,BaA). The set H(IO,BaA) is equal to the set H(IO,BadS) \nwhich con\u00adtains a, since GOTO(IO,BadBa) = 14 # @ and GOTO(IO,BadBa) = GOTO(IO,Ba). On the other hand, \nthe terminal a is the only symbol in DC(IO,S). Similarly, DC(16,S) = {a}. 0 Ewunp~e 4. Consider the usual \ngrammar GO for arith\u00admetic expressions containing the binary operators +and *: E+E+T E-T T+TyF T+F F+ \n(E) F-a  The initial set of LR(l) items for this grammar is: [E + .E,el 10: [E+ .E+T,e/+1 [E+ .T,e/+] \n[T+ .T*F,e/+/*] [T+ .F,e/+/*] [F+ .(E),e/+/*1 [F+ .a,e/+/*] In order to conclude that * is in DC(IO,E) \nfirst note that GOTO(IO,T*) # g. Since GOTO(IO,E+) con\u00adtains the items [T + .T*F,e/+/*1, the set GOTO(IO,E+T*) \nis not empty, either, and thus * is in DC(IO,E). Furthermore, * is the only symbol in DC(IO,E). 0 ~AJe \nshall now state our modification of the definition of the closure of a set of LR(l) items. Let P~ be \na set of single productions of a grmar G = (N,z,P,S)~ let I be a set ofLR(l) items for G, and let J denote \nthe closure of I. The defau2t-correct Ps free closu~e of I is de\u00adfined to be the set of all those LR(l) \nitems which are included in J except any item [A -+ .X,a] such that A + X is in Ps and the following \ncondition is met: if [X + .B,b] is in J and [A + .X,b] is not in J, then b is in DC(J,A]. The set of \nproductions A + X such that [A+ .X,a] for some terminal a is in the closure of a set of LR(l) items I \nbut not in the default\u00adcorrect Ps-free closure of I is denoted by PSD(I). Example 5. Let Ps = {A+ B} \nfor the grammar G1 of Example 1. The default-correct Ps-free closure of the item [S + .S,e] is equal \nto I the closure of o [S + .S,e], since 10 contains item [B+ .d,b] but does not contain item [A -+ .B,b], \nand b is not in DCIIO,A) = o. The default-correct Ps-free closure of the item [S + a.Ab,e] is [S + a.Ab,e] \n[A+ .c,b] [B+ .d,b] since for A+ Band B+ d the closure of [S+a.Ab,e] contains only the items [A+ .B,b] \nand [B + .d,b]. 0 Ex@pZe 6. Consider the grammar G2 of Example 3, and let Ps = {S + B}. Although the \nclosure of [S + .S,e] contains item [B+ .b,a] and does not contain item [S + .B,a], the default-correct \nPs\u00adfree closure of [S + .S,e] is [S + .S,e] [S+ .BaA,e] [B-.b,a/el since a is in DC(IO,S), where 10 \nis the closure of [S + .S,e]. 0 Example 7. If Ps = {E + T, T + F} for the grammar GO then the default-correct \nPs-free closure of [E + .E,e] is [E + .E,e] [E+ .E+T,e/+] [T+ .T*F,e/+/*] [F+ .a,e/+/*] [F+ .(E),e/+/*] \n Note that the items [E + .T,e/+] have been excluded when constructing this set from l., the closure \nof [E + .E,el, since * is in DC(IO,E). n We proceed by defining the sets CHAIN(I,X) and GOTO (I,X) for \neach set of LR(l) items I and for each X in NUT. The definitions correspond to those of CHAIN(X) and \nGOTO (I,X) in the previous section. ~, if PsD(I) contains a pro\u00adduction X+Y for some Y [ CHAIN(I,X) = \n {X} U{AI A derives Xby single { 1 productions inPsD(I)}, otherwise If we assume that in the definition \nof the GOTO function the default-correct Ps-free closure is used instead of the closure, then we can \ndefine the function GOTO (I,X) as follows. u GOTO (I,X) = GOTO(I,Z), ZECHMN(I,Y) where Y is a symbol \nsuch that CHAIN(I,Y) contains the symbol X. If the default-correct Ps-free closure and the function GOTO \nare used instead of the closure and GOTO function in the algorithms for constructing a collection of \nsets of LR(l) items, then we say that the resulting collection of sets of items and the corresponding \nset of LR(l) tables are optimized with defau2t-correct elimination of single produc\u00adtions in Ps. Examp2e \n8. By Example 5 the LALR(l) collection of sets Of LR(l) items for G1 optimized with default\u00adcorrect elimination \nof single productions in Ps can be obtained from the LALR(l) collection given in Example 1 by deleting \nthe set JIO and deleting the item [A+ .B,b] from J4. As demonstrated in Examples 6 and 7 for initial \nsets of LR(l) items we may conclude that collections of sets of LR(l) items for G2 and Go optimized with \ndefault-correct elimination of single productions in Ps do not con\u00adtain sets with items of the form [A-+ \n.B,a], i.e. all desired single productions are eliminated. n Since our method eliminates reductions by \nsingle productions as the methods of Pager [1973a,19741 and LaLonde[19761 but may only leave some reductions \nuneliminated, we may conclude by the proofs in Pager[1973a] and LaLonde[1976] that in the case of the \ncanonical construction our method is correct in the following sense. A+X reductions by which have been \neliminated. (i) A set of LR(l) tables canbe constructed Mmeover, the symbol b must be included in the \nset without parsing action conflicts from the canoni-DC(I,A), where I is the set of items corresponding \ncal collection of sets of LR(l) items for a gram-to the table Goto(TO,y). But this means by the mar G \noptimized with default-correct elimination definition of the set DC(I,A) that the following of single \nproductions in Ps, if this can be done condition holds. For each terminal string x such from the canonical \ncollection of sets of items for that A +* x there exists a viable prefix y~b sat- G. isfying:  (ii) \nThe LR(l) parser for GusinE the canoni\u00ad A-+B~*x. cal set of tables optimized with default-correct r \nThus no string Yxby such that A +* x can be re\u00ad elimination of single productions in Ps accepts a duced \nto yAby, even if the lookahead symbol for string w if and only if w is in L(G). In this case reducing \nwere not checked. Hence we can conclude the parser will output a sequence IT which is the that no invalid \nactions for yA according to Ud can right parse of w less some single productions in be performed. 0 Ps \n. The following theorem implies that the valid-The above theorem implies further that the ity of the \nmethod is not affected by the use of LR(l) parser for a gramnar G using the LALR(l) set default reductions. \n(SLR(l) set) of tables U optimized with default\u00ad correct elimination of single productions in Ps, or \nThmrem. Let U be the canonical set of LR(l) a set of tables Ud constructed for the use of tables for \na grammar G = (N,X,P,S) optimized with default reductions from U, will accept exactly the default-correct \nelimination of single productions same strings as the LR(l) parser using the LALR(l) in ps L p, and let \nUd be a set of tables con\u00adset (SLR(l) set) of tables without elimination. structed from U for the use \nof default reductions. This is due to the fact that the set of tables Ud If the LR(l) parser for G using \nUd accepts a can be obtained by merging compatible tables from string w, then so does the LR(l) parser \nusing U. a set of tables constructed for the use of default Olltli?ze of proof. Assume that the LR(l) \nparser for reductions from the canonical set of tables for G G using Ud accepts some string not accepted \nby the optimized with default-correct elimination of LR[l) parser using ~. Since Ud has been obtained \nsingle productions in Ps. from U by changing certain error actions to reduce It is obvious that computing \nthe sets DC(I,A) actions, this means that following some reduction during the construction of a collection \nof sets of an invalid action is performed. In other words, items may be inefficient, but a similar concept \nmay then there must exist a viable prefix yA of G such be defined on a set of tables so that the default\u00adthat \nin Ud the table Goto(TO,yA), where TO is the correct elimination of single productions can be initial \ntable, contains actions being neither performed after constructing the set of tables. error actions nor \nreduce actions substituted for However, if we desire to perform elimination during error actions, although \nwhen using the canonical the construction of a collection of sets of items, set of tables an error would \noccur. In this case we may restrict ourselves to an easily computed we say that there exist invalid actions \nfor the subset of DC(I,A). We might define viable prefix YA according to Ud. We shall show that slthough \nsuch invalid actions may exist they DC (I,A) = {al GOTO(I,aXa) # @ for all aX such that there is a will \nnot be executed. production A+ aX } Let YA be a viable prefix of G, and suppose that b is a symbol-on \nwhich there exists an in- By using DC (I,A) instead of DC(I,A) in defining valid action for YA. By the \nconstruction of a set the default-correct Ps-free closure we obtain a of tables optimized with default-correct \nelimin\u00ad method which is capable of eliminating all the re\u00adation of single productions in P then there \nmust quired single productions in many practical cases, s exist another viable prefix YX and a production \ne.g. the grammar GO. ACKNOWLEDGMENTS The author shares the credit with Seppo Sippu for finding the grammar \nG1 that was the initial motivation of this work. Thanks are also due to him and Kai Koskimies for several \nuseful dis\u00ad cussions. Finally, I wish to thank Kari-Jouko Raiha and Mikko Saarinen for their helpful \ncom\u00adments on the manuscript. This work was supported by a research project investigating translator writing \nsystems. The pro\u00adject is led by Professor Martti Tienari and spon\u00adsored by the Academy of Finland. REFERENCES \nAho,A.V. [1976] Language theory in compiler design, in App2ied Computation Theory: Analysis, De sign, \nMod@Zing (ed R.T.Yeh), 185-237. Prentice Hall, Englewood Cliffs, N.J. Aho,A.V. &#38; S.C.Johnson [1974] \nLR parsing. Computing Survays 6:2, 99-124. Aho,A.V. &#38; J.D.Ullman [1972] The Theory of Parsing, Translation, \nand L ompiZing, VOZ.1: Parsing. Prentice Hall, Englewood Cliffs, N.J. Aho,A.V. &#38; J.D.Ullman [1973a] \n!i %e Theory of Paining, Translation, and Compiling, VOZ.11: CompiZing. Prentice Hall, Englewood Cliffs, \nN.J. Aho,A.V. &#38; J.D.Ullman [1973b] A technique for speeding up LR(k) parsers. SIAM J. Computing 2:2, \n106-127. Anderson,T. , J.Eve &#38; J.J.Horning [1973] Efficient LR(l) parsers. Aeta Informatica 2:1, \n12-39. Backhouse,R.C. [1976] An alternative approach to the improvement of LR(k) parsers. Aeta Informatica \n6:3, ?77-296. Demers,A.J. [19741 Skeletal LR parsing. IEEE Con\u00adferwcee Reeoyd of 15th AnnuaZ Symposium \non Switching and Automata Theory, 185-198. Demers,A.J. [19751 Elimination of single produc\u00adtions and \nmerging nonterminal symbols of LR(l) grmars. Computer Languages 1:2, 105-119. DeRemer,F.L. [1971] Simple \nLR(k) grammars. Corn. ACM 14:7, 453-460. Horning,J.J. [19741 LR parsers and analysers, in COT?P[kF Construction. \nan Advanced CouFse, Lecture Notes in Computer Science, VOZ. 21 (eds F.L.Bauer &#38; J.Eickel), 85-108. \nSpringer- Verlag, Berlin-Heidelberg-New York. Johnson,S.C. [1975] YACC -yet another compiler\u00adcompiler. \nComputing Science Technical Report 32, Bell Laboratories, Murray Hill, N.J. Joliat,M.L. [1975] The BIGLALR \nparser generator system. Central Laboratory, Bell-Northern Research Ltd., Ottawa, Ontario. Joliat,M.L. \n[1976] A simple technique for partial elimination of unit productions from LR(k) parsers. IEEE Trans. \nComput. (Corresp.) C-27:7, 763-764. Knuth,D.E. [1965] On the translation of languages from left to right. \nInformation and Control 8:6, 607-639. Koskimies,K. [1976] Optimization of LR(k) parsers (in Finnish). \nM.SC. Thesis, University of Helsinki, Helsinki. LaLonde,W.R. [1971] An efficient LALR parser gen\u00aderator. \nReport CSRG-2, University of Toronto, Toronto. LaLonde,W.R. [1976] On directly constructing LR(k) parsers \nwithout chain reductions. Conference Record Third ACM SIGACT-SIGPLAN Symposium on Principles of Programming \nLanguages, 127-133. Pager,D. [1973al On eliminating unit productions from LR(k) parsers. Technical Report \nPE 245, University of Hawaii, Honolulu. Pager,D. [1973bl The lane tracing algorithm for constructing \nLR(k) parsers. Proc. 5th AnnuaZ ACM Symposium on Theory of Computing, 172-181. Pager,D. [1974] On eliminating \nunit productions from LR(k) parsers, inAutomata, Languages and Progrming, 2nd ColZoquiwn, Lecture Notes \nin Computer Science, VOZ. 14 (ed J.Loeckx), 242-254. Springer-Verlag, Berlin-Heidelberg-New York. Pager,D. \n[19751 A practical general method for constructing LR(k) parsers. University of Hawaii, Honolulu. Soisalon-Soininen \n,E. [197s] On constructing LR parsers. Unpublished manuscript. Soisalon-Soininen,E. [1976] Design of \nan automatic constructor of LR parsers (in Finnish). Internal report 1976/27, Department of Com\u00adputer \nScience, University of Helsinki, Helsinki.  \n\t\t\t", "proc_id": "512950", "abstract": "<p>One of the most attractive techniques in optimizing LR parsersis to eliminate reductions by semantically insignificantproductions of the form A &#8594; X (single productions), where X isa nonterminal or a terminal; such a modification can lead tosubstantial savings in both space and time. Therefore, much efforthas been devoted to the development of methods for eliminatingreductions by single productions from LR parsers (Aho and Ullman[1973a,1973b], Anderson, Eve and Horning[1973], Pager[1973a,1974],Demers[1974,1975], Backhouse [1976], Joliat[1976], Koskimies[1976],LaLonde [1976], Soisalon-Soininen[1976]).</p><p>Anderson, Eve and Horning[1973] have described a method by whichall reductions by single productions can be eliminated from LRparsers, but their method may produce a considerable increase inthe number of states in the parser. On the other hand, with thetechniques of Aho and Ullman[1973b] and Demers[1975] no increase inthe number of states can occur, but the elimination of reductionsby single productions is guaranteed only if no two singleproductions have the same left hand side. Pager[1973a,1974] hasextended the method of Aho and Ullman[1973b] so that all reductionsby single productions are eliminated. LaLonde[1976] andBackhouse[1976] consider versions of the method of Pager, andJoliat[1976] considers a method which is essentially that given byAnderson, Eve and Horning[1973] as a suggestion for simplifyingtheir general technique.</p><p>In Anderson, Eve and Horning[1973] the elimination of reductionsby single productions is performed during the construction of theLR parser, whereas in Aho and Ullman[1973b] and in Pager[1973a,1974] reductions by single productions are eliminated afterconstruction of the parser. Demers [1975] considers versions of Ahoand Ullman's method such that elimination can be performed bothduring and after construction of the parser, and LaLonde[1976]describes a version of Pager's method by which reductions by singleproductions can be eliminated during parser construction.</p><p>Except the method of Anderson, Eve and Horning [1973] all theabove techniques rely heavily on the fact that in LR parsingcertain error entries can never be consulted. However, dependenceupon these \"don't care\" entries leads to some difficulties in thepractical use of the techniques. First, they may not be applicablefor all types of LR parsers: the method of Pager[1973a,1974]produces a parser which accepts exactly the strings in the languagein the case of canonical (Knuth[1965]) and SLR (DeRemer[1971])parsers but may produce a parser which accepts erroneous strings inthe case of LALR parsers (used e.g. by LaLonde[1971],Johnson[1975], Joliat[1975]) and generalizations of them (Pager[1973b,1975], Soisalon-Soininen[1975]). Furthermore, certain otherparser optimizations may decrease the number of don't care entries,and these optimizations need special treatment if they are to beapplied in conjunction with the elimination of reductions by singleproductions. One well known method for optimizing LR parsers, whichis extremely useful especially in list representation of LR parsersand which may decrease the number of don't care entries is the useof default reductions (if one or more reduce actions are possiblein some state then one of these reduce actions is chosen for thedefault reduction which is performed instead of reporting error;see Pager[1973a], Aho and Johnson[1974], Horning[1974],Aho[1976]).</p><p>The problem in the use of default reductions in conjunction withthe elimination of reductions by single productions is discussed inPager[1973a] and a method is given there to solve the problem. Thebasis of the solution is to apply first the algorithm foreliminating reductions by single productions and then to checkevery potential default reduction in order to decide whether it canbe used or not. Hence, in the optimized parser all reductions bysingle productions are eliminated, but the use of defaultreductions can be limited. (Pager [1973a] has found that in thecase of some practical grammars almost all of potential defaultreductions can be used.)</p><p>In the present paper we consider another approach to theproblem. In our method the elimination process itself correspondsto the technique of Pager[1973a,1974], but the elimination iscarried out only if it does not affect the applicability of defaultreductions. The main motivation of this approach is the fact thatit leads to a method for eliminating reductions by singleproductions which is applicable for any type of LR parser,including LALR parsers and generalizations of them.</p><p>The rest of the present paper is organized as follows. Section 2contains some terminology and a brief review of the theory of LRparsing. In section 3 we consider the method of Pager[1973a,1974]in a form similar to that given by LaLonde[1976] and show by anexample that the method may produce invalid parsers in the case ofthe LALR construction. Finally, our method for eliminatingreductions by single productions in conjunction with the use ofdefault reductions is given in section 4.</p>", "authors": [{"name": "Eljas Soisalon-Soininen", "author_profile_id": "81100634467", "affiliation": "University of Helsinki, T&#246;&#246;l&#246;nkatu 11, SF-0010 Helsinki 10, Finland", "person_id": "P76898", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512967", "year": "1977", "article_id": "512967", "conference": "POPL", "title": "Elimination of single productions from LR parsers in conjunction with the use of default reductions", "url": "http://dl.acm.org/citation.cfm?id=512967"}