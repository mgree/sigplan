{"article_publication_date": "01-01-1977", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1977 ACM 0-12345-678-9 $5.00 SYMIXILIC EVALUATION AND THE GLCBAL VALUE GRAPH by John H. Reifl and Harry \nR. Lwis2 Center for Research in Computing Technology Harvard University Summarv . This paper i s concer \nned with difficult global flew poblans which require the symbolic evaluation of prograns. W use, as is \nconnmn in global flw analysis, a model in which the expressions ccmputed are specified, bu t the flew \nof contrml is indicat ed o nly by a directed graph whose nodes are block s of assignment statements. \nWe s how that if smh a ~ogran rmdel is interpreted in the dcmain of integer arithmetic then many natural \nglobal fla ~oblems are unsolvable. We then develop a direct (non-iterative) method for finding general \nsymbolic values for progran expressions. Our method Qves r esults simi lar to an i terat ive method due \nto Kildall and a direct method due to Fong, Kam, and Unman. E&#38; means of a structure called the global \nva lU e graDh which compactly represents both symbolic values and the flew of these values thrmgh the \nprogran , w are able to obtain results that are as strong a s e ither of these algorithm a t a lower \ntime cost, bile retaining appliwbility to all flew graphs. 1. Introduction. Th is paper is concerned \nwith the problem o f symbolic Walu ation in the context of a glchal flew model of canputation. Thus the \nonly statements In the progranting language retained in the model are ass~nment statcrne nts whos e left-hand \nsides are variables and whose right-hand sides are expressions built up from fixed sets of variables, \nfunction s%3ns, and constant signs. The language does not Tovide for SW ra ti nlng, and all i ntrapr \nogrm control flew is reduced to a directed graph indi eating which block S of assignment stataents may \nbe, reached frcm which others, but giving no info~a tion aba t the condi ti Ons under 1. Research sup~rted \nby AFPA grant 738-7367. 2. Research supmrted by NSF grant MCS76-09375.  which such branches rrd.gh \nt occur. Ncw in this context we MSan by symbolic evaluation the task of disc ove ring, for each expression \nt in the program text, an expression 0. for the value of t which is valid for all possible executions \nof the program. Such an expressi on o will be said to cover t. Note that lexically identic al expressio \nns located at different positicns in the program text may WS1l have different covers ; thus t must be \nconsidered to be !!t%@d!l ~th its location in the program. Such an expression t, considered as located \nat a particular position in the program, is called a text . expressi on. Kildall[Ki] presents varicus \nexpression optimizationstr for inproving the efficiency of ob>ct code derived frcm text expressi ens. \nMary, bu t not all, of Kildall s expression optimizations reduce to the problem of constructing cove \nrs for text expressions. 1) A text expression t is constant if t has a cover which is a constant sign. \n2) The birth point of a text expression t is the earlie st node in the flew graph (relative to the partial \nordering of nodes by duni nati on discussed belcw) at which the computation of t is defined. Any node \nn OT the fl~ graph occuring be ween (relative to this danlnation ordering) the birthpoint of t and the \noriginal location of t has a cover for t in terms of covers for the variables atn. The earliest suh node \nn, with the further pr q erty that the computation of t induces no nW errors at node n, is called the \nsafepoint of t. The canputat ion of t my safely be moved to the safepo int n. (The text expression appropriate \nat node n nay not be lexically identical to t. ) The safety of code movement is also discussed in [CA, \nG, Kel,R]. 3) Text expression tl is redundant wi th respect to text expression t2 if tl occurs in the \nsane block as t2 and tl is covered by the sane formula as t2. 4) A cover for a global variable on exit \nfrom a node in a loop is a ~ invariant. This problem isd icussed in detail in Fong and Ullnan[FU] and \nkkgbreit[W] . 5) The available expressions at node n are the c cmp utations which ocmr on every executtin \npath fran the start node to n. Varims algcrithns [A, C, GW,HU, KUl, Ke2, Ke3, S, T4, U] have been developed \nfor solvi ng we asyll versions of global fl m problems where the transformations through blocks can be \ncanputed by bit vector operations. Expression optinizations ~Y give considerably more powerful result$ \nthan the easier code improvements. Hcwever, w s hal 1 demonstrate that it is not possible in general \nto c cmpute exact soluticns of Kildall s expression optiniza tion problems in the arithme tic dana in \n(Kam and Ullman[K12] have recently danonstrated that t here exist global flew problems pseci in certain \nglobal flw a naly sis franewo rks which are ~ solvable) . It follows that we must lock for heuristic \nmethods for good, but not optimal, solu tions to these problems . In order to canpare ar methods with \nothers we must fix the relevant parameters of the program and fl a graph. W let n and a be the cardinality \nof the node and edge sets, respec tively , of the flw graph; we let u be the number of variables in the \np-ogran ; and let L be the length of the program text. Our careful considerate ion of the paraneter L \navoiding, for example, r edundant repre~ ntations of the sme expression -i s one of the chief n ove lt \nies of our appro ach ; previas authors have analyzed their algorithms primarily fran the point of view \nof the flew graph parameters n and a. (If w hilt into the programming language a construct for the declaration \nof variabl es local to a b lock , then the paraneter o here ckld be the number of For the seke of simplicity \nwe do not make this refinement, but the interested reader will have no difficulty in seeing hcw cur time \nbands cculd be tightened in this way. ) Q@Q ~riables. Kildall[Ki] presents an algoritti, based on an \nterative method, for Canputing a ppr oxima te solu tions to variws expressi on optimization ~oblcms. \nA version of the Kildall algorithn used for the di w,overy o f c onst ant text expressi ons may r equire \nn(u(!+a)) elaentary steps and Q(ua) operations on bit vectors of 1 engt h 0(01). (Q (f(x) ) is a function \nbounded frcm below by k-f(x) for some k . See Knuth[Kn2] .) Fong and Ullrmn [FU ] show that the, Kildall \nalgorithn discovers on] restri cted c lass of constan t text expressions wk will be called sinple constants. \nFigure 1 .give~ example of a text expression which is constant is not a sinple constant. FIGURE 1 Kildall \ns algorithr my also be used ccmpute a certain class of covers, which we w call mininal fixed point covers \nForg, Kam, . Ullman[FKU] give another algori thn , based c direct (nonite!% tive) w thod which gives \nwea results than Kildall s algorithm and is restric to reducible flm graphs. Kildall s algorithn require \nQ(!n2) elementary steps and Fong, Kam, Unman s algorithn may rquire Q(La log( elaentary steps. A main \ninefficiency of both these algori thns is in the representation of cove rs. Directed acyclic graphs (dags) \nare used represent expressi ens, but separate dags are nee at each node of the flew graph. Since a representi~ \na cover may b.e of size Q(L) the tc space cost may be n(l.n). Varicus operations these dags, which are \nconsidered to be extend steps by Forg, Kam, and Ullman[FKU], cost 0 elementary steps and cannot be implanented \nby fixed number of bit vector operations. In gener any globs flm algorittm for symbolic evaluat which \nattempts to p301 information separately each node of the flow graph will have time cost Q(!?. a), s ince \nthe pools on ever-y pair of adjac nodes must be canpared. Since L z n, s~h a t cost is unaccep table \nfor practic al applications. The global mlue _ (GVG) used in t paper is related to a strut ture used \nSchwa rtz[Sc] to represent the flew of va 1 through the program . The use of the GVG leads t relatively \nefficient direct method for symbo evaluation hhich works for all flw graphs. method derives its efficiency \nby representing cove rs with a single dag, rather than a separ dag at each node. In general, the GVG \nis of s O(ua+t) , although as described in Section 4 in m discovety o f sjmple consten ts (these are \nthe c onstants found by Kildall s algorithn) is linear in the size of the GVG, and the tine cost of our \na lgorithn for finding mi nimal fixed mint covers is almst linear in the size of the GVG, (Our a lgorithns \nWo &#38; for all flcwgraphs. ) Thus our algoritlm for symbolic evaluation takes the alrmst linear in \nua+l(a+ tin many cases), as ccmpared to Kildall s which may require fl( fn2) steps. 2, Graph Theoretic \nNotions. A digraph G . (V, E) consists of a set V of elements called nodes and a set E of ordered pairs \nof nodes called ed~s.. The edge (u, v) departs m u and enters v. M3sayuisa predecessor of v and v is \na smcessor of u.. The cutdeRree of a node v is the number of sw cessors of v and the indegre e is the \nmmber of predecessors of v. A path from &#38; @~in Gisa sequence of nodes p= (U= VI, V2, S., ,Vk=W) where \n(Vi, vi+l ) c E for all I<i <k. The length of the path p is k-1. The path pis acvcle if u . w, A node \nu is reachable frcm a node v if either u : v or there is a path frcm u to V, 1? W shall require variws \nsorts of special digraphs. A rooted di~raph (V, E, r) is a triple s~h that (V, E) is a digraph and r \nis a distinguished node in V, the-smh that r has no predecessors and every node in V is reachable fran \nrw A digraph ii labeled if it is augmented with a mipping whose danain is the vertex set, A Multigraph \nis a digraph augm nted with an ordering or the edges departing from each node. A digraph G is acyclic \nif G contains no cyc les, cvc lie otherwise. Let G be acyclic. A s~cessor of a node v is called a &#38;QQ \nof v. The nodes of G have a partial ordering, called a toDolomcal orderin~ of G, under which each n ode \nprecedes all its sons. A rooted acyclic digraph T is a ~ if every node v other than the root has a unique \npredecessor, the father of v. If u is reachable from v i n T, u is a descendant of v and v is a ancestor \nof u. The reverse of a topological ordering of a tree is called a postordering. A spanning -of digraph \nG . (V, E) is a tree with node set V and an edge set contained in E. Let G . (V, E, r) be a rooted digraph. \nA node u d cxninates a node v if u k v and every path frcm the root to v includes u. It is easily s hewn \nthat there is a unique tree TG, called the dcminator -of G, swh that u dcminates v in G iff u f v and \nu is an ancestor of v in TG. We write u +v if there is apath frcm u to vin TG. Thus $ is a partial order. \nAll of the above properties of digraphs may be ccmp uted very e ffici ently,. An algor ith has linear \nm C-if the algorithn runs in time O(n) on input of length n and has almst linear time Cost if the algorithn \nruns in time O(n a(n)) where a is the extremely SICW growing fmction of [T2] (a is related to a fmetional \ninverse of Ackermann s funct ion) . Using ad>cen~ lists, a graph with V nodes and E edges m.y be represented \nin space O(V+E). Knuth[Knl] gives a linear time algorithn for canputing a topolo~cal ordering of an acyclic \ndigraph.. Tarjan [Tl ] gives a linear time algorithn for canputing a spanning tree and in [T3] gives \nan alrmst linear time algorithn for computing the dcminator tree of a rooted digraph. 3. The Global Flow \nNbdel. Let P be a program to which we wish to apply va ricus global code improvements, In this section \nwe formulate a global flew model for P, similar to a model described by Aho and Ullm. n[AU]. The program \nflm graph F . (N, A, s) is a digraph rooted a t the start node s s N. An execution ~ is a path in F \nbeginning at s. $ Hereafter will denote the partial order by danination with respec t to the fixed rooted \ndigraph F. As described in Section 1, associated with e ach node of the program graph is a block of \nassignment statements, These blocks do not contain condi ti onal or b ranch statements; c ontrol information \nis specified by the program flw graph. Program variables are taken from the set {X1,X2, . ..}. A ~ emression \nt is an expression bu ilt from program variables and fixed sets C of constsnt signs and EI of function \n-. The text expression t is considered to be located at a particular line of code in block lot(t) E N; \nthus two 1 exical ly identic al expressi ons located in different blocks, or even in different lines \nof the sane block , will be considered distinct text expressions. An assignment statems nt is of the \nfo m X:=t where X is a program wariable and t is a text expressi on. Let X be the set of program wariables \nof P. We introduce anothe r set of va riables XN . {Xn /ndV, X6X} to denote the values or variables on \nU to nodes. Let EXP be the set of expressions over C, e, and the variables in the set zN. Thus, u c EXP \nis a finite expression consisting of either a constant symbol c s C, a symbol Xn representing the value \nof global wariable Xon input to node n, or a k-ary function symbol 6 EQ ~efixed to a k-tupl e of expressions \nin HP. The covering expressions sought are expressions in EXP. Now w define birthpcint(a ), which intuit \nively is the earliest point at which all the quantities referred to in Q are defined. Let N(a) = {nI \nthe symbol Xn occurs in a}. If N(cI) is empty then birthpint(a ) . s and otherwise birthpoint(a) is the \nminimum node in N(a) relative to ~. The birthpint need not exist for arbitary expressio ns in EiF , but \nwill be well-defined in all the relevant cases (i.e. birthpoint exists for all covers of text expressions) \n. An interp retation I for the program P is an o rdered pair (U, *). The universe U contains a distinct \nvalue c* for each constant sign c c C. For each k-ary function sign d e 0, there is a unique k-arv operator \ne* which maps k-tuples in Uk into U. Also c; f c? for each distinct cl, C2CC (every constant has at most \none n.ane) . A pro~ram is in the aritbnx? tic danain if it has the interpretation (Z, *) where Z is the \nset of i ntegers and O* = { 8* I 0 E 0] = the arithmetic operations of addition, multiplication, and \ninteger division. An expression in EXP is put in reduced ~ by r epeatedly shstituting for each subexpression \nof the form (cc,...c~)~ a constant sign c su?h that * c= e*(c; , . . ..c~) mtil no further substitutions \nof this kind can be made. It will be useful to a ssune a quivalence relation z smh that for any expressions \nal ,a2 s EX F , al ~ @-2 iff al and a2 have the same reduced form. We take as given functions V and &#38;n \nas described belcw , and trust that the reader can supply definitions if he chooses. For each text expression \nt let $(t) be an expression in EXP tiich represents the value of text expression t in t enns of the values \nof the global mriables on input to lot(t) , i.e. in terms of the X1oc(t). For example, if the block of \ncode at node n of Pis x:=x-1; Y:= Y+4; z ~=x*y X * y located in this and t is the expression b lock , \nthen $(t) = ( Xn-l)*(Yn+4) . MS assume the b lock S are reduced in the sense of Aho and Ullmn[AU], so \nthat y(t) t $( t ) if t and t are distinc t text expressions. Also, for each n e N and X e Z let 6n(X) \nbe an expression in EXP for the value of X on cutput from n in terms of the values of global mriables \non input to n. In the example just given, 6n(Y) = 4yn+4~. A global flm svstem n is a triple (F, Z, I) \nwhere F is a program flw graph, Z is the set of program va riables and I . (U, *) is an interpretati \non. The next de finition~ deal with a ftied global flew system H . (F, Z, I). Let a be an expression \nin EXPandletp = (s, nl, . . ..nk) be an execution path containing birthpoint(a) . Then N(a) s {s, nl, \nn2, . . ..nk} and EVAL(a, p) is an expression for the value of a in the context of this execution path. \nEVAL(a, P) is de fi~d as follcws: (1) EVAL(a, po) = a where PO = (s) (2) foro < i S k let pi = (s, nl, \n....ni). then  EVA L(a, pi) = EVAL(a $pi-l) where a is obtained frcm a by substi tuting ~ i_l (X) for \nXni for all X c z. If t is a text expression located at node n t hen EVA L(Y(t), p) represents the value \nof the text expression t after execution of path p from s to node n. An expression a c EXP covers a text \nexpression t if (1) birthwti t(a) ~loc( t). (2) for every execution path p from s to  lot(t), EVAL(O(t), \np) = EVAL(C!, P). The second c ondition insures that a correc tly represents the value of t on every \nexecution path reaching lot(t). Note that the birthpoint of any cover a of a text expression t is always \nwell defined since the elanents of N(a) will form a chain relative to $. A cover is a ma pping SVAL (for \nSymbolic evaluation) f r an the text expressions of P to expressions in EXP in reduced form suh that \nfor each text expression t, SVAL(t) covers t. SVAL is minimal if birthpoint(SVAL(t) ) $ birth~int(a) \nfor each a which covers text expression t. In the introduction we gave a number of global fl m problems \nwhich reduce to the problem of determining c overs of text expressions. Our first result is a negative \none, which rules out the possibility of finding minimal c overs even in simple danains. Theoren ~. In \nthe arithma tic dcmain, the problem of discovering all text expresti ons covered ty constent signs is \nundecidable. .Proof Let {X0, Xl, X2, . . ..Xk) be a set of variables. Matijasevic[M] has shown t hat \nthe ~oblan of determining if a K lynomial redundant text expressions, loop invarian ts, and Q(x I,x2, \n. . *,Xk) has a root in the natural mimbers available expressions. is remrsively msolwble. The method \nof proof Proof. It is easy to show that the problem of will be to reduce this problem to that of the \ndiscovery of constant text expressi ons reduces to discovery of constant text expressions. each of these \nproblems. n s: Xo:=o; X,:=o; . (J Xk:=o ~y-y-zl--y+ x~: .Xk+l FIGURE 2 Consider the flew graph in Figure \n2. Let t be ll(xO/( 1+Q(X17x2~-. .~ the text expressicm Xk)2) located at node f and let a be the cover \nof t in t ems of the value of the variables on input to f. For any path p from s tof and fori .O, . . \n..k let be the value of Xl just on entering f. ilp Observe that for any k-tuple of natural numbers z \n, t here is an execution path frcm s to f smh that z = (xl, p,x2, p,. ... xk, p). Suppse Q has a root \nin the natw al numbers, say (zl, z2, . . ..zk). Then it is possible to find execution paths p and q to \nf s~h that zi = xi, P = for all i, 1 < i f k, andsu?h that XO,P = O, ipq and Xo, q = 1. Since EVAL(CZ, \nP) z O and EVAL(a, q) = 1, t is not a constant text expression. Suppse Q has no root in the natural numbers.. \nThen for each exemtion path p to f, F(xl, P,x2, P, ..*, xk, p) i O, so EVAL(a, P) = O. Thus, t is constant. \n0 Corollarv the arithmetic danain, the ~~ In following global flcM problems are unsolvable: discovery \nof birth and safe pints of code motion, The above results indicate that we must look for methods for \nccmputing approximations to minimal c ove rs. The method of I@ildall[Ki] may be applied to compute a \nclass of covers which we call fixed mint covers (FPCS ) , so called because they are fixed pints of an \ni terat ive process. Let T be a ~N -> EXp extended mapping: homomorphic ally to a mapping EX P -> EXP \nso that ~(a) is the reduced expression derived a fter substituting T(Xn) for each Xn c ZN occuring in \na . A FPC is a mapping Too for some such T with the fwther prcperty that for each Xn c .zN, either (1) \nT(Xn) . Xn or (2) n A s and T(Xn) = T(6m( X)) for every predecessor m of n in F. That is, either T(Xn) \n. Xn and T gives no information abcut the value of X entering node n or case (2) holds and T(xn) represents \nthe Cmmn output value of X on exit from a 11 nodes from which n can be reached by one edge, That T*$ \nis in fact a cover in this case is proved by Theoran 3.2. !4s first show LemmB ~. EVAL(T(a), P) = EVAL(a, \nP) for all expressions a e EXP with a defined birth ~int and execution paths p containing birthm int(a \n), Proof by c ontradiction. Let a be an expression in EX P with a minimal birthpoint n swh that EVAL(T \n(a), p) # EVAL(a, p) for some execution path p . (s.nl, .#. ,nk) containing n. Thus a must have a sub \nexpression of the f 0 rm w such that EVAL(T (Xn), p) ./ EVAL(Xn, p). The case .(Xn) = Xn is clearly impossible, \nso n i s. Otherwise, let ni be the last occurrence of node ninpandletm. ni_l i Then EVAL(T (Xn) ,P) = \nEVAL(T (6 M(X) ),P) by definition of T = EVAL(6m(X), P) by our assump tion of the minima lity of the \nbirthpoint of a and since n ~ birthpoint(6m(X) ) . EVAL(Xn, p) by definition of EVAL. which contr adicts \nwi th our assump tion that EVAL(T (Xn), p) # EVAL(Xn, p). ~ Theorem ~. T-$ is a cover. Proof. By Lana \n3.1, EVAL(~($(t)), p) = EVAL(O(t), p) for all execution paths p to lot(t). ~ NW call a FPC SVAL a minimal \n~ if birthpoint(SVAL(t) ) ,$ birthpeint(SVAL (t) ) for all text expressions t and all FPCS SVAL . Then \nwhile the problem of finding minimal covers is hopeless, that of finding ninimal fixed point covers is \nnot only solvable but can be done efficiently , as stated in the introduction and described belcw . The \nmain purpose of this paper is to establish that a minimal fixed point cover exists and is Uique (Theorem \n7.2) and to give an efficient algoritkn for finding it (Section 9) . To this end we introchce in Section \n4 the global value graph and show in Sections 5-7 hcw it can be used to derive these result% 4. DaRs \nand the Global Value Graph. In this section we continue to assume a fixed global flCW #ySt~ 1 = (F, E \n, I) as int~~ced in Section 3, MereF. (N, A, s). A labeled -D . (V, E, L) is a labeled, acyclic Multigraph \nwith a node set V, an edge list E giving t he order of edges departing frcm nodes, and a labeling L of \nthe nodes in V. Let RD(r) be the parenthesized inorder listing of the labels of the sub graph of D rooted \nat r, ~ RD(r) = 5+( 5*Xn)) where D . +r * Xn 5 A The dag D is minimal if RD is 1-1. Any expression \nor set of expressions may be represented, tith no redundancy , by a minimal labelled dag D. In particular, \nw use the minimal dag Dn . (Vn, En, Ln) to represent efficiently {$(t) I lot(t) = n] (recall that $(t) \nis an expression for the value of text expression t in terms of the values of variables on input to the \nnode in which t octirs), We have assumed that each blo&#38; is reduced, so we may identify the text expression \nlocated at node n of the flew graph wit h the nodes of the dag Dn associated with n, Hereafter we take \na cover to be a ~pping whose danain is, not the set of text expressions, but the set of nodes of the \ndag Dn representing those text eqressions. Aho and Ullfmn[AU] introduced the use of dags for representing \ncanp utati ons within b lmk .% Kildall[Kil and Fong, Kam, and Ullman[FKU] have applied dags to various \nglobal flm problems, We ncw define two partial mappings frcm Z to Vn . If X occurs in the right-hand \nside of an assignment in block n then we call X an input variable of n and let I%(X) = R~~(Xn), i,e. \nthe node of dag Dn labelled Xn. Also, if X is assigned to in block n then X is called an out Dut variable \nof n and let OUTn(X) . R#(6n(X) ).* Wesay Xc2is constant between ~ and ;? tiere m ~ n, if X is not an \noutput variable of any node, except ~ssibly m or n, on any path from m to n which avoids all daninators \nof m. Let Wn be a function frcm input variables of n to N such that for each inPut variable X of node \nn, %(X) is the earliest node m (relative to ~) such that either m n or X is constant between m and n. \nLet IDEF(n) be the set of global variables which are not constant between the immdiate daninator of n \nand n. W can always modify the program P, at moderate cost, so that Wn and IDEF are easily canputab \nle. For example, for each X c Z and for each node n of which X is not an mtput, add at n a dummy assignment \nX := X. This method increases the she of P to O(un+!L) and trivializes the calculation of Wn and IDEF. \nAlternatively , an algorit~ in [R] C~p UkS Wn and IDEF directly , for P unmodified, in 0( (a+t)a (a+.L) \n) extended bit vector operations. It will be convenient to assume that if X c IDEF(n) then X is also \nan output variable of n. We therefore add dummy assignments, i f necess ary , to accomplish this. Note \nthat this modifica tion changes neither the sanantics of the program P, nor the functions IDEF and Wn; \nn or does it much increase the size of P. Let n, m be a pair of nodes in the program flm graph F. A pair \nof nodes (v, u), where v is a node in the dag of nand u is anode in the dag of m, is a value pair if \nthere is an input variable X of n smh that u . OUTm( X), v . INn(X) and either (a) X s IDEF(n) and (mjn) \ns A or (b) X k IDEF(n) and m . %(X). ~ nw cane to the central definition. To model the flew of values \nthrough a program P, w introduce the global kalu e graph GVG . (V, E , L) which is a ~ssibly cyclic labeled \nMultigraph such t hat: . 1) the node set V is the union of the node sets of the dags of F , 2) E is an \nedge list containing (a) the edge list of each Dn and (b) all value pairs, and 3) L is a labeling of \nV canpatible with the labeling of each Dn. Note that the only edges departing from nodes labeled with \nfunction signs in O are of type (a), and the only edges departing from nodes labeled with variabl es \nin ZN are of type (b), and no edge departs from any node labeled with a constant in C . Also, note that \nthe value edges of type (b) degart ~ a node labeled Xn and enter a node representing a value of X on \nentry to node n; i.e. the direction is opposite to the implied fl m of control. A path in GVG consisting \nentirely of value pairs is called a value path; this noticm is due to Schwa rtz [Se], Bela is a sinple \nalgorithn for building a global va lu e graph. Algorithm ~. lNPUT II with each block n represented by \nits dag Dn for all nc N-OUTPUTGVG = (V, E, L) M canpute W and IDEF; Modify H .sJ that if X E IDEF(n), \nthen X is output at n; L:. an array of length dn+k; V:= E:=$; ~ all nodes ncN&#38; M Let Dn = (Vn) %? \nLn)~ append ~ toE, Vn to V; @all vc VncQ L(v) :. ~(v); &#38; all input variables X of node n ~ j&#38;X \nc IDEF(n) ~ ~ all predecessors m of n in F ~ add (I~(X),OUTm(X)) to E; -add (I Nn(X), OUTwn(x)(X) ) to \nE; @  G. Let d be the average cardir?ality of IDEF(n) for nodes n in the flew graph; many block structured \nprograms have d of order 1, hcwever d nRy be u in the worst case. Theor6n ~. Algorithn A is correct and \nhas time and space bands O(da+!) . Proof* The correctness of Algorithm A follws directly fran the de \nfinit ion of the global walue graph GVG. The size of the program is increased by O (d n) by the modification \nin the second line. The tine to process each node n c N is 0((1 + lIDEF(n)\\ ) indegree(n)+ lVn l). But \ndn+i > IV \\ .n~NIVnl, a = IAI =~ndegree(n), nc and da > IDEF(n) I \"indegree(n) . Z1 nc Thus, the total \ntime cost is O(da+L) . n We nod partially characterize min knal FPCS i n terms of the GVG. Theorem ~. \nIf SVAL is a minimal FPC then for all VEV, (a) if L(v) . C then SVAL(V) = L(v); (b) if L(v) . e then \nSVAL(V) = (L(v) SVAL(U1). S.  sVAL(Uk) ) 1 (that is, the expression whose first subexpression is the \nsymbol L(v) . 0, whose second s ub expres sion is SVAL(U1 ) E EXP, etc. ) where ul, ... ,uk are the smcessors \n(in order) of v in GVG, (c) if L(v) c # then either (i) SVAL(V) = L(v) or (ii) v has at least one smcessor \ninGVG and SWAL(V) = SVAL(U) for ~ such successors u. Proof. Let SVAL . ~.$ be a tinimal fixed point \ncover and let v ~ V, Case a, If L(v) = c where c c C, then T(o(v)) = $(v) = c, Case b. If L(v) . 0 is \na k-ary function sign in e and ul, . . ..uk are the successors of v in G, then T(T)(V)) = T( 1(6 $(ul)...~(uk)))) \n Z (e T($(Ul) )...T($(Uk)))]s Case c. If L(v) . Xn where Xn c ZN, we have V(V) = Xn so v = INn(X). By \nd efinit ion of the FPC , e ither (1) T($(V)) = L(v) = Xn or (2) nk s and T($(v)) = T(Xn) . T(6m(X)) \nfor all predecessors m of n in F. In case (2), consider some edge (v, u) s E. Since (v, u) is a value \npair, u . OUTm(X) for some m c N and either (i) X s IDEF(n) and (m, n) c A or (ii) X z IDEF(n) and m \n. Wn(X). In case (i) recall that 6m(X) = $( OUTm(X)), SO k have T(lj(v)) = T($(OUTm( X))) . T(6m( X))) \n= T($ (u)). Otherwise, in case (ii) X is constant between mand n; and also u is the unique smcessor of \nv in GVG. If T($(V)) A T( $(u)) then we can construct a FPC .9JAL such that SVAL (V) . T( $(u)), which \nviolates the assumption that T*$ is minimal, Thus, T($(V)) = T($(U))$ ~ 5. Discoverv _@ Simple Constants. \n A text expression t is called a stiple c onstant iff SVAL (t) c C for some FPC SJAL. We call v s V a \nsimple constant if RD(v) is, where D is the dag of which v is a node, and the expression RD(v) is taken \nas located at the appropriate point in the text of the program P. It follcws from Theora 4.2 that simple \nconstants can be detected by propagating possible constants through the GVG, starting from nodes labeled \nwith constants, and then testing for conflicts. This 1 cads to an algorittm for s imple constant detect \nion with time cost linear in the size of the GVG. The algoritkn ccmputes a new labeling L such that \nif v c V is a simple constant covered by c s C then L (v) = c, and otherwise L (v) . L(v). The result \nof this r elabel ing of simple constants with corresponding c onstant signs is the reduced global va \nlU e -RGVG= (V, E,L ). Let > be a postordering of some spanning tree of F. We construct an acyclic stigraph \nof GVG by retaining just those edges which are oriented between nodes whose 10C values are compatible \nwith >. Formally, let E> = {(v, u) I(v, u)sE and either (1) 1OC(V)>1OC(U) or (2) 1OC(V) . 1OC(U) and \nv f u} . Then observe that (v, E>) is acyclic. We shall propagate c onsta nts in the reverse of a topological \norder of (V, E>). Our algorithn for simple constant discovery is given below , Algorithm ~. INPUT GVG \n= (V, E, L), F. OUZi?UT FGVG = (V, E, L ). L.%LQ FLAG := a bit vector of length IVI; L := an array of \nlength IVI; Let > be a pstordering of a spanning tree of F; E>:= $; wall (v, u) s E&#38; ~ eithw (1) \n1oc(v)>1oc(u) or (2) 1oc(v).1oc(u) and vku ~ add (v, u) to E>; canrent propagate constants; a:~ each \nv s V in reverse topological order of (V, E>) Q M FLAG (V) := true; ~L (v) = cwherecc C-d: L (v) := c; \nelse if L(v) =ehhere ec6, l?. ..!uk are smcesors of v in GVG, L (ui) = ciwithci c C for 1 < i <k and \nthere is c s C swh that C* = e*(c; , .. J,C:) me: L (v) := c; else if L(v) c #, v has a swcessor in \nGVG, and there isc s C swh that L (u) . c for all sdh swcessors u, -f: L (v) := C; else g: add vto Q; \n~ ccmmsnt test for conflicts; b:~allv s V s.t. L(v) c ~, L (v) cC&#38; ~ there is u s V such that (v, \nu) s E-E> and L (u) < L (v) w h: addvto Q; c: till Q= @do M delete some v fran Q; ~F LAG(v) @ M i: \nFLAG(v) :. false; L (v) := L(v); add all predecessors of v in GVG to Q; ~; m ~. Lemma 5.1. Ifv sVisasinple \nconstant cove red by some constant symbol c, then L (v) is set to c in step (d), (e), or (f). Proof by \ninchction on the reverse of the $ topological order of (V,6>). Basis ~, Observe that, by Theorem Q.2, \nifv is a leaf of (V, E>) and v is a simple constant covered byc cC,then L(v) = c. In&#38;ction ~. Supmse \nfor some v c V, Lemma 5.1 is corr~t for all w occurring after v in the topological order of (V, E>). \nSupwse v is a simple constant covered by c. Consider the follcwing cases. Case 1. If L(v) c C, then L \n(v) is set to L(v) in step (d) , Eut by our otxiervat ion in the basis step, L(v) = c. Thus, L (v) is \ncorrectly set to c in step (d). Case 2, If L(v) . e where 8 c 0, let ul, .. ..uk be the successors of \nv in GVG. Here L (v) is set to c only if c* . O*(c~, . . ..c~) where L (ui) has value Ci C Cforl<i <k. \nBut by Theorem 4.2, the ui are simple consta nts and so by the induction hy~thesfi, L (ui) has been \nprevim sly set to ci. Thus, L (v) is set to c in step (e). Case~. If L(v) E ~, let s be the set of sue \ncessors of v in (V,E>). L (v) is set toc in step (f) only if v hasa successor in GVG and L (u) c for \nall u e S, To shcw that ISI > 0, w must rm all hm the GVG is constructed. We have v = INn(X) for some \nn c N-{s} and X c Z. If X s ASSIGN(n), then S = {O UTm(X) \\n>m} and otherwise s = [Oul mo(x)l, here n \n> mo = Wn(X). By Theorem 4.2, all smcessors of v in GVG must be simple constants coverd by C. By the \ninchction hy~ thesis, each u c S has been previously set to c, Thus, L (v) is set toc in step (f). U \nLet L+ be the value of L at step (b), and otoerve that just before this step Q has the value QO = {v \nIL+(v) k C}. At step (b) , Qis set to Q1 = QO u{vI L+(v) c C but L(v) E ZN and there is u G V such that \n(v, u) c E-E> and L+(u) i L+(v)}. Then v c V is eventually added to Q and L (v) set to L(v) iff some \nelenent of Q; is reachable in GVG from v. If v c V is labeled by L+ with a constant sign, then we show \nLemnB 5.2. vis~a simple constant iff some element of Q1 is reachable in GVG frcm v. Proof, ~. Suppse \nv is not a simple constant, but no element of Q1 is reachable from v. Then let SVAL be the mapping: V \n-> EXP such that for each w E V, if w is reachable frcm v then SVAL(W) = L+(w) and otherwise SVAL (W) \n. ~ tiere a is derived from $(w) by substituting L+(v) for the sti expression o(v) . Then we can show \nthat SVAL is a FPC. But SVAL(V) = L+(v) s C, which implies that v is a simple constant, contra dicticm. \nm E. Suppose some element of Q1 is reachable frcm v in GVG.. Clearly if v c Q1 , then v is not a simple \nconstant. Asswne for some k > 0, if there is a path of length less than k in GVG from some u c V to an \nelenent of Ql, then u is not a simple consta nt= Suppose there is a path p : (V=xf), xl, . . . ,xk) of \nlength k from v to some eknent of Ql, If k . 1, then xl e Ql, and otherwise if:k > 1, then (xl, ..s, \nxk) is a path of length k-l. By the induction hypothesis, xl is not a simple, constant. But (v, xl) c \nE and by Theorem 4.2, v is not a simple constant. El Theorem ~. Algorithn B is corrcx t and has tine \n cost linear in the size of the GVG. .Proof The correctness of Algorithm B follows directly fhom Lemmas \n5.1 and 5.2. In addition we must show Algoritkn B has time cost linear in ]Vl+\\E\\. The initialization \ncosts tine linear in IVI. The postordering > may be canputed in ttie linear in INI+IAI by the depth first \nsearch algorithn o f [TII. The time to process each v c V at step (a) and (b) is O(l+outdegree(v) ). \nStep (i) can be reached at most IV I times and the time cost to process each node v at step (i) is O(l+indegree(v) \n). Thus, the total time cost is linear in \\Vl+l E1. ~ In general, w may improve the power of Algorithn \nB for particular interpretations by applying algebraic identit ies to reduce expressions in EiP more \noften to constant symbols . For example, i n the arithmetic dunain we c an use the fact that O is the \nidentity element under integer multiplication to modify Algorithm B so that if node v is labeled by L \nwith the multiplication sign and a swcessor of v in GVG is covered ty O, t hen at step (e) w may set \nL (v) to the constant si!3n corresponding to O. 6. The F12VG and the Minimal u. In this section we use \nthe RGVG to further characterize aminimal FPC. The following theorem follcws easily frcm Theorems 4.2 \nand 5.1. Theorem ~. If SVAL is a minimal FPC then for each v sV, (a) if L (v) c C then SWAL(V) = L (v), \n (b) if L (v) ~ Q then SVAL(V) = (L (v) SEAL... SVAL(Uk) ) where ul~...?uk are the swcessors of v in \nRGVG. (c) if L (v) s N then either (1) SVAL(V) = L (v) or (2) v has some smcessor in RGVG and SVAL(V) \n. SVAL(U) for all such successors u. Proof  . Case a. If L (v) . cwhere c E C, then by Theorem 5.1 \nv is a sinple constant covered by c and so SVAL(V) = C. Case b. If L (v) = 8 where O is a k-ary function \nsign in Q, then by Theorem 5.1 v can not be a simple constant. So b Theorcm 4.2, SVAL(V) = ((e SVAL(U1). \n. .SVAL(Uk) ) 1 where ul?. ... uk are the swcessors of v in RGVG. But the SVAL(ui) are in reduced form \nso SVAL(V) = ( @ SVAL(ul) . .. SVAL(uk) )). Case c. Otherwise, if L (v) s # then again by Theoren 5.1 \nv can not be a simple constant and part (c) follms directly frcrn Theoran 4.2. ~ Let ~ be the set of \nall nodes of RGVG labeled with constant signs, function signs, or variables of the form Xs (s is the \nstart node of F) . Then Theoren 6.1 characterizes exactly the value of any mininal FPC SVAL on nodes \nin fi in terms of the values of SVAL on the nodes in V-?, i.e. in terms of the values on nodes whose \nlabels are of the form Xn for n ~ For v s V-i it follows from Theorem s. 6.1 that .SiAL(v) must be SVAL(U) \nfor some u that lies on a value path starting frcm v . The next theorem is critical in locati~ u. Call \ntwo paths almost dis.i oint if they have exactly one node in ccrnmon. For any v s V-O let H(v) be the \nset of nodes in ~ that lie at the ends of mximal value paths in RGYG s tarting f ran v. Theorem ~. If \nSVAL is a minimal FPC and v c V-fi, t hen either (a) SVAL(U1) = SVAL(U2) for all u1, U2 c H(v) and SVAL(V) \nis this canmon value; or  (b) SVAL(U1) L SVAL(U2) for some u1, U2 c H(v) , and  SVAL(V) . L (u) , where \nu is the unique node such that (1) ulies on all value paths from v to members of H(v), tut (2) there \nare almst d.isj oint value paths from u to n odes UI , U2 c H(v) such that SVAL(U1) f SVAL(U2) . W? \nshall require a fw technical lanms to aid us in the proof of Theora 6.2. Recall that TF is the dcminator \ntree of the flew graph F, m $ n if there is a path frun m ton inTF, i.e. ifm dcminates n, and m $n if \nm $n orm . n. Then let LCA(N ) be the latest (i.e. rmiximum relative to $) canmon ancester in TF of all \nnodes in set N sN. LemnB. 6.1. Let n c N-{s} and let IDCM(n) be the immdiate dominator of n in F. Then \nLCA({ml(m,n) c A}) = IDOM(n). .Proof Let n = LCA({ml(m,n) c A}). All paths frcm s to each m such that \n(m, n) s A contain n , so all paths frcm s to n mu st contain n , implying that n ~ n. It is obvicus \nthat IDCM(n) $ m for all (m, n) ~ A, with m i IDCll(n), for otherwise there is a path frcm s to n, avoiding \nIDGM(n). SO ID@l(N) In . Finally , sup~se n $ m for all (m,n) c A. Then there can be no path frcxn s \nton, tiich ~ is impossible. So IDOM(n) = n . Extend LCA to s@sets S of V so that LCA(S) = LCA({1OC(V) \nIV s S}). Lemma 6.2. LCA({WI(V, W) E E}) 1oc(v) for all v c v-t. Proof k have v . INn(X) for some n \nc N-{s} and X . c Z. Consider the follcwing cases. Case 1. X s IDEF(n) . By definit ion of the GVG, (V, \nw) E E iff w . OUTm(X) for some (m,n) c A. So LCA({WI(V, W) s E}) = LCA({ml(m,n) .A})~nty LanmB 6.1. \nCase 2. X i IDEF(n). 6y definition of the GVG, wo , OUTm(X) is the unique swcessor of v in GVG, where \nm = Wn(X). Ehtm ~ n, SO LCA({WI(V, W) CE}) . 1OC(WO) = m + n . lot(v). U LannR 6.3. Letv s V-; and let \nS s V-{v) swh that e ach maximal value path in RGVG frcm v contains an element of S. Then LCA(S) $ 1oc(v). \nProof. Fork ~ O, let Sk = {w I there is a value path p frcmvto wand either (1) WES withp of length < \nk or (2) pdoes not contain any elanent of S and is of length k}. W proceed by induction on k. Basis step, \nLCA(Sl) = ~A({wl(v, w) s E}) $1 OC!(V). ln~ctive s-. Sup @ se, for some k > 0, LCA(Sk) $ 1OC(V). Then \nLCA(Sk+l) = I..CA({LCA(Sk), LCA({w [w6k, wcv-f, (w, w )EE} )]) ~ LCA(sk) by LanmB 6.2 $ IOC(V) by the \ninducticn hy~thesis. ~ Now w prove Theorem 6.2. As noted above, SVAL(V) = SVAL(U) for some u reachable \nfrom v by a value path. Case 1 Sup~se there is some a c EXP such that a . SVAL(W) for all w c H(v). Let \nus assume SVAL(U) <a. If usi, then u s H(v) which is impossible. Othetwise supp3se u c v-t. Then birthpoint(a) \n* 1OC(W) for each w e H(v), so birth~int(a) $ LCA(H(V)) $ LCA(H(u)) since H(u) c_ H(v) $ 1OC(U) by L@nmR \n6.3 . birth~int(SVAL(v) ) which contradicts with the assumption that SVAL is minimal. Case 2. SUpw Se \nthere are UT, U2 E H(v) swh that SVAL(U1) i SVAL(U2), Let VS(V) z {w ] w is the last element of a maximal \nvalue path in RGVG frun v s~h that SVAL(V) = SVAL(W)}. Let u be some elenent of VS (v). To demonstrate \nthat SVAL(V) . L (u), let us sup~se SVAL(U) f L (u). Then, by Theorem 6.I, SVAL(U) . SVAL(W) for all \nw such that (v, w) c E, EUtifp. (V=vl, . . ..vi. vi+l, ..i, vk) is a value path in RGVG fran v containing \nu and vi is the last ocarrence of u in p, then SVAL(vi+l ) = SVAL(U) . SVAL(V) . This implies that u \n4 VS (V) , which is impossib le. SO SWAL(V) = L (u). Now sup~se there is a u e VS (V) distinct from \nU, But then SiAL (v) . L (u ) which is impossible since L (u) + L (u ). Thus, all value paths in FGVG \nfrom v to an elaent of H(v) must contain u, Ncw suppose part (2) of Theora 6.2 does not hold. Then there \nis no pair of almst disjoint value paths fran w to u1, U2 s H(v) smh that SVAL(U1) i SVAL(U2) . Hence \nthere is a w c V, distinct from u, swh that w is contained on all maximal value paths 0.. - . -,.,, \n,., Iran u. LeL NHL De Lne FPC swh that for each y E V, if all naximal wlue paths in RGVG from y . c \nontain w , t hen SVAL (y L (W) and otherwise SVAL (Y) = SVAL(y). So birthpoint(SVAL (u) ) . 1OC(W) \nby definition of SVAL $ 1OC(U) by Lam 6.3 . birthpint(SVAL(u)) which implies that SVAL is not ndninal. \nThis is a contradiction, so part (2) holds, d Theorem 6.2 suggests a procedure for calculating SVAL, \nbu t there is an implicit circularity since for v s V-fi the determination of SVAL(U) for u s H(v) may \nrequire the determination of SVAL (W) for some other w c V-f. The way out is by rank decomposition of \nRGVG as discussed in the next s ection, There will remain the problem of ., finding almnst disjoint paths, \nwhich we consider in Section 8. 7. J&#38;&#38; Decomposition of the RGVG. Fong, Kam, and Ullnan[FKU] \nintroduced the use of a rank decomposit ion for dags. Here we generalize the rank deccmposit ion to \nthe possibly cyclic FGVG; this gives us a method of partitioning the nodes of the FGVG into sets of nodes \nwhich my have the sane cover. This allads us to apply Thecrem 6,2 without circularity and thus daonstrate \nthat the minimal FPC is unique, In section 9 w apply the rank decomposition to implement ar direct method \nfor symbolic evaluation. The~ of anode vcVis defined: rank(v) . 0 if v has no smcessor in RGVG . 1 + \nMAX{ rank(u) I (v, u) is in E} for L (v) c ~, . MI N{rank (u) \\ (v, u) in E], otherwise. LernmB 7.1s \nSVAL(W) . SVAL(V) => ratk(w) . rati (v). Proof. W proceed by induction. Basis step. If either SVAL(W) \n. SVAL(V) . c for Som c c Cor SVAL(W) . WAL(V) =Xs for some Xc Z, then neither w nor v has a successor \nin RGVG and by definition of rank, raric (w) = rati (v) . 0. Inchctive ~. Suppose for some r > 0, rank(w) \n. rank(v) for all W,V E V swh that rank(v) ~ r and SVAL(W) = SVAL(V) . Consider some w, v c V such that \nrark(v) = r. It is easy to establish fr&#38;n the definition of rank that rark(w) . MI N{rank (z) I z \ne H(w)} and rank(v) . MI N{rank (z) I z c H(v)], Case av Sup~se SVAL(W) . SVAL(V) = ( e al-..~) i Let \nw c H(v) and w c H(w). Then by Theoren 6.1, L(w) = L(w ) . e and SVAL(zi) . SVAL(yi) for i=l ,.. ,k where \nzl !...!% (respectively Yl! .*. !Yk) are the swcessors of w (respectively w ) in RGVG. By the induction \nhy~thssis, raric(zi) . rark(yi) for i=l ,k. So rank(w) . MAX{ rank (zi) I l<i<k 1+1 = MAX{ rank(yi) I \nI<i<k }+1 = rank (w ). Thus by the above ranark rax (w) . rank(v) . r. @_s&#38; ~. Suppse SVAL(W) = SVAL(V) \nwhere SVAL(V) ~ N. By Theorem 6.2, there is a u E v-; smh that H(u) = H(w) . H(v). Thus, rank(w) . rark \n(u) . rank(v). U To ccxnpute the rank of all nodes in FGVG w use a modified version of the depth first \nsearch developed &#38; Tarjan[l 1] . &#38;cause the search proceeds backmrds , we r~uire reverse ad~cency \nlists to store edges in E. Note that the RANK(v) is used in two different ways; first to store the number \nof swcessors of node v vhich have not been visited, and later RANK(v) is set to rank(v). Let v r, Vr \nbe the nodes in V, V of rank r. We initially ccmpute ~. and on the r th execution of the main loop he \nccmpute Vr-~r and ~r+l . Algorithn ~. INPUT RGVG=(V, E, L ) O U I PUT RANK m RANK:. an array of integers \nof length IV 1; ~allvc V@ RANK(v) := -(outdegree of v) ; r := o; Q := {V / either L (v) is a constant \nsign or is a symbol of the form Xs} ; ~Q =$&#38; w Q:= Q ; Q :=+; . can~nt Q= Vr; ~Q=$ti !2E13&#38;L \ndelete v fran Q; ~ each ~edecessor u of V ~ EL (v) E o~h~ ~ RANK(u) = -1 W !?&#38;Q&#38; cament u c Vr+l; \nRANK(u) := r+l ; addu to Q @ else RANK(u) := RANK(u) + 1 ; else if RANK(u) < 0 ~ !2SlQJi ccmment u s \nVr-Vr; RANK(u) :. r; addu to Q ~ &#38; r := r+l; ~ ~. Theorem j J. Algorithn C is correct and has time \ncost linear in lVl+l E1. Proof . W? will sketch the proof of correc tess by induct iononr. w @.@L. Initially \n, RANK(v) is set to -(ou u!egree of v) for each v c V. So if L(v) c C, then RANK(v) is set to O. Als \nO, Q and Q are initially set to to. Intictive ~. Suppcse for some r > 0, w have on entering the inner \nloop the r th time: (1) Q =fr, (2) For each v c V, RANK(v) is set to rank(v) if rank(v) <r, and RANK(v) \nis set to -(number of swcessors of v with rank > r) if rank(v) 2 r.  Ey a second inductive proof on \nthe inner loop we may show that on exit to the inner loop: (3) For each v s ?, if rank(v) . r+1 then \nv is added to Q and RANK(v) set to r+l , otherwise if rank(v) > r+l the; RANK(v) is set to -(the number \nof swcessors of v with rank > r). (4) Each V c V-; with rank(v) = r is added exactly once to Q and RANK(v) \nis set to r.  Ncw he show that Algorithm C may be implanented in linear time. For each node v E V w \nkeep a list (the reverse adjacency list), giving all predecessors of v. To process any v c Q requires \ntime 0( 1 + indegree(v) ). Since each node is added to Q exactly once, the total tjme cost is linear \nin lVl+ /El. U This suffices for Theorem J J. The minimal FPC is unique. Proof SVAL(V) for v E to, Vo-oo, \nil , VI-$1, . . . . may b e determined by alternately applying Theorems  6.1 and 6.2. !l  Using this \nmethod cald be inefficient, since Theorem 6. 2 cculd be expensive to apply and the representions of the \nvalues cwld grow rapidly in size. The first problem is solved by reducing it to the problems of P-graph \ncanpletion and decomposition as described in the next section. The s econd problem is solved by constructing \na special labeled dag; the construe tion of this dag and the final algorithn are given in Section 9. \n8. P-graph Ccrnpletion @ Decanpositicn. This section present s an efficient me thod for applying Theoran \n6.2 to nodes in Vr-tr. Let RGVG . (V, E, L ) as above. Now to canpute SVAL, the minimal FPC, it suffices \nto find a subset V* s V and a mapping M frcm V onto V* smh that (1) SVAL(U) . SVAL(V) if fM(u) . M(v) \nand (2) ifv V-o and SVAL(V) = L(v) (i.e. SVAL(V) is of c the form xloc(v)) then v c V*. Thus M-l [V* \n] partitions V into blocks swh that two nodes are in the s?rne block iff they have the sane SVAL, which \ncan then be found by referring to node M(v) . Each block contains exactly one fixed point of M, which \nis called the value scurce of all nodes in . the block; thus V* is the set of value sources. Note t \nhat in general V* and M are not uniquely determined, so the de fin iticn of !Imlue source!! depends on \nthe partialar i! we have chosen. We shall find value sources and canpute M by reducing these problons \nto the problems of P-graph c cmpletion and decomposition s tated below . Let G = (VG, EG) be any directed \ngraph and let S S VG be a set of vertices of G such that for each vertex v E VG there is some vertex \nu s S frcxn which v is reachable. P-Graph Completion Problem . Find s+ . s u {V s VGI there are almost \ndisjoint paths frun distinct elernenh of S to v not containing any other elanent of S} . Thi s form of \nthe problem is due to Karr[K] , tiO shcws that it is equivalent to the original formulation &#38;e to \nShapiro and Saint[SSl . (Actually , ,t his form i s sl+ghtly more general than Karr s; Karr satisfies \nour restriction on S by stipulating that there is a single r E S from which &#38;L&#38;!2L v E h G is \nreachable. ) Karr proves t hat for each v s VG there is one and only one elfment of S+ frcm which v is \nreachable (and his proof extends directly to cur slightly more general problem) . P-Graph Decanposition \nProblezn . Given G and S+, find, for each v c VG, the unique u c S+ fran which v is reachable. W first \nshow these problems can be solved e fficiently . Shapiro and Saint give an 0( IVG12) algorithn, wile \nKarr gives a more cunplex O(lVGllOglVGl+lEGl) algori thn . Here we reduce these problems to the canputat \nion of a certain daninator tree, for which there is an almst linear the algorithn a s noted in Section \n2. (This construction was discover ed indepen dently by Tarjan[T5] .) Let hbe a n.w node not inVG, and \nlet G be the rooted dir= ted graph (VG u {h}, EG u {(h, V)l Vcs}-{(U, V)l WVG, VCs], h). Thus G is derived \nfrcm G by adding a new root h, linking h to every node inS, and removing the edges of G which lead to \nnodes in S. Let T be the dmninator tree of G . L6nnB 8.1. The members of S+ are the sons of h in T. . \nProof IJ. Letv E S+. Ifve S then h is a predecessor of v in G so h is the father ofv in T. If v c S+-S \nthen by definition of S+ there are almost disjoint paths PI , p2 in G from distinct elements of S to \nv not containing any other elenent of s. Clearly PI and p2 are also paths in G since they contain no \nedge entering a member of S. Then h, pl and h, p2 are paths from h to v in G which have only their en@oints \nin canmon, so v is a son of hin f. ONLY IF. Suppse v isa son of h inT. If h is a predecessor of v in \nG then v c S G S+. Otherwise there are in G paths h,pl and h,p2 from h to v which have only their endpoints \nin canmon. Moreover these paths contain no element of S except for the first nodes of P1 , P2, since \nno edge of G enters an element of S except frcm h. Hence PI, p2 a re almost disjoint paths in G from \ndistinct members of S to v not containing any other element of S, and hence v~ S+. D Lanma 8.2. For each \nv c VG, the unique node in S+ fran which v is reachable in G is the unique node which is a son of h and \nan ancestor of v in T. Proof Let w be that ancestor of v which is a son . of hin T. By Lenlm 8.1, wc \nS+, and clearly v is reacha ble frcm w in G since it is reacha ble fran w in T. Conversely, if w e S+ \nIS reachable fran v in Gthenw isa sonof hinT by Lana 8.I, and w must be an ancestor of v since otherwise \nv wuld be reachable fran some other mmber of S+. ~ Now w? establish the relation of these problems to \nthe problem of finding V* and M as sta ted above. Fix some V* and M by choosing one node of RGVG for \neach value of SVAL on V. For each rank r, let Gr . (Vr, Er), where Vr is the set of all nodes of RGVG \nof rank r as de fired in Section 7 and ~ = {(v, u) I(u, v) E E, U,VC Vr-~r) u {( M(v), u)l (U,V) E E, \nU c Vr-tr, v E Ir) . Thus Gr is the graph derived fran RGVG by deleting all nodes except those in Vr \nand deleting all edges except those both entering and departing frcm nodes in Vr, and then reversing \nall renaining edges. (Note that anj edge of RGVG departi~ frcm a member of ~r enters a node of rank r-l. \n) Let ~ = {M(v) / vsfir} U {vc Vr-Vr I (v, z). E, for some ZdVr} . Finally , let < be defined fran Sr \nas in the statanent of the P-graph canpleticm problan . Lemma 8.3. The members of ~+ are the value sources \n(relative to M) of rank r. Proof g. Suppose v c ~+. . Case a. By definition, all elenent.? of {M(v) I \nv c Vr} a re value sources. m h. Consider some v s Vr-?r swh that (V, Z)S E for some z d Vr. Call a value \npath in RGVG, containing only nodes of rank r, a r-value I&#38;L Since v is of rank r, thera is a r-value \npath pl frcm v to some node Z1 E 7r . Also, there is a r -value path p2, where r . rank(z) t r, fran \nz to some n ode 22 c fir . By LannB 7.1, SVAL(Z1) i SVAL(Z2) SO M(Z1) f M(z2). Since pl and V,P2 are \nalmst disjoint, by Theorem 6.2 SVAL(V) . L (v). But no other node of RGVG has label L (v) c zN, so v \nis a value eource. Case c. Suppse there are in Gr almost disjoint paths (Xl, . . .. Xj=V) and (Yl, . \n. ..yk=v) in Gr frcm distinct elements of Sr to v. By construction of Gr? there exist distinct ~1,~1 \nc H(v) smh that M(~l) . xl, M(~l) = yl, and (x2,=1) and (Y2, Y1) are value ed~s, and so (v= Xj, Xj-l \n,.. .,x2, ~l) and (v=yk, yk-l, .. S,y2,71) are alrmst disjoint value paths. As in Case (b), he show \nv is a value siti by constructing two almst disjoint value paths ql andq2 frcm vto two nodes in ? with \ndistinct SVAL, and then applying Theora 6.2. Case cl. If xl, yl E fr, then M(Z1) = xl #yl= M(71 ) so \nby definition of M, SVAL(~l) f SVAL(71 ) andql = (V= Xj, Xj_l, J.., X2, El), q2 = (V=yk, yk-1, .*. ,Y2,71) \nare the desired almst disjoint value paths. Case c2. Otherwise, without loss of generality, a ssmne E \nVr-vr. By de finit ion of Sr, X1 . xl . xl Just as in Case (b) there is a r -value path pl , where r \nAr, frcma swceesorof xl in RGVGto a node W1 c Vr-. Case c2*1. If Y1 c ~, then by LanR 7.1 SVAL(yl) .t \nSVAL(W1 ) and let ql = (v=xj, Xj_l). ... Xl, Pi), q2 = (v=yk, yk-l, .s., yl)F Case c2s2. Otherwise, 71 \n. y, c Vr-tir. Then we may similarity find a r+-value path P2, where r i r, from sane successor of yl \nin RGVG to some W2 c ?r* For each x s Vr, we may again apply LemnB 7.1 to shcw that SVAL(X) is distinct \nfrom both SVAL(W1 ) and SVAL(W2) . Since yl is of rank r, there is a r-value path (yl=zl, . ...%) frcm \nyl to some d c fir . Case c2 .2.1. If {zl, .S , zd} n {Xl, .*. ,Xj] = $ then letql = (Xj7Xj_l, . ..7xl. \npi), qz = (yk,yk-l,.-~tyl, 221 *.s, iq): Case c2,2.2 Otherwise, let Ze . xi be the last . element of \nzl, . . . ,zd contained in {Xl, . . ..xj}. ~c2.2s2.1, If {ze+l, . . ..zd] n {yl, . . ..yk] = $ t nen \nlet ql = (Xj, Xj-l, . . .. Xi. Ze+l%, Zd), d), q2 = (yk, yk-1, ... !Y1!P2). ~ c2 .2.2.2. Otherwise, let \nzf . yi -be the last e lenent of ze+l, .,. ,~ contained in {yl, .~~> yk}; then ql . (xj, xj_l, . . ..xl. \npi), q2 = (yklyk_l, ..-, Yi , zf+l, ..., Zd) a re the rqui~d alnnst disj oint value paths. ONLY IF. \nSuppse v is a value source of rank r. Then vis afixed point of M. If v c?r then v . M(v) c Sr and so \nv c S;. Othe~ise, by Theorem 6.2 there are in RGVG two almst disjoint value paths (1 = Xl, X2, t.*, \nXj) and (v=yl, y2, . . ..yk). where Xj, Yk are members of H(v) with distinct SVAL. Let ., J =MIN({j} \nu{ilxi CSr}) andk =MIN({k} u{ilyi ESr)). Then j , k > 1 a nd M(Xj ), M(yk ) c Sr$ but xl~..$ ,xj _l, \nyl,~@*,yk _l ~ Sr. Hence (M(xj ), xj _l, .,. ,x1) and (M(yk ), yk -l, ..s, yl) are almst disjoint paths \nin Gr from element.s of Sr to v, containing no other members of Sr. Thus V e S;, u By Karr s proof of \nthe uniqueness of the P-graph decomposit ion of Gr on Sr, we have Len RB 8.4. For v Vr-~r, M(v) is the \nunique value source contained on all paths in Gr from e lane nt.s of Sr tov. Thus the problem of canputing \nM reduces to the problem of decanposing the reduced global ~lue graph by rark and then constructing daninator \ntrees. The former can be done in linear time by Algorithm C of Section 7, the latter in al~st linear \ntime by Tarjan s Algorithn[T3] , 9. Z&#38; AI Korittm ~ Svmbolic Evaluation. In this section we pull \ntogether the varicms pieces devel~ti in Sections 5-8 to give a unified presentation n of our algorit \ntm for symbolic evaluation. Instead of using the RGVG directly to represent SVAL, as suggsted in the \nbeginning of Section 8, w more economi tally represent SVAL by a dag D* . (V*, E*, L*) such that V* = \n{M(v)]v c V}, E* = {( M(v), M(u) )I(v, u)cE and L (v) e~}, L* is the restriction of L to V*. Recall \nfrom Section 4 that RD maps from the rooted dag D to expressions in EX P. L~~ ~, RD* (M(v) ) . svAL(v) \nfor all v s V. Proof. Note that by definition of M, for each VEV SVAL(M(V) ) = SVAL(V) so we need only \nshow for v c V* RD*(v) ,= SVAL(V) . W proceed by inducticm on the length of the longest path in D* from \nv e V*. Basis step, If v is a leaf of D*, then by definition Of D, L(v) s C U ZN SO L*(v) z SVAL(V). \nBy definition of a dag, RD*(v) . L*(v) = SVAL(V). In&#38;ction ~. Supp3se for some j > 0, RD* (u) . SVAL(U) \nfor all u s V such that the longest path from u in D* is of length less than j. Consider some v E V such \nthat the longest path from v in D* is of length .j, Let ul, .%., uk be the sWces?$ors of v in RGVG and \noberve that M(Ul), . . .. Nl(Uk) are the sons of v in D*. By the inducticm hy~tksis, RD*(l 4(Ui) ) = \nSVAL(M(ui)) . SVAL(ui) for i . 1,, .,, k. Thus RD* (v) = (L3 RD*(I l(Ul )). .. RD*(M{Uk) ))) by definition \nof R = (O SVAL(U1 ).. SVAL ( U~ ) ) . SVAL(V) by Theorem 6.1. B Our algorithn for symbolic evaluation \nis given b elcw . As in secticn 8, w ccmpute SVAL and M in the order of the rark of nodes in V. The array \nCOLOR is used to discover nodes with the sme SVAL. Algorithn ~, INPUT GVG=(V, E,L) ouTPUT M and D* . \n(V*, E*, L*). @i&#38;l initialize: M, COLOR, L* := a~rays of length IV 7 V*:= E* :=$; m- -. . ..- ._ \nL-.,--, ,-0 Lump Ul,e rlw La. ueLlllg LJ 01 V by A gorithn B of Section 5; Compute rark of nodes in V \nby Algorithn C of Section 7; ~r := O to MAX{ rark (v) veV]do . !W31!l Let Vr, ~r be the nodes in V, \n? of rark r; . @Jlallvcvr@ ~r = O -COLOR(V) := L (v) ~ COLOR(v) : = <L*(v), M(ul), . . .. M(uk)> where \nUl, ... f% are s~ce~ors of v; radix sort nodes in ;r by their COLOR; * each maximal set Y s ~r containing \nnodes with the sane COLOR do m choose some u c Y; addu to V*; canmi?nt u is made a value sirk; ~u has \nwl,,~~,wk as swceasors in GVG -add (U, M(Wl)), . . ..(U. kl(Wk)) to E*; ~allvc YcQ w cunmnt by Theora \n6.1, SVAL(U) = SVAL(V); M(v) := u; @ ~ Let hbe some node not in Vr; Er :=$ ,.$; ~ all v 6 Vr-fr @ !U?iQLl \nmall (V, U)C Em ~ u c Vr-cr Ql&#38;tJ add (u, v) to Er; else ifuelr~ add (M(u), v) to Er; &#38;add vto \nSr; mall v c or @addM (v) to Sr; ~ Let Tr be the daninator tree of G; = (Vr u {h}, Er U {(h, v)lv CSr}, \nh); &#38;all sons uof ha w can~nt By Lenma 8.3, u is a value sirk; add Uto V*; mall ancestors v of u \ninTr @ m dir= tly from Theorems 6.1, 6.2 and Lemms 8.3, can~nt SVAL(U) M(v) := By Lam = SVu; 8.4, AL(V); \n~ ~; ~ mall Q@. Theora implemented Proof. . v. M. The V* @L*(v) Algorithn in altmst correctness D linear \n:= is of L (v); cor~ct time. Algorithm and D can be follcws  8.4, and 9.1. In addition, w must show \nAlgorithm D can be implanted in almost linear time. The stor age cost of D* is linear in IVI+IEI. Initialization \ncosts the linear in IN[ + IAI. Algorithm B and C cost linear time by Theorems 5.1 and 7.1, respec tively \n. The time cost of the r th exeation of the main loop, exclusive of the ccxnputation of Tr, is linear \nin lVrl + lEr/+l{ outdegree(v)lv c Vr-~r] / . (Here we assume that elements in the range of L are representable \nin a fixed number of machine wo rds and that the number of argument-places of function signs is bwnded \nby a fixed constant k , so a radix sort can be used to part it ion or by COLOR. ) The computation of \nthe daninator tree Tr requires by [T3] time cost alrmst linear in lVr/ + lErl. Thus, the total time cost \nis almst linear in IV I + IEI. U This completes the present ation of our algorithn. Recall that from \nSection 4 that with the aid of a preprce essing stage [R] costing 0( (a+l)a (a+!) ) bit vector operations, \nwe my construct a GVG of size O(da+L) where d is often of order 1 for blo&#38;-structured pro~ms but \nmay grow to u. (Thus this Preprocessing stage offers no theoretical admntage Wt in practice often leads \nto a GVG of size linear in the program and flw graph. ) In contrast to Kildall s iterat ive method, which \nfor a large class of programs has storage cost !2(!Ln) and time cost fl(L2a), our direct ~thod has storage \ncost linear in the size of the GVG and time cost almst linear in the size of the GVG, Although eithe \nr method may be improved somewhat t hrcugh the use of danain-specific identities, as shown in Section \n3 there is in general no algorithn for ccmputing an opttial symbolic evaluation. In [R] these methods \nare extended to programs which operate on structured data in a language smh as PASCAL or LISP 1.0. References. \n [AU] Aho, A.V. and Ullmn, J.D. , ~ Theory ~ Parsing, Translation a@ Compili ng, vol. II, Prentice-Hall, \nEnglwood Cliffs, N.J. , (1973). l!c~ntrol flm analysis, [A] Allen, F. E., SIGPLAN Notices, Vol. 5, Num. \n7, (July 1970), PP. 1-19. [C] Co&#38;e, J. , !!G1 obal ccmmon sub expression e lamination, ! SIGPLAN \nNotices, Vol. 5, No. 7, (J~Y 1970), pP. 20-24. CA] Co&#38;e, J. and Allen, F. E., A catalo~e of Optimization \nTransfo rma tions, Design and Optimization of Computers, R. Rustin, cd.), Printice-Hall, (1971), PP \n1-30. FKU] Fong, E. A., Kam, J. B., and Ullnran, J.D. , Application of lattice algebra to loop optimization,!! \nConf Re cord of the Second -~ Svmp . ~ Principl es of Progranni~ Languages, (Jan. 1975) , PP. -i-9. \n[FU] ~0~, E.A. and Unman, J.D. , Induction variables in ve ry h~h level language s, Conf. Re cord of \nthe Second ACM Svmp. QrJ Principl es ~ Pro.qranming Languages, (Jan. 1976), PP. 1-9. [G] Geschke, C. \nM., Global progran optinizations, Carnegie-Me non University , Phd. Thesis, Dept of Computer Science, \n(Oct. 1972). [GW] Graha, S., and Wegman, M. A fast and usually 1 inear algori tkm for global flew analysis. \n!! ~ ~, vol. 29, NO. 1, (1975), PP. 172-202. [HU] Hecht, M.S. and Unman, J.D. , Analysis of a simple \nalgori thn for g lobal f lcw problem , Co nf. Record of the ACM Symposium on . Principl es of Progr~~ \nw~angu ag es, (OCF 1973), pp 2oZ217. [KUI] Ksm, J,B. and Unman, J.D. , Global data flew analy sis and \niterative algori tkns , ~ ~, vol. 23, No. 1, (Jan. 1976) , pp. 158-171. [KU?] Kam, J.B. and Unman, J.D. \n, l%notone data flew analysis franewo~s, Technical Re~rt 167, Cbmputer Science Department, Princeton \nUniversity, (Jan. 1976) . [K] Karr, M, P-graphs, P!assachusetts Computer As sociates, CAID-7501-1511, \n(Jan. 1975) . [Kel] Kennedy , K. , Safety of code motion, International &#38; Computer Ma th vol. 3, \n. ! ~-l 5. (Dec. 1971), PP. !!A ~~parison of algoriths [Ke21 Kennedy , K. , for ,global glcw analysti, \n!l TR 476-093-1 , Dept of Ma thema tical Sciences, Rice Univ. , Houston, Texas, (Feb. 1974). [Ke3] Kennedy \n, K. , !!Node listings apPl ied to data fl w analysis, Proceediws of the Second ~ s~mposim ~ principl \nes ~ Progranminz Lanquag es, (Jan. 1975), PP. 10-21. [Ki] Kildall, G. A., A unified appro=h to global \nprogran optimization, Proc. _ACM SymDosiun QQ Principl es of progranmi~ Languages, (Oct. 1973), pP~94-206. \n[Knll Knuth, D. E., ~ Art ~ Computer Pro.gramiqq, Vol 1: Fbnd~n tal Algorithms , Addison-We slay, Reading, \nMass. , (1968) . [Kn2] Knuth, D. E ., Big anicron and big omega and ;~let;;ta, SIG4CT !Naws (Apr.-June \n1976) , -.  [LP] J-oveman, D. and Faneuf, R., !rProgran optimization --theory and practic e, Proceeding \ns of a Conference on Progranmin~ Languages ~ Compilers f= Parallel and Vector Machines, (March 197= \n[M] Matijasmic, Y. , 71Enume rable sets are diophantine, (Russian) , ~ ~ U SSSR 191 (1970), pP. 279-282. \n[R] Reif, J. H. , Ph.D. Dissertation, in progress. [S] Schaefer, M. , ~ Ma thematic al Theom ~ Global \nAnalvsis, Prentice-Hall, Englawood Cliffs, N.J. , (1973). [Se] Schwartz, J. T., Optimization o f very \nh~h lwel languages --valu e transmi ssion a nd i ts corollar ies, 1! ComDuter La MuaKes, V. 1, (1975), \nPP. 161-194. !!Th e [SS] Shapiro, R. and Saint, H. , r epre senta tion of algori thns ,l! R 7C . I \nTechnical Report 313, Vol. , June (1972). llDepth_first search [Tl] Tarjan, R. E., and linear graph \nalgori tlms , SIAM J. Computin~, Vol. 1, No. 2, (June 1972), pp. 146-160. [T2] Tarjan, R ., Efficiency \nof a good but not 1 inear set union algorithn ,! ~ ~, vol. 22, (April 1975), PP 215-225. [T3] Tarjan, \nR.E. , ! Applicaticms of path canpression on balan~d trees , 1! Stanford Computer Science Dept. , Technical \nRe~rt 512, (Au~. 1975) . [T4] Tarjan, R ., !?solvi~ path probl ans on directed graphs, Stanford Computer \nScience Dept. , Technical report 528, (Ott 1975). [T5] Tarjan, R ., Personal canmunication to M. Karr, \n(1976) . [U] Ullnnn, J.D. , !!Fast algorithms for e limi nati on of ccmmon suk expressions, !! &#38; \nIn forma tica, Vol. 2, N. 3, (Dec. 1973), Pp 191-213. !! The [W] Wegbreit, B., synthesis of 1 Oop pr \nedicates, Can m ~, vol. 17, No. 2, (Feb. 1974), n2-112.  \n\t\t\t", "proc_id": "512950", "abstract": "This paper is concerned with difficult global flow problems which require the symbolic evaluation of programs. We use, as is common in global flow analysis, a model in which the expressions computed are specified, but the flow of control is indicated only by a directed graph whose nodes are blocks of assignment statements. We show that if such a program model is interpreted in the domain of integer arithmetic then many natural global flow problems are unsolvable. We then develop a direct (non-iterative) method for finding general symbolic values for program expressions. Our method gives results similar to an iterative method due to Kildall and a direct method due to Fong, Kam, and Ullman. By means of a structure called the global value graph which compactly represents both symbolic values and the flow of these values through the program, we are able to obtain results that are as strong as either of these algorithms at a lower time cost, while retaining applicability to all flow graphs.", "authors": [{"name": "John H. Reif", "author_profile_id": "81100567232", "affiliation": "Harvard University", "person_id": "PP14196622", "email_address": "", "orcid_id": ""}, {"name": "Harry R. Lewis", "author_profile_id": "81100349371", "affiliation": "Harvard University", "person_id": "PP31038347", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512961", "year": "1977", "article_id": "512961", "conference": "POPL", "title": "Symbolic evaluation and the global value graph", "url": "http://dl.acm.org/citation.cfm?id=512961"}