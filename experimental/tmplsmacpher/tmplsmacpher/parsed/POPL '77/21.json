{"article_publication_date": "01-01-1977", "fulltext": "\n Threshold evaluation and the semantics of call by value , assignment and generic procedures Permission \nto make digital or hard copies of part or all of this work or personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; 1977 \nACM 0-12345-678-9 $5.00 Bernard Lang IRIA, LABORIA 78150 -Rocquencourt FRANCE Abstract We use the concept \nof evaluation up to a given threshold of information to generalize the seman\u00adtics of call by value and \nassignment to non-discrete domains, and to define a formal semantics for gene\u00adric procedures, We then \nprove the correctness of McCarthy s transformation of iterative programs in\u00adto recursive ones provided \nthe same threshold is used for assignment and parameter passing. 0, MOTIVATION AND PREVIOUS WORK 0.1 \nMcCarthy s Transformation. The original PurDose of this work was to establish in a Drecise .. way when \nthe McCarthy transformation of an ~terative program intoa recursive one [1] is strongly correct (i.e. \nthe two programs are strongly equivalent). A characteristic of this transformation is that it changes \nassignment into parameter passing. Since assignment requires evaluation of the expression assigned, the \nparameter passing mechanism has to do the same with the expression passed, This usually corresponds to \nthe concept of call by value. So a key concept in our work is that of an eva\u00adluation. By considering \nthe partial evaluation of an expression up to a given threshold of information, we will generalize the \nusual concepts of assignment and call by value. We will then establish the cor\u00adrectness of McCarthy s \ntransformation provided the same threshold is used to evaluate actual parameters and assigned expressions. \nPrevious work on McCarthy s transformation, using call by value, was done by Strong [23. Howe\u00adver Strong \ns syntactic approach is limited to dis\u00adcrete interpretations, i.e. interpretations in which values are \neither completely defined or com\u00adpletely undefined, By non-discrete interpretations we mean domains with \npartially defined values (e.g. a pair having only one component defined). It is not clear how Strong \ns approach could be gene\u00adralized to this case, More recently Courcelle [3] proved the correct\u00adness of \nthe transformation withou~ using call by value, but for a class of interpretations so res\u00adtricted as \nto be of limited practical interest, 0,2 Semantics of Call by Value, We follow here only the fixed point \napproach to the semantics of programs as introduced by Scott [4] and developed by many authors r5,6,73. \nHowever the most natural use of this type of semantics for recursive equa\u00ad tions imply the use of call \nby name as parameter pas\u00adsing mechanism,. The semantics of call by value has so far been approached in \ntwo different ways : a) The first approach is due to Park [81 and re\u00adpresents functions by their graphs, \nThis leads to a fixed point semantics of call by value as naturally as the more direct approach leads \nto call by name. However this representation of functions seems un\u00adpractical to,thls author, and defining \ncall by name in this manner is rather complicated (de Roever E9]). Furthermore this semantics allows \nonly for discrete domains. b) The second approach is to define call by value by some extension of the \nusual call by name approach. This was done by de Bakker [10] and Boudol Fll], but only for discrete domains. \n0,3 Non-discrete Domains, Although the data do\u00admains used in most programnmng languages are discre\u00adte, \nrecent developments in pro~ramming research lead more and more to the consideration of non-discrete domains \n: a) Higher order languages (Lisp, Algol 68, EL1, POP-2 F12,13,14,15]) use functional domains that are \nnot discrete, In fact, call by value as defined by Landin for lambda-calculus [16] has been given a mathematical \nsemantics by Plotkin [17]. This work, done for u-order functional domains, seems compati\u00adble with ours \nwhich is limited to first order but considers arbitrary domains. b) Recent work extending the delay rule \nof Wadsworth [181 and Vuillemin [61 has led to new lazy ~ interpreters F19,20], Typically these inter\u00ad \npreters can deal with data structures that are only partially defined, thus belonging to a non-discrete \ndomain. c) Coroutines as defined by Kahn and MacQueen[21] use non-discrete domains which are sets of \npossible histories for the communication channels. In Wiedmer [22], a mechanism for computing on real \nnum\u00ad bers with arbitrary precision is based on the same principles. Finally, the model theory of the \npro\u00ad gramming language LUCID [23] deals with infinite car\u00ad tesian products of discrete domains, hence \nwith non\u00ad discrete domains. Without resorting to those more advanced con\u00adcepts, we have simple examples \nof interesting use of non-discrete domains, such as passing a pair by value for its first component and \nby name for its second one. 1, PRELIMINARIES 1,1 General notations. If A is a set, we note *O = @,A1 \n=A,Vn>l An =An-lxA, and A* = ~0 An. The cardinality of A is noted IAI. The function 1A is the identity \nmap on A, The set of functions from A to B is noted (A+B). We note [n] = {i. .stillsi~n}. If X = {xili \ncN+}, then Xn = {xiIi e m]}. If f is a function or a function symbol, then p(f) or simply pf is the arity \nof f (number of arguments), We note o the composition of relations, If + is a relation on A, then we \nnote + =lA, ~n>l) S = ;] ~+, U n $n.~~~i$.nz,+,and~ =$u~, In the following F will generally denote a \nfi\u00adnite or denumerable set of function symbols fi, and X a denumerable set of variable symbols : X = \n{xili <N+} 1.2 Vector notation, Let A be a set. We denote by ~ an ele~ent of A*, If:cAn , we note a. \nits i-th component, and ~ = <a ...,an>, If f d~notes 1 a function or a function symbol, then f(~) is \nan abbreviation for f(al,... ,apf). If K is a unary function, then ~(~) is an abbreviation for <K(al), \n. . ..l((an)>. Similarly, the order relation ~ in a c,p,o, <D,~,L> is extended as : tj~,$ cDq &#38;~ \niff (Vie[q] diEd~), However, a derivation relation + on A is ex\u00adtented to Aq differently : b ~,~ eAq \n~+ ~ iff ~ic[q] such that ai + a! 1 and ~jc[q]-{i} a.=a!, JJ Al.&#38; By ; ~ a we denote the k transitive \nclosure (as defined in l.]) of the vector relation ~ + ~ , and not the vector extension of the derivation \nre\u00ad lation ! between single elements of A, The substitution rtl/xl,...,txq]q] (see below) is noted r~/~]. \n1 .3 Orders. A part-ial or de~ is a couple <D,C~ where s is an order relation (reflexive, antisyme\u00adtric, \ntransitive) on the set D. Let A be a subset of D, an upperbound of A is an element d of D such that ~aeA \na~d, Two elements d and d of D are inconpcztib2e (noted d#d ) iff {d,d } has no upper\u00adbound. If A has \na least upperbound it is noted ~A, or dud when A={d,d }. A partial order cD,~> is conditionally complete \niff every upper-bounded subset of D has a least up\u00adperbound. A subset AGD is direeted iff i) A # @ and \nii) da,a cA {a,a } has an upperbound in A. A partial order c~,~> is inductive iff i) there is a least \nelement, noted 1, in D such that kfdeD l~d, and ii) every directed subset of D has a least upperbound. \nThe inductive partial order is noted <D,~,L>. An element deD is iso2ated iff for every directed subset \nSSD, US5d implies 3seS.sSd. We call complete partia2 o~der (in short o.p.o,) a partial order that is \nboth conditionally complete and induc\u00adtive. Let <D,=> and <D ,s> be two partial orders, A function fe(D+D \n) is monotonic iff ~dl,d2cD dl~d2# f(dl)5f(d2). When the two orders are inductive, fis continuous iff \nfor every directed subset AcD i) the image f(A) of A by f is a directed subset of D , and ii) f ( PA) \n= Uf(A), The set of continuous function from D to D is noted [D+D ].Continuity implies monotony. An order \n<D,g> is discrete iff i) there is a least element 1 in D and ii) Vd,d ED-{1} d#d ~d#d . A discrete order \nis a c,p,o, , A special role will be played in this paper by the c,p.o, O = <{l,T},E,L> . Lemma 1.1 Let \n<D,5 ,L> be a c,p.o. and for every subset ACQ note ~A the function in (D-@) defined by ~A F ax T if \n~aeA. a~x 1 otherwise If A is a set of isolated elements of D then SA is continuous. 1,4 F-algebras \n(or F-magmas). Let F = {filic [n]} be a finite set of function symbols. Let D be a set and I a mapping \nin (F+(D*+D)) that preserves arities. We call I an interpretation of F on D. We note F1=I(f) and F1 = \n{fllfcF}. The couple <D,F1> is cal\u00ad led an F-algebra. A morphism of F-algebraa, from <D,F1> to <DJ,F1,> \nis a mapping pe(D+D ) which preserves the functions fl, i.e. Vf cl?, v&#38;Dpf ll(f1(3)) = fll (;(3)). \nThe free F-aZgebra M(F,A) on a set A is the set of well formed (with respect to arities) terms on F and \nA. It is such that for any F-algebra <D,F1>~ any mapping VC(A+D) extends uniquely to a morphism, noted \n<I,v>, in (M(F,A)+D). We call v a vaZuation and <I,v> a valuated interpretation. The valuated interpretation \n<I,v> associates an element of D to every term in M(F,A) as follows : VteMO?,A) i) t aeA ~ <I,v>(a)=v(a) \nii) t = f(?) ~ <I,v>(t)=fl(<~(;)) e al OY any ector+g = g]  gtF~> f unc\u00adtions in (D +D) (resp. d = \n<all,. ..,d > of ele- IA! ments in D) to be considered as an interpretation (resp, a valuation) of M(F,A), \nLemma 1.2 tics of generic programs. LeC D be a c,p,o. and tcM(F,A), then 1-~ ~.~~l>(t) is a continuous \nfunctional from [j)*+D]l FixDIAlto D. A substitution o is a morphism between two free F-algebras M(F,A) \nand M(F,B) ; since o is ful\u00adly determined by its value on A, we note o = [u(al)/a,,.o ,u(ai)/ai , s 1 \nallowing the omis\u00ad sion of those elements in A for which u is the iden\u00adtity. The height of a term tcM(F,A) \nis Iltlldefined by : i) t=acA or t=fwith p(f)=O~llt]\\=l, ii) t=f(;)~ Iltll =l+max{llt,ll Iicrofl}. L \n1.5 Compatible derivation relations. A derivation relation over a free algebra pfM(F,D) is compatible \niff ~fcF, v ~,~ EM(F,D) :-; +f(?)-f(?) , Lemma : If the relation is compatible then k i) the relations+, \n~ and 2 are too, ii) VTCM(F,DUXq) Y;,l CM(F,D)q + t L; -rZ/13T~ [: /zlT 2, GENERIC SCHEMES AND PROGRAMS \nIn order to have a uniform treatment of simpli\u00adfication and rewriting rules in our operational se\u00admantics \n(see [61), we are led to consider a more general concept than that of recursive procedures, namely that \nof generic procedures. These are recur\u00adsive procedures with many bodies, the choice of the body at each \ncall depending on some predicate over the parameters, usually involving their type (e.g. + can be integer \naddition, boolean disjunction or set union depending on arguments types), This con\u00adcepts was introduced \nin programming languages such as Basel, Algol 68, ELI [24, 13,]41 and is discus\u00adsed by Schuman in [25]. \nIndependently, Burstall and Darlington [26 1 have developed for their program transformation system a \nnew representation of recursive programs that is similar to the concept of generic program presented \nhere, Our calling mechanism for a generic procedure includes a set of threshold points in the arguments \ndomain, This set is partitioned into subsets, each corresponding to a different procedure body. Actual \narguments have to be evaluated up to some thres\u00adhold point before the procedure is called. The body chosen \nis then the one corresponding to the parti\u00adtion that contains the threshold point reached by the partially \nevaluated arguments. 2.1 Generic Rewriting Systems. The concept of generic system introduced here will \nbe used later to define the operational seman- Generic systems are a refinement of term rewri\u00adting systems \n[7]. For every rewriting rule there is an applicability condition val , depending on the arguments of \nthe rewritten function symbol (this will correspond to the parameter-passing mechanism, e.g. by name, \nby value...). Furthermore the replace\u00adment term of a rule is also dependant on those ar\u00adguments (this \nwill correspond to the generic aspect of the programs we want to define), This section is devoted to \nthe definition of ge\u00adneric systems and the proof of their Church-Rosser property (slightly generalized). \nThe proof techni\u00adque is inspired from Tait s [27 ] and consists in defining a notion of parallel. derivation, \nshowing it to have the same transitive closure as the usual derivation, and proving the Church-Rosser \nproperty for parallel derivation. 2.1,1 Definitions. a) Generic Systems. Let D be a set, F a finite set \nof function symbols, X a denumerable set of va\u00adriable symbols X = {xii idJ+} . We define a generic rewriting \nsystem as a couple r= <val,~> where i) vale(F+(M(F,D)*4)) ii) TE(F+(M(F,D)*+M(F$DUX) )), and such that \nthe axioms Ar ~ and AI 2 given below .are satisfied, For all f in F we abbreviate pf -val(f) as valfe(M(F,D) \n+) -~(f) as Tfe(M(F,D)pf+M(F,DuXof) ) We call val and T respectively threshold and re\u00adwriting functions, \nb) Derivation, Given the above generic system r, and A<F, we define over M(F,D) the relation derive by \nA into , noted ~ , as the smal\u00ad lest compatible relation such that : Vf.A, Y7;cM(F,D) f, valf(~)=T~f(~)~[~/~]Tf(~) \nc) Axioms. The generic system axioms can now be ex\u00ad pressed as : Vf6F, VF,Z .M(F,D)pf Ar , : ;~? ~ valf(l) \n~ valf(; ) Ar2 : :-@ + Tf(?).Tf(; ).1 valf(T)=Tl Those axioms insure that no possible derivation will \nbe disabled by performing first an inner derivation . d) Parallel derivation. Given the generic gystem \nr and -.ASF. we define over M(F.D) the relation derive-in parallel by A in~o; , noted -, as the snallest \nrelation such that ~ n (proof by induction on the sum of the length of the Notation When A=F we note \nrespectively + and T or ~and~. 2.1,2 Properties. We now give a few technical lemmas relating ~and ~SI \nh~main results areeorollaries 2.4 and 2,7, which are used here to prove the Church-Rosser property for \ngeneric systems (theorem 2.8), and in section. 2.4 to study the need for simplifica\u00adtion rules. In the \nfollowing, a generic system r = <val,T> over <D,F,X> is understood, (proof by induction onll~ll). Lemma \n2.2 Vt,t .M(F,D) t% t +t~t (proof by induction on Iltll). Lemma 2,3 ~t,t ~M(F,D) t ~t + t+t (proof by \ninduction on the length of the proof of from the axioms of parallel derivation). Wt Corollary 2.4 ~t,t \n~M(F,D) t V **t+t Lemma 2.5 Extension of the axioms to parallel derivation. iffcF, @,; eM(F,D)pf ~valf(l) \nEvalf(; ) ) w 2)2-l+.f(t) .Tf(a) Va@)-T ) (prOOf by induction on the length k of the deriva\u00adtion ;&#38; \n). Lemma 2,6 VA,BCF ~t,t ,t cM(F,D) proofs of t~t and t~t ) . Corollary 2,7 VA, BgF Vt,t ,t cM(F,D) . \nt> + +30.M(F,D) .1 t+ J 1 * (proof by induction on i+j), Theorem 2,8 Generic systems are Church-Rosser \n. Vt,t ,t <M(F,D) * * t 1 ~ t t I +38cM(F,D) ~ 1 * t J--N tt 1 (proof by corollaries 2.4 ancj 2,7), \n2,2 Generic Programs, 2.2,1 Syntax Let @ = {@ilic Fn]} be a set of unknown function symbols, X = {xilicN] \nbe a set of (dummy) variable symbols, F be a finite set of base function symbols, Q be a finite set of \nthreshold function symbols. A generic scheme G on <F,Q,@,X> is a set of n equations of the form : l$i(:)e \npi , : ei 1 9# ... ]Si<n. ... P.l,q(i) : i,q(i) where -p. .cM(Q,@)1)3 note that at least one nullary \nfunction symbol is needed in Q. -e. .eM(Fu@, X l>J P($i)) The terms p. . snd e. . will be interpreted \nres\u00adpectively as th$ ~-th th~~~hold partition and body of the i-th generic procedure defined, 2.2.2 Interpretation. \nLer <D,= ,lz be a capma. . Let S=2D% be the set of sets of sequences in D. Let I he a mapping in (F+[D*+DI) \nu(G(s*+s)). We note F1=I(F) and QT=I(Q), The restrictions  IF and IQ of I to F and Q are extended into \nmor\u00adphisms. IFC(M(F,D)+<D,F1 >) and IQc(M(Q,@)+<S,Q1>). We define I to be an interpretation for a ge\u00adneric \nscheme on <F,Q,O,X> iff the following two We will then prove their equivalence (S2.6). axioms hold : \nand I is an interpretation on the C.P.O. <D,= ,1>. Actually we will only use the associated mappings \nAI, : Vicrnl, Vjc[q(i)l I(pi, j) is a set of iso\u00ad val and ~, without referring anymore to the syntac\u00ad \nlated p($i)-tuples in DP$i tic definition of G. We will define for <G,I> : A12 : ~icrnl, ~j, j c[q(i)l \nj+j implies -a notion of operational semantics (52.3), and -a notion of denotational semantics($2.5). \n The functions in F1 and Q1 are respectively 2,3 Operational semantics. celled base and threshold functions. \nTo the generic program <G,I> we will associate A generic program is a couple <G,I> where G a generic \nsystem r = <val,T> on D,FuO,X>, thus de\u00ad and I are respectively a generic scheme and an fining a notion \nof computation of a term tcM(FuO,D)interpretation. To the generic program <G,I> we now by mean of the \nderivations in r. For every function. associate two mappings noted val and T . symbol $ in FuO, valv \nand T$ w ill be first defined For i~rn] we define the indexing function on I)p@, then extended to M(FuO,D)PV. \nJ(i)=X~.cjc [q(i)]. Z~cI(pi ,j)-~&#38; The mappings val and T are built from two parts : where cj.P \nmeans the unique j such that P holds, if it exists, and L otherwise . a) the first part corresponds to \nthe base functions in F , It is not constructed from <G,I>} but is Note that the uniqueness of j is guaranteed \nby I axiom AI a wired-in machinery that is provided together 2 with I in order to compute on schemes \ninterpre\u00ad P$i The function J(i) is in (D + rq i)lu{.L}). ted by I. This machinery is compos$d of two \nmap\u00adpings : vale(F+Ci)*+Ill) and TE(F+(D +M(F,X))). The functions vale(@+(D*+)) and There is of course \na requirement that this machi\u00ad~< (@+(D*+M(FuO,X))) are defined as fo: lows : nery be coherent with I, \nexpressed by the fol\u00ad lowing axiom AS : val($i)=A~. if J(i,~)~rq(i)I I T ASL if J(i,;)=l T(@i)=&#38;. \n+ if J(i,~)c[q(i)~ i,J(i,x)+ L if J(i,x)=l I b) the second part is programmed . It is the map\u00ad pings \nval and T associated to the generic pro-We note again val and T+ for val($) and T(@), gram <G,I>, as \ndefined in S2.2,2 ,@ Those two parts are merged into one mapping vale(FuO+[D*+O~) and one mapping TE(FU&#38;+(D*+M(FUO,X))). \n(continuity Of val$) In order to get the promised generic system r, ~ T@(~)=@ ) we must now extend val \nand TV (for every $ in FuQ) ~b, To thisvend, we introduce the concept to M(Fu@,D) of direct approximant \n(Wadsworth r181). proof : Axiom AI] and lemma 1.1 imply that J(i) is P $i a continous function from D \nto the discrete The direct approximant u(t) of a term C,p,o, 4iu{L},s,l>, Lemma 2.9 is an immediate co-tsM(Fu@,D) \nis the best approximation Of the e~ralua\u00adrollary. I tion of t in the interpretation I when the generic \nscheme G is ignored. Formally it is the valuated Intuitively, in order to evaluate @i(Z) in the interpretation \na = <IFUIO,ID>, where L$ denotes the + interpretation (where+E is a vector of expressions p$+D],and lo \n= <l$I, $L$ passed as arguments),c has to be first evaluated up function X~~J in rD to the threshold \ndefined by the points in u n (Recall that To may be considered as a mapping frov I (p i,j), i.e. until \nwe have an approximation ~ O to {l@l$c@}). We will often note at for a(t). j of the v~lue of the arguments \nsuch that valet, We then choose the body e. iff the The generic system T associated to <G,I> is ~ l$j \n now defined as I = <val,T> where val and T are the threshold has been passed at a point a belonging \nabove defined mappinzs, extended as follows : to the threshold set I(p. .). lJJ kj$cFu@, vteM(Fu@,D)p$ \nFrom now on, we assume given a generic pro\u00ad val$(?) = valo(;(;)) TO(;) = T$(:(;)). gram <G,I> where G \nis a generic scheme on <F,Q,O,X> We still have to verify that the axioms Arl tions : and Ar are satisfied. \nThis is a consequence of 2 lemma 2,9 and the following lemma 2.10 : Lemma 2,10 ~t,t cM(Fu@,D) a)t + \n@ts at 7 b)t~ !+ .~. Ctt (proof by induction on Iltll, using axiom AS), We now proceed to define the \noperational se\u00admantics d of ~he generic program <G,~>. Definition : ~tcM(FuO,D). A(t) = {at \\t% } Lemma \n2.11 ~tcM(FuO,D) A(t) is directed, (proof immediate from lemma 2.10 and the Church-Rosser property of \ngeneric systems), Therefore, for every term t in M(Fu@,D) we can define the value ~[t] = UA(t). For \nevery TcM(FuO,DuXq) we define ()[.]= 1~. ~[[~/;]T] c(Dq+D). Finally, we associate to every $60 the func\u00adtion \n0[01 = 0 [O(xl, ,xp$)l . The operational value ~[t] of a term t is thus defined as the limit (i.e. least \nupperbound) of a directed set A(t), Unless this limit is tri\u00advial (i.e. contained in A(t)), no finite \ncomputa\u00adtion will ever reach it. Thus, in some sense, we are considering infinite computations, This \nis one way to deal with such machines as lazy interpreters that compute possibly infini\u00adte values by \ncomputing increasingly more informa\u00adtion about them (e.g. the successive elements of a list) without \never producing them fully when they are infinite (e.g. infinite lists), Finite values correspond to isolated \npoints (which can only be trivial limits) of the domain and are thus always computed in finite time, \nIn particular, thresholds are finite values and are always reached in finite time, if at all. 2,b Simplifications. \n The derivation of a term f(t) such that fgF is called Simplifications in\u00ad s-zhplificcztion,are teresting \nbecause they correspond to the operation of an actual computing machine for base functions. A similar \nconcept cai be found in [6,7,281. One reason to introduce the generic concept is that it can deal with \nsimplifications, i.e. com\u00adputation of base functions, as well as with rewri\u00adting rules corresponding \nto the evaluation of recur\u00adsive programs. For example, the most common base function ~ corresponds to \nthe following simplifica\u00ad true ~ t, -==+~ (t,,t2,t3)+t2 faz8est1 +~ (t, ,t2,t3) t3 and we have : val. \n(~) = T iff tl~{true,~aZsel q (true, t2,t3) = X2 and ~ti(fa2se, t2,t3) = X3 ~g However the use of simplifications \nthat are gi\u00adven in addition to the interpretation, rather than being constructed from it, is not very \nsatisfactory. We will now show that simplifications are not neces\u00ad sary. Corollary 2.12 (of lemma 2,10) \ntft,teM(FuO,D) L a) t Fuo # atcat! b) t+ t +~t at Lemma 2.13 ~t,t ,t cM(FuO,D) 38;8 6M(FuO,D) wt \nFt + ] F me  [t ~e  (proof by induction on the sum of the length of the two parallel derivation proofs), \nLemma 2.14 ~t,t;t elf(Fu@,I)) t~t ~t +3~; O cM(FuO,D)t~@# 1t t~,,!  (proof by induction on k, using \nlemma 2.13 and corol\u00adlary 2.7), Lemma 2,15 ~t,t eM(FuO,D) t + 36 ,6 EM(FutI,D) t&#38;3 &#38;9\u00b0 t+ { % \n (proof by induction on the length k of the deriva\u00adtion t~t , lemma 2.14 and corollary 2.7), Theorem \n2,16 vt,t cM(Fu@,D) t Fuo t ~ 3t <M(FuO,D) -.-l.+ t+tll ~t! c ~t~l 1\u00ad(proof by lemma 2,15 and corollaries \n2.4 and 2.12). For every term t in M(FuO,D) we define A@(t) = {at I t+ }. From theorem 2,16 we see that \n: ~tcM(Fu@,D) lJA(t) = UAo(t). Therefore the operational semantics could have been equivalently defined \nwithout simplifications, using only derivation on unknown function symbols. Intuitively, simplifications \nare redundant with the use of direct approximants (see lemma 2.10). However the elimination of direct \napproximants in favor of simplifications would not work. Without elaborating, let us say that direct \napproximants are more powerful because they allow us to consi\u00adder incremental increases of information \nduring com\u00ad putation, and thus to compute infinite values as limits of finite ones. 2,5 Denotational \nSemantics. We will now use fixed-point techniques to de\u00adfine a denotational semantics for generic programs, \nWe refer the reader to [4,5] for more details about fixed-points and fixed-point semantics. This type \nof semantics is usually more tractable in proofs about programs. Let ~ be the *O,@n>. Given a vec-  \nVe-: $1 \u00b7 tor j of functions in [D +D] such that ~(~)=~(~), P and a vector ~eD , since the interpretation \nI on <D,~ ,1> is fixed, we can define in a standard way a valuated interpretation P = <Iu~,~Du~> for \nthe terms in M(FUO,DUXP). We will often abbreviate to + p = <~,j>,or even v = <g> when X = 0* P To every \n@i in O we associate the functional P $i UiE([D*+D]n+(D +D)) defined by : 0, = 1~~ . if val$ (d)=l then \n<~,~>(T4 (t)) else L. 1 ii Lemma 2.17 ViE[n] ai is continuous (the proof relies on lemmas 2.9 and 1.2). \nWe note ;=<ul,.oc,un>. By lemma 2.17 we have + OE[[D*+D]n+[D*+D]n]. Thus &#38; has a least fixed-point, \n noted Y;, in [D*+In. The denotational semantics 0[$.1 of a func\u00adtion symbol $ie$ is then defined as \ntie i-th compo\u00ad nent OfY8 : die [n] v [$il = (Ya)i For every term t in M(Fu $,D) we define : U[t] = <IuY&#38;,D>(t). \n2.6 Adequation. We now prove the adequation theorem establis\u00adhing the equivalence of operational and \ndenotatio\u00adnal semantics. Lemma 2.18 tft,t cM(FuO,D) , Vk.bl tJ$+t + <:k(To)> (t ) G<;k+ (T@)>(t) (proof \nby induction on Iltl! ) . Lemma 2.19 ~t,t cM(FuO,D), ~keK t% + <?o>(t )s <:k(lo)>(t) iproofby induction \nonk and lemma 2.18). Lemma 2.20 v@.@ 0[$1 !30[$1 (proof by lemma 2.19 and continuity of ;). Lemma 2,21 \n~TCM(FUC ,DUXq) , VICM(FUQ,D)q J Vk~@J rd [J1/21T~13 + + qT EM(FUtJ,DUXq) 3Z CM(FU0,D)q ,~ = [8[;]/;]T \n+* :! t ~~ EM(FUO,D)q a;!~a~ ~ [; /~]T &#38;[8 /l]T (proof by induction on <k, \\lT\\l>) Remark : this \ncrucial lemma is better understood in ~ght of the comments at the end of 52,3. Lemma 2.22 V TEN(FUO;DUXq), \nVZEM(FU@,D)q ()[[b[;]/;]T]~~ [[?/;~Tl Lemma 2.23 &#38;c[D*+D]* such that ~(~)=;(~) ;=i[Jl + VtO(Fu@,P) \n+(t)50[tl (proof by induction on Ild) . Lemma 2,24 ~keN ~k(L@)~ Bill (proof by induction on k) Corollary \n2.25  fi[JlE3[tl Theorem 2,26 (Adequation) D[tl=d[Jl 2,7 Applications a. Tf a function has only one \nbody ei * and I(p. ~)={L], then it is a usual re?ursive func\u00ad tie; with call by name. b. If @i has one \nbody e. and I(p i,l) is the set l)] of p($i)-tuples of maximal elements in D, then we have a recursive \nfunction with the usual call by value. c, We can consider intermediate cases : some parameters can be \ncalled by name, and others by value, terpretation specifies a set El of isolated thres\u00adhold points in \nthe domain D of interpretation, As\u00ad a Parameter can be called partially by va\u00adsignments can be performed \nonly when the assignedlue, i.e. be required to be evaluated up expression has been evaluated up to some \nthreshold to some non-maximal point in D, For exam\u00ad point in 0, ple we can have an array argument, and \nre\u00adquire only the first two elements to be The threshold set El actually determines the evaluated before \npassing the actual array, semantics of assignment, If O is the set of i~ola\u00adted maxim-al points in D, \nwe have the usual concept d. With appropriate interpretations (see e,) we of assignment (thus corresponding \nto call by value) a semantics for generic procedure, with the which requires the assigned expression \nto be complet\u00adpossibility of calling the parameters by na\u00adely evaluated, For other thresholds (3, the \nassi\u00adme for some bodies, and by value for others gned expression is not always required to be com\u00ad(a \nproblem left open in [24]), In the case of pletely evaluated when the assignment is executed,generic \n+ considered earlier we may wish it In particular, when Q = {l}we have an assignment to call its arguments \nby name when it is the by name as we might want it in a lazy interpreterboolean disjunction, and by value \nwhen it is [19,201, This assignment by name is very similar tothe integer addition, the port assignment \nused in F21] to build coroutine networks, e. To enable the threshold machanism to perform type checking \nwe can include types in the do- Note that we simplify the following presenta\u00admain of interpretation, \ne.g. : tion by considering just one flowchart rather than a set of flowchart procedures calling each \nother ,,, -1 0 1 ,.. true false .,,,,, recursively. Thus expressions (or rather terms) are built only \nfrom base functions without recursive calls to other procedures, integer boolean list ,,, 3,1,1 Flowchart \nschemes,   \\\\ll/ \\I \\/ \\\\// Let L,XP and F he three finite sets whose ele\u00ad 1 ments are respectively \nnoted (3i l<i<n, x. l<i<p 1 Example : and f. l<i<lFl, and are called labek, registers 1 and base .functien \nsymbols. We consider an interpretation T in the above do~in. The interpretation of the threshold func- \n We define the followin~ sets : tion symbol va2ue is a function I(?.khe) (S) is the set of isolated \nmaximal points greater than some i) AS (L,XP,F)=XPXM(F,XP)XL is the set of point in S. Then assignments, \nnoted <xi+t;@>, foo(x)e I integer : cl(x) ii) Br(L,Xp,F)=M(F,Xp)X1.XL is the set of [vczihe(boolem,) \n:eo(x) branching, noted <ta~ ,$ >, I cons(va~ue(list),list) : e3(x) iii) EX(XP,F)=M(F,XP) is the set \nof exits is interpreted as a generic function where the body e] g ets its argument almost by name (almost \nbecause noted <return. t>, we require it to be at least an integer), e2 gets iv) St(L,Xp,F)=As(L,Xp,F)uBr(L,Xp \n,F)uEx(XP,F)its argument by value, and e , requires its argument .J is the set of statements. to be a \nnon-atomic list in which only the first su blist must have been evaluated, In the above definitions, \nt denotes some ele\u00adment of M(D,XP). 3. FLOWCHARTS AND McCARTHY S TRANSFORMATION We define a flouehart \nscheme on <L,X ,F> as a In $3.1 we use threshold evaluation to genera- P lize the concept of assignment \nin flowcharts as we mapping d c(L+St(L,Xp,F)). did call by value in recursive programs. The cor rectness \nof McCarthy s transformation is then esta-3,1.2 Interpretations, blished in $3,2 , Let <~,~,~> be a C.~,i3, \ncontaining three dis 3.1 Flowchart programs, tinguished elements, noted tt, ff and=% , that are isolated \nand maximal, Those elements stand respec-The flowcharts defined here are composed of tively for the boolean \nvalues true and false, and assignment and branching statements, and of exit a special value corresponding \nto error messages in statements returning the results of computations, real computations. Sequencing \nis done exclusively through labels (it is never implicit). Let I be a mapping in (F+[D*+D])preserving \narities, and El a set of isolated elements of D. We will define in a standard way the inter\u00ad pretation \nand the operational semantics of a flow-We define the couple <1,0> to be an interpre\u00adchart program. The \noriginal aspect is that the in-tation for flowchart schemes on <L,XP,F>. The set O is called the thyeshold \nset. result for finite arguments). If the result is not 1 (non termination), it is obtained after a finite \nnum- To the set G we associate a continuous map\u00adping val@c [D+@] defined by : = Ax.if jdcO.d~x then \nT else L a1(3 3.1,3 Operational Semantics. From now on we implicitly consider a flow\u00adchart program <&#38;,<I,~>>, \ncomposed of a flowchart scheme 6 on <L,X ,F> and an interpretation <1,~> on P the domain <D,~ ,L>} with \nthe function val as defi\u00adned above, o A state is a couple rl=<v,~> where v is a va\u00adluation of the registers \nin X , i.e. a mapping in (XP+D), or equivalently (up t: isomorphism) a vec\u00ad tor ~cDp, and 6 is a label \ncalled program counter in this context, Let S=DPXL be the set of states, A register valuation v together \nwith I defi\u00adnes a valuated-interpretation <I,v> of the terms in M(F,Xp)~ A derivation relation, noted \n~ . is defi\u00adned between states as follows : i) if 6(B)=~xj+t,8 > then va16(<I,v>(t)).T + <V,B> +<vl,~~> \nwhere v =[<I,v>(t)/xi]v i.e. v is equal to v except for the i-th register which has taken the value <I, \n>(t), ii) if 6(6)=<to~ j6 > then <I,v>(t)=tt ~ <V,6> b<v,~f> <I,v>(t)=~~ ~ .cv,~> l--<v,(ljt> Remarlj \nthat for every state TI there is at most one state ~ such that rI~q . We have deterministic computations, \nWe now define a mapping a6(%D), called c7<rect result, as follows : a(<u,B>) = <I, v>(t) if d(~) =<return \nt> % if 6(B)=<t28 ,6 > and <I,v>(t)#tt, <I,v>(t)#f~ L otherwise. Note that if a state ~ is derivable, \nthen a(n)=.L. The result is+, meaning error, when a bran\u00adching test is applied to a non-boolean value, \nFor everv state rle.$, let A(n) be the set A(n)={ci(n )ln+n }. By the above remarks on derivations we \nsee that A(rl) contains at most one element not equal to 1, So we can define the value computed by the \nflowchart program for some initial state ~ as : (l[n]=uA(n), Note that this limit is always trivial, \nwhich means that only finite elements of I) can be compu\u00ad ted (assuming finite initialisation of the \nregis\u00ad ters in n, and that base functions give a finite ber of computation (derivation) steps. Finally \nour operational semahtics associates to every label 6 in L a function in [DP+DI as fol\u00adlows : VB.L ()[~] \n= a3.(l[<&#38;~>] Defining a fixed-point semantics for flow\u00adchart programs (see for example [29]) and \ngiving an adequation theorem would be much easier than for ge\u00adneric programs, but without real interest \nfor the present work. 3,2 McCarthy s Transformation. We now study the transformation due to McCarthy \ns [1] that transforms a flowchart program into an equivalent recursive one, or ger,eric one here. We \nwill have to consider only generic func\u00adtions with a unique body ; thus we will ignore the threshold \nfeature that generalizes call by value. Consequently we will abbreviate the notation of ge\u00adneric equations, \nin schemes, by writing simply $i(~)~ pi:ei (i.e. without the second index cor\u00ad responding to different \npossible bodies), The essential point in our presentation of the transformation is that it uses the same \nthres\u00adhold for the flowchart program and its generic trans\u00adform. With the usual semantics of assignment, \nthis amounts to requiring the use of call by value for the transform. In this section, x will always \ndenote the vector <X ,...,x >, 1 P 3.2,1 The transformation. Given the flowchart program <8,<1,0>> \nas de\u00adfined in 53,1, we build a generic program as follows. i) Let @={@i \\ lSi<n=ILl} be the set of unknown \nfunction symbols, ii) Let F =Fu{~} be the set of base function sym\u00adbols, iii) Let Q be the set of threshold \nfunction symbols containing only the symbol n, with the arity p (IT)=o, iv) Let the generic scheme G \non <??;Q)CI,X> be the set.of equations l<iSn. 1 such that : a) d(~i)=<xi+t;~k> *ei=[t/xjl(Ok(~)) $+(;)+ \nn : e. b) a(~i)=.t=~j,~k>+ei=fi(t,c$j (~),$k(~)) c) d(~i)=<return t>sei=t Note that the threshold term \nis the same(i.e,n) for all equations. v) Let I be the mapping on F uQ defined by a) k fcF I (f)=I(f) \n b) I (~)=~X 2X3  2 X3 . . lt if X,=tt x,=~~ #\u00ad if xl#tt and x,#ff c) I (IT)=EIP 1 otherwise with ~ \nEM(F ,De)p and <l ,ID>(; )=&#38; + We define the generic proEram <~,1 > to be the McCarthy transform \nof the flowchart program <d,<I,@>>, 3.2.2 Correctness. An operational semantics ~ is defined for both \nthe flowchart program <6,<1,6>> and its gene\u00adric McCarthy transform <G,I >, that associates func\u00ad tions \nin [DP+D] to every label f3~L or unknown func\u00adtion symbol $cO. Strong correctness of the trans\u00adformation \ncan thus be expressed by : Vie [n] OIBil= OL$i] However we will not be able to completely achieve this \ngoal. Indeed, for any ~ieO and ~eDP, if there is an index jc[p] such that va18(dj)=l, (~)=J. and 0[Oi(3)l=L. \nBut the henwe ave alOi same hypothesis do not generally imply that 0[<3,B.>]=1, i.e. the non-termination \nof the flow\u00adchart 1 computation. The reason for this discrepancy is that a generic function in the transform \nalways requires its actual arguments to be above the threshold whereas the flowchart does not have this \nrequire\u00adment for the initial content of registers. We could deal with this problem by duplica\u00adting 2P \ntimes each unknown function $., with a dif\u00adferent threshold for each copy, to me~t all initial cases \nof arguments above or below the threshold, This would in general require n.2p unknown function symbols \nin the generic transform, instead of n, In practice, we may consider that the flowchart is the body of \nsome procedure which is called only if its arguments (i.e. the initial values of the registers) are above \nthe threshold, Hence we will restrict our strong correct\u00adness requirement to the domain D6={dcD lva10(d)=T}, \nThe following lemmas 3.1 and 3.2 show that the flowchart and its generic transform can simulate each \nother, The correct ness theorem 3.3 follows imm\u00ad ediately. Lemma 3,1 &#38;D;, V@i.@, ~k<~ Oi(z)At implies \n-either t =~j (~ ) with ~ CM(F ,DO)p, and -<3,6i>&#38;<<~(: ) ,f3j> or t ~M(F ,D@) and ()[<~,~i>l= <l \n,~D>(t) (proof by induction on k) + with tcM(F ,DO) and <l ,ID>(; )=d (proof of a) is done by induction \non k) , Theorem 3.3 Strong Correctness on Do ~ic[nl, ~~cD~ mi(ibl= O[<hi>l 4. SUYMARY We have defined \na concept of threshold evalua\u00adtion in non-discrete domains, and applied it to the following points : \n1) Uniform treatment of call by value and call by name, generalizing both into a continuum from one to \nthe other. 2) Similar generalization of assignment resulting also in a continuum from the usual assignment \nto an assignment by name. 3) Analysis of McCarthy s transformation that rela\u00adtes assignment and parameter \npassing, We showed in particular that, as originally described, it is on\u00adly weakly correct when applied \nto the flowchart bo\u00addy of a procedure calling its arguments by name. 4) Formalization of the concept \nof generic proce\u00addure, 5) Uniform treatment, using the generic mechanism , of recursive rewriting rules \nand of simplifications of base functions in the operational semantics of recursive (here generic) programs, \nThe proofs of the lemmas and theorems enoun\u00adced in this paper will be published in [30]. Aknowledgements \nI wish .to thank my friends G. Berry, G. Huet, G. Kahn and D. VacQueen for many helpful discus-. sions, \nJ.J. Levy for constant technical and moral support and C. Le Meal for her speedy typing. References D \n1 J.McCarthy, A basis for a mathematical theory of computation. In Computer fiograrrning and Formal Systems, \nBraffort and Hirschberg Ed., North Holland, Amsterdam, (1963) . [ 2 1 R, Strong, Translating recursion \nequations into flow charts, Journal of Computer and System Sciences, Vol,5.N03. (June 1971), r3 I B. \nCourcelle, Personal communication. To ap\u00adpear in book form.  P,I?enderson luator, 3rd pp. 95-103. and \nJ. Morris, ACM Fpmp.on Jr. Prin, A of lazy Prog. eva-Lang., D,P. Friedman and not evaluate its Coil. \non Automata, ming, Edinburgh, J),S, Vise, arguments, Languages (1976). CONS should proc. of 3rd and Program\u00ad \nr217 G, Kahn works of publication. and D, parallel Mac@ueen. processes, Coroutines Submitted and net\u00adfor \nr227 E. Wiedmer, Fxaktes Rechnen mit Zc?zzen. Eidgen6ssiche Technische Z;rich, Bericht nr,20, (]976). \nreellen Hochschule, r23] FOA, Ashcroft and 1.1. hladge. without tears. F&#38;oc. Symp. improving prog~ams, \nIFIA, Fuet and Kahn Ed., (1975). proving on Proving Rocauencourt, programs and r247 Ph. Jorrands. Contributions \nment des langages extensible. lJniversit6 Scientifioue et Grenoble, (1975). au developpe-Th2se d Ftat, \nMcdicale de r257 S,A. Schuman, On generic Directions in A2porithmic (ed,S,A. Scbuman) IRT.L, functions. \nLanguages (1976). In 75 New r26-1 R, Burstall formations grams. proc. Softvure, and J. Darlington. Some \ntrans\u00adfor developpinp recursive pro\u00adof~nternati. CoKf. on Re2iabTe LOS A~geles, Cal!, (1975). r277 H,P, \ndels Ph.D. Barendregt. Some extensional term mo\u00adfor combinatory logics and X-calculi. thesis, University \nof Utrecht, (1971). r281 J,M. tial Ph.D. ( adieu. functions thesis, Fecursive and their Stanford definitions \ncomputations. ~Jn., (1972). of par\u00ad r297 R.. Bird. J. Comput. On transformations System Sci.,EJ, of 22-35, \nprograms. (1974). r303 B, Lang. Transformations ThFse 3S cycle, lJuiversitE Paris, (to appear). Schematiaues. \nparjs VT1, [41 D. Scott, Outline of computation. Monograph N0.2, of a mathematical Programming Research \nOxford University [51 Z. Manna and J. Vuillemin. Fix point proach to the theory of computation. nications \nof the ACM, [6] J. Vuillemin. Syntax, tique d un language de ple, These de Doctorat tiques, Universit6 \nde (1974) , see also theory Group (1970). ap-Commu\u00ad(1972). axioma\u00adsim-Mathema- Implementation of recursion \nin a simple programming language. Proc, 5th Annual ACM Symposium on Computing, (1973). r73 M, Nivat. \non the interpretation of recur\u00adsive progran schemes. Symposia Mathematical, V02, XV, Instituto Nationale \ndi Alta Mate\u00admatica, Italy, pp. 255-281, (1975). [83 D, Park, Fixpoint induction and proofs of program \nproperties. Machine Inte22i?enee 5 (eds. B. Meltzer and D, Fichie), Edinburgh: Edinburgh lJniversity \nPress, pp.59-77 (1969). r9] W,P, de Roever, Recursion and pararceter\u00admachanisms : an axiomatic approach, \nIn Automata, Languages and .Wo@aming (cd, !5, 528-536, setnantique programmation es-sciences Paris VII, \net Paris, J, Loeckz) , pp.34-65, puter Science Vol. 14, Berlin, etc., (1974). no] J,W, de Bakker, Least \nted, PFOC. of Symposium Lecture Notes in Com\u00adSpringer-Verlag, fixed pointa revisi\u00adon A-Calculus and Co~uter \nScience Theory, Roma, pp.1-35, (1975). rll] G, Boudol. Langages po7Uadiques algebriques. Theorie des \nschemas de programmed : seman\u00ad tique de 2 appe2 Universit6 Paris r12] J. McCarthy et Manua2, MIT ~e~, \nr131 A, van Wijngaarden on the algorithmic Acts Informatica, r14] B, Wegbreit et Manual. Harvard par \nvaleur. ThSse 3: cycle, VII, (1975). al. LISP 1.5 Programmerts Cambridge, Nass,, (1962), et al, Revised \nreport language ALGOL 68. VOZ.5, Fast.1-3, (1975). al. The FCL Programmer s University, Center for \nResearch (1972), in Computing Technology, 21-72, rls] R.N. Burstall, J,S. Collins and R,J, Popplestone, \nProgramming in Edinburgh : Edinburgh University (1971), POP-2. Press, rl 61 P.J. Landin. expressions, \nThe mechanical Computer Journal, evaluation Vol.6 of N04. r171 G,D. Plotkin. Call-by-name, and the k-calculus. \nJ, 125-159, (1975). call-by-value Theoret. Comp.Sei.,1, r181 C.P, Wadsworth. Semantics and pragmatic \nthe lambda-calculus. Ph.D.t?zesis. University of Oxford, (1971). of  \n\t\t\t", "proc_id": "512950", "abstract": "We use the concept of evaluation up to a given threshold of information to generalize the semantics of call by value and assignment to non-discrete domains, and to define a formal semantics for generic procedures. We then prove the correctness of McCarthy's transformation of iterative programs into recursive ones provided the same threshold is used for assignment and parameter passing.", "authors": [{"name": "Bernard Lang", "author_profile_id": "81100409202", "affiliation": "IRIA, LABORIA, 78150 - Rocquencourt, FRANCE", "person_id": "PP14144732", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512972", "year": "1977", "article_id": "512972", "conference": "POPL", "title": "Threshold evaluation and the semantics of call by value, assignment and generic procedures", "url": "http://dl.acm.org/citation.cfm?id=512972"}