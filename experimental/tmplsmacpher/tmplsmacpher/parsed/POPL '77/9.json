{"article_publication_date": "01-01-1977", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1977 ACM 0-12345-678-9 $5.00 An Efficient Insertion-Only Error-Corrector for LL(l) Parsers C. N. Fischer \nD. R. Milton S. B. Quiring Computer Sciences Department University of Wisconsin-hladison 1210 West Dayton \nStreet Madison, WI 53706 Abstract An LL(l )-based error-corrector which operates by insertion-only is \nstudied. The corrector is able to correct and parse any input string. It is efficient (linear in space \nand time requirements) and chooses least-cost insertions (as defined by the user) in correcting syntax \nerrors. Moreover, the error-corrector can be generated automatically from the grammar and a table of \nterminal symbol insertion costs. The class of LL(l) grammars correctable by this method contains (with \nminor modifications) grammars used to specify most common programming languages. Preliminary results \nsuggest that this method can be used to advantage in LL(l )-driven compilers. 1. Introduction The problem \nof correcting and recovering from syntax errors in context-free parsing has received much attention ([1], \n[3], [6]-[18]). Known solu\u00adtions, however, usually contain some rather seri\u00adous drawbacks. Some ([3], \n[7], [8], [14]) are essentially ad-hoc, requiring the use of hand\u00adcoded recovery routines. Others ([6], \n[7], [8], [10], [14]) when faced with certain syntax errors are forced to skip ahead, completely ignoring \nportions of the input. Some methods ([1], [8], [15]) must be considered impractical in that they have \nnon-linear space or time bounds. Yet others ([8], [9], [10], [14]) when faced with a choice of possible \ncorrections make an arbitrary (and all too often unreasonable) choice. We consider an LL(l )-based error-corrector \nwhich remedies these difficulties. This method limits its attention to insert-correctable LL(l) grammars, \nthat is, those LL(l) grammars ([2]) for which it is always possible to effect an error correction by \na suitable insertion of a terminal string. This class of grammars is a large and interesting one, including,for \nexample, grammars which (with slight modification) can specify the syntax of such programming languages \nas ALGOL 60 and PASCAL. In an error-correcting compiler this insert only philosophy is attractive because \ncorrect programs can always be built around the programs submitted by a user. The error corrector considered \nhas many de\u00adsirable properties. It requires at most linear time and space. It produces a syntactically \ncorrect program from any input string. It can be automatically generated from an insert-cor\u00adrectable \nLL(l) grammar and a supplied vector of terminal symbol insertion costs. When choosing a string to be \ninserted to correct an error, it always chooses a locally optimal least-cost string (as defined by the \ncost vector). This allows the choice of insertions to be fine-tuned by merely adjusting the cost vector. \n2. The LL(l) Error-Corrector The algorithm we present is an insertion\u00adonly error corrector for LL(l) \nparsers. Since we may need to consider insertions at the end of an input string, it is necessary to use \nan augmented grammar. Let G = (Vn,Vt,P,S) then the augmented grammar G = (Vn U {S },Vt u ;},P u {(s +s$)1,s \n), where nput strings will $dVt>S 4Vn. All be terminated by the endmarker symbol, $ . We shall consider \nall grammars to be augmented and denote Vt u {$} by ~t, Vn u {S } by on . Given as input a string xa... \n(xcV~, a~tt) such that S ++ x... but S ~+xa... , the correction algo\u00ad rithm will find a y~V~ such that \nS ++ xya... . In order for this algorithm to succeed, we need two restrictions: one on the class of lan\u00ad \nguages considered, another on the parsing algorithm used. It is clear that not all LL(l) languages will \nbe susceptible to an insertion-only corrector. Consider the LL(l) grammar: G1: s +s$ S+al(a) For input \na)... there is no insertion y=V~ such that ay). ..~L(Gl) . We define a class of grammars for which inser\u00ad \ntion-only error correction is always possible: A cfg is said to be insert-correctable iff for all xfV~ \nand a~~ ~ such that s ++X... and S P+ xa... , there ex\u00ad ists yEV~ such that S ++ xya... . In the next \nsection we will show that it is decid\u00ad able whether an LL(l) cfg is insert-correctable. For real programming \nlanguages insert-correcta\u00ad bility does not appear to be a serious constraint. For example, in order to \ntransform ALGOL 60 into an insert-correctable language it is only necessary to allow a <program> to be \na sequence of <block> s rather than just a single <block>. The LL(l) parsing algorithm must also be con\u00adstrained. \nIt is well-known that every LL(l) gram\u00admar is strong ([2]), and the conventional parsing algorithm for \nLL(l) languages takes advantage of this fact. However even for insert-correctable LL(l) grammars this \nalgorithm will not necessarily detect an error upon first encountering the errone\u00ad ous symbol ([2], [5]). \nConsider the following in\u00ad sert-correctable LL(l) grammar: G2: s +E$ E+TE E ++ TE Ic T+al(E) and try \nto parse a) $. The parsing stack sequence E$ +LmTE $ +LmaE $ +Lm E $ +Lm$ , (the s: km last transition \noccurs because )C FOLLOW). At this point the parser announces error , but it is too late--there is no \nuseful information left on the parsing stack to guide a correction al\u00adgorithm. We thus require a parsing \nalgorithm which will never make a transition on an errone\u00adous input symbol, thus detecting the error \nwhen that symbol is first encountered. The algorithm which is usually used for parsing LL(k) languages \nfor k > 1 suffices ([2]). This involves con\u00adstructing LL(k) tables which identify the exact lookahead \nset. These tables are, in effect, then used as nonterminals in the parsing algorithm, and an error is \ndetected whenever an erroneous symbol appears as the lookahead. (An LL(k) table can be represented as \na pair, (A,Y), where Aetn and Y is a local follow set ([2]); how\u00adever the error-corrector ignores the \nlocal fol\u00adlow sets, so for our purposes the parsing stack will be written as X X where XiC~n u tt) . \nn 1 The error-correcting algorithm requires two auxiliary tables, S and E . These tables rely on an insertion-cost \nfunction C: C(c) is defined to be O ; for ac~t, C(a) is supplied as an a priori value, and for w = X. \n xnci;, c(w) = C(x,p : C(xn) . For XcVn u Vt, S(X) = y where YE;;,X+ y and for all ZE;: such that X \n+* z C(Y) s c(z) . In other words, S(X) ident fies a least-cost terminal string derivable from X . The \ninsertion-cost function C can now be ex\u00ad tended to nonterminals: C(A) = C(S(A)) . . For A~vn and ac~t, \nE(A,a) = (0,0) if A~*. ..a... . Otherwise, E(A,a) = (p,i) where p= (A+X X. Xn) and X.+* . ..a... . \n1 In addition, (~,i) has a lea~t-cost property:. let w be a least-cost terminal string such that Xi \n+* wa... , then for all (q,j) where ~=(A+Y .-. Yj Ym) and Yj +* za... we 1 have C(X1 Xi_l w) SC(Y1 \n Yj-l z) . That is, with A on top of the parsing stack and a the erroneous input symbol, E(A,a) will \niden\u00adtify an expansion that will lead to a least\u00adcost insertion. The algorithms which compute the S and \nE tables operate by iteration over the grammar until the costs converge to a minimum; they are discussed \nin detail in the appendix. A Given AEVn u Vt and ac~t such that A+*. ..a... , the following recursive \nprocedure * will compute the least-cost ycVt such that A+*ya. . . . It will do this by performing a sequence \nof insertions into the string being parsed: INSERT(w) will insert the terminal string w immediately to \nthe left of the sym\u00adbol a currently flagged as being in error, (and to the right of any previous insertions). \nAlgorithm 2.1 procedure PREFIX(A,a); ifA=athen return _ else begin comment let E(A,a)= (p,i) where p= \n(A+X X. S X ); lNSERT(S(X ) s(xi-] )); n PREFIX(X, ,A) I end; We are now ready to give the error-correction \nalgoritilm. Let the parsing stack be Xn e Xl$ , and let the erroneous input symbol be a . The parser \nwill detect the error when it finds tnat tile parsing table entry T(Xn,a) = error ; it will flag a as \nbeing in error and will call the following procedure: Algorithm 2.2 procedure ERRORCORRECTOR; for i := \nnstep -1 until 1  doifXi=a then return ~~Vtg E(X. ,a)= (0,0) . then IliSERT(\\(Xi)) . else begin PREFIX(X, \n,a); return end; The procedure scans down the stack until it finds tne first stack symbol tilat can \nderive the error symbol, while inserting S(xi) for all other stack symbols. When an Xi is found such \nthat Xi +* ...a... , if Xi # a the PREFIX procedure is called to compute the re\u00admaining insertions required. \nThe parser is then restarted, reading the leftmost inserted symbol . 3. Properties of the Error-Corrector \nWe now consider the salient properties of the error-correcting parser introduced above. The most important \nproperty is correctness--any input string (with proper endmarker) can be corrected and parsed. Further, \nwhen an insertion is required it is locally optimal in the fol\u00ad -. . . lowing sense: Theorem 3.1 Assume \nthat for some insert-cor\u00ad rectable LL(l) grammar G, x.. ..L(G) but xa... #L(G) for xV;, a~~t . Further, \nassume that while attempting to parse xa... , Algorithm 2.2 is invoked with wY... on the parse stack \nAA where w-(Vn ~~Vt)*,Y<Vn IJ Vt, and wfi* . ..a..., * y+ ,..a... (Y must exist since G Is insert\u00adcorrectable). \nThen Algorithm 2.2 will find and insert a string yy :V~ such that w -* y and Y-z* y a... . Furthermore, \nthere is no + * Zz .v t such that w -* z and Y + z a... where C(zz ) ~ C(yy ) . Proof: The LL(l) parser \nfails as soon as sym\u00ad bbl a is encountered. Since G is insert\u00adcorrectable, we know that for some symbol \nY on the parse stack Y +* . ..a... . Algorithm 2.2 examines in turn each symbol on the parse stack; if \na symbol cannot derive a it in\u00adserts the lowest cost string derivable from it. If a symbol Y can derive \na , it inserts the lowest cost prefix ucV~ such Y ->* us... . The net result is to insert the lowest \ncost string which will allow a to be accepted by the parser. Q.E.D. Corollary 3.2 Let x$ be any input \nstring* where X<vt . Then an LL(l) parser using Al\u00ad gorithm 2.2 as an error-corrector will parse and \naccept x$ . We thus have a very robust error-correc\u00adtor which can build a correct string out of any input. \nAlso, since all insertions are lo\u00adcally optimal, we can use the cost vector to fine-tune the choice of \npossible insertions. As the next theorem demonstrates, /41go\u00ad rithm 2.2 is efficient and compact: Theorem \n3.3 Assume an LL(l) parser using Al\u00adgorithm 2.2 as an error-corrector processes x$ . Then it requires \n(a) at most O(lxl) time and (b) at most O(lxl) space. Proof: (a) We can establish two important ob\u00adservations: \n (1) each step of Algorithm 2.2 can be charged to some stack symbol, and each stack symbol is charged \nan amount of time bounded by a constant dependent solely on the grammar; (ii) each input symbol causes \na number of symbols, bounded by a grammar-dependent constant, to be added to the parse stack. Note that \n(i) and (ii) yield the desired result immediately, and hold for normal LL(l) parsing. During error correction, \nobservation (i) follows from tne fact that each stack symbol considered either generates a least-cost \nderivation string or a least-cost prefix string of the error symbol. In either case the string is bounded, \nso it takes a bounded amount of time to do the insertion and later parse it. During error correction, \nobservation (ii) follows from the fact that those stack entries which derive least-cost strings are effectively \ndeleted. Further, that stack symbol Y which can derive a , the error symbol, is in effect replaced by \nWC(Vn u ;t)* where y +*M uaw and u is the prefix to be inserted. Since w is determined solely by Y and \na , its size can be bounded by a constant. (b) Trivial. Q.E. D. We now consider the problem of deciding \nwhether an LL(l) grammar is insert-correctable, To do this, we characterize the situation in which tne \nerror-corrector is invoked. Assume we are just about to match some valid input symbol a with the top \nstack symbol. The stack is of ttle form aXn X1$ for n>O and X c(Vn u Vt) . We pop a and consider l \n n tile next input symbol b , which is in error. The error corrector will succeed if and only X ,$ can \ngenerate b . ifoneof l  n To decide whether ttlis can be guaranteed, we must characterize the possible \nsequences of stack symbols. We observe that a leftmost der\u00adivation of a string y in a cfg G corresponds \nREV exactly to a rightmost derivation of y ~REV REV is in a cfg (GG with all right\u00adhand sides reversed). \nWe can then easily estab\u00adlish that aXn X,$ can occur on the parse stack of an LL(l) parser if and only \nif $X1 Xna can be read by the Characteristic Finite State GREV l~aciline ([4]) which corresponds to \n. G is then not insert-correctable iff the CFSM for GREV can read a sequence $Xl Xna for which $X1 \nXnP* . ..b... for some bc~t . Since the CFSM is deterministic, we can associate a path with each input \nsequence. We need only consider cycle-free paths (if b can t be generated by a path with cycles, it certainly \ncan t be generated by that path with the cycles removed) and paths for which l  xncvn (otherwise terminate \nthe path at the first Xcvt). We then obtain: Theorem 3,4 An LL(l) grammar G is insert\u00ad correctable iff \nthe CFS!I corresponding to GREV has the property that for all b,~t and for all cycle-free paths of the \nform A $,x, , ,..Xn,a (n~O, X1,4 ..,XnCVnY aCVt) starting at the start state, $X1 Xn+* . ..b... . Usually \nit will not be necessary to generate the entire CFSM. Consider G2REV: S+$E E ~ E T E AE T+IE T+al)E( \nThe CFSM has the form: All cycle-free paths ending in a terminal will begin with $E , and since $E \n++ . ..b... for all bc~t, G2 is insert-correctable. 4. Implementation and Conclusion The error-corrector \ndescribed above has been successfully implemented and tested on an LL(l) grammar for a language similar \nto ALGOL W. The algorithms to compute the S and E tables (detailed in the appendix) proved to be acceptably \nfast, requiring less than 10 seconds on a Univac 1110 for a grammar with 99 nonterminals, 56 terminals, \nand 186 produc\u00adtions. Although the E-table is large, it can be stored efficiently in secondary stora~e, \nsince for each error-correction it is only necessary to access a single column of the table. This fact, \ncoupled with the results of the previous section, indicate that the tirle and space ctlaracteristics \nof tile LL(l) parser are not materially degraded when the error-cor\u00adrector is added. The only significant \nloss of efficiency (in space) is a result of requiring all LL(l) parser rather tilan a strol~g-LL(l) \nparser. For the above grammar, this tripled tile size of the parsing table, resulting in about 2200 non\u00adzero \nentries. However this still compares favor\u00adably with the size of tables (for similar grammars) employed \nby many bottom-up parsers. The following short (and meaningless) program provides examples of the kinds \nof corrections effected by Algorithm 2.2. The terr,rinal symbol insertion costs have all been fixed at \n1; con\u00ad siderable improvement could be expected through fitle-tuniflg adjustments of the cost vector. \nidote that insertions are made just ahead of tl~e symbol flagged as being in error. it~teger I J; t t \n real array A(5: ; if I=A) + goto L; I:= JJ:=K + I integer while K = 4 do; + $ The corrected program: \nbegin i)lteger I J; ***** : real array A(5: ID ) ; . **** if I=A (ID) . **** then gc&#38; L;  **** \nI:= J(J):=K ** ; begin . * integer procedure ID ;for Ib:= ID ~*xx**m******* wl~ile K=4~, end end $ . \n******* It is possible to allow it to search further down the stack (replacing all passed symbols X with \nS(X)) . A number of insertion strings There is an interesting variation of Algorithm 2.2 which will , \nin general, gener\u00ad ate lower cost insertions. As it is, the algorithm searches down the parse stack \nfor the first symbol which derives the error symbol. may then be computed, each a result o-f allowing \na different stack symbol to be the root of a derivation of the error symbol, and the least\u00adcost string \nis chosen. In the above example, procedure ID; for ID := ID is inserted be\u00adtween i)lteger and. while \nbecause the top stack - symbol is predicting tile remainder of a <type\u00addeclaration>, and a <type-procedure-decl \nara\u00ad tion> is capable of deriving a while The \u00adshorter (and presumably better) insertion string ID; for \nID := ID ! is obtained with the nlodi\u00adfied algo~ithm. Searching down the parse stack reveals cIlat the \nnext symbol, <statement-list>, is also capable of generating a while, and by replacing the rest of the \n<type-declaration> Witil ID, the lower cost insertion is found. Although we will not analyze it here, \nthe stack searcl~ is bounded if we insist that there is always a positive cost for replacing a stack \nsymbol by its least-cost derived string. Thus the modified algorithm will still operate in linear time \nand space. It sl~ould be emphasized that the error-cor\u00adrector we present is not restricted in applica\u00adbility \nto insert-correctable grammars. If the grtrmmar is not insert-correctable, the algo\u00adrithm will always \nfind a least-cost insertion if there is one, and could otherwise be modi\u00adfied to announce failure. The \nalgorithm can also be modified to allow deletions: simply adjust tl]e cost vector to make certain inser\u00adtions \nvery expensive, while adding a procedure to evaluate the cost of deletions. Algorithm  2.2 can thus \nbe used as the basis of a large family of LL(l) error-correctors. Appendix Algorithm A.2 The following \nalgorithm computes tl~e table comment Initialize; of It least-cost strings, S(A) , where AC~n simultaneously \ncomputes C(A) , iterating . for all for Ae~n jo all a~Vt~E(A,a) := (O,O,CO); over the grammar a minimum. \nuntil the costs converge to comment The main loop; Algorithm A.1 for all AE~n cl&#38;C(A) := CO; reoeat \n~HAHGE := true; for all p =-~l Xn) do ~ C(X1 xn) < C(A) repeat NOCHANGE:= true; for all ad do for \nall ~~(A~Xl Xn) do begin k := min (C(XT Xi-l) + K(Xi,a)); l<i<n commefit-let j be such that k= C(X1... \n-Xj ,) + K(Xj,a); if k < K(A,a) until %! : :ll$ i?!;~.-NOCHANGE:= false end NOCHANGE; . . S(xn); until \n _,a) end NOCHANGE; := (p,j,k); t/OCHA~iGE:= false end The i-tll iteration of the repeat loop of Algorithm \nA.1 calculates those least-cost strings having a derivation tree of height i. Every A~~n has a least-cost \nderivation tree of height ~ l~nl (trees of greater height must contain a derivation sequence . ..B. ..+aBy.aBy. \n. . which can be col\u00adlapsed). Thus at most l~nl iterations of the repeat loop are needed. The inner for \nloop will execute in time proportional to the size of the gramnar, IGI (/G/ is considered to be the number \nof productions plus the sum of the lengths of all the right-hand sides). The execution tine of Algorithm \nA.1 is thus bounded by O(l~n/.lGl) To facilitate the computation of the E-table (and to accommodate thernodified \ninsertion algo\u00adrithm discussed in section 4), we extend the E-table entries to include a cost conponent. \nThus if A +* . ..a... , then E(A,a) = (p,i,c) where p= (~~x x. 1 Xn) > w; pREFIX(Xi,a) and c = C(Xl \nO Xi-l W; . If A/+ . ..a... , . The number of iterations of the repeat loop is again bounded by ~~n] \n(for essentially the same reason as noted above), while the nested for loop iterations are bounded by \nl~tl and /G/ respectively. Thus the execution time of Algorithm 2.2 can be bounded by @nl l~tl lGl) . \nIn practice this algorithm can be improved substantially. Each time an E-table entry is changed, it is \nplaced on a stack. The stack is initialized with entries obtained from all one-level derivations. The \nmain loop then operates by (1) unstacking an entry; (2) stacking all other entries whose costs are lowered \nthrough application of the unstacked entry (this determination is facilitated by employing a table linking \nall nonterminals to their posi\u00adtions in all right-hand sides). The loop is terminated when the stack \nis empty, then E(A,a) = (O,O,CO) . \\/e define K(A,a) = c, where E(A,a) = (p,i,c) . For a,b~~t , if a=b \ntnen K(a,b) = O , otherwise K(a,b) = ~ . The following algorithm is very similar in struc\u00ad ture to Algorithm \nAl. References [1] Aho, A. V. and Peterson, T, G., A Minimum [17] Rhodes, S. P., Practical Syntactic \nError Distance Error-correcting Parser for Context-Recovery for Programming Languages. free Languages, \nSIAM Journal of Computing Ph.D. Thesis, Univ. of California, Berke 1, 4, 305-312, 1972, Dept. ofComp. \nSci, Tech. Rep. 15, 1973. [2] Aho, A. V. and Unman, J. D,, The Theory of [18] Teitelbaum, R., Context-free \nError Analy Parsing, Translation, and Compilinq, Vol. 1 by Evaluation of Algebraic Power Series. Prentice-Ht]ll, \nEnglewood Cliffs, N. J., Proc, ACM SIGACT Fifth Annual Conf. on 1972, Section 5,1. Theory of Computing, \nAustin, Texas, 196\u00ad 199, 1973. [3] Conway, R. W. and Wilcox, T. R., Design and Implementation of a Diagnostic \nCompiler for PL/1 . CACM16, 3, 169-179, 1973, [4] DeRemer, F. L., Practical Translators for LR(k) Languages. \nPh.D. Thesis, M.I,T., 1969. [5] Ghezzi, C,, LL(l) Grammars Supporting an Efficient Error Handling. Information \nProc\u00adessing Letters 3, 6, 174-176, 1975. [6] Graham, S, L, and Rhodes, S. P., Practical Syntactic Error \nRecovery. CACM18, 11, 639\u00ad650, 1975. [7] Gries, D., The Use of Transition Matrices in Compiling. CACM11, \n1, 26-34, 1968. [81 Gries, D., Compiler Construction for Diq\u00adital Computers. Wiley, New York, 1971, \n320\u00ad 326. [9] Irons, E. T., An Error-correcting Parse Algo\u00adrithm. CACM6, 11, 66Q-673, 1963. [10] James, \nL. R., A Syntax Directed Error Re\u00adcovery Method. M,S. Thesis, Univ. of Toronto, Computer Systems Research \nGroup Tech. Rep. CSRG-13, May 1972. [11] LaFrance, J. E., Syntax Directed Error Re\u00adcovery for Compilers. \nPh.D. Thesis, Univ. of Illinois, Urbana, Comp. Sci. Dept. Illiac IV DOC. 249, 1971. [12] Leinius, R. \nP., Error Detection and Recovery for Syntax Directed Compiler Systems. Ph.D. Thesis, Comp. Sci. Dept. \nUniv. of Wisconsin-Nadison, 1970. [13] Levy, J. P., Automatic Correction of Syntax Errors in Programming \nLanguages. Ph.D. Thesis, Cornell Univ., Comp, Sci. Dept. Tech. Rep. TR 71-116, 1971. [14] Lewis, P. M., \nRosenkrantz, D. J., and Stearns, R. E., Compiler Design Theory. Addison- Wesley, Reading, Mass., 1976, \n276-284, 462\u00ad469, 526-531. [15] Lyon, G., Syntax-directed Least-error Analysis for Context-free Languages: \na Practical Approach. CACM17, 1, 3-14, 1974. [16] Peterson, T. G., Syntax Error Detection, Correction \nand Recovery in Parsers. Ph.D. Thesis, Stevens Inst. of Tech., 1972. \n\t\t\t", "proc_id": "512950", "abstract": "An LL(1)-based error-corrector which operates by \"insertion-only\" is studied. The corrector is able to correct and parse any input string. It is efficient (linear in space and time requirements) and chooses least-cost insertions (as defined by the user) in correcting syntax errors. Moreover, the error-corrector can be generated automatically from the grammar and a table of terminal symbol insertion costs. The class of LL(1) grammars correctable by this method contains (with minor modifications) grammars used to specify most common programming languages. Preliminary results suggest that this method can be used to advantage in LL(1)-driven compilers.", "authors": [{"name": "C. N. Fischer", "author_profile_id": "81100312451", "affiliation": "University of Wisconsin-Madison, Madison, WI", "person_id": "PP43118826", "email_address": "", "orcid_id": ""}, {"name": "D. R. Milton", "author_profile_id": "81100102683", "affiliation": "University of Wisconsin-Madison, Madison, WI", "person_id": "PP39027227", "email_address": "", "orcid_id": ""}, {"name": "S. B. Quiring", "author_profile_id": "81100518142", "affiliation": "University of Wisconsin-Madison, Madison, WI", "person_id": "P348472", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512960", "year": "1977", "article_id": "512960", "conference": "POPL", "title": "An efficient insertion-only error-corrector for LL(1) parsers", "url": "http://dl.acm.org/citation.cfm?id=512960"}