{"article_publication_date": "01-01-1977", "fulltext": "\n + soclAL pROCESSES Permission to make digital or hard copies of part or all of this work or personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advantage and that copies bear this notice and the full citation on the first page. To copy \notherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission \nand/or a fee.&#38;#169; 1977 ACM 0-12345-678-9 $5.00 AND pROOFS OF THEOREMS AND PROGRAMS Georgia Richard \nInstitute A. DeMillo* of Technology Richard J. Lipton Yale and Alan University J. Perlis* I should like \nto ask the same question that Descartes asked. You are proposing to give a precise definition of logical \ncorrectness which is to be the same as my vague intuitive feeling for logical correctness. How do you \nintend to show that they are the same? . . . r, . . . [the average mathematician] should not forget that \nhis intuition is the final authority . . . + J. Barkley Rosser It is exactly those processes which mediate \nproofs of theorems in mathematics that require that program verification, as perceived by a large segment \nof the computer science community, is bound to fail in its primary purpose: to dramatically increase \none s confidence in the correct functioning of a particular piece of software. This is a view that we \nhave found to be shocking to many, but the key to our position rests on a relatively simple observation. \nA large measure of credit for the continued success and growth of mathematics belongs to the social mechanism \nof proving theorems; in proving + Many of the ideas reported in this paper were crystallized out of discussions \nheld at the DOD Conference on Software Technology, July 12 &#38; 13, 1976 in Durham, NC. We acknowledge \nin particular the help of J.R. Suttle who organized this con ference and has been of continuin~ encouragement \nin our work. This work was supported in part by the US Army Research Office, Grant No. DAHC04 74 G-0179, \nDAAG 29 76 G 0338 and by NSF Grant No. DcR74 12870. 3? Authors Addresses: R. DeMillo, School of In\u00adformation \nand Computer Science, Georgia Institute of Technology, Atlanta, GA 30332; R. Lipton, A. Perlis , Department \nof Computer Science, Yale Uni versity, New Haven, CT 06520. Logic for Mathematicians, McGraw Hill, 1953. \nprograms, however, these social mechanisms are almost totally lacking. It has been extensively argued \nthat the art and science of programming should strive to become more like mathematics. In this paper \nwe argue that this point of view is correct, but that the reasons usually given for it are wrong. In \nthe first part of the paper we present our view that mathematics is, rather than a formal process, an \nongoing social process and that the formalistic view of mathematics is misleading and destructive for \nproving software. In the second part of this paper we interpret these arguments as positive suggestions \nfor producing reliable software and better programming tools, and we conclude that there is every reason \nto believe that there are social mechanisms that can make program verifica\u00adtion more like real mathematics. \nWe have used proving in two different senses in a previous paragraph. The doubly quoted sense of proof \nrefers to the common notion of informal proof used in everyday mathematics; the italicized sense of proof \nrefers to the formal notion of proof that appears in the literature on program verification. By a proo~we \nshall mean the sort of valid, step-by step, syntactically checkable deduction as may be carried out within \na consistent, formal, logical calculus such as Zermelo-Fraenkel set theory or Peano arithmetic. We have \nbeen condi tioned to confuse proofs with proofs. Let us call this viewpoint monolithic. The monolithic \nview is the one of Hilbert school of logic: mathe matics proceeds from axioms (or postulates or hypotheses) \nto theorems by steps, each of which is easily justifiable from its predecessors by a fixed allowable \nrule of transformation. We will begin by arguing that the views of the Hilbert school can be very misleading \nand that mathematics is (and must be) highly non-monolithic. BELIEVING THEOREMS Indeed, every mathematician \nknows that a Proof has not been understood? if one has done nothing more than verify step by step the \ncorrectness of the deductions of which it is composed and has not tried to gain a clear insight into \nthe ideas which have led to the construction of this particular chain of deductions in preference to \nevery other one. -t N. Bourbaki Stanislaw Ulam [1] estimates that every year over 200,000 theorems are \npublished by mathemati cians. A fair number of these are subsequently contradicted or disallowed for \nother reasons, others are thrown into doubt, most are ignored, but a tiny fraction come to be believed \nby a sizea,ble portion of the mathematical community. Theorems that get published are seldom the work \nof crackpot scientists, and those that are discredited are not always the work of incompe tent mathematicians. \nIn 1879, Kempe [2] published a proof of the four-color conjecture which stood for eleven years before \na fatal flaw in the reasoning was uncovered by Heawood [3] (this fallacious proof, by the way, has since \nbeen rediscovered by many well-known mathematicians who managed to convince their colleagues that they \nhad at last solved this celebrated problem). The algebraist Britton published a monumental 300\u00adpage proof, \napparently settling an important problem i.n group theory [4]--unfortunately, the proof contains a flaw \nso subtle that it can only be detected by a very careful analysis of an i+ induction involving many lemmas \nchained together. Mathematical folklore is filled with stories of famous mathematicians whose best efforts \nwere sometimes less than perfect of, for instance, Legendre rising to address a mathematical con\u00adgress \nonly to pause, return his notes to his pocket, and quietly announce that the matter would + The Architecture \nof Mathematics, American Math. Monthly, 57 (1950): 221-323. HThe authors are indebted to Prof. Y. Zalcsteim \nfor this observation. require further thought. Just increasing the number of mathematicians working \non a given problem does not necessarily insure believable proofs. Recently two indepen\u00addent groups of \ntopologists (one American, the other Japanese) announced results concerning the same homotopy group (a \ntype of object arising in homotopy theory; a branch of topology). The results turned out to be contradictory, \nand since both proofs were very complex and involved detailed symbolic and numerical calculation, it \nwas not at all evident who.had goofed. But the stakes were sufficiently high to press the issue, so the \nJapanese and American proofs were ex changed. Obviously each group was highly moti\u00advated to discover \nan error in the others proof, but neither the Japanese nor the American proof could be discredited; \nyet one was clearly incor rect. Subsequently, a third group of researchers obtained yet another proof, \nthis time supporting the result in favor of the Americans. The weight of evidence now being against their \nproof, the Japanese retired to reconsider the issue. Notice that the probable truth of the theorem, at \nthis point, is still very low compared to the far more comprehensible results we tend to regard as theo\u00adrems. \nOne of the American mathematicians was so unsettled by this experience that he has since given up mathematics \nfor, presumably, a career in which the results of his labor can be judged more objectively. A recent \nissue of Science [5] contains a provocative suggestion that the apparently secure notion of mathematical \ntruth may be due for revision. The central issue here is not how proofs get believed, but rather what \nit is that is believed when one asserts his belief of a particular theorem. There are two relevant views \nthat may be roughtly classified as classical and probabilistic. The CZassieal View. When one believes \na mathematical statement A, one believes that, in principle, there is a correct, formal pPOOf of A in \na suitable logical theory that (semantically) completely formalizes the Aristotelian notion of truth: \n A is true if it says of what is that it is, and it says of which is not that it is not. Two points deserve \nspecial attention here. First, the classical view requires that we judge proper ties of mathematical \nobjects in a strictly biva lent fashion: a theorem either ascribes or fails to ascribe a property to \nan object. Secondly, the classical view does not require that every informal proof be accompanied by \nits formal counterpart . In fact, the classical view does not even require that it be humanly possible \nto produce such a proof. There is a mathematically sound reason for allowing the gods to formalize some \nof our arguments. For even the most trivial mathematical theories, there are simple statements whose \nfinite proofs are impossibly long. Albert Meyer s outstanding lecture on the history of such research \n[6] concludes with a striking physical interpretation of how hard it may be to prove comparatively simple \nmathematical state\u00adments . Suppose that we encode logical formulas as binary strings and set out to build \na computer that will decide the truth of a simple set of formulas of length, say,at most 1000 bits. Then \neven allowing ourselves the luxury of a techno logy that will produce proton sized electronic components, \nconnecting them with infinitely thin wires, the computer we design must densely fill the entire observable \nuniverse. These precise observations concerning lengths of proofs coin tide with our intuitions about \nthe amount of detail embedded in proofs. For example, we often use !! . . . let us assume without loss \nof generality . . . and !, . . . therefore, by renumbering if necessary . . . to replace enormous amounts \nof formal detail. T?w ProbzbiZistie Vieti. Since long proofs, in the classical view, can only be viewed \nas probably correct, it is perhaps reasonable to deliberately give probabilistic demonstrations of mathematical \nstatements. The reasoning is that a probabilistically valid proof may have the dual advantag@ of being \ntechnically easier than a classical one and may allow mathematicians to isolate those critical ideas \nthat give rise to uncertainty in classical proofs - hopefully, this process leads to a more plausible \n(classically) valid proof. An illustration of this notion is Michael Rabin s algorithm for testing probable \nprimality [7]. For very large integers N, all of the classical techniques for determining whether or \nnot N is composite fail because of computational reasons--more time is required for the test than is \nleft in the lifetime of the earth. Rabin s insight was that it is possible to guarantee that any such \nN is prime or not with vanishingly small probabili\u00adty of error, within a reasonable amount of time. In \nview of these difficulties, how is it that mathematics has survived and has been so success ful as a \ndescription of nature? Obviously, impor\u00adtant theorems get believed by mathematicians and mOst of these \nsurvive. Is it possible that this process is at an end, and that mathematics in its classical form will \nnot survive? Almost certainly not. The mechanisms that cause theorems to be believed and understood operate \nexceedingly well in large communities of mathematicians. Let us sketch some of these mechanisms. First, \nproofs are widely read. An author writes a proof down on paper and reads it for errors . In the common \ncase that several mathema ticians collaborate on the same proof, it is usually read by them all, by their \nstudents, and by many others. This leads to a second mechanism. Proofs are refereed, published and reviewed. \nThis is a triple filter. A referee must be con vinced before publication. A large audience must be convinced \nin a printed article. Finally, after some of the smoke has cleared, a reviewing publica tion such as \nMat7zematieaZ Reviews takes a more leisurely look at the proof. Third, mathemati\u00adcians talk to each other. \nThey give symposium and colloquium talks which attempt to convince doubting (sometimes hostile) audiences \nof their arguments, they burst into each others offices with news of insights for current research, and \nthey scribble on napkins in university cafeterias and expensive restaurants . All for the sake of convincing \nother mathematicians . They key is that other mathemati\u00adcians are inclined to listen! What happens to \na proof when it is believed? The most iamediate transformation is probably an internalization of the \n proof. ThJs leads usually to alternative proofs and several versions of the same theorem. An excellent \nsource of examples 208 of the transformations that can take place by this process is the little monograph \nby Paul Erd6s and Joel Spencer [8]. The combinatorial proper ties discussed in [8] are usually presented \nin a variety of guises, each of which aids the intuition in a slightly different way. After enough inter \nnalization and alternative proof construction, the community seems to decide that the central concepts \nhave an ultimate stab~~ity. If the various proofs begin to feel right and the con\u00adcepts are examined \nfrom enough angles, the classi\u00adcal truth of the theorem becomes established. The next activity that sometimes \ntakes place is that the theorem is generalized in some way. If, in the passage to the generalization, \nthe social mechanisms lead to the belief of the generalized proof, then the probable truth of the original \nstatement is considered established. Finally, important theorems are used. They , may appear as lemmas \nin larger proofs ; if they do not lead to contradictions, then the confidence in the supporting lemmas \nof a larger proof is increased. Theorems can be used in other ways. For example, engineers use theorems \nby plugging in values and relying on a particular physical interpretation of the conclusion. Planes that \nfly and bridges that stand are impressive evidence of belief in theorems. Believable theorems sometimes \nmake contact with other areas of mathematics important ones invariably do--and the successful transferal \nof information between distinct branches of mathe\u00ad matics also increases confidence in theorems. The \nmost famous example of this sort of techno\u00adlogy transfer is Hadamard s proof [9] of the prime number \ntheorem. This celebrated proof uses connections established by Riemann and Dirichlet between theorems \nin complex analysis and certain asymptotic properties of the sequence of prime numbers. A more recent \nexample of the same phenomenon is the comparatively rapid digestion of the notion of @Z&#38;ng into mathematical \nlogic. Paul Cohen s original proof [10] of the independence of the Axiom of Choice and the Generalized \nContinuum Hypothesis from the remaining axioms of set theory was so radical that it was believed (i.e., \nunderstood) by very few logicians. Dana Scott, Robert Solovay and J. Barkley Rosser internalized Cohen \ns central notion of forc~ng giving it an alternative algebraic characteriza\u00adtion [11]. Abraham Robinson \nand others [12] con netted forcing arguments with more familiar ideas in logic, generalized the concept, \nand found the generalization to be immensely useful. When Cohen announced his results to the National \nAcademy of Sciences in 1964, very few logicians believed his proofs. By 1976, forcing arguments are routinely \nstudied by graduate students in logic and are used as standard tools in certain areas of logic (half \nof the papers examined in random selection from the Journal of Symbolic Logic make essential use of forcing). \nLet us summarize the main argument of this section. Working mathematicians usually do not believe proofs \nbecause they believe that they can translate them to a formalized logical theory to act as the ultimate \narbiter. Rather, mathe matical theorems get believed because they are: 1. read 2. refereed, published, \nand reviewed 3. discussed 4. internalized and paraphrased 5. generalized 6. used, and 7. connected \nwith other theorems.  THE ROLE OF SIMPLICITY We acknowledge that very few theorems are subject to azz \nof the filters 1 through 7 listed above. Indeed, the degree to which a theorem is believed is largely \ngoverned by its importance, and this seems to be highly correlated with its simplicity of statement. \nAs a general rule, the most important mathematical problems are clean and simple to state. An important \ntheorem is much more likely to take the form !lkeorwrn. Every - - is a - --, rather than the form Theorem. \nIf -- -and - -and --- and ---\u00adand -----except for special.cases i. ------------\u00ad. xx--------------\u00ad \ns then unless i. -------------, or . ~iv.----------\u00adevery that satisfies ---is a ----\u00ad ---- The problems \nthat have most occupied mathemat-human activity and are thus detailed and messy, icians since Thales \nhave been simple to state. reflecting the ad-hocery and defaults which are In fact, mathematicians probably \nuse simplicity imposed upon them by their human designers. Real as a first guage of a problem s importance, \nso programs are not simple in the sense we mean here, that the decision to consider a proof in de-and \nthe theorems that arise in trying to prove tail is often influenced by some slightly irra-real programs \nare not simple. tional concern how does the problem feel? This BELIEVING SOFTWARE ,, is Occam s razor \nfor mathematics; Einstein held that the maturity of a scientific theory could The program itself is the \nonly complete description of what the be judged by how well it could be expla$ned to the program will \ndo-. man on the street [13]. A similar criterion + P. J. Davis aPPlies to mathematical theories. The \nmechanisms that save proofs of mathe Of course, a judgement of simplicity must matical theorems are the \nones that doom proofs of be tempered by the underlying theory. The four\u00adsoftware. Let us concentrate \non program verifica color conjecture rests on such slender foundations tion by the method of inductive \nassertions. that it can be stated with complete precision to The kinds, of specifications that usually \na child. The Riemann hypothesis asks about accompany software tend to be long and complex. location of \nthe zeroes of the complex function m That is, the verification conditions that result s from common input \noutput assertions (these are c(s) = n, z the theorems to be p~oved) seldom satisfy the ~. 1 simplicity \ncriteria outlined above. Workers in which may not be clear to a non scientist, but the area of program \ncorrectness counter this argu\u00ad certainly requires only the most terse introduc\u00adment by claiming that \nthe long complex theorems to tion to mathematics. The deeper independence be pPoved are seldom deep; \nthat they are, in fact, questions of set theory are similarly basic; can, usually nothing more than extremely \nlong chains for example, the existence of certain large ob of substitutions to be checked with the aid \nof jects be proved from the remaining axioms of set simple algebraic identities. One group we know of \ntheory ? Even though it requires some effort to has taken this concept to its extreme by proposing be \nprecise in stating such a problem, the that verification conditions be proved by teams informal statements \nserve the intuition very well. of grunt mathematicians. Presumably, these are A simple statement of category \ntheory may look very to be teams of low level mathematical technicians complicated as a formal statement \nin axiomatic set who will savant style check the verification theory; but we are generally willing to \nallow for conditions . Besides offending the sensibilities, this sort of translational phenomena because \nof the grunt mathematician concept is exactly why the social processes. Category theorists have verification \nmust fail. internalized the fundamental concepts of their What program provers have failed to recog field \nin ways which are foreign to, say, set theo\u00adnize is that the proofs will be unbelievable, not rists. \nBut the important concepts are simple in because the theorems that are being proved are their domains. \ndeep, but rather because the social mechanisms The point, again, is that simple, unspecial\u00adthat we have \ndiscussed here simply will not apply ized theorems those that are easy to state and to the kinds of theorems \nthat they are proving. motivate in a specific domain are far more likely The theorems are neither simple \nnor basic, and to be read, published, and used, than idiosyn the proofs of even very simple programs \nrun into chratic, narrow theorems that apply to such a dozens of printed pages. Thus , the incentive \nfor paltry class of structures that no mathematician +,,, will ever again consider the class. Yet it \nis Fidelity in Mathematical Discourse: Is One and One Really Two? American Math, Monthly,exactly this \nkind of theorem that arises in pro\u00ad (1971):252-263. gram proving. For real programs deal with real a \ncommunity to accesa and assimilate the proof of an individual piece of software is no longer present; \n~pOOfS simply will not be read, refereed, discussed in meetings or over dinner, generalized, or used. \nThey are too specialized for any of those activities. The sad fact is that the kind of mathematics that \ngoes on in proofs of correctness is not very good. There are, of course, algorithms that do get proved. \nBut these tend to be algorithms like FIND f143, which while generally useful, have nothing to do with \nsoftware---the kind OF program that is written for specialized uses and which must operate in a production \nprogramming environ\u00adment ! The fast pattern matching algorithm of Knuth, Morris and Pratt [15] was first \nimplemented and ~Poued by Jim Morris as part of Berkeley s text editing system. Subsequently, a system \nprogrammer who did not understand the new algo\u00adrithm, pulled it from the text editor and replaced it \nwith a much slower pattern matching routine. Presumably the system programmer undersood the new algorithm. \nThe point is simple: the kinds of algorithms that get proved correct have nothing to do with software; \ngive a choice between a very good algorithm with a proof of correctness, but which may be hard to understand, \nand a straightforward, unproven algorithm which an implementor believes he understands, the com plex \nalgorithm invariably loses. And, it is the complex algorithms that are most interesting and have the \nmost chance of being subjected to the sociology of proof. There have been several apparent trap doors \nleft in our argument thus far. We will now seal them off. What about machine aided proof systems? Well, \ntotally automated prwof systems are out of the question for a variety of reasons. In the first place, \nthe lower bounds [16] on the length of computer proofs for mathematical theories paints a very dim picture \nof automated Proof Secondly, researchers in the area do not even take seriously the possibility of totally \nauto\u00admated proof. Ralph London [17] characterizes the out-to-lunch program verification system as one \nthat can be left in an unsupervised mode to grind out the proofof a program. Even if an out to\u00ad lunch \nsyst~m could be built (and London doubts that such a system Can be built) to work with reasonable reliability, \nimagine the reaction of a programmer who inserts his 300-line input-output package and returns several \nhours later to find the message VERIFIED, followed by a 20,000 line proof. We seem to be left with some \nkind of man\u00admachine system that uses machine checks on complex proofs . This type of system, of course, \ndoes not help at all. The human prover still makes mis\u00adtakes that will never be subjected to the social \nprocesses of proof. Another apparent way out is to use very high level languages to raise the intellectual \ncontent of the theorems being proven. The strategy here is to use the fact that very high level languages \ncan deal directly with a broader range of mathema tical objects to insure that the complex theorems resulting \nin a set of verification conditions will be truly interesting and therefore subject to the social processes \nwe have been discussing. Unfor tunately, the situation in proofs of very high level programs is not much \nchanged over their lower level counterparts. For example, the following verification condition arises \nin the proofof a Fast Fourier algorithm written in Madcap, a very high level language similar to SETL \n[18]. Theorem (?). If N is a pOwer of 2, F is a complex vector and r is an integer, and if 2rrSi/NSE{1,-1} \nand b=2 ,and C= {2j : 0Lj2N/4], then i. <bj :OLj LN/4> =<ar :a = r r mod n/2 b and O < r<N/2> ).(j ii. \n<j : OSj<N/2 :jmodN N/2 and O~j <N ) iii. ifF=f =x=x and O ~r < N (rrr ) then P(FA + FA*) b a(FA FA,)) \n= < (kl Ir 2r-1 I)mod N xkfr:fr= b (I k CR At some level, the transition between lr and R = {j : (j-r) \nr ZOmod N/2})  specification and program must be left unformalized; this follows by two compelling observations. \nFirst, the data sets on which programs operate are, in general, enormously complex objects. In computing \nthe payroll for the French National Railroad, for example, we find that each employee has more than 3,000 \npay rates, incorporating, for instance, the time his train was traveling uphill versus down hill. Similarly, \nthe input assertions for many numerical algorithms are not even formulatable-\u00adcertainly they cannot be \nformalized [19]. The second observation seems to us to be the most telling, however. The purpose of a \nprogram is an informal, often unstated, criterion and the tran sition from informal to formal objects \nmust forever be unformalized, lest we be caught in the paradox of assuming the formalization of an object \nwe know only informally. CONSTRUCTING BELIEVABLE SOFTWARE One of the chief duties of the mathe matician \nin acting as an adviser to scientists . . . is to discourage them from expecting too much of mathematics. \n+ N. Wiener We can combine the arguments of previous sec tions with the intuition gathered from a century \n(or so) of experience in dealing with mathematics in a symbolic, formalistic way. Since symbols can \nbe written and moved about with negligible expenditure of energy, it is tempting to leap to the conclusion \nthat anything is possible in the symbolic realm. This is the lesson of computabi lity theory (viz., solvable \nproblems vs. unsolva ble problems), and also the lesson of complexity theory (viz., solvable problems \nvs. feasibly solvable problems) : physics does not suddenly break down at this level of human activity. \nIt is no more possible to construct symbo2ic atruc tures without using energy than it is possible tO \nconstruct material structures for free. But if symbols and material objects are to be identi fied in \nthis way, then we should perhaps pay special attention to the way material artifacts are engineered, \nsince we might expect that, in + I Am a Mathematician, The Later Life of a Prodi Q, MIT Press, 1964. \n principle , the same limitations apply. Before we return to our theme of relating proofs to believ\u00adable \nsoftware, let us briefly digress to consider the role of engineering principles. It appears to us that \nthe engineering pro\u00adfessions have been remarkably adept at reconciling the normal-cultural desires for \nthe creation of reliable structures w ith two human failings: (1) human beings cannot create perfect \nmechanisms, (2) human beings tend to plunge into  activities before they are understood. Surprisingly, \nthis reconciliation is accomplished by virtue of the same social mechanisms we have been extolling. First, \nin mature engineering disciplines, reliable never means perfect in the monolithic, classical notion of \nperfection. There are simply no proofs (or proofs ) that bridges stand, that airplanes fly, or that power \nsystems deliver electricity. Rather, engineers set probable limits of failure, relying on other design \ncriteria to place these limits well above the con ditions likely to be encountered in practice. It is \nperhaps symbol chauvinism which suggests to computer scientists that (a) our structures are so. much \nmore important than material structures that they should be perfect, (b) our available energy is, in \npractice, sufficient to certify pro grams as perfect. We now see connections with mathematics: the probabilistic \nview of mathematical truth is closely allied to the engineering notion of reliable structure. This suggests \nthat we should make more serious attempts to treat software reliability in a setting distinct from program \nproving, since both merely establish expected limits of confidence. Second, engineers tend to counteract \nthe human tendencies to try untested designs by lim iting the amount and kind of innovation in designs. \nThis suggests that engineers tend to recycle designs and to thus subject them to some of the same social \nprocesses as are present in mathematics. Is the situation as bleak as we suggest? There are almost certainly \nmechanisms which make software more like mathematics in the, reaz sense i.e., which elevate software \nto the level at which the social processes described above operate. Many of these mechanisms are just \napplications of 1 unselfconscious engineering design principles (e.g., seek reliability within economic \nlimits, channel innovation into constructive paths by reusing previously successful designs), while many \nare straightforward extensions of our thoughts on what causes mathematics to be, in the main, successful. \nThe desire to prove programs correct is constructive and valuable; the monolithic view of proof has succeeded \nin hiding the primary benefits to accrue from program proof. What we have done is to point out a basic \ndifficulty with any large-scale attempt to prove programs correct. However, proofs of software may be \ncoupled with engineering techniques and may yet succeed. Indeed there is considerable evidence that the \nverification of software can be subjected to the key social processes that allow us to understand and \nbelieve mathematical proofs ; i.e., there are mechanisms with which to make software more like real mathematics. \nThe first mechanism which may be exploited is the device of creating general structures, the rarious \ninstances of which become more reliable due to the believability of the general struc tures. In particular, \nthe Alphard notion of form appears to be exactly the sort of mechanism that encourages this sort of activity: \n . . . a library of useful abstractions will develop, and . . . programmers will simply not have to program \nas much to get a new system . . . [20]. This notion has appeared in recent years in several incarnations: \nDonald Knuth s insistence [21] in the creation and understanding of general\u00adly useful algorithms represents \nsuch a trend; the team programming methodology of [22] is another example of attempts to ezport software \nexplicitly for the purpose of exposing it to social proces ses. Reusability of effective designs causes \na wider community to examine the programming tools to be most commonly used. A second mechanism is the \nnotion of high level proof. We have basically argued that a proof of correctness will not be correct. \nHow ever, if proofs are correct, they must be generally us~~-ul in order that Information may be extracted \nfrom them. The metaphor here is that algorithms yield ideas about other algorithms and are thus exportable, \nwhile low level proofs may not be exported. The languages of proof must be carried out in high level \nstructures -certainly at higher levels than programming is done. Consider that theorems which are subjected \nto social mecha\u00ad nisms are exported to a larger community, and if they are created in high level languages \nthen instantiation to programs become feasible and con sistent with our other mechanisms. The concept \nof verifiably correct software haa been with us too long (as a goal) for it to be easily displaced; in \nfact, as a goal it offers con siderable impetus for research in computer science, providing for example \na ladder to even more export\u00ad able programming tools and methodologies. For the practice of programming, \nhowever, the notion of program correctness has overshadowed that of pro gram believability. Like good \nscientists we should not confuse our mathematical models with reality and correctness (like proof) is \nnothing but a model of believability. Relatively little philosophical discussion (see e.g. [23]) has \ngone into determining alterna\u00adtive methodologies, developing technical tools, and creating research paradigms \nfor other styles of reliability issues. We feel that the growth of complex software systems has not yet \nbeen discussed using metaphors that are sufficiently precise for development of alternative views of \nsoftware believability. When another view of reliable design arises that more fully exploits the social \nmechanisms which have proved useful in the development of mathematics and for which we have argued in \nthis paper we expect to see technical developments follow in this alternative track. References 1. S. \nUlam, Adventures of a Mathematician, Scrib\u00adner, 1975. 2. A. B. Kempe, On the Geographical Problem of \n the Four Colors, Amer. J. Mathematics, V. 2, (1879), pp. 193-200. 3. P. J. Heawood, Map Coloring Theorems, \nQuar\u00adterzy J. Math. Oxford Ser., V. 24, (1890), pp. 322-332 213 214 4. 5. 6. J. L. Britton, The Existence \nof Infinite Burnside Groups, in W. W. Boone, F. B. Can\u00adnonito and R. C. Lynden (eds.), Wor2d Prob\u00adlems, \nNorth-Holland, (1973), pp. 67-348. G. Bari Kolata, Mathematical Proof: The Genesis of a Reasonable Doubt, \nScience, Vol. 192, (1976), pp. 989-990. A. Meyer, The Inherent Computational Com\u00adplexity of Theories \nof Ordered Sets: A Brief Suzvey, Proc. International Congress of Mathematicians, August 1974. 22. 23. \nF. T. Baker, Chief Programmer of Production Programming, nal, Vol. 11, No. 1, (1972), S. L. Gerhart and \nL. Yelowitz, of Fallibility in Applications Programming Methodologies, in Software Engineering, Vol. \n(September 1976), pp. 195-207. Team Management IBM Systems Jour-PP. 56 73. Observations of Modern IEEE \nTransactions SE 2, No. 3 7. M. O. Rabin, private communication. 8. P. Erdos Methods (1974) . and J. Spencer, \nin Corbinator its, P~obabilistie Academic Press 9. J. Hadamard, Sur la Distribution des de la Fonction \nC(S) et ses Consequences metiques, Bull. See. Math de France, (1896), pp. 199-220. Zeros Arith-V. 24, \n10. P. J. tinuum USA, Part Cohen, The Independence of the Con Hypothesis, PPOC. Nat. Acad. Sci., Part \nI, V. 50, pp. 1143-1148 (1963), II, V. 51, pp. 105-110, (1964). 11. J. B. Rosser, Academic Press, Simplified \n(1971). Independence Proofs, 12. A Robinson, Infinite Forcing in Model Theory; in J. E. Fenstad (cd.) \nWoe. Second Sean dinavian Logic Symposium, North-Holland, (1971), pp. 317-340. 13. R. W. World Clark, \n(1971). Einstein: The Life and Times, 14. C. C. A. M., R. V. Hoare, 4(7), Algorithm (1961), pp. 65: \nFIND, 321+. C. A. 15. D. Knuth, Matching Computing. J. Morris, in Strings, V. Pratt, to appear Fast \nin Pattern SIAM J. 16. L. Stockmeyer, The Problems in Automata Thesis, (1974). Complexity Theory and \nof Decision Logic, MIT 17. R. London, private communication. 18. J. Schwartz, On Programming, NYU Courant \nReport, 1973. (See also A Comparison of MADCAP and SETL by J. B. Morris, Los Alamos Sci. Lab, University \nof California, Los Alamos, NM, 1973.) 19. J. K. Rice, private communication. 20. W. A. Wulf, Abstraction \nCarnegie Mellon Department R. L. London, and Verification University, Research Report, and M. Shaw, in \nAlphard, Computer Science July 1976. 21. D. E. Kn.th, Vol. I (1969), Addison Wesley. !7!ke Art Vol. of \nII Computew Pro@-ming, (1969), Vol III (1975), \n\t\t\t", "proc_id": "512950", "abstract": "", "authors": [{"name": "Richard A. DeMillo", "author_profile_id": "81100059944", "affiliation": "Georgia Institute of Technology", "person_id": "PP43115675", "email_address": "", "orcid_id": ""}, {"name": "Richard J. Lipton", "author_profile_id": "81100546583", "affiliation": "Yale University", "person_id": "PP15035881", "email_address": "", "orcid_id": ""}, {"name": "Alan J. Perlis", "author_profile_id": "81100086771", "affiliation": "Yale University", "person_id": "P12703", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512970", "year": "1977", "article_id": "512970", "conference": "POPL", "title": "Social processes and proofs of theorems and programs", "url": "http://dl.acm.org/citation.cfm?id=512970"}