{"article_publication_date": "01-01-1977", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1977 ACM 0-12345-678-9 $5.00 A COP!PLETEAND CONSISTENT HOAREAXICWTICS FOR A SIMPLE PROGR/-WlING LANGUAGE \nby J. Cherniavsky &#38; S. Kamin SUWYat Stony Brook, ~.Y. Introduction The problem of formal correctness \nproofs for programs has received a great deal of attent~ol, [MA] . Recently models have been developed \nfor verification systems that allow the formulation of questions concerning the consistency and complete\u00ad \nness of such systems. In this paper we present the axiomitization of a simple programming language, Lm \n(Meyer and Ritchies [MR] Ll with menus 1), along with interpretive model based on Presberger s arithmetic, \nP We show the verification system + to be consistent and complete with respect to the interpretive model \nand develop a relative com\u00adplexity result. The complexity result states that in a proof of P{A}Q, the \nsize of any line of the proof is no larger than a polynomial in \\Pl+lAl+l Ql assuming that we don t count \nproofs ly\u00ading solely in P+. Lm is the first non-trivial programming lan\u00adguage in which a complete and \nconsistent interpre\u00adtive semantics has been given. Furthermore, our complexity result is an encouraging \nresult for those hoping to automate parts of the verification process. Given a mathematically astute \nprogrammer (whomwe assume can decide the validity of P+ formulas), the verification of any program in \nLm is computationally feasible. This is because the space necessary to write down assertions that must \nbe checked for validity is bounded by a polynomial. Although L is not a general purpose language, it \nm is fairly powerful in that it computes all the + representable functions. Also, as Cooper points out \n[CO], a significant fraction of mathetnatics arising in proofs about programs lies in P+. Preliminarie~ \nWe fix an assertion language, a programming language and a model for the assertion language calling them \nrespectively LA, PA and Let A A be a program in PA, P and Q assertions in Then we call formulas of the \nform p{A}Q A correctness formulas (CFS). A Hoare-type axiom system for P then consists of axioms in \nthe form A of CFS and inference rules whose assumptions con\u00adsist of CFS and assertions, and whose conclusions \nare CFS. For any program A and assertions P and correct wrt P, Q and Q, I-LAP{A}Q (A is LA) if P~A}Q \nis the last line in a sequence af lines consisting of (1) Axiom CFS (2) Proofs of assertions in  A \n(3) Instances of conclusions of inference rules where the assumptions occur on earlier lines. An interpretive \nmodel for the above system con\u00ad sists of a model for the assertion logic, and A a model for computations \nin P This second A model is normally defined by specifying the actions of program components on program \nstates (e.g. , ~+~+1 changes the state s by incrementing the component in s corresponding to x). We then \nsay s such that P is true on s and A executies and l= MAp{A]Q istrueprovided that for all states halts \non s, Q is true of the resultant state. An axiom system is consistent if for all CFS com-A plete if ~L \np{A}Q+ I=MAP{A}Q. An axiom system is I=M P{A}Q > I-LA P{A}Q. A1l axiom A systems should be consistent, \nhowever, completeness is generally impossible due to three factors: (1) The logic LA may be incomplete, \n (2) The logic LA may be too weak, (3) The Hoare system (irrespective of the  completeness of LA) may \nbe incomplete. k example of (1) is where is first order A arithmetic and we examine True {x+x}P. This \nis provably correct exactly when P is provable in it is true exactly when P is valid. Godel s A incompleteness \ntheorem then tells us that the axiomatic are incomplete. An example of (2) is when P is, say, Constable \ns G3 [CB] (a univer A sal programming language with simple primitive statements) and P+. Then given a \npro\u00ad A s gram A, which halts with Output Z=O exactlY when its input x is a square, to prove true {A} \nZ=O requires an assertion in P+ which is true exact\u00adly when x is a square; this is impossible in P+[E] \n. When a situation as (2) arises, A s said to be inexpressive. An example of (3) is present in [CL] where \ncall by neme parameters in procedures lead to incompleteness even assuming LA is complete with respect \nto A We will be concerned with like questions in analyzing programming language Lm and logic P+. Since \nP+, relative to a suitable axiomitization [M], is complete (1) does not apply. Likewise, we will demonstrate \nthat (2) and (3) do not apply. Our main result is that I=ol P{A}Q =~l-p p{A}Q. + The language ~ can be \ndefined by the following BNF : PROG ?:= LOOP x PROG1 END IPROG ; PROG / PROG1 PROG1 ::= x+y I X+X21 I \nx+x+1 I x*O / PROG1;PROG1 where x and y are variables and +1 and 21 have their usual interpretations \n(x-1 = XL1 if x>O, O otherwise). Programs in L operate over m the natural numbers and LOOP x A END is \nto be interpreted as requj.ring val(x) executions of A (A is a PROG1). The logic P+ is the set of true \nfirst order statements about the natural numbers in which the allowed operations are X+y, X+l, x: 1, \nX2Y, x div ~ x rem k and the allowed predicates are x.() , X=y, x<y, x<y, x>y, x>y, and x~y mod k; where \nkiss constant. A n-ary relation R is P+ represen\u00adtable by Q(xl, . . ..xn) provided that <a, . . ..an>eR \n<% .,,,an) is true for Q(al, 1 al%. ..,an natural numbers. Axioms and Interpretive Model / Let Pve be \nthe uniform substitution of expres\u00ad sion e for free variable v in P. The axioms and inference rules for \nL then consist of: m Al P;+l {X+x+l} P A2 ~:1Px {x + X:11 P (3) COMP(S,LOOP y A END) = S . LCOMP(S,A,I) \nA3 A4 % Px Y {X+o} {X+yl P P where LCOMP(S,A,I) COMP(S,A)  I = S(y) = if 1=0 LCOMP(s ,A,I~l) then A \nelse RI p {A} Q, Q {B} R where s = OUT(S,A) p {A; B} R R2 z>O &#38; P(z) {A} P(z~l) We then write l=Np \n{A} Q iff for all states s P(z); {LOOP y A END} P(z): and s , variables if P provided is true by s under \nand the assignment s MOUT(S,A), of then Q where z and y are free in P is true under the assignment provided \nby s . R3 P > P, p {A} Q, Q => Q Consistency As is and Completeness frequently the case with consistency \nand p {A} Q completeness results, the consistency results are The interpretive model for Lm is based \nupon the easieat. It suffices to show that the axioms P+ and its standard model IN, the integers, with \nand inference rules are true in the interpretive all operations in pretations. Let program variables \nP + taking their s be an assignment to values in IN standard of free (s is the inter\u00ad model. Lemma model. \nProof: We consider 1: The LOOP Assume /=N the rule z>O hardest case. is true in the &#38; P(z) {A} P(z~l) \ninterpretive and program which state). takes a We program define state COMP and to a be a program function \nand maps assume I = S(y). s is If such 1=0 , that then P(z)z is Y COMP(S, true. LOOP y Let A END)= them \nto the sequence of execution states resulting S.h = s. But in this case P(z)~[s] ~ P(z)~[s] from the \nprogram s execution, Auxiliary functions since s(Y) = o. If I > 0, then COMP(S,LOOP y LCOMP COMP. yields \nand OUT OUT of the last are necessary a program state state in the in the definition and a program sequence \ndefined of just by A END) = S,-aq .s9. L/.L ai+l si+l =COMP(Si,A). assumption to the . . . .aT s~ . . \nFrom loop rule, where s, = . the truth of (P(z) &#38; z > s, the O)[si] CF => COMP. (P(z:l))[si+l]. Thus \nby induction on I, The assignment value s of is predicate denoted P as under P[s]. variable We now define \nP(0) [sI] is true hence P~[sl] is true. Q.E.D. COMP as follows: The remaining cases are straightforward \nalong the lines of [CK]. ~+~+1 Completeness, as is frequently the case in (1) COMP(S,;-J1) X+o s(x) s \n(x) s (x) = s (Y) o +1 11 s where 51=5 except mathematical logic, is considerably more difficult to \nshow. We say a logic is expressive with respect to a programming language if for every assertion P in \nthe logic, program A and state s, thenis an (2) COMP(S,A;B) = COMP(S,A) . COMP(OUT(S,A))B) assertion \nQ such that Q is true exactly for s , when P is true of s and A executing on s 3 yields s (i.e., Q is \na strongest post con\u00addition (SPC) for P and A). This can also be stated as: Q is a SPC for P and A provided \nthat I=NP{A}Q and for all assertions R, if I=N P {A} R then Q => R is valid. In our com\u00adpleteness proof, \nwe need to show how to explicitly construct the SPC for A in Lm and P in P+. ,All cases are straightforward \nexcept for LOOP; in the case of LOOP we need some preparatory lemmas. Let A be a L program consisting \nof prim m itive statements Xi+xi+l, Xi+xi l, xi+O and , ~ ,+X with n program variables. The primitive \nlJ operations correspond to the monadic functions +1, 1 and 6 (where 6(x)=0 for all x). A single execution \nof A results in a final value for each x. in terms of a sequence of the above functions 1 applied to \nsome variable x.. Let r (map indices 3 to indices) be such that the value of x after i one execution \nof A is f.x that is r(i) 1 r(i) chooses the v?.riable that x.= depends upon after one execution of A \nand fi is the function sequence operating on that variable. We have the following lemmas: Lemma 2: For \neach i, there exist p,q depen dent upon i such that p+q s n+l and rp(i) = r +q(i) where rp(i) is the \np-fold composition of r. Proof: By the pigeon hole principal. Lemma 3. The value of variable xi after \nm executions of A is: x =f O...of )k. i rp-l . (f  frp+q-l(i) i (1) rp(i) f frp+s l(i) x r p+s(i) \nrp (i) where p and q are as in lemma 1 and m = kq + p% (S<q)-Proof : We prove by induction on m. m=o \n: xi =xi. m=n : Assume for m=n=kq+p+s that k xi =f. f f o(f 0...0 1 r(i)  rp l frp+q l), (i) rp(i) (1) \nf 0...0 f rp+s-l rp(i) (i) rp+s(i) m=n+l : The value of any variable xi after one execution of A transforms \nto f.x I r(i) Since k. the index of x is r(l), x, tran sforms to m(i) Substituting into case m=n we \nk r (: )Xr(rk(i)) have k x= fi . . ..of (f o...of i ~p l (i) rp(i) r +q-l(i)) 0 . rP(i)o  frP+s(i) rP+s+l(i) \n If s+l=q, by lemma 2 we have o(f o...of k+l rp-l rP(i) Xi=fi. of (i) rp(i) r +q-l(i] and m = (k+l)* \nq+p. Otherwise, the formula as it stands is correct. Q,E.D. 1 Lemma 4: Equations of the form xi = al \no.... i n c1 .x, where i n l  in are + epresentable and is a sequence of functions from aj {~,+1,-1}, \nare P+ representable. Proof: The proof proceeds by induction on n. case O: With n=O, the equation reduces \nto Xi=x which is in P + 1 i case n: Assume that al OB. .OannOX = xi is P+ representable by a formula \n@(ii,...,in,xi,x). 1 i noakox = x is case n+l: To show that o . . .o~ aln i P+ representable we use \ncase n and substitute cxkx for all occurrences of x, CLkX can appear in three sorts of atomic formulas: \n&#38; (x2p &#38; k#O) =>(m(ctm+r*(k-1) + z ti) < z tj &#38; Proof: Formulas arising from lemma 3 are \nof the I is a new variable, is the T component (i) (ii) m*akx+ Z tit i Etj j Z t < ii +m*akx X tj j \\ \ni=l) case .> b: m*x + x i Ifx<p, t i <Zt.]. i~ then any i execution of j a results (iii) ~ i ti = X t. \njJ + m*akx in a constant c less than p. Ifx2pandk <(x p) div r, then x is decreased by k*ro If m is the \nnumber of occurrences of akx in the X?p and k > (x-p) div r, then x is set to c. atomic formula are terms \nfree (and of is k a x. a constant) We will and {t.}, {t. } 1 J only prove case The formula [(X~p &#38; \nk#O is &#38; then: k < (x-p) div r) (i), the other cases are similar. a can have four . > effects (a) \na and upon x: can increase # 6 s = O) x (if # +1 s > # :1 s &#38; (X+ &#38; k+O &#38; k => 2 (x-p) m*c \n+ div Zti i r) < Zt jj (b) a ~15 can = decrease ()) x (if # +1 s < # ~1 s and &#38; (X<p &#38; k+O) => \ni . jJ (c) a can leave x unchanged (if # +1 s = # ~1 s &#38; k=O => m*x+ Eti i < Zt.]. jJ and # 6 s = \nO) case c: If x < p, then a sets x to a con\u00ad (d) a can set x :0 a constant (if # 6 s > O), stant C=p, \nIf X 2 p, then a does nothing In cases (a) -(c) consideration must be taken of to x. The formula is: \nsmall values of x ind of k (e.g., if a = [(x>p &#38; k#O) => m*x+ Zti i < Zt. jJ +1 2; ~1 if ~1 11 x=2 \nand then x > x 2, is then decreased x is by decreased 1; if k by = O, &#38; (x<p &#38; k#O) => m*c + \nZti i < Zt jj then there is no effect upon x). Let p be the &#38; k=O => m*x+ Et. iJ < Zt.]. jJ largest \ndecrement that any suffix of a applied to x yields (in khe above example p = 3). Let r case d: a sets \nx to a constant c. The total be the excess of +1 s over :1 s in (a) and formula is then: the excess of \n~1 s over +1 s in (b). We can now [k#O => m~~c + Zti i < Zt jj analyze case a: transform cases Ifx2p, \nx (a)-(d), to x k executions + r*k. If x of < p, a will the first &#38; k=O => m*x This completes + Zti< \nZt,]. i j the analysis and the induction. Q.E.D. execution of a will yield a constant C>p. Lemma 5: Formulas \narising from lemma 3 are P+ Then after k executions, x is transformed to representable using space linear \nin the size of c + x + (k-l)*r. The formula then becomes: the formula. [(x ~p&#38;k#O)+(m(x+r*k) +Zti)<Ztj \ni j ~om ~% 2 3 where =i =1and i2 la203xj=xi 1 3 is P+ representable as a modulus. Using lemma 4 these \nequations are P+ representable and an examination of that lemma shows that at most 64 clauses, each linearly \nrelated to the original formula, are introduced. Q.E.D. SPC Theorem: For any program A in L and m assertion \nP in P+, there is a function SPC(A,P) which yields the strongest post condition for P and A. Furthermore, \nSPC(A,P) is polynomially bounded in the size of P and A. Proof< It suffices to show the theorem for each \nstatement type and prove by structural induction. Let Z be a set of n new variables and assume we have \nn program variables. X.+X.+1 (1) SPC (X:+x;:l , P) ~ +()i x i+x , 3 Zi+l @z(P(E) &#38; Xl=zl &#38;...&#38; \nxi= Zi:l &#38;...&#38; Xn=zn) o z. J (2) SPC (A;B,P) = SPC(B,SPC(A,I )) (3) SPC(LOOP y A ENO,P) = HZ(P \nz)  &#38; A &#38; I=zy) aj j <n+l where w. = (1=0 &#38;Xj = ZjV...v j I=p-1 &#38; xj=fj . . ..of rp-2 \n~j)zrP-l(j) v vI-p~m mod q&#38;k=(I-p div q) &#38;I >p &#38; m< q kX.=f o...of rp-l (f Jj (j) rP+cl-l(j)) \n0 O...of rp+m-l z pi-m rp(j) (j) r (j)) f Y corresponding to y, and m and k are a con stant and a P+ \ndefined quantity respectively. SPC(A,P) is O (\\nl +IPI) in case (1) and O(n3.1Al+lPl) in case (3), From \ncase (2) (composition) we see that for arbitrary program A, SPC(A,P) is 0(\\A12*n3+lPl). From lemma we \ncan translate the iterated function sequences in linear space, thus the SPC formula is bounded by a polynomial \nin [Al + /Pi. It remains to show that the above formulas are really the strongest post cond tions. We \ncons d er in detail case (1): cases (2) and (3) can be shown using similar techniques Let A be any of \nthe assignments in case 1) . Let s be such that P[s] is true and s the state resulting from execution \nof A. Let ~ be the assignation of values to free varibles in P. Then ~ P(Z) is true (as can be seen by \nletting z=a). Still letting Z=l, it can be seen that s makes all the equalities true (for S =S except \nat the assignation variable, but then the equality reflects the change in the variable s value). To see \nthat SPC(A,P) is a strongest post condition, we will assume that it is not and derive a contradiction. \nLet R be the putative SPC, then R=>SPC(A,P) and SPC(A,P) #>R. Let s be such that SPC(A,P) [s ] is true, \nthen P(z) is true for some 2, Hence, after execution of A on ~ (yielding ~ differing from ~ in one component), \nwe still have LEZP(Z) true for Z=~ and additionally the equalities are satisfied for Z=~ and But ~=~ \n, R(Z) is false (by assumption), therefore we have a contradiction for P(d) is true before execution \nof of A, E is the result of A s execution and R(E) 6 is false. Lemma 6: I=N P{LOOP y A END}Q The proof \nfor case (3) is along the same > l-p P{LOOP y A END} Q. lines. The value of the loop variable (I) deter-+ \nProof: Construct SPC(LOOP y A END, P) with one mines which values the variables attain upon com\u00adchange. \nInstead of defining I by I=z define pletion of execution of the loop. Thus the proof Y it as I=zy~w \nwhere w is a new free variable. that SPC(A,P), for A=LoOP y B END, is a strongest Call this formula SPC \n. It is easy to show post condition for P and A proceeds as above. I=NSPC (W) {A} SPC (w~l) and hence \nCase 2 follows from the transitivity of impli\u00ad cation and the definition of SPC (SPC(A,P) is the l-p \nSPC (W) {A} SPC (w~l) (by induction hypothe\u00ad+ strongest statement that can be asserted after A sis). \nSPC (w)~ ; P and SPC (w)~ finishes execution on a state that has P true) . ~ SPC(LOOP y A END, P). Q.E.D. \nFrom the properties of the strongest post con-As an example of the SPC theorem we construct dition, SPC(LOOP \ny A END, P) => Q. Hence, by the SPC(A,X2=O) where A is the following program: consequence rule and the \nloop rule, LOOP x 1 l-p P{LOOP yAEND}Q. + Q.E.D. 1 + 2 +X+l  2 2 Realizing P+ in L m END The heart \nof the completeness result is the From the body of the loop we see that r(l)=2, construction of a P+ \nformula expressing the result r(2)=2, fl= no-op, f2= +1. We can now construct of executing an Lm program, \nSince P+ is a our output equations and u . al 2 complete theory (relative to a suitable axiomiti-For \nx,, p=q=l, then L zation [M]), we conclude that the axiom system for (1=0 &#38; X1=21) V (121 &#38; 1-1s0 \nmod 1 1 = Lm is complete. The question arises, can we get k &#38; k=I-1 div 1 &#38; Xl=(+l) 22) the \nsame result for a more powerful language than : (1=0 &#38; X1=21 v 1>1 &#38; X1=Z2+I-1) Lm? That is, \nis p+ really capable of expressing For we have p-O and q=l, then 2 more than Lm? We will now prove that \nthe answer [1=0 mod 1 &#38; R=I div 1 &#38; x2=(+l)kz2] a2 = to these questions is no, that is P+ is \nthe I . 2 2 + 1 weakest theory which expresses Lm s SPC S. Then SPC(A,X2=O) is 5X Definition: A programming \nlanguage exactly A ml 21z2 [z2=0 &#38; 1=. ~ &#38; [(1=0 &#38;xl=zl) realizes a logic iff A v (Iz1 &#38; \nX1=.2+1-1)] &#38; X2=Z2+I] 1) For every program A(X) in PA with a = Zlzl([(zl =0 &#38; Xl=o) v (Zl>l \n&#38; X1=21-1)] &#38; X2=.1). output variable, there is a formula R(%) in LA such that A(E) = O <=> \nR(a) is true, and The SPC theorem allows us to prove our com\u00ad 2) For every forumula R(z) in LA, there \nis a pleteness result. We only show the hardest case, program A(R) in P such that A(5) = O that of LOOP, \nthe rest are straightforward using A <=> R(a) is true. techniques such as in [CK]. (Note that this definition \ndiffers slightly from that given in [CH].) Theorem 2: L exactly realizes P+. m Proof : The two parts \nof the proof correspond to the parts of the above de~inition. 1) This is a simple corollary of the SPC \ntheorem. 2) This part is a modification of a proof in [CH]. Assume we are given formula R(R) in P+. We \nshow that we can construct program A(X), in four steps. a) By a well-known technique (see [E]), transform \nR to a quantifier-free formula R! having the same free variables. R has the form v q~ Ari-si<rj-sj+~ \n&#38; j <!2 i<.!,. ~rj=sj+q<ti-ui &#38; i<k ~ rj-sj+qzmivi-w ] i where f.,m,k,n,m. are constants, and \nri,si,ti,ui, 1 are terms in P over variables xi. 1  v. Swi + b) Construct programs to compute the terms \nof R (that is, the ri,si, etc.). The reader may do this simple construction himself or consult [CH]. \nc) Construct programs to realize the conjuncts of R . It should be clear that the functions x : y, X+Y \nand the constant functions are computable in Lm . We show how to realize the three types of conjuncts: \nri% i < r.%.+q : x+r ~s+l JJ ii y+r. ~s.+q 33 Z+x:y Z=(J X<y After executing this fragment, iff iff \nr ~s. <r. : s. +qo i 1. JJ rj%j+q < ti%. : similarly 1 rj%j+q ~ m Vi:wi : x + (r.%.+q) mod m. JJ i y \n+ (vi~wi) mod m i z + (X:y) + (y:x) Now Z=O iff x=y iff rj~sj+q = Vi:wi . The m. 1 tricky part here \nis performing the mod mi oper\u00adation. A program to compute x mod m is the following: 0+0 1+1 m + m-1 m \n1 LOOP X temp +m o o + 1 m +m in-2 m-1 m + temp m-1 END zi-m o d) L is closed under &#38; and v, that \nis, if m programs A and B realize relations and A % with output variables A and z B, respectively \nthen there are L m programs realizing relations IiA &#38; RB and RA v RB. It is then essential to realize \nthat in R ,k,m, and n are constants, so there are only a fixed number of sub-programs to be connected \nby &#38; s and V S. We now prove the closure property. RA&#38; ~: A; B 2+2+2 A ~ {Z=o <=> ZA=O A ZB=() \n<=~RA A ~} RAVR: A; to a similar study. Of particular interest would B +lJZ A; {2A=(J <=, lRA} be those \nprogramming languages whose assertion A language lies in the first order theory of real B; closed fields \nor algebraic fields. Difficulties +1: lRB} B B; zB=O => arise, however, in the study of such systems \nas z+z+~ g; {z=() <=> lRA A lRB to the appropriate computational-model. A We believe that such investigations \nas above, <=>-I(RAV RB)} although not of immediate practical use, at least z=O <=> R A %  delineate \nthe complexities that can be encountered Q.E.D. with even simple languages. They also give some What \nthis proof shows is that Lm uses the hope (in particular the relative complexity result) full power of \nP+, so that a more powerful that automatic verifiers (in an interactive envir\u00ad language (such as L2 [ \n~]) will lead outside of onment) might become more than expensive research P+, tool s . Relative Complexity: \nReferences Define the relative complexity of a verifica-[CH] Cherniavsky, J.C., Simple Programs Realize \nExactly Presberger Formulas , SIAM Journal tion proof to be the length (i.e., number of of Computing, \nto appear. symbols) of the longest CF appearing in the proof. [CL] Clarke, E.M., F rogramming Language \nCon\u00adstructs for which it is Impossible to Obtain The relative complexity of P{A}Q is then the Good Hoare-Like \nAxioms , Cornell University TR 76-287, August 1976. minimum of the relative complexities of all proofs \n[CB] Constable, R.L. &#38; A.B. Borodin, Subrecursive of P{A}Q (if P{A}Q is provable, otherwise it Programming \nLanguages, Part I: Efficiency and Program Structure , JACM, 19 (1972), is undefined). The following theorem \nthen shows pp. 526-568. that the relative complexity of the Lm -P+ [CK] Cook, S.A., Axiomatic and Interpretive \nSemantics for an Algol Fragment. T.R. No.79, verification system is polynomial. Dept. of Computer Science, \nUniversity of Toronto, February 1975. Relative Complexity Theorem: The relative [co] Cooper, D.C., Theorem-proving \nin Arithmetic complexity of P{A}Q (in the Lm -P+ system) is Without Multiplication , Machine Intelligence \n~, Meltzer and Michie, cd., John Wiley, 1972, polynomial in lP/+lAl+lQl. pp. 91-99. Proof: The SPC S \nare all bounded by a polynomial [E] Enderton, H.B., A Mathematical Introduction to Logic, Academic Press, \nNew York, 19720 in lPl+lA/. Hence the longest SPC is bounded [MA] Manna, Z., Mathematical Theory of Computa\u00adby \na polynomial in lpj+\\A\\+lQlo ~, McGraw-Hill, Inc., New York, 1974. Q.E.D. [M] Mendelson, E., Introduction \nto Mathematical Conclusion Logic, D. Van Nostrand Company, Inc., Princeton, N.J., 1964. We have investigated, \nin rather thorough de\u00ad[MR] Meyer, A.R., &#38; D.M. Ritchie Ad The Complexity tail, the completeness and \nconsistency of a of Loop Programs , Proc. 22 Natl. Conf. ACM Thompson Book Co,, Washington, D.C., 1967, \nsimple verification system. There are other pp. 465-469. programming languages that are certainly amenable \n \n\t\t\t", "proc_id": "512950", "abstract": "", "authors": [{"name": "J. Cherniavsky", "author_profile_id": "81100340831", "affiliation": "SUNY at Stony Brook, N.Y.", "person_id": "P348470", "email_address": "", "orcid_id": ""}, {"name": "S. Kamin", "author_profile_id": "81100030799", "affiliation": "SUNY at Stony Brook, N.Y.", "person_id": "PP39024044", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512951", "year": "1977", "article_id": "512951", "conference": "POPL", "title": "A complete and consistent hoare axiomatics for a simple programming language", "url": "http://dl.acm.org/citation.cfm?id=512951"}