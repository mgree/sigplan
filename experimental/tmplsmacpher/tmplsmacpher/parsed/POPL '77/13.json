{"article_publication_date": "01-01-1977", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1977 ACM 0-12345-678-9 $5.00 THE EVOLUTIONOF PROGRAMS: A SYSTEM FOR AUTOMATICPROGRAMMODIFICATION Nachum \nDershowitz and Zohar Manna Stanford Artificial Intelligence Laboratory, Stanford University, Stanford, \nCalifornia and Department of Applied Mathematics, Weizmann Institute of Science, Rehovot, Israel ABSTRACT \nA plog! a17~mer spencfs mot-e t]rne modifying already existing plogtams than ccnlstructing o!lginal ones \nAn attempt IS made to formulate tcctlnlques of program nmcllhcatlon, whereby a program that actlleves \none result can be transformed Into a new program that uses thr sat71r ptinclpies to achieve a different \ngoal. For example, a plo~ram that uses the binary search paradlgrn to divlcte two numbers may be modified \nto calculate the square-root of a number ItI a slmllar manner, F ro~i am debugging is considered as a \nspecial case of nmcflficatlon if a program compurcs wrong results, it must be n~odlflmi tcl achieve [he \nintended Iesuks The application of abstt acr p! (>}P,Iam schemara to concrete probleims IS also viewed \nfrom [be pm spec(lve of modification techniques. M e, ll:lve elmbedded [Ills approach In a running llll[llclllrll \ntatl(~ll; cm r methods ate Illustrated with several ex atmplcs that have been performed by It. 1. INTRODUCTION \nTyl)tcaily, a plo~, ranlmer dl!ects more of his effort at the Imocllflcation of pto~rams that have already \nbeen written than at ttle dcvclopmcnt of new ptograms. Even when nomjnally enga~,ed III Llle consttwctlon \nof a new program, he M constantly r.ecyclinp, ~lsrd programs and adapting basic programming pt Inciplcs \nthat have alreacly been incorporated into other ptogtanls hfuch al!tomatic programming resea)-ch has \nfocused on the ot IgIt Iat ImI of [llcj~,talns, but ve)y Ii f[le of this woik shows how to pI oflt II \nmm p3st cxpct Ience when apl)roachill~ a new problem. ]n this plwt, we wlst) to emulate th{s latter aspect \nof programming in tbc cloi][rxr of an automatic p]o~,t am development systcm. The esscllcf of OIt I al, \n[,roactl I]cs iii lhc ability to Fotlmulate ail analogy bct;vcrn two SCIS of spccihcattons, those of \na p]ogram that has already bvrll coltscructd and those of the 1)]-o~ran] that we desire to Collsrl [l \nCt. TIIIs analosy is then used as the basis for tt ansfo) r]in~ tile eslstlng pt ogram to meet the new \nspecifications, As a I)lc)$talnlnwr M by nature error prone, hls mistakes must be co! I ccted. I-his \ndeb\\}p;Sing pl ocess ]s an impott ant spcc!al case clf pi o~i al-n Imoclifjca!ion It-I our approach, \nthe properties of an Incor)ect p] o?,t-anl are compared wfth the spec]hcat]oos, and a n~ocliflcation \n(ccmrect!on ) sought that transforms the incorrect pt-ogl-am Into a correct one past successes Abstract \nprogram schemata are often a convenient form fot-Incotpot sting pto~ramming knowledge; they may embocly \nbasic techniques and strategies such as the Scnetate-ancl-tmt paradigm or the binary search technique. \nThe application of these schemata to programming tasks may be consldei ed wjttltn the framework of modification. \nA schema wlltch achieves some abstract goal M modified (instantiated ) to achieve a concrete goal on \nthe basis of a comparison of the abstract specifications of the schema with the concrete specifications \nof the desired program. The use of analogy m problem solvjng in general, and theorem p]ov]np, in partlcolar, \nis discussed by Khng [ 1971 ]. The n~c]dlflcat[m~ of an alteady existing prograin to solve a somewhat \ncliffe; ent tasL was su~)gested as a powerful approach by Manna 211cI Walcllnfgcr [ 1!175], AIso, tbc \nS7 RIPS (Flkes, Hart and NIlsson [ i{17~]) and FIACKER (Sossman [ 1972]) sys~ems were to scnme cxtrnt \nca[]able of generalizing and reoslng [he robot plans they p,enelatrc]. The compilation of a handbook \nof program sct]emata has tecently been advocated by Gerhart [ 1975]; their use ]n ttle context of program \nsynthesis has been discussed by D.erstlc)witz and Manna [ 1975]. I he next sectton elucidates the basic \naspects of our approach to pI-OF,I an] mocllflcatlon With the aid of several relatively sttalgtltforwatd \nexamples. hiore subtle facets of the techniques are [Illustrated In the third section. The methods described \nare almcllable tc, autornatlon, and have been implemented m O~LISP (Wliber [ 1975]). All examples of \nmodlrlcations that we present ran successfully on our system; a sample run may be found m the Appendix, \nIl. OVERVILW 1 yi)lcally, p)og!am spcclftcatlons are expressed in a hl~h-levei a.rje>izon [17n,q1i17{t \nIn telms of an buts,hc(i$ccz[ion detailing mit,  thr cl~sircd rcl. tiot, sl>tp betu>een tl, e progtatw \nvariables ul,on tct 17~inatlon, atlcl an input ~ptxi$cafion --definins the set of legal input< foi wt!lch \nthe ptogram IS expected to work. For program ntodijic(71r on, OIIe IS given a known correct program with \nits inpot.output spcc)flcatlon and the specification for a new program. C.omparmm of the two speclhcations \nsug~,ests a transformation ttlat is tltrn applied to ttle given prog!-am. Even if the transfotmecl pro~, \nram cioes not exactly fulfill the speclficatlons, it can sclve as ttle basis for constructing the desired \nnew program. The human programmer does have the ability to learn from 1. lkic TccAniquc: Global Tronsjot \nmctiort in ttle app] oactl to program mocflfication presented in this pallet, we stress transformations \niti which rzl/ occurrences of a par ttcular symbol throughout a program are affected, Such ttansfotma[[ons \nare tetmecf global , In contrast with local transformations which ate applled only to a particular seynent \nof a pto~ran). As a Sllnple example, consider the follow ins pl-op;ram (annotafrxf will] its output specification): \ny+n lpop until y = O Llfy-1] + if fl[2y-1] s A[2y] then A[2Y-1] else /![2y] fi y + y-1 repeat assert \n.4[0] = rrrirr(A[n:2rr]) . Given an array /l[n:2n], which M non-empty (i./., n IS ncm-nc~ative), when \nthis program terminates, /l[O] will contain the n~lninmnl of the values of the n+l array elements A[n], \nA[n+l], . . . . ,4[2n], This output specification is formally expressed in the final statement: assert \nAIO] = rn7n(A[n:2n]) . To n]ocflfy thlsprogran~ tocolmpute themaxlmumof the array, rather tllan the mlnimurn, \nwe compare thts specification with the cfesirecl: assert AIO] = rnax(A[n:2rrJ) and note that since nrax(ll) \n= -nrirr( -A) (where -A M equal to the array A wl[h each element negated ),thisis equlvalentto assert \n-A IO] = mirr(-A[n:2n]) . Thus, thetlansformatlon A 6CCCWWS-A transforms the given specification into \ntheclestred. Applying this transformation to the program affects only the conditional assignment: A[y-1] \n+ if A[2y-1] s A[2Y] then A[2y-1] else A[2yJ fi , which becoimes: -A[y-1] ~ if -A[2y-1] s -A[2Y] then \n-A[2Y-1] else -A[2Y] fi It is llleSal for the array -A to appearon the left-hand sldeof an assignment; \ntherefore, both sides of the assignment are multiplied by -1 And since the test -A[2y-1] s -A[2Y] is \nequivalent to A[2Y] s A[2y-1], we obtain the statement: A[y-1] -if A[2Y] s A[2y-1] then A[2Y-IJ else \nA[2Y] fi , yielding a pl ograrn that computes the maximum. Note that the array -A no longer appears m \nthe program; only the original A is actually used. 2. S,beciol Case: Program l~ebugging Plograrn dkuggi?tg \nmay be considered as a special case of mocflfication: a program which computes wrong results must be \nmodified to compute the desired (correct) results. If we know what [he bad program actually does, then \nwe may compare that with the specifications of what it should do, and modify (debug) the Incorrect program \naccordingly. AS an example, consider a program intended to compute the integer squa]e-root z of the non-negative \nnumber c , that is, c should lie between the squares of the integers z and z+l : assert Z2<c<(Z+1)2, \nzcN , where N is the set of natural numbers. The given program is: (z, s, t) +(1, o, 3) loop until c \n< s (z, 5, t) -(Z+l, S+t, t+2) repeat assert (Z-1)2 < c+] < Z2, z c N+ , ~l]t ta[llet thatl computltlg \nthe Integer square-root of c, this program arll[eves tl~ere13tloll: assert (7-1)2 s c+] < Z2, z c N+ \n, wh?te N+ IS the set of positive itltegers. [This follows from the fact tliat t . 2z+1 and s = Z2-1 \nthrougtlou L] The cause of the bug, was the Inadvertent exchange of the Initial values of z and s Con~pattnS \nthe cleslred assertion with the actual assertion, we note that t!le fotmer may beobtalned from the latter \nby replacing z wlttl z+] allcl c with c-l Applying ttle transformation c (X<ornes c-1 to the ploglam \nstatements affec~s only the exit test C<s, u,l~ich becomes c-l < .s , or equivalently c s S. The transfotlnat!on \n z bccomr$ .?+1 afi ects two other statements: tlte lnltlalizatlon z, + 1 becomes z+l + 1 and the Iool)-bocly \nasslylnlent z + z+l becomes z+l + 2+2. These resultant assigllmcnts, however, are illegal , inasmuch \nas an expression nlay not appear on the left hand sldeof an assignment. Instead, the expression z+l is \ngiven the Initial value 1 by ass{gnlng z~o, and the value of the expression 2+1 is incremented to 7+2 \nby the legal assignment z + z+l Wc have th(!sohtalned the corrected program: (z, .s, t) +(o, o, 3) loop \nuntil c s s (7, s, t) e (2+1, S+t, t+2) repeat assert Z7sc<(Z+l)z, zcN . Note that ttlough this program \nIS not exactly what the programmer lntcnded we claimed that he reversed the mitlal values of z and s \n it M nevertheless correct. 3. CO17rCt71t 3s [Onsidcr ations In the ptev Ious examples only input and/or \noutput variables were tt-ansforrned. It can be shown that such ~,fobal transformations wtlere an input \nvariable is sys~ernatlcally refjlacecl by a function of Input variables, or an output variable by a futjctlon \nof output variables always preserve the cot-rectnms of a program with respect to its specifications. \nHowever, it jsoftml desirable totransfotm a function, predlcateor constant, In wtllch case the transformation \nis no longer guaranteed to tesult in a coltect program. FcJl example, we may wish to construct a fjrogram \nto fit-id the maximum of a non-empty array the output specification M z = max(fl[l: n]) given the program: \n(z, Y) ~ (A[~l, 0) loop until y = n y . y+l z G nrirr(z, A[y]) repeat assert z = rrlirr(AIO:n]) for finding \nthe Cnjnlmurn. The transformations  rnin bfcomc~ max  and  O fwomcs 1 suggest themselves. Though \nin this case applym~: these transformations yields a correct program, such transformations of a function \nsymbol or constant do not necessarily preserve co]-rectness. Were the function min not explicitly usecl \nin the program, c.g,, if thecondltional statement: if A[y] <zthen z+A[y] fi were substituted for the \nassignment: z + rnirr(z,A[y]) then the proposed transformation nrirs become~ max would clearly not \nwork. Thus, forsomet ransformations, correctnessmust beverihed. In order to prove the correctness of \na prograln, invariant assetfio,ns are commonly Lltlllzed. AJ$erthzs are colmmenu which express relationships \nbetween the different variables manipulated by the program; they relate to specific points in the program, \nand are meant tO hold fot the cur]ent values of the variables whenever control passes tllrough the corresponding \npoirnt. When an asset tion has been prcwe[i to be consistent with the cocle i,e., the assertion holds \nfor the current values of the variables each time control passes through the point to which the assertion \nis affixed then it M sad to be intrczriarrf. [All assertions annotating our example programs are indeed \ninvariant. ] In particular, the output a-iscrfiorz, associated with the point of termination, IS invariant \nlf tlle final values of the variables satisfy the assetwon; a loop asser~ion, attactled to the beglnnlng \nof an Iterative loop, M invariant if it I1oIc1s when the loop N first entered, and remains true eacll \nsubsequent tlnle control passes the beginning of the Ioopbody, The assettion is termed an output lnvarian/ \nin the former case, and a 100) invariant in the latter. A program, then, may be considered correct if \nthe output invariant implles that the output spec]hcation IS true. The above mirr program, with its loop \nassertion appended, is: (z, y) +-(A[o], 0) loop assert z = mirr(ll[O:y]) until y =n y . y+] z -mirr(z, \n/t[y]) repeat assert z = mfrr(/l[O:n]) . Recently, invariant generation techniques have been developed \nand implemented (see, e.{., German and Wegbreit [1975] and Katz and Manna [1976]), They allow for the \nautomatic discovery of invarlants which may then be used to prove the correctness or incorrectness of \nthe program. Our system incorporates many of those generation techniques, as well as several ncw ones. \nlnvaliant assertions are essential in our aiJprOach to debugging too, as it is necessary to have an idea \nof what the progralm actually does before it can be corrected. Global transformations are applied to \nall assertions, as well as to the cocle. Using these transformed assertions, verification conditions \nfor the new ptogram may be obtained; if they hold, then the new progl-am IS correct. Sometimes, a verification \ncondition that turns out not to hold may, nevertheless, suggest additional tlansforrnations which do \nsucceed. Alternauvely, a plogratm segment can be synthesized that WIII establish the verlficat}cm condition; \nfor example, the Jnltlallzatlon of a loop might bc synthesized If the condltlon for the current mitlailzatlon \n]s false. Returning to our example, after appllcatjon of the tran SfOlmatlon S nrin 6fcomcs max and \n O becorne$ 1 to the ak>ove program, we obtain: (z, y) ~ (A[l], 1) loop assert z = max(ll[l:yl) until \ny =n y ~ y+l z ~-mdx(z, /l[y]) repeat assert z = max(ll[l:n]) , Using the new assettlons;the correctness \nof this max program may straightforwardly be shown, 4. A?z Applicctio?u /rlstarrtiotion oj~rogram Sch&#38;rrlota \nOne important application of our program modification techniques is ttle instantidion of pro~ram sctlemata \nto obtain conctcte ptogtams. A progralm schtrna M agenerailzed version of some programming strategy and \ncontains abstract predicate, function and constant symbols, in terms of which its input-output relation \nIS speclhed. This abstract specification may then be matched wjth a given concrete specification and \nan instantiation founcl that, when applked to the schema, yjelds the desired concrete progra171. In instantiating \na prograln schema, the schema is transformed into a concret? program after an analogy between the abstract \nspecifications of the sctlerna and the given concrete specifications is constructed. Not all instantiation \nyield correct ptograms; therefore, a schema is accompanied by a set of prccorzditiorrs derived from \ntheschema s verification conditions-which must be fulfilled before the schema may be employed. When satisfied, \nthese condttlons wIII guarantee the correctness of the new program. As an illustration, cons]det ttlefollowing \nprogram schema: (z, y) +(k, j) loop assert P([j:y],z), y c I until y =n y + y+] if -P(y,z) then z + f(y,z) \nfi repeat assert P([,j:n],z) . Here P([u:rl],lv) means (Vi c I)(u< 7S v)(P(i,W)) and 1 is the set of \nIntegers. Thn schema will achieve the relation P(i, z) for each integer i from j to n. For this schema \nto be apphcable, the following three precollclltlons must be satisfied by the predicate P, function f \nand constants j , k and n: P(j,k) Aj(r P([j:y],Z) A Y ( ~ A Y # /7 A -p(y+~,Z) * P([j:y+l ], f(y+l, z)) \nj<n An<I. _f he first conrlltlon ensores t}lat the loop invariant N initialized f510perly; the second \n]s suticient to guarantee that lf the invariant hclcl befot-e execution of the Ioolj-body, then they \nhold after; and the last condition secures term] natiom F ro[:tams fur frttdlng the position or value \nof the n)i!lt!~l~l l?l/il~ax[ll)tlll] of an array (or of ot}]er functions w]th lnte~;er domain, for that \nmatter) are valld instant jat]ons of this sche171a. F-o! example, say we w]sh to achieve the output spec}ficatlon \n/l[O:n] < x, In order to find the maximum x of the rim-empty array AI O:n]. Applylng our modification \ntectlnique, we compare ,4[O:n] s x with the schema s specification P([j:rr], z) Thlssuggests lett[ng \nj be O, z be x and P(u, v) be /t[u] s v The transformed preconditions, then, are: AIO]$ k n O<I AIO:y] \n$ X A Y(lfiY#nAX</l[Y+l ] =) AIO:Y+l] s f(y+l,x) r7<n An<I . The first maylJeachleveci by letting k \nbe /l[O]; the secondby Iettlng f(u, v) be /l[u], since AI O:Y] < x < A[y+l] and A[y+.f] < A[y+l]; the \nlast is true by virtue of ,4[o:rr] being notl-enlpt y. Applying tllesetransforn~ ations, uiz j 1w[o171cJ \nO , k lwomfs AI O], 7 1,1 i@?IlfJ X, f(u,u) bfcomfs A[u] and P(o, v) IW(O?U< J A[lJ] 5 V, we c) btain \ntt)e :,tiat anted correct pro:ram (x, y) ~-(/l[o], 0) loop assert AI O:y] s x, y c I until y =n y + y+] \nif x </l[y] then x+A[y] fi repeat assert AI O:n] s x . 5. Using Ex(or~hl sometimes, transformltlg a program \nor lnstantlatlnq a schema only achieves some of the conjuncts of the output specification. In such a \ncase, it is possible that the program can be extmded to achlcve all the desired conjuncts by achieving \nthe missing conjuilcts at the onset and maintaining them mvat lant until the encl. Altetnatlvely, code \nthat will achieve the additional conjuncts w\\ttlout clobbet Ing what has already been actlieved by the \nploglam could be synttlesiz.ed and appendecl at the end. As all cxampk of the need for extension, consider \nthe case wllete It IS desired that the pto~ram above also find the position z , in the att ay, of the \nntaxilmum x We can extend the above program to achieve x = /l[z ] by maintaining that relation as an \ninvartant t}llou~hotst the executmn of the program. Initially we want x = AIO] = /l[z], so we set z e \nO. When the then path is executed, we want x c A[y] = A[Z] and assign z + ~, whetl that path IS not taken, \nx is unchanged and the relation remains true. Thus, when the program terminates, the desired relation \nx = /l[z] WIII hold. The extended program M: (x, y, z) + (AIO], O, O) loop assert AI O:y] s x, y K 1, \nx = il[z] until y =n y * y+] if x < /l[y] then (x, z) + (/l[y], y) fi repeat assert ll[O:n] : x, x = \nA[z] . Ill. E_xA~PLE&#38;_ In this section we demonstrate val-ious stages in the evolution of one pl \no~ralm, We lJe#In with a program containing a logical error and then find and apply alternative corrections. \nAn abstract version, which represents an Important search method embedded in the proyam, M then applied \nand adapted to two other problems Each, in turn, is modified to apply to a new task, The examples are \nolltlined in Figure 1. They owe their motivation to Wensley [ 1!)59] and Dijkstra [ 1 276]. Our modification \nsystem has successfully performed the modification steps, includlng debugging and instantiation, in these \nexamples (sometimes resorting to the user s expertise in theorem proving), An annotated trace of the \nfirst example may be found m the Appendix. (1) annotation dcbugg i ng Good Real Division &#38; (2) abstraction \nB I NARY SEARCH SCHEMA &#38;a ion   n t &#38; ((, ) nloc{if icat ion n]odif ication (6) extension \n Rea I Harcliiare Integer Division Division Figure 1. The evolution of a divlslon pl-ogram, (Outllne \nof examples 1 through 6,) Example 1: Bad Real Diuision to Good Real lJivision C.otnslcier the problem \nof computmg the quotient z of two real numbcts a and b , where O s a < b , within a specified tolerance \nc , 0 < e In other words, the ]nput specification is: Osa<bf10 <c, and the output SpeClfiCatlOll is: \nzsC?//) A a/b <z+e, or equlvalcnt]y: 1).2 s a A a < b.(z+e). ln order fot-the problem to be non.trivial, \nwe must assume that no general real division operator is avaliabie (though division by two M permissible). \nThe given program IS: BAD REAL DIVISION PROGRAM assert Osa<b, O<e (z, y) -(o, 1) loop until y s e if \n/).(z+y) < a then z -z+y fi y + y/2 repeat .  The tnltlal asset tion contains the input speclficat!on \nwh!ch the input variablm a , b and e are assumed to satisfy. But, for example, a=], b = 3, and e = 1/3 \n, which satisfy the input spccjficatlon, yield z = O which does not satisfy the second conjunct of the \noutput specification, The bug IS caused by the Intetchangmg of the two statements within the loop. Before \nwe can cicbug this program, we must know something about what it actually does, For this purpose, we \nannotate the ptogt am with loop and output mvariants Recall that for a relatlon to be a loop Invariant, \nit mist be true upon mitlal entry into the loop, and must remain true after each execution of the loopbod \ny, We begin with the then path of the condiuonal statement and note that th]s path M taken when b (z+y) \n< a; thus, after resetting z to z+y we have b.z s a. Since b.z S a is true Initially, when z = O and \nO s a , and n unatiected when the conditional test M false (the value of z is not changed), it rema]ns \nInvariant throughout loop execution. We have derived then the loop Invar lant: (1) b.zsa. The then path \nis not taken when a < b. (z+Y) In that case y IS divided in half and z is ieft unchanged, yielding a \n< b. (z+2Y) at the end of the current iteration. It turns out that the ihcn path preserves this rela(ion, \nand that it holds upon initlnllzatlon (since a < 2/1 K implled by O < a < b ). Thus we have the additional \ninvariant: (2) a < b.(z+2y). These two loop invariant along w][h the exit relation Y s e imply that upon \ntermination of the program the followlng output invatiants hold: b.zsa A a < [J. (z+2e) Note that the \ndesired relatlon a < b. (z+e) is not implied. The annotated program with mvariants that correctly express \nwhat the IJrograrn does do IS: ANNOTATED BAD REAL DIVISION PROGRAM asset tOsa<b, O<e (z, y) +(o, 1) \nloop assert b.z s a, a < b.(z+2y) until yse if b.(.?+y) s a then z -z+y fi y . y/2 repeat assert b.z \n$ a, a < b. ( z+2e)  We now have the task of finding a transformation (correction ) tliat transforms \nthe actual output invariant into the desired out[]ut SIJeClfiCatlOll: lJ. z< aA a < b.(z+e) , and then \na}>plylng it to the whole annotated program (statements and trlvarlatlt assertions). Accord jng]y, we \nwould Iilie to modify the pto~ram In such a manner as to transform the Insufficiently strong a < b. (z+2e) \ninto the desired specification a < b.(zfc): a < b. (zf2e) bccomej a < b.(z+e), At the same time, we must \npreserve the correctness of the other COll JUllCt Of [he spccif)catlon: /J. Z < a unchanged, T he most \nobvious correction i5 to replace all occurrences of e In the program (there n only one affected statement \n-the ex]t test y < e )with e/2 : Correction 1 Rc/Jocc tibetfst y<ebyySe/2 . exit Addltlonal debugging \nmodifications are possible: we may replace b with b/2 and z with 22 ; alternatively, we might replace \na with 2a and z with 22. Doubling z and either halving b or doubhng a , yields a conditional test 6. \n(z+Y/2) s a Transforrntng z into 22 equivalent to af[ects two acfclltlonal statements: the initialization \n2+0 becomes the illegal assignment 2Z + O , but the equivalent original assignment z + O may be substituted; \nthe assignment z (-Z+y of the then branch becomes 2Z + 2z+y , or z -z+y/2 No other statements are affected \nby either of the two rnodlfications; thus they both yield: Correction 2 RPploct lh conditional xtotcment \nwith if b. (z+y/2) s a then z + z+y/2 fi . Each of these possible transformal]ons involved one of the \ninput variables e , a and b C)ne must, however, be careful when transforming input variables, since the \ntransformation should be applied to the input assertion as well, possibly changing the range of legal \ninputs thereby. In this case, the transformations we have pe]formed are all permissible: The specification \nO < e is equivalent to O < e/2 and therefore halving e has no effect on the ]nput range. Since in fact \nthe condition a < 2b , rather than a<b, is strong enough to imply the loop invariants, replac!ng b by \nb/2 (or a by 2a ) still yields a program correct for inputs satisfying a < b , as is desired. Our progiam \nafter correction 2, annotated with appropriately modlfwd Invariant assertions is (all b have been replaced \nby /J/2 and all z by 22 and the resultant expressions have been simpllfted ): assert OSa<b, O<e (z, y), \n(o, 1) loop assert b.z $ a, a < b.(z+y) until y <e if b.(z+y/2) -S a then z e z+y/2 fi y * y/2 repeat \nassert b.z s a, a < b.( z+e) . This pro~ram may be sli~htly optimized, by evalu.atlng the subexpr&#38;si&#38;l \nY/2 before theco~-ldi~ional statelnent, toobta~n: GOOD REAL DIVISION PROGRAM assert OSa<b, O<e (z, Y)-(0, \n1) loop assert b-z $ a, a < b.(z+y) until yse y + y/2 if b.(z+Y) s,athen z+z+y fi repeat assert b.z \ns a, a < b.(z+e) Note that this ptogram IS the same as the otiginal bad program, witl) the two Iool]-body \nstatements commuted, C.onsiclct an abstt-act version of the correct real clIv IsIon p!oSran~ wh!ch has \njust been obtained: BINARY SEARCH SCHEMA (7,Y)c(j, k) loop assert P(z), O(z+y) IIlltil R(y) y . y/2 \nif P(z+y) then z -Z+Y fi repeat assert P(7), C2(z+e) I This schema 1s an attempt to capture the technique \nof binary search otldetlylng the lreal division program. It is obtained from that l,tu~,tam by abstracting \npredicates that appear In the plogtam tckt ancllol assertions: /).0 < a h3i0111t3J P(u) , <? < b.1{ \nl,fcolllcs 0((/) and (/<c [>f[O)nfJ R(IJ) The ]n!tl~l valuesof ttlevallablesa realsoabstracted: o lCi@?71C8 \nJ and 1 lICCCWIFJ k The followlnK four preconditionsun the predicates P, Q and R and constants j and \nk aresufhcient to guarantee correctness (they correspond to the vertficatlon conditions of (1) the Initialization \npath, (2) ttle loop-body path and (3) the loop-exit path, ancf (4) tel-minatlo n): PRECONDITIONS for \nBINARY SEARCH SCHEMA (1) P(J) A O(j+k) (2) -P(z+y/2) * Q(z+y/2) (3) Q(z+Y) A R(y) * Q(z+e) (4) (3rr)(R(k/2n)) \n. L-.. - I  What we have, thrln, IS a gcnetal pro~ram schema for a binary seatch wlthln a tolerance \nwith an output specification: P(Z) A Q(Z+C). Clearly, the p]ecilcares P and R which appear In the schema \nmust be pllmltlve (that IS, available In the target language), othet wlse they must be replaced by equivalent \npredicates for the sctlenla to ymlci an executable program. Similarly, the constants j and k must be \ngiven, or their values set, prior to their assignment to the variables z and y, Excrrnplt 3: Bi71ary \nSearch Scllcvla (o Real Square-rooi As indicated earner, oneof the applicationsof our modification system \nIS the instantiation and adaptation of program schen~ata to specific problems, To Illustrate how the \nbinary search schema that we have just seen may be used, we consider the computation of squat e-roots. \nStIppose that we are g;iven the task of constructing a program that fujcls the square-root z of the \nreal number c , 1 < c , Wlttlln rhc toh!rance d, O<d <l. Then the input specthcatlon is: O<d< 1<C, and \nthe output specification ix In order to match this output specification with that of our schema P(z) \nA Q(z+e), we let the constant e be the constant expression -d (vlewlng z-d as z+ (-d) ) and obtain the \ntransformations: P(O) l,c<ornfs 4E <U, Q(U) (1<.C@VltJ <@ and c 1,< iO??l~S -d Condition (2) lssatlsfied: \n (2) -(JE 5 z+y/2) * z+y/2 s JE, b~lt we must still satisfy conditions (l), (3) and (4). TosatLsfy concliticm \n(1 ), we need j and k such that: ([) ~ESj A j+ksJ6. v~e notethat s]nce 1<C, ./E sc and c+(I-c) . 1s<~, \nThus bothcotljuncts hold when we let: J[v c and k [w l-c. [An altclnatlvc would have been to take -c \nfor k, since C+(-c) = o s ./F.] For coll~itlon (1) to be satisfied, we need a predicate R such ttlat: \n(3) z+y s<z A R(Y) * z-d s-/Z. By transltlvlty It follows that R should imply z-d < Z+Y and we let: \nR(y) 1,? -d <y. This also satlshes: (4) (3rr)(-ds (1-c)/2~), since both -d and l-c are negative. The \nInstantiated schema is assert O<d<1<c (z, y) + (c, l-c) loop assert J? s z, z+y ~ JZ until -d sy y + \ny/2 if JF sz+y then z+z+y fi repeat assert -/c 5 z, z-d s Jc Howevet, s[nce P Involves the square-root \nfunction itself, the conditional test IS not primitive and must be replaced. 1( can be teplacecl by c \n< (Z+Y)2 provided that z+Y IS non-negative, The relation Z+y IS In fact an Invariant: initially o< z+y \n= c+( I-c) = 1 ; for the then path, Y IS first halved and then aclclcci to z ,so the valueof z+y is unchanged; \nand if the then path is not taken, Y is increased by halving it, since Yis alwayk negative (by virtue \nof the loop assertion z+y s J5 s z), Ttluswe have REAL SQUARE-ROOT PROGRAM assert O<d<1<c (z, y) -(c, \nl-c) loop assert J? s z, z+y s JF, O s z+y until -d sy y + y/2 if c s (z+y)2 then z ( z+y fi repeat \nassert d~ sz, z-d s 42 . Exantp[c4: tlt,71Sqiiare-root to Reo[Llioislon In this example, we shall clelmonstrate \nhow the above real square-toot plcyram may be modified to construct a program that approximates ttle \nquotient z of two real numbers a and b , where Os a < b,wjthin atolerance e, 0 < e < 1 We begin by comparing \nthe output speclficat]oos of the two plogtatns. We watlt: z-e 5 a/b A a/b<z; wh}le for the square-root \nprogram we had: z-d <dc A ./z <z. Thlssug~ests Ehetratlsforma[ ions: d bccon[es e and 4F twor?lf s a/b \nToot.,taln the latter, we can use: bf(LV?l<J (a/b)2 , (slncecfl < a/b ), Applyil)g tl]cse tratnsformations, \nthe exit test -d s Y becomes -e<y and the ccmdltional test c s (Z+Y)2, becomes (a/b)z s (z+Y)2,0t equivalently \na s IJ. (z+Y) (since a, b and z+y are non-negative). Thus, we have the transformed program: (Z, Y) + \n((a/b)2, l-(a/b)2) loop assert a/b s 2, z+y < a/b, O < z+y until -e sy y ~ y/2 if a $ /J.(z+y) then z \n+.z+y fi repeat assert a/b s z, z-e s a/b , It 1s, tlowever, cleat-ly tlnsatisfactory, slllce expressions \ninvolving divislotl appear In the mittallzation. The loop invariatlt,though, can be lnltlallzecl In another \nmanner. Since a/b < 1 , we can actlieve the relation a/b s z by initializing z to 1 ; since O 5 a/b, \nwe acllleve O ~ z+y ~ a/b by inwmg that z+y = I+y = () , for which we initialize y to -1 We havcrhe program: \nREAL DIVISION PROGRAM assert Osa<b, O<e<l (z, y) +-(1, -1) loop assert a/b i z, z+y < a/b, O 5 z+y ui}til \n-esy y ~ y/2 if a < b.(z+y) then z _ z+y fi repeat assert a/b < z, z-e s a/b . Exmnfi{t 5: Birlc7ry Search \nSchcntato lnleger Square-root For ~hls exampie we return toourblnary search schema: Preconditions: (1) \nP(j) A Q(.j+k) (2) -P(z+Y/2) * Q(z+y/2) (3) Q(Z+Y) A ~(y) + (?(Z+e) (4) (3n)(R(k/2n))  s c /Jem : \n(z, y) +(j, k) loop assert P(z), Q(z+y) until R(y) y . y/2 if P(z+y) then z + z+y fi repeat assert P(z), \nt2(z+e) , and Illmwlate how it may be applled to the computation of integer square-roots. This WIII \nIlecessitate extension aod the synthesis of a n initlallzatlon IOOP (which have not been completely inl[Jienlelttecl \nIn our system). Consequently, this example is more compirx than the previous one. We would Ilke to construct \na program that finds the integer squal e-root z of a non-negative integer c III ottler words. z . .. \nshould be the largest iotege}-whose square is not greater than c. Thus, the input specification is: c<N, \nand the OLltpLlt SpeClhCatlOn IS: 27s c A c< (2+1)2 n z<N. C.omparisoo of this output specification with \nthat of our schema: P(z) A Q(z+e), suggests lettiog: P(u) be U2<C, z Q(U) 6C C<u ande l~e 1. In atldltion, \nwe WII1 have toensoret hat the fitlal valueof z isa notwtle~ative lnte~er. Clearly, cotlcfition (2) \nIssitisfied: (2) -((z+y/2)2 s c) * c < (z+y/2)2. To satisfy: (~) C < (Z+Y)2 A R(y) + c < (Z+l)2, we let: \nR(y) he (Z+Y)2 < (Z+l)z. We are left with thetoitializatioo and termlllatlon col~dlt~ons: (1) j2sc A \nc< (j+k)z (4) (3n)((z+k/2n)2s (Z+~)2).  In order to satisfy the lnltlalization condit]on we form the \ngoal: achieve j2 s c, c < (j+k)2 . T-his conjonctlve goal may bespllt mtotwo consecutive ones: achieve \njz s c achieve c < (j+k)2 , Since c ]s sl]eclfied to be nonnegative, we can solve the fil-st by Iettlng: \nJ [~F O if., z IS Inltlallzccl to O For the second we need now achieve 2 c<k Oor partlaily written program \nis: assert c{ N 2.0 achieve c < kz y.k 2 loop assert Z2 s c, c < (z+y) until (Z+Y)2 .s (Z+I)2 y -y/2 \nif (z+y)2 scthen z+z+y fi repeat assert zz S c, c < (241)2 achieve z c N assert 27sc, c<(Z+l)z, z<N \n. At thl~ p,int wc have a cllolce 10 orclct to achwve z c N , either w e fitst execute the loop arid \nthen adjust z to satisfy the addltlnllal ~,ual z c N wblle preserving the iela~mt]shlps Z2 s c and c \n< (7+y)2, m wc aclllcve z ( N first and then preserve lt ttlt ou?, hout the loop computatloo. T tle ex!enslclll \ntechnique su~gests preserving ZCN rht ou[gtlcwt 101111 computation. [This Is, in fact, the o~ore etlicient \nof thp twc, cboiccs. ] Inltfaliy z=j=O(N, butsJnce ZIS somctt!7~r\\ IItci cmrnted by y , the latter should \nalso be a nomne?,atlve Inte$er, Assuming that z and y are nomnep,attve, ttle exit test (Z+Y)z s (Z+I)2 \ncatn be replaced by y<l. Furtlletnlore, y 1s nomzero (since fniually o<~~<k.y and the only operator apphed \nto y Is halving ), so, under the assumption that Y IS an integer, we need only testfor y=1 Fjnally, it) \norder for y to remain in N while it M repeatedly halved until It equals 1, we must have y ( 2~ So lnltlally, \nwill-n yrk , w insist that k c 2N , and accordingly add the COll JUIICt kcp~ to ttle Inltlallzatlon sub$oal \nc < k2 Note that IIO!V, with k c 2N , the termination condmon: (4) (~rr)((z+k/2n)2 S (Z+~)2) clearly \nholds. Thus far, we have the partially written prog)-am assert c(N Z+o achieve c<kz, kc2N y+k loop assert \nz2 SC, c < (Z+Y)2, z c N, y c 2N until y=1 y .-y/2 if (z+y)2 scthen zeZ+Yfi repeat assert Z25c, c<(2+1)2, \nzrN , The uoachlevecf subgoal: achieve cKkz, k c2N must now be synthesized. We would first attempt to \nachieve this &#38;oai oiic cm, junct at a time. Tlle first might easily be achieved by Iettinp: k = c+] \n, whtle the second could easily be achleveci by Icttlng k = 1. Hc,wevet , though each corljunct IS achievable \nby itself, achmvtng both together M more dlflicult, since these two sol LIt Ions In generai conflict \nwllh eaCh other, So, we ttansform this cotljunctive goal, choosing first to achteve k c 2N by icttmg \nk = 2\u00b0 = 1, and then to keep it true while executing a loop until the rernain]n~ conjunct, c < k2, IS \nalso satisfied. Doubilng k with each Iteration will preserve the invariant k < 2N while making ptogress \ntowards the exit test c < kz [l-he reasoning is as follows We know that k should bc inctcasln~,. since \nInitially k = 1 and ultimately Me want O s w c < k Slilce we wish k = 2 for some natural number n to \nIclllaln 111Vatiallt K hl\\e k Iticreases, It follows that the expollcnt n also increases. IJoubllng \nk lnctements the espotlrnt by 1 .] Wc Ilave c,bta{llrd the followlng m[tlaliza[lon: assert c <N (Z, k).(O,1) \nloop assert k < 2N until c<k2 k.2k repeat y~k NotIs tl]at tllc last a$~ignnvmt y -k Is supel[luous; \nItmay be ellinitlatrd II file t-cl}l~ce all occoirciices of k irl the cocie with Y Wjth th!s chan~,c, \n~e have the Integer squaie-)oor progjam: INTEGER SQUARE-ROOT PROGRAM asset-t c ( N (z, y) +(o, 1) loop \nassert y c 2N until c<yz y.7y repeat loop assert z2 s C, c < (Z+Y)2, z ( N, y [ 2N until y=1 y ~ y/2 \nif (Z+Y)z scthen z+z+y fi repeat assert Z2sc, c< (z+l )2, zcN , Ewrnp]c 6: lnfr~c! Sqli(7rt-roo( to \nHardware !nlt gt r Division We wisl} to construct a proKranl to compute the quotient q and remainder \nr of two Integers a and b The pro~ram must satisfy the output specification: o<r Ar<b A q<NA a=h. q+r, \nor-equivalently: (:)) q~ajb A d/b<q+l A qcN A r=a-b. q, given the Inl,ut specification: a[NAb [N+ ( \nN+ IS the set of positive integers). We could develop this program from our binary search sclle,nla in \nthe same manner as we constructed the Integer square-root program. Instead, however, we will demonstrate \nhow to transform the just constructed integer square-root program directly into the tfesired integer \ndivision pl-ogram. As for the teal division example, we compare the desired spec(f]cations (:: ) with \nthose of the square-root program: z <CA C< (2+1)2 A ZCN, or: z<d~~ 4F<z+1Azc N, and obtain the transformations: \nz br(onws q ,and c fworrws (a/b)2 In addition we will have to achieve r = a-b. q Applying these transformations, \nthe exit test of the first loop, c < Y2 , becomes (a/b)2 < y2 . Since both a/b and y are positive, this \nM the same as a/b < y or a < b.y Similarly the conditional test (Z+Y)z s c becomes (q+Y)2 s (a/b)2, or \nequivalently b.(q+y) s a. Thus, we have the program: (f?, Y) + (0, ~) loop assert y c 2N until a < b.y \ny.2y repeat loop assert q s a/b, a/b < q+y, q c N, y c2N until y=1 y + y/2 if b.(q+y) sathen qeq+y fi \nrepeat assert qsa/b, a/b <q+l, qcN . Spectal attention must be paid to the input specification: By (a/b)z \nto the input apillyln?; the transformation c fXCOmCJassettton of the Integer square-root program, the \ninput contfltion for this program Isobtalned. Wenote, however, that the only fact needed for the construction \nof the square-root program was O<c; its input specification c<N was unnecessarily restrictive. A pplylng \nthe transformation to O s c yields (z < (a/b)2. Now, since this is implied by the input spectficatlon \na c N A bc N+, the above program is correct for any legal values of a and b. To achieve the addltlonal \noutput specification r = .s-b. q, we extend the above program to keep that relation invariantly true. \nSo whenever q is updated, it M necessary to update r accordingly: when q is initialized to O, r = a-b. \nO = a; q when is incremented to q+y, r becomes a-b. (q+y) = r-by. Sofarwe have: assert a <N, b cN+ (q, \ny, r) +(0, 1, a) loop assert y { 2N, r = a-b.q until a < b.y y.2y repeat loop assert q < a/b, a/b < \nq+y, q c N, Y c2N, r = a-b.q until y=1 y + y/2 if b.(q+y) s a then (q, r) + (q+y, r-by) fi repeat assert \nqsa/b, a/h <q+], qcN, r =a-b.q . Note that the conditional test b,(q+y) ~ a IS equivalent to b.y s a-/J. \nq or b.y s r. The expression b.y involves multiplication atnd appears tht-ee times, so a new variable \nu is introduced to always equal by. Substituting u for all occurrences of b.y and updating u whenever \nthe value of Y is changed, we obtain: HARDWARE INTEGER DIVISION assert a<N, bcN+ (q, y, r, (J)+(0, 1, \na, b) loop assert y c 2N) r = a-b.q, u = b.y until a<u (y, u) + (2y, 2U) repeat loop assert q<a/b, \na/b <q+y, qcN, yc2N, r = a-b.q, u = b.y until y=1 (y, u) -(y/2, lJ/2) if usr then (q, r) +(q+y, r-u) \nfi repeat assert q,< a/b, a/b <q+l, qcN, r =a-b. q , This then M the desired hardware integer djvmon \nprogram. Its only operations are addition, Subtraction, comparison and shlfhng, all of which ale ha!dware \nlnstructionson binary computers. NotQ the slmllatity between the extension and optimization steps it) \n[his example. In both cases a relation was added and kept ltlvatlantly tiue at all points of the program, \nAs a final note, we wish to IJolnt out that most of the previous examples would have profited from simllaro \nptimlzations. ACKNOW~GEMENT . We thank Richard Waid]nger forma nyfruitful discussions and constructive \ncomments, l tlis research was supported in part by the Advanced Research Projects A~,ency of the Department \nof Defense under Contract hiL)A 90?-76-C.-O2O6, by the C}tlce of Scientific Research of the United States \nAir Force under C1-ant AFOSR-7&#38;2909A, and bya grant from the United States -Israel Binational Science \nFounclation. Computer time was provided by the Artificial lntclllgcncc CcntcI of Stanford Research Insti[ute. \nREFERE_N~ Dershowitz, N. and Z, Manna [July 1975], On automating sttuc[urd ,bIogromming, Proc. Symp on \nProving and lnll]l\"ovl!lg Pt`oSran}s, Arc-et-Setlatls, France, pp. 167-193. Dijkstra, tl.W. [1976], A \ndi5ciplirre of ,@I o$Iat71ming, Prentice EIall, Erl~,lewood Cliffs, N.J. Fikes R. E., P.E, Hart and N.J. \nNilsson [Winter 1972], Lmr)rri7?g crrd fxccuting gcnerdizt?d robot plans, Aruhclal lntellip,ence, V. \n3, No.4, pp. z51-2S8. Gerhart, S,L. [Apr. 1975], Krroru!edge ahout ,brog?ams: a model and ca$e jft~dy, \nProc. Intl. Conf, on Rellable Software, Los A ngelcs, Ca., pp. 88-95. German, S,M. and B. Wegbreit [Mar, \n1975], A s~rrtllesizero~ indur[ioc a55c]fion~, IEEE Trans, on Software Engineering, V, SE-I, NO. l,pp \n.68-75. Katz, S,M. and Z. Manna [Apr. 1976], Logical anal~$i$ of firogtam$,CACM, V. 19, No4,pp.188-206, \n Manna, Z. ancf R.J. Waldinger [Summer 1975], Knowltd:t and ?t.asoning i7z proglam synthesis, Artificial \nlntelhsence, V, 6, No. 2, pp. 175-208. Sussman, G.J. [ Aug. 1973], A cotn~utationa! wdel oj skill (7((~ul.c(tion, \nPh.D. thesis, fJI-f_, Cambridge, Mass.; also I)tlhllsllcci as A iom~rffcr rno[/c-/ of Jkili acquisition, \nAmerican Llsevler, New } otk, N.} . ( 1975). Wensley, J.tl, [Jan, 1959], A class oj non-ana/yticc/ iteratiue \n~)oi<~~t$s, C:olrlpu[er J., V. 1, No. 4, pp, 163-167. Wilber, B.M. [Mar. 1976], A ~LISP rtfcrtncc manual, \nTech, note I 18, A rtlficlal intelligence Center, Stanford Research institute, Menlo Park, Ca. A.P~PEN_tyx \nThe following IS a QL15P trace of Example 1 (the debugging of the real CIIVISIOI1 program ), as executed \nby out modification system. I IIc steps and expressions differ somewhat from the example as pt-esentecl \nin the previous section. The trace has been edited and annotated to enhance Its understandablhty, False \nleads that the system followed are also included. The procedure MODIFY modlfles a program to achieve \na new gDal. Here it 1s used to debug 6 real dlvlslon progrhm: MOOIFY: This IS the annotated bad given \nproqram: ((ASSERT (AND (LTQ O A) (LT A (TIMES 2 B)) (LT O E))) (SETQ Z O) (SETQ Y 1) (LOOP (ASSERT (ANO \n(LTQ (TIMES B z) A) (LT A (TIMES B (AOO Z (TIMES 2 Y)))))) (UNTIL (LTt2 Y E)) (IF (LTQ (TIMES B (AIJEI \nZ Y)) A) THEN (SETQ Z (ACID Z Y)) FI) (SETO y (DIV2 Y)) REPEAT) (ASSERT (ANII (LTQ Z ([IIV A B)) (LT \n(D]v A (TIMES 2 B)) (ADD (nIv z 2) E))))) prefaced by an Input assertion, containing the conditions \nunder which the invarlants hold, and fol lowed by output invariant We desire that the program achieve \nthe ouJJuJ specification: (ASSERT (AN[l (LTQ Z (DIV A B)) (LT (fI1V A B) (AEIU Z E)))) wltl, the leqal \ninputs defined by the followlng J!DLLt speclflcatlon: (ASSERT (AND (LTQ O A) (LT A B) (LT O E))) Note \nthat this specification differs from the Input assertion of the program. The system bet)lns by applylng \nthe function MATCH to compare the output invariant with the desired output specification: MATCH: (AND \n(LTQ z (DIV A B)) (LT (EItv A (TIMES 2 t3)) (ADD (Dlv z 2) E))) The first CCIl)JUllCtS Of both are the \nSame, ~nd the sYstem compares tile second CO!lJUnCtS. It notices that If the e>:presslon (TIMES 2 B) \ncould be transformed Into B and (OIV Z 2) Into z, then the whole conJunct would transform as deslrerl \nSo It calls the function INVERT, which su!jqests the transformation B becomes (DIV B 2) for (TIMES 2 \nB): lNVFRT: (TRANSFORM (TIMES 2 B) B) rescllt. (TRANSFORM B (DIV B 2)) and slm]larly for ~[llV Z 2): \nINVFRT (TRANSFORM (OIV z 2) z) result: (T ItANSFORM Z (TIMES 2 Z)) Thus , we have found triinsformatlon \n1: ((TRANSFORM B (OIV B 2)) (TRANSFORMZ (TIMES 2 Z))) But first, tl, e system must ~PPIY this trtinsformatlon \nto the first CO13JU11Ct: TKANSFOR!I-EXPRS: (LTQ Z ([IIV A B)) result. (LTQ (TIMES 2 Z) ([IIV A ([IIV \nB 2))) and prove that the con Junct remains true, 1.e. , (IMPLIES (LTQ (TIMES 2 Z) (EIIV A (OIV B 2))) \n(LTQ Z (OIV A B))) Be forP Iproceedlnq. the system looks for additional possible trsnsformstlons. Since \nAIKI IS commutative, an attempt 1s also made to malcl, (A[l[l ([IIV Z 2) E) with (A[l[I E Z), This, tocjether \nwith (TRANSFORM B (DIV B 2)), yields trinsformatlon ~.: ((TRANSFORM B (CIIV B 2)) (TRANSFORME Z) (l KANSf \nORN Z (TIMES 2 E))) However, this set of transformations 1s dlsqual)fled, since there 1s no way to transform \nthe variable Z Into the constant expression (TIMES 2 E). Contlnulnc) system speciflcatlons+ In also Its \nsearch finds e. q.: for alternative equivalent fo transformations, rmulations of the the (AN[l (AND (LTQ \n(TIMES B Z) A) (LT A (ADD (TIMES B Z) (LTQ (TIMES B Z) A) (LT A (AII@ (TIMES B Z) (TIMES (TIMES 2 B E)))) \nB E)))) Comparlnr! them yields Lransformatlon ?: ((TRANSFORM E (OIV E 2))) The system now cdl 1s the \nfunction TRANSFORM-PROGRAMeach for of the two ellqlble transformations (1 and 3) In tllrn: TRANSFORt+PROGRAM: \n((ASSERT (ANII (L.TQ O A) (LT A (TIMES 2 B)) (LT o E))) (SETQ z O) (SETQ Y 1) (LOOP (A5sERT (AND (LTQ \n(TIMEs B z) A) (LT A (TIMES B (AIIEI Z (TIMES 2 y)))))) (UNTIL (LT6 y E)) (1F (LTQ (TIMES B (AOO Z Y)) \nA) THEN (SETQ Z (ADD Z Y)) Fl) (SETQ Y (DIV2 Y)) REPEAT) (ASSERT (ANII (LTQ z (oIv A B)) (LT (DIV A (TIMES \n2 B)) (ACID (OIV Z 2) E))))) ((TRANSFORM B (OIV B 2)) (TRANSFORMZ (TIMES 2 z))) (AND (LTQ z (DIV A B)) \n TRANSFORM-CONST-EXPR, which transforms constants, is now (LT (nIv A B) (AEIO Z E))) called. and B 1s \nreplaced by ([IIV B 2) throu!jhout: appl led: TRANSFORFI-CONST-EXPR: (TRANSFORMB ([l]v B 2)) TRANSFORM-PROGRAM: \n((ASSERT (ANII (LTQ o A) (LT A (TIMES 2 B)) (LT o E))) TRANSFORFI-VAR-EXPR transforms a variable, In \nthis case the (SETQ Z O) (SETQ Y 1) variable Z becomes (TIMES 2 z): (Loop (ASSERT (AND (LTQ (TIHES B \nz) A) (LT A (TIMES B (AIID Z (TIMES 2 Y)))))) 1RANSFOR14-VAR-EXPR, (TRANSFORMZ (TIMES 2 Z)) (UNTIL (LTQ \nY E)) (]F (LTQ (TINES 0 (AIIII z Y)) A) This may entell el]mlnatlnq expressions from the left-hand TH[N \n(S[[Q Z (AOO Z Y)) FI) ,slde of asslcjnmcnts The functlor TKANSFORP-SETQ IS used tO (SETQ Y ([IIV2 Y)) \ndI~PIY (lp~+li SFOR14Z (TIMES 2 Z)) to all asslqnments to z: REPEAT) (ASSERI (ANO (LTQ z ([IIv A B)) \n\u00ad(SETQ z o) (LT (DIV A (TIMES 2 B)) (ADD (OIV Z 2) E))))) result= (SETQ Z ([l I d O 2)) (( TRANSFORFfE \n(DIV E 2))) and: obtalnlnr] (after slmpllflcatlon) a second corrected proqram: (SETQ Z (AII[l Z Y)) \n((ASSERT (Ahi[] (LTQ O A) (LT A (TIMES 2 B)) res~llt= (SETQ z (OIV (ADO (TIMES 2 Z) Y) 2)) (LT O ([IIVE \n2)))) (SETQ Z O) (SETQ Y 1) The transformed program 1s: (LOOp (ASSERT (AND (LTQ (TIMES B Z) A) (LT A \n(TIMIS B (ADD z (TIMES 2 Y)))))) (( ASSLRT (AND (LTQ o A) (UNTIL (LTQ y (oIv2 E))) (LT A (TIMES 2 (oiv \nB 2))) (LT O E))) (If (LTQ (TIMEs B (AOO z Y ) A) (SETQ z (DIV o 2)) (sE10 y 1) THEN (SETQ Z (ADO Z Y) \nFl) (Loop (ASSERT (SETQ Y (D1v2 Y)) (AND (LTQ (TIMES (iIIv .9 2) (TIMES 2 z)) A) REPEAT) (LT A (TIMES \n([IIV B 2) (ASSERI (ANII (LTQ z (oIv A B)) (AIIII (TIMES 2 Z) (TIMES 2 Y)))))) (LT (oIv A (TIMES 2 1)) \n(UNTIL (LTQ Y E)) (ADO ([IIV Z 2) (DIV E 2)))))) (IF (LTO (TIMES (Dl!f B 2) (AIIE (T I14[s 2 z) Y)) A) \nA~jaln lt [must be shown that the transformed Jnput zssertlon THEN 7S lmpl led by tl, c Input speclflcatl \non: (StTQ Z (DIV (AIID (TIMES 2 Z) Y) 2)) FI) (SETQ Y ([IIV2 Y)) (I MPLIFS (ANII (LTQ o A) (LT A B) \n(LT o E)) REPFAT) (ANO (LTQ O A) (LT A (TIMES 2 B)) (ASSERT (ANO (LTQ (TIMES 2 Z) (OIV A ([IIV B 2))) \n(LT O ([IIV E 2)))) (LT (EIIV A (T IP4ES 2 (OIV B 2))) (ADD ([IIV (TIMES 2 Z) 2) E))))) which 1s Indeed \ntrue, since A(2B lS lmpl]ed by A(B and O<E/2 IS ecl~llvalent to O<E. No!?-executable statements ( Involvlnq \n[l IV) are now replaced by executable ones (01V2) as part of a slmplqflcatlon step. The slmpll fled e.:presslons \nhave been underscored; they Include replaclnq 1 lMFS by TI11ES2. where possible. Thus the system obtains \nIts first corrected proqrtim: ((ASSERT (ANEI (LTQ o A) (LT A (TIMES 2 ([IIV B 2))) (LT O E))) (SETQ Z(I) \n(SETQ Y 1) (LOOP (ASSERT (ANO (LTQ (TIMES (OIV B 2) (TIMES 2 Z)) A) (LT A (TIMES (DIV B 2) (AOD (TIMES \n2 Z) (TIMES 2 Y)))))) (UNTIL (LTQ Y E)) (IF (LTQ (TIMES (W B) (A[l[l (T~2 Z) Y)) A) THFN (S~TQ z (u2 \n(Aoo (M2 z) y))) FI) (SETQ Y ([11V2 Y)) REPEAT) (ASSERT (AND (LTQ (TIMEs 2 z) (oIv A (@iv B 2))) (LT \n(EIIV A (TIMES 2 (OIV B 2))) (AEID (oIv (TIMES 2 z) 2) E)))))  Laztly, lt must be proved that the transformed \ninput assertion 1s lmpl led by the cjlven input speclflcatlon, I.e. : (IMPLIES (ANII (LTQ o A) (LT A \n6) (L7 o E)) (ANII (LTQ O A) (LT A (TIMES 2 (EIIV B 2))) (LT O E)))  and It does, since (TIMES 2 (DIV \nB 2)) IS equal to B, The second possible transformation, trtinsformatlon 3, is now \n\t\t\t", "proc_id": "512950", "abstract": "A programmer spends more time modifying already existing programs than constructing original ones. An attempt is made to formulate techniques of program modification, whereby a program that achieves one result can be transformed into a new program that uses the same principles to achieve a different goal. For example, a program that uses the binary search paradigm to divide two numbers may be modified to calculate the square-root of a number in a similar manner.Program debugging is considered as a special case of modification if a program computers wrong results, it must be modified to achieve the intended results The application of abstract program schemata to concrete problems is also viewed from the perspective of modification techniques.We, have embedded this approach in a running implementation; our methods are illustrated with several examples that have been performed by it.", "authors": [{"name": "Nachum Dershowitz", "author_profile_id": "81100258959", "affiliation": "Stanford University, Stanford, California", "person_id": "PP39034861", "email_address": "", "orcid_id": ""}, {"name": "Zohar Manna", "author_profile_id": "81100089034", "affiliation": "Weizmann Institute of Science, Rehovot, Israel", "person_id": "PP15021756", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512964", "year": "1977", "article_id": "512964", "conference": "POPL", "title": "The evolution of programs: a system for automatic program modification", "url": "http://dl.acm.org/citation.cfm?id=512964"}