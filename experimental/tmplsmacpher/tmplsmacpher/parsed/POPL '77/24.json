{"article_publication_date": "01-01-1977", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1977 ACM 0-12345-678-9 $5.00 Synchronization in Actor Systems Russell Atkinson Carl Hewitt MJ.T< M.I.T. \nRoom 527 545 Technology Square Cambridge, Mass. 02139 (617) 253-6015 SECTION I ABSTRACT This paper \npresents a mechanism for the arbitration of parallel requests to shared resources. This mechanism is \nthe serialize, which may be described as a kind of protection mechanism, in that it prevents improper \norders of access to a protected resource. The mechanism is a generalization and improvement of the monitor \nmechanism of Brinch-Hansen and Hoare. Serializes attempt to systematize and abstract desirable structural \nfeatures of synchronization control structure into a coherent language construct. They represent an improvement \nin the modularity of synchronization over monitors in several respects. Monitors synchronize requests \nby providinga pair of operations for each request type [examples are STARTREAD/ENDREAD and STARTWRITE/ENDWRITE \nfor the readers-writers problems]. Such a pair of operations must be used in a certain order for the \nsynchronization to work properly, yet nothing in the monitors construct enforces this use. Serializes \nincorporate this structural aspect of synchronization in a unified mechanism to guarantee proper check-in \nand check-out. In scheduling access to a protected resource, it is often desired to wait in a queue for \na certain condition before it continues execution. Monitors require that a process waltlng in a queue \nwill remain dormant forever, unless another process explicitly signals to the dormant process that it \nshould continue. Serializes improve the modularity of synchronization by providing that the condition \nfor resuming execution must be explicitly stated when a process enters a queue making it it unnecessary \nfor processes to signal other processes. Each process determines for itself the conditions required for \nits further execution, The behavior of a serialize is defined using the actor message-passing model of \ncomputation. Different versions of the readers-writers problems are used to illustrate how the structure \nof a ,serializer corresponds in a natural way to the structure of the arbitration problem to be solved. \nThe correspondence makes it easier to synthesize a scheduler from behavioral specifications and to verify \nthat an implementation satisfies its specifications, No claim is made for the completeness of the serialize \nmechanism, beyond showing that semaphores can be implemented using serializes. Further, no complete \n solution is proposed to the no-starvation specification which rquires Room 813 545 Technology Square \nCambridge, Mass. 02139 (617) 253-5873 that a resource reply to each request which it receives. Rather, \nit is shown for some simple examples that serializes represent a step toward better structuring of parallel \naccess to shared resources, and that proofs that starvation is impossible for these examples are easier \nwith serializes than with some of the currently existing mechanisms for controlling parallel access to \nresources. SECTION II ---PARALLELISM in PROBLEM SOLVING Serializes have been developed as a modular arbitration \nprimitive for actor systems to aid investigating the issues of parallelism in problem solving. Conceptually \nan actor is an object which has both procedural and data aspects. A process is a totally ordered sequences \nof computational events where each event consists of sending a message to an actor. The behavior of a \nprimitive actor such as a serialize is defined by the relationships among the events which are caused \nby the actor. We now feel that parallelism may have a more important role than previously realized in \nexplicating the structure of higher level symbolic processing, Until recently it has been widely accepted \nthat parallelism is not suited for the higher level symbolic processing of problem solving. Most psychological \nevidence seems to point to individual humans as being almost entirely serial in their high level problem \nsolving. Recently the development of actor message passing semahtics has brought about a shift in our \nparadigm for problem solving. Early programs which tried to be expert in some domain were thought to \nbe analogous to an individual human expert who was expert in the domain. Most programs were developed \non the basis that there should be a single unified coherent intelligence which was directing all aspects \nof the problem solving in a serial fashion. Ttie development of the actor model of computation has encouraged \nus to attempt to develop a paradigm ,based on ~ society ~ experts comrnunicatin~ ~ pm messages. This \nswitch in paradigm has provided us with a rich source of ideas for problem solving strategies. We are \nattempting to develop a dialo~ue ~~ of programming which places its emphasis on the modular distribution \nof knowledge and clean means of communication between pieces of knowledge. Thinking and programt ning \nin this new paradigm has in turn caused us to re-evaluate the case for parallelism. We note that societies \noften make good use of parallelism for a variety of purposes. The additional programming burden imposed \nby parallelism is the task of arbitrating the activities of modules running in parallel. We hope that \nby analyzing the structure of problem solvers that attempt to use parallelism at the highest levels of \nproblem solving that we can further explicate the structure of problem solving. This paper contributes \ntoward that aim through the explication of a modular arbitration primitive. We further seea need for \nthe development of language construct$ that are at least partially chosen for their provability. A language \nfeature providing synchronization should be designed toprovide usable axioms about thepossible orders \nof events in a program. The language feature should guarantee that conditions needed to prove properties \nof programs are explicit in the axioms for the language feature. W? have attempted to design serializes \nto facilitate the proof that schedulers implemented using them satisfy their specifications. The specifications \nof a protected resource typically inVOiVe stating both integrity and scheduling constraints. An integrity \nspecification typically takes the form of a consistency constraint. A typical example of a integrity \nspecification might be that the position and velocity of an airplane must be recorded for the same instant \nof of time. A scheduling specification typically takes the form of a constraint on the time order of \ncertain events. A typical example of a scheduling specification is that if two requests are received \nin a certain order to write in a data base then the one which is received first will be perfomed before \nthe other. We would like to be able to demonstrate that protected resources implemented using serializes \nsatisfy their specifications. In particular, we would like to prove that a scheduler implemented using \nserializes guarantees a reply to each request received. Guaranteeing that a reply will be sent for every \nrequest received is a stronger and more useful property than merely being free of deadly embrace which \nis the scheduling specification most extensively treated in the literature on synchronization. SECTION \nIII --SERIALIZES 111.1 ---Concept of a Serialize In this section we will describe an abstract mechanism \ncalled a serialize for guaranteeing the integrity of a protected resource. The mechanism is an abstraction \nand encapsulation of the method commonly used in operating systems. A detailed analysis of the facilities \nneeded will be used to motivate the design decisions which we have made. A serialize bears an analogy \nto the front desk of a hospital such that only one person can check in or out at a time. The front desk \nof a hospital serves to schedule the entrance and exit of people in the hospital. Entering or leaving \nthe hospital is impossible without checking through the front desk. Various queues are maintained for \npeople who are waiting. In addition records are maintained of where people are within the hospital. Serializes \nare modular in the sense that they can be constructed to encase the resource to be protected in such \na way that the protected resource can only be accessed by passing through the serialize. A serialize \nshould be constructed to surround the protected resource in such a way that it is imtsossible to accidently \navoid passing through it when using the protected resource. We shall avoid in this paper the issues involved \nwith exactly how one guarantees that a serialize has sole possession of a resource, or-even if cooperating \nserializes might share access to a resource. The reader may assume that the serializes we deal with in \nthis paper have been constructed to effectively have sole access to the encased protected resource. Serializes \nare intented to be constructed to enforce constraints on access to resources. We can diagram how a seriallzer \ncan be used to schedule access to a protected resource as follows SERI AL I ZER-RECMJEST + ------- I \n------\u00ad --------------------\u00ad ------\u00ad + I v I I I I ENQUEUE I I I I + ---&#38;-i JOIN-CROUD I I I i I \nI I +------\u00ad ------\u00ad + I I I v I I I I I I + ---\u00ad 1+---- I +-----------+ [ I I ; II ~ j Ii RESOURCE I \nI I I / I +--------d I / / \\ LEAVE-CROWD ~ 1 I II I +-------I -------+ I EXIT / II /I I +-----------------------------------------+ \nI Diagram of Serialize Encasing a Protected Resource Each arrow in the above diagram is labeled with \nthe kind of computational event it represents, The events fall into two disjoint categories which are \nto~ally ordered in time those which GAIN-POSSESSION and those which RELEASE-POSSESSION of the serialize. \nEach event in the former category subsequently causes an event in the latter category to occur. Furthermore \nafter a CAIN.POSSESSION event has occured, then another such event will not occur until after the former \nhas caused a RELEASE-POSSESSION event to occur. A typical sequence of events which records the activities \nassociated with the use of the protected resource P begins with a SERIALIZER-REQUEST event in which the \nserialize receives a message M which is intended for the protected resource P. The request must eventually \nresult in an ENTRY event which gains possession of the serialize. A GUARANTEE request can be used in \nordir to wait until some condition is true before proceeding. Such a request releases possession of the \nserialize. If a reply is received for the GUARANTEE request then it will be called an ESTABLISHED event \nbecause the condition is guaranteed to have been established at the time of the reply. Thus each ESTABLISHED \nevent regains possession of the serialize at a point in time at which the condition is guaranteed to \nbe true. The above sequence of GUARANTEE and ESTABLISHED events may occur a number of times in order \nto sequentially guarantee a number of conditions in succession. When the proper condition for using a \nprotected resource has been established then possession of the serialize can be released by a JOIN-CROWD \nevent which records that there is another process in the crowd using P. Next the message M is delivered \nto the protected resource P in a RESOURCE. REQUEST event. Eventually the protecied resource P may produce \na reply R to the request which will be called a RESOURCE-REPLY event. The RESOURCE-REPLY will eventually \nresult in a LEAVE-CROWD event which regains possession of the serialize and records that the process \nis no longer in the crowd using P. The next event is called an EXIT which releases possession and causes \na SERIALIZER-REPLY event in which the message R is sent as the reply to the original SERIALIZER-REQUEST \nevent. Serializes derive their name from the fact that all of the events which gain and release possession \nof the serialize are totally ordered (serial) in time. Furthermore the ordering is such that an event \nwhich gains possession is always followed by one which releases possession. This property is represented \nin the diagram by indicating an event which gains possession by an an arc which crosses the boundary \nfrom the unshaded area to the shaded area and conversly by indicating an event which releases possession \nby an arch which crosses the boundary in the opposite direction. Notice that the shaded area has a number \nof holes in its interior. The purpose of these holes is to allow possession of the serialize to be released \nfor either of two purposes. The first is to wait for some condition to become true. The second purpose \nis to allow parallelism in the use of protected resources without tying up the serialize. To understand \nthe behavior of serializes, one must understand the ways that possession of a serialize is gained and \nreleased. There are three ways to gain possession of a serializefi An ENTRY event, which gains possession \nas a result of a SERIALIZER-REQUEST event. An ESTABLISHED event, which regains possession as a result \nof a GUARANTEE request with a condition which has been established to be true. A LEAVE-CROWD event, which \nregains possession as a result RESOURCE-REPLY event from a protected resource. There are three ways to \nrelease possession of a serialize A GUARANTEE event, which occurs in order to guarantee that some condition \nis true before continuing execution. A JOIN-CROWD event, which records that a process is using the protected \nresource. An EXIT event, which causes a reply to the original SERIALIZER-REQUEST event. For any given \nserialize and process after an ENTRY event and before the corresponding EXIT event, exactly ~ of the \nfollowing two conditions will hold: The process is in possession of the serialize (executing in the shaded \nregion of the diagram). The process has released possession in order to wait for some condition before \nproceeding or to join a crowd of processes executing in some protected resource. Furthermore, it is \nnever the case that two processes are in possession of the serialize at the same time. SECTION IV ---SERIALIZE \nCONSTRUCTS In this section we present the language constructs used in the serialize mechanism. They \nhave been developed to facilitate the implementation of the abilities enumerated above. NJ ---Creation \nA serialize is constructed by an expression of the form (cons-aerializer (IW.UCS: ccdlection-of---fothehserializer)r) \n. . (croseds: collection-of-crowds-for-the-serializer) - . (entry: ~-of-serializer))  The g ueues \nare used to provide first-in-first-out service to processes waiting for some condition in order to continue \nexecution. The crowds are used to record which protected resources are in use. If an actor constructed \nby a expression of the form given above is sent a message M in a SERIALIZER-REQUEST event then M will \neventually be sent to =of-serializer in an - ENTRY event which gains possession of the serialize. At \nmost @te process can be in possession of a serialize at one time. The queues and crowds for the serialize \nrelate to its internal working and are explained in greater detail below, IV.2 ---Queues Queues are provided \nto allow a processto wait until some condition is met before proceeding further. Serializes provide an \nenqueue command which has the following syntax to meet this need: (enqueue the-wait-queue (guarantee: \nthe-condition) (then: the-coritinuation))  A process which executes the above command immediately releases \npossession of the serialize with a ENQUEUE the-wait-queue to GUARANTEE the-condition event. It will not \nregain possession and continue with execution of the-continuation with an ESTABLISHED the-condition event \nuntil all of the following pre-requisites hold: 1: Ail the previous GUARANTEE requests in the-wait-queue \nhave received replies that the condition was ESTABLISHED. 2 the-condition is true. 3: A JOIN-CROWD, EXIT, \nor GUARANTEE event has just occurred releasing possession of the serialize. Note that ~ of these pre-requisites \nmust be simultaneously satisfied before execution will continue with the-continuation. It may be the \ncase that there is more than one process which satisfies the above pre-requi~ites. In this case it is \nnot obvious which process should g~in possession next. We recommend that serializes be constructed so \nthat they satisfy the following property: 4 There is no other process such that the above three conditions \nhold. If all four conditions hold then the process is guaranteed to get possession of the serialize \nnext before any further ENTRY or LEAVE-CROWD events occur. In other words, conceptually at least the \ncondition that must be guaranteed for further execution is evaluated for each process that is at the \nfront of a queue every time possession of the serialize is released. If there is only one whose condition \nis true then it gets possession next. The condition in the guarantee: clause of the enqueue command is \npotentially any expression with a boolean result. The expression is evaluated whenever possession of \nthe serialize is yielded. We have found one particular form of expression to be quite useful, which is \na test for emptiness of queues or crowds. This is written as (empty: gueuel queue? ...) Each queue listed \nmust be empty for the expression to be true. The evaluation of an expression of the above form has no \nside-effects. It simply calculates the boolean value for the expression. We wish the-condition to be \nguaranteed to be true when execution continues with the-continuation. This depends on several constraints: \n1: The evaluation of the-condition must not change the value. of ~he-condition. LE. the evaluation of \nthe-condition is free of sid,e-effects. 2 The value of the-condition must be unaffected by any execution \nby any process which does not possess the seriaiizer. Given these constraints, we can say that the-condition \nmust be true when execution resumes with the-continuation of an enqueue command. IV.3 --Relaying Messages \n Within a seriali r it is necessary to be able to temporarily release posse sion of the. serialize in \norder to relay 7 the message to the prot~cted resource and then later regain possession with the re~ly \nfrom the protected resource. A com~and of the following form accomplishes this by transtnitting the message \nreceived by the serialize to e-protected-resource: (relay-to a-protected-resource (thru: a-crbwd)) An \nentry is made h a-crowd to record the presence of a process in a-protected-resource and then possession \nis yielded. After a-protected-resource has replied and possession of the serialize has been regained \nby a LEAVE-CROWD event then the entry is removed from a-crowd. During the time between the JOIN-CROWD \nand the LEAVE-CROWD events, the entry is a member of a-crowd. Thus by inspecting the various crowds of \na serialize it is possible to determine which resources currently have processes executing within them. \nThe value of the relay-to expression is the reply of a-protected-resource to the message. SECTION V-BEHAVIORAL \nPROPERTIES OF SERIALIZES A kerializer is a language construct that is intended to facilitate the synthesis \nand analysis of synchronizers. For this to be possible we must provide precise specifications of the \nbehavior of serializes. The axioms for serializes given below can be formally expressed in the actor \nmodel of computation. However, such rigor is not necessary for the purposes of this paper, so we shall \nstate the properties lessformally in English. Behavioral properties of sequences can be stated in terms \nof events and relations between events. We shall use the notation El --> E2 to indicate that the event \nEl precedes the event E2. The precedes relationship is an acyclic partial order. The events of processes \nthat do not interact are not ordered. In the rest of the paper we will require that the protected resource \nis well-behaved in the sensethat for each request sent to the resource exactly one reply will, be received. \n1: The idea of keeping records of which processes are currently executing in protected resources instead \nof merely keeping a count of the number was suggested by Brian Smith. The additional information i$ useful \nfor implementing debugging features, deadlock detection, and gracefully backing processes out of protected \nresources. Another requirement we will make is that every process that comes into possession of a serialize \nwill eventually release possession. The intent is to exclude behaviors where the serialize is locked \nup forever by a process which is performing an infinite computation while in possession. We believe that \nthis condition will usually be trivial to satisfy in practice since the code in a serialize simply has \nto decide whether to wait for some condition or join some crowd of processes executing in a protected \nresource. This decision must be made as efficient as possible in order to maximize the thruput of the \nserialize. Otherwise the serialize can seriously degrade the efficiency of a system by becoming a bottleneck. \n V.1 ---Prot)erty of Mutual Exclusion The most fundamental property of a serialize is that processes, \nmutually exclude one another from possession so that at most one process has, possession at any given \ninstant. For any given serialize there is a total ordering in time for all of the ENTRY, GUARAN EEE, \nESTABLISHED, JOIN-CROWD, LEAVE-CROWD, and ~XIT events of that serialize. A process gains possession of \na serialize starting with an ENTRY, ESTABLISHED, or LEAVE-CROWD event, and retains possession until it \nreleases possession with a GUARANTEE, JOIN-CROWD, or EXIT event. We will use subscripts to indicate distinct \ninvocations of a serialize. The property of mutual exclusion of possession of the serialize can be formalize \nin tetms of events as follows Either the i-th possession precedes the j-th possession GAIN-POSSESSIONi \nRELEASE-POSSESSIONi --> CAIN-POSSESSIONj ~ RELEASE.POSSESSIONj or the j-th possession precedes the i \nth. GAIN-POSSESSIONj ~ GAIN-POSSESSIONi <--RELEASE-POSSESSIONj $ RELEASE-POSSESSIONi where a CAIN-POSSESSIONi \nevent is either an ENTRYi, Established. or LEAVE-CROWDi event; and RELEASE-POSSESSIONi is the the next \nevent after CAIN-POSSESSIONi which is a GUARANTEE JOIN-CROWDij or EXITi event. V.2 ---Gaining Possession \nWe would like to guarantee that any process which sends a request or reply to a serialize must eventually \ngain possession of the serialize. This property is, satisfied by any serialize which has no cycles such \nthat a process can wait in the same statement of the serialize twice without first releasing possession \nwith a JOIN-CROWD or EXIT event. It is not clear that it is ever useful to violate this restriction. \nAll of the serializes in this paper satisfy it because the serializes have no loops whatsoever. If the \nabove restriction is satisfied then any SE~IALIZER-REQUEST or RESOURCE.REPLY event must everdually result \nin a GAIN-POSSESSION event. More precisely if there is a SERIALIZER-REQUEST in the history of a computation \nthen it is followed by an ENTRY event. Furthermore if there is a RESOURCE-REPLY event in the hisfory \nof a computation then it is followed by a LEA~E-CROWD event.  V.2.a ---First Come First Served for Entry \nSince serializes are designed to implement scheduling of access to protected resources it must be possible \nfor them to observe the order of arrival of requests to the serializes in order to carry out certain \nscheduling tasks. Thus we provide that requests for entry into the serialize will be served in the order \nin which they arrive at the serialize. In terms of events this can be formalized by supposing that SERIALIZER.REQUESTi \nand SERIALIZER-REQUESTj are two events such that such that the first arrives before the second: SERIALIZER-REQUESTi \n--> SEkIALIZER-REQUESTj The next event after SERIALIZER-REQUESTi iS ENTRYi and the next event after SERIALIZER-REQUEST \ni is ENTRYJ We require that these two events be related as follows ENTRYi --> ENTRYj V.2.b ---First \nCome First Served for Re.EntrL Similarly it must be possible for a serialize to observe the order of \narrival of replies to requests sent to protected resources. Thus if RESOURCE.REPLYi precedes RESOURCE-REPLYj \nso that RESOURCE-R EpLYi --> RESOURCE-REpLYj then we require that LEAVE. CRfJWDi ..> LEAVE.CROWDj  V.3 \n---Properties of Guaranteed Conditions V.3.a --Guaranteed Condition is True if Execution Continues Let \nC be the condition guaranteed in an event of the form ENQUEUE#ARANTEEC proceed as soon as possible. \nRoughly speaking, if there are any which is caused by executing an expression of the form waiting processes \nread y to go when possession of a serialize (cnqtseuo q (guarantee: C) (km ...)) If execution of the \nprocess continues, then the next event of the process is of the form ESTABLISHEDC and C is true at the \ninstant of this event. s  V.3.b ---Internal Queues are First In First Out Suppose that q is an internal \nqueue of the serialize S and that there aretwo events such that ENQUEUEq-GUARANTEEC1 --> ENQuEuEq-GuARANTEEc2 \n[i.e. such that the former precedes the latter in the total ordering of the serialize] and that F,STABLISHEDC2 \nis the next event after ENQUEUEq-GUARANTEEc2 . Then there is an event ESTABLISHEDC1 which is the next \nevent after ENQUEUEq-CUARANTEEcl such that ESTABLISHEDC1 --> ESTABLISHEDC2 which says that ENQUEUEq-GUARANTEEcl \nwas served before ENQUEUEq-CUARANTEEc2 since both guarantee requests were placed in the same queue. \nV.3.C ---Priority for Waiting Processes Each time possession of a serialize is released, waiting processes \nare given the opportunity to continue execution, This property of serializes simplifies proofs that a \nscheduler guarantees replies to requests received and increases the responsiveness of schedulers by allowing \nwaiting processes to is released then the next event to gain possession of the serialize must be an ESTABLISHED \nevent which gives one of those processes possession. In terms of events, a processwill be said to be \nread y to go at the instant of a RELEASE-POSSESS1ON event if it is waiting because of a previous ENQUEUEQ-GUARANTEEC \nevent but such that the corresponding ESTABLISHED event has not yet occurred and the following properties \nhold: h The condition C is true. 2 The process is at the front of the queue. I.E. all previous events \nwhich waited for some condition on Q have already continued with their condition ESTABLISHED. The above \nproperties give internal queues priority over external queues. SECTION VI --MUTUAL EXCLUSION One of the \nmost common uses of semaphores is to implement mutual exclusion of execution in protected resources. \nIt is relatively easy to implement mutual exclusion using a semaphore. The idea is for each process to \nperform a P operation on the semaphore before using the resource and then to perform a V operation when \nfinished using the resource. The program mutual-exclusion-l given below can be used to construct systems \nthat insure are a resource does not receive any messages while still processing a previous message. Thus \nprocesses are guaranteed to mutually exclude each other from overl~pping execution in the protected resource. \nThis simple example is presented to illustrate more concretely the concept of encasing a resource in \na serialize. (mutual-exclusion-1 =resource) ~ ;mutual exclusion of a resource is en[orced by Uet (sem \n= (cons-semaphore)) ;constructing a new semaphore called sem in (=> =message ;then returning an actor \nsuch that whenever it receives a message (P aem) ;performs a P operation on sem (let (result = (resource \n<= message)) ;then sends the message to the resource in ;such that after the result i.s received (V sem) \n;a V operation is performed on the semaphore result))) :and the result is returned Semaphores are a \nvery primitive synchronization method which can be used to implement the facilities needed by modular \nschedulers. In some ways semaphores are analogous to the goto construct which can be used to implement \nthe control structures needed for modular programming. Serializes abstract the control structure of schedulers \nsuch as the simple one ,presented above. They can be used to increase the modularity of implementations \nby making the structure of the implementation more closely match the structure of the task to be a~complished. \nIn this way the synthesis of schedulers from specifications is facilitated because serializes provide \nfacilities for directly implementing common aspects of specifications for schedulers. Furthermore proofs \nthat implementations satisfy their specifications is facilitated because the structure of the serialize \nguarantees many properties of the implementation that would otherwise have to be painfully extracted \nfrom a global analysis of the implementation. The fundamental integrity constraint for mutual exclusion \nof the use of a resource is that if two requests SERIALIZER-REQUESTi and SERIALIZER-REQUESTi are made \nto the serialize then either the i-use completely pre;edes the j-use RESOURCE-REQUESTi I v RESOURCE-REPLYi \n--> RESOURCE.REQUESTj I v RESOURCE-REPLYj or the j-use completely precedes the i-use. RESOURCE_REQUESTj \nI v RESOURCE_REQUESTi <-RESOURCE_REPLYj I v RESOURCE_REPLYi (mutual-exclusion-2 =resource) s (cosw-serializcr \n(queues: q) (croteds: c) (entry: (enqueue q (guarantee: (empty c)) (then: (relay-to: resource Ml-u: c)))))) \n Actually mutual -exclusion-2 implements a stronger specification: namely that if SERIALIZER_REQUESTi \n-> SERIALIZER_REQUESTj then RESOURCE_REQUESTi I v RESOURCE_REPLYi .-> RESOURCES_REQUESTj The proof of \nthis stronger specification is given below. If we suppose that SERIALIZER_REQUESTi -> SERIALIZER_REQUESTj \nthen SERIALIZER-REQUESTi --> SERIALIZER.REQUESTj II vI ENTERi I ~I v  ENQUEUEi -> ENTERj I v ENQUEUEj \n follows from mutual exclusion for serializes. Therefore ENQUEUEi I v DEQUEUEi -> ENQUEUEj ; DEQUEUEj \nwhich says that one or the other must enter and leave the protected resource before the other enters. \n It is easy to see that mutual-exclusion-2 implements the integrity specification given above. The only \nway to enter the resource through the seriaiizer is to pass through the crowd c. Furthermore the crowd \nis guaranteed to be empty whenever a message is relayed to the resource. ;to enforce mutual ezclu8ion \nfor a resource ;corsstruct a serialize ;with one queue q ;and one crowd c ;tuch that when entry is gained \nto the serialize ;then wait on q ;for the condition that the crowd c is empty ;then relay the message \nto the resource ;passintr through the crowd c since queues of a serialize are first-in-first-out. Since \nserializes are mutually exclusive we know that DEQUEUEi I --> DEQUEUEj JO;N_CROWDi Therefore JOIN.CROWDi \n{ -> DEQUEUEj LEAVE_CROWDi since the pre-requisite for DEQUEUE i is that the crowd must be empty. Now \nwe can read off the desired answer by transitivity JOIN_CROWDi RESOURCE_REQU ESTi J RESOURCE.REPLYi \n{ LEAVE-CROWDi --> DEQUEUEj I JOI~_CROWDj ~ RESOURCE=REQUESTJ VIL2 ---Readers-Writers Scheduling Specifications \n One extremely common specification is that an actor must reply to each request it receives (a guarantee \nof service Variations of the readers-writers problem derive fromthat implies that the actor is starvation-free \nand thus free of deadlock). For serializes this is expressed in terms of events the desirability of imposing \nstronger scheduling specifications by simply requiring that for every SERIALIZER-REQUEST than simply \nthat the serialize must reply to requests that it event there is a corresponding SERIALIZER-REPLY event \nin receives. Note that readers do not interfere with one another the history. Similarly the resource \ncan be required to reply to if they executing in parallel in the protected resource. even are requests \nby specifying that for every RESOURCE-REQUEST Therefore allowing multiple readers into the resource in \nevent there is a corresponding RESOURCE-REPLY event in parallel can increase thruput. Several variations \nof scheduling the history. A serialize constructed using muiual-exclusion-2 is specifications that require \nmore parallelism will be presented below. In all of these implementations we will keep track of guaranteed \nto reply to requests provided that the resource it whether there are readers in the resource or there \nis a writer in encases is guaranteed to reply to requests. the resource by keeping a separate crowd for \nthe readers and a separate crowd for the writer (which will of course never have than the code for mutuaI-exclusion-2, \nbut that is largely due to The code for mutual-exclusion-1 looks slightly shorter more that one member). \nthe extra words that indicate the structure of mutual-exchtsion-2. In mutual-exclusion-1 the semaphore \nbookkeeping is explicit for The following invariants are relevant to understanding the message passing \nto and from the resource. In all of the implementations to be presented below: mutual-exclusion-2 the \nrequired bookkeeping is implicit in the structure of the language construct. readers is thecrowd of readers \nin the protected resource writer is the crowd of writers in theprotected resource It is well known that \nsemaphores can be implemented the size of the writer crowd is never greater than one the readers crowd \nand the writer crowd are neuer both using mutual exclusion. Therefore no power is lost by using nornempty \nat the same time serializes instead of semaphores. The fact that all of the above invariants are preserved \nwill be SECTION VII ---READERS-WRITERS PROBLEMS immediately evident from inspection of the code of all \nthe implementations given below. No complicated chain of reasoning will be required. This is an example \nof how VII.1 ---Readers-Writers Integrity Specification properties of a scheduler implemented using \nserializes can be seen with greater perspicuity than is possible from A readers-writers serialize is \nintended to protect the implementations using less structured arbitration primitives integrity of a resource \nby scheduling access to the resource in such as semaphores. such a way that it is impossible for two \nprocesses to overlap in their use of the resource if one of them is a writer. An event in which a message \nis received by the protected resource is called a RESOURCE-REQUEST, of which there are two VII.3 ---Writer \nExcludes Others speciai cases RESOURCE-READ and RESOURCE-WRITE. In response to these requests the protected \nresource will produce Let us introduce no new constraints beyond the primary responses which will be \ncalled RESOURCE. REPLY events. one of insisting that a writer has sole access to the resource. One possible \nimplementation that would satisfy those The integrity specification for a readers-writers serialize constraints \nis the one-at-a-time seriaiizer presented above. is that a write request excludes ail other requests \nfrom the Another implementation follows that would allow readers to resource . This integrity specification \ncan be expressed in access the resource in parallel. event terms as follows If SERIALIZER-WRITEi and \nSERIALIZER.REQUESTj are two requests received by the serialize then either RESOURCE-WRITEi --> RESOURCE. \nREPLYI -~> RESOURCE.REQUESTj --> RESOURCE-REPLYj or RESOURCE.REQUESTj --) RESOURCE-REPLYj --> RESOURCE-WRITEi \n--> RESOURCE-REPLYi  ((writer-exclude-others =the-resource) * ;O serialize which enforces that writers \nexcludes others ;from the resource is implemented by constructing (cofw-serializer ;ssserializcr which \nhas (queues: readers-q writers-q) ;tteo queues called readers-q and writers-q (crowds: readers writer) \n;Iseo croteds called readers and writer (entry: ;a f ter entry (cases ;there are two cases for the message \n(E> (read-using: ...) ;receive a request to read the information in the resource (enqueue readers-q ;enqueue \non the readers queue to (guarantee: (empty: writer)) ;guarantee that thero is no writer in the resource \n(then: ;when dequeued, (relay-te the-resource ;deliver the message to the resource (thru: readers))))) \n;passing thru the reade?s crowd (S> (write-using: ,..) ;receive a request to write in the resource [enqueue \nwriters-q ;ersqueue on the writers-q to (guarantee: (empty: readers writer)) ;guarantee that there are \nneither rersders nor a wn ter in the resource (then: ;when dequeued, (rehsy-to the-resource ;deliver \nthe message to the resource (thrsu writer))))))))) ;passing thru the writer crowd It is easy to see that \nthe above implementation guarantees that writers will exclude others from the resource since if there \nis an element in the writer crowd then all the queues of the serialize are blocked. However, the above \nimplementation does not satisfy the requirement that the serialize must always reply to requests which \nit receives since nothing forces the readers crowd to eventually become empty. If the readers crowd does \nnot empty then a writer could be stuck forever in the writers-q. Therefore the above implementation must \nbe refined or interpreted in some way in order to meet the specifications. VII.4 ---First Come First \nServed The implementation given below satisfies the specification that the protected resource is served \non a first come first served basis. In addition, starvation is not possible with the first-come-first-served \nserialize and a certain amount of parallelism is guaranteed. Note that the additional specification results \nin an implementation that is simpler than the previous one. ((first-come-first-served =the-resource) \n= ;a first came tirst served serialize of the resource which ;dispatches readers in parallel can be implemented \nby constructing (cons-serializer ;a serialize which has (queues: waiting-q) ;a queue called the waiting-q \n(crowds: readers writer) ;and twe crowd~ called readers and writer (entry: ;after entry (cases ;there \nare two cases for the memage (s> (read-using: ...) ;receive a request to read the resource (enqueue waiting-q \n;enqueue on the waiting queue to (guarantee: (empty: writer)) ;guarantee that there is no writer in the \nresource (then: ;when dequeued, (relay-to the-resource ;deliver the message to the resource (thrsx readers))))) \n;passing th~ the readers crowd (=> (write-using: ...) ;receive a request to write in the resource (enqueue \nwaiting-q ;enqueue on the waiting-q to (guarantee: (empty readers writer)) ;guarantee that there are \nneither readers nor a writer in the resource (then: ;when dequeued, (relay-to the-resource :deliver the \nmessage to the resource Wax writer])))))))) ;x$stng th~ [he ~~-ter crowd VH.4.b --Proof of Guaranteed \nParallelism VII.4.a ---Requiring Parallelism from the Serialize In the readers-writers problems there \nisa basic integrity constraint that the serialize must maintain, which is to ensure that a writer does \nnot have access to the resource at the same time as any other requestor. However, a simple one-at-a-time \napproach can easily guarantee this property. The more complex versions of the problem attempt to provide \nreaders with parallel access to the resource without starving the writers. When we say that some amount \nof parallelism is guaranteed, we mean that the specifications for the serialize require that certain \nreaders be given the opportunity to access the resource at the same time. The, serializer cannot guarantee \nthat the requests are actually processed in parallel, since either the structure of the resource or some \nexternally defined scfseduling policy may prevent actual parallelism. We say that readers Ri and Rj are \nparallel readers if -.> LEA VE.CROWDj and JOIN-CROWDj --> LEAVE-CROWDi JOIN-CROWDi The specifications \nfor the first-come-first-serve serialize include a requirement for parallelism. We can informally express \nthis requirement as saying that whenever one reader s entry into the serialize (an ENTRY event) immediately \nprecedes another reader s entry, and the second reader enters the serialize before the first reader enters \nthe resource (a JOIN-CROWD event), then these two readers must enter the resource in parallel. We can \nalso give a more formal specification in terms of events: If Ri and Rj are readers such that ENTRYi --> \nENTRYj --) JOIN-CROWDi and there is no requester Xk (a reader or writer) such that ENTRYi --> ENTRYk \n-> ENT Rl j then Ri and Rj must be paralkd readers, i.e. JOIN-CROWDi --> LEAVE-CROWDj and JOIN-CROWDj \n--> LEAVE-CROWDi Note that the above requirement would be the same if we required that the requestor \nXk be a writer, although the proof would be somewhat more difficsslt. A proof that the first-come-first-served \nserialize shown above satisfies the given parallelism requirement proceeds by assuming the existence \nof two readers with the given relationship, then showing that they must be parallel readers. Since we \nhave ENTRYi --> ENTRYj --> JOIN-CROWDi we know that the reader Ri must be in the waiting-q when the reader \nR. gains possession of the serialize. R must be JJ enqueued directly behind Rij since by our assumptions \nthere are no intervening entries to put other requesters in the waiting-q. Therefore when reader Ri does \nget into the resource through a JOIN-CROWD event (thereby releasing possession of the serialize), then \nthe requestor at the head of the waiting-q must be Rj and the condition of (empty: writers) must be true. \nWe then appeal to the axiom about priority of internal queues over external queues to argue that it must \nbe true that JOIN-CROWDj --> LEAVE-CROWDi ,, Since we know that JOIN-CROWDi --, JOIN-CROWDJ and JOIN-CROWDj \n--> LEAVE-CROWDj we conclude that JOIN-CROWDi --> LEAVE-CROWDj which completes the proof that Ri and \nRj are parallel readers. VII.5 ---Readers Priority The following serialize forces readers into the resource \nin parallel. However, we need to guard against starvation. Our approach is to allow all waiting readers \nto enter the resource, then to designate the writer which has been waiting as the new privileged writer, \nand keep further readers from entering the resource until the privileged writer has relayed its message \nto the resource. After the privileged writer has been served, then all readers which have been waiting \nfor that writer to finish are allowed to enter the resource, and a new privileged writer is chosen. A \nreader may not deliver a message to the resource while there is a privileged writer, or there is a writer \nin the resource. A writer may not enter the resource unless it is a privileged writer, and there are \nneither readers nor a writer in the resource. ((read-in-parallel =the-resource) s ;a serialize which \nenforces reading in parallel within ;the resource is implemented by constructing (con$-serializer ;a \nnen alizer which has (queues: readers-q writers-q) ;two queues called readers-q and writers-q (crawds: \nreaders writer) ;two crowds called readers and writer (entry: ;after entry (cases ;there are two cases \nfor the message (=> (read-using: ..,) ;receive a request to read the resource (enqueue readers-q ;enqueue \non the readers queue to (guarantee: (empty: writer)) ;guarantee that there area no writers in the resource \n(then: ;when dequeued, (relay-to the-resource ;deliver the message to the resource (thrw radars))))) \n;Passinir lhru 1he readers crowd (=> (write-using: ...) ;receive a request to torite in the resource \n(enqueue writers-q ;enqueue on the writers-q to (guarantee: (empty: readers-q writer)) ;guarantee that \nthe readers-q, and writer crowd are all empty (then: ;when dequeued, (enqueue readers-q ;enqueue on the \nreadera-q to (guarantee: (errtpt~ readers writer)) ;8uarantee that there ore netther readers ner a writer \nin f he resource (then: ;when dequeued, (relay-to the-resource ;deliver the message to the resource (thru: \nwriter))))))))))) ;rxssaistg thru the writer crowd The above implementation is a little more complicated \nthan the previous one. However, it is not difficult to show that writers exclude others using the technique \nused for the previous implementation. In order to show that neither readers or writers can possible starve, \nconsider the following partial order or the queues and crowds of the serialize~ Enter ng readers Enter \ni ng writers II I I v ~ wr i ters-q I / +----------+ +---------------+ ~ i (empty: readers-q writet-) \nI Vv readers-q II (empt~: readers) I I (empt~: readers writer) II + ---------\u00ad + +---------------+ I \nI / / I { v readers btr i ter Traffic Diagram for Queues and Crowds of read-in-parallel The idea of \nthe proof is to first show that the readers-q must eventually empty, then to show that any writer in \nthe writers-~ must eventually migrate to the readers-q. These two conditions ensure that every read or \nwrite request to the seriaiizer is eventually satisfied. 277 N Ri 8A R, are readers then VII.5.a Proof \nthat the Readers Queue Must Empty If there is a privileged writer inthereaders-q, then there is only \none such writer, and it must be at the head of the queue. A writer can only enter thereadors-q after \nit has been dequeuecl from the writers-q, and the guarantee of every writer exiting the writers-q is \nthat the readers-q is empty. Thus, not only is it true that there may be only one writer in the readers-q, \nthe writer must also beat the head of the queue If it is there. Processes may only enter the readers \ncrowd or the writer crowd by first exiting the readers-q. We have assumed that the-resource is correct \nin that every message sent to the resource will eventually produces single reply. Therefore, if a writer \nis at the head of the readers-q, it is guaranteed that no messages will be sent to,the-resource from \nthe serialize until both the readers crowd and the writer crowd are empty. By a similar argument, if \na reader isat the head of the readers-q, the writer crowd must eventually empty, which implies that a \nreader at the head of the readers-q must eventually exit the queue. Once a single reader is dequeued \nfrom the readers-q all readers in the readers-q in front of a writer must be dequeued. For any reader \nin the readers-q an event of the form ESTABLISHEDreader$.q must be followed by an event of the form JOIN-flROWDreader. \nFor every such JOIN-CROWD event, the serialize is released, and if the readers-q has a reader at its \nhead, that reader must be dequeued, since the reader-q is the only internal queue with its guaranteed \ncondition true (the writer crowd remains empty). Thus, we have showed that all readers must exit the \nreaders-q if they occur before a writer in that queue or if there is no writer in that queue. Further, \nif a writer is at the head of the readers-q then it also must exit the readers-q. Once a writer exits \nthe readers-q there may be no additional writers added to that queue until it is empty. Therefore, the \nreaders-q must empty. VH.5.b ---Proof That No Process in the writers-q Can Starve The idea behind this \nproof is simple. Any writer in the writers-q is waiting for both the writer crowd and the readers-q must \nempty. By our assumption about the resource there must be a RESOURCE-REPLY message for any writer, so \nthe writer crowd must empty. We have just proved above that the readers-q must empty. Therefore the process \nat the head of the writers-q must eventually be dequeued, which is sufficient to show that no process \nin the writers-q can starve. VII.5,C ---Required Parallelism for Reader s Priority The readers-priority \nserialize is intended to give more throughput to readers at the expense of writers, while still guaranteeing \nthat each write request will receive a reply. Our informal requirement is whenever one reader s entry \ninto the serialize follows another reader s entry (regardless of intervening serialize entries), and \nthe second reader enters the serialize before the first reader enters the resource, then the two readers \nenter the resource in parallel. In terms of events, this requirement can be expressed as ENTRYi --> ENTRYj \n--> JoIN.CRowDi impfkkthat Ri end Rj are parallel readera, i.e. JOIN-CROWDi --> LEAVE-CROWDj and JOIN-CROWDj \n--> LEAVE_CROWDi Note that the above requirement is stronger than the parallelism requirement given for \nfirst-come-first-served. All readers that have entered the serialize and not yet in the resource are \nin the readers-q, and the only writer that can be in the readers-q must be at the head of the queue. \nWe have previously shown that once one reader can leave the readers-q then all must leave the readers-q \nand enter the resource. We note that by the axiom of giving internal queues priority over external queues \nall readers in the readers-q must enter the resource before any reply from the resource will enter the \nserialize (through a LEAVE-CROWD event). This completes the proof. SECTION VIII -ANALYSIS of SERIALIZES \nVHL1 ---Properties Guaranteed by Serializes We would like to insure that every request sent to a serialize \neventually receives a reply. Unfortunately, the serialize mechanism can allow starvation to set in, so \nthis guarantee cannot be made in general. However, if the internal queues and crowds of a seriahzer can \nbe partially ordered then using a technique introduced in this paper it is relatively straightforward \nto prove that starvation is Impossible. To insure that the message that the serialize receives to be \npassed on to the protected actor is not altered in any way before it is given to the protected actor, \nwe need only verify that the message is inspected without changing it. Since the replies received from \nthe protected actor cannot be examined by the serialize, they are guaranteed to be passed through unaltered. \nVHI.2 ---Comparison with Monitors Serializes are generalizations of the secretary concept which was \nconceived by Dljkstra and later developed into monitors by Hansen, and Hoare. The purpose of serializes \nis to schedule access to shared resources in order to protect their integrity. Roughly speaking, serializes \nare analogous to monitors in the same way that actors are analogous to SIMULA-67 classes. A serialize \nis an actor that will allow only one process to be executing inside it at a time whereas a monitor is \na SIMULA-67 class that will allow only one process to be executing inside it at a time. A general principle \nof efficient operation that is applicable to both serializes and monitors is to try to keep the serialize \n[monitor] unlocked as much of the time as possible to keep it from being a bottleneck in the operation \nof a larger system. Serializes have some structural advantages over the monitor construct of Brinch-Hansen \nand Hoare. Serializes handle the scheduling of messages to be passed through to a protected resource \nm a modular fashion by allowing possession of the serialize to be released in order to relay the message \nto the protected resource. are ENDREAD and ENDWRITE m an implementation of a readers-writers problem \n(Hoare 1975). There is only one means to enter a serialize with a request to begiven tothe encapsulated \nresource. There isonly one means for a resource to reply to a message (which is independent of whether \nit has been called from a serialize or any other module). Using serlalizers theconditlon associated with \nanerr~ueue command is explicitly stated in the code of the implementation whereas the conditions used \nin the WAIT statement m a monitor are syntactic constructs which do not explicitly state what condition \nmust be guaranteed m order to proceed. A process which needs to wait forsornetondmon to be guaranteed \nbefore it proceeds explicitly states the condition in the serialize. In our experience this feature lessens \nthe number of internal queues and tends to. Mmphf y program proofs. Another difference is the use of \ncrowds rather than counters to keep track of processesthat have been allowed to access the encapsulated \nresource. While there is an additional cost associated with such accounting, we beheve that the benefits \nwill make the use of crowds a decided advantage. It is possible to examine the crowds to determine which \nprocesses are currently accessing which resources. We expect that this will have significant impact on \ndebugging programs that use parallel processes. Furthermore, if some process must be terminated externally, \nthen the resources it is accessing can be reclaimed its a modular fashion. Axioms about monitors and \nImplementation of monitors are both made more difficult by the necessity of having an urgent queue . \nProofs of programs using the SIGNAL statement are made more complicated by the necessity of considering \nthe possible effects of processes emerging from the urgent queue. Hoare states in his paper on monitors \nthat he considers it to be good practice to exit a monitor Immediately after a SIGNAL statement. We consider \nit to be a practice worthy of enforcement. All internal queues in a serialize are explicit, and explicit \nsignals do not occur. Rather, the conditions for emerging from aqueueare explicitly listed at the point \nof enqueuelng. SECTION IX ---CONCLUSIONS In this paper we have introduced a modular arbitration prvmitive \ncalled a serialize which is a generalization and improvement of the monitor construct previously developed \nby Brinch-Hansen and Hoare. Serializes aid in the synthesis of modular synchronizers because their structure \ncorresponds in a natural way to typical specifications for useful synchronizers. The structure Imposed \nby using serlalizers provides Important guarantees that aid in proving that the implementation meets \nits specifications. The specifications for a serlalizer include integrity specifications relating the \norder of access to the type of access, and scheduling specifications to ensure that differing types of \naccess occur in the proper order. Part of this ordering specification included a specification of requesters \nthat must enter the resource in parallel. In the readers-writers seriahzer, we gave the integrity specifications \nthat readers and writers were mutually exclusive in accessing the resource, and that at most one writer \ncould access the resource at a time. Our different solutions to the readers-writers problem resulted \nfrom different scheduling specifications. We have attempted to explicitly introduce facilities into serializes \nthat directly correspond to synchronization specifications. The constraint that the resource is not being \naccessed by either readers or writers when a writer enters is explicit in the code of our implementations, \nas is the requirement that no writers are accessing the resource when a reader enters. Serializes provide \nthat the condition for a waiting process to proceed is explicitly stated. In this way integrity specifications \ncan be dmctly expressed in the language. Scheduling specifications are more complicated, We have been \nable to use a specification language based on partial orders among events to good effect to express scheduling \nspecifications. Furthermore, the structure of the serializes has enabled us to give simple intuitive \nproofs that various scheduling specifications are satisfied by implementations that use serializes. The \nsimple specification that starvation is prohibited is common to almost all synchronization specifications. \nYet serializes at present make no such guarantee. At best serlalizers make It easier to prove that some \nImplementation always replies to requests which it receives. We feel that research should continue to \nsearch for mechanisms that provide effective guarantees of such properties, yet also provide sufficient \ngenerality to cope with a wide range of problems. The differences between monitors and serializes are \ngreatest where the resource is encapsulated, as in the reader-writers example. The differences are least \nwhere the resource is embedded in the serlalizer, as in the bounded buffer example. We believe that serializes \npromote modularity in their use of guarantees and the elimination of the SIGNAL statement. Further, they \nhave potential for use in robust systems in that more information is avadable for error recovery. SECTION \nX --ACKNOWLEDGEMENTS This paper builds on the work of Irene Greif who developed behavioral specifications \nfor all of the versions of the readers-writers problems given in this paper. Conversations with Ole-Johan \nDahl, E. W. Dljkstra, Tony Hoare, James H. Morris, and John Reynolds have helped us to crystallize our \nideas on these issues. Mark Laventhal made several useful suggestions that have materially improved the \ncontent of this paper. The concept of a serialize which we have developed over the last year owes a tremendous \nintellectual debt to the monitors developed by Brinch-Hansen and Hoare. We have attempted to constructively \nbuild on their work to develop better structured arbitration primltlve for actor systems. The development \nof serializes would not have been possible if monitors had not been previously developed. A very preliminary \nversion of this paper was presented at the ACM SIGCOMM-SIGOPS Interface Workshop on Interprocess Communication \nin March 1975. In December 1975 this paper was extensively revised to reflect improvements in serializes \nthat were in achieved in the PLASMA implementation meetings that fall in which Russ Atkinson, Mike Freiling, \nCarl Hewitt, Kenneth Kahn, Henry Lieberman, Marilyn McLennan, Ronald Pankiewicz, Brian Smith, and Aki \nYonezawa were active participants. These meetings resulted in substantial improvements in our understanding \nof modular arbitration mechanisms. Building on the work of Irene Greif, Aki Yonezawa has developed improved \nnotations for expressing contracts for the implementations in this paper. SECTION XI ---BIBLIOGRAPHY \n Dijkstra, E. W. Hierarchical Ordering of Sequential Processes Acts Informatica. 1971. Greif, I. Semantics \nof Communicating Parallel Processes MAC Technical Report TR-154. September 1975. Greif, I. and Hewitt, \nC. Actor Semantics of PLANNER-73 Proceedings of ACM SIGPLAN-SIGACT Conference. Palo Alto, California. \nJanuary, 1975. Hansen, P.B. Operating System Principles Prentice-Hall. 1973. Hewitt, C., Bishop P., and \nSteiger, R. A Universal Modular Actor Formalism for Artificial Intelligence IJCAI-73. Stanford, Calif. \nAug, 1973. pp. 235-245. Hewitt, C. and Smith, B. Towards a Programming Apprentice IEEE Transactions on \nSoftware Engineering. SE-I, 1. March 1975. pp. 26-45. Hewitt, C. Protection and Synchronization in Actor \nSystems ACM SIGCOMM-SIGOPS Interface Workshop on Interprocess Communication. March 24-25, 1975. Santa \nMonica, Calif. Hoare, C. A. R. Monitors An Operating System Structuring Concept CACM. October, 1975. \nHoward, J. H. Proving Monitors CACM. May, 1976. pp 273-278. \n\t\t\t", "proc_id": "512950", "abstract": "This paper presents a mechanism for the arbitration of parallel requests to shared resources. This mechanism is the serialize, which may be described as a kind of protection mechanism, in that it prevents improper orders of access to a protected resource. The mechanism is a generalization and improvement of the monitor mechanism of Brinch-Hansen and Hoare.Serializers attempt to systematize and abstract desirable structural features of synchronization control structure into a coherent language construct. They represent an improvement in the modularity of synchronization over monitors in several respects. Monitors synchronize requests by providing a pair of operations for each request type [examples are STARTREAD/ENDREAD and STARTWRITE/ENDWRITE for the readers-writers problems]. Such a pair of operations must be used in a certain order for the synchronization to work properly, yet nothing in the monitors construct enforces this use. Serializers incorporate this structural aspect of synchronization in a unified mechanism to guarantee proper check-in and check-out. In scheduling access to a protected resource, it is often desired to wait in a queue for a certain condition before it continues execution. Monitors require that a process waiting in a queue will remain dormant forever, unless another process explicitly signals to the dormant process that it should continue. Serializers improve the modularity of synchronization by providing that the condition for resuming execution must be explicitly stated when a process enters a queue making it it unnecessary for processes to signal other processes. Each process determines for itself the conditions required for its further execution.The behavior of a serializer is defined using the actor message-passing model of computation. Different versions of the \"readers-writers\" problems are used to illustrate how the structure of a serializer corresponds in a natural way to the structure of the arbitration problem to be solved. The correspondence makes it easier to synthesize a scheduler from behavioral specifications and to verify that an implementation satisfies its specifications.No claim is made for the \"completeness\" of the serializer mechanism, beyond showing that semaphores can be implemented using serializers. Further, no \"complete\" solution is proposed to the \"no-starvation\" specification which requires that a resource reply to each request which it receives. Rather, it is shown for some simple examples that serializers represent a step toward better structuring of parallel access to shared resources, and that proofs that starvation is impossible for these examples are easier with serializers than with some of the currently existing mechanisms for controlling parallel access to resources.", "authors": [{"name": "Russell Atkinson", "author_profile_id": "81100309892", "affiliation": "M.I.T. Room 527, Cambridge, Mass.", "person_id": "PP14113238", "email_address": "", "orcid_id": ""}, {"name": "Carl Hewitt", "author_profile_id": "81332503927", "affiliation": "M.I.T. Room 813, Cambridge, Mass.", "person_id": "PP43124513", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512975", "year": "1977", "article_id": "512975", "conference": "POPL", "title": "Synchronization in actor systems", "url": "http://dl.acm.org/citation.cfm?id=512975"}