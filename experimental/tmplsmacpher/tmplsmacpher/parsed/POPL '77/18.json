{"article_publication_date": "01-01-1977", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1977 ACM 0-12345-678-9 $5.00 STRUCTURING Eric C.R. Hehner University of Toronto Abstract: Structuring \ncan be defined inde-in the above. We give ourselves alao a handful of pendently of what ia being structured, \nand can be logical, numeric and comparison operators for applied profitably to more than one domain. \nforming expressions. Using one mechanism to structure both values and aeeignments, we obtain equivalents \nfor a variety Next, we give ourselves a simple assignment: of data and control structures. Structuring \nassignments ia preferable to structuring control: identifier := expression the former is more conducive \nto a mathematical style of programming while the latter ia more Note that the left side may not be an \narray conducive to tracing. element. (Declaration of variablea, though important, is irrelevant at present.) \nKey Worda and Phrases: language design, data structures, control atructurea, recursion. Finally, we give \nourselves a naming notation for values and assignments. For example, CR Category: 4.20. pi: 3.14 0. Introduction \nmeans that wherever pi aeeears, it will stand Programming languagea today have a variety for 3.14, and \nof data structures and control structures that are intended to be convenient for programming. -hcrement: \ni := i + 1 For example, PL/I provides character stringa (a structure of character), arraye, and the means \nthat wherever increment appears, it will structure (known in some languagee aa a atand for the assignment \n~ :-i + 1. To distin\u00ad record ) for structuring data, and if state-guish increment from a conventional \nlabel, we ments, definite (or indexed) iteration, in-emphasize that the above statement does not in\u00addefinite \niteration (the while loop), and of crement i, but only gives a name to the act of course, the go to for \nstructuring control. In incrementing i. each case, it is quite clear whether the construct is a data \nstructure or a control structure. TWO Our structure is simply a set of ordered assumptions are implicit: \nthat a variety of pairs. The first member of each pair is called structures servea us better than one, \nand that an index, the second an element, of the structure. structures are appropriate for data or for \ncontrol Indices are valuea. (It may seem appropriate to but not for both. This paper questions these \ntwo restrict the indices of a given structure to one asaumptiona. It suggests that a well-chosen type, \nor to a contiguous subrange of a type, but structuring mechanism, defined independently such restrictions \nare irrelevant to this paper.) of what is being structured, can provide the An expression of an index \nmay include variables, good things we now enjoy, while keeping the although our examples will use only \nconstants. number of basic language constructs to a minimum. The elements of a structure constitute that \nwhich We first exhibit one such mechanism, then diacuse is being structured; we shall consider structured \nits merits. valuea and structured assignments. 1. The Structure 2. Structured Values To begin with, we \nshall give ourselves come Define a map as a structure whose elements simple valuea: the two logical values \ntrue and are values. For example, the map false; numeric values such as 3 and 3.3E3; character values \nsuch as A ; and a facility for m= 1+11, 2+12, 3+13 D defining new simple values, such as red, blue and \ngreen, as in Paacal. Whether these values are has indices 1, 2 and 3, and elements 11, 12 and truly simple \nwi.ll not be debated; it is a con-13., A map is itself a value, and can be used in venient choice for \nthe moment. Character strings expressions, in assignments, or as indices or are not considered simple, \nand are not included elements. It may be given a name by the same notation used to give a simple value \na nama. If M is or denotea a map, and i is or denotes an index of M, then M[i] denotes an elemenf of \nM corresponding to index i (if this element ia to be unique, the indices must be unique). Other operations \non maps may be defined as deemed necessary; for example, if M is a map and i and e are values, then the \nexpression M with i-w denotes a map like M except that M[i] = e. Certain special cases of mapa deserve \nspecial notations. When the indices are the integers 1 to n, the notation may be abbreviated by listing \nonly the elements, in order of index, enclosed in angle brackets. The map of the previous paragraph may \nbe expressed as (11, 12, 13) This gives us a kind of array. If the elements are characters, e.g. ( A \n, B , C ), we may abbreviate further, e.g. ABC . This gives us character strings. The equivalent of records \n(or PL/I structures) are formed, not as an abbrev\u00adiation, but simply by using suitable programmer\u00addefined \nvalues as indices: ~ name + HEHNER , address + ~ citzj + TORONTO , country + CANADA Cl Cl It is convenient \nto group indices that have equal elements, so that 3,4,5+50 standa for three index-element pairs. In \nthis connection, and for arrays, the abbreviation n to m can stand for n, n+l,..., m whenever n and \nm denote appropriate values. By introducing a name for the index, we can express a group of elements \nin terms of their indices. BY specifying a range for the index (i.e. a domain for the map), we obtain \neither redundancy that is useful for checking that all indices are present, or the ability to specify \na restricted else; for example, ~i c(1 to 100) 3, 5, 17r+ 50, 11~ 20+i*2, else +OEI ia a sparae array \ncontaining thirteen non-zero and eighty-seven zero elements. The generaliza\u00adtion to maps with more than \none index (multi\u00addimensional arraya) is straightforward. In some cases, a -ompiler may represent a map \nas a sequence of pair~ of values; in other cases only the elements need storage. In still other casea, \nmaps may be compiled into code for comput\u00ading values from indices. As an example in which the lattar \nis suitable, consider the following re\u00adcursive definition of limited factorial. factoriaZ: mm n s (0 \n~ 99999) o +1, ~+ n*factoria2[n-1] D The reader may, at this point, feel drowned in notation. But he \nshould not feel drowned in concepts or language featurea. Differsnt pro\u00adgrammers will have different \ndata structuring requirements, and different notations and abbrevi\u00adations that seem convenient for their \npurposes. No programming language can hope to provide all such notationa, nor should it attempt to. Instead \nit should provide a general structure, and a mechanism for specializing it to an individual s needs, \nand for making convenient abbreviations. This paper doea not discuss such mechanisms. It suggesta that \nthe map can easily be specialized to provide a variety of programmers needs, while maintaining an economy \nof concepts within the pro\u00adgramming language. It also suggests certain specializations that seem needed \noften enough to deserve special notations within the language. 3. Structured Aasignmenta Define a group \nas a structure whose elemente are assignments. For example, =1+X:=11; 2+y :=12; 3+z:=13D A group is Ltself \nan assignment; it is executed by executing its elements in the order they are written.* (This may be \na slight abuse of the term assignment ; it is used here to mean a notation for associating some variablea \nwith some values, rather than exactly one variable with one value.) A group may be given a name by the \nsame notation used to give a simple assignment a name . If G is or denotes a group, and i is or de\u00adnotes \nan index of G, then G[i] denotes an element of G corresponding to index $. (Once again, if the element \nis to be unique, the indices must be unique. Without this restriction, we can build Dijkstra s guarded \ncommand sets [1] by using logical expressions as indices.) Thus one builds a group and selects elements \nfrom it the same way one builds and selects elements from a map. Most of the same abbrevia\u00ad tion are \nrelevant. When the indices are the integers 1 to n, or when we are uninterested in the indices~the elements \nmay simply be listed, giving us the usual do group . For example, the group of the previous paragraph \nmay be ex\u00adpressed as doZ := 11; Y := 12; z := 13 c1 *The alternative of executing elements in order of \nincreasing index was considered, but rejected for two reasons: we did not want to restrict the indices \nto be of an ordered type; the for con\u00ad struct for this alternative was more complicated. One alternative \nremains in contention: that groups should not be executed; a separate syntac\u00adtic construct ia then required \nfor sequencing. If G is a group, then G[i] is evidently a 4. Understanding Structured Assignments case \nstatement (either the Algol W kind, or the Pascal kind), for which a more familiar notation is When we \nread or write programs, we have case iofG As a further specialization, we introduce the no\u00ad tation \n~ ... ~ ... &#38; ... D to abbreviate a two-element group, whose indices are true and false, from which \nwe are selecting one ~he elements. For example, if b then x:=5 else y:=7D abbreviates group true + x \n:= 5; false+y := 7 Cl [b] Similarly, if . . . then . . . D abbreviates the special cas=when the false \nalternative is null. The else, which was so useful in the previous section for specifying sparse arrays, \nhas an analogous role in groups used as case statements. By introducing a name for the index and group \ning indices, we have a for construct. The nota\u00ad tion fori:l~3,5do s := s+i rJ merely abbreviates mic(ltQ3,5) \nlt&#38;3,5+s:=s+iu which in turn abbreviates =l+s:=.s+l; 2+5:=5+2; 3 +5 :=s+3; 5+s:=s+50 The generalization \nto more than one index, which in the previous section gave us multi\u00addimensional arrays, here gives us \nthe effect of nested ~ constructs, but written as a simple construct. Notice that the indices are not \nvariables, so no question of assignment involving indices within the construct is raised. Finally, the \nnotation while . . . do . . . Cl may be used to abbreviate a recursivel~defined group. For example, -i< \n10do i:=i+~D abbreviates a group, say G, defined as G:ifi <10 then i :=i+1; GO Ttaose who consider iteration \ncc. be simpler than recursion may, at this point, be unhappy. The next section is intended to change \nthe viewpoint of those people. always maintained a thinly disguised program counter or instruction pointer \n; we are always aware of the flow of control. For example, at the end of a loop we know that control \nor ex\u00adecution goes back to the beginning of the loop. We have no problem understanding the ~ to: execution \ncontinues at the indicated statement (understanding programs containing go tos is another matter). Recursive \nflow of control, in general, in\u00advolves a stack of return addressea, and so it is more complicated than \nlooping. In current pro\u00adgramming languages it ia further complicated by making it inseparable from procedures, \nwhich in\u00adtroduce a new local scope each invocation. In this paper, recursion was introduced independently \nof local scope; even so, defining a while loop by way of recursion may seem to be defining something \nsimple by way of something complex. A program should not be understood in terms of a particular implementation \nof a language, nor by tracing an execution of the program. These two premises are generally well accepted, \nand need no defense in this paper. Yet in almost every programming text, control structures are ex\u00adplained \nonly by explaining how to trace an execu\u00adtion according to some implementation. Selection (if or case) \nia usually explained by saying that c~trol jumps to one of the alternatives, and from there to the end \nof the construct. In this paper, the notation G[i] is aaid to denote an element of G. Apart from the \nsubtle change in attitude, the use of the word jump may sometimes be misleading. For example, with the \nconstant definition devices: 4 the structured assignment if devices c 10 then A else B El can be compiled \nsimply as A, giving conditional compilation without any new language feature. Reintroduced the for construct \nas an abbreviation for a sequence of~signments, rather than aa a loop . The important point is not the \nchange in terminology, but the change in thinking: from jumping control to structured assignments. One \ncould never invent a S@ to as a structured assign\u00ad ment. An explanation of recursion that involves activation \nrecords or return addresa stacks is irrelevant, confueing, and oftan wrong. The best implementation of \nthe recursive group in the previous section is exactly the same as the im\u00adplementation of the while construct \nthat abbreviates it[6]. The proper explanation of a recursive construct, or of a while construct, in\u00ad \nvolves the principle of mathematical induction[3]. It is sometimes objected that an average where the \nnotation exit Al means that we jump to person cannot be expected to understand the prin-the statement \nfollowing Al. The benefit of this ciple of induction, or to apply it to programming. construct is efficiency: \nwith only single-level If that were true, it would not be an argument exits, one needs to perform a test \nwithin Al, juet against the use of induction in programming, but prior to A3, to determine whether to \nexecute A3 against the use of average people as programmers. and continue Al, or to exit Al. The problem \nwith In fact, average people understand the principle this construct is a loss of clarity: an examina\u00adperfectly \nwell, although informally. Given a tion of Al would lead one to conclude wrongly positive integer, and \nenough time, an average that A2 and A3 are executed repeatedly until person believes he can count from \n1 to the given bl becomes false. integer. For large enough integers, that be\u00ad lief is not based on the \nexperience of having As structured assignments, rather than done so, but on an implicit understanding \nof structured control, loops and exits are unaccept\u00adthe principle of induction. able. The equivalent \nrecursive definitions are as follows. It is often easy to see that a recursive construct works for n \n= O, and that if it works Al: ~bl forn=k-1, it will work for n = k. The then A2 Cl common mistake is \nasking (or explaining) how it works for n -k -1. This mistake is made for one of two reasons: (a) failure \nto assume the in\u00adducive hypothesis; induction requires that we prove an implication, not the hypothesis \nof the implication. (b) curiosity about the implementa\u00adtion; an explanation of the ~mplementation should \nelse A3; come only after the semantics are understood, not Al O as an explanation of the semantics. For \neither reason, this mistake leads to an effort to The recursions may be implemented by simply branch\u00adunderstand \nby tracing, and to the poor man s ing to the appropriate label; we thus have the induction: If it works \nfor n = 1, 2 and 3, then efficiency of the deep exit without inventing a that s good enough for me. , \nnew language feature. And the condition under which A3 is executed is clear at a glance. The Mathematical \nsemantics refers to the loop-with-exit has the curious property that when characterization of programming \nlanguage state-there is more to be done,one says nothing,but when ments by their effect on program state \n(the there is no more to be done, one says something: mapping from variables to values). It has exit. \nThe recursive version is more straight\u00addeveloped as a technique for defining programming forward; when \nthere ia more to be done, one languages[9]. In this view, the time sequence specifies it, and when there \nis not, one says of events that occur during program execution is nothing. irrelevant: a statement is \na mathematical function from states to states. Unfortunately, 6. Uniform Referents may of the statements \nit has been used to characterize were designed to control execu- When programming, if one decides that \none tion. By structuring assignments, rather than needs to select a value from a class of values, control, \nwe are taking the view that is con\u00ad one can use the notation F[x] where F denotes sistent with mathematical \nsemantics. the clasa, and x ie used to select the desired element of F. One may then decide to implement \n5. Exits F either as a map, or, if one needs to intro\u00ad duce local names and variables and to use assign-The \nwhile loop, considered as a construct ments in the production of the desired value, as denoting repetitive \nexecution, has one exit: at a function (procedure that returns a value and its head. And that exit is \nonly a single\u00ad does not affect global variables). The notation level exit that cannot be used to terminate \nF[z] must not prejudice the choice of implemen\u00adexecution of several nested loops at once. tation of F. \nA change in the implementation Intermediate and deep exita have been proposed of F that does not change \nthe meaning of the in various forms; for arguments pro and con program, such as substituting a map for \na see [7]. Suppose Al is defined as function or vice versa, should not require changing the notations \ninvolving F throughout Al: while bl do the program. The above principle of language A2; design is (a \nversion of) the principle of A3 Cl uniform referents [8]. and action (assignment) A2 within Al is We \nnow have a new application for-thedefined as principle. If one decides that one needs to select an action \n(assignment) from a class of A2: wnile b2 do actions, one can give the class a name, say G, A4; and denote \nselecting the desired action by G[x]. if ~b3 This notation should allow G to be-implementedthen exit \nAl Cl; either as a group, giving us a case statement A5F implementation, or asa routine (procedure that \naffects global variables and does not return a value). 7. Conclusion The point of this paper is not the \nnota\u00adtions used to present the structuring mechanism; when the reader finds them awkward or un\u00adpleasant \nhe is invited to change them. Nor is the point the particular structuring mechanism chosen; it is not \nclaimed that the mechanism in this paper is adequate or suitable for all purposes. There are two resin \npoints. One is that structuring can be defined independently of what is being structured, and can then \nbe applied profitably to more than one domain. A well\u00adchoeen general structure that can be specialized \nin a variety of ways is preferable to the myriad of seemingly unrelated structures we now live with. \nThe other main point is that structuring assignments is preferable to structuring control. The former \nis more conducive to a mathematical style of program composition, while the latter is more conducive \nto tracing. Arguments in favour of structuring value= rath~r than storage have been presented elsewhere[2,4]. \nAcknowledgement I am indebted to Jim Horning, Nigel Horspool and Brian Clark for discussion and suggestions \nthat lead to this paper. References 1. Dijkstra, E.W. A Discipline of Programming. Prentice-Hall (1976). \n 2. Hehner, E.C.R. A simple view of variables and parameters. (to appear.) 3. Hoare, C.A.R. An axiomatic \nbasis for  computer programming. Comm. ACM 12(10) (October 1969). 4,. floare, C.A.R. Recursive data \nstructures. Report STAN-CS-73-400, Stanford University (1973). 5. Kieburtz, R.B. Programming without \npointer variables. ACM Conference on Data, Salt Lake City (March 1976). 6. Knuth, D.E. Structured programming \nwith  ~ to statements. ACM Computing Surveys, 6.4YDecember 1974). 7. Ledgard, H.F., Marcotty, M. A genealogY \nof control structures. Comm. ACM 18(11) (November 1975).  8. Ross, D.T. Uniform referents: an essential \nproperty for a software engineering language. in Tou, J.T. (cd.) Software Engineering, Academic Press \n(1970).  9. Scott, D. and Strachey, C. Towards a mathematical semantics for computer languages. J. Fox \n(cd.), Computers and Automata, John Wiley, pp. 19-46 (1972). \n\t\t\t", "proc_id": "512950", "abstract": "Structuring can be defined independently of what is being structured, and can be applied profitably to more than one domain. Using one mechanism to structure both values and assignments, we obtain equivalents for a variety of data and control structures. Structuring assignments is preferable to structuring control: the former is more conducive to a mathematical style of programming while the latter is more conducive to tracing.", "authors": [{"name": "Eric C. R. Hehner", "author_profile_id": "81452616535", "affiliation": "University of Toronto", "person_id": "PP39032654", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512969", "year": "1977", "article_id": "512969", "conference": "POPL", "title": "Structuring", "url": "http://dl.acm.org/citation.cfm?id=512969"}