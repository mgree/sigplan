{"article_publication_date": "01-01-1977", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1977 ACM 0-12345-678-9 $5.00 PARALLEL PROGRAM CORRECTNESS THROUGH REFINEMENT* Thomas W. Doeppnerr Jr. \nProgram in Computer Science Box F Brown University Providence, R.I. 02912 ABSTRACT: We develop a theory \nfor the correctness initially end is the address of a cell such of asynchronous parallel programs. A \nprogram is that next(end)=null considered correct if its behavior is in some sense private i similar \nto that of an abstract version of the pro gram. We discuss various criteria for this simil\u00ad next(end) \n+iarity. We then concentrate on one of them and next(i) + nulldevelop a technique for showing that a \nparallel end +i program is correct with respect to this criterion. + 1. INTRODUCTION Here i represents \nthe address of some data The benefits of a top-down approach to the cell, and next is a field within \nthe cell design of programs are well known (Dijkstra [2]). which takes on values that refer to other \nThe use of such techniques for the correctness of cells. sequential programs makes correctness proofs \nsim- Fiqure la . pler (Dijkstra [2], Gries [5], Infante and Monta nari [6], for example) . We will develop \nsome tech niques for using this approach for proving the cor\u00adinitially S=1 rectness of asynchronous parallel \nprograms. The correctness of parallel programs has been P: when S O studied in Keller [71, Lamport [91, \nand Owicki and do S + S-1 Gries [12]. Our approach bears some resemblance to that of Rosen [13]. His \nuse of the Church-Ros-next(end) + i ser property and equivalent states is similar to f the notions of \nconsistency that we develop, but he next(i) + null does not explicitly take advantage of program structure \n. Part of approach is also related to --i-\u00adthat of Lipton [11], although his emphasis is end + i bottom-up \nwhile ours is top-down . As the first step in the development of a par-v: s + S+l allel program, we envision \nan idealized version in which complex operations are assumed to be 3\u00ad performed in an indivisible manner. \nFor example, Figure lb. see Figure la. Here we have a program, called EQO, for appending item i to the \nend of a queue. Consider the program of Figure lb, which we Several processes may attempt to perform \nthis op- call EQ1. Here we have broken up the operation of eration simultaneously, so we present an ideal-appending \nitem i onto the queue into three opera\u00adized version in which the operation is assumed to tions, and have \nused Dijkstra s P and V operations be performed instantaneously. As far as correct-on the semaphore S \nto ensure that only one process ness is concerned, it is easy to verify that the can execute these operations \nduring any one period predicate next(end) =null is invariant, i.e. of time. The predicate next(end)=null \n, that was true for all reachable states. invariant in EQO, is no longer invariant, although intuitively \nthe two parallel programs are, at the As the next step in the development of a par\u00adleast, very similar. \nallel program, we break up sections of the program that were previously assumed to be indivisible There \nare two approaches to the correctness of into more reasonably s;zed pieces . That is, we EQ). The first \nis to modify the original predicate use operations that are closer to those that some so that it is invariant \nin EQ1. The other is to processor might actually perform instantaneously , weaken our criteria for correctness, \nso that we con\u00ad s<de~ a prog~arn to b-c-~~.ck --.=-;g tk-de=i=ea *This work was supported by the National \nScience predicate is not invariant. Foundation through grant G>-42627 and by Bell Lab \u00ad .. The first \napproach, although plausible, has a oratories, Murray Hill, N.J. while the author was the at Princeton \nUniversity. few difficulties associated with it. Modifying predicate so that it becomes invariant in \nthe expanded parallel program may be fairly difficult to do. Even if an invariant predicate can be found, \nits relation to the original predicate might not be clear. Since we are using a top-down approach tO \nthe design Of a program, the relation ship between the programs at different levels of abstraction should \nbe well-defined. Let us consider the second approach to the cor\u00adrectness of EO1. It is clear that the \npredicate next(end)=null is true for all reachable states in which no processes are between the P and \nV op erations. Hence EQ1 is actually simulating EQO in that the composite effect of transitions tl through \nt5 of EQI is exactly that of transition t Of EQO. If we can prove that, in some sense, the execution \nof EQ1 is guided by the execution of EQO, then the predicate that is invariant in EQO can be used as \na weaker indication of the correctness of EQ1. What we need then is a formal method of propagating the \ncorrectness of a program at one level to the programs at lower levels as we descend through the various \nlevels of abstraction. 2. MODEL AND NOTATION Our model of a parallel program is similar to that presented \nin Keller [7]. We present the model in a slightly different way, as we want to put more emphasis on the \nindividual processes. A parallel program (or system) is a 4-tuple <Q,V,II,L>. O is a possibly infinite \nset of states, V is a finite set of variable names, II is a poss ibly infinite set of processes, and \nZ is a finite set of transition names. Each state of Q is a vec\u00adtor, the components of which are named, \nnot neces\u00adsarily uniquely, by elements of V. Each process of ~ consists of a name m, and a partial function \npf IImapping Q into Q. Certain components of the state vector have unique names from V, and are referred \nto as shared variables . The remainder of the components do not have unique names, and are referred to \nas private variables . Each private variable can only be mod\u00ad ified by a unique pf, and hence is associated \nwith some particular process. We qualify references to private variables by appending the Process name \nin parentheses after the name of the variable. For example, if c is the name of a private variable, then \nthe particular variable named c that is accessible by process T is called c(m) . For any shared variable \nb or private variable c(n) , the value of the variable in state q is re\u00adferred to as q.b or q.c(m), respectively. \nAssociated with each process n is a private variable i(m) called the instruction pointer. This variable \ncan only take on values from a finite cet of place~. There is a natural way in which we can name the \nordered pairs of states that are related by the varibus pffs. We define a transition to be a set of ordered \npairs of states, each related by some pf, such that the values of instruction pointers are equal in all \nstates which are first in an order\u00aded pair, and are also equal in all states which are second in an ordered \npair. Each such transition is given a name from Z. We assume a one one corres\u00adpondence between all transitions \nand X, and hence consider Z to represent the set of all transitions. Each transition defines a relation \non the states . If t is a transition, and ql and q2 are two states related by t, we then write this as \nql Jq2 Only one of the instruction pointers can differ in value between the two states, as the transition \nrelation is a subset of the relation specified by some pf. If n is the process name associated with the \nparticular instruction pointer involved, then we say that n executed the transition t. If need be, we \nmodify our notation and explicitly mention IT as follows. tp ) ql q2 If ql and q2 are related by some \nunspecified transition we write ql + q2r i.e., + is the rela\u00adtion on QxQ which is the union of all the \npf s. Letting e denote the null transition, we write q 9 q for all states q. Ifr for all states q,, qq, \n~. and q 3 ql h2A q,$q, fOr XEE* and tcl, we then write If there exists an XEZ* such that q A ql $ clz. \nIf we need to specify to w+1~~ch 2 e r te parallel program we are referring, say Sj, we writer for example, \nWe will always specify some state, written as qO, to be the start state. If there exist states ql and \nq2 such that ql ~ q2, then we say that x is a valid transition sequence. If ql is the start state, then \nwe say that x is a valid initial trans\u00adition sequence. If there exists a valid transition sequence x \nsuch that ql ~ q2, then we say that q2 is reachable from ql, or just reachable if ql is the start state \nqo . Following Keller [7], we present a graphical interpretation of our model. We use a bipartite directed \ngraph, with one class of nodes, written as horizontal lines, representing transitions, and the other \nclass of nodes, written as circles, represen\u00adting places, i.e. the values of instruction poin\u00adters . \nSee Figure 2. place node ? +.l transition node v when P do F 6 Process n s instruction pointer has the \nvalue of the indicated place. Figure 2. There is an arc from a place a to transition t and from transition \nt to place b iff there exist two states ql and q2 such that ql $ q2, and in ql some instruction pointer \nhas the value a, while m q7 it has the value b. If there is an arc from one node to another, we say that \nthe fprmer is an input node of the latter, and the latter is an output node of the former. In any particular \nstate of a parallel program, the individual processes are thought of as dwelling at the place nodes representing \nthe values of their respective instruction pointers. We often attach to transition nodes information \nspecifying the rela\u00adtion that the transition represents. For example, for a predicate P and a function \nF we write When P do F to mean that if there is a process T dwell\u00adin~at the input place of the transition \nand P is true (when this is truer we say that T is enabled for the transition), then T may move so as \nto dwell at the output place of the transition, and at the same instant the state is further modified \nas specified by F. P is called the enabling predicate of the transition, and F is called the action func \ntion of the transition. See Figure 2. If the disjunction of the enabling predicates of the output transitions \nof a place is identically true, then the place is called a non-synchronizing place, and the output transitions \nare called non\u00adsynchronizing transitions. Otherwiser the place is called a synchronizing place, and the \noutput trans itions are called synchronizing transitions. We often include in our graphical model trans\u00adition \nnodes with no input places, representing cKeators of processes , called entrance transi\u00adtions, and include \ntransitions with no output places, representing annihilators of processes , called exit transitions. \nSee Figure 3. An en\u00adtrance transition is always enabled, and hence al\u00adlows the introduction of an unbounded \nnmnber of processes into the system. Exit transitions, when executed, effectively destroy a process. \nT L an entrance an exit transition transition Figure 3. These special transitions are not intended to \nincrease the power of the model. They are just a convenient shorthand. The creation of processes could \njust as well be represented by infinite pools of processes dwelling at certain places, just biding their \ntime until they are allowed to proceed, and destruction of processes could be han\u00addled in a similar fashion. \nA typical way of showing a parallel program to be correct is to prove that all reachable states satisfy \nsome predicate. Following Keller [7], we give the following definition. DEFINITION: Let <Q,V,H,~> be \na parallel program. A unary predicate J on Q is said to be q-invar\u00adiant if (W CQ) q~q ~J(q ). If q is \nomitted, then we mean qo-invariant. Prcving a predicate to be invariant can be very difficult, if done \ndirectly. It is most often easier, if one wants to prove J invariant, to prove a stronger version of \nJ to be inductive, as defined below (also following Keller [7]). DEFINITION: Let <Q,V,II,X> be a parallel \nprogram. A unary predicate K on Q is said to be -inductive if K(q)A(Wq1,q2@) (K(q1)Aql+q2) +K(q2) If \nq is omitted, then we mean qO-inductive. An important property of a parallel program is that of deadlock-freedom. \nFollowing Doeppner and Keller [4] , we formalize this property. DEFINITION: We say that a process n is \ndead in state q if n has not executed an exit tra~sition and there exists no state q such that q + q \nand T is enabled in q . We write this condition as dead~(q). DEFINITION: A parallel program is said to \nbe deadlock-free if for all processes IT, -deadm is qo-invariant. 3. EXPANSION When developing a parallel \nprogram, it is con\u00advenient at first to treat certain complex Opera\u00adtions as indivisible. When more detail \nis required, the complex operations can be split up into less complex, component operations, with the \nexecution of these components interleaved with the e~ecution of operations of other processes. We call \nthis expansion. For example, see Figure 4. In Figure 4ar we have two processes, with one process performing \ntwo additions in one step. In Figure 4b, we have ex\u00adpanded this complex operation, and introduced new \nvariables to control the execution of the expanded operation. Correctness of such expansions will be \nconsidered in the next section. In this section we formally explore the notion of expansion. initially \nx=y=O +IT +n 1 ? x + X+l ~+ X+1 y+X+y + ~ Figure 4a. +n o 2 when S=0 do X+ X+l +\u00ad y + X+y S*O % Figure \n4b. Let us consider a parallel program S i. We wish to refine transition t of Sir resulting in a new \nparallel program Si+l. We write this act of expan\u00adsion as si~>si+l. If t is understood or not important, \nwe omit the t. We call transition t the prototyp e of the expansion, and we call the process which contains \nt the expan\u00ad sion process. Let pl and p2 be the input and output plaCeS Of t, respectively. In the graphical \ninterpretation of sir there is a path from pl to P2 containin9 only one node, t. BY expanding Sir we \nreplace this single path with a subgraph, called the expansion subgraph Of Si+l, containing new place \nnodes called expansion places, and new transition nodes called expansion transitions. is formed from \nxi by replacing t with the expansion transitions . plis called the input place of the expansion subgraph, \nand p2 is called the output place of the expansion subgraph. i+l Referring to Figure 4, process 1 is \nthe expan sion process. Transition t of Figure 4a is the prototype of the expansion. It is replaced by \nthe subgraph that is shown in Figure 4b. We will find it necessaq to relate the transi\u00adtion names of \nthe expanded system to those of the unexpanded system. We define a homomorphism from the transition names \nof the expanded system to those of the unexpanded system. For non-expansion trans itions, the mapping \nis just the identity mapping. For expansion transitions, we will map all but one into the empty string, \nand the remaining transition will map into the prototype of the expansion. The choice of which one to \nmap into the prototype is somewhat arbitrary. We choose the last transition of an expansion sequencer \nmainly because in this way only complete expansion sequences will map into the prototype. More formally, \nwe define the homomorphism #i+l mapping Zi+l onto xi, where = s if s is not an expansion transi\u00adtion. \n= t if tn is an expansion transition, the output place of which is the out .. put place of the expansion \nsubgraph, and t is the prototype of the expan\u00adsion. Vi+l(ti) = e for all other expansion transi\u00adtions \ntit where e is the empty string. This mapping is illustrated in Figure 5. tl ui+l  expan\u00ad 1 sion t2 \nlli+l sub graph t3 Lli+l t lJi+l .    1 1 S2 v,1+1 2 i s. 1 Illustration of the mapping p i+l. \nFigure 5. We augment the state set of Si bY introducing new (non-instruction pointer) variables in the \nstate vectors, where these variables take on some set of values. Let Qi denote the state set of Si and \nQi+l denote the stiate set of Si+l. We define a Partial function ~i+l maPPin9 Qi+l Onto Qit where ~i+l(q) \nis the state q in Qi such that the ValUeS of each of the variables in q! are the same as those in q. \nrli+l is not defined when the expansion process s instruction pointer has the value of an expansion place. \nWe attach to the transition nodes replacing the expansion transition information specifying state relations, \ni.e. , enabling predi\u00adcates and action functions. we always use q. to denote the start state of a sys \ntern. Although this is somewhat ambiguous, the system of which q. is the start state should be clear \nfrom context. Other processes are also possibly modified by the addition of new variables, and the correspond\u00ading \npf s are extended over the larger domain. We restrict the modifictition of other processes so that if \nn is not the expansion process, then We call this restriction faithfulness. The expansion subgraph defines \na set of paths from pl to p2r which we wish to treat collectively. DEFINITION: The set of expansion sequences \nT of Si+l is the set of all transition sequences from paths from the input place to the output place \nof the expansion subgraph of Si+l that can appear as a subsequence of a valid transition sequence. We \nwant to ensure that in some sense expansion sequences mimic the operation performed by the prototype \ntransition. We make certain that this is the case when non-expansion transitions are not interleaved \nwith expansion transitions. DEFINITION: A set of expansion sequences T is said to be accurate if for \nall sequences l - - tn from T and all states ql and q2 from Qi+l l...tn t ql i+1 q~- i+l(q/ ~ i+l(q2) \nwhere t is the prototype transition (note that this definition only concerns the composite behavior of \nexpansion transitions; there is no mention of the effects of interleaved execution with transitions of \nother processes). We should contrast faithfulness with accurate expansions. Faithfulness is a restriction \non non\u00adexpansion transitions, while accuracy is a similar\u00adly motivated restriction on expansion transitions. \nAs accuracy seems to be the more difficult to ver\u00adify, we stress this difficulty in the remainder of \nour work by explicitly requiring an expansion to be accurate, while we implicitly assume it to be faith\u00adful \n. What we have described concerns only the refine\u00adment of a single transition, which we shall refer to \nas a single expansion. We are usually concerned with a sequence of expansions, i.e., S04)S1, 1+)s2,---/si_~+>si-We \nabbreviate our nota\u00adtion as SO~>S1~>S2~)...~~Sit and call such a sequence of expansions a multi-expansion, \nor sim\u00adply expansion. When referring to a multi-expansion, our use of the terms expansion process, prototype \ntransition, etc. should be interpreted as referring to the last expansion, i.e. S.,_l<)Si of the aforementioned \nmulti-expansion. We have now developed our idea of an expansion and presented a notation. The remainder \nof the paper mainly concerns what happens when the execu\u00adtion of non-expansion transitions is interleaved \nwith that of expansion transitions. 4. CONSISTENCY suppose that a system SO is correct , and SYS\u00adtem \nSi is the result of expanding SO. We want to develop criteria on the basis of which we can de\u00adcide whether \nthe correctness of Si can be inferred from the correctness of SO. The criteria which we discuss are based \non the notion of Si being able to simulate so. There are two parameters involved in this simu lation. \nVery roughly, the first parameter concerns what we want to be preserved by the expansion. We can use \nthe strict requirement that state reachability be preserved, i.e. that what is true in SO always be \ntrue in Si. We can also use the weaker requirement (assuming that SO @ judged cor\u00ad +n +11 12 rect because \na predicate W is inductive) that only read write W need be preserved.  CL o- The second parameter concerns \nhow closely Si should follow SO. Again we have two choices. The first is the strict requirement that \nSi can only deviate from SO when Si is executing expansion transitions. The second is the weaker requirement \nthat Si be allowed to stray from the path of SO, as long as it can always get back onto the path of s \no We first mention three intuitive ideas which we often desire to be incorporated as constraints in our \ncorrectness criteria. The first and third con\u00adstraints we always require. The second, because it is not \nessential to the proofs of later theorems, we present as an optional requirement. These ideas are similar \nin spirit to those of Lipton [10] in his definition of simulate . Our first constraint is that we want \nboth the unexpanded and expanded systems to be deadlock\u00adfree. If it is desired to have a process termin\u00adate \n, this can be accomplished by the use of an exit transition. The second constraint, which we often place \non a correct expansion, is what we call our bounded\u00adness constraints. We want to bound the amount of \ntime a process spends executing the expansion transitions , as opposed to just constraining a pro\u00adcess \nto spend a finite amount of time executing these transitions. The essence of the situation that we wish \nto avoid is expressed in Figure 6. If initially i=k=O +TI 1 ta: when i>k (?\u00ad v) tb: when i<k do i+i+l \n Figure 6. process 1 is the expansion process, and ta is an expansion transition, then ta will always \nbe able to be executed after a finite period of waiting, but this waiting period will increase without \nbound after each successive execution of t.. In a real system, such a situation would probsbly result \nin a continuing degradation of performance. Hence we usually warrt to ensure a bounded period of waiting. \nSimilarly, if process 2 is regarded as the ex\u00adpanSiOn process and tb an expansion transition, then after \neach successive execution of an expansion sequence containing ~, the expansion sequence will grow longer, \nwithout bound. Hence we usually want to bound the length of expansion sequences. The third constraint \nis the requirement that, in some sense, the expanded system can do every\u00adthing that the unexpanded system \ncan do. For ex\u00ad ~Ple/ consider the well-known reader-writer idealized reader-writer Figure 7a. +-n 2 \n / 7 bad solution to reader-writer problem Figure 7b. problem (Courtois et al. [1]). In Figure 7a, we \nhave an idealized solution to it. In Figure 7b, we have expanded the solution, but the expansion requires \nthat the readers and writers alternate. This we do not wish to consider correct, as the expanded system \nshould have at least as many de\u00ad grees of freedom as the unexpanded system. The following definitions \nare useful in relat\u00ading the states of the various systems. DEFINITION: We let ~~(q~ represent ~1(~2(...~k(q)) \n. ..)) if each of the n IS defined. i DEFINITION: A state q of Si is said to be conceip able in Sj for \ni>j, if ~ (rli(q)) . ..) is j+l(. .. li-l defined. Conceivability is an important concept and should \nbe emphasized. A state of Si is conceivable inS. if the instruction pointers of all processes take]on \nthe values of places that exist in Sj. In such states we can make direct comparisons of the two systems. \nOur correctness criteria will be based on reaching these conceivable states, and showing that certain \nproperties of the states of Sj also hold for the states of Si which are con\u00adceivable in S.. 1 Our first \ncorrectness criterion is fairly strict, and useful mainly in systems with trivial interaction among processes. \nReferring back to the parameters of simulation , we are using their strict values. That is, if So~).S~4~...4)Si, \nthen Si should always be capable of reaching a state conceivable in So, and that all reachable states \nof Si that are conceivable in So shOuld be such that their images under q? are reachable in S 1 0. This \ncorrectness criterion is diagramed in Figure 8. Circles represent states of Sir and solid circles represent \nstates that are conceivable in So. The wavy lines Xepresent transition sequen\u00ad ces, and the bracket means \nthat between states q, and qy, the system enters no state that is con ceivable in So. The interpretation \nof the diagram is then that if Si reaches a state (q2) that is not conceivable in So, then the next state \nreached that is conceivable in S will be reachable in S o 0. An example of an expansion that is correct \nunder this criterion is giv~n in Figure 9. The ex\u00adpanded system is effectively behaving exactly as the \nunexpanded system. o initially x=y=l ql O+IT1 + n 2 ~2 * + X+3 ~+ X+2  [1 y+y*x y+y+xq3{~eachable \nIn S -o + + W-consistency consistency unexpanded parallel program Figure 10. Figure 8. Figure 9a. +7 \n+Ti 1 Y ?2 initially j=clk=tl=tz=t+o when S>0 when S>0 do S+ S 1 do S+ S-1 +IT +Tr + * 1 2 tl + Clk \nr-3+ Clk tz + Clk+l clk + clk+l clk +clk+2 j+j+3 (j + j+3 unexpanded parallel program Figure ha. a consistent \nexpansion Figure 9b. +7T *IT In the following, ~. and xi denote the respec-tl + ~lk t3 + clk tive sets \nof transition names of So (the unexpan clk + clk+l clk + clk+l ded system) and Si (the expanded system). \nn is un-j + j+l j + j+3 derstood to be a natural number. ? denotes unde\u00ad fined . Rj(qo), the reachable \nset is defined to t2 + clk +1 (12 be clk + clk+l {qlqo ; q} j j+2 DEFINITION: An expansion Soj)Sl~)..._>Si \nis a j is a multiple of 3 -consistent expansion boundedly consistent if So,.sl, . . ..si are deadlock\u00adfree \nand Figure llb. (3n)(Wq~i(qo)) but not consistent is shown in Figure 11. Here W n;(q) # ? ~ n;(q)~Ro(qo) \nis the predicate j is a multiple of 3 . The ex\u00adpansion is clearly W-consistent, but it is not con n~(d \n= ?=) ((% @i) (sx~:n) (q f q An~(q)+?)) sistent since in the unexpanded system tl and t2 If we replace \n(3xcZ~n) with (3x~~) , then an will always have consecutive values, but in the ex expansion satisfying \nthe criterion IS said to be panded system this is not necessarily so. consistent. consistency and W-consistency \nboth require a Ordinarily, in an expansion we are not concern certain structuredness of an expansion. \nThat is, ed so much with preservation of reachability as the expanded system is only allowed to behave \nsig\u00adwith the preservation of some weaker predicate W. nificantly differently than the unexpanded system \nSo we weaken the first parameter of simulation . when it is executing an expansion sequence. That is, \nwe modify the consistency definition so This structure makes proofs of consistency and W\u00adthat it only \nneed be that W is true of reachable consistency relatively easy, as we shall see in the states that are \nconceivable in S next section. Howeverr we may still want to con\u00ad o sider some expansions to be correct \neven if they doDEFINITION: An expansion .so+%l+)...+)Si is not display this structure. boundedly W-consistent \nif ,...,Si are deadlock\u00ad O sl free and so we weaken the second parameter and strength\u00aden the first parameter \nof simulation. That is, we @n) (tiq @i (qo) ) weaken our first correctness criterion in another n;(q) \n# ?>W(q) way so that we do not require all reachable states of Si that are conceivable in S0 tO be reachable \nin so. What we require is that there always be reach- If we replace II(3XX:n) with (3xE Z*) , then an \nable a state from which direct simulation of So is expansion satisfyingxthe criterion i; said to be possible. \nW-consistent. DEFINITION: An eXpanSiOn so~~s~~~...~)si is W-consistency is diagramed in Figure 10. \nHere, boundedly semi consistent if SO,sl,. ..,sl are dead\u00adfrom any reachable skate of Si that is not \nconceiv-lock-free, and there exists an integer n such that able in So, the next state reached that is \nconceiv-for all reachable states q of Sir there is a valid ~le in So will be such that W is trUe. transition \nsequence XE~~n and a state q such that An example of an expansion that is W-consistent 1)+2 2) fl~(q \n) is reachable in S. initially i=j=k=O 1u 3) if V:(q ) ~ q , then there is a state qb in Si such tha% \nrl~(qb) S qa, and there is a transition sequence ysZ~n and a state q! such that qt ~ I b If we replace \nZ~n with Z? , then an exPmsion satisfying the criterion islsaid to be semi-consis tent. Semi-consistency \nis diagramed in Figure 12. Here, from any state of Si, there is reachable a state that is conceivable \nin S and reachable in o o In Figure 13, we have an example of a system that is semi consistent, but \nneither W consistent nor consistent. In all states reachable in the unexpanded system, i is a power of \ntwo. In the expanded system, there certainly are reachable states in which i is not a power of two. However, \nfrom any such state there is reachable a state in which i is a power of two. From this state, direct \nsimulation of the unexpanded system is possible. ql q2 [ reachable in So t semi-consistency Figure 12. \n0 initially i=l +T 1 i .+i*2 unexpanded parallel program Figure 13a. +Tr &#38;+IT    +1, 2 k- i+i+l \ni+i*2 k + k+l when i is a when i is not Y power of 2 &#38; a power of 2 W doi+i+l a semi-consistent \nexpansion Figure 13b. In certain cases, when w is inductive in SO, we can combine the previous two correctness \ncri\u00adteriar i.e. , we weaken both parameters of simula\u00ad tion. The combined criterion is that from any \nreachable state of Sir there is reachable a state which is conceivable in So, and in which the pre\u00addicate \nW is true. Presumably, this would mean then that from this state, direct simulation of SO is possible, \nand hence every time Si enters a state conceivable in SO, W would be true. Unfortunately, thi~ is not \nalways the case. Although So and Si may both be deadlock-free, it is possible that a state q of Si that \nis conceivable in S0 may be such that deadn(n~ (q)). +IT - m  1 (!-2 when k=O if i#j do i,j + i+l ~enk+l \n if k=l Gen i+j unexpanded parallel program Figure 14a. +Ir +n 1 D2 if k=l if i+j ~en irk + O ~enk+l \n&#38;\u00ad j + 1000 when k=O i + i+l j + j+l if k=l Ken i+j an undesirable expansion Figure 14b. For example, \nsee Figure 14. In the unexpanded system, the predicate i=j is clearly invariant. In the expanded system, \nit is possible for i and j to become unequal. Once this occurs, they will only again be equal when an \ninstruction pointer takes on the value of pl. But in such a state, k will be 1. This is clearly a deadlock \nsituation in the unexpan\u00added system. For the process to proceed in the ex\u00adpanded system, it must set \ni and j to unequal val\u00adlx?s . Such an expansion ,one surely does not want to consider correct. Because \nof this problem, we require the reacF,\u00ad ability of a state in Si which is such that it is conceivable \nin So, W is true, and in its image in So no process is dead. . DEFINITION: An expansion So~~Sl~)...~)Si \nis boundedly semi W-consistent if Si is deadlock free, W is inductive in S., and there exists an integer \nn such that for al.l reachable states q of Sir there is a valid transition sequence xc~$n and a state \nqf such that l)q;q 2) q is conceivable in SO 3) -deadn is 11~(q )-invariant in So for all processes \nn 4) if m~(q ) ~ qa, then there is a state qh in Si such that,; (qb? = qa and there is a transition \nsequence yE~~n such that q? ~ q b If we replace Z*r. with 1? , then an expansion satisfying the cr~terion \nislsaid to be semi W\u00ad~nsistent. Semi W-consistency is diagrammed in Figure 15. This is interpreted as, \nfrom any state that is reachable in S, , there is reachable a state that is 1 concentrate on consistency, \ndeveloping a method ! qo similar to that of Lipton. It is often convenient to view the component ql \n transitions of an expansion as one transition per\u00ad o forming some desired action, and a set of other \nq~ I W(q ) and -dead transitions performing actions that are more of a in 20 semi.-W-c0nsistency Figure \n15. + n 2 1 &#38; i*2 if i isnot a power of 2 then t+1 else; i. unexpanded parallel p roq ram Figure \n16a. + fr +11 1 i+i+l i+i*2  (l n  \\ a semi- i is a power of two -consistent expansion Fiaure 16b. \n not dead in SO , and such that W is true for th~ state. conceivable in S , An example of an expansion \nwhich is semi W\u00adconsistent but neither semi-consistent, W consis tent, nor consistent is given in Figure \n16. This is basically the same as the example of a semi con sistent expansion, but the setting of the \nvariable t whenever i is not a power of two prohibits the possibility of direct simulation. We have presented \nformalization of our intuit\u00adive ideas of how a correct expansion should behave. We summarize our criteria \nin Figure 17, where an expansion satisfying an upper criterion implies that it satisfies the lower criteria \n. consistent _----- \\consi5tent W consistent ~\u00ad semi-W-consistent summary of criteria Figure 17. 5. \nPROVING CONSISTENCY In his paper on reduction [11], Lipton discus\u00ad ses a technique which, in the terminology \nand con\u00adteXt Of our present work, is a method for proving an expansion to be consistent. We develop tech\u00adniques \nof a similar motivation for proving an ex pansion to be W-consistent. However, we first bookkeeping nature, \nnot really affecting the pro gress of other processes. The former transition we call the representative \nof the expansion, in that with respe-t to other processes, it embodies all that is important of the expansion \ntransitions. The usefulness of this idea is that it provides a simple method for proving an expansion \nto be con\u00adsistent. In developing this idea, we need the fol\u00adlowing definition. DEFINITIO!~: Let s be \na transition of a process different from the expansion process and tr an ex\u00adpansion transition. s is \nsaid to commute =round tr (in the expanded system) iff for each sequence ~t,...r tn> from the set of \nexpansion sequences T, all states q, and q2, and for each tiE<tl, . . . ,tn>, if ti precedes tr, then \ntis St. clo+q1~q2+ ql=q2 and if tr precedes tir then St, tis qo&#38;T1dq2 + q1~q2 Transition tr is said \nto be a representative of the expansion. In Figure 18, transition S1 commutes arO?nd t2, but S2 does \nnot. Here transitions tl, t2, and t3 are expansion transitions. + 11 2 S1: j+j+3 j+j+l 1 S2: j+3 j+j+l \n2: t3: j =j+l d example of commutativity Figure 18. Intuititively, transition s commutes around tr if \nthe execution of s is in no way affected by the execution of any of the transitions in the expan\u00adsion \nexcept tr. We nsed to make certain that a process cannot get stuck while executing expansion transitions, \n i.e., that the system can always reach a state which is conceivable in the unexpanded system. We formalize \nthis constraint below. DEFINITION: An expansion So is said to be S1 extendable if for each transition \nsequence x such . that q q , there exists a Y from ~f such that ql $q~ ~nd2q z is conceivable in SO. \n, We now combine our definitions into one, re\u00adsulting in a sufficient condition for consistency. DEFINITION: \nIf all transitions of all processes except the expansion process commute around trt foK some expansion \ntransition tr, and the expansion is accurate and extendahle, then the expansion is said to be interleavable. \n THEOPJ3M 1: If SO&#38;Jsl is an interleavable expan\u00ad sion, then the expansion is consistent. PROOF: \nWe want to show two things, which together imply that the expansion is consistent: 1) if S1 is a reachable \nstate that is not con\u00ad ceivable in SO, then after some finite number of transitions it will be in a \nstate that is conceiv\u00ad able in S0. 2) If S1 is in a reachable state that is con\u00adceivable in So, then \nthe image of this state under ill is reachable in So. ~Let x be any transition sequence such that qo \n+ ql. Since the expansion is interleavable, the transitions O;,X can be permuted into a sequen\u00adce xl \nso that q. + ql, and all transitions of Aeach expansion se uence in x are contiguous. s up\u00ad pose that \nql is not conceivable in SO. This means that the rightmost transitions of x are a proper prefix of an \nexpansion sequence. Since the expan\u00ad sion is extendable, x can be extended forming the transition sequence \nz = sty. It is now true that x Y o i g 11q2 where q2 is conceivable in So. Since the expan sion is accurate, \nit follows that VI(Z) nl(qo)-&#38;n1(q2) which proves the theorem. There are examples of the use of \nthe preceding idea in Lipton [11]. In particular, he shows (in the terminology and context of our present \nwork) that Dijkstra s P and V primitives, as used to im\u00adplement mutual exclusion, form consistent expan\u00adsions. \nWe now concentrate on proving an expansion to be W-consistent. We first consider the case of a single \nexpansion. Later, we generalize these re\u00adsults , allowing multi-expansions. Since interleavability implies \nconsistency, we weaken the idea of interleavability into something that implies W-consistency. Suppose \nthat when a transition sequence is permuted as in the definition of a transition cormnuting around tr, \nthe new se\u00adquence does not take the system into the same state as the previous sequence. But if the desired \npre\u00addicate W is still true in this new state, then we can still show the system to be W-consistent. We \npostulate a new set of transitions to account for the differences in states arising from permuting the \ntransition sequences. DEFINITION: For system Si, let L represent the set of all partial functions mapping \nQi into Qi such that for each iEL and each q@i, if Q(q) is defined, then W(q) ~ W(L(q)), and the value \nof each instruction pointer in q is the same as the corresponding instruction pointer in L(q) . We call \neach member of L a W-preserving residual. NOTE : Although not transitions in the sense that they are \nnot part of the parallel program, we will use W-preserving residuals as if they were part of the program. \nIn order to avoid confusion, if two states of Si are related by a transition sequence that contains W-preserving \nresiduals, we will write and say that x is a W-vzl.id transition sequence. We extend p: to map W-preserving \nresiduals into the empty strin$. DEFINITION: If there exists a W-valid transition sequence x such that \nwe say that ql is W-reachable. If a transition sequence of Si+l is such that whenever an expansion sequence \nis executed, the ex\u00adecution of the expansion sequence is not interrup\u00adted by the execution of any other \ntransitions, then this transition sequence is effectively mimicking a transition sequence of Si, with \nthe prototype transition replacing the expansion sequences. DEFINITION: A W-valid transition sequence \nx of s i+l is said to be performable in Si if it is the case that each occurrence of an expansion sequence \nin x is a substring of x. W-preserving residuals will be used for proving that W is true for states of \nan expanded system. Our general plan for showing an expansion to be W\u00adconsistent will be as follows. \nGiven any valid transition sequence of an expanded system leading to a state q that is conceivable in \nthe unexpanded system, we will show that there is another W-valid transition sequence leading to q, which \nis perform\u00adable in the unexpanded system. Assuming the expan\u00adsion to be accurate, and since W is inductive \nin the unexpanded system and W-preserving residuals do not falsify W, it will follow that W(q) must be \ntruer and hence the expansion is W-consistent. We now define a class of transition sequences which are \nequivalent, modulo W-preserving resi\u00adduals to transition sequences performable in S 0. DEFINITION: A \nvalid transition sequence X Of S1, such that ql ~ q2 where ql and q2 are conceivable in So, is said to \nbe W-compressible if there exists a W-valid transition sequence y such that ql~q2, and y is perfortile \nin S 0. We broaden our notion of extendable to ensure that in system Sit states conceivable in so are \nalways reachable by a finite number of transitions. DEFINITION: An expansion So~)Sl~) . . ..~)Si is said \nto be extendable to So if for each transition sequence x such that qO ~ q2, there exists a Y from is \nconceivable in S~~ such that ql ~ q2 and q2 0. If an expansion is extendable, then any valid transition \nsequence can be extended so that it takes the system into a state that is conceivable in the unexpanded \nsystem. We formalize this notion as follows. DEFINITION: Let So~)S1j)... ~}Si and let x be a transition \nsequence such that ql $ q2. To SO\u00ad extend x is to a end to x a transition sequence % Y~~~ so that ql \n~ q3 and q3 is conceivable in SO. We are now able to weaken our notion of inter\u00adleavability so that only \nthe predicate W need be preserved in an expansion. DEFINITION: An expansion So~%l is said to betj\u00ad interleavable \nif it is accurate, and each valid transition sequence of S1 starting from a state q such that q is conceivable \nin So and W(q) is true can be So-extended so that the result is W-compres\u00adsible. Related to our previous \ndefinition of a trans ition sequence comnuting around the prototype, we define what we call W-commute, \nin which we allow the insertion of W-preserving residuals to fix things x The result is a sufficient, \nbut not neces\u00adsary, condition for W-interleavability. UP . DEFINITION: Let s be a transition of a process \ndifferent from the expansion process, and let tr be an expansion transition occurring in all expansion \nsequences. s is said to W-commute around tr in S1 if 1) w is inductive in So, and Z) for each sequence \n<tl, . . ..tn> from the set of expansion sequences T, all states ql and q2 from 91 such that W(ql) is \ntruer and fOr each kc<tlr . ..rtn>. a) if tk precedes trr then . ..tks klsf,2t;. ..t! 1 1 . ~qz=ql-1 \n ql1 }q2 where <tip ..., t;> is a prefix of an expan\u00adsion sequence, and k and 9.are W-preserv 12 ing \nresiduals, b) if tw precedes t,., then L . St . ..t t . ..t.9.1si k k2 > C12= ql> ql1 1q2 . ..rt~> is \na suffix of an expan\u00ad here % sion sequence, and L and i are W-preserv\u00ad 12 ing residuals. ?2 +IT r :i \n+ i*3+i tl:i + i+l 1 :i+i+l 2 2:i+3 :i&#38;i+l 3 }i example of i is a multiple of 3 -commutativity Figure \n19. For an illustration of the definition of W\u00adcommutativity, see Figure 19. Here tl, t2, and t3 are \nan expansion sequence. If we let W be the predicate i is a multiple of 3 , then rl W-com\u00admutes around \neach of the expansion transitions, but r7 does not W-commute around any of them. s up\u00adpose <hat it is \nthought that rp W-commutes around Consider the transition sequence t1t2r2t3. ,.. j~.i = O in the Inltlal \ns;ate , -this will result in a state in which i = 4. If we now consider the sequence t1t2t3r2, as required \nby the definition, this will result in a state in which i = 3. what we need is a W-preserving residual \nk such that r 2 9. reSUlts in a state in which i = 4. But lt2t3 this is impossible, since 9. would then \nbe causing a change from a state in which k~ is true to a state in which W is false. W commutativity \nprovides us with a sufficient condition for W-interleavability. THEOREM 2. Let So#S1. If all transitions \nof processes other than the expansion process W-com\u00admute around tr, for some expansion transition tr, \nand the expansion is accurate and extendable, then the expansion is W-i~terleavable. PROOF : A straightforward \ninduction based on the definition of W-commute. We now proceed to show that W-interleavability provides \na sufficient condition for W-consistency. LEMMA 1: w is inductive in SO, and x If q1~q2, is performable \nin So, then if W(ql) then W(q2). PROQF : x is composed of 1) transitions that exist ~, 2) W-preserving \nresiduals, and 3) expansion transitions. In case 1), since we assume that W is inductive in S and by \nour faithfulness restriction on expansion t R at it follows then that W(qa) implies W(qb). In case 2), \nthe truth of W is preserved by definition of W preserving residuals. Case 3) follows from the assumption \nthat the expansion is accurate and the argument of case 1) . THEOREM 3: If expansion So~>S is W-interleav\u00adable, \nthen the expansion is &#38;-cor+sistent. PROOF : Let ql~l be such that W(ql) is true. Suppose that cll \n$ c12r where yEX~. Since the ex\u00adpansion is extendable, y can be extended into a valid transition sequence \nx = yz such that z llq2iq3 and q3 is conceivable in Si. By the definition of W-interleavability, x is \nW-compressible and hence they exists an x performable in So such that By lemma 1 we have that W(ql) implies \nw(q3) . Since we assume that W is true for the in\u00aditial state, the theorem follows. ql ~q3. Let us consider \nsome system, say So, in which the predicate W is inductive. If we expand So by a W-interleavable expansion, \nthen we have a W-consis\u00adtent expansion, resulting in S~. Now suppose that we continue to expand, creating \nsystems S2,S3,. . . . by W-consistent expansions. In order to show that the expansion So~}S1~). . . ~)Si \nis W-consistent, we would like to make use of the knowledge that the transitions of Si are either transitions \nof so, or expansion transitions. Given a state q~ Of S1, We wish there to be a valid transition sequence \nx such that q, ~ q. and q. is conceivable in SO. Using the id~a~ o? W-co&#38;utativity, we then show \nthat since W is inductive in SO, W(q2) must be true in Si. In the definition of W-compressibler we were \nonly concerned about single expansions. Now we are concerned about multi-expansions, and need to make \ncertain that W preserving residuals are not inter\u00adleaved with expansion transitions of any system of \nthe sequence, as they are only useful when applied to states that are conceivable in SO. We first broaden \nour definition of performable. DEFINITIOIJ: Let So-)S1~9. ..d)Si. A transi\u00adtion sequence x of i is performable \nin S0 if x is performable in Si_~/ ~i(x) is performable in Si_2, Pi-l(Pi(~)) is performable in S. 1 \n3 u2(P3(.. .(!Ji(x)) . ..)) is performable in So. We broaden our definition of W-compressibility to account \nfor multi expansions. DEFINITION: A valid transition sequence xxof Sir where So~)Sl~)... ~~i, such that \nql ~q2 where q and q2 are conceivable in So, is .sSid to be (3,W) compressible if there exists a transition \nsequence y = Q uP. such that 12 1) u is from Z:, 2) LI and !,2 are W-preserving residuals, 3) SI&#38;%12, \n4) y IS performable in SO. DEFINITION: An expansion is said to be (O,W) interleavable if it is accurate, \nand each valid transition sequence starting from a state q such that q is conceivable in SO and W(q) \nis true can be So-extended so that the result is (O,W)-compres\u00ad sible. In order to make use of the idea \nof W-commut\u00adativity in our new context, we need to choose the W-preserving residuals from a slightly \nrestricted class. We will only want to apply W-preserving residuals to states that are conceivable in \nSo, because only in these states will we know that W is true. So we will use those W-preserving resi\u00adduals \nwhose locations in a transition sequence can always be changed so that they only occur when the system \nis in a proper state. DEFINITIOIJ: Let SO~)S1~).. .~l. A W-pre\u00adserving residual L is said to be O-preadjusting \nin Si if for all states ql and q2 of Qi, where ql is conceivable in So and W(ql) is true, if Cll+ q2 \n where x is from X*, then there exists a W-preserv ing residual Q1 aid a y from Z! such that .L1y cl= \nq2 A W preserving residual L is said to be O-postad\u00adjusting in Si if for all states ql, q2, and q3 Of \nQi, where ql and q3 are conceivable in s and o W(ql) is true * Lx q*q2~ q3  where x is from Z;, then \nthere exists a W-preserv\u00ading residual L1 and a y from Z; such that C12>Y.I.+. q3 i  Using these restricted \nW-preserving residuals, we extend our definition of W-commute. DEFINITION: Let s be a transition of a \nprocess different from the expansion process, and let tr be an expansion transition occurring in all \nexpan\u00adsion sequences. s is said to (O,W) commute around tr inSiif 1) W is inductive in So, and 2) for \neach sequence <tl, . . . ,tn> from the set of expansion sequences T, all states ql and q2 from Qi such \nthat ql is W-reachable, and for each t@<t, ,...,tm>, ,. af recedes t then if tkP r . ..tns kst . ..t \n1 lj ) q2+ ?lI> 1i iq2 where <tj,, . . . , t!> is a prefix of an expan\u00ad sion sequence, and L is a O-preadjusting \nW-preserving residual in Si_l, b) if t~ precedes tk, then Gt . ..t -t . ..t s9. k km Cll %2=%1) ~ > q2 \nwhere <t;,...,<> is a suf;ix of an expan\u00adsion sequence, and i is an O-postadjusting W-preserving residual \nin Si_l. (O,W)-commutativity provides us with a suf\u00ad ficient condition for (O,W)-interleavability. \nTHEOFU3M 4: +). . . IS (O, -+xi. expansion, ~jSi_l e so+)si+) .a )-lnterleavable lfsO*% and all transitions \nof processes other than the ex\u00adpansion process of Si (O,W)-comnute around tr, for some expansion transition \ntr, and the expansion (So+kl+.. . ~)Si) is accurate and extendable to S0, then the expansion is (O,W)-interleavable. \nPROOF: A straightforward induction based on the definition of (O,W)-conunute. Finally, we show that (O,W)-interleavability \nis a sufficient condition for W-consistency. THEOREM 5: If W is inductive in So, and So~}Sl +). . . 4}Si \nis an (O,W)-interleavable expansion, then the expansion is W-consistent. PROOF : Consider a state ql \nof Si such that W(ql) is true. Let y be any valid transition sequence such that ql ~ q2. Since the expansion \nis (O,W)-inter\u00adleavable, y can be So extended to a valid transition sequence x = yz, such that q1:q2:q3 \n where q3 is conceivable in So, and zEZf. We now proceed by induction on i. The basis, i = 1, is theorem \n3. For the induction step, by definition of (O,W)-interleavability, x is (O,W) -compressible and hence \nthere are exists an x performable in So of the form Qluk2 such that Q2 1 q ~y q; ~ q~~q~  Here L1 and \n!,2 are W-preserving residuals, and u is from Z*By the restriction that 1. r 5 lli(ql) i:l ni(c12) ql \n1q2 (faithfulness) and the assumption that the expansion is accurate, we have that y q a i-1 b where \nqa = ~i(qi) and qb = ~i(q$). From the induc\u00adtion hypothesis, we know that W(qa) lmplleS W(qb). The theorem \nthen follows since we know that %1 and k2 do not falsify W. We have presented a method of attacking the \nproblem of proving the correctness of a system in\u00advolving complicated interaction among the processes. \nSimply stated, our method is to show that the in\u00adteraction of processes can be ignored, thereby re\u00adducing \na system with much interaction between pro\u00adcesses to a simpler system with little interaction between \nprocesses. In the next section we illus\u00adtrate our ideas with an example. 6. EXAMPLE -PARALLEL GARBAGE \nCOLLECTION In this section we use the theory which we have derived to develop and prove correct a program \nfor parallel garbage collection. The program is basic\u00adally that of Dijkstra et al. [4], although the \ncor\u00adrectness proof is ours. What we envision is a LISP-like environment, with one process, called the \nmutator, performing basic LISP operations, i.e. manipulating a set of cells representing a graph structure, \nand another process, called the collector, performing garbage collection. The two processes will execute \nin par allel, with a minimal amount of interaction . In particular, there will be no synchronizing places \n(i.e., neither process will ever have to wait for the other). The variables used by the program include \na root 1 root 2 finite set of cells. Each cell consists of three parts -a color and two pointers which \nwill refer-collector ence other cells. The two cells so referenced are / called the left son and the \nright son. A subset (Y of these cells is designated to be roots; they are cell a always accessible by \nthe two processes. Another cell is specialized to be the head of the free-Figure 21a. list. The free-list \nis a list of garbage cells. A cell is termed garbage if it is not on a path root 1 root 2 from a root. \nIt is termed mutatable otherwise. The collector process determines which cells are collector garbage, \nand then places these garbage cells on the free-list. The mutator process may take cells cell a off the \nfree-list, and make them sons of mutatable cells. For more details, see Dijkstra et al. [4]. Figure 21b. \nm: perform basic LISP operation ~t< shade all toots gray; G~true; : when G=true 2 mark non-garbage \ncells do G~~; &#38; t: 9 P do i~l to # cells c: collect garbage : af celfli)-is gray + then do;  \n(1? 1. shade left son gray GC (if any); o shade right son gray Figure 20. (if anv): color cell(i) black; \nInitially we consider the program of Figure 20, G~true; which we designate GCO. The mutator process is \nC?@; conceptualized as one transition and one place. The transition will be thought of as performing \nsome basic LISP operation. The expansion subgraph of GCo~)GC1. This replaces transition t of GCO tO fOrm \nGC1. The collector process is conceptualized as two transitions, representing a marking and a collect-Figure \n22. ing phase, and two places. All cells are assumed to be initially white. The first transition col-Q \nors all non-garbage cells black. The second trans-+ . ;+n ition then places all white (i.e. garbage) \ncells on the free-list, and resets the black cells to . .. A. .,, ..G--ti white. T+i+ l \\ We first sketch \nthe expansions to GCO; then we ~: -cell(i) tc: when cell(i) is graywill prove them to be W-consistentr \nfor a W yet to is not gray be presented. ft The first step is to expand the marking shade left son gray \nphase of the collector. As is mentioned in Dijk\u00ad (if any) stra et al. [4], it is necessary to specify \nsome overhead on the part of the mutator. The reason shade right son gra>, for this is shown in Figure \n21 (from [4]). In (if any) Figure 21a, root 2 points to cell a, and the col\u00adlector is examining root \n1 to see if it has color cell(i) black any sons, which it does not. Nextr as shown in Figure 21b, the \ncollector examines root 2 to see G+true if it has any sons. But in the meantime the muta tor has modified \nthe graph structure of the set of The expansion subgraph of GC1-)GC2. cells, and now root 1 points to \ncell a, but root 2 does not. The collector sees that root 2 does Figure 23. not have any sons, and incorrectly \nassumes that cell a is garbage. synonymous with to make a cell at least gray , means In order to avoid \nthis problem, we introduce if the cell is white then color it gray; else do nothing; an intermediate \ncolor for a cell -gray. The mutator, at the same instant that it establishes a pointer to a cell, makes \nthe cell at least gray , It is not difficult to verify that the expan\u00adto use the term of Dijkstra et \nal. [4]. sion is accurate. We prove later that it is W-con\u00ad sistent as well. The details of the first \nexpansion are shown in Figure 22. Here, to shade a cell gray , The marking phase is further expanded \nin Figure 23. Now we come to the expansion of the mutator transition. We will ignore one detail -that \nof one process adding cells to the free-list while the other process removes them. This is an in\u00adstance \nof the producer-consumer problem, which has been treated by several authors (see Dijkstra [2], for example). \nThere is one detail associated with the free list that we do consider, however. This is the problem of \nhow to handle a cell during the period from when it is taken off the free-list to when it is made the \nson Of some mutatable cell. We solve this problem differently from as was done in Dijk\u00adstra et al. [4], \nwhere an elegant solution is pre\u00adsented to both this problem and the producer con sumer problem, but \nis not proven correct. We have the mutator mark any cell that is about to be made the son of some other \ncell. This mark cannot be erased by the collector, and a marked cell, even if the cell is white, is not \ntreated as garbage in the collection phase. The details of the expansion are shown in Figure 24. The \nfinal expansion of the collecting phase, shown in Figure 25, is straightforward. let c1 be a mutatable \ncell 1 : let C2 be either a mutatable cell or a cell from the free\u00adlist mark C2 m : set c Is right or \nleft son to 21 be C2 : Shade C2 gray 3 m : unmark c 4 2 The expansion subgraph of GC2~)GC3. Each cell \nhas been given a mark field. To mark a cell means to set the field to 1, to unmark it means to set the \nfield to O. Transition c (the collection phase) is modified to read place all cells that are white and \nunmarked on free-list . Figure 24. 0 when cell(i) is white A not marked V marked I I do color do place \ncell(i) . cell(i) white 1 on free list \\ The expansion subgraph of GC3.&#38;)GC4. Figure 25. We now \nconcentrate on proving the parallel garbage collection program to be correct. GCO is rewritten in Figure \n26 with more detail, but each m: let c1 be a mutatable cell. let C2 be either a mutatable cell or a cell \nfrom the free-list. set cl s right or left son to be C2, and shade C2 gray. t: shade all roots gray \nG+true ; do while (G); G+false; do i+l to # cells; - If cell(i) is gray then do; ~hade left son gray \n(if any) shade right son gray (if any) color cell(i) black; G+=; *; end; end; P c: place all white cells \non free-list; color all cells white; GC with more detail. o Figure 26. transition is still thought \nof as being indivisible. We write black&#38;white to mean that no cell col\u00adored black has as either a \nright son or a left son a cell colored white, and similarly for gray ~ white . We assume that in the \ninitial state, all cells are colored white, and all cells except the roots are on the free list. The \nfollowing predic\u00adates are easily shown to be inductive in GCO. 1) black~white 2) i (collector) = p~ all \nroots are colored black 3) i(collector) = p= gray~white The conjunction of the three predicates, which \nwe call W, implies that when the collector is at p, any white cell is garbage; however, they do not im\u00adply \nthat all garbage cells are white. We will modify GCO by a series of four expan\u00adsions that are W consistent. \nFor the resulting system, GC4, we will show that since the predicates are GCO-inductiver there will always \nexist a reach\u00adable state in which the collector is at p and all and only all garbage cells are white. \nThe first expansion is shown in Figure 22. The key idea in showing that this expansion is W-inter\u00adleavable \nis that if one considers a proper prefix of any expansion sequence, the composite effect of the expansion \ntransitions, disregarding their eff\u00adect on the collector~s instruction pointer, is that of a W-preserving \nresidual. This is easily verified by observing that the only predicate affected is black~white . No cell \nis colored white in an expansion sequence, and a cell is colored black only if (simultaneously) its sons \nare shaded gray. (We note that in the above we are only considering the collector process, and hence \ncan treat it as a se\u00adquential program, allowing us to examine the com\u00adposite effect of expansion transitions.) \nIt follows that m, the mutator transition, W\u00adcommutes around the last occurrence of t3 in any expansion \nsequencer i.e. tl(t2t3)nm !,lmtl > q~~q$ GC q2 1 GCl 1 and t1t2 (t3t2)nm 9. mt t 392*ql) 2 &#38;2>q2. \nql GC 1 where n is a nonnegative integer, ~1 is a W-Preser\u00adving residual whose effect is that of (t2t3)n \nres\u00adtricted to non-instruction pointer variables, and 9.2 is a W-preserving residual whose effect is \nthat of (t~tz) n restricted to non-instruction pointer variables. The expansion is clearly accurate and \nextendable; hence by theorems 2 and 3 it is W\u00adconsistent. The second expansion, resulting in GC2, is \nshown in Figure 23. We want to show this expansion to be (O,W)-interleavable, as W is not inductive in \nGC1. We first show the expansion to be W-interleav\u00adable, i.e., if t . . . m...tn. .tn a ( c-he 0ri9inal \nsequence) ql GC )q2 2 then there exist W-preserving residuals 11 and 12 such that ilta. ..tirmnl12 }q2 \n(the modified sequence) ql) GC 2 In order to show this, we need to determine the effect of moving the \nmutator transitions to the end of the expansion sequence. Any particular cell is either unaffected by \nthe action of the occur rences of m or its components are changed in some way. The effect of an occurrence \nof m is either to change the value of one of a cell s pointers or to shade a cell gray. We call the execution \nof either transition tc or th visiting cell(i). If a cell is shaded gray by an occurrence of m before \nit is visited, then that cell will eventually be colored black and its sons shaded gray. In the modified \nsequence, the same effect can be achieved by having kl shade the cell gray. If the cell is shaded gray \nby an oc\u00adcurrence of m after it is visited, then this shad\u00ading will not cause other cells to be shaded \nby a transition of the expansion sequence. Hence in the modified sequence the effect can be achieved \nby having L2 shade the cell gray. The modification of a pointer by m has two effects on a cell. The previous \ntarget of the pointer is disowned , i.e. it becomes no longer a son of the changed cell. The new target \nof the pointer is adopted , i.e. it becomes a son of the changed cell. The effect of delaying the adoption \nof a cell is the same as the effect of delaying Ehe shading of a cell, which we have alyeady di~ cussed. \nBy delaying the disowning of a cell, we may be causing that cell (and its descendants) to be shaded when \nthey were not shaded in the original sequence. we cannot account for this in i2, as this would require \ncells to be colored white, which would be difficult to show to be W-preserving. Instead we have 9, c \nnange any pointer that is mod\u00adified by an occur~ence of m to null. (This is permissible, as the actions \nof m are not predicated on the previous value of a pointer. It may be that in practice the previous value \nof a pointer is im\u00adportant for the execution of the mutator, but this value is not important in establishing \nthe correct\u00adness of the garbage collection scheme.) The effects of this early disowning of a cell can \nthen be han\u00addled by shading appropriate cells, as was previously discussed. We now consider whether Ql \nand ~2, as we have defined them, really are W-preserving residuals. That is, if W is true for some state, \nis W true in the state which is the image under L1 or !2? The only action of Q2 is to shade some set \nOf states gray. As the mutator s instruction pointer does not reference P, this will clearly preserve \nW. L1 will shed? some set of cells gray, and will also set some set of pointers to null. Again, it is \nclear that neither of these actions will falsify W. That the expansion is accurate and extendable is \neasily verifiable. Hence we have that it is W\u00adinterleavable. But we need to show that it is (O,W)-interleavable. \nThis can be ascertained by the arguments which showed that the first expansion was W-interleavable, i.e., \na proper prefix of an expansion sequence is effectively a W-preserving residual. we now expand the mutatorr \nresulting in GC3, as shown in Figure 24. We will show that all transi\u00adtions (O,W)-commute around m2. \nActually, all transitions except c, the collec\u00adtion transition, commute around m2. If c occurs immediately \nbefore m3, the result is that the cell being shaded by the mutator at m3 will end UP shaded, but if c \noccurs after m3, the result is that the cell will end up white. This can clearly be accoun\u00adted for by \na W-preserving residual % after c that shades the appropriate cell gray. It is trivial to verify that \nthe other transi tions corranute around m2. Hence we have that each collector transition W commutes around \nm2. The ex\u00adpansion is certainly accurate and expendable; hence it is W-interleavable. Howeverr we still \nneed to show it to be (O,W)-interleavable. We do this by showing that the W-preserving residual E used \nin the expansion, i.e. shading a cell gray, is O-postad\u00adjusting in GC2. That is, we must show that if \nk occurs in a state not conceivable in GCO, then we can remove i and replace it with a W-preserving residual \nit, situated so that 9. will occur when tie system is in a state conceivable in GCO. Since the transition \nc and the prototype m of our current expansion exist in GCO, ,9, will only occur in a state conceivable \nin GCO. Hence the expansion is (O,W)\u00adinterleavable by theorem 4 and is W-consistent by theorem 5. The \nfinal expansion, shown in Figure 25, is trivially W-consistent. We have shown that our predicate W is \nGCO inductive in GC4. As mentioned previously, this only implies that no non garbage cells will be col \nlected as garbage. It is possible that the system will never be in a state in which all garbage cells \nhave been collected. But, whenever GC4 reaches a state that is conceivable in GCO, the predicate W will \nbe true. From such a state, direct simulation of GCO is possible, and it is not difficult to prove that \nfor any state of GCO in which-W is true, after one execution of the marking transition, the system will \nbe in a state in which all and only all garbage cells are colored black. It then fol\u00adlows that GC4 is \nsemi-consistent. Acknowledgements : We thank Professor Robert M. Keller for several helpful discussions \nabout this paper. We also thank Mrs. Katrina Avery for typ\u00ad ing the manuscript and Miss Eleanor Addison \nfor drawing the figures. 7. REFERENCES [1] Courtois, P.J., Heymans, F., and Parnas, D.L. Concurrent Control \nwith Readers and Writers . Communications of the ACM, vol. 14, no. 10 (October 1971). [21 Dijkstra, \nE.W. Notes on Structured Program ming r in Structured Programming, by Dahl, Dijkstra, and Hoare, Academic \nPress (1972). [3] Dijkstra, E.W., Lamport, L., Martin, A.J., Scholten, C.S., and Steffens, E.F.N. On-the- \nFly Garbage Collection: an Exercise in Cooper\u00adation. Submitted to CACM, also EWD520 (Oct\u00adober 1975). \n [4] Doeppner, T.W., Jr., and Keller, R.M. On the Relevance of Abstract Models in Modeling Sema\u00adphore \nImplementations. Princeton University, Dept. of Electrical Engineering, Computer Science Laboratory Technical \nReport TR 193 (October 1975). [5] Gries, D. On Structured Programming -A Reply to Smoliar. In ACM Forum, \nCommunications of the ACM, vol. 17, no. 11 (November 1974) [61 Infante, R., and Montanari, U. Proving \nStruc\u00adtured Programs Correct, Level by Level. Proc\u00adeedings of 1975 International Conference on Reliable \nSoftware, SIGPLAN Notices, vol. 10, no. 6 (June 1975) [7] Keller, R.M. Formal Verification of Parallel \nPrograms. Communications of the ACM, vol. 19, no. 7 (July 1976) [8] Lamport, L. On-the-Fly Garbage Collection: \nOnce More with Rigor. Massachusetts Computer Associates cA-7508-1611 (August 1975). [9] Lamport, L. \nProving the Correctness of Multi\u00adprocessing Programs. Massachusetts Computer Associates CA-7508-0111 \n(August 1975). [10] Lipton, R.J. Limitations of Synchronization Primitives with Conditional Branching \nand Global Variables. Proceedings of Sixth Annual ACM Symposium on Theory of Computing (April 1974) . \n[11] Liptonr R.J. Reduction: A Method of Proving Properties of Systems of Processes. Communi\u00adcations \nof the ACM, vol. 18, no. 12 (December 1975) . [12] Owicki, S., and Gries, D. Verifying Properties of \nParallel Programs: an Axiomatic Approach. Communications of the ACM, vol. 19, no. 5 (May 1976). [131 \nRosen, 13.IZ. Correctness of Parallel Programs: The Church Rosser Approach. IBM Research Report RC5107 \n(October 1974).   \n\t\t\t", "proc_id": "512950", "abstract": "We develop a theory for the correctness of asynchronous parallel programs. A program is considered correct if its behavior is in some sense similar to that of an abstract version of the program. We discuss various criteria for this similarity. We then concentrate on one of them and develop a technique for showing that a parallel program is correct with respect to this criterion.", "authors": [{"name": "Thomas W. Doeppner", "author_profile_id": "81100553401", "affiliation": "Brown University, Providence, R.I.", "person_id": "P280521", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512950.512965", "year": "1977", "article_id": "512965", "conference": "POPL", "title": "Parallel program correctness through refinement", "url": "http://dl.acm.org/citation.cfm?id=512965"}