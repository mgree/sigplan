{"article_publication_date": "04-01-1993", "fulltext": "\n Addendum to the Proceedings OOPSLA I Washington, DC-26 Ada Electronic Reported by: Kurt D. Welker Michael \nW. Snyder Jerry A. Goetsch September-I October, 1993 Experience Report  Combat Modeling Idaho National \nEngineering Laboratory 1. Introduction Software engineers at the Idaho National Engineering laboratory \n(INEL) have been working with persomlel at the Air Force Electronic Warfare Center (AFEWC) on re-engineering \nfour electronic combat software models. This report summarizes our experiences using object- oriented \ntechnologies and Ada. In 1984, the AFEWC developed an electronic combat model called IMOM, (Improved \nMany-On-Many) which was written in FORTRAN, operated in a VAX/VMS environment, and utilized PLOT- lO/STI \n(Tektronix) graphics. This software, although machine dependent, developed a proven track record for \nsuccess in numerous exercises and deployments. With success came requests for enhancements to the models \nand the need to support tasking for related capabilities. In 1988, as part of the Contingency TACS Automated \nPlanning System(CTAPS) program, the INEL modified the IMOM software. IMOM was translated from FORTRAN \nto C, was modified to operate in a Unix/X- Windows environment, and used GKS graphics. In 1990, in support \nof Desert Storm, and as part of the Sentinel Byte program, the INEL modified the C baseline of IMOM to \ninclude the functional capabilities of a more recent FORTRAN version of IMOM plus some additional capabilities. \n High maintenance costs were starting to be realized for all baselines of the model and the original \ndesign of the model had deteriorated significantly. In 1991, the Air Force directed the INEL to analyze \nthe model from a software engineering perspective, taking into account Department of Defense and industry \nstandards and software development trends. The INEL study recommended a complete re-engineering effort \nusing modem software engineering practices which included using Ada and object-oriented technologies. \nThe new design goals were to gain hardware independence, increase run time performance, enhance the user \ninterface, and provide for a significant reduction in software maintenance. In addition to tbe IMOM model, \nthe AFEWC had three other models(COMJAM, Passive Detection, and RECCE) which had originally been based \non IMOM which they were interested in re-engineering as well. The project team re-engineered the software \nusing object-oriented analysis and design techniques and then implemented this new design in Ada, an \nobject-based programming language. The new software runs under the Unix operating system, uses an X/Motif \nbased user interface, and utilizes GKS graphics. This success provides clear evidence that object- oriented \ndesigns implemented in Ada are a viable software engineering solution for the DOD. Each of the original \ndesign goals were met. The new software interfaces with other Air Force software packages written in \nC and FORTRAN. The use of Ada, GKS, Motif, and Unix, along with the new software design, provides platform \nportability. The electronic combat algorithms were streamlined to provide an improvement in run time \nperformance. The new user interface is window oriented and was built using Motif. A number of Ada utilities \nhave been developed. In addition,a high percentage of the software is shared between the models including \nthe user interface software, electronic combat algorithm software, and electronic combat component software. \n 2. Methodology-Design and Implementation into Ada Members of our software development team had little \nexperience with object-oriented design and Ada. Training was accomplished by way of in-house courses, \ncontracted training classes, university courses, seminars and conferences, and a significant amount of \npersonal literature research. From this knowledge base, team members determined that no published object- \noriented methodology would optimally handle our requirements. We therefore decided to come up with our \nown approach which incorporated key concepts from several published methodologies. In order to establish \na consistent design and implementation, a Software Development Plan (SDP) was written which specified \nthe software development methodology, established reviews and audits, listed standards, practices, and \n Addendum to the Proceedings OOPSLA 93 conventions, and provided a configuration management Plan. We \nalso realized that since this was a re-engineering effort rather than a new development effort, that \nmuch information could be used from the existing system to help with the redesign. Requirements were \nderived based on currently functioning software systems, users manuals, customer direction, users, and \nour own insight into the problems being solved. Furthermore, we recognized that since we were using Ada, \nsome object-oriented concepts would not be supported to the same extent that they would have been in \nlanguages with stronger object-oriented ties. Our core design methodology centered around the three model \napproach specified by Rumbaugh in Object- Oriented Modeling and Design. All three models were used; the \nobject, functional, and dynamic models.We used Rumbaugh s object model notation to document the backbone \nof our design. We found that the data flow diagrams and the state diagrams were generally useful to guide \nus through the aspects necessary for a complete design. Significant ideas from Booth s Sojiware Components \nwith Ada, and Object-Oriented Design with Applications were incorporated. Detailed design included using \nBooth s Ada graphical notation for the specification of subsystems, package specifications and bodies, \nsubprograms, generics, dependencies, etc. Generally speaking, we chose to implement classes and objects \nvia the Ada package. Each package exported types, methods, and exceptions. Packages also were used to \nencapsulate functional support libraries. Types, private types, and limited private types were used to \nimplement the appropriate level of information hiding for each class. Ada generics were used very little, \nand Ada tasks were not used at all. Some object classes were implemented across multiple packages, and \nsome were combined into a single package depending on specific implementation situations. Inheritance \nin the design was handled by: ( 1) named reference (data driven, relational) (2) variant records, implementing \nsibling objects within a single package  (3) call-through to a common base parent, i.e. layered packages \nand types  (4) limited duplication of code (5) using it for design but not implementing the inheritance \nin the code  Polymorphism in our system was implemented in Ada by the use of collections of variant \nrecords, overloading, and generics. The Ada package turned out to be an excellent construct for encapsulating \nthe object classes, while providing the right degree of modularity and information hiding. The package \nspecification conveniently acted as an interface contract to other classes in the system. Care had to \nbe taken to manage the dependencies between object classes located in different subsystems. Our design \nchanged several times throughout the life cycle. This was painful at times but has resulted in high quality \nsoftware. We wanted to end up with a design which was consistent throughout. We weren t afraid to Washington, \ngo back and make large scale changes in the system. The design changes were absorbed into the current \nschedule without significant impact. Object-oriented CASE tools were not used during this effort. This \nwas not due to lack of CASE tool capability, but because of high cost. The Ada programming language provides \na sound implementation language for developing large scale object-oriented systems. It not only supports \nmany object-oriented philosophies, but also has tremendous robustness due to its inherent software engineering \nprinciples. We do not claim that we had continual smooth sailing on this project, nor that our approach \nand eventual solution was by any means perfect. We do believe that we ended up with a system that exhibits \nhigh quality and one which met our design goals and our customer expectations. 3. Reuse During the initial \nanalysis of the four models, we recognized that each of them had, at a conceptual level, a wide variety \nof components which could possibly be shared. Each application contained similar electronic components, \nmodeling algorithms, user interfaces, graphics, etc. Therefore, in the design phase, an emphasis was \nplaced on determining the appropriate abstraction for each object class and what its role was within \neach model. It became apparent through the design process, that we would achieve varying levels of reuse. \nThe level of reuse was directly linked to the role of the object within the models. Some object classes \nhad the possibility for reuse outside the electronic combat domain, others were shared between two or \nmore electronic combat models, and pther classes were highly specialized for a particular role within \none of the models. We began designing the electronic combat specific object classes by examining the \nessential characteristics of each electronic combat component and its role within the various electronic \ncombat models. Some of the classes fit well into more than one electronic combat model. Some did not. \nWe found that while most object classes in our application domain were conceptually the same, their characteristics \nand roles within each of the models were different. When it appeared that the difference was minor, an \nobject class was designed which would meet the multiple requirements. This approach added only limited \ncomplexity to the class. Many of our objects fit into this level of reuse. It is conceivable that some \nof these objects could be reused within other electronic combat software systems. When the differences \nin the classes characteristics and roles were major, object classes were designed which fit a highly \nspecific need and thus had a relatively low possibility for reuse even between our models. Some attempts \nat the design and implementation of our object classes were for a specific model. Once the core class \nwas established, we expanded and refined its context to be reusable in the other models. This approach \nworked well when not enough details were available up front as to the specific role of the class in the \nother models. Other attempts concentrated on building classes which were, from the onset,designed to \nD.C. September 26-October 1, 1993 be part of multiple models. In these cases, we had very detailed knowledge \nearly on as to the role of the class within each application. We made a concerted effort to develop objects \nthat would achieve their optimal reusability level, without becoming overly complex or compromising engineering \nprinciples. Much publicity surrounds the issue of reusable objects. Our redesign effort was able to \nachieve high reuse. It was our finding that reuse is not nearly the general . panacea which has been \ntouted by many software engineering professionals, but for certain types of problems, and within specific \napplication domains, it can improve software quality and enhance the software development process. The \ngreatest reuse is possible when sharing objects within the same specific application domain within a \nsoftware development shop. Beyond that, object reuse is still very difficult. Our experience showed that \ndeveloping reusable software does not come without cost, nor without increasing the object s complexity. \nThe four models have 112 object classes, 73 which are shared between two or more software systems. Each \nclass exports on the average 7.5 methods, and has an average of 1200 lines of commented source code. \nThere are 11 algorithmic or interface libraries which are shared between the models.  4. Architecture \nA key aspect of the engineering solution was the selection of a software architecture that would support \nthe design goals of increased portability and ease of maintenance. We determined that by establishing \na software architecture composed of layered subsystems we could achieve these goals. Each subsystem contains \nlogically related objects and/or algorithmic or interface libraries. Loose coupling exists between objects \nof different subsystems. To some extent, the subsystems are hierarchically organized to achieve maximum \nportability and long term maintenance. The architecture begins with an application layer at the top level. \nThis layer includes all of the model specific subsystems. These subsystems are hierarchically organized \nas well thus establishing dependencies and visibilities between application subsystems. Each subsystem \ncontains closely related modules. Key to our design was the concept of an electronic combat component. \nThese components, when collected together, form a significant portion of the architecture and also define \nthe basis for the engineering analyses that occur within our models. The next layer is comprised of several \ninterface library subsystems which buffer the application subsystems from the actual graphics system(GKS), \nthe windowing system (Motif/X), the operating system (Unix), hardware peripherals (plotters, printers, \nstorage devices, etc.) and other third party software. This layer is essential to the architecture as \nit allows changes to occur in the lower layers without impacting the application subsystems. The intent \nbehind these layers was to implement an interface specification that would allow for future maintenance \nchanges such as using alternative graphics or windowing environments without impacting the entire software \napplication. The package specifications from these interface modules to the application subsystems remains \nconstant, while the specific implementation was hidden from the other subsystems.  5. Hybrid Solution \nThe basis for the design of our system was provided by an existing functionally decomposed system. We \nbegan our analysis by looking at the existing models and answering these three questions: ( 1) What does \nthe model do? (2) What are the pieces or building blocks? (3) What do the models have in common?  We \ndetermined early on that we would be dealing with a number of external subsystems, so we would require \na layered architecture, as described earlier. All of this allowed us to visualize a number of subsystems \nthat made up our complete system. We then took a more detailed look at the existing system to help derive \nthe lower level components of each sub-system. We were able to examine the code and the data tiles to \nhelp define some of the details of the data structures that we would need to support. We also examined \nthe engineering analysis routines to determine how they fit into the subsystems. This information gave \nus a rough basis for the system classes that we would need to support and the types of operations that \nwould need to be supported by these classes. These classes and methods were then refined by determining \nthe exact role of each of the object classes in the electronic combat models. This process involved extensive \ndiscussion and reviews by all team members and was not considered complete until the classes were refined \nto the point of being able to produce complete Ada package specifications. Next, the package bodies were \nimplemented and a prototype constructed to test our design assumptions. This process gave us an increased \nunderstanding of the role of the classes within the system and allowed us to further refine these classes. \nIt is important to note that this entire process was highly iterative. This allowed us to do unit testing, \nand integration testing throughout the development process. Through this process, we learned that the \nimplementation of some parts of the system was better off left functionally decomposed. Specifically, \nthe engineering analysis algorithms were taken from the existing code, and refined using functional decomposition. \nA few of the subprograms in the functionally decomposed code were adapted into methods for object classes \nin the new system. Most were completely redesigned, either from scratch or by familiarity with the old \nalgorithm. Furthermore, some of the subsystems such as the graphics and window interface layers, which \nfunction as support libraries, were left functionally decomposed. Although not object- oriented, they \nwere designed and implemented using sound, modern software engineering principles. Our system indeed \nhas a hybrid design solution. Because the subsystems are carefully layered, this approach seems to be \nan optimal solution for achieving our design goals. We produced a soundly designed software system, which \nused conservative software engineering concepts. Addendum to the Proceedings OOPSLA 93 6. Conclusions \nAfter completing this effort, we wanted to determine how successful we were in meeting our software quality \ngoals. A metrics analysis was performed on each of the electronic combat software baselines which were \nimplemented in FORTRAN, C, and Ada, as a cooperative effort between the INEL and the University of Idaho. \nThe Ada software touted a reduction in software complexity and had a maintenance index which indicated \nmuch better long term maintenance than the original functionally decomposed software. We believe object-oriented \ndesigns are resistant to design degradation over the application life cycle. Actual tracking of the software \ndefects showed that the re-engineered software had 20% less known defects than earlier baselines. Actual \ndevelopment time for systems developed at the INEL averaged at 32 man- months per model for the original \nsystems, and 25 rnan- months per model on the re-engineered systems. We attribute a large percent of \nthe increased software quality and the shorter development time for the new software systems to the use \nof object-oriented design and Ada. Object-oriented design does not give license to avoid sound software \nengineering, it is the embodiment of such principles. A solid software engineering process is paramount \nto achieving excellence in software quality. Object-oriented design has been a keystone in our software \ndevelopment process, and was a primary factor in our success, . Contact information: Kurt D. Welker Michael \nW. Snyder Jerry A. Goetsch Idaho National Engineering Laboratory Idaho Falls, ID. 83415-2090 wdk@inel.gov, \nswnz@inel.gov, goe@inel.gov Prepared for OOPSLA 93 under the direction of: The United States Air Force \nElectronic Warfare Center and the U.S. Department of Energy, DOE Idaho Field Office Contract DE-AC07-76IDO1570 \n 22 Washington, D.C. September 26-October 1,1993  \n\t\t\t", "proc_id": "260303", "abstract": "", "authors": [{"name": "Kurt D. Welker", "author_profile_id": "81100218683", "affiliation": "Idaho National Engineering Laboratory, Idaho Falls, ID", "person_id": "PP31032594", "email_address": "", "orcid_id": ""}, {"name": "Michael W. Snyder", "author_profile_id": "81100167831", "affiliation": "Idaho National Engineering Laboratory, Idaho Falls, ID", "person_id": "P198891", "email_address": "", "orcid_id": ""}, {"name": "Jerry A. Goetsch", "author_profile_id": "81100218897", "affiliation": "Idaho National Engineering Laboratory, Idaho Falls, ID", "person_id": "P139043", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260303.260308", "year": "1993", "article_id": "260308", "conference": "OOPSLA", "title": "Ada electronic combat modeling", "url": "http://dl.acm.org/citation.cfm?id=260308"}