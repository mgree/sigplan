{"article_publication_date": "04-01-1993", "fulltext": "\n OOPSLA  Washington, DC-26 September-7 October, 1993 Supporting the Evolution of Class Definitions Report \nby: Theodore C. Goldstein Sun Microsystems Laboratories, Inc.  Scope and Goals of the Workshop: This \nworkshop focused on the interactions of the object- oriented technology and its support for the development \nof large software systems that evolve over time. This workshop brought together the related areas of \nType Theory Object-Oriented Database Schema Evolution Designing Evolution Runtime Systems Designed to \nSupport Evolving Implementations We examined technology which can support changes to class definitions \nwithin the constraints of existing and proposed object-oriented languages.  Type Theory: Barbara Staudt \nLerner of University of Massachusetts at Amhearst (USA) spoke on Extending the Notion of Type Conformance \nto Interfaces and Type Systems. This is work pursued in the context of interface type hierarchies which \nare independent of their implementation class hierarchies. This was work in progress which seeks to extend \nexisting type systems to allow existing instances to evolve to new implementations of classes. She makes \nthe observation that existing types rarely delete functionality. This is the case to optimize. Types \nwhich delete functionality are not as important, since it is nearly impossible to support in any meaningful \nway. By using method lookup rules which dispatch both on the version of the object, as well as the object \ns identity, it is possible to select the appropriate version specific implementation. Difficulties arise \nduring contravariant changes to methods. Old code might use new instances which require a runtime check. \nAs well new methods cannot be applied to old instances since it is not possible to guarantee that certain \ninvariants may still be maintained. One possible solution is to identify special problem objects and \nconvert (mutate) old instances explicitly into newer versions. Franz J. Hauck of Department of Computer \nScience at University of Erlangen-Nurnberg in Erlangen (Germany) spoke on Supporting Class Evolution \nby Typing Inheritance. The problem presented was that changes of classes caused problems to classes which \ninherit from them. The solution he proposed was to create stronger models by treating the inheritance \nrelationship by explicit bindings. In effect, putting a explicit type on the inheritance relationship. \nThus the rights of the super type variable is typed with the type elements it depends upon of the base \ntype. Additional benefit can be made by separating the aggregation type from the inheritance type.  \nObject-Oriented Database Schema Evolution: Clara Smith of LIFIA Computer Science department at Universidad \nNational de La Plata in Buenos Aires (Argentina) spoke on Understanding elementary schema updates in \na attribute oriented database using a set theoretical framework. The principle of the talk was that it \nwas possible to maintain attribution as individual predicates on the semantic domain for the objects. \nModifying the schema in which those attributes were accesses should be independent of the attribution \nof the objects. Peter Schwarz of IBM Almaden Research spoke on The Rufus approach to schema evolution. \nRufus is a research database system which integrates object-oriented databases, semi-structured dam and \ntext to provide continuous query and response without recompilation. The approach is to use a conformance \nbased data model (originally found in Emerald and Melampus) to provide separate interface and implementation \nhierarchies. Inheritance implementation is simplified because it is implemented by a process of copying \nsource code and permanently sealing its implementation. Every version is thus immutable. Existing objects \nare never modified or invalidated. An object s implementation is not deleted until all of associated \nobjects are deleted. Christopher Frye of Andersen Consulting in New York (USA) presented some MIS problems \nin his talk entitled Evolution of class definitions in information systems. Several principles emerged \nwhich are key to his approach in managing evolution of systems. First, all class definition is static. \nAll possible variability in a class s behavior and structure must be anticipated in the class definition \nor in the superclass definitions. This Addendum to the Proceedings OOPSLA 93 103 strategy is realized \nby planning for extensible structures from the beginning. Fabrizio Ferrandina of J.W. Goethe-Universitat \nFachbereich Informatik of Frankfurt am Main (Germany) presented Object-Oriented Database Schema Evolution: \nAre Lazy Updates Always Equivalent to Immediate Updates? Schema evolution in an object-oriented database \nsystem refers to the ability to change the schema and the data in the database. Transmuting an entire \ndatabase at once however may be impossible because the entire database must be removed from application \nuse during the mutation. For many databases, it is necessary to update the database incrementally (or \nlazily) as individual objects are needed. The approach presented was a layer on top of the commercially \navailable 02 database. It is possible to write an application such that it performs lazy incremental \nmutation. But if care is not taken, the application may distort the perform the lazy incremental updates \nin such a fashion that is not equivalent to immediate complete updates.  Designing Evolution: William \nOpdyke of AT&#38;T Naperville, Illinois (USA), presented techniques for Refactoring Object-Oriented Programs. \nRefactorings are semantic preserving rearrangements of a class hierarchy. These refactors are necessary \nto cope with expanding object-oriented libraries to simplify code and remove redundancies. There are \nbarriers to refactoring. Refactoring is time consuming, and performing it with ordinary text editors \nare dangerous. With large bodies of code, there are often social political problems which must be handled. \nTo provide well formed code, it is necessary to interleave code growth with incremental consolidation \nand refactoring. These refactorings partition complicated classes into separate subcomponent subclasses. \nThis allows a subcomponent to be reused for other purposes. Refactorings must preserve program behavior. \nThey are iterative refined over time. It is important not to violate naming, scoping rules or type rules. \nRecompilation will not catch all possible errors. The approach taken here was to define a set of invariant \nprogram properties which must be preserved. Refactorings must check to make sure that these invariants \nare satisfied. Automated tools help, but some languages are easier to refactor than others. Runtime \nSystems Designed to Support Evolving Implementations: Theodore C. Goldstein of Sun Microsystems Laboratories \nand Alan Sloane of SunPro, Mountain View California (USA) presented Versioning in C++ and the Object \nBinary Interface. Object-oriented languages like C++ allegedly support evolution. Various techniques \nand idioms such as naming conventions, derivation (subclassing), overloaded pointers, conversion operators \nand namespaces purport to be tools to provide versioning. But these tactics provide ambiguous versioning, \nforce recompilation and recoding, and prevent any form of binary compatibility of programs. In a world \nof distributed objects whose implementations reside in dynamically linked shared libraries, it is necessary \nto support multiple implementations of an object simultaneously in the same program. This requires that \nthe C++ one definition rule be relaxed. The subset of the C++ object model which would support this is \nto only access the object through virtual functions. No friend access to an object s private members. \nNo access using non-virtual functions. Since the size of objects are always private and are not known \nuntil object construction time, an implementation must get any offset from the class itself. A new object \nmodel is presented called Otbls (pronounced O-tables), which completely describe a level of the class \nhierarchy. Unlike conventional, Vtbls, Otbls are dynamic data structures which are generated at runtime \nwhich are dynamically built to reflect the class hierarchy and physical layout of an object. Early analysis \nof this approach was shown to have comparable performance with conventional vtbl-based implementations. \nAndrew J. Palay Visual Magic Division, Silicon Graphic of Mountain View (California) presented another \napproach entitled Delta C++ which allows a developer to make compatible definitions to a class with minimal \nrecompilations. The set of compatible changes maintains or extends the class interface without altering \nthe code sequence used to access members of that class. Delta C++ accomplishes this by resolving classes \nat link time. Changes are handled by extending the linker to support new relocation types. Most code \nsequences are identical to cfront generated code except for constructors/destructors, calls to non-virtual \nmembers, access to embedded structures and some optimizations. Scott Danforth of IBM Object Technology \nProducts, Austin, Texas (USA) presented Evolution of Class Definitions in SOM (The System Object Model). \nSOM is an implementation of the Object Management Group s object-oriented interface definition language \n(IDL). SOM extends the OMG s notion of distributed objects with a uniform object model to provide a uniform \nobject-oriented interface between languages. SOM also has an extensive metaclass framework. By extending \nIDL s notion of interfaces with a implementation construct called release-order it is possible to extend \nand change an interface. By using the metaclass protocol SOM supports many class evolutions. The biggest \nrestrictions on SOM were that class implementations may not change dynamically at runtime once a class \nis registered, and all instances of a given class objects at runtime must correspond to the data layout \ndefined by the register class. SOM requires that the implementor has responsibilities of maintaining \nconformant release order definitions between versions. E.g., the release-order entries must only be extended, \nnever removed or deleted. SOM uses a dispatch mechanism which supports multiple inheritance but favors \nsingle inheritance implementations. Washington, D.C. September 26-October 1,1993 Conclusions: It was \nagreed that our comprehension of the problem is still in its infancy. There were many similarities in \nthe approach, and that no single magic bullet was going to emerge as a solution. Many of the approaches \nwould seem to work well in combination. Clearly, having separation between interface and implementations \nprovide some help with the problem, but techniques and formal approaches still need to be sought. Listed \nWorkshop Organizers: Alan D. Sloane, SunPro Theodore C. Goldstein, Sun Microsystems, Inc. Michael S. \nBall, Taumetric Corporation Andrew Palay, Silicon Graphics Inc.  Addendum to the Proceedings OOPSLA \n93 105  \n\t\t\t", "proc_id": "260303", "abstract": "", "authors": [{"name": "Theodore C. Goldstein", "author_profile_id": "81100321568", "affiliation": "Sun Microsystems Laboratories, Inc.", "person_id": "P279887", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260303.260344", "year": "1993", "article_id": "260344", "conference": "OOPSLA", "title": "Supporting the evolution of class definitions", "url": "http://dl.acm.org/citation.cfm?id=260344"}