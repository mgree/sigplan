{"article_publication_date": "10-01-1993", "fulltext": "\n Subject-Oriented Programming (A Critique of Pure Objects) William Harrison and Harold Ossher IBM T.J. \nWatson Research Center P.O. Box 704 Yorktown Heights, NY 10598 Abstract Object-Oriented technology is \noften described in terms of an interwoven troika of themes: encapsulation, polymorphism, and inheritance. \nBut these themes are firmly tied with the concept of iden-tity. If object-oriented technology is to be \nsuccessfully scaled from the development of independent applica-tions to development of integrated suites \nof applica-tions, it must relax its emphasis on the objecf. The technology must recognize more directly \nthat a mul-tiplicity of subjective views delocalizes the concept of object, and must emphasize more the \nbinding concept of identity to tie them together. This paper explores this shift to a style of object- \noriented technology that emphasizes the subjective views: Subject-Oriented Programming. 1. Introduction \nFigure 1 illustrates the definition of a tree in a com-monly accepted way of thinking about objects, \nsometimes called the classical model [22]. In this model, a tree is defmed by defining a class, the class \nof all trees, in terms of internal state information and methods that can be applied. Proponents of the \nad-vantages of data abstraction, a form of encapsulalion, emphasize the fact that client programs manipulating \nthese trees do so only through the exposed operations. Permission to copy without fee all or part of \nthis material is granted provided that the copies are not made or distributed for direct commercial advantage, \nthe ACM copyright notice and the title of the publication and its date appear, and notice is given that \ncopying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, \nrequires a fee and/or specific permission. . .  @ 1993 ACM O-89791-587-9/93/0003/041 1 . ..$1.50 Ideally, \nthe designer of such an object-oriented tree defines and works with the intrinsic properties and behavior \nof a tree. In the real-world, properties of a tree like its height, cell-count, density, leaf-mass, etc. \n are intrinsic propcrtics. Intrinsic behaviors include things like growth, photosynthesis, and other \nbehav-iors that affect the intrinsic properties. This ideal classical model is utterly inadequate to \ndeal with the construction of large and growing suites of applications manipulating the objects. Designers \nof such suites are forced either to forego advantages of the object-oriented style or to anticipate all \nfuture applications, treating all extrinsic information as though it were intrinsic to the object s nature. \nFigure 2 shows an example of the situation that gives rise to this pressure. In it, we see that a tax-assessor \nhas his own view of characteristics and behaviors associated with a tree. The characteristics include \nits contrib-ution to the assessed value of the property on which it grows. The behaviors include the \nmethods by which this contribution is derived. These methods may vary from tree-type to tree-type. In \nfact, such methods may form part of a tax assessor s view of all objects, tree and non-tree alike. These \ncharacteristics and behav-iors are extrinsic to trees. They form part of an assessor s subjective view \nof the object-oriented tree. With the classical object model, the designer of the tax-assessor application \nis faced with one of two choices. On one hand, the application can be con-structed as a &#38;en/ using \nthe encapsulated methods but forgoing the advantages of encapsulation and polymorphism for the tax assessor \napplication s state and methods. On the other hand, the application s function could be integrated into \nthe same tree class manipulated by other applications; in effect, treating OqPSLA 93, pp. 411-428 Figure \n1 -An Object-Oriented Tree the extrinsic characteristics of the tax-assessor appli-cation as though they \nwere intrinsic to trees. 130th choices are objectionable. Figure 3 illustrates how unmanageable the latter \nap-proach is by reminding us that tax-assessor is merely one of a suite of applications, each of which \nhas its own subjective view, its own extrinsic state and be-havior for the tree. Although the theme of \nsubjects in anthropomorphic terms is illustrative, we should not lose sight of its importance in tool \nand application integration set-tings. The tree could easily be a node in a parse tree, the bird an editor, \nthe assessor a compiler, and the woodsman a static-semantic analysis tool. Each of these tools defmes \nits own state and methods on the parse-tree nodes, e.g. the editor has display status, the compiler has \nassociated code expansions, and the checker has use-definition chains. Either the developers of these \napplications cannot encapsulate their own state and behavior with the parse-tree node to gain the advantages \nof encapsulation and polymorphism, or the system de-signer must manage an ever-expanding collection of \nextrinsic state and behavior becoming part of the in-trinsic node. In fact, in the presence of market \npres-sure to adopt applications provided by vendors rather than do all development in-house, the defnler \nof the node faces the impossible task of anticipating all fu-ture extrinsic requirements. This burden \ndemands a Figure 2 -A Tax Assessor s View of the Tree more powerful model than the classical object model \nin order to facilitate the devclopmcnt of application suites. We propose .rul,jccl-oricnld prr~grarnmit~~qas \nsuch a model. Section 2 outlines the goals of subject-oriented pro-gramming. Section 3 then provides \nan ovcrvicw of subjects, and sections 4 and 5 discuss aspects of sub-ject interaction. Section 6 then \ndescribes a model of subjects, and claboratcs some details in terms of the model. Section 7 discusses \nconsiderations in imple-menting efficient support for suhjcct-oriented pro-gramming. Section 8 provides \na more concrctc example of the use of subjects in defining software development environments, and Section \n9 discusses related work.  2. Goals The overall goal of subject-oricntcd programming is to facilitate \nthe development and evolution of suites of cooperating applications. Applications coopcrate both by sharing \nobjects and by jointly contributing to the execution of operations. l hc following re-quirements arc \nimportant in this context: 0 It must bc possible to develop applications scp- aratcly and then compost \nthem. . The separately developed applications should not riced to bc explicitly depcndcnt on the other \nap-plications they arc to be composed with. . T hc composed applications might coopcratc loosely or closely, \nand might bc tightly hou~~cl for Figure 3 -Many Subjective Views of an Object-Oriented Tree frequent, \nfast interaction, or be widely distrib-In the subject-oricntcd paradigm, each application is uted. a \nsubject or a composition of subjects: it defines just . It must be possible to introduce a new applica-the \nstate and hchavior pertinent to the application it-tion into a composition without requiring mod-self, \nusually fragments of the state and behavior of ification of the other applications, and without collections \nof relevant classes. As discussed in the rest invalidating persistent objects already created by of this \npaper, the semantics of subject composition them. Ideally, even recompilation of the appli-and interaction \nensure that the requirements listed cations should not be required, except to facili-above arc satisfied. \ntate global optimization if desired. Unanticipated new applications, including new 3. Subjects applications \nthat serve to extend existing appli- cations in unanticipated ways, must be sup-This section discusses \ngeneral characteristics of ported. The notion of extending an application subject-oricntcd programming \nwithout introducing a by writing an extension application and com-specific model. Recausc the use of \na more format or posing it with the base application is discussed in detailed model makes discussion \nmore precise, how- detail in [ 141. . ever, Section 6 will introduce such a model and re- Within each \napplication the advantages of visit some of the topics addressed in this section in encapsulation, polymorphism \nand inheritance - some more detail. object-oriented programming -must be re- tained. We USC the term \n.rul,jecl to mean a collection of state These requirements and their relationship to object-and behavior \nspecifications reflecting a particular oriented technology are discussed in more detail in gestalt, a \nperception of the world at large, such as is [lo]. As illustrated in Section 1, the classical object \nseen by a particular application or tool. Thus, al- model does not satisfy them. though for smoothness \nof flow we may occasionally speak of subjects as individuals, they are not the in-dividuals thcmsclvcs, \nbut the gcncralized perception t The term subject differs somewhat from its use by Coad and Yourdon [Z], \nalthough both usages share the idea or reflecting a smaller, more l ocussed perception of a complex shared \nmodel. We avoided the similar term view in order to emphasize the stronger philosophical similarity with \nnon-classical philosophical trends thal emphasize the idea that subjective perception is more than just \na view filtering of some objective reality. The perception adds to and trans- forms that reality so that \nthe world as perceived by a body of perceptive agents is more than the world in Isolation. of the world \nshared by some individuals. Similarly, subjects are not classes. They may introduce new classes into \nthe universe, but subjects generally de-scribe some of the state and behavior of objects in many classes. \nOne often thinks of particular state and behavior as being intrinsic to an object: the state and behavior \nthat describe its essential characteristics, as opposed to additional state and behavior associated with \nit by various subjects. For example, the height, weight and other attributes and behavior associated \nwith trees in Figure 1 might be considered intrinsic to trees, whereas the other attributes and behavior \nsuch as as-sessed value and sale price are not. In the subject-oriented model there is no special status \naccorded to the intrinsic properties. The developer is free, if she chooses, to have a subject that implements \nthe in-trinsic properties of one or more classes of objects, and to require that any manipulation of \nthe intrinsic properties employ that particular subject to carry it out. The essential characteristic \nof subject-oriented pro-gramming is that different subjects can separately de-fme and operate upon shared \nobjects, without any subject needing to know the details associated with those objects by other subjects. \nOnly object identity is necessarily shared. A subject is definitional or schematic -it corresponds to \na traditional (though usually incomplete) class hi-erarchy, describing the interfaces and classes known \nto this subject. A subject does not itself contain any state. 3.1. Activations and Compositions of Subjects \nA subject activation, often referred to just as an acti-vation, provides an executing instance of a subject, \nincluding the actual data manipulated by a particular subject. Subjects can be combined to form cooperating \ngroups called compositions. The composition also defines a rule, the composition rule that specifies \nin detail how the components are to be combined; for example, how methods from different subjects for \nthe same operation and class are to be combined, and whether nested compositions form separate scopes \nor are a!l combined into a single scope. A great variety of composition rules is possible, and some cxamplcs \nwill be given in subsequent sections. In distributed systems, subject activations may be separated in \nspace and time, and state changes to in-dependent subject activations of an object may occur in separate \ntransactions. This makes even the concept of a unified state of the object inaccurate and mis-leading. \nA vital aspect of subject-oriented program-ming is that it be possible to extend subjects and to introduce \nnew subject activations without disrupting others. It is therefore important that ncithcr source nor \nobject code rely on the global state of the object or on its format. Accordingly, we use t.hc term \nobject-identifier or oid to mean the globally known unique identification of the object as it appears \nin the context of one or more subjects of interest. In the context of a particular subject, we also use \nobject to mean the state and be-havior associated with an object identifier by that subject. Similarly, \nthere is no global concept of class: each subject contains class descriptions that describe state and \nbehavior from that subject s point of view. Aspects of a this way of manipulating objects will bc expanded \nand explored in the following sections, in the course of explaining the features of subjcct-oriented \nprogramming. As mcntioncd, a more precise but also more particular model will be introduced later in \nSection 6. 3.2. Relationship to O-O Technology The classical object model is, in many respects, the \nmodel of objects seen by any one subject. Within a subject, an object has an implementation class that \ndefines the implementation of behaviors provided for the various operations supported by the object and \nthe state information needed by these implcmcnta-tions. Subject-oriented programming thus includes object-oriented \nprogramming as one of its tcchnolog-ical elements.  Interfaces Interfaces describe in abstract terms \nthe operations that a class of objects supports. Variables that point to objects , whether instance variables \nof objects, static or dynamic program variables or paramctcrs, are declared in terms of the interfaces \ntheir contents must support, rather than in terms of specific classes. -I-1Lis ayprwa&#38; lea&#38; Lu \ntjrt;irter encapsulation, and hence to greater flexibility and reuse. It is being in-creasingly accepted \nwithin the object-oriented com-munity [S, 231. Even in languages such as C + f that do not explicitly \nrequire separate interfaces, con-ventions arc frequently adopted that amount to using certain classes \n(abstract base classes in C + +) as interfaces. Separation of interface definition from implementation \ncharacterization is of even greater importance in subject-oriented programming, because interfaces are \na point of agreement between separate subjects as to the operations that are available on an oid, without \none subject needing to have any access at all to the class hierarchy describing the implemen- tations \nprovided by another subject.  Beha viov Behavior is specified by means of methods, which are the actual \ncode implementing operations on specific classes of objects. In classical class-based models, all methods \nare associated, either explicitly or by inheritance, with the single class of which the object is an \ninstance. In the subject-oriented approach, the class associated with each oid can differ from one subject \nactivation to another. This means that each subject can specify its own behavior for each object. What \nis more, the inheritance relationships among classes can be different in different subjects.  State \nInformation State information is retained in instance variables. Classically, all of an object s state \nis treated as a unit, and is known and accessible to all methods associated with that object, though \nit might not all be used by all of them. In the subject-oriented approach, the state associated with \na particular oid can vary from one subject to another. In addition, since the subject really just provides \na template for state and behavior, there can even be be multiple activations of a single subject, each \nwith its own state for the object. 4. Interactions Among Subjects Since the model of an object seen \nby any one subject is essentially the classical object model, this convcn-tional model is adequate if \nall subjects remain iso-lated. The need for a subject-oriented model arises when dealing with interacting \nsubjects. This inter-action can take any of several forms: . A request for function or state change to \nbe supplied by another subject. For example, the woodsman s invocation of cut-down affects the tree s \nheight as well as her own caloric con-sumption Performance of an activity in which another subject might \nparticipate e.g. the assessor s csti-mate of the value of a tree may be reflected by a private interpretation \nof the woodsman s decision to estimate the effort to cut the tree down, Notification of an occurrcncc \nwhich tnay hc of intcrcst to another subject e.g. the bird s ncst-building activity might influence the \nwoodsman s schedule for cutting down the tree llse of one subject s behavior as part of the larger behavior \nof another e.g. the tax assessor may use the woodsman to cut down many trees to pay delinquent taxes \n(perhaps he s the Sheriff of Nottingham?). Sharing of state, e.g. the bird and the woodsman might both \nhave the same notion of tree height. Subjects interact only if they are composed with one another in \na universe. I>etails of the interaction are determined by the composition rule. The rest of this section \ndiscusses some of the semantic details of sub-ject composition. 4.1. Operatiou Invocatiou All code in \na subject-orient4 framework executes in the context of a particular subject activation. An op-eration \ncall can thcrcfore bc modclled as a tuple (a, OP, P), where . a is the subject activation making the \ncall. . op identifies the operation to be performed. . p is a list of parameters. Some of these parame- \nters will bc oids. Some of them will be used to control operation dispatch, details dcpendcnt on the \nlanguage used. In many embodiments, the first parameter will be considered the controlling object or \nreceiver , to be used for dispatch. When an operation is invoked in a subject-oriented model it might \ncause cxccution of methods in multi-ple subjects. I he composition rules control what happens, so that \nwithin a subject-oriented model, there is freedom to craft and use different composition rules. It is \ntherefore possible to describe complex combinations of detailed aspects of the separate sub-jects. The \nmost useful composition rules, however, are likely to be those that are simple and can specify briefly \nsome frequently useful ways of combining the d&#38;ails of separate subjects. The simplest composition \nrule, closest to the rule in C+ -!- , Smalltalk or OM<; COIiI~A[23], is perhaps: An operation can be \ndispatched to only a single subject activation. IIowever, this rule rather sevcrcly limits the usefulness \nof composition to preplanned extension of existing frameworks. An example of a simple and more appealing \ncomposition rule, called merge, is: 1. For each subject activation in arbitrary o&#38;r (but not in parallel), \ndispatch the operation within that activation. This local dispatch within an activation is whatever form \nof objcct-oriented dispatch is provided by the language in which that activation s subject is written. \nWhen an operation implementation is dispatched to within a separate subject, the dispatch is dircctcd \nusing the receiver s classifcation of the object. Thus dispatch can be based on different classes in \ndifferent subjects. 2. If the methods r&#38;urn values, all the return values must be identical, or \nan exception is raised. 3. If the operation defines inour parameters, they may be set by one method \nand used by the next. IIowever, the operations performed on them should be commutative.  These characteristics \nprovide a commutative compo- sition with the desirable characteristics discussed in [14]. Tool composition \nin OOTIS provides a com-position rule similar to merge, with an cflicient underlying implementation [lo]. \nIt is worthwhile to illustrate the way in which the merge composition rule enables the distributed im-plementation \nof an object. Assume, for example, that both the tax assessor and the woodsman arc tracking the existence \nof a nest in the tree. Ihc bird, uses op-erations called make-nest and abandon-nest to per-form its nest-building \nwork. To track this behavior, the woodsman and tax assessor each can supply be-haviors for make-nest \nand abandon-nest. In the im-plementations used by the woodsman and tax assessor, make-nest increments \na state variable in their representation of the tree and abandon-nest dccrc-ments the variable. So, each \ntime a bird makes a nest in a tree, the assessor and woodsman also update their mental models of the \ntree to record the nesting. Further, if one or more of the subjects (bird, woodsman, tax-assessor) provides \na has-nest the rc-sult should always bc the same, whether the imple-mentation is supplied locally or \nhy sharing from another subject. I he cxamplc rule above, by cycling through all sub-ject activations, \ndots not respect subsidiary compos-itions. An altcrnativc rule, calicd rtcslirzg, treats composilions \nas scopes, and allows calls to propagate beyond scopes only if specilicd rxplicitly. A dis-cussion of \nnesting is made within the framework of a more specific model in Section 6. As with mcrgc, tool composition \nin OO I IS also provides an cflicicnl im-plementation for a composition rule similar to ncst-ing. I hcse \ncxamplcs should make it clear that many vari-ations arc possible, both subtle and dramatic. t;or-mulation \nand cficicnt implcmcntntion of various composition rules is an interesting topic for future rcscarch. \n 4.2. Object Creation and Initialization I he sharing of behavior among suhjccts leads to the fact that \ncreation and initialization bchnvior tnust bc shared as well. A rcqucst to crcatc an object can he modcllcd \nas a tuplc (Q, c), whcrc . a is the subject activation making the rcqucst. . c is the name of a class \ndcfincd in (z s subject. For reasons nolecl below, paramctcrs specifying initial values arc not pcrtnitted \nin the create request. Al-though creation of an object is thus rcquestcd by one subject, other subjects \nalso riced to initiali%c informa-tion before they opcratc upon the object. The steps involved in object \ncreation and initializa-tion arc: 1. Allocation of an oid from the 0111 set.  2. I;or each subject activation, \ndctcrmining the ap-propriate class. 3. I:or each subject activation, allocating space for the object \ns state 4. Placing the appropriate initial values in the stor-age allocated.  I he creation operation \nspecifics the class to bc created from the point of view of the activation rcqucsting the creation. Classifying \nthe object within that activation is straightforward. Classifying the ohjcct for the other subject activations \nitivolvcs class tnatching across subjects according to the composition rule. This issue is discussed \nin Section 5. The composition rule is also responsible for specifying whether any instance vari-ables \nare to be shared across subjects. 110~ this is accomplished depends on the details of the subject model \nand is explained further in Section 6. The composition rule can use either of two ap-proaches to the \ntiming of a subject s initialization of an object: . Immediate initialization, in which all subjects \nparticipate in the initialization at the time the object is created. This has the advantage of the conceptual \nsimplicity of its determinism. . Deferred initialization, in which subjects pat-tic-ipatc in initialization \nof the object only as they need to respond to an operation on it at later times. This can have substantial \nperformance benefits: time is saved by avoiding communi-cation with numerous and potentially remote subjects, \nand space is saved because it is not al-located unless the subject actually participates in behavior \nof the object. Dcferrcd initialization also facilitates graceful introduction of new sub-jects that extend \nexisting objects. For these rea-sons, deferred initialization was selected in CL,ORIS[9]. Deferred initialization \nprecludes the use of parameters to the creation operation for determining initial val-ues. Such parameters \nare undesirable in the subject-oriented context in any case, however, since it would be undesirable to \nrequire addition of p arametcrs to all creation invocations whenever a new subject arises. (One might, \nin fact, argue that the fact that even an perception of the object s intrinsic state and behavior gradually \nevolves should argue against the use if in- itialization parameters even in the classical model. Considerations \nlike this illustrate the value of viewing even the intrinsic object as a subject.)  4.3. State References \nWhen a method within an activation is executing, it can access only the instance variables that it s \nsubject specifies. Note that this subject-oriented approach to state references provides tighter encapsulation \nthan classical object-oriented models: only a subset of the instance variables are accessible to each \nmethod, in general. Methods in different subjects can manipulate the same instance variables if data \nsharing between suhjccts is done, as described above.  4.4. Points of Agreement It should be clear from \nthe discussion above that two arbitrary subjects cannot necessarily be composed with any cxpcctation \nthat they will cooperate cffcc-tively. There does need to bc limited agreement be-tween them: . Since \nmultiple subjects can respond to the same operation call, thcrc needs to bc agrccmcnt among subjects \nregarding the operation inter-faces. When an operation is called, all relevant subjects must agree as \nto what operation it is that is being called, and must understand the param-cters. Each subject contains \ndescriptions of the intcrfaccs provided for the classes it defines. De-termining appropriate correspondences \namong interfaces used by cotnposcd subjects is tcrtned interface matching. Since one subject can operate \nupon an object (oid) that another subject has created, there needs to be agreement among subjects regarding \nthe nature of objects. Lath subject contains its own classification hierarchy. Dcterrnining appro-ptiatc \ncorrespondences among classes defined by composed subjects is termed class matching. Interface and class \nmatching stratcgics arc dictated by the composition rule. Various strategies arc possible for interface \nand class matching. The simplest and most rigid requires idcn-tity, agreeing on a set of interfaces and \na set of classes for the whole suite of subjects. Each subject is then written with those global definitions \nin mind. liven this is less restrictive than the classical model, because agreement on classes is really \nonly on class names; each subject is still fret to supply its own state, be-havior and superclass definitions \nfor each class. Nonetheless, identity matching is too rigid to deal with composition of separate subjects \n(like pre-existing applications or applications devclopcd com-pletely separately) that were not written \nto predetermined, global definitions. I hc tnorc flexible matching is, the greater the differences it \ncan cope with, and the more potential there is for composing diverse subjects. Both interface matching \nand class matching are inter-esting and important areas for future research. We do not address interface \nmatching in this paper. The next section discusses a spectrum of possible approaches to class matching. \n  5. Matching Classes Across Subjects Subject-oriented programming can accommodate the real-world s \ncharacteristic that different subjects clas-sify objects in different hierarchies, and that one sub-ject \nmight manipulate objects that another subject has not classified at all. Consider, for example, Figure \n4. The bird classifies objects into plants (nectar-providing plants, insect-providing plants), nestables, \nand predators. The woodsman, on the other hand, classifies objects into nontrees, and trees (hardwood \nand softwood). This classification represents two different ways of looking at an underlying instantiable \nuniverse of pine, maple, cherry, dandelion, woodsman, bird, and object. Often, diagrams of this sort \nare used to illustrate the fact that interface hierarchies are generally not mutu-ally conformable. The \nmost important thing to real-ize about this illustration is that we are dealing here, however, with implementation \nhierarchies. The bird subject defnles state information and methods needed for processing plants (nectar-providing \nplants, insect-providing plants), nestables, and predators. The woodsman subject defines state information \nand methods needed for processing nontrees, and trees (hardwood and softwood). In all examples thus far, \nwe have discussed the inter-action of subjects in a way that presumed all instantiable classes for which \nprocessing is shared across subjects are declared and classified by all sub-jects. This presumption is \nalready less constraining than the classical object model found in language-based O-O technology like \nthat provided by C+ + , which presumes that all classes, not just the instantiable ones, are declared \nand similarly classified by all subjects. However, the constraint is really still too strong to support \nthe degree of independence de-sirable in the composition of a community of sub-jects. Suppose for example, \nas shown in Figure 5, that the bird is familiar with locust trees as well as the others. This may have \nresulted from the release of an enhanced bird and may someday be handled by an enhanced woodsman. But \nin the available world, locusts are known in detail only to the bird. Two sorts of problems arise: the \nsemantics of coop- erative operation implementations and the possibility of direct discovery of objects \nof unknown classes. I,et us take these in turn. 5.1. Cooperative Operations On an Unknown Class When \nsubjects interact in a universe, diffcrcnces be-tween their class hierarchies must bc resolved by the \ncomposition rule. Such resolution is essential to cna-ble each subject s classification of an object \nto bc set correctly at the object s initialization (whether itnme-diate or dcferrcd). If the bird nests \nin a locust, the bird s shared ncstablc behavior will include possible implementations of the make-nest \noperation from the woodsman. In conse-quence, the woodsman will be asked to dispatch this operation on \na locust, a class of which she has no knowledge. One way of resolving this undefined situation is to \nspecify that all such circumstances result in null in-vocations in the subject. In the absence of the \ndis-covery situations discussed next, this is a semantically well-formed, although perhaps unsatis-factory, \ndefinition. It tnerely makes the subject totally blind to objects of that class. I his solution is unsatisfactory \nin that one might ex-pect the woodsman to treat the locust as other trees. But, unless the woodsman has \nsome way to under-stand its tree-ness, she has no way to classify it. In fact, however, we also need \nto develop a stronger solution to treat the cases in which the woodsman is forced deal with a locust \nbccausc she stumbles right over it. 5.2. Discovering Objects Of an Unknown Class In the course of normal \nprocessing, a subject obtains the identity of an object as the result of a function, instance variable \nreference, or operation call on an-other object. If the object is not yet classified by the subject, \nsome determination must be made as to how to classify the object so that the operation can be properly \ndispatched. Such classification will be based on information obtained either directly from one or more \nother subjects or from the interface definit.ions that govern the sharing of objects. Figure 4 -Two Class \nIIierarchies over the Same Instantiable Objects  There are many possible approaches to performing this \nclassification. Exploration of these possibilities is an interesting and important area of research. \nWe begin this exploration by identifying a spectrum of approaches. The near end of the spectrum, explicit \nmatching, is a simple generalization of today s object-oriented repository technology. It acts as a proof \nthat useful solutions exist. From that known point we outline several, more speculative approaches of \nincreasing power: inferred class matching, interface-based class matching, and operational clas- sification. \nDetailed discussion and semantics of these approaches is beyond the scope of this paper.  Explicit \nClass Matching Assume, for example, that the woodsman s class de-finitions can share information with \nthe bird s. WC might assume, that the woodsman s and bird s de&#38; nitions share not only the instantiable \nobjects, but the general superclass object and, in addition, that the bird s insect-plant class and the \nwoodsman s tree class are explicitly matched. Given this knowledge, al-though locust is not known to \nthe woodsman, it is known to be a subclass of insect-plant which is matched with tree which can be used \nby the woodsman to define the behavior for locust. Figure 5 -Two Class IIierarchies over Different Instantiable \nObjects  infevved Class Matching A less preplanned approach is also possible. Although locust is undefined \nin the woodsman s hierarchy, in bird it has both insect-providing plant and nestable as its superclasses. \nWe can determine the set of their instantiable subclasses to be maple. cherry, and pine. These arc also \nall subclasses of the woodsman s tree. Hence, the inference might reasonably be drawn that locusts should \nbe treated as trees. Intevface-Based CIass Matching In the discussion thus far, we have treated all \nof the non-instantiablc classes as though they were com-plete, placing no behavioral or interface constraints \non their subclasses. If, on the other hand, they are what are often called abstract cl~rscr, then declaring \nor inferring that locust is a subclass of tree requires locust to provide certain behaviors. Since these \nbe-haviors are clearly not provided by woodsman, they are required imported behavior. An alternative \nstrategy for inference is to use the interface dcfmitions rather than the implementation hierarchy for \nsuch an inference, even though the result is the determination of an implementation class to be used \nas the object s superclass. The refcrencc to locust was derived with respect to an interface deli-Figure \n6 -Classification Using Interfaces nition. It would be possible, therefore, to select any implementation \nclass that meets the same interface. However, in the presence of a shared base of objects, the relationships \namong the objects becomes a shared property. As discussed before, each subject contains class defmitions, \none aspect of which is the specifica-tion of relationship links (pointers) between objects. These links \nare defined in terms of the interfaces that must be supported by the target object of the link. In the \nworld described by two composed subjects, the target objects must satisfy the union of the interfaces. \nIn fact, the object must satisfy all of the interface constraints imposed by the relationships to it. \nThis implies that in classifying an unknown instantiable class, it must be provided with all of the requisite \nbe-havior. Some behaviors are supplied by one subject and other behaviors by the other, as illustrated \nin Figure 6. Knowledge of the class assigned to the ob-ject in the other subject allows the determination \nof a viable classification for the new class, if one exists. In the example we illustrate how the woodsman \nmay be using an operation called access-neighbors to fol-low the neighbors relationship link from one \ntree to another. The woodsman expects to find an object that implements an interface supporting access-neighbor, \nmake-nest, abandon-nest, and compute-profit. The woodsman actually encounters a locust which she does \nnot know how to classify. But examining the bird s schema elicits the information that access-neighbor, \nmake-nest, and abandon-nest. are provided by the bird. Therefore the locust may safely be clas-sified \nunder tree because tree defines an implementa-for a Discovered Object tion for compute-profit and imports \nimplementations for the others. Opevational Classification The classification strategies described thus \nfar can be thought of as static, in that objects of the same class in one subject always have the same \nclass in other subjects, This need not be so. A subject s classilica-tion of an object could be based \non operational tests made at the time the object is introduced into the subject s classification. For \nexample, if trees all sup-port a wood-density operation, then the woodsman could classify the locust \ntree of Figure 5 as hardwood or softwood rather than simply as tree, and perhaps different subspecies \nof locust would be classified dif-ferently even though birds see them all as locusts. Operational classification \nis one way in which a single class in one subject may correspond to many classes in some other subject. \n6. A Subject Model This section presents a model of subject-oriented programming for definitional and \nexplanatory pur-poses; it is not intended to suggest or constrain im-plementation architecture. Section \n7 discusses means of implementing subject-oriented support efficiently. Components of the model are illustrated \nin the con-text of the tree example in Figure 7. A subject is modelled as a tuplc S = (N, I, I), P) where: \n0 N is a set of class names oids), and a set, SA, of sulject activations, each of which specifics the \nstate associated with each oid by each of the subjects in M. There may be more than one activation of \na subject in the universe. The key characteristic of a universe is that it is a single <III) space; all \nthe subject activations associate state with oids in the same spacc2 This concept of a shared space of \nunique identities for the objects can be .._......_. I..... somewhat limiting. For cxatnplc, it hinders \nthe simple f... Inkme Adkalbn (A) inter-operation of a tool that SCM a highway as a col- 010 lection \nof unidentified lanes and a tool which just sees the lanes in a non-aggregated manner. IIowever, as a \nsimplifying concept it parallels the Knowlcdgc-Hased lrd concept of .standard names or ri<qid designators, \nwhich has been found to bc a useful simplifying assumption me2 in that domain as well [7]. A subject \naclivation, often referred to just as an acti-Figure 7 -A Simple Subject-Oriented Ilniverse vation, \nmodels the actual data manipulated by a par-. ticular subject. It is a tuplc A = (S, T, CT ) where: I \nis a set of interfaces, defining operation signa- tures . S is the szll?jecl . D is a class descriptionfunction, \nwhich maps class 0 7 is the state ,function, which maps oids to names to descriptions of class details, \nincluding structures of addresses of instance variables tna-instance variable declarations and methods. \nnipulated by that subject. The state function is . P is a superclass function, which maps each class \n partial; not all subjects provide state corre-natne to a sequence of class names representing sponding \nto all oids. its immediate superclasses. . C is the ilzstatzce_c~Sunction, which tnaps oids to class \nnames. I hc class name corresponding to an A composition is a tuple (R, Q), where oid is the name of \nthe class that describes, from the point of view of this subject, the state and . R is a composition \nrule, and behavior associated with that oid. Ilie . Q is a sequence of components, each of which can \ninstance-of function is also partial. be either a subject or a subsidiary composition that includes its \nown composition rule. An oldect in a subject-oriented universe is really just As mentioned above, a great \nvariety of composition an object idcntifler (oid), an element of the OZI) set. rules is possible. Formalization \nof such rules is be-Through its I and C: mappings, each subject can as- yond the scope of this paper. \nsociate its own state and behavior with each oid. We deliberately avoid defining an object as the union \nof A subject-oriented universe is a tuple iJ = (M, A), all this state and behavior. where The following \nsections rc-visit sotnc of the discussion . h4 is a composition of subjects. Since nested in the earlier \nSection 3.1, providing more detail andcomposition is supported by the definition provision on certain \ntopics. above, a universe can contain an arbitrarily large tree of subjects. . A = (OiLI, SA) is a universe \nactivation consisting 6.1. Operation Invocation of a global set, Ofi), of object identifiers (called \n2 In some implementations, of course, different subjects may employ different representations for the \noids. 3 Of course, explicit dependencies can arise when one subject explicitly imports behavior from \nanother to realize its function. When an operation ((a, op,p)) is invoked in a subject-oriented universe \n(M, A), where M = (R, Q), it might cause execution of methods in multiple subjects. The composition rules \nin M control what happens with a great degree of freedom. The entire tree Q of subsidiary compositions \nand subjects, in full detail, is potentially available for use by R. As mentioned earlier, one such usage \nis a composition rule called nesting. Nesting treats compositions as scopes, and allows calls to propagate \nbeyond scopes only if specified explicitly. For example: 1. Delegate dispatch of an operation to the \nlowest enclosing composition L, in the tree Q, of the subject whose activation made the call. 2. L performs \ndispatch as described above. 3. In addition, if explicitly specified by L, the oper-ation call is imported \n. This causes the next-higher composition to dispatch the operation also. By successive imports, dispatch \ncan be propagated all the way to the top of the tree, but in their absence, it will be confined to a \nparticular subtree.  6.2. Object Creation and Initialization Within the subject model presented here, \nthe steps involved in object creation and initialization are more precisely: 1. Allocation of an oid \nfrom the OID set. 2. For each subject activation, setting the value of the C function for the new oid, \nspecifying the class to which it belongs in that activation. 3. For each subject activation, allocating \nspace for the state information to be associated with that oid in that activation, and setting the value \nof the T function appropriately. 4. Placing the appropriate initial values in the stor-age allocated. \n Allocation of oids happens globally, and is the re-sponsibility of the universe activation, independent \nof all subjects. The remaining steps come under the control of the composition rule, so many approaches \nare possible. The creation operation specifes the class to be created from the point of view of the activation \nrequesting the creation. However the class to be created for the ob-ject in each other subject is one \nof the issues ad-dressed by the composition rules. As mentioned earlier, the composition rule is also \nresponsible for specifying whether any instance variables are to be shared across subjects. This specification \naffects the allocation of storage and the details of the 7 func-tions; sharing is accomplished by having \nthe results of the 7 functions for different subject activations re-fer to common addresses. 6.3. State \nReferences The addresses of the instance variables that a subject s activation can manipulate arc obtained \nby means of the activation s T function. If I is undefined for the activation cand oid, deferred creation \nand initialization must take place as described above. Tighter encapsulation than that obtained from \nclas-sical object-oriented models is possible because only a the subject s subset of the instance variables \narc ac-cessible to each method.  7. Considerations in Implementing Efficient Subject-Oriented Support \n7.1. Package Sharing Between Subjects The division of processing into a multiplicity of sub-jects should \nnot be presumed to imply high-overhead implementations in which subjects are implcmcnted as separate \nprocesses or threads, in which operation invocation involves interpretive overheads, or in which each \nsubject s representation for an object im-plies a separate invocation of metnory allocation. The problems \ninvolved in resolving these issues efli-ciently are similar to those faced in the implementa-tion of \ninherited characteristics in conventional object-oriented languages. For example, in C + + the instance \ninformation storage requirements of inde-pendent class elements called superclasses are com-bined efficiently; \nsimilarly, in CLOS method combinators present potentially complex dispatching requirements that are solved \neffGently. In efficiently implemented Object-Oriented systems, these potential inefficiencies are resolved \nby a deli-nition processor that uses information derived from the entire class-definition hierarchy to \naggregate and optimize functions across class boundaries. For ex-ample, the C + + compiler uses the declaration \nof the entire class hierarchy to determine the total size needed for an object to hold the instance variables \nin all of its subclasses. Similar techniques can be applied to applications formed from a multiplicity \nof subjects. Processors like that used for OOTIS [lo] employ a language for de-fling the subjects and \ntheir composition so that op-timized allocations and linkages can be created. Using that technology, \nsubjects can be composed into a single application process with competitive operation-call costs. The \nobjects manipulated by the application process contain information for all of the subjects, but are allocated \nin single invocations of the underlying storage allocation mechanism.  7.2. Data Sharing Between Subjects \nThe division of processing into a multiplicity of sub-jects should not be presumed to imply drastically \nin-efficient duplication of state information among subjects concerned with an object. As with the use \nof more conventional object-oriented technologies, when a single organizational provider is defining \nmany classes or subjects, that provider may wish to exploit agreements about the instance variables in \nthe implementation of the classes or subjects. These agreetnents may avoid the cost of duplicating state \ninformation or of indirect accesses. In C + + , for cx-ample, subclasses or friends of a class have direct \nac-cess to public and protected instance information. These agreements take the form of a shared data \nmodel among subjects. Such shared data models are common in support frameworks for integrated appli-cations, \nand mechanisms like the schema deJ?nition set (SDS) and working schema defined in I CTE [24] might be \nused in relating the instance variable deli-nitions provided by different subjects. In general, data \nsharing is specified in composition rules, and can be implemented efficiently by subject compositors \neven if the subjects involved are not developed to-gether. 7.3. Separate OID Spaces In a distributed, \nheterogeneous subject-oriented envi-ronment, one might expect different activations to want to store \ntheir state in different repositories, with each repository having control over its own oids. This seems \nto be at odds with the requirement imposed by the subject-oriented model that all activations in a universe \nshare the same OID space. IIowever, these requirements can be reconciled by an implementation in which \nthe global oids required by the model are implemented as mappings between the separate oids provided \nby the repositories. 7.4. Subject Compositors Composition rules in the model arc abstract spccifi-cations \nof the semantics of inter-subject interactions. A .ruJljecf composilor is a tool that combines subjects \nin an environment according to a certain rule or class of rules. Whcrcas performance is not an issue \nwhen dealing with rules in the model itself, it is very much an issue for compositors. Practical composition \nrules must be capable of efiicient impletnentation, espe-cially in cases of frequent interaction, and \nsubject compositors must be built to ensure high perform-ance. There is no need for a subject compositor \nto be present at run time. It could perform its work stat-ically, generating code or stubs that realize \ninter-subject interaction according to the desired composition rule. An approach of this sort is likely \nto be necessary to achieve high performance. A subject compositor provides definitions for: 1. the specification \nand defaulting rules for method combination 2. the strategies for matching interfaces and classes across \nsubjects 3. the strategies for propagating interactions across compositions (scoping) 4. the packaging \nof subjects into threads, processes and nodes, 5. the packaging of subjects object state informa-tion \ninto databases and local-id spaces.   8. A Software Development Example Using Subjects In this section \nwe present an example to illustrate in concrete terms some of the key features of the subject-oriented \napproach. The example is from the domain of software development environments, and subjects are used \nto accomplish aspects of the tool integration that is recognized as an important need in such environments. \nEach tool is a subject, with its own class hierarchy and definitions for the classes. Figure 8 shows \nthree tools to be eventually integrated together. IIowcvcr, since we wish to present the editing. When \nerrors are discovered or removed, the Syntactic Edltor Project Manager Schedule Trrrcker set-error-status \noperation is called to update the error-status state variable. ImyouIpoallbn Figure 8 -A Software Development \nExample as Subjects gradual enhancement of an environment as an ongo-ing process, we will introduce \nthe tools one at a time. The first subject around which the environment is built is an extended syntactic \neditor, capable of editing system structures, specifications, and code, like that described in [15]. \nAlthough the class structure for such an environment is complex, we will focus on aspects of three classes: \nmodules, includes, and spec-ifications. They are scattered about the class hierarchy because they do \nnot have common implementation structures. Each of these classes has its own rich structure which we \nwill not fully elaborate here, but it is Likely that each will have state of its own, in-cluding relationships \nto objects containing more de-tail. For example, modules will probably have names and will be related \nboth to their includes and to the code for the functions implemented in the module. Includes will probably \nhave names as well, but also relationships to the declarations contained in the in-cludes. Specfications \nmay be unnamed primitive el-ements. For the our example, we will assume that this subject has been in \nuse for some period of time, and the development repository has been populated with large numbers of \nobjects of all sorts. For illustration, we consider the editor s handling of error tracking in more detail. \nThe editor checks on an ongoing basis the correctness of the modules it is Consider, now, a hypothetical \ngeneric project man-agement subject. This tool employs a class hierarchy containing ownable items, a \nsubclass of ownable items called testable items, and a class of objects called points for recording test \nstatus. We wish to compose these two subjects to achieve a system whose syntactically edited modules \nand includes are managed by the gcncric project manager. To do so, we must specify a composition rule \nthat controls how the subjects are to interact. The class hierarchies of the two subjects are quite different, \nwhich is not surprising given the different nature of the subjects. The composition rule must define \nhow objects in the already populated reposi-tory, and any new objects created by the editor, are to be \nmapped to the classes defined in the newly in-troduced subject. I his involves matching of classes across \nsubjects, as discussed in Section 5. Figure indicates this mapping with broken lines across the class \nhierarchies in the several subjects. 130th includes and modules are ownable items, but only the modules \nare testable. One of the ways that class matching among subjects differs from simple multiple inheritance \nis that in the syntactic editor modules and includes have no subclass/superclass relationship - having, \nin fact, different attributes and/or relation- ships. On the other hand, testables are a subclass of \n ownables. So different answers to a subclass/superclass test would be given in the project manager from \nthose in the syntactic editor, even for the same objects. One of the consequences of matching class module \nwith class testable ownable is that any instance of module that existed before the subject composition \ntook place is now also an instance of testable. As such, it has additional operations and instance vari-ables, \nas defined in the project manager subject. Ac-cess to these operations and instance variables is available \nthrough the object s single oid, the same oid it had before the composition. However, the new in-stance \nvariables arc directly accessible only to code within the project manager subject. Subject-oriented programming \nthus includes the ability to expand the operations and state of existing instances. The new state information \nbelonging to the generic project manager needs to be initialized before use, even though this initialization \nmust necessarily take place after creation of the original module object by the editor. The project manager \nsubject is responsible for this initialization; it must compute the appropriate values, perhaps using \ninformation obtained from the human user and from other subjects in the composi-tion via operation call. \nThe project manager and syntactic editor interact on the issue of error-status. The project manager main-tains \nstatus information also, but is concerned with other forms of status than just syntax errors. It therefore \nprovides more general get-status and set-staus operations. The desired semantics for the com-position \nare that the set-error-status operation of the editor correspond to the set-status operation of the project \nmanager, with parameter syntax-error indi-cating the kind of status. This correspondence is an example \nof interface matching, mentioned in Section 5.2. The composition rule either defines this corre-spondence \nexplicitly, or specifies a strategy by which it can be determined. Once it has been established, any \ncall on the editor s set-en-or-status operation re-sults in execution of both the editor s implementation \nof this operation and execution of the project man-ager s implementation of set-status, with the appro-priate \nadditional parameter. This situation involved matching different operations in the different subjects. \nIn many cases, the subjects being combined have similar operational concepts, such as those being developed \nin connection with Case Communique[21], in which case interface matching is trivial. Subject-oriented \nprogramming supports both cases, and includes the ability to have multiple implementations from multiple \nsubjects be executed in response to a single operation call. Finally, we consider the introduction of \na third sub-ject -a schedule tracker. This is a PERT-chart-like application concerned with charts containing \nchart items, indicating planned and actual schedule infor-mation. Dy identifying the schedule tracker \ns chart items with the generic project manager s owned items, we allow the modules and includes to be \norganized into PERT-charts. As with the introduction of the general project manager, no magic applies \nhere; the schedule dependencies must be constructed by the schedule tracker itself. We also identify \nbehavior to be provided for set-status in terms of the PERT-chart s set-futcness. The USC of a sin&#38; \nobject, be it module or include, through the three subjects lends a unity of manipu-lation that makes \nit easier to discuss shared behavior, and makes it possible to add shared behavior without modification \nof the individual subjects. The existing objects acquire more state and behavior as more subjects arc \ninlroduccd into a composition, with the manner in which the state and behavior are combined being governed \nby the composition rule. The com-position rule, or the compositor, also dictate how tightly-coupled the \nsubjects should bc: linked into a single program, distributed with each running on a separate machine, \nor various other options. Good compositor implementation will permit many such options with no change \nneeded to the subjects thctn-selves . Space does not permit detailed discussion of how this example would \nbe handled by conventional ohject-oriented programming. Suflicc it to say that the compositions described, \nif not anticipated by the au-thors of the subjects, could not he achicvcd without source-code tnodilications \nto the individual subjects. 9. Related Work 9.1. Views of Objects Pat-t of the motivation behind subject-orientation \narises from the need for functional-extension within an object paradigm. 1 0 satisfy this need without \nwidespread change and recompilation requires that applications have their own views of data, and do not \ndepend on global definitions. ln l CTI5 [24], each tool (application) runs within the context of a working \nschema, which specifies an or-dered list of schema defirzition sets (SD&#38;). Each SDS defines a model \nof some of the data objects manipu-lated by the tool. An SDS can extend other SD%, such as those describing \nthe views of data seen by other tools. Extensions provide additional types of objects, and additional \nattributes of and relationships among both existing and new types. The subject-oriented models extends \nthis general concept to the operations and methods associated with an object, and to allowing each aubjcct \nto have its own classi-fication hierarchy[ 1 I]. Shilling and Sweeney proposed an object-oriented paradigm \nexploiting views, in which an object is seen through a multiplicity of interfaces to the object [ 181. \nEach interface determines the visibility and sharing of operations and instance variables. The subject-oriented \napproach separates the object inter-face supported by a subject from its implementation, relegating issues \nsuch as the sharing of state to a characterization of the subject s implementation. In addition, subject-orientation \nemphasizes the ability of different subjects to form different behavioral hier-archies over the objects, \nrather than consolidating them within a single class hierarchy. In some ways, mpects of an object as \ndefined by Richardson and Schwarz [17] can be modelled as different subjects providing their own classification \nand categorization of the object. In addition, subjects can provide coordinated aspects for a variety \nof object classes. 9.2. Routing Messages The topic of routing messages from originators to participants \nwithin a suite of integrated tools is ad-dressed in several generic settings:  Field[ 161 Field uses \nmessage passing as a way to connect tools in a software development environment. Aimed pri-marily at \nthe integration of existing tools, Field em-phasizes the use of one-way notifications created by encapsulations \nof the tools. These notifications are broadcast through a message server that delivers them destinations \nthat have registered interest by spetiifying patterns to be matched by the message and its argu-ments. \nThis paradigm is being exploited by others [21] for both event and more general operation de-livery. \nThe subject-oriented model provides a more general setting in which message broadcasts can be seen as \none kind of composition (broadcast), but provides a context for richer connection structures such as \ndirect or nested connections can be estab-lished and intermixed. Tools[ IO] and Toolies[6] The toolies \nmodel emphasizes the direct routing of events that are automatically triggered by updates of data in \na shared colIection of data, and tools em- 4 [23] page 34 phasize the intermix of events and requests. \n130th emphasize a reduction in size and monolithicity of the packages of software that are produced that \ncan ac-crue from sharing a common shared model of struc-tured data rather than bulk file manipulation. \nThe subject-oriented approach continues and extends this direction, emphasizing both the need to retain \nprivate (subject-specific) information about shared data and the need to compose the elements with flcxiblc \npack-aging and dispatching strategies.  9.3. Composition Technology The role of composition, including \ninheritance styles of composition, is increasing in importance, as is the attention being given to describing \nand constraining the compositions. An Object Request Broker as defined by the Object Management Group \n[23] supports objects by routing messages and by interfacing with Object Adapters that actually support \nthe implcmcntations. Object Re-quest Brokers provide support for a uniform rcpre-sentation of oids.4. \nTheir dispatching mechanisms are based on an object registry approach. Subject com-positions, on the \nother hand, perform registry of packaged behavior for a collection of classes at the same time. In addition, \nthe subject concept allows more than one subject to provide state and behavior for the same object. No \nrequirement exists that the oid representation be common across all subjects in a composition. The CORIM \nspccitication provides great latitude for implementations. Within this lati-tude, some manufacturers \nhave provided Object Re-quest Brokers not well suited to support of a subject-oriented methodology, while \nothers have provided more flexible realizations in anticipation of the needs of complex environments. \nThe Object Re-quest Broker is one example of a compositor, but more powerful ones exist as well. Class \ncomposition, as in Jigsaw [ 11, separates inheritance from the troika of encapsulation, polymorphism, \nand inheritance, in effect depicting inheritance as one of several operations by which classes can be \ncomposed. Ilierarchy composition [4, 14, 191 extends this concept to collections of classes. The subject-oricntcd \napproach goes a step further by removing the restriction of having a shared definition of the inheritance \nhierarchy. stnall a package of functionality to play this role. In The frameworks model for object-oriented \ndesign [20] emphasizes the use of abstract classes which are extended to form concrete classes by either \nthe im-plcmentation or re-implementation of some of the operations they define. Well-crafted frameworks \ngreatly facilitate application development in their particular domains, but they are subject to two re-strictions: \n. They can be specializ,ed or extended conveniently only in those areas specifically designed to be extended. \nYet the framework designer cannot anticipate all future extension needs. . Changing or further subclassing \nthe concrete classes leads to invalidation of existing objects. This is especially important when the \nobjects exist in a persistent, shared store or repository. The subject-oriented approach overcomes these \nre-strictions. Much of the work done on methodologies for developing and describing frameworks applies \nto subject-oriented programming as well. Contracts [ 121 provide an abstract way to charactcr-ize the \nbehavioral inter-dependencies among a col-lection of objects. Axiotnatic specifications establish what \nactivities in one object are expected to lead to what activities in other objects. Within the subject-oriented \nmodel, contracts can bc used to characterize the interdependencies among the objects making up a subject. \nThe concept can also be usefully extended to characterizing behavioral interdependcncics among tnultiplc \nsubjects. Where contracts provide an axiomatic characteriza-tion describing and constraining the interaction \nof objects, the law-governed systems approach specifies the detailed semantics of interactions by means \nof a law [13]. As with the contracts model, the same similes can be applied to messages between subjects \nabout an object as can be applied to messages be- tween objects within a subject. In fact, the composi- \ntion rule, R, can be seen as the law of a subject composition, (R, Q). 10. Conclusion The software chip \nis one of the 1101~ Grails of software development. (Holy Grails are somewhat larger than silver bullets). \nObjects and classes have been seen as the software chip [3], but a class is too a sense, objects and \nclasses arc more like circuits, or what the hat&#38;arc designers call macros . We be-lieve that subjects \nare far more likely to play the role of software chips as the next higher-order software building blocks \nin the scqucncc of procedure, class, and subject. In many respects, a subject can be viewed as the softwarc \ncquivalcnt of the hardware micro-chip, with the subject compositor providing a way of manufacturing the \nsoftware equivalent of cir-cuit boards. The suhjcct-oriented approach brings into focus and provides \na model within which to explore a number of important issues associated with software compo-sition: Composition \nrules and compositors Object creation/initialization and finalization/deletion protocols Interface and \nclass matching, leading eventually to matching for applications that USC drastically different models \nof common domains. Implementation issues, including efficiency, dis-tribution and multiple 0111 spaces. \nWe expect the dcveloptncnt of subject compositors to be an important arca of research and development \nover the next few years. The development of a subject compositor along the lines of the one described \nfor OOTIS [IO] is proceeding at IRM s I . .J. Watson Research Center to support the use of a subject-oricntcd \nstyle and to further the exploration of this domain.  References Cl1 Gilad Bracha, Gary I ,indstrom, \nModularity meets Inheritance , I roccedings of the 1992 International Conference on Computer 1 ,an- guages, \n(Oakland), pp. 282-290, April 1992. PI I cter Coad and Edward Yourdon, Ohject-oriented Design , Prentice-I \nIall, Inc., (Englewood Cliffs), 199 1. cv Brad .J. Cox, Object-oriented Programming -An Evolutionary \nApproach , Addison-Wesley Inc., (Reading, Mass.), 1986. William I<. Cook, ,4 Denotational Semantics of \nInheritancr, PhD. thesis, J3rown Ilniversity, 1989. CSIWilliam 1~. Cook, Intcrfaccs and Specifications \nfor the Smalltalk-80 Collection Classes , I ro-ceedings of tfic Confcrcncc on Object-Oriented CA1 Programming: \nSystems, Languages, and Appli- cations, (Vancouver), ACM, October 1992. [6] David Garlan, Gail Kaiser, \nDavid Notkin, IJs-ing Tool Abstraction to Compose Systems , IEEE Computer, pp. 30-38, June 1992. [7] \nM. Genesereth and N. Nilsson, Logical Founda-tions of Artificial Intelligence, Morgan-Kaufmann, 1987. \n[S] William Harrison and Ilarold Osshcr, Extension-by-addition: Building extensible software , IBM Research \nReport RC 16127, IBM Thomas J. Watson Research Center, Yorktown Heights, NY, September 1990. [9] William \nHarrison and IIarold Ossher, CI,ORIS: A clustered object-relational information store , Proceedings of \nthe Experts Meeting on Object Oriented Computed Research and Development, Information Technology Research \nCentre, Toronto, May 1991. [lo] William Harrison, Mansour Kavianpour, and Harold Ossher, Integrating \nCoarse-grained and Fine-grained Tool Integration , Proceedings of Fifth International Workshop on Computer-Aided \nSoftware Engineering, July 1992. [ 111 William Harrison, Harold Ossher, and Mansour Kavianpour, PCTE \nSDS s For Modelling OOTIS Control Integration , Proceedings of the I CTE 93 Conference, PCTE Interface \nManagc-ment Board, November 1993. [12] Richard Helm, Ian Holland, and Dipayan Gangopadhyay, Contracts: \nSpecifying Behav-ioral Compositions in Object-Oriented Systems , Proceedings of the Conference on Object-Oriented \nProgramming: Systems, Ian-guages, and Applications, (Vancouver), ACM, October 1990. [ 131Naftaly Minsky \nand David Rozenshtein, A Law-Based Approach to Object-Oriented I ro-gramming , Proceedings of the Conference \non Object-Oriented Programming: Systems, Lan-guages, and Applications, ACM, October 1987. [ 143 Harold \nOssher and William Ilarrison, Combi-nation of Inheritance IIierarchies , Proceedings of the Conference \non Object-Oriented I rogram-ming: Systems, I .anguagcs, and Applications, (Vancouver), ACM, October 1992. \n [ 1 S] I Iarold Osshcr and William I Iarrison, Support for Change in R1 DI1l , I rocecdings of the I:ourth \nACM SIGSOI; I Symposium on Soft-wart Devclopmcnt Environments, pp. 2 I X-228, Irvine CA, Dcccmhcr 1990 \n[16] S. Rciss, Connecting l ools lJsing Message Passing in the Field I~nvironmcnt , IlJliI Soft-ware, \npp. 57-66, July 1990. [ 171 Joel Richardson and I etcr Schwarz, Aspects: Extending Objects to Support \nMultiple Inde-pendent Roles , I rocccdings of the 1991 ACM SIGMOD Confcrcncc, May 1991, 1)cnvcr CO, pp. \n298-307. [IS] John Shilling and I ctcr Swccncy, I hrce steps to views: I(xtcnding the object-oricntcd \nparadigm , I rocccdings of the Confercncc on Object-Oriented Programming: Systems, I ,an- guagcs, and \nApplications, (New Orleans), pp. 353-361, ACM, October 1989. [19] Alan Wills, Capsules and types in \nI;rcsco! , In I icrre America (cd), Proceedings of the 5th European Confcrcnce on Object Oriented I ro-gramming \n(13COOF 91), Springer, I99 1. [20] Rebecca Wirfs-ljrock and Ralph .Johnson, Current Research in Object-Oricntcd \nDesign , Communications of the ACM, pp. 104- 124, ACM, Scptcmbcr 1990. r211 -, Achieving Agreement , \nCast Communiqu&#38;, 3404 I Iarmony Road, ITort Collins CO, June 1992 [22] -, Object Management Architecture \nGuide, OMG J1ocument 92. I 1.1, Ohjcct Management Group, Septcmbcr 1992. [23] -, Common Object Request \n13roker Architec-turc and Specification, OMG Document 9 I. 12.1, Object Management Group, Dcccmbcr, 1991. \n[24] -, Portable Common 1 001 Ilnvironment (I C I I~), Standard ECMA-149, ISuropean Com-putcr Manufacturers \nAssociation, Dcccrnber 1990. \n\t\t\t", "proc_id": "165854", "abstract": "", "authors": [{"name": "William Harrison", "author_profile_id": "81385594269", "affiliation": "", "person_id": "PP39077552", "email_address": "", "orcid_id": ""}, {"name": "Harold Ossher", "author_profile_id": "81100333974", "affiliation": "", "person_id": "PP39038143", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/165854.165932", "year": "1993", "article_id": "165932", "conference": "OOPSLA", "title": "Subject-oriented programming: a critique of pure objects", "url": "http://dl.acm.org/citation.cfm?id=165932"}