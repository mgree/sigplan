{"article_publication_date": "10-01-1993", "fulltext": "\n Building and Maintainin Analysis-Level Class Hierarc Bies Using Galois Lattices Robert Godin, Hafedh \nMili Departement de Mathematiques et d lnformatique Universitt?du Quebec a Montreal Case Postale 8888 \n(A) Mont&#38;al, PQ H3C 3P8 CANADA  Abstract Software reuse is one of the most advertised advantages \nof object-orientation. Inheritance, in all its forms, plays an important part in achieving greater reuse, \nat all stages of development. Class hierarchies start taking shape at the analysis level, where classes \nthat share application-significant data and application-meaningful external behavior are grouped under \nmore general classes. At the design level, such hierarchies are augmented with imple-mentation classes, \nand possibly reorganized to take into account implementation factors such as perfor- mance or code reuse \n[Rumbaugh9 la]. Getting the analysis-level hierarchy right is very important for the understandability \nand traceability of the models and the reusability of the resulting code [Rumbaugh9la]. In this paper, \nwe propose a formal method that organizes a set of class interfaces into a lattice structure called Galois \nLattice [Godin86a]. Such a lattice has several advantages including: 1) embodying protocol conformance, \n2) supporting an incremental updating algorithm [Godin93a]), with applications for class hierarchy maintenance. \nWe first present the basic method and illustrate its use through an example inspired from [Cook92a]. \nNext, we discuss extensions to the method to take into account richer class descriptions in general, \nand the specifics of 00 analysis-level models. Finally, we discuss some of the research directions we \nare currently pursuing. Permission to copy without fee all or part of this material is granted provided \nthat the copies ara not made or distributed for direct commercial advantage, the ACM copyright notice \nand the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. g 1993 ACM 0-89791-587-9/93/0009/0394...$1.50  1. Introduction Several tenets of \nobject-orientation make 00 software more reusable: 1) information hiding, which shields clients (objects, \nmodules) from imple- mentation changes in servers, 2) generic@ and overloading, which parametrize functionality, \nby abstracting out some type-dependencies, and 3) inheritance, which provides a conceptual framework \n(and a language construct) for reusing software components. Inheritance, plays an important part in achieving \ngreater reuse, at all stages of development. Class hierarchies start taking shape at the analysis level, \nwhere classes that share application-significant data and application-meaningful external behavior are \ngrouped under more general classes. Identifying generalizations of classes at this level has several \nadvantages including: bility of the models independent concepts with, 2) providing tionaries to enforce \nand 3) identifying 1) enhancing the undcrstanda- by reducing the number of that a analyst/user has to \ndeal a crosrs:-check with data dic-consistency within the model, opportunities for code reuse [Wirfs-Brock90a,Rumbaugh91a. \nCoad9lal. The latter is justilied by the intuitive realization that similar requirements in terms of \nexternal behaviors- an analysis-level product--generally lead to similar implementations. In this paper, \nwe propose a family of methods that organize classes within a lattice based on the specification of their \ninterfaces. Existing 00 development methodologies (see e.g. [Rumbaugh9 1 a, Wirfs-Brock90a, Coad9 la]) \nprescribe that design builds on the basic class struc- ture identified at the analysis level--one aspect \nof the much vaunted seamless transition--by adding high level (control) and low level (utility) OOPSLA \n93, pp. 394-410 394 application-independent classes. Methodologists recognize that in some cases, some \nrestructuring of the basic application classes may be warranted to accommodate some implementation-level \nconcerns such as performance and code reuse. They also sug- gest looking into other alternatives to inheritance \n(e.g. delegation) that achieve the same goals [Rumbaugh91a]. A number of researchers have observed that \nexisting class hierarchies do not always make sense (see e.g. [Cox90a, Cook92al). Cook thoroughly studied \nSmalltalk40 s collection classes and found a number of discrepancies between the protocols that classes \nimplement and their place in the code class hierarchy. He explains the discrepancy by the fact that the \n(code) class hierarchy presents the implementers view of the class library, while the protocol hierarchy \npresents the clients view 1 [ Cook92al. In [Cox90a], Brad Cox studied a commercial class library and \ndwelled on the extent to which the place of some classes in the hierarchy did not make sense: I... Semaphores \nare a kind of Queue only from the arcane viewpoint of their author. This hierarchy resulted from a speed \noptimization of no interest to consumers, who should view as scheduling primitives with only wait and \nsignal methods [Cox90a]. In both cases, a reuser/user of the class library is a client who approaches \nthe class library more from a requirements (analysis-level) point of view than from an implementation \npoint of view. While design and implementation efficiency may, in some cases, supersedes semantic/conceptual \nclarity, we believe that unnatural class (code) hierarchies often result from poor design choices, as \nin using inheritance when delegation is more appropriate [Rumbaugh9la], or in poor analysis-level classification, \ni.e., all implementation charac- 1. This is possible in Smalltalk because it is untyped and because a \nclass can cancel methods inherited from its superclasses (simply by redefining them to raise exceptions \nwhen they are invoked). tetistics equal (e.g. space requirements, time perfor- mance), a better class \nhierarchy could have been devised that achieves the same or a higher level of code reuse, with less cancellations, \nredefinitions, etc. Cook showed that Smalltalk s Collection class hierarchy can be improved-- semantically--with \nno additional implementation costs [Cook92a]. Despite the importance of the analysis-level hierarchical \norganization of classes on the 00 development lifecycle, and the long-established research tradition \nin classihcation in artificial intelli- gence, there have been notably few efforts to pro-vide automated \nor semi-automated tools for building or maintaining class hierarchies. One such effort is part of the \nDemeter System, and involves the automatic discovery of classes from example objects, and the hierarchical \norganization of those classes [Bergstein a]. They propose a two-step learning algorithm, where the second \nstep, called the minimi- zation step, consists of factoring out the common parts in a way that optimizes \nsome structural pro-perties of the class dictionary graph [Bergstcin9la]. The concept of Galois lattice \ncan be seen as a sim- ple and elegant framework for dealing with the minimization step. Further, their \nmethod takes into account only data attributes--no behaviors. Cook used automatically extracted interface \ndescriptions of the Smalltalk collection classes to build an inter-face hierarchy based on interface \nconformance [Cook92a]. Other work addressed issues of class hierarchy maintenance, for example when new \nclasses are added and new generalizations emerge (see e.g. [Pcdersen89a,Gibbs90a, Bergstcin9la1, and \nto some extent [Ossher92a]), or when new methods are added to existing classes [Li89a,Ossher92a]. Such \nreorganization/maintenance methods incur local changes that plug unto existing hierarchies, although \nthe underlying restructuring principles may-- modulo some changes--be used to build hierarchies from \nscratch. The family of conceptual structures presented in this paper subsumes the ones used by Cook [Cook92a] \nand has interesting computational properties. In section 2, we describe the basic method used to gencratc \nGalois lattices from class intcr-faces. We illustrate the method using a subset of the collection classes \nused by Cook [Cook92a]. In sec- tion 3, we describe extensions to the basic method that take into account \nricher class descriptions and application domain knowledge, thereby refining the classification. We conclude \nin section by summariz- ing the findings of the paper and discussing some research directions we are \ncurrently exploring.  2. Buildin a Galois Lattice of Class Protoco Ifs The use of Galois* lattices as \na model of con-ceptual hierarchies has been first introduced by Wille [Wille82a]. He used the Galois \nlattice of a binary relation between a set of instances and a set of features, as a basis for what he \ncalled formal con-cept analysis [Wille82a]. The Galois lattice of a binary relation between instances \nand features may be considered as an (extensional) class hierarchy where each node of the lattice represents \na class in terms of: 1) the set of its instances, and 2) the set of shared features between its instances. \nSuch lattices have been used for a variety of applications, includ-ing conceptual distance measurements \n[Ganter86a], and document classification and browsing [Godin86a, Godin93al. Building such lattices incre- \nmentally may be likened to a process of learning or concept formation [GennariBOa]. We developed one \nsuch algorithm that incrementally generates/augments the Galois lattice and its Hasse diagram with an \naverage case complexity of O(n), where n is the number of instances [Godin91a]. For reference, we illustrate \nthe basic method and some flavors thereof on an example based on [Cook92a]. We describe the full Galois \nlattice in section 2.1. Two refinements are discussed in sections 2.2 and 2.3 to the extent that they \nrelate to protocol hierar-chies and class design. 2. Galois is a French mathematician of the early 20th \ncentury, who died, presumably, in a duel for the love of a young lady. 2.1. The Galois Lattice of a \nBinary Relation Consider two finite sets E (set of instances) and E (set of features), and a binary relation \nR between the two. Among all the subsets X of E, only a few satisfy the property: x= (-) R- (Y) Y E n \nR(x)XE x where R(x) (R- (y)) is the set of images (antecedents) of x (y) by R. The same is true for \nsubsets of E , where we interchange R and R-l, and there is a one-to-one correspondence between the two. \nRoughly speaking, the Galois lattice of R is defined by the subset relation between those subsets of \nE (E ) that satisfy the above property. Consider the binary relation represented by the boolean matrix \nin Figure 1. In this case, the set E (columns) correspond to classes and the set E corresponds to the \noperations/methods supported by any one of those classes. The set of classes is a subset of the Smalltalk-TM \nCollection classes that were studied by Cook in [Cook92a]. A sufficient subset of methods was chosen \nin order to relate the resulting structure to that given in [Cook92a]. For a given class, the protocol \nconsists of the names of the operations (or message selectors) supported by the class3. Figure 2 shows \nthe corresponding Galois lat- tice. Only the uppercase letters for the class names appear in the Figure. \nTM. Smalltalk-is a trademark of ParcPlace. 3. Smalltalk-80 s keyword notation for methods with parameters \nwas not respected for clarity. For exam-ple, atPut should read atzput:, or, at: anIndex put:anObject. \n Figure 1. Matrix representation of a binary relation R. Each element of the lattice is a pair-- called \nconcept by Wille [Wille82a]-- (X,X ), where X c_ E, X E E , and: 1) X = f(X), where f(X) = {x E E ] V \nx E X, (x,x ) E R) = n R(x), and XE x 2) X = f (X ), where f (X ) = [x E E ] V x E X , (x,x ) E R) = \nn R- (x ) X E X We say in this case that (X,X ) is complete. Only maximally extended pairs are kept \nin the lattice. A set X c E is considered to not be maximally extended if there are other instances (elements \nof E), that are not in X, but that are nevertheless described by all the features common to all the elements \nof X; X must be extended to include such instances. Con-versely, if X does not contain a feature x that \nis shared by all of the elements of X, then it has to be extended to include x . The pair of functions \n(f,f ) represents a Galois connection between the power set of E (2E) and the power set of E (2E ). The \nGalois lattice G for the relation R is the set of com- plete pairs related by the partial order defined \nas fol- lows: Let C, = (X1,X ,) and C2 = (X2,X *), we have: c, < c* = X 1 G X 2. Notice that the functions \nf and f are monotonically decreasing in the sense that: X , c X z t* x, E x, and thus: c, < c2 s x2 \nc x1  (tCA,D,LL,B,S,SCl, (isEmpty, size, includes]) ((&#38;W-LSCI, WWLWI, (isEmpty,size,includes,at)) \n(isEmpty,size,includes,add]) ((ADI, (IDJ-LI, (IW-LW, (IDS), (ULB,S), (isEmpty,size, (isEmpty,size, (isEmpty,size, \n(isEmpty,size, (isEmpty,size, includes,at, includes,at, incl.udes,at, includes,add, includes,add, aw \n1) add)) t,last})firs1 minus J) remove)) I I (IA), (IDI, (IS19 t(B), (isEmpty,size, { isEmpty,size, (isEmpty,size, \n(isEmpty,size, includesgt, includes,at, includes,add, includesadd, atput,atAllF ut, atput,add, minus, \nremove, first,last]) minus, remove)) addWithOccurrences)) keys ,values ) ) (all methods)) Figure 2. \nGalois lattice for the relation in Figure 1. The Hasse diagram of the partial order c is gen- elements \nin C. erated as follows: we create an edge between C, Each pair represents a set of classes with their \nand CZ, if Ci c CZ, and if there is no other element common protocol and the Hasse diagram C3 in the \nlattice such that Ci < C3 c C2. In other corresponds to the conformance relationship as words, we create \nan edge between Ci and C2 if CZ is defined by the inclusion of the sets of message the smallest pair \nthat is bigger than Ci. When selectors understood/supported by the classes drawing a Hasse diagram, the \nedge direction is Modulo some differences--to be [Cook92a]. downwards. Given, C, a set of elements from \nG, explained below--, the Galois lattice is closely inf(C) and sup(C) will denote respectively the related \nto the protocol hierarchy defined in greatest lower bound and lowest upper bound of the [Cook92a]. That \nhierarchy was used as a tool for analyzing and discovering inconsistencies in an existing class library. \nWe suggest that such a hierarchy/lattice be generated before class design and implementation based on \nthe operations that we wish the classes to support, and perhaps try harder to make the implementation \nhierarchy fit in the proto- col hierarchy to avoid the kinds of problems dis-cussed in [ Cook92al. Notice \nthat while the number of subsets of E is exponential in the size of E, provided that the number of features \nper instance (i.e. cardinal@ of R(x)) is bounded-- which is usually the case in prac- tical applications--, \nthe worst case complexity of the structure is linearly bounded with respect to the number of instances \n(size of E) [Godin86a]. Further, we developed incremental algorithms for updating the structure, either \nby adding/removing instances, or by adding/removing features to existing instances. In our case, this \nwould correspond to incorporating new classes in the protocol hierarchy, or adding/removing operations \nto existing classes. Empirical data presented in [Godin9la] showed that adding a new instance takes O(n) \ntime, where n is the number of existing instances. Under the assumption of a fixed upper bound on the \nnumber of features per instance, this is also confirmed by a complexity analysis of the algorithm. 2.2. \nInheritance Galois Lattice There is much redundant information in a Galois lattice. For a pair C= (X, \nX ), X will be present in every ancestor of C and symmetrically, X will appear in every descendant. The \ninherited (redundant) elements may therefore be eliminated without losing any information. For a pair \nC = (X, X ), let X be the set of elements in X that do not appear in any ancestor of X, and X the set \nof ele- ments of X that do not appear in any descendant of X . The reader can check that, for a given \ncomplete pair (X,X ), X and X are defined as follows: * X = ( XE EIR(x)=X } * X 33 = { x E E 1 R- (x \n) = X) Figure 3 shows the lattice of Figure 2 where the nodes contain the pairs (X ,X ) instead of the \npairs (X,X ). We calI this lattice an inheritance Galois lattice. Notice that for a node C, the corresponding \nvalues of (X,X ) can be recovered from the pairs (X ,X ) by taking the union of the X (respectively X \n) sets for the descendants (respectively ancestors) of C, including C itself. Depending on the application \nand on time versus space requirements, these structures may be considered as an alternative to the full \nGalois lattice representation. The representation used in [Cook92a] is based on the inheritance Galois \nlattice. For a given node, the inheritance Galois lattice shows explicitly only the message selectors \nthat are not inherited from the parent nodes, and that are specific to the set of classes represented \nby that node. This may help clarify the concept represented by the node. For example, the node (Q,{at)) \ncan be inter- preted as the set of collections whose elements can be accessed by position/index. We may \ncall these Indexed Collections. Notice that a node with a pair (a, X ) corresponds to the case where \nno class exists that implements exactly the operations in X and the node s ancestors. In other words, \nthere are no objects/instances in the application that will respond to only those messages. Accordingly, \nsuch a node can be considered to represent an abstract class. Figure 4 shows the named nodes, where we \nused the names in [Cook92a].  2.3. The Galois Knowledge Space (KS) There remains an interesting difference \nbetween our lattice and that in Cook [Cook92a]: the node IndexedExtensibleCollection. Such a node has \nthe peculiar property that both X and X are empty. It means that it represents an abstract class in \nthe sense described above. Further, it does not add/introduce any operation that is not inherited from \nthe ancestors. In some applications, such nodes are of no interest. (a* (( Sequenceable, @? w? (atput)) \nCollection], (minds)) (remove) ) ((Arwl, ([Dictionary}, ( ( LinkedList ] , WagI, IatAllPut)) (keys,values)) \n(addFirst, addWithOccurrences)) Figure 3. Inheritance Galois lattice. Eliminating such nodes ( bypassing \nthem in the lat- 2) with the appropriate names--may be more reveal-tice) yields what we called a knowledge \nspace ing. For example, it may be argued that the node (KS)4, and has been used in the more general con-IndexedExtensibleCollection \nenhances our under-text of conceptual clustering of conceptual graphs standing of what Dictionary and \nLinkedList do, [Mineau90a]. For the sake of illustration, the result- and highlights a similarity between \nthe two that ing hierarchy is shown in Figure 5, which coincides would otherwise require more thorough \nnavigation with that in [Cook92a]. in the knowledge space. Second, in anticipation of future amendements/extensions \nto the class hierar- Whether such nodes (i.e. (a,@)) should be deleted from the inheritance Galois lattice \nis actually chy, such a generalization may be worth keeping. debatable. First, as a model of the application \ndomain, the full inheritance Galois lattice (Figure 4)--or for that matter the full Galois lattice (Figure \n4. We developed an incremental algorithm that gen-erates the knawledge space directly, rather than going \nthrough the Galois lattice first [Godin93a]. Updatable Collection (a, (I~ayl, (atAWut )) Indexed Collection \n(at)) Indexed Extensible Collection W. ((Dictionary], (keys,values)) Figure 4. Inheritance Indexed Collectio \n(@P  Extensible Collection ({ Sequenceable, Collection), { first,last]) ({ LinkedList), (addFirst, \n(add)) Subtractable Collection (@9 (ISet), 0) Galois lattice with abstract class names ({ Sequenceabl \n, Collection), (first,last)) Removable  Collection (Q ((Bag). addWithOccurrences): Extensible Collectio \n(0,. t Subtractable Removable Collection Collection PR (09 [ minhs]) (remove)) I I Figure 5. Inheritance \nknowledge space for the relation in Figure 1. Figure 6-a. Implementing an inheritance Galois lattice \nwith single inheritance Figure 6-b. Implementing a knowledge space (KS) with single inheritance Figure \n6. Keeping (CD,@) pairs reduces the amount of duplication during design. Notice that neither justification \nwould necessarily As it turns out, design issues may actually be compel us to implement such a class: \nwe could the most compelling reasons to keep such nodes. For prescribe that the full inheritance Galois \nlattice be instance, in languages that do not support multiple kept at the analysis level for the sake \nof understan- inheritance, some methods will have to be imple-dability, but that it should be streamlined \nat the mented at least twice. Such nodes may be rcquircd design stage. to reduce the amount of duplication. \nFigures 6-a and 6-b illustrate this point. In Figure 6-a, a decision was made to detach D from C, and \nreimplement C s methods (0, and 0,). Such a decision may be based on the (anticipated) relative complexity \nof (O,,O,) with respect to (O,,O,). In Figure 6-b, we showed one of three possibilities, each of which \nwould result in reimplementing/duplicating 4 methods (or 2 methods twice).  3. Using Richer Class Descriptions \nThe description of classes used by the method presented in the previous section consisted simply of a \nlist of items. The fact that these items corresponded to method names had no bearing on the technique. \nWe could have used data attributes instead, or both. Some OOA methodologies suggest using associations \nas additional criteria for classification (see e.g. [Rumbaugh91 a, Bergstein9lal). Using the appropri- \nate notation, associations could also be included in the descriptions of classes, and used for classificatior+. \nHowever, the classification method--as presented-- implicitly assumes straight inheritance along the \npaths of the lattice. In particular, it does not handle explicitly cases where methods may have to be \nredefined/refined at lower levels and ultimately require separate--if only partial-- implementations. \nWe cannot consider such methods as completely different, for otherwise we miss a useful abstraction. \nAt the same time, they could not be considered equal, and some of the operations performed to derive \nthe inheritance Galois lattice and knowledge space may no longer be justified. Actually, this is one \ninstance of the more general problem where a partial order relation exists between descriptors themselves. \nWe describe the changes needed to the basic method to take advantage of ;his relationship in discovering \nuseful abstractions. 5. In fact, come implementation time, the three may not be distinguishable: 1) access \nmethods are needed for both the stored (e.g. birthdate) and the computed (e.g. age) instance variables, \n2) some computationally costly methods may store their results, and 3) some associations may be implemented \nas instance vari-ables or as methods [Rumbaugh91 .x1. 3.1. Using Partial Order Relations Between Class \nDescriptors For the sake of illustration, we use an example from the procedural world where we take multi-faceted \ndescriptions of software procedures [Prieto-Diaz87al. For our purposes, the facets are only important \nto the extent that they define a domain of comparable values. In an actual class description problem, \nif operations are given by their signatures, operations with the same name will be compared using signature \nconformance relationships as in [Meyer88a]. If operations are given by formal rela- tional specifications, \nthen we may compare specifications whose domains have a non-empty intersection. And so forth. Consider \n5 software components, numbered 1 through 5, described by three properties (or facets [Prieto-Diaz87al): \n1) Function, describing the pur-pose of the procedure, 2) Object, indicating the main data object transformed/operated \non by the pro-cedure, and 3) Medium, description the medium in which the object resides while being manipulated. \nFigure 7 shows the values of the facets for the 5 components. The corresponding full Galois lattice is \nshown below (Figure 8). :{3}, [F:mergesor;, ((4],(F:print, O:string, O:string, M:file)) M:file)) Figure \n8. Full Galois lattice based on Figure 7. The bottom of the lattice (0, <union of leaf nodes>) is not \nshown. FUNCTION OBJECT or MEDIUM A ti&#38; number/\\ x match search verify quicksort heapsort mergesort \nreal integer set array file I I string Figure 9. Partial order relations between facet values. The lattice \nin Figure 8 shows a few useful abstrac-tions. If we knew the relations between the values of the facets \nthat are shown in Figure 9, we could iden- tify a useful abstraction between components 1 and 2, which \ncorresponds to sorting arrays. Further, both 1 and 5 operate on arrays of numbers. We define a partial \norder c between facet-value pairs, noted facet:value , as follows: (f,:t < f2:t ) t) [(fi = fi> A (t \nLT t )] where LT is the partial order between values. Refer- ring to Figure 9, we have: Function:quicksort \n< Function:sort . By contrast, no relation exists between Function:quicksort and Function:print , or \nbetween Function:print and Medium:file . Using this definition, we induce from the relation R that relates \na component to a facet:value pair, a new relation R+ defined as follows: (x,x ) E R+ = (3 y ) [(y I x \n) A ( (x,y ) E R )] In other words x is related to x by R+ if one of its descendants is related to x \nby R, i.e., one of its des- cendants is a facet:value pair for the component x. For example, (1, Function:sort \n) belong to R+, because Function:quicksort , a descendant of Function:sort , is a facet:value pair of \ncomponent 1. ;( 1,2,3],{M:collection, :11,2S),IM:arwl) ~(2,3,4),(0:string))F:sort]) .( 1,5), (O:number, \n.( 1,2), [F:sort, ({2,3), (Fsort, ((3,4),(O:string,M:fileJ) M:array)) Marray)) O:string, Figure 10. New \nlattice using partial order relations between facet values. The new lattice consists of (X,X ) pairs \nwhere: 1) X = f(X) = (x E E 1 (tl x E X), (x,x ) E R+), and (3 7 y ) s.t. y < x , and for all x t= X, \n(x,y > E R+l 2) X = f (X ) = { x E E 1 It x E X , (x,x ) E R+l With regard to f(X), notice that of all \nthe elements of E that are related (through R+) to every single element of x, we keep only the smallest \nones. In particular, if all the elements of X have one facet:value pair in common, only that pair will \nappear in X , and none of its ancestors. Figure 10 shows the new lattice. Compared to Figure 8, four \nnew abstractions were created: ( 1,2,3}, to sort collections, (2,3), to sort collections of strings, \non arrays when we 2.2 and { 1,2), to sort arrays, and [ 1,5), to operate of numbers. The reader may check \nthat apply the reduction techniques of sections 2.3, only { 1,2,3} survives in the final knowledge space. \n 3.2. Examples 3.2.1. Refining Instance Variables Unlike methods, in most OOP languages, instance variables \nare inherited as is: they may not be redefined6. Most knowledge representation languages support a number \nof partial order relation- ships between concepts attributes [Mili92a], among which value restriction \nand specialization. For example, belonging Teenager interval the class Person may define Age as to the \ninterval O..lOO. The subclass may restrict the values of Age to the 13..19. Similarly, a class Organiza- \n6. In Eiffel. attributes may be renamed by subclasses [Meyer88a]. tionalunit may have a property called \nLeading Officer , and a subclass may refine that to Chairperson , Director , Chief Executive Officer \n, etc, all of which are specializations of Leading Officer . In knowledge representation languages, the \nsame semantics would be used to represent specialization between properties (slots) as that between conceptsV7 \n(see e.g. KL-ONE [Brachman85a]). At the 00 analysis level, we are typically dealing with application \ndomain knowledge, the kind for which such nuances are significant to the user/analyst. Short of allowing \nfor such a flexibility in modeling, and providing the required application domain knowledge base to back \nit up, we have to either: 1) push nomenclature standardization to ridi- culous limits to make sure that \ncommon abstractions are properly factored out, or 2) forgo opportunities for useful generalizations. \nComes the design and implementation level, value restriction can be enforced via a redefinition of the \naccess methods. In the Age example, we simply redefine setAge() to reject arguments outside the [ 13..19] \ninterval, reduc- ing this case to the next (method conformance). As for specialization, we could rename \nboth the instance variables and their access methods, d la Eiffel [Meyer88a], or, if the language does \nnot support it, simply provide additional access methods within subclasses that would have more significant \nnames. 3.2.2. Method Conformance With methods, a range of partial orders may be defined, depending on \nthe formalism used to specify the methods, and on the knowledge/tools available to the classification \ntool. If methods are specified sim-ply by their--presumably domain-meaningful--names, an explicit taxonomy \nof domain tasks would need to be referenced by the classification tool to identify conformance relationships. \nSuch a taxon- omy might identify, e.g., computeWeeklyPay as a special case of computePay . If methods \nare specified by their signatures, conformance may be 7. with interesting implications, such as the circularity \nand hence undecidability of classification! defined by covariance. In this case, the classification \ntool tests methods that have the same name for con- formance, and will OdY test those. The subtype/subclass \nrelationships between method argu-ments could be either available explicitly, or com-puted. If pre-conditions \nand post-conditions are used, some sort of a theorem prover would be needed to establish implication \nrelationships between pre/post-conditions8. Naturally, the richer the specification technique/language \nused, the more reli- able are the generalizations, and the more complex is the process of establishing \nthem. It is worth pointing out that when conformance relations between methods have to be computed on \nthe fly , computing the pairs of sets (X,X ) for the Galois lattice (more specifically, the set X , see \n9 3.1) involves computing the lowest upper bound of a set of methods. Interestingly, Mili et al. have \ndeveloped an algorithm that organizes a set of rela- tional specifications into a lattice [Mili92b]. \nSuch a lattice would have to be made available to our Galois lattice generation algorithm before the \norgani- zation of classes can proceed. 3.2.3. Associations A number of 00 development methodologies \nprescribe mat associations (conceptual relationships) be both: 1) used as criteria for generalization \n(to the same degree that attributes and methods do), and 2) be subject to generalization (see e.g. [Wirfs-BrockgOa, \nRumbaughgla, Bergsteingla]). We wish to qualify the first statement by restricting this to what we call \ndefining associations such as aggrega- tion, as in [Bergstein91a], associations involving 8. In Eiffel, \nthe covariance of pre/post-conditions, if we may call it that way, does not require proving be- cause \nof the way the compiler treats the pre- conditions (require clause) and post-conditions (en- sure clause): \n1) pre-conditions are implicitly ORed with those from the inherited version, and 2) post- conditions \nare implicitly ANDed with those from the inherited version [Meyer88a]. Such a strategy would not work \nin our case, because we don t know that the method redefines/refines an inherited version; that is what \nwe try to establish!  PERSON name address CAR Figure 11. Generalizing conceptual graphs. Transaction \nValue Purchase .ANDLORD name address Figure 12. A case of circular generalization. existential dependencies, \nand intrinsic constraints [Mili90a]. In one application, the method presented in section 2 has been extended \nto handle concepts represented as conceptual graphs [Mineau90a]. Such an algorithm is capable of generating \nthe gen- eralization shown in Figure 11. Notice that in the resulting lattice , all three associations \nare kept. An inheritance lattice of conceptual graphs [Godin93a] would eliminate the redundant OWNS associations \nbetween Tenant and Landlord on one hand, and Car in the other. Consider now the trickier case of Figure \n12, where we used Rumbaugh s object model notation. The target generalization is shown in Figure 13. \nHowever, such a generalization cannot systemati-cally be obtained from the method shown in Q 3.1. For \ninstance, while the similarity between Tenant and Landlord is sufficient to suggest the parent con- cept \nPerson, the common generalizations between the attributes of the associations (see [Rumbaugh91a]) are \nnot sufficient to suggest the generalization of the Lease and Acquisition associa-tions to the Housing \nTransaction association: asso-ciations are first and foremost defined by the classes they relate. Thus, \nprior to establishing that Tenant and Landlord generalize to Person, we cannot say that Lease and Acquisition \ngeneralize to Housing  Transaction. PERSON name address Trans. value Effect. start. I . HOUSE A I \n r----L:-------~ TENANT I II I I I I I I I I I I ANDLOR A2QSUISITIO ~ Purch. price Date acqui  ITI \nI I This is another instance of the more general problem of circular classification, often encoun-tered \nin knowledge representation languages [Lipkis82a]: classification is expressed in terms of equivalence \nof logical expressions whose truth values can be established through classification. The consequences \nof such circularity go from undeci-dability to unpredictability. In this case, if the lattice generation \nmethod happens to generalize Tenant and Landlord first, then Lease and Acquisition will be properly generalized. \nA more serious problem occurs if we could not generalize Tenant and Land-lord without generalizing the \ncorresponding associa-tions9. We had to amend the algorithm for concep- tual graphs by revisiting some \nnodes of the lattices as new generalizations are found. In this case, we would have a lattice of associations \nwhere the related classes are used as features, and Tenant and Landlord would appear within the X component \nof (X,X ) pairs. Upon discovering the Person gen-eralization, we revisit the nodes of the associations \n9. This is only a problem in knowledge representation languages that do not allow for exceptions. In \nour case, we take the best generalizations we can get! lattice whose X component contain either Tenant \nor Landlord, and we recompute the nodes from that point upward using the algorithm for incremental updates \n[Godin93a]. 4. Discussion In this paper, we proposed a formal method for building and maintaining hierarchies \nof class descriptions. The method is based on the concept of Galois lattice of a binary relation and \nrefinements thereof. One such refinement, the inheritance knowledge space, relates directly to the notion \nof protocol hierarchy described in [Cook92a]. Our method has some advantages compared to other con- ceptual \nclustering methods [Godin86a]: 1) it supports an efficient incremental rithm, update algo- 2) it does \nnot depend on any (subjective) ter tuning or input ordering, and parame- 3) the resulting hierarchy is \nnot limited to be a tree. Over the years, we developed a number of exten-sions to the basic method to \ntake into account richer class descriptions [MineaugOa]. WC showed how 408 these extensions may be advantageously \nused to pro- vide greater flexibility in 00 analysis, and showed how the enhanced models can be mapped \nto design and implementation. We are currently involved in a major government-industry collaboration \non 00 metho-dologies for distributed systems. The ideas presented in this paper are being implemented \nas part of an 00 development toolkit, and will be tested on distri- buted systems software (DSS). Given \nthe higher-than-average use of formal specification techniques in DSS, we expect the project to provide \na good testbed for the range of methods discussed in this paper. We are also exploring an adaptation \nof the method to the case where the application domain represents several functional views of the same \ndata objects. We believe that the views may have to be modeled separately. Further, we see distinct advan-tages \nto implementing distinct class hierarchies that delegate to the same base classes, which act as common \ndatastores [Mili92c]. One of the research challenges consists of detecting these views a-posteriori, \nfrom the anatomy of the lattice, and suggesting a subdivision of class descriptions, each corresponding \nto a functional view; In other words, we are concerned with developing a slicing algo-rithm for Galois \nlattices that maximizes some meas-ure of cohesion within the slices [Mili92c]. In some cases, this approach \nwould obviate the need for-- the problematic-- multiple inheritance. In gen- eral, we believe that this \napproach leads to flexible, yet clean (conformant, no-cancellations, etc) class hierarchies. Acknowledgements. \nRobert Godin and Hafedh Mili are supported through individual operating grants from Canada s Natural \nSciences and Engineering Research Council (NSERC), and a team grant funded through Quebec s SYNER-GIE \ncollaborative research initiative. References Bergstein 1 a. P. Bergstein and K. J. Lieberherr, Incremen- \ntal class dictionary learning and optimization, in Proceedings of ECOOP 91, ed. Springer Verlag, pp. \n377-395, Geneva, Switzerland, 1991. Brachman85a. Ronald J. Brachman and James G. Schmolze, An Overview \nof the KL-ONE Knowledge Representation System, Cognitive Science, vol. 9, pp. 171-216, 1985. Coad9 1 \na. Peter Coad and Edward Yourdon, in Object-Oriented Analysis, Prentice Hall, 1991. second edition Cook92a. \nWilliam R. Cook, Interfaces and Specifications for the Smalltalk-Collection Classes, in Proceedings \nof OOPSLA 92, pp. l-15, ACM Press, Vancouver, B.C., Canada, October 18-22, 1992. Cox90a. Brad J. Cox, \nPlanning the Software Revolu-tion, IEEE SofnYare, vol. 7(6), pp. 25-35, November 1990. Ganter86a. B. \nGanter, J. Stahl, and R. Wille, Conceptual Measurement and Many-Valued Contexts, in Classification as \na Tool of Research, ed. M. Schadcr, pp. 169-176, North-Holland, Amster-dam, 1986. Gennari90a. J. H. \nGennari, P. Langley, and D. Fisher, Models of Incremental Concept Formation, in Machine Learning: Paradigms \nand Methods, ed. J. Carbonell, pp. 1 l-62, MIT Press, Amsterdam, the Netherlands, 1990. Gibbs90a. S. \nGibbs, D Tsichritzis, E. Casais, 0. Nier-strasz, and X. Pintado, Class Management for Software Communities, \nCommunications of the ACM, vol. 33, no. 9, pp. 90-103, 1990. Godin93a. Robert Godin, Rokia Missaoui, \nand Alain April, Experimental Comparison of Naviga-tion in a Galois Lattice with Conventional Information \nRetrieval Methods, International Journal of Man-Machine Studies, 1993. To an=-. Godin86a. R. Godin, E. \nSaunders, and J. Gecsei, Lattice Models of Browsable Data Spaces, Journal of Information Sciences, vol. \n40, pp. 89-116, 1986. GodinSla. R. Godin, R. Missaoui, and H. Alaoui, Learning Algorithms Using a Galois \nLattice Structure, in Proceedings of the Third Inter- national Conference on Tools for Artificial Intelligence, \npp. 22-29, IEEE Computer Society Press, San Jose, CA, 1991. Li89a.Q. Li and D. McLeod, Object Flavor \nEvolu- tion in an Object-Oriented Database System, in Proceedings of the Second International Conference \non Expert Database Systems, ed. L. Kershberg, PP. 469-495, Benjamin/Cummings, 1989. Lipkis82a. Thomas \nA. Lipkis, A KL-ONE Classifier, in Proceedings of the 1981 KL-ONE Workshop, ed. J.G. Schmolze &#38; R. \nJ. Brach- man, pp. 128-145, Bolt Beraneck and New-man, Inc., June, 1982. Meyer88a. Bertrand Meyer, in \nObject-Oriented Software Construction, ed. Prentice-Hall International, 1988. Mili92b. Ali Mili, Noureddine \nBoudrigua, and Fathi Elloumi, The Lattice of Specifications: Appli- cations to a Specification Methodology, \nFor-mal Aspects of Computing, Springer-Verlag, 1992. to appear Mili90a. Hafedh Mili, John Sibert, and \nYoav Intrator, An Object-Oriented Model Based on Rela-tions, Journal of Systems and Software, vol. 12, \npp. 139-155, 1990. Mili92a. Hafedh Mili and Roy Rada, A Model of Hierarchies Based on Graph Homomor-phisms, \nComputers and Mathematics with Applications, vol. 23, no. 2-5, pp. 343-361, Winter 1992. Mili92c. Hafedh \nMili and Robert Godin, Sofrware Reuse Research Plan for the SYNERGIE Project, p. 16, Department of Maths \nand Computer Sci-ence, Univ. of Quebec at Montreal, November 17, 1992. Mineau90a. G. Mineau, J. Gecsei, \nand R. Godin, Struc-turing Knowledge Bases using Automatic Learning Processes, in Proceedings of the \nSixth International Conference on Data Engineering, pp. 274-280, IEEE Computer Society Press, Los Angeles, \nCA, 1990. Ossher92a. Harold Ossher and William Harrison, Combi- nation of Inheritance Hierarchies, SIGPLAN \nNotices, vol. 27, no. 10, pp. 25-40, Vancouver, B.C. (Canada), October 18-22, 1992. Proceed-ings of OOPSLA \n92. Pedersen89a. Claus H. Pedersen, Extending Ordinary Inheritance Schemes To Include Generaliza-tion, \nSIGPLAN Notices, vol. 24, no. 10, pp. 407-418, New Orleans, Louisiana, October 1-6, 1989. Proceedings \nof OOPSLA 89. Prieto-Diaz87a. Ruben Prieto-Diaz and Peter Freeman, Clas-sifying Software for Reusability, \nIEEE Software, pp. 6-16, January 1987. Rumbaugh9 1 a. James Rumbaugh, Michael Blaha, William Premerlani, \nFrederick Eddy, and William Lorensen, in Object-Oriented Modeling and Design, Prentice Hall, 1991. Wille82a. \nR. Wille, Restructuring Lattice Theory: An Approach Based on Hierarchies of Concepts, in Ordered Sets, \ned. I. Rival, pp. 445-470, Reidel, Dordrecht-Boston, 1982. Wirfs-BrockBOa. Rebecca Wirfs-Brock, Brian \nWilkerson, and Lauren Wiener, in Designing Object-Oriented Software, Prentice-Hall, 1990. \n\t\t\t", "proc_id": "165854", "abstract": "", "authors": [{"name": "Robert Godin", "author_profile_id": "81100494832", "affiliation": "", "person_id": "P244990", "email_address": "", "orcid_id": ""}, {"name": "Hafedh Mili", "author_profile_id": "81410594736", "affiliation": "", "person_id": "PP39076012", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/165854.165931", "year": "1993", "article_id": "165931", "conference": "OOPSLA", "title": "Building and maintaining analysis-level class hierarchies using Galois Lattices", "url": "http://dl.acm.org/citation.cfm?id=165931"}