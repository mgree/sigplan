{"article_publication_date": "10-01-1993", "fulltext": "\n Roles for composite objects in object-oriented analysis and design France Civello Computing Depattment,University \nof Brighton Watts Building, Lewes Road, Brighton BN2 4GJ, UK frc@brighton.ac.uk Abstract A method is \npresented for using composite objects which separates their role and meaning as models of relations between \nproblem-domain concepts from their role and meaning as models of hierarchical sof twarc structures. The \nmeaning of composite objects is analysed in terms of connections bctwccn real-world concepts in object-oriented \nanalysis and bctwccn software objects in object-oriented design. By capturing the designer s rationale \nfor model transformation, the resulting models arc casicr to understand and maintain. An embedded systems \nexample illustrates the approach. 1 Introduction 4 composite object has a complex internal structure \ndefined in terms of other objects. A whole-part association (WPA) exists bctwccn the class of the composite \nobject and the classes ot each of its composing objects. The purpose of a WPA is to describe the common \nproperties of the whole-part links that instantiate it, just as a class describes the propcrtics common \nto all its instances [Rumbaugh, Blaha, Premerlani. Eddy, Lorensen 911 . Permission to copy without fee \nall or part of this material is granted provided that the copies are not made or distributed for direct \ncommercial advantage, the ACM copyright notice and the title of the publication and its date appear, \nand notice is given that copying is by permission of the Association for Computing Machinery. To copy \notherwise, or to republish, requires a fee and/or specific permission. . . @ 1993 ACM O-89791 -587-9/93/0009/0376...$1.50 \nHowcvcr, classes have a well-established semantics and can be described in object-oriented programming \nlanguages, whereas there is no standardization of meaning and USC for WPAs between classes ([Rubin and \nGoldberg 921. [Monarchi and Puhr 921). This paper presents a method for the definition and USC of WP.4s \n(and hcncc composite objects) in object- oriented analysis (OOA) and object-oriented design (OOD). The \nmethod is based on the view that WPAs are used for dif fercnt purposes in OOA and OOD. In OOA, WPAs capture \nsemantic properties of the problem-domain, whereas in OOD they capture semantic properties of the software. \nThe nature and range of these properties and the method used for separating them is illustrated with \nan example of an cmbcddcd control system. Section 2 introduces a notation and terminology for whole-part \nassociations and composite objects. In section 3 the method is presented in outline and the motivation \nbehind it is discussed. In section 4 the rcquiremcnts of the example application are presented. Section \n5 discusses the USC and meaning of WPAs in OOA. Section 6 discusses the semantic properties and the USC \nof WPAs in OOD. Finally the benefits and limitations of the method are discussed and ideas for further \nwork arc prescntcd. 2 Notation and terminology A whole-part association (WPA) is an association bctwccn \ntwo classes, the composite or wlzole class and the part class. To distinguish WPAs from other associations, \nthe OMT convention of drawing a OOPSLA 93, pp. 376-393 diamond shape on the association link, next to \nthe whole class box, is adopted (Figure 1). A WPA is instantiated by a link between a composite (or whole) \nobject and a part object. A whole-part structure [Coad and Yourdon 911 includes a composite class, all \nof its part classes and all the WPAs between the composite and its parts. The classes Car and Engine \nand their WPA form a whole- part structure. The Car-Engine WPA is mandatory in both directions, i.e., \neach Car must have an Engine and each Engine must be part of a Car. Other WPAs may be optional in one \nor both directions. I Car Figure I : a whole-part association  2.1 Aggregates and Collections Two patterns \nof whole-part associations recur frequently in object-oriented models. Aggregates [ Coad and Yourdon \n901 are patterns where a class has several named part classes, each with multiplicity 1 (Figure 2). The \nname of a part class can be omitted from the diagram if no ambiguities can arise (c.g., Text in TextBox). \nI TextBox +i-++, Figure 2 : un aggregate By default, a WPA is tiken to be a (1) to 1 association: i.c., \nan instance of the whole class needs a link to one instance of the part class, whereas an instance of \nthe part class can exist without a link to an instance of the whole class. (Each TextBox needs a Text \nand two Buttons, but Text and Button objects do not exist just as parts of a TextBox). The second recurrent \npattern of association is the collection, in which a composite object is linked to many part objects \nof the same class. Figure 3: a collection For cxamplc, in a graphical editor for geometrical drawings, \nwe can model the association between the class Drawing and the class Shape, of which elements of the \ndrawing are instances, as a collection (Figure 3). R I I 00 Introduction Figu.rc 4: Q. multi-level composite \n 2.2 Composition hierarchies To model complex hierarchies of objects, it is often necessary for a part \nclass in a WPA lo be the composite class in another. So whole-part associations can induce multi-level \nobject composition hierarchies (part-of hierarchies) (Figure 4). 3 Rationale and outline of the method \nWPAs can be used to model part of relationships between entities in a domain (e.g., OMT [Rumbaugh et \nal. 911, OOA [Coad and Yourdon 911) and to control design complexity by encapsulating the parts of composite \nobjects (e.g., OOAD [Booth 91 1, HOOD [Robinson 921, [dechampeaux 91) ). Thcsc two goals are difficult \nto separate by looking at it Linishcd model, as this not only attempts to rellcct the structure of a \nproblem domain, but is also dcsigncd to be understandable, manageable, rcusablc, resilient to change \nand to result in software with dcsircd computational features, such as pcrformancc and physical distribution. \nThis situation arises from the twofold purpose of object-oriented models: to describe the structure and \nbehaviour of entities in the problem domain (analysis), and to describe the structure and behaviour of \nthe software components of the system (design). During OOD an object model is relined and transformed \nto address design issues that arc not considered in analysis [dechampeaux, Lea and Faurc 921. New WPAs \ncan bc created. Existing ones arc viewed from a new, software pcrspcctivc and can therefore change their \npropel-tics or acquire new ones. When a model undergoes substantial transtbrmation during design, it \nis vital that the analysis model. reflecting the client s and analyst s understanding of the problem \ndomain and system requircmcnts, is preserved. The transformation steps musl also be recorded. This way, \nwhen the requirements change ot are extended, the analysis model can bc modified and ldeChampeaux (91) \nuses the term cnscmblc to rcfcr to special kinds of composite objects that encapsulate their components. \nThis concept is subsumed by the categorisation of composite objects given in this paper, where encapsulation \nis only one of the design roles of a composite. the transformations chcckcd for consistency with the \nnew requircmcnts. If the design model is modified directly, problem and solution domain issues cannot \nbc distinguished and considered scparatcly. This makes system cvolulion harder to control and more error-prone \nIt follows that WPAs must be documented so that their analysis and design properties, and the different \nconstraints and decisions they reflect, can be separately identified. Furthcrmorc, within their analysis \nand/or design roles, WPAs can be used for multiple and different purposes which affect their semantics. \nThis view is supported by rcscarch in cognitive psychology [Winston et al X7], which has shown that there \narc diffcrcnt types of part-whole relations (mcronymic relations) bctwccn concepts, with different semantic \nconnotations. For cxamplc, the whole-part relations Person-Ann and Company-Person arc semantically diffcrcnr2. \nThis variety of purposes and semantics is not supported by the notations of current object-oriented methods, \nwhich tend to bury it under a single notational construct, ending up with a concept too broad in scope \nto have a prccisc meaning or a useful role within the development process. Table summarizes the terminology \nand approach of a rcprcscntativc sample of current object-oricntcd methods. A striking feature is that \nthose methods that use WPAs in the analysis stage (e.g., OMT, OOA) do not distinguish berwcen WPAs and \nother class associations in design and implcmcntation, whcrcas those methods that USC them for software \ndesign purposes (c.g., Boo&#38;, HOOD) do not cxtcnd into the analysis stage. Thus no existing method \ngives rules or guidclincs for using WPAs throughout analysis, design and ilnplcrncntation. In fact, the \ndifference bctwecn WPAs and other associations is often only cosmclic and diagrammatic. While it is generally \nacknowlcdgcd lhat whole-part associations bind 2Thc transitivity properly (i.e., if A is part of B and \nB is part of C, then A is part of C) is lost when relations with different semantic propcrtics arc involved \n( my Arm is nol part of my Company). classes more strongly than other associations, there are no further \nrules or constraints to guide design and implementation decisions. For example, the duties of a composite \nobject as owner and manager of its parts are not sufficiently elaborated by any existing method, although \nthe TROLL language [Hartmann, Jungclaus and Saake 921 allows the representation of structural and behavioural \nconnections between a composite and its parts. This paper proposes a method L or using and documenting \nwhole-part associations throughout model development, that addresses the problems mentioned above: . \nIn OOA, WPAs arc shown individually alongside other associations and domain-specific terms, such as is \npart of or OOA are named explicitly in prccisc rather than in gcncric tcnns includes . In addition, each \nOOAD OMT aggrcgatc and collection is classified as belonging to one of thrcc semantic patterns and textually \nannotated accordingly. This requires the dcvcloper to invest more resources in understanding the domain \nbetter, but it pays dividends in later stages by making the model easier to comprehend and providing \nmore precise guidance f or the designer. . In OOD, more emphasis is placed on the object composition \nhierarchy rather than individual associations. The design properties of each whole-part structure arc \ncaptured using annotations. A rationale is given for each composite object in the object composition \nhierarchy by cross-referencing corresponding WPAs in the analysis model and/or by stating its design \npurpose within the model. This gives tractability 01 WPAs by documenting the rationale for the transl \normation bctwccn the analysis and the design model. CRC Objectory HOOD Source [Coad and [Booth 911 [Rumbaugh \n[Wirfs-Brock [Jacobson 921 [Robinson 921 Yourdon 91 I et al. 911 ct al. 901 Notation Yes YW Yes No No \nsupport for WPAs Terminology whole-part has aggrcga tion part of consists-of include structures \nrelationship (whole-part relationship relationship relationship association) Problem- strong weak strong \nweak none domain (pervasive (parts modelling organising common semantics principle) Drouerties) Variations \ncontainer by-value 11011~ con taincr IlOIlC none collection i1 bv-rcfcrencc composite assembly Definable \noptionality optionality optionality IWIl~ none properties multiplicitv multiplicitv multit7licitv Software \nnone ownership/ none encapsulation design encapsulatiori /delegation semantics Relevance major in method \nMain decomposi- purpose tion/ modclling design/ distribution 4 The example system The system specification \nis derived from a published example of real-time structured design techniques [Ward and h4ellor 851. \nThe system consists of a number of bottle-filling lines fed by a single vat containing the liquid to \nbe bottled. Figure 5 shows some of the details of the vat apparatus and of a representative bottling \nline. Because of the single vat, the composition of the liquid being placed in the bottles is the same \nfor all lines at a given time. However, the bottle size may differ from line to lint. The tasks of the \ncontrol system arc to control the level and the pH of the liquid in the vat, to manage the valve pH control \nvalve vat . il. . . r .,. . . . . . . .,. i::.:.: .. . .... ..,..............,....,........... .../:.:....,:. \n :.::.:i:I:,,Ii..i.:::::,:::::,:.j .:. ;: i::: :.:::: .::..:.::..: . j:;j?j!:i:::.i.>:: .:y Y::.::. .,.:::>:: \n: :.j.:..:.::>:.:::.::::y:,::. :z:;:::.::::::::::-:: :;:.. ..,..... :.::+:.:: : . .::::.y::.:: .::::i, \n:.:.A... :. : . ::.,::.; :.:; ... . :.::i.::i-I;ilLiif!d;:~-];:,~j-i-:j::j:-I:::i:jl .\\...A.. . :. ::::::.: \n:.:.:.:: .: ::,.:.::.:.,. .y$:;:;::;:;:;:,::::::. y,:p:.:;:: ::::.:.,.,. .:.:...:.:...:.j::.j: PH contact \n scales Figure 5: the physical structure of the bottle,fi lling plant, excluding Only one bottle filling \nline is shown. movement and filling of bottles on the various lines, and to exchange information with \nhuman operators working the individual lines and with a supervisor monitoring the entire system. The \nvat level control is accomplished by monitoring the level with a sensor and adjusting a liquid input \nvalve accordingly. The requirement for controlling pH arises because the liquid to be bottled reacts \nwith its surroundings, causing the pH to creep over time. A constant pH is maintained by introducing, \nthrough the pH control valve, small quantities of a chemical that revcrscs the pH creep . . .. :.:; .:. \n.. . .:.--:.-.:-.-::-..~:-:. :.. .: :-::..:::..,:.,,,:. .(.) .:.:...:.:..:;.,.,.:,.:::.,: ;: i ,:j::..: \n::., .,:...:.;;.:::;; jl:j :.:::. ::..:.::..: :/:...:..:.::::::.::. I,:: (.:i::::::: : ::::::?::: .:.:::...:..::::::::,:::,: \n:.:::::A: level sensor bottle release ga tc the .~upervi,wr and the operator interfaces. Bottles to \nbe filled on a particular lint arc drawn one by one from a supply of bottles, as follows: . A bottle \nis released from a gate and drops down a chute onto a scale platform, at the same time depressing a bottle \ncontact sensor. The bottle is weighed empty. . The bottle-filling valve is opened, and a measured amount \nof liquid is let into the bottle. The weight of the bottle plus its contents is used to determine when \nthe bottle is full and to shut off the valve. . The filled bottle is labcllcd to show the actual pH when \nfilled, and the nominal pH. The lint operator caps and removes the filled bottle, and signals the systems \nthat the bottle has been removed. Removing the bottle releases the boulc contact sensor, rcmovcs the \nweight on the scale and allows the next bottle 10 bc released from the gate. The line operators can signal \n~hc system to start and stop individual lines, and the supervisor can signal the system to enable or \ndisable the opcralion of all the lines. The line operators arc given displays of the lint status and \nare able LO change bottle size for Ihc lint. The area supervisor is given a display of the current status \nof the system pH, vat liquid lcvcl and statuses of the individual lines, and is able to control Lhc pH \nof the bottled liquid by entering a new dcsircd pH to bc maintained. If, during operation of the system, \nIhc pH goes out of limits (>0.3 from the setpoint) all control actions arc suspended. The vat pH is then \nsrabiliscd manually. When the pH is back within limits. the system restarts automatically 5 Whole-part \nassociations in the analysis model Class associations identified during analysis model connections between \nobjects in the problem domain (Figure 6). The key class attribulcs in the model arc shown inside their \nclass symbol. The associations provide a basis from which to derive the dynamic communication links amongsl \nsoftware objects, although they do not prcscribc the directions of the links, nor their implementation \nmechanisms- . The WPAs arc dcscribcd with domain-specific terms (c.g., Gate re1ccr.se.s bottles OIZ BottlingLine) \nrather than generic ones (e.g., Gate is purr oj BottlingLine), to convey more precisely the role of the \nlinks. 5.1 Semantic patterns of object composition WPAs can be divided into two categories: jbzctionaf \nand non~jiunctional. In a functional WPA the part is conceptually included in Lhc whole because of slruclural \nand functional connections that make it possible for it to contribute to the funclion of the whole [Winston \nct al. X71. For example, the devices which make up it Boltlinglinc arc structurally situated and conncctcd \nin such a way LO support the function of the BottlingLinc (c.g., Lhc gate is connected via the chute \nLO the platl orm LO which Lhc contact sensor is attached). Each part object has a function to fulfil \nthat conlributcs to the function of the whole object. We call thc parts in a functional WPA components \nto cmphasizc their csscntial role in the association. We call the whole object an a.s.sembl\\~, although \nno physical cxistcncc is implied. Essential parts of physical systems (c.g., the cnginc in a car), organisations \n(c.g., the headteachcr of a school), or conceptual cntilics (c.g., the activities in a project plan) \nfall within this dclinition. Non-functional WPAs modct looser connections bctwccn wl~olc and part. Such \nWPAs can be divided in two catcgorics: tuplc-element, and group-member, corresponding to the notions \nof aggregation and trssociution rctations in Semantic Data Modelling 3Additional textual constraints \nare required to capture the full semantics 01 the associations. For example, it should bc stated that \nthe SCI of BottlingLine objects linked to the Vat s Supervisor, found following the path Vat->Supcrvisor->BottlinSLinc \n, is the same set of BottlingLinc objects found following the path Vat->Valve->BottlingLinc . In other \nwords the Supervisor supcrviscs all the bottling lines which arc fed by the filling v;~Ivcs, and no others. \n Valve lets liquid in 1 * measures Analogue Sensor 1 level of liquid&#38; Vat 1 supervises - la S pcrvisor \nlets PH system status Valve chemical in I___) ICVCI desired pH 1 desired level measures pH of 1 liquid \nin ICLS Analoguc liquid Sensor 1 O t out of I I n 1supcwiscs rcleascs Gate / Labcllcr boulc on -1 \nweighs Analogue boulc on Sensor Operator scnscs prcscnce of boulc on signals rcmo\\~al 01 Button boulc \non 1 Figure 6: Class associc~tions in the Bottle Filling S~~.stm [Hull and King 871. A tuple models \na rclntion bctwcen its clcmcnts model the cntitics parlicipaling in the two or more entities.The two \nentities normally cxisl CVCIll. independently from each other. Tuplcs arc aggrcgatcs Groups arc sets \nof objects brought together by where the names of the elements convey the roles they virtue 01 sharing \nsome property or by some other play in the relation (e.g., Marriagc(Husband, Wife), looser connection. \nExamples of group-member Sale(Purchaser, Vendor, Property), Rcgistration(Car, associations arc: Hotel-Room, \nCommitte-Member, Owner) ). Often the tuple object models an cvcnt and Document-Page. In the bottle filling \nplant, should we require to keep track of each bottle lillcd, the set of filled bottles would be modellcd \nas a group object with no functional relation bctwecn whole and parts and no structural connections between \nthe mcmbcr objects (FilledBottles-Bottle). Just as aggregates and collections provide syntactic patterns \nof object composition, so asscmbly-component, tuple-element and group-mcmbcr provide semantic patterns, \nsince they capture the purpose for which WPAs are being used. Components in an assembly normally appear \nas the named parts in an aggregate pattern, as each has the ability to fulfil a different function, described \nby its name, within the composite. Members in a group, on the other hand, tend to be parts of a collection. \nThey are not individually named because they all play a similar role from the viewpoint of Lhcir composilc \nand none of them individually is essential to the function of the composite object. So funclional WPAs \ndescribe srrongcr: usually non-optional, links than non-~unclionat ones. Each composition pattern should \nbc annotated lo rcflccl this distinction and to justify it. In particular. I or each group object the \nanalyst needs to slate the common properties that brings together all member objccls. For each assembly, \nthe function of the composite and the contribution of each component must also bc described. In the Bottle \nFilling System (BFS) all WPAs arc functional and non-oplional. An example 01 ;1 model annotation is given \nbelow: Whole: BottlingLine Parts: ValvefUingValvc, Gate, Labeller, AnalogueScnsor sculc.s. Bu.tton removeSignal. \nOnOjjTensor contactSensor. Kind: Assembly Function: Manages the movement undfi llingof bottles on n single \nline. It controls the actions und monitors the stC/tc of each .component device. In summary, WPAs arc \nuseful to highlight strong associations in a problem-domain, but come in different flavours and need \nto bc dcscribcd accordingly. A dcsigncr would be entitled to ignore the difference between WPAs and other \nassociations if their meaning was no1 made clear.  5.2 Other (non-WP) associations This method of classifying \nWPAs helps to tell them apart from other associations, which are sometimes confused with WPAs : Spatial \nor temporal inclusion (e.g., Room-Desk, Process-Phase). Spatial (temporal) inclusion or proximity is \na good heuristic clue to identify a WPA. However it dots nol jusliI y a WPA in the absence of slructural \nor funclional connections relevant to the system responsibility. The filling Valves, for example, may \nby physically closer LO the Vat than to the BottlingLincs, but they are funclionally closer to the latter, \nas Lhcir operation depends on events happening within them. Spalial (temporal) inclusion justilies the \nsharing of some spatial (temporal) propet1ics bctwecn objects, so it might I oIm the basis for a group-member \nWPA, but it is semantically wcakcr than a L unctional WPA. Thus the spatial I calurcs of the Pilot-Aircraft \nassociation ICoad &#38; Yourdon 91 I do not justify a WPA. Pilots and Aircrafts are independent entities. \nOne just happens 10 be inside Lhc other for a time period. Their association is semantically similar \nto that between a tcmotcty-controltcd aircr-al t and its human controller. Artrihution (c.g., Building-Height). \nHeight is not pars 01 ;I building, but one ol its attributes. Attribution is of tcn conlused with whole-part \nbecause the distinction bclwccn an attribute and a part of an object is of tcn lost in an objecl-oriented \nimplcmcnlalion. For cxamplc the height of the building and ~hc heating-system in the building would both \nbe implcmcntcd as instance variables or class Building in Smalllalk. Furthermore, in object-oriented \nmodelling the choice bctwccn attribution or WPA can be subjcctivc as wctt as purpose and context dependent. \nArc Ihc start-point and end-point attributes or parts of a tint scgmcnt ! The mswcr depends on the conlexl: \nare the delimiting points used just as inlbnnation holders, to store and provide access to their coordinates, \nor do they have bchaviour that can bc invoked by their LineSegmcnt or other objects? In the latter case \nthe two points should be modclled as part objects. Since such behavioural decisions are often taken \nduring OOD, an attribute in an analysis model can bccomc a part object during design. Class nzetnbership \n(e.g., John Smith -Person). This is a relation between an instance and its class, not between two instances. \nSemantically it cxprcsscs the fact that the properties of John Smith are dcfincd by the class Person. \nHowever if one takes an cxtcnsive view of meaning for classes (a class is a set), it is tempting to treat \na class as a collcclion of all its instances. Although possible, this is bad practice at both the conceptual \nand the practical Icvcl. At the conceptual level, it confuses the mcmbcr-collection relation, based on \nthe connections between or the extrinsic properties of a group of objects, with the class membership \nrelation which is based on the intrinsic propcrtics of Lhc class mcmbcrs. At the practical level it crcatcs \na computational abstraction with two distinct responsibilities: dclining and creating instances of a \nclass, and keeping and managing the instances of the class. The latter is usually application and context \ndependent whereas the first is fixed. In addition, there is often a need for distinct collections ol \nobjects of the same class in an application. The extensive approach creates a displeasing asymmetry between \nhow different collections of objects of the same class are handled. 6 Whole-part associations in the \ndesign model The WPAs in the design model arc shown as an object composition hierarchy (Figure 7) to \nemphasize that their main role is in structuring the software system as opposed to modelling the problem \ndomain. Whereas a problem-domain association captures, in application-related terms, the purpose I or \nwhich objects are linked, composite objects place objects (and hence their classes) in a logical hierarchy, \nso that software can bc designed in layers of abstraction. with functional responsibilities suitably \ndistributed among the layers. Some WPAs in the objecl composition hierarchy do correspond to problem-domain \nclass associalions, in which case the relevant links arc rcplicatcd ;~cross (17~ two diagrams (c.g., \nBottlingLinc -Gate). Others do not have such semantic support in the class association model, but arc \nintroduced to make the model more suitable to a sol twarc rcalisation (have a design role only). 6.1 \nSemantic properties of WPAs in a design model In OOD, a WPA models a part-of relation between software \nobjects, not bctwccn real-world entities or concepts. Thcrcforc, its semantics should be based on properties \noI sof twarc links. However it is counter-productive to give necessary and sufficient conditions for \ncalling a software link a whole-pan link. The rcsulling conditions are either too prcscriptivc or too \nbroad, and thcrclorc unhelpful. The reason is thill the concept of whole-part association in software \nhas too many I accts and shades and so defies cxccssivc simplilicalion. It is more I ruitl ul to consider \nthe primitive propertics of each WPA and annotate the model accordingly. This way the dcsigncr is I rce \nto use WPAs as hc or she sccs appropriate, provided some minimal ncccss;u-y conditions are satisfied, \nbut is also Ibrccd LO dcfinc whirt is meant by each WPA. The list below is an attempt LO establish the \nprimitive sctnantic propcrtics of software links on which WPAs arc based. Visibility. A ncccssary (but \nnot sufficient) condition for an object to bc part of another is that the whole object has the ability \nto send messages to the part. Thus the composite class is a client of the part class. The converse may \nalso be true if the application requires it. In MacApp and other GUIs, for example, CilCh View holds \nil rcfcrcncc LO its enclosing View in order to propagalc cvcnts. Etzcapsulatiutz. An cncapsulatcd (or \nnested) object is only visible within the scope of its encapsulating object. A composite object may cncapsulalc \nits parts, making its intcmal structure invisible to its clients. Current programming languages do not \nI uI ly support ~llCilpSUl~ltiOll, as a private inslancc viiriablc can be assigned to a method argumcnl, \nmaking the part object visible outside ti whole objcc[. Component objccls should bc encapsulated by their \nassembly to separate the external functionality of the assembly from its internal structure and functions, \njust as in real lift complex armfacts present a simple extcmal intcrfacc that shields the user from their \ninternal workings. Elements of a tuple arc not usually encapsulated by the tuple, as thci r function \nwithin a system is not just subsidiary to the tuplc. Encapsulation can be further constrained or rclaxcd \nby limiting or extending the visibility within and across the composite object: Inward Visihilitv. A \nclient of the encapsulating object can use the encapsulated object, but only by obtaining a dynamic (i.c., \nreleased after method completion) reference to the laucr, from the former, during execution of one of \nthe client s methods. This is similar to Hogg s (91) islurzds, with the whole object playing the role \nof bridge. Islands limit the scope in which an object can be statically aliascd, making a design more \namenable to proofs 01 correctness [ Hogg 9 11. Outward visibilit\\;. The cncapsulalcd object may bc granted \nstatic or dynamic visibility to objects outside the scope of the encapsulating object. In the Bottle \nFilling System, for example, a BottlingLinc has visibility to the Vat, to obtain pH data. Inward and/or \noutward visibility arise from associations between a part class and classes outside its composite (e.g. \nthrough its Valve, BottlingLinc has an association with Vat (Figure 6) ). Whole-indenendence. A whole-independent \npart has no visibility to its whole. Peer-indenendence. A peer-independent part has no visibility to \nother parts of the same whole. Seaarate vart. A part that is both peer-and wholc- independent. Such an \nobject dcpcnds only on its own parts, if any. An object composition hierarchy whcrc all parts are separate \ninduces a strictly hicrachical interaction scheme, in which every sub-tree of the object composition \nhierarchy is totally self-contained. Strict hierarchies cnhancc robusrncss ol dcsigns at the expense \nof flexibility. Sharing. An object is shared if two or more objects hold refcrcnccs to it. A part object \ncan bc shared by multiple composites (c.g., a programmer can bc a mcmbcr of a dcvclopmcnt team and of \na quality rcvicw group). A shared part object cannot be encapsulated, as it must be visible to mom than \none composite. Part-Whole Inseparability. A separable part can be disconncctcd from its whole. An inseparable \npart cannot: its cxistcncc depends on the existence of a connected whole. For example each filling Valve \nis inscparablc from its FillingStation (Figure 7). A scparablc part can bc crcatcd by some other object \nand subscqucntly acquired I,,\\:the whole; or released from its whole and passed on to another object. \nFor cxamplc the mcssagcs in a mailbox are produced somcwhcrc clsc and inserted into (acquired by) the \nmailbox. Later they will bc released to be used and kept or dclctcd by some consumer object. Whole-Part \nInseparability. The existence of the whole object may dcpcnd on the existence of the part object. An \ninscparablc whole will create or import its part at creation time. The part object cannot bc dclctcd \nwithout causing the deletion of the whole. For example, an OpcratcdLinc depends on the existence of a \nBottlingLinc and an Operator (Figure 7). 1nsepar:rbility is thercfore about the relation bctwccn the \nobjects lil etimc. If a part is inseparable from its whole, then its lil ctimc is included in that of \nthe whole object (Figure 8). Conversely, if a whole is inscparablc from its part, then the lifetime of \nthe whole is included within that of its part (Figure 9). Mutual inseparability (part-whole and whole-part) \nmeans that the two lifctimcs coincide (Figure 10). It is usual for asscmblics and their components to \nbe mutually inseparable, for tuplc objects to be inseparable from their clcmcnts, and for members in \na group to bc scparablc from their whole. Together, the propcrtics of inseparability and encapsulation \ncorrespond to ownership, or has-by-value relationship in Booth (91). Keeping the two propcrtics scparatc \nprovides greater modelling I Vat  Supervisor Opcr,ltcdLincs A I Ill LiquidLcvelControl PHControl OpcratcdLinc \nA A I AnalogueScnsor Valve inputValve IevclSensor BottlingLinc Operator Labellcr FillingStation rcmovcSignal \nA I OnOlEcnsorValve fillingValvc AnalogucScnsor conUctScnsorscalcPlalfonn Figure 7: Cotnpositc ohjcct \nhicrmdzy in tlzc Bottle Filling System flexibility (e.g., inseparability with no encapsulation). objccl \nwould bc involved. Thus the cntily modclled by Immutability. In an immutable WPA the identity kc whole \nobject would no longer bc the same entity if of the part object cannot chsngc [Odctl 921. For one of \nits parts changed. In an immurablc WPA, the example, in a Marriage, the identity of the husband 01 part \nis scparablc from the whole, but the whole is not wife cannot be changed. If it did, ;I dil l crcnt Xl~r-iagc \nscparabtc from the part. ,411 inseparable pan cannot bc mutable, but an inseparable whole may have a \nmutable part. A sailing boat, for example, needs a sail (inseparability), but the sail can be changed \nl or an equivalent sail without affecting the l unction of the boat. Thus it is the role of the part \nthat is csscntial, but not its identity. Ownership. Ownership and encapsulation of a software object \nare treated as synonyms by some (e.g., Booth (91), Atkinson (92) ). Instead, WC dclinc ownership in terms \nof the way that the destiny of UK whole and part objects are interlinked. Marc precisely, an object owns \nanother if dclction of the whole object implies deletion of the part object. This dclinition 01 Crcatc \nownership is a pragmatic one: it allows us to represent situations where an object is owned but not cncapsulatcd \nby another object and where creation and dclction 01 the same object arc carried out by different objects \n(this is quite common with objects that rcprcscnt dynamic real-world objects that undergo a series of \nproccsscs bcl orc coming to the end of thei lil c). Also note that ownership is weaker than inseparability: \nfor cxamplc a member object owned by a group may be owned by the group but also separable Whole object \ns lifctirnc -b 1-.... Creak 1 Part object s lifc climc d from it (it can be released and continue its \nexistence outside the group). Delete BottlingLlnc ..-1 Dcletc Co-cxislcnce period 7 Boulc Figure and \n8: An exatnple demvys it when of at1 itzseparohle it leaves the line. sofn~ure part: a BottlingLine creates \na Bottle, tracks it ltz real 1@ the bottle is not inseparable frotn the line. I Whole object s lifetirnc \nPart object s lifetime __) I I I Figure Whole object s lifetime Z~lj-: Part object s lifetime __) 10: \nAn example of a tnutuall~* itlseparahle Gate WPA: the l~f~titnes of a BnttlingLitle atzd a I Gate coincide. \nCollaborations. Although in some composite objects ( called containers by Wirfs-Brock et al. (90) ) \nthe whole objects do not call operations on their part objects nor viceversa, normally, strong collaborations \nexist between a whole and its parts. The nature of such collaborations is application dependent, but \na few general categories can be identified. Constraint Maintenance: where a constraint must hold that \ninvolves all or some of the parts, the composite object can take charge of ensuring that the constraint \nis satisfied. A special cast of collaboration arising from the need to maintain a constraint is propagation \n[Rumbaugh et al 911, which occurs when the value of an attribute or link is shared bctwcen the whole \nand its parts. Changes to the value must bc propagated or broudcust to each part object. Configuration. \nA composite object can bc responsible for configuring its part objects. WC distinguish internal from \nexternal configuration. The former involves binding an object to other objects in the system; the latter \nsets up a link between an object and an interacting entity in the system environment. Internal Configuration. \nPart objects of ten collaborate with their peers, and, sometimes, with clients or servers of their whole. \nA whole object is ideally placed to set up such links, as it provides lhc context within which its parts \noperate. Internal configuration of part objects by their composite objects makes the part objects context \nindependent and therefore more reusable [Kramer, Magec, Sloman and Dulay 921. External Configuration. \nInterface objects modclling entities in the physical system environment that interact directly with the \nsystem need to bc externally configured. If the physical interfaces arc arranged into structures or sets \ncorresponding to the whole-part structures in the object model, then it is convenient for composite objects \nto set up the links between their parts and their physical counterparts. Delemtion of active behaviour. \nObjects can IX passive or active. An active object has its own execution thread. Active objects are \ndenoted by an A in the lower right comer of their icon (Figure 7). FOI the sake of conceptual simplicity, \nan object can have at most one execution thread [Kramer ct al. 921. However, composite objects, whether \npassive or active, may include active parts. So complex dynamic behaviour within an object can be decomposed \nby delegating part of it to the object s parts. A simple and easily verifiable cast of algorithmic decomposition \narises where a complex state in the state chart of an object (i.e., a stale with an internal activity \nthat can itself be represented as a state chart) is transformed into a component object. Control. The \ndynamic behavior of an object can be modcllcd as a finite stale machine. States arc abstractions of the \nvalues and links held by an object, and rcprcscnt its dispositional behaviours: in different states an \nobject reacts dil l crently to the same event. Transitions bctwecn states are caused by events gcncratcd \nby other objects or by events external to the model. See Coleman (91) for how to use object charts, an \ncxlcnsion to state charts [Harcl 871, to model dynamic object bchaviour. An object controls another if \nit generates events fol it (i.c. sends it mcssagcs that fire transitions between states). In principle \ncvcnts can be generated across any object link. Howcvcr the complexity of object interactions, and with \nit the potential for data corruption, race conditions or deadlock, is reduced if objects do not mutually \ncontrol each other and if control links are kept to a mimimum and explicitly documented in a model. The \nobject composition hierarchy can be used fat the purpose OF reducing behavioral complexity by giving \ncomposilc objects the role ol solc controllers ot their active parts. This should not bc considered a \nrigid rule but only a flcxiblc guideline to bc applied as long as it dots not distort the correspondence \nbetween the model and the problem-domain. In the Bottle Filling System, for example, each composite object \nis the sole controller of its active parts (thcrc arc no shared active parts), except in two casts whcrc \nthe control relationships are already clear in the problem domain: Supervisor controls Vat and Operator \ncontrols BottlingLinc. Most of the semantic properties discussed above are not directly supported by \ncurrent object-oriented programming languages; however, as they impost important constraints on the implcmcntation, \nthey should be explicitly captured in an object-oricntcd model. 6.2 Design rationale for composite objects \nJust as the properties of each whole-part structure must be documented to guide the implemcntalion process, \nso the purpose of each composite object must be documented to help understand the design model and its \nderivation from the analysis model. To illustrate the approach, the rationale for each wholc-part structure \nin the BottlcFillingSystcm is discussed, and the semantic propcrtics of each arc documcntcd. We proceed \ntop-down, depth-first down the object composition hierarchy in Figure 7. Whole: Bottle Filling System \n(models entire system) Parts: Vut, Supervisor, 0peratedLine.s Kind: Assembly Rationale: Top-down Decomposition: \nSystem Partitioning into .separate, cohesive parts Properties: Mutual insepurubility. Confi xuration, \nBehuviour delegation The whole system is modellcd as an assembly, whose components are subsystems with \nscparatc functional responsibilities. This structure is dcrivcd from the analysis model in three slcps: \n1. Partition the classes into a small number of groups, so as to minimize the number and strength of \nthe inter-group links (Figure 1 I). WPAs bind more strongly than other associations -this is why filling \nValves end up in the same partition iIs the BottlingLines. If shared WPAs arc involved, then assemblies \nare considered stronger than groups and groups stronger than tuples. Thcsc guidclincs help lo minimise \ninteractions amongst di ffcrcnt branches 01 the hierarchy. 2. Select a key class in each group and model \nthe whole system as a composite formed by objects 01  these classes (Figure 12). BottlingLine has been \nrcnamcd OpcrutcdLine to better convey its role. 3. Introduce a new object to manage the collection of \nOpcratcdLinc objects (Figure 7). \\ Bottling Line 1 I 1 n / Figure I I: Partitioning the model to ident@ \ntop-level al,.straction.s BottlcFillingSystcm I Figure 12: The system modelled as u composite object \nwhole: OperatedLines Pam OperatcdLinc Kind. Group Ra tiorzalc : Simpl(fj, top-level deu~mposition Properties: \nOwnership, Constraint maintenance, ~Me.ssa~c broadcasting, Configuration This composite object does not \nmodel a specific entity in the problem domain. It is used to collect together all the BottlingLincs (and \ntheir Operators), in order to simplify the top-lcvcl system structure by taking charge o 1 the mimagcmcnt \nof the OperatedLine objects. It cnsurcs that all its mcmbcr objects have the same value I 0 r their status \nattribute (disabled/enabled/suspended). To maintain this constraint, OperatedLines is responsible for \nbroadcastins supervisor messages to its members. OperatedLines does not encapsulate its members, so the \nSupervisor can share a rcferencc to a single OperatedLine if necessary. Also no internal links between \nOperatedLine objects are required, as the lines in the plant operate independently from each other. However, \neach BottlingLine within each OpcratedLine needs a link to the Vat to find out the liquid s pH to print \non the label. Such a link is established as follows: BottleFillingSystem passes a reference to the Vat \nto its OperatedLines component, which in turn broadcasts it to each OperatedLine, and so on. So the composition \nhierarchy is used recursively to configure objects that need links to others in different branches of \nthe hierarchy. As a result 0 f this 1 r a n s I 0 r m a t i on , BottleFillingSystem is no longer a \ncombination of an assembly and a group, but just an assembly: the grouping responsibility having been \ndclcgatcd down to the new object. This reflects more accurately the meaning of the top-level decomposition: \ncvcn though individual lines are dispensable and not functional components of the system as a whole, \nthe set of lines is a functional component of the system. Objects modelling entire systems can often \nconveniently bc modelled as assemblies of functional components. Any grouping composites can bc pushed \none lcvcl down in the part-of hierarchy by introducing new abstractions. Whole: OperatedLine Pam: BottlingLine, \nOperutor Kind: ASSembly Rationale: Encapsulation c!f us.rol:itrtiolz Properties: Mutual insepurubility, \nCorlfigurcltion, Proj3agation This aggregate does not correspond to an entity in the problem domain. \nIts main purpose is to encapsulate its two part objects and their association, to decouple them from \nthe OperatcdLincs collection. It propagates messages coming from the OpcratcdLines collection to the \nOperator object, which communicates them to the human operator and starts/stops the BottlingLine as appropriate. \nAn OperatcdLine object conceals and manages a BottlingLinc-Operator link. Whole: BottlingLine Pam. Laheller. \nFilling Station, Gute, Button removeSignal Kind, Assembly Rutionule: A.s.sembly,from problem-domain model \nPrt3pertie.s: E~zcapsulation, External co~fipration of all parts; Mutual inseparnbility, Corzfiguration, \nBehaviour delegation and control of FillingStation Bottlinglinc is dcrivcd from the analysis model. \nThe three dcviccs directly involved in the filling process have been grouped into a new assembly, the \nFilling Station. Bottlinglinc manages its components. In particular, BottlingLinc is the only object \nthat can generate events (c.g., slop-lilling, start-lilling) for the FillingStation. All the part objects \n(cxccpl the FillingStation, set below) arc dcvicc intcrfricc objects, i.c., they interface to a concrete \ndcvicc. In this system, all such objects arc passive and have no knowlcdgc of their function within the \nproblem domain, whereas functional aggrcgatcs arc olicn active and embody crucial domain knowledge (c.g., \nthe BottlingLine knows that when a bottle is removed the gate should bc opened). This approach enhances \nthe reusability of the interface objects and dccrcases design complexity by limiting the number of objects \nwith control responsibilities. As another cxamplc of the allocation of problem- domain knowlcdgc, the \nLabellcr dots not know what values it is printing on the Iabcls nor whcrc they come from. This knowlcdgc \npertains to the BottlingLine, which has a link to the Vat 10 find out the values to bc printed. wi101e: \nFilling Stution Parts.. OnOfl Sensor contactSensor. Ana.lo~ueSensor Scales, Vcrlvc,fllingVulve Kind \nA.s.scrnbl~~ Rutionale: Algorithmic cieL,ornl,o.sitiotl: ,simpl~fies dynamic behuviour oj BottlinxLine \nProperties: Encapsulation, Mmal insepurubilty, External conjiguration of all parts The FillingStation \nis a conceptual abstraction with no corresponding tangible entity in the problem domain. It manages the \npassive objects interfacing to the real devices directly involved in filling bottles with liquid. The \nFillingStation exhibits behaviourul cohesion. In other words, there exists a process in the system - \nfill one bottle -that calls at frcqucnt intervals the services of its three parts. This process is encapsulated \nby the Filling Station object. Its existence simplifies, by decomposition, the dynamic behaviour of the \nBottlingLinc object. This dclcgatcs responsibility for bottle filling to the active FillingStation, while \nretaining responsibility 1 01 starting and stopping the filling process and interacting with the operator \nand the other dcviccs in the bottle filling line. Whole: Vat Par&#38;: PHControl. LiquidLevelControl \nRationale: Models a tangible object in the problem domain and its &#38;tributes Breaks the vat control \ninto two concurrent activities Kind: Assembly Properties. Encapsulation (Supervisor visible to PHControl) \nOwnershiI1. Dynamic bchaviour delegution The Vat is a problem-domain object. Its parts arc derived from \nwhat were attributes in the analysis model: the liquid pH and the liquid level. The reason for promoting \nthese to the rank ol part objects is that each is associated with a scparatc system activity. Furthermore \nthe two activilics can bc dcscribcd and implemented as concurrent processes. Whole: PHControl (LiquidLevelControl) \nParts: PHSensor, PHValve (LevelSensor, InputValve) Kind. A.ssembl;\\~ Rutionale: Models a property @ the \nVat associated with u control process Separates essential function from implementation mechanism Properties: \nEncapsulation, Mutual Inseparability, Externul conjiguration Thcsc two composite objects do not model \ntangible objects but concurrent system functions. Their parts model the dcviccs used in each control \nfunction. Encapsulating the dcviccs within each control object separates essential system functions from \ntheir implementation, an approach consistent with the separation of essential and implementation modelling \nof Real-Time Structured Analysis and Design [Ward and Mcllor X5 1. Objects clearly related to system \ngoals arc more stable than objects modelling physical dcviccs that arc part of the solution space. FOG \nexample, if it was rcquircd to measure the pH via multiple sensors to increase accuracy, the change would \nbc limited to the implementation of pHContro1 and would not al l cct its cx~.cmal interface to the Vat. \n7 Conclusions Current object-oricntcd methods and languages arc not cxprcssivc enough to represent the \nrichness in semantic propcrtics and development roles of composite objects. WC have argued that treating \ncomposite objects scparatcly from problem-domain class associations and explicitly capturing their design \nrole, as well as their problem-domain semantics, helps to separate analysis and design concerns and to \ndocument the rationale for important modelling and design decisions that might othcrwisc bc lcl t unrecorded. \nWC have illustrated how whole-part associations can model difl crcnt types of problem-domain relationships, \nand how object composition can be used to cvcnly distribute structural, functional and control complexity \nin a model. A useful spin-off of capturing the design properties of composite objects explicitly in a \nmodel is to enable checking of a model for semantic consistency between the bchavioural and structural \nview. For example, scenarios of object interactions can be checked for consistency with the stated structural \nproperties (whether the visibility properties are complied with, whether creation and deletion of objects \nis compatible with the separability, ownership and immutability properties, etc.). CASE tools for OOD \nshould automate as much of this as possible. The example used in this paper has illustrated the analysis \nand design roles of composite objects particularly applicable to the domain of embedded monitoring and \ncontrol systems with a fairly static configuration. We believe more research is required to analyse and \nstreamline the use of composite objects in more dynamic environments, where objects and links are frequently \ncreated and deleted at run-time. The concepts of encapsulation and separability, in particular, must \nbe refined to account for their temporal dimension. It must be possible, fbr example, to model the migration \nof objects I rom one composite to another. We also believe that many of the propcrtics that we have classed \nas design properties, such as separability and immutability, can apply to real-world entities as well \nas software objects. Thus they can bc investigated before software concerns are addressed. However, since \nsoftware objects often do not exhibit the same properties as their real-world counterparts, WC bclicvc \nthat a better than currently available understanding 01 the model transformation process that takes place \nduring design is required, in order to account l ol differences between the analysis and design model. \nThe method presented here does not address such issues, although it provides a framework in which they \ncan be explored. Acknowledgements I am grateful to Richard Mitchell for his collaboration in the original \ndesign of the Bolllc Filling System and for his tireless support and useful comments. References Atkinson \nC. 199 1. Object-Oriented Reuse Concurrency and Distribution. An Ada-based approach. ACM Press. Addison-Wcslcy. \nBooth G. 199 1. Object oriented design with applications. Benjamin Cummings. Coad P. and Yourdon E. 1990. \nObject-oriented analysis, 1st ed., Yourdon Press/Prentice-Hall. Coad P. and Yourdon E. 1991. Object-oriented \nanalysis, 2nd ed., Yourdon Press/Prentice-Hall. Coleman D., Hayes F. and Bear S. 1992. Introducing ObjectCharts \nor how to use Statecharts in Object- Oriented Design. IEEE Transactions in Software Engineering, 18(l), \n9- 18 de Champeaux D. 1991. Object-Oriented Analysis and Top-Down Sof twarc Dcvclopmcnt. Proceedings \nofthe I99 I Europeun Cotzfercnce on Ob,ject-Oriented Programming, Springer-Verlag, X50-376. de Champcaux \nD., Lea D. and Faurc P. 1992. The Process of Objccl-Oriented Design. Proceedings ~1 OOPSLA 92, ACM, 45-6 \n1. Hare1 D. 19X7. Statccharts: a Visual Formalism fof Complex Systems. Science of Computer Programminx, \nS(3), 23 l-274. Hartmann T., Jungclaus R. and Saake G. 1992. Aggregation in ;I Bchaviour Oriented Object \nModel, Proceedings of the 1992 European Conference on Ol?ject-Oriented Programming, Springer-Verlag, \n57- 77. Hogg J. 1991. Islands: Aliasing Protection In Object- Oricntcd Languages, Proceedings of OOPSLA \n91, ACM, pp. 271-285. Hull R. and King R. 1987. Semantic Database Modclling: Survey, Applications and \nResearch Issues. ACM Computing Surveys, lY(3), September 1987. Jacobson 1. 1992. Object-Oriented Software \nEngineering. A Use Ca.ve Driven Approach. Addison-Wcslcy. Jungclaus R., Saakc G. 1991. Formal Specification \n01 Object Systems, in TAPSOFT 91, Proceedings of the International Joint Conference on Theory and Practice \nof SofnYurc Development, Goos G. &#38; Hartmanis J. eds., Springer-Vcrlag, 60-82. Kramer J., Magee J., \nSloman M. and Dulay N. 1992. Configuring object-based distributed programs in REX. Sqftwure Engineering \nJowxal March 1992, 139-149. Monarchi D.E. and Puhr G.I. 1992. A Rcscarch Typology for Object-Oriented \nAnalysis and Design. Communications 35(9), 35-47. qf the ACM, Scptcmbcr 1992, Ode11 J. 1992. composition. \nManaging Journal object of complexity, part Object-Oriented II: Programming,, j(6), October 1992, 17-20. \nRobinson P. ed. 1992. Ol?ject-oriented Design Chapman &#38; Hall. Rubin K. and Goldberg A., 1992. Object \nBchaviour Analysis. Communications of the ACM, Scptcmbcr 1992, 35(9), 48-62. Rumbaugh J., Blaha M., \nPremerlani W., Eddy F. and Lorcnsen W. 199 1. Object-oriented ModclinK clmi Design. Prentice-Hall. Ward \nP.T. and Mellor S.J. 1985. Stru(:tured Development for Real-Time Systems. Vol. I-.?. Yourdon Press. Winston \nM.E., ChafJin R. and Hcrrmann D. 1987. A Taxonomy of Part-Whole Relations. Cognitive Science, 11, 417-444. \nWirfs-Brock R., Wilkerson L. and Wicncr L.1990. Designing Object Oriented S~ft~urE.Prcnticc-Hall.  \n \n\t\t\t", "proc_id": "165854", "abstract": "", "authors": [{"name": "Franco Civello", "author_profile_id": "81100014106", "affiliation": "", "person_id": "PP31074894", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/165854.165929", "year": "1993", "article_id": "165929", "conference": "OOPSLA", "title": "Roles for composite objects in object-oriented analysis and design", "url": "http://dl.acm.org/citation.cfm?id=165929"}