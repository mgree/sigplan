{"article_publication_date": "04-01-1993", "fulltext": "\n Washington, DC-26 September-l October, 7993 Workshop 11 Understanding Object-Model Concepts Edited by: \n David W. Embley Brigham Young University Besides developing software, we may also create a  Introduction \n&#38; Motivation model for the sake of understanding and insight. (3) A Minor and major variations in \nconcepts and terms for model is an abstraction of some part of the real world. object-oriented models \nabound. These variations cause This implies that some of the qualities or properties of problems in communication. \nAlthough there are different real-world objects are modeled while others are not. views, the concepts \nand terms are maturing to the point Furthermore, we can model these qualities and that it may now be \npossible to recognize, if not resolve, properties in a number of ways. (4) Not everyone will differences \nand come to some agreement. agree. We can agree to disagree. When we disagree, however, we can still \ntry to faithfully represent aWith this in mind, the idealistic objective for our particular point of \nview and reach agreement that what workshop was to come to an understanding of object- is said is clear \nand concise. (5) We are not bound to model concepts. In particular, we wanted to identify core defining \nonly what is; we also have the freedom object-model concepts, define them, and describe them to define \nwhat ought to be. by augmenting definitions with examples and discussion. Realizing up front that we \nwould not Finally, we began with the following specific task accomplish these objectives in a one-day \nworkshop, we, objectives. (1) Provide a list of core concepts for the nevertheless, wanted to address \nthe problem and see group s area of work. (2) Provide definitions for each how much could be accomplished. \ncore concept. (3) Identify subtleties that expose fundamental differences. (4) Provide an example of \neach To cover more ground and to increase the opportunity for core concept. (5) Suggest criteria for \nselecting amongindividuals to be heard, we divided ourselves into three competing ideas. (6) Explain \nhow the core conceptsworking groups. Each group addressed a coherent synergistically fit together. We \nsucceeded, however,subset of object-model concepts. Group 1 discussed only in making a reasonable list \nof core concepts,objects-how to model entities. Group 2 discussed providing partial definitions and explanations, \nandbehavior-how to model activity. Group 3 discussed exposing some of the subtleties. The remainder of \nthe abstraction-how to manage complexity. report documents our results. To be reasonably well focused, \nwe established some purposes for defining object-model concepts, some basic Group 1 -Objects assumptions, \nand some task objectives. The purposes we established were as follows. (1) Identify and Hermann Kaindl, \nFrederick Kohun, Barry Kurtz, characterize the kinds of qualities and properties of real- Steve Liddle, \nJim Rumbaugh, Robert Skovira. world objects that can be modeled. (2) Reduce the mismatch between concepts \nas they exist, and concepts Object Concepts as they are modeled in software implementations. (3) Object \n Explain the metamorphosis of concepts as they move through the phases of software development-analysis, \nPoints of view include: something with identity; design, and implementation, (4) Understand conflicts \nin something with state and identity; something with state definitions when considered from different \npoints of view and identity encapsulated; and an instance of a class. and different subdisciplines of \ncomputer science. (5) From an analysis point of view, an object is an Establish common perceptions among \ndevelopers, abstraction of something in the problem domain; researchers, and users. whereas from an implementation \npoint of view an object has private memory and a set of operations. PrivateThe basic assumptions we established \nwere as follows. memory consists of an object s identifier and an object s (1) Object modelers in the \nsoftware industry wish to state, which can be characterized by the values of its cost-effectively produce \nquality software (software that attributes. Operations constitute the services an object is more robust, \nmaintainable, reusable, etc.). The object can provide. model helps achieve this by allowing software \nto be organized in a natural way around objects. (2) Addendum to the Proceedings OOPSLA 93 Instance \nClass &#38; Type Is a synonym for object when an object is thought of as being in a class. Whether value \nis an object is debatable. From a real-world and analysis point of view, all values (e.g., the number \ntwo, the driver s license number U123456789) are objects, but not all objects (e.g., the Washington Monument, \nBoris Yeltsin) are values. But from a design or implementation point of view, it may be useful to distinguish \nobjects that can only be represented by an object identifier and those that can be represented by a lexicalized \nincarnation of themselves. Objects have properties, including identity, state, behavior, lifetime, and \nboundary. From an analysis point of view, identity can be thought of as an intrinsic property of an object \nthat makes it recognizable and distinguishable from other objects. In an implementation, the identity \ncan be explicitly represented as an object identifier, but this may be unnecessary if the attributes \nor relationships are sufficient to identify the object for all time. State and behavior are discussed \nmore fully by other groups (see sections below). Lifetime is the period of time during which an object \nexists. Boundary is what separates an object from other objects. Attribute Points of view include: a \nstructural part of a class; and a relationship between an object and a particular value. Both of these \nideas require further exploration. The relationship point of view, for example, includes the special \ncases of functional relationships and multi- valued functional relationships. When values are thought \nof as objects, this point of view also allows for inverse relationships. In addition, this functional \npoint of view allows attributes to be thought of as operations, which leads to a unification of the ideas \nof attribute and operation. This blurs the distinction between structure, which is commonly thought of \nas being represented by attributes, and behavior, which is commonly thought of as being represented by \noperations. Operation, Method, and Protocol An operation is a description of something to do. It includes \na signature and a behavior specification. It may be polymorphic, and, for different classes, may even \nhave different behavior specifications for the same signature. A method is the implementation of an operation \nspecific to one class. A protocol defines the messages that objects can accept, the interface to an object, \nor the set of operations an object can perform. A class has a set of operations, which constitutes its \nprotocol. Relationship There are several kinds of relationships: class-to-class, class-to-object, and \nobject-to-object. Generalization/specialization is an example of the first, instantiation is an example \nof the second, aggregation and association are examples of the third. Inheritance is not an object-model \nrelationship, but rather is a consequence of other relationships. Both Group 1 and Group 3 discussed \nclass and type. Group 1 treated class and type more abstractly and did not arrive at a clear dichotomy \nexcept that if objects and values are distinct, then a class is a description of a set of objects, whereas \na type is a description of a set of values. Group 3 treated class as a real-world or analysis concept \nand treated type as a design or implementation concept. One reasonably clear implication of all this \nis that if people wish to communicate properly about type and class, they will have to tell each other \nwhat they mean when they use these terms.  Group e-Behavior Scott Burleigh, Steve Clyde, William Harvey, \nShin Nakajima, Carlos Pereira, Bob Wilhelm. Behavior Concepts State Points of view include: a phase \nin the lifecycle of an object, a description of a phase in the lifecycle of an object, a subset of the \nstate of the system to which an object belongs, the minimal set of information required to predict the \nresponse of an object to any possible stimulus, the result of a sequence of behaviors or transitions, \nand an abstraction of the properties of an object. Since a property can be viewed as a <name, value> \npair or a <location, value> pair, these seeming different points of view can all be unified. However, \neach is also useful for different circumstances: a named phase in the lifecycle of an object may be sufficient \nfor analysis at one level of abstraction, but a detailed description of the phase may be necessary at \nanother level of abstraction. When an object is implemented, giving the values of its properties may \nbe the most efficient way to represent an object s state. When a state of an object is viewed as a subset \nof the state of the system to which the object belongs, the question naturally arises about whether the \nstate of the system is the aggregate of the states of the objects. One possible answer is: probably not, \nunless meta- states (states about states) are also treated as first- class states. Event An event is \na detectable, instantaneous occurrence. Examples include a change of some value and the arrival of a \nmessage. Whether an event is an object is debatable. Normally we do not treat events in the object model \nas objects themselves. When we wish to reason about events, however, we can model them as objects. Transition \nA transition is a change from one state to another. For a given time granularity, a transition may be \nconsidered to be instantaneous and atomic. However, transitions may be decomposed into other states and \ntransitions in a finer granularity. Furthermore, differences in granularity associated with different \nevents may be reconciled by introducing states for the transitions, e.g. a going to Washington,D.C. September \n264ktober 1,1993 work state can be introduced in an at home/at work transition.   Behavior-General \nComments Several general comments made during the workshop about behavior are worth preserving. (1) We \nmust distinguish between specification of the behavior of which an object is capable (its semantics), \nand an instance of that behavior under particular circumstances (its current behavior). (2) Interruptibility \nappears to be an important criterion for deciding whether to break a transition into components (substates \nand transitions). (3) State transition and events can be modeled in terms of preconditions, postconditions, \nand invariants. (4) It is useful to model states and state transitions, and then treat the stimuli for \nthe transitions as candidate stimuli for invoking services. (5) States must eventually be mapped directly \nor indirectly into instance variables. Concurrent Behavior Threads of execution are prime movers for \ncomputation. Concurrent behavior consists of multiple threads of execution either happening simultaneously \nor appearing to happen simultaneously. When several objects each have a thread of execution, the system \nexhibits inter- object concurrency. If an object contains multiple threads, it exhibits intra-object \nconcurrency. Flow of behavior is separate from flow of control even if flow of behavior is implemented \nwith flow of control. In passive object models, a thread follows a computational activity from object \nto object. In active object models, objects encapsulate their own thread(s) of activity. Continuous \nBehavior Ideally, continuous system behavior represents continuous response to continuous stimuli, rather \nthan discrete responses to discrete events. Thus, the state variables that characterize continuous systems \ntake on an infinite number of values, and hence are not characterized by finite state machine models. \nThe transitions are also continuous, rather than discrete. In computer implementations, however, digital \ncomputers have finite memory. Therefore, every variable involved in a program running on a digital computer \nhas a finite number of possible values, and the number of such variables is likewise finite. Thus, every \nprogram running on a digital computer is a finite state machine. Even so, we model continuous systems \nusing software on digital computers all the time. To do so, we use approximations of the values of continuous \nsystem variables (such as 3.14 for rr). Thus, we must indeed characterize continuous behavior on digital \ncomputers by finite state machine models, though not without some loss of either precision or computability. \n Group 3-Abstraction Bruce Conrad, Franz Hawk, Lennart Ohtsson, Philip Santas, Dick Felsinger, Scott \nWoodjield. Abstraction produces models that hide detail, extract the essence of objects being modeled, \nand chunk concepts. Multiple levels of abstraction facilitate the presentation and management of varying \namounts of detail, Abstraction is a coping strategy that helps us deal with complexity.  Abstraction \nConcepts Three kinds of abstraction appear particularly useful: classification, generalization/specialization, \nand composition. We discuss classification and generalization/specialization below. There was insufficient \ntime in the workshop to discuss composition. CIassification Both class and type are classification mechanisms. \nHowever, class is a real-world or analysis concept and type is a design or implementation concept. Classes \nclassify objects, and types describe object representations. (We note that some thought we used type \nfor what should be class and vice versa. However, we agreed that there are two different concepts worth \ndistinguishing and avoided the tight over which labels should designate them.) Specifics for class include \nthe following. A class is a set of objects with common properties and a membership condition. In particular \nthe predicate M(x) => C(x) = > P(x) holds, where M is a membership predicate for an object X, which, \nif it holds, causes x to be a member of class C, which in turn implies that certain properties P are \ntrue forx Since an object is subject to change, class membership is dynamic. Moreover, the membership \npredicate for a class can change too, which also causes class membership to be dynamic. Additional observations \nabout classes were given as follows. An object is a member of some universe of objects. An object can \nbe a member of more than one class. Many different classifications are possible. Objects can exist before \nclasses and have inherent properties that can be used to classify them. Common properties are those that \nhold for every member of a class. There is no guarantee for capabilities, which are properties that hold \nfor some members of a class, but need not hold for all members of a class. Behavior of an object is only \nloosely dependent on its class. (This last point may be particularly controversial and provocative.) \nSpecifics for type include the following. A type is a set of attributes and applicable functions or methods. \nA type provides an interpretation of a bit string or a group of bit strings. Types do not have extent, \nbut rather are descriptors for objects. An object is created as an instance of a particular type and \nusually remains associated with that type over its lifetime. An object cannot exist before its type exists. \nBehavior is inherent to the type, rather than the instance. In particular the predicate T(x) => P(x) \nholds, where T is a type for an object n, which, if it holds, implies that certain properties P are true \nfor X. The properties P are usually only signatures, not full semantics. Addendum to the Proceedings \nOOPSLA 93 Generalization/Specialization Given the predicates above for class and type, we can define \ngeneralization/specialization for classes and types as follows: subclass class M W =>(?) M(x) clcx, => \nC(x) p (xl => P(x)  subtype type T (n) => T(x) p (4 => P(x)  These constraints lead to the following \nobservations. A subclass has fewer objects than any of its superclasses. Subtype objects may have more \nattributes than do supertype objects. When methods are interpreted as common properties, the parameters \nof these methods in a subclass must be contravariant with respect to the parameters in the superclass. \nWhen methods are interpreted as so called capabilities, which are not essential for a class, the parameters \nof these methods can be covariant in subclasses. It was claimed that parameterization provides a safe \nway to have covariant functions.  Concluding Thought Group 3 included some questions in their report \nthat seem applicable to all three groups and, indeed, to conceptual modeling and the implementation of \nconceptual models in general. We conclude with these questions: Are the useful modeling concepts more \ncomplex than implementations can allow? If so, how many of these concepts are we willing to sacrifice \non the altar of efficiency? As an alternative, are we willing to do the necessary research to find algorithms \nand storage structures to allow these more complex concepts to be handled efficiently? Washington, D.C. \nSeptember 264ctober 1,1993 \n\t\t\t", "proc_id": "260303", "abstract": "", "authors": [{"name": "David W. Embley", "author_profile_id": "81452616755", "affiliation": "Brigham Young University", "person_id": "PP95033737", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260303.260364", "year": "1993", "article_id": "260364", "conference": "OOPSLA", "title": "Understanding object-model concepts", "url": "http://dl.acm.org/citation.cfm?id=260364"}