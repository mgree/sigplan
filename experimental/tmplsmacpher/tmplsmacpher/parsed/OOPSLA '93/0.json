{"article_publication_date": "04-01-1993", "fulltext": "\n Addendum to the Proceedings Washington, DC-26 September-l October, The Society of Objects Mario Tokoro \nKeio University &#38; Sony Computer Science Laboratory Inc.  Abstract In this paper, I will first review \nthe notions of objects and concurrent objects and discuss their main roles. Then, I will introduce two \nobservations on our current computer systems and explain why we need an evolved notion of objects, which \nwe call uut0num014~ agents, to describe open and distributed systems. An autonomous agent is a software \nindividual that reacts to inputs according to its situation and its goal of survival. A collection of \nsuch autonomous agents shows emergent behaviors which cannot be ascribed to individuals, eventually forming \na society. Research into achieving a society of autonomous agents being carried out at Sony Computer \nScience Laboratory and Keio University will then be presented. In the last section, I will speculate \nabout yet-to-be-realized computational modules called volitional agents, that could be used to create \nsafe, evolutionarily stable, cohabitating society. 1 Introduction Human society is characterized by \na dichotomy between individuals with their goals and aspirations, and the emergence of collective behavior \nthat cannot be ascribed to individuals. Intriguingly, computational systems and environments are beginning \nto exhibit some of the collective behavior that is characteristic of society. As high speed communication \nnetworks proliferate, every computer and, thus, every software module is connected with every other. \nAn enormous variety of software, with many variants for each type, has already been produced, and will \ncontinue to be produced by a great many software manufacturers. Hence, future software systems will consist \nof multi-vendor software, often dynamically integrated, residing at multiple sites as servers. Software \nmodules, or servers, are dynamically shared by multiple users, and may be changed from time to time. \nFuture software systems will also exhibit dynamic resource discovery. It will be useful to view such \nsystems as forming a society that is analogous to human society and interleaved with it. Hence, we need \nan evolved notion of objects, derived from a dynamic and interactive viewpoint. In this context, I will \nspeculate on what the evolved notion of objects is, and how future software should be composed. 7993 \nInvited Address I will first review the notions of objects and concurrent objects. Then, I will present \ntwo observations on our current computing systems operating in open, distributed environments, and illustrate \nthe necessity for higher-level software modules called autonomous agents. Then, I will present some of \nour research work, being carried out at Sony Computer Science Laboratory and Keio University. This research \nis aimed at achieving a society of autonomous agents that cohabit with human society. The presentation \nfeatures a personal, personified computer with a face and capable of vocal communication, called the \nIntimate Computer; an infrastructure model that abstracts future open, distributed computing environments, \ncalled the Computational Field Model (CFM); the Apertos distributed, real-time operating system; and \nthe Virtual Internet Protocol (VIP) mobile host protocol. In the last section, I will be a little provocative \nin advocating an even more advanced notion of autonomous agents, called volitional agents, that could \nbe used to create safe, evolutionarily stable, cohabitating society. I will conclude this paper with \na description of recent developments toward the understanding of collective behavior in terms of dynamic, \nnon-deterministic, stochastic, and irreversible processes taking root in various scientific fields. \n 2 From Objects to Concurrent Objects The world in which we live is concurrent in the sense that there \nare multiple active entities; distributed such that there is a distance between entities that yields \na propagation delay in communication between them; and open, meaning that the entities and their environment \nare always changing. Computation can be considered as a simulation of part of the real or an imaginary \nworld. In doing a simulation, you can model your problem in terms of sequential computing, concurrent \ncomputing, distributed computing or open computing. To solve a simple, small problem, sequential computing \nis usually sufficient. However, when the problem becomes larger and more realistic, it is much easier \nto model it as concurrent, distributed, or open computing. For example, if you have multiple users at \na time, such as in banking or airline reservation systems, you would naturally model the problem in the \nform of concurrent or distributed computing. 2.1 Objects The notion of objects provides a very convenient \nway of describing problems in any of sequential to concurrent, distributed, or open computing. An object \nis usually considered as being a physical or logical entity with a unified communication protocol, which \nis usually message passing [44]. It is composed of a local storage and a set of procedures, as shown \nin Figure 1. Figure 1: An Object However, if we examine more closely what an object is, it can be seen \nto be an abstraction of computation as things. Chairs, pens, books, . . . these are things. The sky, \nair, and water are not usually considered as being things. Things can be distinguished from others. An \napple is distinguished from other apples. Water in a glass can now be distinguished from other glasses \nof water. This is the external view of things. The other characterization is that a thing has both an \ninside and an outside. This is the internal view of things. Programming and computing a problem in terms \nof the interaction between things is the true benefit of object orientation. It is for this reason that \nthe notion of objects is applicable equally to concurrent, distributed, and open computing. Object-oriented \ncomputing can be understood as being a movement from a microscopic view of computing to macroscopic view, \nwhere microscopic corresponds to computation done by executing an algorithm, and macroscopic is computation \ndone using the mutual effects of objects. However, objects in most existing languages and systems are \nsequential, and therefore, static, or passive. This is a remnant of programming styles from when the \ncomputer was centralized and based on a uniprocessor. Using this kind of object abstraction, programmers \nhave to write execution control, or processor allocation, for objects, if they need to write a concurrent \nprogram. That is, we need the notion of processes on top of the notion of objects. This is very inconvenient \nand is a common source of errors. The fundamental reason for this is that real things are not like this. \nEvery thing exists and behaves simultaneously on its own right. Analogically, every object should exist \nand behave simultaneously. Therefore, it should have its own processor. Washington, 2.2 Concurrent Objects \nThe notion of concurrent objects is an extremely significant development. A concurrent object contains \na (virtual) processor, as shown in Figure 2. Here, we can eliminate the notion of processes which is \nnecessary in concurrent programming using sequential objects. Programmers don t have to describe execution \ncontrol. Concurrent objects are executed in the same way as in time-sharing systems. Figure 2: A Concurrent \nObject We can trace the history of concurrent objects back to the early 70 s when Carl Hewitt proposed \nActors [16, 11. Since then, many concurrent object-oriented languages and systems have been proposed \nand used. Concurrent Smalltalk [56] and Orient84/K [24] are languages which I designed with my co-researchers. \nABCL [59], POOL [3], Concurrent Eiffel [7], Concurrent C++ [15], Active Objects [341, and many other \nlanguages have also been designed. It was almost ten years later when I edited the book titled, Object- \nOriented Concurrent Programming with Aki Yonezawa [60]. The notion of concurrent oblects can be found \nin the field of operating s) :t~~~s, too. Examples include Eden [5] and Apertos 157, 583. Thcorctical \ninvestigations on concurrent objects have also been pursued, such as n-calculus [30] and v-calculus [19, \n203. Some recent accomplishments are detailed in PI. Although the notion of concurrent objects is a \nmore natural means of modeling things in programming, it has not yet found practical or commercial use. \nThis is probably just a matter of the notion C*X yet being well known. It takes some time, say 10 yenrs \nor so, until people actually feel comfortable with a new noti:)n. Virtual memory is one such example, \nand (sequential) object-oriented programming is another. The notion of \\ concurrent objects will become \nmuch more import ,nt when we need to migrate objects in a widely distributed environment. I fully expect \nthe notion of concum;nt objects to be accepted and widely utilized in the near future. In summary, the \nmost important role of objects (for both sequential and concurrent objects) is modularity: Fiat is, to \nenable the writing of a program as a thing with interface. This affords us various benefits, such as \nmacroscopic programming, analysis and design, classes and instances, class hierarchies, concurrency, \nand so on. D.C. September 26-October 1, 1993  3 Computation in Open, Distributed Environments I have \nbeen doing research on concurrent objects for more than ten years. The notion is neat, and provides us \nwith a very appropriate level of abstraction. As such, it seemed as though it would be enough for describing \ndistributed and even open systems. I tried to convince myself that concurrent objects would be enough. \nAnd, I was almost fully convinced. But something had annoyed me for a long time and prevented me from \nbeing fully convinced. In the following subsections, after presenting the essential characteristics of \nopen, distributed systems, I will explain what it was that annoyed me by observing two example systems. \n3.1 Essential Characteristics The technical characteristics of open and distributed systems can be summarized \nas follows. Distributed systems are characterized by there being distance between objects, which results \nin communication delays. Distance, and therefore delay, has an inherent consequence that there is no \nunique global view of the system. The state-space of the system that one observer sees is different from \nthe state space a distant observer sees. Since there is delay in communication, we use asynchronous communication \nfor the sake of efficiency. Asynchronous communication means that the timing when the sender sends a \nmessage and that when the receiver receives it are different. By using asynchronous communication, we \ncan exploit the concurrency between computation and communication. Open systems are characterized by \ntheir entities and environments constantly changing. Widely distributed systems are usually open systems, \nsince the topology cf the networks, the component computers, and the functions, quality, and locations \nof the services are dynamically changing. Thus, our future computing environment will be modeled well \nas an open, distributed environment.  3.2 Two Observations Here, I would like to describe two observations \non our computing systems, which offer a good prediction of future computing environments. The first observation \nis as follows: Assume you need a system. You write a specification, you program it or have somebody else \nprogram it, and you use it. Then, after a while, or perhaps even before the completion of the system, \nyou need to change it. And at a later time, you need to change it again. This is the problem of version \nmanagement. As everybody knows, it is not easy to follow how the current system is composed, and how \nit works. Version management is much more complex in open, distributed environments. Assume your friends \nor colleagues happen to know that you have a good system. So, they ask you for permission to use it. \nThey are usually at remote sites, so they want to use your system through remote procedure calls (or \nremote object calls). However, they also request revision of the system to tailor the system to their \nparticular needs. This tends to be repeated over and over, in a distributed manner. Thus, after a while, \nnobody understands the inner workings of the system, even though the users are using the system at a \nreasonably satisfactory rate. However, a problem arises when somebody finds a bug. How can the system \nbe debugged and maintained without interfering with the other users? What should be done if the system \nstops? Can you, in fact, depend on the system at all? The second observation is of almost the same problem, \nbut from a different viewpoint. Nowadays, programs with the same functions are provided by many different \nvendors, so that users can choose those that best fit their needs and budget. For example, user #l buys \nan OS from vendor #l, and a windowing system from vendor #2, etc. This is very good situation for the \nusers. Vendors request software houses to develop program modules, and buy complete modules from other \nvendors, and combine those modules into software products for release under the vendor s own brand. I \ncall this nested multi-vendor software in the sense that software vendors use other software vendors \nsoftware as their components. Up to this point, users have a physical copy of the software on their machines. \nHowever, the next step is a distributed version. Here, the users don t have a copy on their machines. \nInstead, they only have a calling program and the right to access programs on the vendors machines, In \nturn, the software on the vendors machines will call program modules residing on machines located at \nsoftware houses, and so on. I would like to call this distributed, nested multi-vendor software. Here, \nno physical copy of the programs are made. Instead, they perform remote procedure calls, or remote object \ncalls to each other. In fact, this is already happening. You are using a program on your network through \na license server. The program may use other programs remotely (Figure 3). Figure 3: Distributed, Nested \nServers Once again, assume that somebody finds a bug. How can the system be debugged and maintained without \ninterfering with the other users? What should be done if the system stops? Can you depend on the system \nat all? I would like to summarize that, in open and distributed systems, we use a software module without \nhaving complete knowledge of it. Thus, it would appear to be like it is changing by itself. And, you \nneed to discover the services you need. Then, you have to write your program in such a way that it protects \nthe users or customers, by protecting the services and defending the computational resources you provide. \nI don t think that concurrent objects provide a suitable framework for such defensive programming. First, \nI would like to claim that we need the notion of time for programming open, distributed systems. This \nnecessity is derived from the fact that the essential difference between a distributed system and a concurrent \nsystem is the existence of distance in the system, which is equivalent to time. Second, we need a higher \nlevel module than a concurrent object for constructing a larger system. Hence, the above situations can \nbe naturally modeled as a society of such modules. Let s call such a higher level module an autonomous \nagent.   4 Autonomous Agents Now, I would like to give a rough definition of autonomous agents. First, \nI would like to clarify that the notion of autonomous agents does not conflict with the notion of objects \nor concurrent objects. In fact, an agent will be composed of concurrent objects, in much the same way \nas a person is composed of cells living concurrently. An autonomous agent is the unit of individual software, \nthat interfaces with humans, other agents, and the real world in real-time. Each autonomous agent has \nits own goal, and reacts to stimuli, based on its situation. It behaves to survive. The collection of \nautonomous agents forms a society. The definition of an individual is most important in thinking about \nautonomous agents. This is one kind of granularity argument, but taken from a completely different viewpoint, \ni.e., not for parallelism or efficiency, but for robustness or defensive programming. According to recent \nfindings in biology and the theory of evolution, definition is very difficult, ahnost impossible, in \nfact. But we will not take such a serious approach. We instead use a naive, intuitive definition: An \nindividual autonomous agent is a collection of component objects (or cells) that are not physically shared \nwith other individuals. We assume an individual is a unit of feedback for utility or reward. An individual \ncan be considered as being the unit of security, which corresponds to our bodies immune system. It can \nalso be regarded as being the unit of reliability and maintenance which corresponds to homeostasis. That \nis to say, security and reliability have to be provided and maintenance has to be done on an individual \nbasis, not as a whole system. Each individual autonomous agent should provide such abilities per se. \nFor its functionality, each autonomous agent has an individual goal. It is reactive, in the sense that \nit responds to a stimulus, taking the situation or environment into consideration, in real-time. This \nimplies that an autonomous agent is not just an object that responds to an input, but also needs to be \nable to learn the situation, and to have the ability to make timely decisions in real-time. Survival \nis yet another important property of each individual autonomous agent. This property is, in fact, the \nresult of only autonomous agents with a higher survivability surviving. To survive, an autonomous agent \nhas to make its best effort to satisfy the users, in terms of response time and functionality; or the \nquality of services in general, so that it can maximize its utility. Restaurants with bad food or those \nthat makes you wait one hour for today s special would never survive. To survive, an autonomous agent \nhas to keep its losses to a minimum. This is called the least suffering strategy. A simple example is \nthat, if your order doesn t come within one hour, you should decide whether to wait longer or move to \na different restaurant. You have to monitor the situation and make a decision on time-out. That is to \nsay, time-out is the last resort for survival in open, distributed systems. A simple programming language \n[47] and a formal system [42], which provide for the agents survivability by incorporating a time-out \nnotion, were presented at OOPSLA 92 by myself and my co-authors. Agents should provide the facility of \nreflection to allow their adaptation to environments 128, 251. Agents with negotiation ability are advantageous. \nAgents that can maintain a cooperative relationship for a longer duration are more profitable. They can \nform a group, and thus, society. Research on negotiation, cooperation, and group formation can be seen \nin one area of Artificial Intelligence, called Distributed AI [23, 131 or Multiagent Systems [lo]. 5 \nCurrent Research Activities Here, I would like to present some of our research activities into open and \ndistributed systems, currently being carried out at Sony Computer Science Laboratory and Keio University. \nThe work is mainly based on concurrent objects and, as a whole, on autonomous agents. I believe that \na future computer system must be: ubiquitous, so that you can use it any time and anywhere; . portable \nand mobile, so that you can carry it and use it on the move; reliable and secure, so that you can depend \non it; and . friendly, so that it is comfortable and easy to use. With the ultimate goal of realizing \nsuch a computer system, I have been proposing two notions: intimate computers and computational field \n[52, 531. 5.1 Intimate Computers Intimacy implies security, peace of mind, trustworthiness, reliability, \nand respect. The intimate computer is intended to inspire users with such a feeling. It has a face, and \nit understands natural languages, so that it presents you with a completely different user-computer interface \nfrom those we are used to today (Figure 4). An intimate computer can be seen as an autonomous agent overall, \nwhereas it is composed of a collection of autonomous agents. Washington, D.C. September 26-October 1, \n1993 5.2 Computational Field Model Figure 4: An Intimate Computer An intimate computer can be thought \nof as an evolved version of a Personal Digital Assistant. It can be used as an access terminal to distributed \ncomputing facilities. It can be used as a communication terminal to access other intimate computers and \ntheir users. But, the ultimate purpose is the dialog itself; understanding each other and recognizing \neach other, rather than an interchange of ordering and inquiring. Unfortunately, intimate computers are \nnot yet available, but the following is an example of a possible conversation with an intimate computer \nin the future: Hey buddy, couEd you arrange a dinner meeting with Ralph? My intimate computer understands \nwho I mean by Ralph, asks Ralph s intimate computer when he is available, what kind of food he likes, \nmakes a reservation for a restaurant, then comes back to me saying, It s done. On another occasion, my \nintimate computer suddenly talks to me Hey, Mario, how re you doing ? And I respond Don t bother me now! \nThen, my intimate computer exultantly says to me Sorry, but I guess you forget something. It s your daughter \ns birthday. You should go back home right now! To make intimate computers usable in a distributed environment, \nwe need an infrastructure. I am proposing a higher-level abstraction of distributed computing than that \nof computers connected by networks. Forget about computers and networks; let s consider the field of \ncomputers. It is like a sea of computers. Concurrent objects are floating on the sea (Figure 5). The \nsea, the Computational Field, yields various forces between objects for the suboptimal placement of objects \nfor moving users, grouping objects, balancing loads, and avoiding faults, such as: Gravitational force \nis defined for grouping objects. Frequent communication between objects yields a stronger force. Repulsive \nforce is defined for load balancing. If two objects come very close, the repulsive force increases between \nthem. Friction is defined for stability. It is proportional to the size, or weight of each object, so \nthat a large object tends not to move. Significance of the Computational Field Model is that it integrates \nload balancing and object grouping. Figure 5: Computational Field Model I will explain how the Computational \nField works (Figure 6). If you place a task in the Computational Field, a mountain is formed which is \na collection of concurrent objects for the given task. Then, a repulsive force between the objects arises, \nso that the mountain becomes lower and lower. At the same time, the gravitational force between concurrent \nobjects increases, as they send messages to each other. Thus, they form a hill, as the two forces balance. \nIf the user moves, the mountain follows. Figure 6: Dynamic Object Placement All those properties are \nactually realized by an underlying distributed operating system. Also, the notion of concurrent objects \nis indispensable for object migration, as pointed out above. 5.3 Essential Technologies To realize intimate \ncomputers and the computational field, many points demand our attention. We are currently concentrating \nour efforts on the following five topics: Multi-Modal Interaction Operating Systems Computer Networks \nProgramming Languages, and Multi-Agent Systems Demonstration videos are available for the first three \ntopics. Speech Dialog with Facial Displays The first demonstration is of the speech dialog system with \nfacial displays [48, 331. The system was developed to verify the idea of bringing facial displays into \nhuman computer interaction as a new modality to make computers more communicative and sociable. It consists \nof two subsystems. One is a speech dialog subsystem, The other is a facial animation subsystem. The speech \ndialog subsystem consists of a speech recognition module, a syntactic and semantic analyzer, a plan recognition \nmodule, a response generation module, and a voice synthesis module. It realizes speaker-independent speech \nrecognition and handles the speaker s intentions. A facial animation subsystem generates a facial display \nby the local deformation of the polygons representing the 3D face. We adopted Keith Waters method [55] \nfor our deformation scheme. Lip and speech synchronization was also implemented. The speech dialog subsystem \nrecognizes a number of typical conversational situations that are important in dialog. These situations \nare associated with specific conversational facial displays categorized by Nicole Chovil [8]. Upon detecting \na prescribed situation, each module in the speech dialog subsystem sends a request for a specific facial \ndisplay to the facial animation subsystem. An empirical study of the system with 32 subjects indicated \nthat the speech dialog system with facial displays is helpful, especially in the first interaction with \nthe system. An example of a session is shown in Figure 7. Figure 7: Speech Dialog System with Facial \nDisplays The system uses two workstations, one for speech dialog and the other for facial display, running \nin real- time mode. The speech dialog subsystem is designed as a multi-agent system, whereas the facial \ndisplay subsystem is currently a collection of C programs. We plan to introduce more modalities, such \nas reading the user s face. We are also interested in investigating the relationship between the framework \nof our work with social knowledge and social actions, as presented by Les Gasser [ 141. Apertos Distributed \nReal-Time OS The second demonstration is on the Apertos operating system [57, 581. The Apertos OS is \na pure object- oriented, real-time OS, based on concurrent objects. It clearly separates objects and \nme&#38;objects, and it can evolve by itself by using the mechanism of reflection, without stopping. Object \nmigration and distributed naming mechanisms are provided at the system level. That is, this supports \nthe Computational Field. The Apertos OS has been stably operating on Sony s 68030- based workstations \nsince April 1991, and was recently ported to Sony s R3000-based workstations and 486- based IBM PC-compatible \ncomputers. Virtual tnternet Protocol The last demonstration is of the computer network protocol that \nsupports mobile hosts. It is called the Virtual Internet Protocol, or VIP for short [50,49]. By using \nthis protocol, you can hook-off your portable workstation from the current network, move with it, and \nhook it into any interconnected network. You can obtain the same computing environment there, and all \nWashington, D.C. September 264ctober 1,1993 messages are redirected to the new location, taking their \noptimal routes. You can even move with your portable workstation while preserving communication channels. \nThe mechanism we designed is analogue to that of virtual memory. Virtual to physical address translation \nis done in a distributed manner by using cached mapping information. Since this protocol is implemented \nas a sublayer of IP, it is transparent to application programs. It has been running since spring of 1992, \nand has been proposed to the Internet Engineering Task Force (IETF) for standardization. VIP protocol \nis running on UNIX and MS-DOS machines, but is not described in an object-oriented style at this moment. \nPorting to Apertos OS in an object-oriented fashion will be done very soon. We are also interested in \ncombining this technology with real- time communication facilities [43]. Pro ramming Languages and P \nSystems  Mu ti-Agent We are intensively doing research on Programming Languages and Multi-Agent Systems. \nRegarding the former field, we are especially interested in persistent object programming languages [54, \n3 1 I, distributed transactions [183 and the applicability of the notion of reflection to distributed \nand real-time programming [37, 211. For the latter, we are interested in collaboration [38, 291.  6 \nVolitional Agents I have proposed concurrent objects and autonomous agents, and have presented some of \nour research at Sony Computer Science Laboratory and Keio University. Here, I would like to raise the \nfinal question, that is: Are autonomous agents suficient for future computing? Are they safe? Are they \nstable? Are they cooperative to humans? In fact, I don t have any answer to these questions. But, I would \nlike to be a little provocative and controversial in saying that the definition of autonomous agents \ngiven in section 4 may not be sufficient, safe, or cooperative to humans, and that a society composed \nof such autonomous agents would not be stable. Hence, I would like to propose volitional agents. Volition \nmeans actions with will or actions of will. So, a volitional agent is an autonomous agent with will, \nor a spontaneous autonomous agent. A volitional agent is more active than an autonomous agent which is \nreactive. It has desire, or it is aggressive [27]. I am saying that volitional agents are safer, more \nstable, and more cooperative with humans, compared to autonomous agents that are reactive. Reactive implies \npassive in a sense, since the agent doesn t perform any action unless it receives input. A society of \nautonomous, reactive agents may seem safe and stable, because they are passive. But that can be the very \nsource of danger. You cannot know anything unless you give an input to the society, which may eventually \nresult in a fatal damage. Volitional agents are active and dynamic, and are doing something all the time. \nInternally, they will have antagonistic desires. Externally, they will have contentions with other agents. \nThey will cooperate to achieve higher utility, and they will compete with each other to survive through \nnatural selection (since computer environments are rather artificial than natural, we may need minimal \nlegislation to ensure fair competition). They might behave selfishly [9]. Since volitional agents are \nactive, and society is living, we can observe the behavior of the society. And, we can obtain even a \nhigher stability of the society. Of course, it is impossible to predict the precise behavior in any ways, \nsince the system is very large and complex. However, we can take advantage of recent developments in \nthe study of complex dynamical systems. For example, according to the theory of chaos [ 111, it is given \nthat under a certain condition, a system of active or dynamic components give a higher stability than \nthat of passive or static components. A society of agents, as well as our own society, should be evolutionarily \nstable. This means that society is stable for a while, but the environment changes, so that it rather \nquickly moves to the next stable state. This phenomenon can also be explained for a system of active \nor dynamic components as a phase transition by taking the same approach. Hence, we can conclude that \nvolitional agents can provide a higher stability without sacrificing flexibility of the society than \nautonomous agents. This will lead to a society that is safer and more cooperative with humans. The importance, \nand the necessity for aggressiveness in forming a stable society has been studied in the field of biology \nand ethology, such as in the work of Nikolass Tinbergen [5 11 and Konrad Lorenz [27]. The stability of \nsociety has also been intensively studied by political scientist Axelrod [4], biologist Maynard-Smith \n[45], and other researchers, taking game-theoretic approaches. Study for the behavior of society taking \ndynamical systems approaches are found in the new area called Ecology of Computation [22] or Emergent \nComputation [12]. We have also started research in this direction, particularly on chaos and collective \nbehavior [35, 46, 361. Distributed and massively parallel computing are expected to be powerful computing \nplatforms [26].  7 Conclusions I have discussed a couple of things in this paper. Objects are things \nwhich can be distinguished from others. This notion brought us macroscopic programming. Concurrent objects \nare the real self- contained objects including virtual processors. This provided us with easy concurrent \nprogramming. Objects and concurrent objects are the cells for autonomous agents. Autonomous agents are \nbased on the notion of the individual, are reactive, and try to survive. They form a society. Then, I \ndescribed and showed our recent research accomplishments toward the society of agents: the Intimate Computer, \nthe Computational Field Model, the Apertos object-oriented OS and the VIP mobile host protocol. Finally, \nI raised a controversial proposal for volitional agents, that would provide safer and more cooperative \ninteraction with humans and other agents, and that would provide an evolutionarily stable society, with \nwhich we can cohabit. The notion of volitional agents is a conjecture, without any proof. We don t know \nhow to make a volitional agent. We don t even know what desire, or aggressiveness mean. But a new way \nof under- standing collective behavior in terms of dynamic, non-deterministic, stochastic, and irreversible \nprocesses is taking root in various scientific fields. I have already mentioned this trend in biology, \nethology, and the theory of evolution. We can also see similar movements in AI, such as the Society of \nMind by Marvin Minsky [321 and the Subsumption Architecture by Rodney Brooks [6]. It is also happening \nin Chemistry and Physics. For example, a new view is given based on Thermo- dynamics by Ilya Prigogine \n[41]. It is giving us the sign of departing from the reductionist attitude or the Cartesian attitude \nin science. The notion of Open Systems was advocated by philosopher Karl Popper [39, 403 and brought \nin to computer science by Carl Hewitt [17]. We must inevitably see Distributed and Open Systems as societies. \nThis is already coming. In this paper, I proposed the notion of autonomous agents and volitional agents \nas individuals of societies. Volition might be the true meaning of autonomy, and may realize a safe, \nstable, cooperational society with computers.  Acknowledgment I would like to thank Akikazu Takeuchi, \nYasuhiko Yokote, Fumio Teraoka, Katashi Nagao, Hiroaki Kitano, Jun Tani, Toru Ohira, Chisato Numaoka, \nShigeru Watari, Tatsumi Nagayama, and other researchers at Sony Computer Science Laboratory; Kohei Honda, \nIchiro Satoh, Vasco Vasconcelos, and many other students and ex-students at Keio University; Aki Yonezawa, \nSatoshi Matsuoka, Gregor Kiczales, Eric Manning, Koiti Hasida, J&#38;g Kaiser, and many other friends \nof mine in computer science, for their inspiring discussions and help in preparing for the speech and \nthis manuscript. Finally, I would like to thank the many members of the audience at the OOPSLA 93 conference \nwho gave me useful comments and encouraged me to prepare this manuscript. References [l] Agha, G., ACTORS: \nA Model ofConcurrent Compuration in Distributed Systems, MIT Press, 1986. [2] Agha, G., Wegner, P., and \nYonezawa, A., eds, Research Directions in Concurrent Object-Oriented Programming, MIT Press, 1993. [3] \nAmerica, P., POOL-T: A Parallel Object-Oriented Language, in Object-Oriented Concurrent Programming, \neds. Yonezawa, A., and Tokoro, M., MIT Press, 1987. [43 Axelrod, R., The Evolution of Co-operation, Basic \nBooks, Inc., 1984. [S] Black, A. P., Supporting Distributed Applications: Experience with Eden, Proceedings \nof ACM Symposium on Operating System Principles, p. 39-5 1, December, 1985. [6] Brooks, R., Intelligence \nWithout Representation, Artificial Intelligence, Vol. 47, p, 139-160, 1991. [7] Caromel, D., Concurrency: \nAn Object-Oriented Approach, Proceedings of TOOL2, p. 183-198, June, 1990. Washington, [8] Chovil, N., \nDiscourse-Oriented Facial Displays in Conversation, Research on Language and Social Interaction, Vol. \n25, p. 163-194, 1991 [9] Dawkins, R., The Selfish Gene (2nd Edition), Oxford University Press, 1989. \n[lo] Demazeau, Y., Muller, J.-P., and/or Werner, E, Decentralized A.1. 1, 2, and 3, North-Holland, 1990, \n1991, and 1992. [ 1 l] Devaney, R. L., An Introduction to .Chaotic yJ;;mical Systems (2nd Edltlon), Addison-Wesley, \n[12] Forrest, S. (ed.), Emergent computation, MIT Press, 1991. [13] Gasser, L. and Huhns, M. (eds.), \nDistributed Artificial Intelligence Vo1.2, Pittman, London, 1989. [14] Gasser, L., Social Knowledge and \nSocial Action: Heterogeneity in Practice, Proceedings of International Joinr Conference on Artificial \nIntelligence (IJCA1 93), p. 75 l-758, 1993. [15] Gehani, N. H., Concument C++: Concurrent Programming \nwith Class(es), Software Practice and Experience, Vo1.16, No.12, Dee, 1988. [16] Hewitt, C. E., A Universal, \nModular Actor Formalism for Artificial Intelligence, Proceedings of International Joint Conference on \nArtificial Intelligence, 1973. [17] Hewitt, C. E., The Challenge of Open Systems, Byte, April 1985, p. \n223-242, 1985. [ 181 Hirotsu, T., A Flexible Transaction Facility for Distributed Object-Oriented Systems, \nProceedings of IEEE Works/lop on Object-Orientation in Operating Systems, September, 1992. [19] Honda, \nK. and Tokoro, M., An Object Calculus for Asynchronous Communication, Proceedings of ECOOP 91, LNCS 512, \np. 133-147, June, 1991. [20] Honda, K. and Tokoro, M., Combinator Representation of Mobile Processes, \nProceedings of Symposium on Principle ofProgramming Languages, January, 1993. [21] Honda, Y. and Tokoro, \nM., Soft Real-Time Programming through Reflection, Proceedings of IMSA 92 International Workshop on Reflection \nand Meta-level Architecrures, 1992 [22] Huberman, B. A. (ed), The Ecology of Computalion, North-Holland, \n1988. [23] Huhns, M. N. (ed), Distributed Artificial Intelligence, Vol. 1, Pitman, London, 1987. [24] \nIshikawa, Y. and Tokoro, M., A Concurrent Object-Oriented Knowledge Representation Language Orient84/K: \nIts Features and Implementation, Proceedings of OOPSLA 86, p, .232-241, September, 1986. [25] Kiczales, \nG., Towards a New Model of Abstraction in Software Engineering, Proceedings of the IMSA 92 International \nWorkshop on Rejlection and Meta-level Architectures, 1992. D.C. September 26-October 1,1993 [26] K&#38;no, \nH. and Hendler, J., eds., Massively Parallel Artificial Intelligence, The MIT Press, 1994. [27] Lorenz, \nK., Das Sogenannte Bose, Dr. G. Borotha-Schoeler Verlag, 1963. [28] Maes, P., Concepts and Experiments \nin Computational Reflection, Proceedings of OOPSLA 87, p. 147-155, 1987.  [29] Matsubayashi, K., A \nCollaboration Mechanism on Positive Interactions in Multi-Agent Environments, Proceedings of International \nJoint Conference on Artificial Intelligence (IJCA1 93), p. 346351, August, 1993. [30 ]Milner, R., Parrow, \nJ., and Walker, D., A Calculus of Mobile Processes, Part 1 &#38; 2, Technical report ECS-LFCS-89-85 &#38; \n86, University of Edinburgh, 1989. [31] Minohara, T. and Tokoro, M., Providing Dynamic Abstractions and \nType Specifications for Persistent Information, Proceedings of Int. Conf on Deductive and Object-Oriented \nDatabases, December, 1991. [32] Minsky, M., T/!e Society of Mind, Simon and Schuster, New York, 1987. \n[33] Nagao, K. and Takeuchi, A., A New Modality for Natural Human-Computer Interaction: Integration of \nSpeech Dialogue and Facial Animation, Proceedings of the International Symposium on Spoken Dialogue (ISSD \n93), p. 129-132, 1993. [34] Nierstrasz, 0. M., Active Objects in Hybrid, Proceedings of OOPSL.4 87, p. \n243-253, September, 1987. [35] Numaoka, C. and Takeuchi, A., Collective Choice of Strategic Type, Proceedings \nof International Conference on Simulation of Adaptive Behavior (SAB92). December. 1992. [36] Ohira, T. \nand Cowan, J. D., Feynman Diagrams for Stochastic Neurodynamics, Proceedings of Australian Conference \nof Neural Networks, January 1994. [37] Okamura, H., Ishikawa, Y., and Tokoro, M., Metalevel Decomposition \nin AL-l/D, Proceedings of Object Technologies for Advanced SoftnJare, LNCS No. 742, p. 110-127, November, \n1993. [38] Osawa, E., A Scheme for Agent Collaboration in Open Multiagent Environment, Proceedings of \nInternational Joint Conference on Artificial Intelligence (IJCAI 93), p. 352-358, August, 1993. [391 \nPopper, K. R., The Open Society and its Enemies, Princeton University Press, 1945. [40] Popper, K. R. \nand Lorenz, K., Die Zukunft ist OfSeen (The Future is Open), R. Piper GmbH &#38; Co., 1985. [41] Prigogine, \nI. and Stengers, I., Order out of Chaos, Bantam Books, 1984. 1421 Satoh, I. and Tokoro, M., A Formalism \nfor Real- Time Concurrent Object-Oriented Computing, Proceedings of OOPSLA 92, p. 315-326,1992. [43] \nShionozaki, A. and Tokoro, M., Control Handling in Real-Time Communication Protocols, Proceedings of \nSIGCOMM 93, 1993. [44] Shriver, B. and Wegner, P, eds., Research Directions in Object-Oriented Programming, \nMIT Press, 1987. [45] Maynard Smith, J., Evolution and the Theory of Ganles, Cambridge University Press, \n1982. [46] Tani, J. and Fukumura, N., Learning Goal-directed Sensory-based Navigation of a Mobile Robot, \nNeural Networks, in press. [47] Takashio, K. and Tokoro, M., DROL: An Object- Oriented Programming Language \nfor Distributed Real- time Systems, Proceedings of ACM OOPSLA 92,  p. 276-294, October, 1992.  [48] \nTakeuchi, A. and Nagao, K., Communicative Facial Displays as a New Conversational Modality, Proceedings \nof ACM/IFIP INTERCHI, 1993. [49] Teraoka, F., Yokote, Y., and Tokoro, M., A Network Architecture Providing \nHost Migration Transparency, Proceedings of ACM SIGCOMM 91, p. 209-220,199 1. [50] Teraoka, F., Claffy, \nK, and Tokoro, M., Design, Implementation, and Evaluation of Virtual Internet Protocol, Proceedings of \n12th International Conference on Distributed Computing Systems, p. 170-177, 1992. [51] Tinbergen, N., \nSocial Behaviour in Animals, Methuen &#38; Co. Ltd., 1953. [52] Tokoro, M., Computational Field Model: \nToward a New Computing Model/Methodology for Open Distributed Environment, Proceedings 2nd IEEE Workshop \non Future Trends in Distributed Computing Systems, September, 1990. [53] Uehara, M. and Tokoro, M., An \nAdaptive Load Balancing Method in the Computational Field Model, OOPSMessenger, Vol. 2, No. 2, April, \n1991. [54] Watari, S., Honda, Y., and Tokoro, M., Morphe: A Constraint-Based Object-Oriented Language \nSupporting Situated Knowledge, Proceedings of International Conference on Fifth Generation Computer Systems, \n1992. [55] Waters, K., A Muscle Model for Animating Three-Dimensional Facial Expression, Computer Graphics, \nVol. 21, No. 4, p. 17-24, 1987. [56] Yokote, Y. and Tokoro, M., The Design and Implementation of Concurrent \nSmallTalk, Proceedings of OOPSLA 86, p. 331-340, September, 1986. [573 Yokote, Y ., Teraoka, F., and \nTokoro, M., A Reflective Architecture for an Object-Oriented Distributed Operating System, Proceedings \nof ECOOP 89, p. 89-108, July, 1989. [58] Yokote, Y., The Apertos Reflective Operating System: The Concept \nand its Implementation, Proceedings of OOPSLA 92, p. 397-413, October, 1992. [59] Yonezawa, A., eds., \nABCL An Object-Oriented Concurrent Systems, MIT Press, 1990. [60] Yonezawa, A. and Tokoro, M., eds., \nObject-Oriented Concurrent Programming, MIT Press, 1987.  Contact Information: Mario Tokoro Department \nof Computer Science Keio University 3-14-1 Hiyoshi Yokohama 223 Japan E-mail: mario@keio.ac.jp Mario \nTokoro Sony Computer Science Laboratory Inc. Takanawa Muse Building, 3-14-13 Higashi Gotanda, Shinagawa-ku \nTokyo, 141 Japan E-mail: mario@csl.sony.co.jp Washington, D.C. September 264ctober 1,1993 \n\t\t\t", "proc_id": "260303", "abstract": "", "authors": [{"name": "Mario Tokoro", "author_profile_id": "81100239370", "affiliation": "Keio University & Sony Computer Science Laboratory Inc.", "person_id": "PP43117907", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260303.260305", "year": "1993", "article_id": "260305", "conference": "OOPSLA", "title": "The society of objects", "url": "http://dl.acm.org/citation.cfm?id=260305"}