{"article_publication_date": "04-01-1993", "fulltext": "\n Addendum to the Proceedings OOPSLA Washington, DC-26 September-l October, 7993 Workshop Object-Oriented \nReflection and Metalevel Architectures {F&#38;rth Annual) Report by: Brian Foote University of Illinois \n Introduction This year s workshop on object-oriented reflection and metalevel architectures generated \nan unprecedented level of interest, with thirty-one submissions, and in excess of fifty people in attendance. \nThis summary presents but a flavor of the issues that were addressed at the workshop. Instructions for \nobtaining electronic copies of the attendance list, and the position papers themselves, appear at the \nend of this summary. Session I-A: Theory Moderator: Dan Friedman Presenter: Anurag Mendhekar Respondents: \nJohn Simmons, Constantin Laufer Anurag Mendhekar spoke on representing reflection in the lambda calculus. \nHis system implements an operator reifying the current continuation of an expression, represented by \nits lexical context. This operator corresponds to Scheme s call/cc. Another operator is provided to reinstall \nthe abstracted context. Only the context is reified, and there is no explicit tower. A calculus for the \nsystem is developed and proved correct relative to its operational semantics. John Simmons spoke on extending \ncomputational reflective systems by making the interpreter first-class and extensible. The interpreter \nis represented as two procedures, a prelint and a dispatch. The dispatch does the main work of interpretation \nby dispatching on the type of the expression and performing the proper computation for it. The prelim \nallows additional actions to be performed before or after the dispatch. This representation extends the \npower of traditional reflective systems. It permits the addition of new special forms, the modification \n(by shadowing) of basic interpreter actions on constants, variables, and applications, and the inclusion \nof actions preceding or following the main computation. Constantin Laufer spoke on implementing reflection \nin a statically typed system. Using Haskell, he implements a system providing reflection on expressions. \nExpressions are represented as pairs, containing both uncompiled and (lazily) compiled versions of the \nexpression. The compiled version can be used for computation, the uncompiled version for reification. \nThe reify and reflect operators provide reification and reflection, with the reify operator recursively \nhandling motion up the implicit tower. Session I-B: Architecture Moderator: Dan Friedman Presenter: \nJeff McAffer Respondents: Care1 Bekker, Patrick Steyaert Jeff McAffer presented the CodA MOP, a framework \nfor creating, controlling, and understanding concurrent computing environments. CodA is built atop Smalltalk- \n80. Its essential component is a simple, clear, and consistent interface protocol specification for basic \nsystem objects, such as schedulers, objects, and meta- objects. CodA uses the operational decomposition \nmethod of defining the metalevel. CodA embodies a complete system model which is independent of any implementation \nenvironment or language. Metadefinition, rather than meta-interpretation is emphasized. Care1 Bekker \npresented ALBEDO, a meta-object infrastructure for Smalltalk. ALBEDO adds support for a family of Maes-style \nme&#38;objects to Smalltalk-80. These meta-objects may be associated with any existing Smalltalk object. \nA library of me&#38;objects has been implemented using ALBEDO. Because meta-objects are distinct from \nthe objects they are attached to, reusability, extensibility, and the understandability of the system \nare enhanced. Patrick Steyeart took the view that rather than viewing extensibility as a consequence \nof a reflective architecture, we should instead consider extensibility as an a priori condition for the \ndefinition of reflection. He presented a two stage approach for introducing reflection into a hypothetical \nprogramming language, ASEL. The first stage is to define an open implementation for this language. The \nsecond stage is to make this open implementation explicit, or first-class. Addendum to the Proceedings \nOOPSLA 93 123  Session II-A: Concurrency Moderator: Pierre Cointe Presenter: Hideaki Okamura Respondent: \nKen Wakita Hideaki Okamura presented a paper discussing how shared resources can be modified in AL-l/D. \nThe mechanism used employs the concept of grouping. Objects in a group share the resources that belong \nto the group. Examples of shared resources might be schedulers or garbage collectors. The paper also \naddressed how user-defined and default system resources cooperate. Ken Wakita discussed how first-class \nmessages, or message continuations provide object-oriented concurrent programming languages with extensibility \nin modeling and programming communication schemes such as asynchronous communication, multicasting, sophisticated \nsynchronization constraints, inter-object synchronization, concurrency control, resource management, \nand the like. Despite this extensibility, the framework guarantees that no program can undermine the \nbuilt-in communication primitives, Session II-B: Massive Parallelism Moderator: Pierre Cointe Presenter: \nHidehiko Masuhara Respondent: Takashi Tomokiyo Hidehiko Masuhara discussed the design of an object- oriented \nreflective language for massively parallel processors. One of the major problems in massively parallel \nprogramming is dynamic resource management, such as load balancing and scheduling. Simple management \npolicies sometimes lead to lackluster performance under unexpected conditions, while complicated ones, \nwhich are effective under any situation, often impose considerable overhead. What is needed is an ability \nto provide abstractions for a variety of policies. Reflective languages provide this flexibility. Masuhara \net. al s language is based on ABCL/R2, which is extended so that the user can control the parallel programming \nprimitives. In this architecture, the user can build his or her own resource management system-load-balancing, \nscheduling, etc.-at the me&#38;level, controlling the policies of primitives such as object creation, \nobject migration, and scheduling. Takashi Tomokiyo presented the metalevel architecture of a parallel \nobject-based language called OCore. This language has simple, statically typed semantics to make compiled \nprograms more safe and efficient. An object has a single thread, called the normal thread, for normal \noperations. Exceptions are handled by an exception handling thread. Communication between objects is \nbased on asynchronous, one-way message passing. Classes in OCore are merely templates, as in C++, and \nare not themselves first-class objects. The metalevel architecture of OCore handles three kinds of events: \nstate transition events, user-defined events, and exceptions. Certain elements of an object s internal \nrepresentation are visible at the metalevel via pseudo- variables. Session Ill-A: C++ Moderator: Jacques \nMalenfant Presenter: Shigeru Chiba Respondents: Roger Burkhart, Roger Voss There is growing evidence \nthat users are chafing under the limitations that relatively closed languages such as C and C++ impose \nupon them. For instance, the current interest in runtime type information in the C++ community, and the \nwidespread practice of building dynamic object systems atop C and C++, support the observation that real-world \nproblems demand first- class, dynamic access to metalevel information and mechanisms. Shigeru Chiba described \nthe language Open C++, which extends C++ to allow programmers to define their own method call and variable \naccess mechanisms. He then showed how they used these Open C++ mechanisms to support distributed programming. \nThe second paper, by Roger Voss, illustrates the dilemma that faces the frustrated user who would like \nto have a hook into some part of a language s implementation to be able to solve a particular problem. \nMr. Voss is confronted with the problem of class evolution in C++ class libraries. His proposal for addressing \nthis issue requires a modification to the usual C++ v-table-based dispatching scheme. In non- reflective \nlanguages, even a simple change can entail a protracted struggle with various standards committees. Roger \nBurkhart discussed request functions for C. A request function is a new kind of C function that creates \na context, which is a set of data concerning the function call, that is made accessible to the program. \nThe primary point of this conservative extension is to have a means, readily implementable in C, for \nbuilding more comprehensive reflective facilities. Session III-B: Partial Evaluation Moderator: Jacques \nMalenfant Presenter: Erik Ruf Respondent: Kenichi Asai Erik Ruf feels that partial evaluation is far \nfrom the point where it could be used to efficiently implement reflective languages. In fact, existing \npartial evaluators are weak, bulky and inefficient. Moreover, there is a major flaw in the current work \nin partial evaluation for reflective languages. When reifying portions of the implementation information, \ndecisions are made about the way this information will be represented. For instance, when reifying environments, \nit is standard practice to reify them as association lists. Currently, there is no way a partial evaluator \nwill be able to get rid of this data structure and the resulting program (after partial evaluation) may \nget stuck with inefficient access to environments because the implementation decision survived the partial \nevaluation process. Kenichi Asai reported on some experiments in partial evaluation using a reflective \nextension to Scheme that allowed reflective towers in which the interpreter at each level could be modified \ndynamically. Asai noted that they succeeded in applying partial evaluation, but in a static way (once \nand for all before the execution of the program). Washington, D.C. September 264ctober 1,1993 During \nthe discussion, Dan Friedman asked Mr. Ruf if he considers it impossible to build a partial evaluator \nthat would be able to cope with the environment access problem discussed above. Friedman conjectured \nthat with sufficient knowledge and complexity, an interpreter could deal explicitly with storage management \nand make it possible for the partial evaluator to generate code which would compare favorably with compiled \ncode. Mr. Ruf conceded that he could imagine such an interpreter, but it would be quite a challenge to \npartial evaluate it using the current partial evaluation technology.  Session Ill-C: Garbage Collection \nModerator: Jacques Malenfant Presenter: Barry Hayes The final part of the session was devoted to a paper \nby Mr. Hayes on reflection and garbage collection. He claimed that the state of the art in garbage collectors \nis to provide knobs that allow users to feed in application level information that can be used profitably \nby the garbage collector. Unfortunately, these knobs are introduced in an ad hoc manner. Maybe reflection \ncan help here, but it is also a challenge to open garbage collectors to users. While he noted that reflective \ngarbage collectors could probably be implemented efficiently, the questions lie more on the side of the \nusers. Will they be able to manipulate such a crucial part of the system profitably and correctly? Session \nIV-A: Object Integration Moderator: Yasuhiko Yokote Presenter: Mireille Fomarino Respondents: H. Justin \nCoven, Ming Peng Existing object-oriented languages provide relatively weak facilities for representing \ndynamic relationships among objects. Users, however, may build their own using reflection. Mireille Fomarino \ndescribed a CLOS/MOP-based meta-architectural solution to the problem of keeping track of dependencies \nbetween objects. They introduce links to define dependencies, metalinks to define the structure of links, \ncontrollers to invoke control procedures and manage interactions between instance-of-links, and generic \nfunctions to invoke the current controller. Links are created incrementally. Thanks to metalinks, users \ncan extend and customize the behavior of links, H. Justin Coven discussed how interconnections, the links \namong pieces of information, and control issues might may be addressed using reflection. Ming Peng described \nan object-oriented system that illustrated how mechanisms to dynamically represent interacting forces \nto address the frame problem might be constructed. Session IV-B: Systems and Applications Moderator: \nY asuhiko Yokote Presenter: Gary Lindstrom Respondents: John Gilbert, Francois Rousseau Ubiquitous object \nsupport in truly open systems will require that we refactor our computing systems so that support now \nprovided on a per-process basis is elevated to the level of permanent system service. Gary Linstrom proposed \nthat module management be elevated to this level, and that these objects be cast themselves as first-class \nobjects. His factoring draws on insights from the programming language as well as system architecture \ncommunities. Although many systems are (assumed to be) implemented in the context of a single programming \nlanguage, their work investigates how to support multiple programming languages. John Gilbert discussed \nthe importance of reflective facilities in open-ended scientific, realtime, and multimedia applications. \nHere, he claimed, reflection is essential to facilitate computational resource management, software configuration, \nfault tolerance, and reuse. Francois Rousseau illustrated how meta-information is vital to the construction \nof modem tools for browsing programming languages such as ClassTalk. Concluding Remarks: Dave Thomas \nReflection and me&#38;object programming provide an elegant and principled perspective on computation. \nThe breadth of presentations at this workshop serve to illustrate the wide applicability to both applied \nand theoretical problems. These concepts, however, need to be clearly illustrated and explained to students, \nresearchers and software engineers if this promising perspective of computation is going to have a major \nimpact on mainstream computation. Everyone I know who has experienced computation through the exploration \nof even a simple me&#38;circular interpreter has a different, deeper view of language semantics and computation. \nWe need to use common reference implementations such as TinyClos and Classtalk to illustrate applications \nand new ideas. Only if we communicate our ideas will others be able to understand the true benefits of \nOpen Architectures. Failure to do so will leave reflection as a computational cult going meta. One need \nonly look at how few schools teach Scheme, ML or Smalltalk to realize the challenge which we have if \nmeta- programming is to be part of every software engineer s toolkit/thinking process. The well-attended \nand highly successful MOP tutorial earlier this week is an excellent beginning.  Epilog: Brian Foote \nJust as objects are good for building programs and for aiding in their evolution, so too are they good \nfor building programming languages and computing systems. Unfortunately, the reflection community has \ndeveloped a not entirely undeserved reputation for abstruseness, even as meta-architectural ideas are \nincreasingly being incorporated into real object-oriented languages, databases, and systems, such as \nIBM s SOM. One of the more interesting discussions of the day raised the question of whether terms such \nas reflection and metalevel have unnecessarily confused the broader perception of our open object- oriented \narchitectural agenda. Gregor Kiczales remarked that these are good terms, but we shouldn t lead with \nthem. In any case, as the computing industry prepares to build its next-generation systems out of objects, \nit is Addendum to the Proceedings OOPSLA 93 imperative that we reach out and strive to more widely and \nclearly communicate our architectural vision.  Workshop Organizers: Electronic Proceedings: Pierre Cointe \nE. des Mines de Nantes Brian Foote (chair) U. of Illinois at UC Dan Friedman Indiana University Jacques \nMalenfant U. of Montreal Dave Thomas OTI Yasuhiko Yokote Sony CSL  Anonymous ftp to: p3OO.cpl.uiuc.edu \n(128.174.72.1) pub/Washington camille.is.s.u-tokyo.ac.jp (133.11.12.1) pub/oopsla93/reflection or EMail \nto: reflection-workshop@p3OO.cpl.uiuc.edu foote@cs.uiuc.edu Reflection Mailing List Join: reflection-request@ \np300.cpl.uiuc.edu Post: reflection@p300.cpl.uiuc.edu Washington, D.C. September 26-October 1,1993  \n\t\t\t", "proc_id": "260303", "abstract": "", "authors": [{"name": "Brian Foote", "author_profile_id": "81100258465", "affiliation": "University of Illinois", "person_id": "PP31034318", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260303.260359", "year": "1993", "article_id": "260359", "conference": "OOPSLA", "title": "Object-oriented reflection and metalevel architectures {fourth annual}", "url": "http://dl.acm.org/citation.cfm?id=260359"}