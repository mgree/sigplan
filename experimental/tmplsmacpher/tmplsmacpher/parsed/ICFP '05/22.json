{"article_publication_date": "09-12-2005", "fulltext": "\n Associated Type Synonyms Manuel M. T. Chakravarty Gabriele Keller Simon Peyton Jones University of \nNew South Wales Microsoft Research Ltd. Programming Languages and Systems Cambridge, UK {chak,keller}@cse.unsw.edu.au \nsimonpj@microsoft.com Abstract Haskell programmers often use a multi-parameter type class in which one \nor more type parameters are functionally dependent on the .rst. Although such functional dependencies \nhave proved quite popular in practice, they express the programmer s intent somewhat indirectly. Developing \nearlier work on associated data types,we propose to add functionally-dependent types as type synonyms \nto type-class bodies. These associated type synonyms constitute an interesting new alternative to explicit \nfunctional dependencies. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language \nConstructs and Features General Terms Design, Languages, Theory Keywords Type classes; Type functions; \nAssociated types; Type inference; Generic programming 1. Introduction Suppose you want to de.ne a family \nof containers, where the repre\u00adsentation type of the container de.nes (or constrains) the type of its \nelements. For example, suppose we want containers supporting at least insertion, union, and a membership \ntest. Then a list can con\u00adtain elements of any type supporting equality; a balanced tree can only contain \nelements that have an ordering; and a bit-set might represent a collection of characters. Here is a rather \nnatural type for the insertion function over such collections: insert :: Collects c . Elem c . c . c \nThe type class Collects says that insert is overloaded: it will work on a variety of collection types \nc, namely those types for which the programmer writes an instance declaration for Collects. But what \nis Elem? The intent is obviously that Elem c is the element type for collection type c; you can think \nof Elem as a type\u00adlevel function that transforms the collection type to the element type. However, just \nas insert is non-parametric (its implementation varies depending on c), so is Elem. For example, Elem \n[e] is e,but Elem BitSet is Char. The core idea of this paper is to extend traditional Haskell type classes \nwith the ability to de.ne associated type synonyms. In our example, we might de.ne Collects like this: \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n05 September 26 28, 2005, Tallinn, Estonia. Copyright c . 2005 ACM 1-59593-064-7/05/0009. . . $5.00. \nclass Collects c where type Elem c --Associated type synonym empty :: c insert :: Elem c . c . c toList \n:: c . [Elem c] The type de.nition says that c has an associated type Elem c, without saying what that \ntype is. This associated type may then be used freely in the types of the class methods. An instance \ndeclaration gives an implementation for Elem, just as it gives an implementation for each method. For \nexample: instance Eq e . Collects [e] where {type Elem [e]= e; ...}instance Collects BitSet where {type \nElem BitSet = Char; ...}instance (Collects c, Hashable (Elem c)) . Collects (Array Int c) where {type \nElem (Array Int c)= Elem c; ...} Haskell a.cionados will recognise that associated type synonyms attack \nexactly the same problem as functional dependencies, intro\u00adduced to Haskell by Mark Jones .ve years ago \n[15], and widely used since then in surprisingly varied ways, many involving type\u00adlevel computation. \nWe discuss the relative strengths of the two ap\u00adproaches in detail in Section 6. It is too early to say \nwhich is bet\u00adter ; our goal here is only to describe and characterise a new point in the design space \nof type classes. Speci.cally, our contributions are these: We explore the utility and semantics of type \nsynonym declara\u00adtions in type classes (Section 2).  We discuss the syntactic constraints necessary to \nkeep type in\u00adference in the presence of associated type synonyms decidable (Section 3).  We give a type \nsystem that supports associated type synonyms and allows an evidence translation to an explicitly typed \ncore language in the style of System F (Section 4).  We present a type inference algorithm that can \nhandle the non\u00adsyntactic equalities arising from associated type synonyms; the algorithm conservatively \nextends Jones algorithm for quali.ed types [12] (Section 5).  This paper is a natural development of, \nand is complementary to, our earlier work on associated data types [1], in which we allow a class declaration \nto de.ne new algebraic data types. We discuss other related type systems in particular, functional dependencies, \nHM(X), and ML modules in detail in Sections 6 and 7. We de\u00adveloped a prototype implementation of the \ntype checker, which we make available online.1 1 http://www.cse.unsw.edu.au/~chak/papers/CKP05.html \n2. Applications of Associated Type Synonyms We begin informally, by giving several examples that motivate \nassociated type synonyms, and show what can be done with them. 2.1 Formatting: type functions compute \nfunction types The implementation of a string formatting function whose type depends on a format speci.er \nseems a natural application for de\u00adpendent types and meta programming [26]. Although Danvy [4] demonstrated \nthat Standard ML s type system is powerful enough to solve this problem, type functions enable a more \ndirect solu\u00adtion [10], using an inductive de.nition instead of explicit continu\u00adation passing style. \nThe following implementation with associated synonyms is based on [22]. Format speci.ers are realised \nas single\u00adton types:2 data If = If --Integer value data Cf = Cf --Character value data Sf = SString f \n--Literal string formatSpec :: S (I (S (CString))) formatSpec = S \"Int: \" $ I $ S \", Char: \" $ C $ \".\" \n--Example format: \"Int: %d, Char: %c.\" The singleton type declarations re.ect the structure of a format \nspeci.er value in their type. Consequently, we can use a speci\u00ad.er s type to calculate an appropriate \ntype for a sprintf function applied to that speci.er. We implement this type level calculation by de.ning \nan associated synonym Sprintf in a class Format in the following way: class Format fmt where type Sprintf \nfmt sprintf, :: String . fmt . Sprintf fmt instance Format String where type Sprintf String = String \nsprintf, pre.x str = pre.x + str instance Format a . Format (Ia) where type Sprintf (Ia)= Int . Sprintf \na sprintf, pre.x (Ia)= .i. sprintf, (pre.x + show i) a instance Format a . Format (Ca) where type Sprintf \n(Ca)= Char . Sprintf a sprintf , pre.x (Ca)= .c. sprintf , (pre.x ++[c]) a instance Format a . Sprintf \n(Sa) where type Sprintf (Sa)= Sprintf a sprintf, pre.x (Sstr a)= sprintf, (pre.x + str) a sprintf :: \nFormat fmt . fmt . Sprintf fmt sprintf = sprintf, \"\" New format-speci.er types (such as I and S above) \ncan be intro\u00adduced by the programmer at any time, simply by de.ning the type, and giving a matching instance \ndeclaration; that is, the de.nition of sprintf is open, or extensible. Notice how important it is that \nthe associated type is a synonym: it is essential that Sprintf fmt is a function type, not a data type. \n 2.2 Generic data structures The collections abstraction Collects from Section 1 is an exam\u00adple of a \ngeneric data structure others include sequences, graphs, and so on. Several very successful C++ libraries, \nsuch as the Stan\u00addard Template Library [29] and the Boost Graph Library [28], pro\u00advide highly-parameterised \ninterfaces to these generic data struc\u00adtures, along with a wide range of implementations of these inter\u00adfaces \nwith different performance characteristics. Recently, Garcia et al. [8] published a qualitative comparison \nof six programming 2 The in.x operator f$ xin Haskell is function application fxat a lesser precedence. \n languages when used for this style of programming. In their com\u00adparison Haskell, including multi-parameter \ntype classes and func\u00adtional dependencies, was rated very favourably, except for its lack of support \nfor associated types. Here is part of the interface to a graph library, inspired by their paper; although, \nwe have simpli.ed it considerably: type Edge g =(Node g, Node g) --We simplify by .xing the edge representation \nclass Graph g where type Node g outEdges :: Node g . g . [Edge g] class Graph g . BiGraph g where inEdges \n:: Node g . g . [Edge g]  Using an associated type synonym, we can make the type of nodes, Node g, a \nfunction of the graph type g. Basic graphs only support traversals along outgoing edges, whereas bi-graphs \nalso support go\u00ading backwards by following incoming edges. A graph representa\u00adtion based on adjacency \nlists would only implement the basic inter\u00adface, whereas one based on an adjacency matrix can easily \nsupport the bi-graph interface, as the following instances illustrate: data AdjList v = AdjList [[v]] \ninstance Enum v . Graph (AdjList v) where type Node (AdjList v)= v outEdges v g =[(v, w) | w . g!!fromEnum \nv] type AdjMat = Array.Array (Int, Int) Bool instance Graph AdjMat where type Node AdjMat = Int outEdges \nv g = let ((from, ), (to, )) = bounds g in [w | w . [from..to], g!(v, w)] instance BiGraph AdjMat where \ninEdges v g = let ((from, ), (to, )) = bounds g in [w | w . [from..to], g!(w, v)] By making Edge, as \nwell as Node, an associated type synonym of Graph and by parameterising over traversals and the data \nstruc\u00adtures used to maintain state during traversals, the above class can be made even more .exible, \nmuch as the Boost Graph Library, or the skeleton used as a running example by Garcia et al. [8].  3. \nThe programmer s-eye view In this section, we give a programmer s-eye view of the proposed language extension. \nFormal details follow later, in Section 4. We propose that a type class may declare, in addition to a \nset of methods, a set of associated type synonyms. The declaration head alone is suf.cient, but optionally \na default de.nition much like those for methods may be provided. If no default de.nition is given, an \noptional kind signature may be used; otherwise, the result kind of a synonym application is assumed to \nbe *. An associated type synonym must be parametrised over all the type variables of the class, and these \ntype variables must come .rst, and be in the same order as the class type variables. Each associated \ntype synonym introduces a new top-level type constructor. The kind of the type constructor is inferred \nas usual in Haskell; we also allow explicit kind signatures on type parameters: class Ca where type Sa \n(k :: * . *):: *  Instance declarations must give a de.nition for each associated type synonym of the \nclass, unless the synonym has been given a default de.nition in the class declaration. The de.nition \nin an instance declaration looks like this: instance C [a] where type S [a] k =(a, ka) The part to the \nleft of the = is called the de.nition head. The head must repeat the type parameters of the instance \ndeclaration exactly (here [a]); and any additional parameters of the synonym must be simply type variables \n(k, in our example). The overall number of parameters, called the synonym s arity, must be the same as \nin the class declaration. All applications of associated type synonyms must be saturated; i.e., supplied \nwith as many type arguments as prescribed by their arity. We omit here the discussion of toplevel data \ntype declarations involving associated types, as we covered these in detail previ\u00adously [1]. In all syntactic \nrestrictions in this section, we assume that any toplevel type synonyms have already been replaced by \ntheir right-hand sides. 3.1 Equality constraints Suppose we want to write a function sumColl that adds \nup the elements of a collection with integer elements. It cannot have type sumColl :: (Collects c) . \nc . Int --Wrong! sumColl c = sum (toList c) because not all collections have Int elements. We need to \nconstrain c to range only over Int-element collections. The way to achieve this is to use an equality \nconstraint: sumColl :: (Collects c, Elem c = Int) . c . Int sumColl c = sum (toList c) As another example, \nsuppose we wanted to merge two collections, perhaps with different representations, but with the same \nelement type. Then again, we need an equality constraint: merge :: (Collects c1, Collects c2, Elem c1= \nElem c2) . c1 . c2 . c2 merge c1 c2= foldr insert c2(toList c1) Without loss of generality, we de.ne \nan equality constraint to have the form (Sat = .), where S is an associated type syn\u00adonym, a are as many \ntype variables as the associated class has parameters, and the t and . are arbitrary monotypes. There \nis no need for greater generality than this; for example, the con\u00adstraint ([Sa]=[Int]) is equivalent \nto (Sa = Int); the con\u00adstraint ([Sa]= Bool) is unsatis.able; and (a = Int) can be eliminated by replacing \na by Int. These restrictions are stronger than they would have to be. However, they allow us later on \nto characterise well-formed programs on a purely syntactical level. 3.2 Constraints for associated type \nsynonyms Does this type signature make sense? funnyFst :: (Elem c, c) . Elem c Recall that Elem is a \npartial function at the type level, whose domain is determined by the set of instances of Collects.So \nit only makes sense to apply funnyFst at a type that is an instance of Collects. Hence, we reject the \nsignature, requiring you to write funnyFst :: Collects c . (Elem c, c) . Elem c to constrain the types \nat which funnyFst can be called. More pre\u00adcisely, each use of an associated type synonym in a programmer\u00adwritten \ntype signature gives rise to a class constraint for its asso\u00adciated class; and that constraint must be \nsatis.ed by the context of the type signature, or by an instance declaration, or a combination of the \ntwo. This validity check for programmer-supplied type an\u00adnotations is conveniently performed as part \nof the kind checking of these annotations, as we will see in Section 4. Kind checking is only required \nfor programmer-supplied type annotations, because inferred types will be well-kinded by construction. \n 3.3 Instance declarations Given that associated type synonyms amount to functions on types, we need \nto restrict their de.nitions so that type checking remains tractable. In particular, they must be con.uent; \ni.e., if a type expres\u00adsion can be reduced in two different ways, there must be further reduction steps \nthat join the two different reducts again. Moreover, type functions must be terminating; i.e., applications \nmust reach an irreducible normal form after a .nite number of reduction steps. The .rst condition, con.uence, \nis already standard on the level of values, but the second, termination, is a consequence of the desire \nto keep type checking decidable. Similar requirements arise already for vanilla type classes as part \nof a process known as context reduction. In a declaration instance (p1,...,pn ) . C t1 \u00b7\u00b7\u00b7tm we call \nC t1 \u00b7\u00b7\u00b7tm the instance head and (p1,..., pn ) the in\u00adstance context, where each pi is itself a class \nconstraint. Such an instance declaration implies a context reduction rule that replaces the instance \nhead by the instance context. The critical point is that the constraints pi can directly or indirectly \ntrigger other context reduction rules that produce constraints involving C again. Hence, we have recursive \nreduction rules and the same issues of con.uence and termination as for associated type synonyms arise. \nHaskell 98 carefully restricts the formation rules for instance declarations such that the implied context \nreduction rules are con.uent and terminat\u00ading. It turns out, that we can use the same restrictions to \nensure these properties for associated type synonyms. In the following, we discuss these restrictions, \nbut go beyond Haskell 98 by allowing multi-parameter type classes. We will also see how the standard \nformation rules for instances affect the type functions induced by associated synonym de.nitions. Restrictions \non instance heads. Haskell 98 imposes the follow\u00ading three restrictions. Restriction (1): Heads must \nbe constructor\u00adbased; i.e., the type patterns in the head may only contain variables and data type constructors, \nsynonyms are not permitted. Restric\u00adtion (2): Heads must be speci.c; i.e., at least one type parameter \nmust be a non-variable term. Restriction (3): Heads must be non\u00adoverlapping; i.e., there may be no two \ndeclarations whose heads are uni.able. Given that the heads of associated synonyms must repeat the type \nparameters of the instance head exactly, the above three re\u00adstrictions directly translate to associated \nsynonyms. Restriction (1) is familiar from the value level, and we will discuss Restriction (2) a little \nlater. The value level avoids Restriction (3) by de.ning that the selection of equations proceeds in \ntextual order (i.e., if two equations overlap, the textually earlier takes precedence). However, there \nis no clear notion of textual order for instance declarations, which may be spread over multiple modules. \nRestrictions on instance contexts. Haskell 98 imposes one more restriction. Restriction (4): Instance \ncontexts must be decreasing. More speci.cally, Haskell 98 requires that the parameters of the constraints \npi occurring in an instance context are variables. If we have multi-parameter type classes, we need to \nfurther require that these variable parameters of a single constraint are distinct. Restriction (4) and \n(2) work together to guarantee that each context reduction rule simpli.es at least one type parameter. \nAs type terms are .nite, this guarantees termination of context reduction. In the presence of associated \ntypes, we generalise Restric\u00adtion (4) slightly. Assuming .1,...,.n are each either a type vari\u00adable or \nan associated type applied to type variables, a context con\u00adstraint pi can either be a class constraint \nof the form D .1 \u00b7\u00b7\u00b7.n or be an equality constraint of the form S a1 \u00b7\u00b7\u00b7am = t. The right-hand sides \nof the associated type synonyms of an in\u00adstance are indirectly constrained by Restriction (4), as they \nmay only contain applications of synonyms whose associated class ap\u00adpears in the instance context. So, \nif we have instance (p1,...,pn ) . C t where type SC t =[SD a] and SD is associated with class D, then \none of the pi must be D a. In other words, as a consequence of the instance context re\u00adstriction, associated \nsynonym applications must have parameters that are either distinct variables or other synonyms applied \nto vari\u00adables. Hence, the reduction of associated synonym applications ter\u00adminates for the same reason \nthat context reduction terminates. This might seem a little restrictive, but is in fact suf.cient for \nmost applications. Strictly speaking we, and Haskell 98, could be a bit more permissive and allow that \nif there are n occurrences of data type constructors in the type parameters of an instance head, each \nconstraint in the instance context may have up to n -1 occurrences of data type constructors in its arguments. \nMoreover, we may permit repeated variable occurrences if the type checker terminates once it sees the \nsame constraint twice in one reduction chain. Work on term rewriting system (TRS) [19] has identi.ed \nmany possible characterisations of systems that are guaranteed to be con.uent and terminating, but the \nrestrictions stated above seem to be a particularly good match for a functional language.  3.4 Ambiguity \nThis celebrated function has an ambiguous type: echo :: (Read a, Show a) . String . String echo s = show \n(read s) The trouble is that neither argument nor result type mention a , so any call to echo will give \nrise to the constraints (Read a, Show a), with no way to resolve a. Since the meaning of the program \nde\u00adpends on this resolution, Haskell 98 requires that the de.nition is rejected as ambiguous. The situation \nis much fuzzier when functional dependen\u00adcies [15] are involved. Consider class Cab | a . b where ... \nposs :: (Cab, Eq b) . a . a Is the type of poss ambiguous? It looks like it, because b is not mentioned \nin the type after the . . However, because of the functional dependency, .xing a will .x b, so all is \nwell. But the dependency may not be so obvious. Suppose class D has no functional dependency, but it \nhas an instance declaration like this: class Dpq where ... instance Cab . D [a] b where ... poss2:: (Dab, \nEq b) . a . a Now, suppose poss2 is applied to a list of integers. The call will give rise to a constraint \n(D [Int] t), which can be simpli.ed by the instance declaration to a constraint (CInt t). Now the functional \ndependency for C will .x t, and no ambiguity arises. In short, some calls to poss2 may be ambiguous, \nbut some may not. It does no harm to delay reporting ambiguity. No unsoundness arises from allowing even \necho to be de.ned; but, in the case of echo, every single call will result in an ambiguity error, so \nit is better to reject echo at its de.nition. When the situation is less clear-cut, it does no harm to \naccept the type signature, and report errors at the call site. Indeed, the only reason to check types \nfor ambiguity at all is to emit error messages for unconditionally\u00adambiguous functions at their de.nition \nrather than at their use. Associated type synonyms are easier, because functionally\u00addependent types are \nnot named with a separate type variable. Here is how class C and poss would be written using an associated \nsynonym S instead of a functionally-dependent type parameter: class Ca where type Sa poss :: (Ca, Eq \n(Sa)) . a . a So, just as in Haskell 98, a type is unconditionally ambiguous if one of its constraints \nmentions no type variable that is free in the value part of the type. There is a wrinkle, however. Consider \nthis function: poss3:: (Ca) . Sa . Sa It looks unambiguous, since a is mentioned in the value part of \nthe type, but it is actually unconditionally ambiguous. Suppose we apply poss3 to an argument of type \nInt. Can we deduce what a is? By no means! There might be many instance declarations for C that all implement \nS as Int: instance ... . C t where type S t = Int (In fact, this situation is not new. Even in Haskell \n98 we can have degenerate type synonyms such as type Sa = Bool which would render poss3 ambiguous.) The \nconclusion is this: When computing unconditional ambi\u00adguity to emit earlier and more-informative error \nmessages we should ignore type variables that occur under an associated type synonym.For poss3, this \nmeans that we ignore the a in Sa, and hence, there is no occurrence of a left to the right of the double \narrow, which renders the signature unconditionally ambiguous. An important special case is that of class \nmethod signatures: Each method must mention the class variable somewhere that is not under an associated \nsynonym. For example, this declaration de.nes an unconditionally-ambiguous method op, and is rejected: \nclass Ca where type Sa op :: Sa . Int  4. The Type System In this section, we formalise a type system \nfor a lambda calculus including type classes with associated type synonyms. This type system is based \non Jones Overloaded ML (OML) [13, 14] and is related to our earlier system for associated data types \n[1]. Like Haskell 98 [9, 7], our typing rules can be extended to give a type\u00addirected translation of \nsource programs into an explicitly-typed lambda calculus akin to the predicative fragment of System F. \nWe omit these extended rules here, as the extension closely follows our earlier work on associated data \ntypes [1]. The key difference between type checking in the presence of associated data types compared \nto associated type synonyms is the treatment of type equality. In the conventional Damas-Milner system \nas well as in its extension by type classes with associated data types, type equality is purely syntactic \ni.e, types are equal iff they are represented by the same term. When we add associated type synonyms, \ntype equality becomes more subtle. More precisely, the equations de.ning associated type synonyms in \nclass instances re.ne type equality by introducing non-free functions over types. The treatment of this \nricher notion of equality in a Damas-Milner system with type classes during type checking and type inference \nconstitutes the main technical contribution of this paper. 4.1 Syntax The syntax of the source language \nis given in Figure 1. We use overbar notation extensively. The notation an means the sequence a1 \u00b7\u00b7\u00b7an; \nthe n may be omitted when it is unimportant. More\u00adover, we use comma to mean sequence extension as follows: \nn a ,an+1 . a n+1. Although we give the syntax of quali.ed and quanti.ed types and constraints in an \nuncurried way, we also some\u00ad Symbol Classes a, \u00df, . .(type variable) T .(type constructor) Sk .(associated \ntype synonym, arity k) D .(type class) x, f, d .(term variable)  Source declarations pgm .cls; inst; \nval (whole program) cls .class .a.D, a .Da where (class decl) tsig; vsig inst .instance .a.f where (instance \ndeclaration) atype; val val .x = e (value binding) tsig .type Sk (assoc. type signature) ak vsig .x :: \ns (method signature) (k-1) atype .type Sk t\u00df= . (assoc. type synonym) Source terms e .x |e1 e2 |.x.e \n|let x = e1 in e2 |e :: s Source types t, . .T |a |t1 t2 |. (monotype) . .Sk t k (associated type) . \n.p .t (quali.ed type) s ..a.. (type scheme)  Constraints pc .Dt (class constraint) p = .. = t (equality \nconstraint) p .pc |(simple constraint) p = pc f .p .(quali.ed constraint) . ..a.f |.a.p = (constraint \nscheme) Environments G .x : s (type environment) T .. (instance environment) U .p= (set of equality constraints) \nFigure 1: Syntax of expressions and types times use equivalent curried notation, thus: pn . t =p1 .\u00b7\u00b7\u00b7.pn \n.t tn . . =t1 .\u00b7\u00b7\u00b7.tn . . .an.. =.a1 \u00b7\u00b7\u00b7.an.. We accommodate function types t1 .t2 by regarding them \nas the curried application of the function type constructor to two arguments, thus (.) t1 t2. We use \n(Fv x ) to denote the free variables of a structure x, which maybe an expression, type term, or environment. \nThe unusual features of the source language all concern as\u00adsociated type synonyms. A class declaration \nmay contain type declarations as well as method signatures, and correspondingly an instance declaration \nmay contain type de.nitions as well as method implementations. These type synonyms are the associated \ntype synonyms of the class, and are syntactically distinguished: S is an associated type synonym constructor, \nwhile T is a regular type constructor (such as lists or pairs). In the declaration of an associ\u00adated \ntype synonym, the type indexes come .rst. The arity of a type synonym is the number of arguments given \nin its de.ning tsig. The arity is given by a superscript to the constructor name, but we drop it when \nit is clear from the context. The syntax of types t includes ., the saturated application of an associated \ntype. Note that such a saturated application can be of higher kind, if the result kind . in the de.ning \ntsig is not *. In the syntax of Figure 1, and in the following typing rules, we make two simplifying \nassumptions to reduce the notational burden: 1. Each class has exactly one type parameter, one method, \nand one associated type synonym. 2. There are no default de.nitions, neither for methods nor syn\u00adonyms. \nA program with default de.nitions can be rewritten into one without, by duplicating the defaults at instances \nnot provid\u00ading their own versions. 3. We elide all mention of kinds, as we exactly follow Jones system \nof constructor classes [14].  Lifting the .rst restriction is largely a matter of adding (a great many) \noverbars to the typing rules. 4.2 Type checking Figures 2 and 3 present the typing rules for our type \nsystem. Our formalisation is similar to [9] in that we maintain the context reduc\u00adtion rules as part \nof the instance environment. The main judgement has the conventional form T |G fe : s meaning in type \nenvi\u00adronment G, and instance environment T, the term e has type s . Declarations are typed by Figure \n3, where all the rules are standard for Haskell, except for Rule (inst). The instance environment T isa \nsetof constraint schemes . that hold in e. A constraint scheme . takes one of two forms (Figure 1): it \nis either a class constraint scheme .a.f,or an equality scheme .a.p =. The instance environment is populated \n.rstly by class and instance declarations, which generate constraint schemes using the rules of Figure \n3; and secondly by moving underneath a quali.ed type (rule (.I ) of Figure 2). The latter adds only a \nsimple constraint p, which can be a class constraint pc or an equality constraint p =; these simple constraints \nare special cases of the two forms described earlier3. The typing rules are almost as for vanilla Haskell \n98, with two major differences. The .rst is in the side conditions T fs that check the well-formedness \nof types, in rules (.I ) and (.E), for reasons we discussed in Section 3.2. The rules for this judgement \nare also in Figure 2. The judgement needs the instance environ\u00adment T so that it can check the well-formedness \nof applications of associated-type applications (Rule (wfsyn)), using the entailment judgement T I . \ndescribed below. In the interest of brevity, the presented rules elide all mention of kinds, leaving \nonly the well\u00adformedness check that is distinctive to a system including associ\u00adated types. More details \nconcerning the implications of the judge\u00adment T fs are in our previous work [1]. It is worthwhile to \nnote that Rule (sig) does not contain well-formedness judgement, al\u00adthough it mentions a user-supplied \ntype. This type is also produced by the typing judgement in the hypothesis, and the judgement al\u00adways \nproduces well-formed types. So, the rule will never apply to a malformed type. The second major difference \nis Rule (conv ), which permits type conversion between types t1 and t2 if we have T I t1 = t2. The auxiliary \njudgement T I . de.nes constraint entailment, which in Haskell 98 only handles type classes, but which \nwe extend here with additional rules for type equality constraints. These rules are also given in Figure \n2 and include the four standard equality axioms (eqre. ), (eqsymm ), (eqtrans ), and (eqsubst ). The \nlast of these allows equal types to be wrapped in an arbitrary context: for example, if t2 = t3, then \nTree (List t2)= Tree (List t3). 3 Rule (.I ), and the syntax of types, does not allow one to quantify \nover constraint schemes, an orthogonal and interesting possible extension[11]. (x : s) .GT1 |G fe1 : \ns1 T2 |G[x : s1] fe2 : s2 T |G fe : t1 T I t1 = t2 (var)(let)(conv ) T |G fx : s T1, T2 |G flet x = e1 \nin e2 : s2 T |G fe : t2 T |G[x:t1] fe2 : t2 T ft1 T |G fe1 : t2 .t1 T |G fe2 : t2 (.I)(.E) T |G f.x.e2 \n: t1 .t2 T |G fe1 e2 : t1 T,p |G fe : . T |G fe : p .. T I p (.I)(.E) T |G fe : p .. T |G fe : . T |G \nfe : sa .Fv T .FvG T |G fe : .a.s T ft T |G fe : s Fv s = \u00d8 (.I)(.E)(sig) T |G fe : .a.s T |G fe :[t/a]s \nT |G f(e :: s): s . .TT I .a.. T I p .f T I p (mono)(spec)(mp) T I . T I [t/a]. T I f T I t2 = t1(eqre. \n)(eqsymm ) T I t = t T I t1 = t2 T I t1 = t2 T I t2 = t3 T I [t1/a]p T I t1 = t2(eqtrans )(eqsubst ) \nT I t1 = t3 T I [t2/a]p T fti T I Dt0 S is an associated type of D T fSk t0 t(k-1) (wfsyn ) T fs a .Fv \nT T f.a.s (wfspec ) T ft1 T ft2 T ft1 t2 (wfapp ) T fa (wfvar ) T fT (wfcon ) Figure 2: Typing rules \nfor expressions T,p f. T fp .. (wfmp)  Figure 3: Typing rules for declarations Much of this is standard \nfor extensions of the Hindley-Milner system with non-syntactic type equality [24, 22, 21, 23, 32, 2]. \nNovel in our system is the integration of entailment of type class predicates with type equalities. In \nparticular, our system allows equality schemes, such as .a. Sprintf (Ia)= Int . Sprintf a in the constraint \ncontext T of the typing rules. Equality schemes are introduced by Rule (inst) of the declaration typing \nrules from Fig\u00adure 3. This rule turns the de.nitions of associated type synonyms into equality schemes, \nsuch as the Sprintf scheme above, which are used in the inference rules of judgement T I . from Figure \n2. An important property of the system is that the well-formedness of types is invariant under the expansion \nof associated type syn\u00adonyms. Speci.cally, Rule (inst) ensures that each equality scheme .a.St \u00df = . \nis paired with a class constraint scheme .a.p . Dt , where D is the class S is associated with. Hence, \nall the premises p for the validity of . are ful.lled whenever the equality is applicable. Rule (inst) \nensures this with the premise Tc,p f .. Let us consider an example: The Format class of Section 2.1 has \nan instance instance Format a . Format (Ia) where type Sprintf (Ia)= Int . Sprintf a Hence, Rule (inst) \nadds the two constraint schemes .C = .a.Format a . Format (Ia) .= = .a. Sprintf (Ia)= Int . Sprinft a \nto the context T. Now consider an expression e of type Format (IString) . Char . Sprintf (IString) Note \nthat the context Format (IString) is required for the type to be well-formed according to judgement T \nf s. In order to remove the constraint Format (IString) from the type of e by Rule (.E), we need to have \nT I Format (IString), which according to .C and Rule (mp) requires T I F ormat String. The result of \napplying .= to Char . Sprintf (IString), i.e., Char . Int . Sprintf String, is well-formed only if T \nI F ormat String holds. That it holds is enforced by .C . There are two more noteworthy points about \nRule (inst). Firstly, the rule checks that the superclass constraints of the class D are ful.lled in \nthe .rst premise. Secondly, when checking the validity of the right-hand side of the associated synonym, \nnamely ., we assume only Tc (the superclass environment). If we would add Ti, we would violate Restriction \n(4) of Section 3.3 and potentially allow non-terminating synonym de.nitions.   5. Type Inference The \naddition of Rule (conv ) to type expressions and of equality axioms to constraint entailment has a signi.cant \nimpact on type inference. Firstly, we need to normalise type terms involving asso\u00adciated types according \nto the equations de.ning associated types. Secondly, type terms involving type variables often cannot \nbe com\u00adpletely normalised until some type variables are further instanti\u00adated. Consequently, we need \nto extend the standard de.nition of uni.cation in the Hindley-Milner system to return partially-solved \nequality constraints in addition to a substitution. To illustrate this, reconsider the de.nition of the \nclass Collects with associated type Elem from Section 1. The uni.cation problem (Int, a)=(Elem c, Bool) \nimplies the substitution [Bool/a], but also the additional constraint Int = Elem c. We cannot de\u00adcide \nwhether the latter constraint is valid without knowing more about c, so we call such constraints pending \nequality constraints. In the presence of associated types, the type inference algorithm has to maintain \npending equality constraints together with class predi\u00adcates. In this section, after .xing some constraints \non source programs, we will .rst discuss a variant of Hindley-Milner type inference with predicates. \nThe inference algorithm depends on a uni.cation pro\u00adcedure that includes type normalisation (Section \n5.3). Afterwards, we will use the uni.cation procedure to test the subsumption rela\u00adtion of type schemes \n(Section 5.4). We conclude the section with some formal properties of our inference system for associated \ntype synonyms. 5.1 Well-formed programs To achieve decidable type inference computing principal types, \nwe impose the following restrictions on the source programs as produced by Figure 1 (cf., Restrictions \n(1) to (4) in Section 3): Instance heads must be constructor-based, speci.c, and non\u00adoverlapping.  \nInstance contexts must be decreasing.  To guarantee a coherent (i.e., unambiguous) translation of well\u00adtyped \nsource programs to an explicitly-typed language in the style of System F, which implements type classes \nby dictionaries, we require two further constraints: Equality constraints (in programmer-supplied type \nannotations) must be of the form Sat = . (i.e., the .rst argument must be a type variable).  If s = \n(.a.p . t ) is a method signature in a class declaration for D \u00df, we require that \u00df . Fv p.  (These \nrestrictions are not necessary if the semantics of the pro\u00adgram is given by translation to an untyped \nintermediate language, or perhaps one with a richer type system than System F; see for ex\u00adample [30].) \nFinally, to stay with Haskell s tradition of rejecting unconditionally-ambiguous type signatures, in \nthe sense of Sec\u00adtion 3.4, we require two more constraints: If s = (.a.p . t ) is a method signature \nin a class declaration for D \u00df, we require that \u00df . Fixv s.  Similarly, we require of all signatures \ne :: .a.. that anFv . . Fixv ..  Here Fixv s, the set of .xed variables of a signature s, is de.ned \nas follows: Fixv T = {} Fixv a = {a} Fixv (t1 t2) = Fixv t1 . Fixv t2 Fixv . = {} Fixv ((. = t ) . .)= \nFixv t . Fixv . Fixv (D t . .) = Fixv . Fixv (.a.s) = Fixv s \\{a} Intuitively, the .xed variables of \na type (or signature) are those free variables that will be constrained when we unify the type (or type \ncomponent of the signature) with a ground type; provided it matches. A program that meets all of the \nlisted constraints is well-formed. The declaration typing rules of Figure 3 determine, for a given pro\u00adgram, \nthe validity of a program context TP and typing environment G. Both are inputs to type inference for \nexpressions and, if they are without super.uous elements, we call them well-formed. As in the typing \nrules, we implicitly assume all types to be well-kinded. It is straight-forward to add the corresponding \njudgements to the pre\u00adsented rules. We call an expression well-formed if any signature annotation of \nthe form (e :: s) obeys the listed constraints. For the rest of the paper, we con.ne ourselves to well-formed \nprograms, program contexts, typing environments, and expressions. This in particular means that the rewrite \nsystem implied by the equality schemes in a program context TP is con.uent and terminating. 5.2 Type \ninference We begin with type inference for type classes with associated types. Figure 4 displays the \nrules for the inference judgement W T,U | TG f e : t. Given a type environment G and an expression e \nas inputs, it computes the following outputs (1) a set of class constraints T, (2) a set of pending equality \nconstraints U, (3) a substitution T, and (4) a monotype t. The judgement implicitly also depends on the \nprogram context TP , initially populated by the instance declarations and remains constant thereafter. \nBecause class and instance declarations are, in effect, explicitly typed, their type inference rules \nare extremely similar to those in Figure 3; so, we do not give them separately here. Our inference rules \ngeneralise the standard rules for Haskell in two ways: (1) the inference rules maintain a set of equality \nconstraints U and (2) uni.cation produces a set of pending equality constraints in addition to a substitution. \nLet us look at both aspects in some more detail. Type inference for Haskell needs to maintain a set of \nT of con\u00adstraints, called the constraint context. In Haskell 98, the constraint context is a set of type \nclass predicates. We extend the context to also include equality constraints, just as in the typing rules. \nHow\u00adever, as we need to treat these two kinds of constraints differently during the inference process, \nwe partition the overall context into the two subsets T and U denoting the class constraints and equality \nconstraints, respectively. Hence, the phrase T,U to the left of the vertical bar in the inference judgement \ncaptures the whole context. In particular, Rules (varW ) and (sigW ) result in contexts [\u00df/a]p, which \nare implicitly partitioned into the two components T and U in the hypotheses of other inference rules. \nDuring generalisation by the function Gen(G; .) in Rule (letW ) and (sigW ), both class and equality \nconstraints are moved into the signature context of the produced signature. In Rule (.EW ), the two sets \nof equality constraints U1 and U2 are both extracted out of the constraint context, to be fed to the \nuni.cation process in conjunction with the new equality constraint T2t1 = t2 . a. Uni.cation simpli.es \nthe equalities as far as possible, producing, in addition to a substitution R, a set of pending equality \nconstraints U. This set is used in the conclusion of the inference rule. Rules (.EW ) and (sigW ) make \nuse of two auxiliary judge\u00adments for uni.cation and subsumption, respectively. Both of these judgements \ndepend on the program context TP and are the subject of the following two subsections.  5.3 Uni.cation \nAssociated type synonyms extend Haskell 98 s purely syntactic type equality; e.g, Elem BitSet = Char \nholds under the de.\u00adnitions for the class Collects discussed before. To handle non\u00adsyntactic equalities \nduring uni.cation, we exploit the properties of well-formed programs. In particular, the type functions \nin well\u00adformed programs are con.uent and terminating; i.e., type terms have unique normal forms. Hence, \nwe can determine whether two type terms are equal by syntactically comparing their normal forms. The \njudgement T I t t,, whose inference rules are given by Figure 5, de.nes a one-step reduction relation \non type terms under a constraint environment T. The reduction relation on types is used by the one-step \nuni.cation judgement T IU t1 = t2 U; R. This judgement holds for an equality t1 = t2 iff the corresponding \nuni.cation problem can be reduced to a simpler uni.cation problem in the form of a set of equality constraints \nU and a substitution R. The symbol in the inference rules represents an empty set of equality constraints \nand the identity substitution, respectively. The repeated application of one-step uni.cation, as performed \nby the re.exive and transitive closure T IU U * U,; R, reduces a set of equality constraints U to a set \nof pending equality constraints U, and a substitution R.If U, cannot be reduced any further, we also \nwrite T IU U ! U,; R, hence turning the transitive closure of one-step uni.cation into a deterministic \nfunction. Note that, due to the syntactic restrictions on t, Rule (appU ) and (redU ) are not overlapping. \n Uni.cation is performed under a constraint environment T only because this environment is required by \nassociate type synonym expansion. It is easy to see that, where two types t1 and t2 are free of associated \nsynonyms, the relation IU {t1 = t2} ! ; R coincides with standard syntactic uni.cation as employed in \ntype inference for vanilla Haskell 98. Just like Jones [14], we only need .rst-order uni.cation despite \nthe presence of higher-kinded variables, as we require all applica\u00adtions of associated type synonyms \nto be saturated. Soundness of uni.cation. The judgements of Figure 5 enjoy the following properties. \nLEMMA 1 (Soundness of type reduction). Given a well-formed constraint environment T and a type t with \nT f t, we have that T I t t, implies T I t = t,. LEMMA 2 (Soundness of one-step uni.cation). Given a \nwell-formed constraint environment T, the judgement T IU t1 = t2 U; R implies that T I R(t1 = t2) iff \nT I U. THEOREM 1 (Soundness of uni.cation). Given a well-formed con\u00adstraint environment T and a set of \nequalities U, then T IU U * U,; R implies that T I RU iff T I U,. The proofs proceed by rule induction. \nMoreover, Theorem 1 re\u00adquires that T I R.1 iff T I R.2 follows from T I .1 iff T I .2 for any substitution \nR, which is a basic property of con\u00adstraint entailment. 5.4 Subsumption To handle type annotations, \nsuch as in expressions of the form e :: s, during type inference, we need to have an algorithm deciding \ntype subsumption. We say a type scheme s1 subsumes s2, written s1 = s2 iff any expression that can be \ntyped as s1 can also be typed as s2. The subsumption check can be formulated as a constraint entail\u00adment \nproblem in the presence of equality constraints. If we want to check (.a1.p1 . t1) = (.a2.p2 . t2), \nin the context of a program context TP , we need to demonstrate that, given a set of new type constructors \nT of the appropriate kind, there exists a substitution R =[./a1], such that TP , [T/a2]p2 I Rp1,Rt1 =[T/a2]t2 \n where we de.ne the entailment of a set of predicates T I . as the conjunction of all T I .i. Given that \nwe implement the entailment of equalities by uni.\u00adcation during type inference, it is not surprising \nthat we can imple\u00adment subsumption via a combination of uni.cation and the usual backchaining approach \nto entailment; a process called context re\u00adduction when used to simplify type class contexts. In Figure \n6, we de.ne the procedure computing entailment using the same struc\u00adture as we used for the uni.cation \nprocedure: Firstly, we de.ne a one-step entailment judgement T IE p P; R that reduces a constraint p \n(which may be a class constraint or equality con\u00adstraint) to a simpler set of constraints P and a substitution \nR. (x : .a.p . t) . G \u00df fresh (varW ) W [\u00df/a]p | G fx :[\u00df/a]t a fresh WW T1,U1 | T1G f e1 : t1 T2,U2 \n| T2(T1G) f e2 : t2 TP IU U1,U2, (T2t1 = t2 . a) ! U; R (.EW ) W R(T2T1, T2),U | (RT2T1)G fe1 e2 : Ra \nW T,U | TG[x : a] f e : ta fresh (.IW ) W T,U | TG f.x.e : Ta . t WW T1,U1 | T1G f e1 : t1 T2,U2 | \nT2(T1G[x : s]) f e2 : t2 s =Gen(T1G; (T1,U1) . t1) (letW ) W T2,U2 | (T2T1)G f(let x = e1 in e2): t2 \n\u00df fresh T,U | TG f W e : t1 s =Gen(TG; (T,U) . t1)TP I s = (.a.p . t2) Fv(p . t2) . a W (sigW ) [\u00df/a]p \n| TG f(e :: .a.p . t2):[\u00df/a]t2 Gen(G; .)= .a.. , where a =Fv . \\ Fv G Figure 4: Type inference rules \n T I t1 t1,T I t2 t2, (lappR)(rappR) T I t1 t2 t1,t2 T I t1 t2 t1 t2, t, = i 1 = i = k T I ti ti,j = \ntj , .j (.a.. = t) . T (argR)(synR) T I Sk tk Sk t, k T I [./a]. [./a]t T IU t2 = t1 U; Ra. Fv t (re.U \n)(symmU )(varU ) T IU t = t ; T IU t1 = t2 U; RT IU a = t ;[t/a] T I . t2 (appU )(redU ) T IU t1 t2 \n= t,t, {t1 = t,,t2 = t,}; T IU . = t1 {t2 = t1}; 1212 ; R,, T IU t1 = t2 U,; R, T IU R,U, U, * U,, \n= t2 * U,,; R,,R, T IU U * U; T IU U, t1 Figure 5: Uni.cation in the presence of type functions Figure \n6: Constraint entailment with equality constraints Rule (bchainE ) formalises standard backchaining, \nRule (redE ) en\u00adables the reduction of associated type synonyms in class parame\u00adters, and Rule (eqE ) \ninvokes one-step uni.cation for equality con\u00adstraints. Secondly, we de.ne the re.exive and transitive \nclosure T IE P * P,; R. Finally, we turn the closure into a deter\u00administic function by requiring that \nfor TP IE P ! P,; R, the resulting set of constraints P, cannot be reduced further. Now, we can de.ne \nsubsumption as follows: TP ,[T/a2]p2 IE {p1,t1 =[T/a2]t2} ! ; R T new type constructors (=) TP I (.a1.p1 \n. t1) = (.a2.p2 . t2) In other words, subsumption succeeds if context reduction can resolve the constraint \nset entirely. Soundness of subsumption. The subsumption rule enjoys the following property. LEMMA 3 (Soundness \nof subsumption). Let TP be a well-formed constraint environment, and s1 = .a1.p1 . t1 and s2 = .a2.p2 \n. t2 signatures with TP I s1 and TP I s2, where s2 is closed. Then, TP I s1 = s2 implies that, given \na set of new type constructors T of the appropriate kind, there exists a substitution R =[./a1], such \nthat TP ,[T/a2]p2 I Rp1,Rt1 =[T/a2]t2. The lemma is an immediate consequence of Theorem 1.  5.5 Formal \nproperties of type inference THEOREM 2 (Soundness of type inference). Assume a well-formed program context \nTP , typing environment G, and expression e.If W T,U | TG f e : t, then (TP ,T,U) | TG f e : t. In proving \nthis theorem, we followed Jones [12] who introduces a syntax-directed system as a bridge between the \ndeclarative typing rules and the algorithmic inference rules, as .rst suggested by Cl\u00b4ement at al. [3]. \nThe tricky bit is to de.ne the inference rule for function elimination in the syntax-directed system \nsuch that a correspondence to the inference system can be established. We de.ne the rule as follows: \nT | G f e1 : t1 T | G f e2 : t2 TP ,T I t1 = t2 . t1, (.ES)T | G f e1 e2 : t, 1 In addition, we need \nto use Theorem 1 and Lemma 3. We believe that our inference algorithm is complete and that we can obtain \nprincipal types by performing a further generalisation step on its outputs. However, we leave the proof \nto further work which we plan to do by again following Jones scheme for quali.ed types.  6. Functional \nDependencies Associated type synonyms cover much the same applications as functional dependencies. It \nis too early to say which of the two is better ; hence, we will simply contrast the properties of both. \nThe comparison is complicated by the existence of at least three variants of functional dependencies: \n(1) The system described by Mark Jones [15], (2) the generalised system implemented in the Glasgow Haskell \nCompiler (GHC) [31], and (3) an even more permissive system formalised by Stuckey &#38; Sulzmann [30]. \nLike our associated type synonyms, the .rst two of these systems permit an implementation by a dictionary \ntranslation to an explicitly-typed language akin to System F. Stuckey and Sulzmann s system, based on \nan encoding into constraint handling rules, gains additional generality by giving up on a type-preserving \ntranslation and on separate compilation. As pointed out by Duck et al. [6], GHC s system is not decid\u00adable, \nas it permits recursive instance declarations that, for some pro\u00adgrams that should be rejected, leads \nto non-termination of type in\u00adference. Jones original system is decidable. The Stuckey-Sulzmann system, \nand the associated type synonyms we describe here, both ensure decidability by a suitable set of restrictions \non the admissi\u00adble constraint handling rules and associated type synonyms, respec\u00adtively; both systems \ncan handle more general rule sets if decidable inference is not required. 6.1 Type substitution property \nWe usually require from a type system that, if we can type an expression e with a type scheme .a.s, then \nwe can also type it with an instance [t/a]s. Interestingly, this property does not hold for Jones and \nGHC s version of functional dependencies. Here is an example: class Cab | a . b where foo :: a . b instance \nCBool Int where foo False =0 foo True =1 Under these de.nitions, consider the following three signatures \nof the function bar : bar :: Ca b . a . b --(1). . . most general type bar :: CBool b . Bool . b --(2). \n. . subst. instance bar :: Bool . Int --(3). . . apply fun-dep bar = foo With signature (1) and (3) \nthe program type checks .ne, but with (2) it is rejected by both GHC and Hugs. This is despite (2) clearly \nbeing a substitution instance of (1), and (2) and (3) being equivalent (i.e., each one subsumes the other). \nThe Stuckey-Sulzmann system accepts all three signatures. The corresponding declarations with associated \ntypes would be class Ca where type Ba foo :: a . Ba instance CBool where type BBool = Int foo False =0 \nfoo True =1 and we get the following signatures: bar :: Ca . a . Ba --(1). . . most general type bar \n:: Bool . BBool --(2). . . substitution inst. bar :: Bool . Int --(3). . . reduce assoc syn. bar = foo \n Here we immediately get a ground constraint (which we omit as usual) by the substitution and all three \nsignatures are accepted. The crucial difference is that with associated type synonyms, we do not need \na type variable to represent the functionally dependent type.  6.2 Readability As observed by Garcia \net al. [8], if functional dependencies are used for the type of generic programming outlined in Section \n2.2 on a full scale graph library and not the cut down version we used for illustration purposes type \nclasses quickly accumulate a signi.cant number of parameters. This affects readability for reasons similar \nto why records with named .elds are preferred over tuples of large arity. Associated types, just like \nrecords with named .elds, refer to parameters by name and not by position. The same observation led to \nthe addition of traits classes [20] in C++, which use a form of associated type synonyms in C++ classes. \nAs discussed in Section 3.4, if a class with functional dependen\u00adcies is used in the context of an instance \ndeclaration of a class that does not have functional dependencies, the arising dependencies can be quite \nsubtle and depend indirectly on the types of arguments a function is applied to. 6.3 Expressiveness \nAn immediate question is whether associated types can generally be encoded as functional dependencies \nand vise versa. This ques\u00adtion does not have a simple answer. Duck et al. [6, Example 4] use the following \nclass head: class Zip a b c | ac . b, bc . a It is not immediately clear how to translate this to associated \ntypes. However, as Oleg Kiselyov [17] demonstrates, the simpler class header class Zip a b c | c . ab \nis suf.cient for this and similar applications. This second declara\u00adtion can also be readily captured \nas an associated type synonym. In fact, it appears from inspecting publicly available code as if func\u00adtional \ndependencies are normally used in a way that can be directly translated into associated types. In particular, \neven sophisticated uses of functional dependencies, such as HList [18] and a type safe evaluator, can \nbe mirrored with associated types. Conversely, a direct encoding of associated types with func\u00adtional \ndependencies is not possible with Jones and GHC s system due to the limitation discussed in Section 6.1. \nA more sophisticated encoding similar to the translation to an explicitly type passing lan\u00adguage in the \nstyle of System F, as discussed in [1], does not re\u00adquire functional dependencies; plain multi-parameter \ntype classes are suf.cient. The Stuckey-Sulzmann system is, however, more powerful and seems to be able \nto directly handle all signatures in\u00advolving associated types.  7. Other related work Associated data \ntypes. In our previous work on associated data types [1], we allowed a class declaration to de.ne a new \ndata type (rather than a new type synonym). Is it necessary to have associated type synonyms as well \nas associated data types? At .rst, it might seem as if not but both mechanisms are subtly different and \ncannot completely emulate each other. Let s .rst try realising associated type synonyms as associated \ndata types. Recall, for example, the list instance for Collects: instance Eq e . Collects [e] where type \nElem [e]= e insert x xs = x : xs  The elements of [e] are of type e. It would be extremely inconve\u00adnient \nto have to wrap the elements of the list with a constructor, so that they were a fresh type: instance \nEq e . Collects [e] where data Elem [e]= ListElem e insert (ListElem x) xs = x : xs  In fact, it is \nnot only inconvenient, as now signatures, such as merge :: (Collects c1, Collects c2, Elem c1= Elem c2) \n . c1 . c2 . c2 do not make any sense anymore. If Elem is an associated data type, the equality constraint \nElem c1= Elem c2 is unsatis.able. Moreover, the Format class crucially rests on Sprintf being a synonym; \notherwise, the right-hand sides would not be function types anymore. Now, how about the converse can \nassociated synonyms em\u00ad ulate associated data types? They almost can. Declarations of the form class \nArrayElem e where data Array e index :: Array e . Int . e instance ArrayElem Int where data Array Int \n= ArrInt UnboxedIntArray index = indexUnboxedIntArray  can be rewritten as class ArrayElem e where type \nArray e index :: Array e . Int . e data ArrayInt = ArrInt UnboxedIntArray instance ArrayElem Int where \ntype Array Int = ArrayInt index = indexUnboxedIntArray The translation becomes more involved for more \ncomplicated instances, but the principle remains the same. The difference between the two versions is \nthe following. If we pass to the index :: Array e . Int . e function a value of type Array Int, then \nfor an associated data type, we know that e = Int. However, for an associated synonym, we cannot draw \nthat conclusion. The equation Array e = Array Int may have more than one solution, depending on the available \nArrayElem instances. More generally, the introduction of a new type by an associated data type implies \na bijection between collection type and element type, much like a bi-directional functional dependency. \nThis is too strong a requirement for, for example, the class Collects. It needs a uni-directional dependence, \nand that is just what an associated synonym does. In particular, two collections represented differently \nmay still contain elements of the same type. Open versus closed type functions. Each associated type \nsyn\u00adonym constitutes a function over types, which is de.ned by the set of type synonym equations contained \nin the instance declarations of the class the synonym is associated with. Since Haskell permits to add \nnew instances to an existing class at any point, associated type synonyms are open type functions in \nthe same way as class methods are open functions on the value level. Using associated synonyms, we can \nde.ne computations on the type level, and such computations, expressed using functional de\u00adpendencies, \nhave become quite popular with hard-core Haskell pro\u00adgrammers. The standard example is addition on Peano \nnumerals: data Zero --empty type data Succ a --empty type class Nat n where type Add n m :: * instance \nNat Zero wh ere type Add Zero m = m instance Nat n . Nat (Succ n) where type Add (Succ n) m = Succ (Add \nn m) This is, for example, useful to de.ne bounded data types, such as .xed length vectors: class Nat \nn . VecBound n where dataVec n a appVec :: (VecBound m, VecBound (Add n m)) . Vec n a . Vec m a . Vec \n(Add n m) a instance VecBound Zero where data Vec Zero a = Nil appVec Nil ys = ys instance VecBound n \n. VecBound (Succ n) where data Vec (Succ n) a = Cons a (Vec n a) appVec (Cons x xs) ys = Cons x (appVec \nxs ys) The signature of appVec guarantees that the length of the result vector is the sum of the lengths \nof the argument vectors. The type Vec is an associated data type. This de.nition of Add is unsatisfactory \nin two ways: (1) In its use of empty data types (i.e. ones with no constructors) and (2) the use of type \nclasses to de.ne Add. After all, we would not use type classes to de.ne summation on Peano numerals on \nthe value level! Instead, we would use an algebraic data type and a closed function. On the type level, \nthis corresponds to an algebraic kind de.nition and a closed type function, which we might denote as \nfollows: kind Nat = Zero | Succ Nat type Add Zero m = m type Add (Succ n) m = Succ (Add nm) This is not \nonly more concise, it also captures our intentions much better: it ensures that Add is only applied to \ntypes of kind Nat, and it asserts that we will not extend the de.nition of Nat and Add in the future. \nClosed kind and type function de.nitions in a Haskell-like language have been proposed by Sheard for \nthe .mega system [25]. Closed type functions are de.nitely useful but so are open type functions! Indeed, \nopen type functions are an extremely natu\u00adral complement to the value-level open functions expressed \nby type classes. Although we have not addressed closed type functions in this paper, we would like to \nnote that the type system and type in\u00adference algorithm presented in Sections 4 and 5 can handle closed \ntype functions as well as open type functions. All we have to re\u00adquire is that the equations de.ning \nclosed type functions are total and obey the same restrictions as those for open type functions, which \nwe outlined in Section 3.3, so that they are con.uent and terminating. Functional logic overloading, \nHM(X), and constraint handling rules. Neubauer et al. [22] proposed a variant of type classes that de.ne \nfunctions, instead of predicates, for use in type contexts. In their system, constraint environments \ndo not contain any predicates anymore, but only equalities. Moreover, one type class de.nes ex\u00adactly \none function, whereas a type class can have multiple associ\u00adated type synonyms in our system. Multiple \nassociated synonyms are, for example, useful for a more fully .edged version of our Graph class. Neubauer \net al. consider both open and closed func\u00adtions as well as overlapping de.nitions, whereas we only consider \nopen functions without overlapping de.nitions. An evidence trans\u00adlation for Neubauer et al. s system \nis future work, whereas the trans\u00adlation of associated synonyms follows our earlier work on associ\u00adated \ndata types. Neubauer et al. base their formal system on work by Oder\u00adsky et al. [23], which introduces \nHindley-Milner type inference parametrised with a wide range of constraint systems, called HM(X). The \nHM(X) system is based on type subsumption, of which equality is a special case. Stuckey and Sulzmann \n[30] have developed the HM(X) frame\u00adwork further by .xing the constraint system to be based on con\u00adstraint \nhandling rules (CHRs). The resulting system is no longer restricted to regular equational theories and \nhas been successfully used to encode a general version of functional dependencies. The price for this \ngenerality is the loss of the ability to translate to an explicit type-passing language, as is standard \nin dictionary transla\u00adtions of type classes. Moreover, separate compilation is problem\u00adatic as whole-program \ninformation is required for the translation. Nevertheless, we expect to be able to implement type classes \nwith associated types via HM(CHR) and indeed this seems to be an in\u00adteresting item for future work. Guarded \nrecursive data types and generalised abstract data types. Generalised abstract data types (GADTs), also \nknown as guarded recursive data types and .rst-class phantom types, constrain the construction of data \ntypes by equality constraints in data type de.nitions [32, 2, 16, 25]. These constraints are available \nin the corresponding branches of case expressions, which enables typing expressions that would otherwise \nhave been too speci.c. There appears to be a connection between these equalities and equality constraints, \nbut they are handled differently during type inference. Moreover, GADTs are closed and not associated \nwith type classes. ML modules. There is a signi.cant overlap in functionality be\u00adtween Haskell type classes \nand Standard ML modules [5] . As\u00adsociated types increase this overlap even more, and our equality constraints \nappear to bear a relation to sharing constraints. Never\u00adtheless, there are also interesting differences, \nand both constructs have a large design space. We regard a more precise comparison of the two as interesting \nfuture work. C++ traits classes. Typedefs in C++ class templates are of a sim\u00adilar nature as associated \ndata types [20], and there are many C++ libraries [29, 28, 8] that demonstrate the usefulness of this \nmech\u00adanism. Type checking in C++ is, however, of an entirely different nature. In particular, template \nde.nitions are not separately type checked, but only after expansion at usage occurrences. Moreover, \nC++ does not have type inference. In exchange, C++ does not con\u00adstrain the resulting type functions to \nbe terminating or con.uent, but permits arbitrary computations at compile time. Siek and Lumsdaine [27] \nrecently proposed an interesting com\u00adbination of Haskell-style type classes with the C++ approach to \ngeneric programming. They propose a language FG that adds a no\u00adtion of concepts to System F and includes \nsupport for associated types of the same .avour as those introduced in the present paper. The main difference \nbetween Siek and Lumsdaine s work and ours is that Siek and Lumsdaine trade type inference for a more \nexpres\u00adsive type language. 8. Conclusions and further work In this paper and its predecessor, we have \nexplored the conse\u00adquences of enabling a Haskell type class to contain data and type de.nitions, as well \nas method de.nitions. Doing so directly ad\u00addresses Garcia et al s primary concern about large-scale program\u00adming \nin Haskell. It also .lls out Haskell s existing ability to de.ne open functions at the value level using \ntype classes, with a comple\u00admentary type-level facility. There is clearly a big overlap between functional \ndependencies and associated type synonyms, and no language would want both. We do not yet have enough \nexperience to know what dif.culties (ei\u00adther of expressiveness or convenience), if any, programmers would \nencounter if functional dependencies were replaced by associated type synonyms but we regard that as \nan attractive possibility. Acknowledgements. We particularly thank Martin Sulzmann for his detailed and \nthoughtful feedback, which helped to identify and characterise several potential pitfalls. We are also \ngrateful to Roman Leshchinskiy and Stefan Wehr who suggested signi.cant improvements to the presentation \nand the formal system; moreover, Stefan Wehr throughly improved and extended the prototype type checker. \nWe also thank the anonymous referees for their helpful comments. The .rst two authors have been partly \nfunded by the Australian Research Council under grant number DP0211203.  References [1] Manuel M. T. \nChakravarty, Gabriele Keller, Simon Peyton Jones, and Simon Marlow. Associated types with class. In Martin \nAbadi, editor, Conference Record of POPL 2005: The 32nd ACM SIGPLAN-SIGACT Symposium on Principles of \nProgramming Languages, pages 1 13. ACM Press, 2005. [2] James Cheney and Ralf Hinze. First-class phantom \ntypes. Technical Report TR2003-1901, Cornell University, 2003. [3] Dominique Cl\u00b4ement, Thierry Despeyroux, \nGilles Kahn, and Jo\u00a8elle Despeyroux. A simple applicative language: mini-ML. In LFP 86: Proceedings of \nthe 1986 ACM Conference on LISP and Functional Programming, pages 13 27, New York, NY, USA, 1986. ACM \nPress. [4] Olivier Danvy. Functional unparsing. J. Funct. Program., 8(6):621 625, 1998. [5] Derek Dreyer, \nKarl Crary, and Robert Harper. A type system for higher-order modules. In Proceedings of the 30th ACM \nSIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 236 249, 2003. [6] Gregory J. \nDuck, Simon Peyton Jones, Peter J. Stuckey, and Martin Sulzmann. Sound and decidable type inference for \nfunctional dependencies. In ESOP;04, LNCS. Springer-Verlag, 2004. [7] Karl-Filip Fax\u00b4en. A static semantics \nfor Haskell. Journal of Functional Programming, 12(4+5), 2002. [8] Ronald Garcia, Jaakko Jarvi, Andrew \nLumsdaine, Jeremy Siek, and Jeremiah Willcock. A comparative study of language support for generic programming. \nIn Proceedings of the 18th ACM SIGPLAN Conference on Object-Oriented Programing, Systems, Languages, \nand Applications, pages 115 134. ACM Press, 2003. [9] Cordelia V. Hall, Kevin Hammond, Simon L. Peyton \nJones, and Philip L. Wadler. Type classes in Haskell. ACM Trans. Program. Lang. Syst., 18(2):109 138, \n1996. [10] Ralf Hinze. Formatting: A class act. Journal of Functional Programming, 13:935 944, 2003. \n[11] Ralf Hinze and Simon Peyton Jones. Derivable type classes. In Graham Hutton, editor, Proceedings \nof the 2000 ACM SIGPLAN Haskell Workshop, volume 41.1 of Electronic Notes in Theoretical Computer Science. \nElsevier Science, 2001. [12] Mark P. Jones. A theory of quali.ed types. In ESOP 92: Symposium proceedings \non 4th European symposium on programming, pages 287 306, London, UK, 1992. Springer-Verlag. [13] Mark \nP. Jones. Simplifying and improving quali.ed types. In FPCA 95: Conference on Functional Programming \nLanguages and Computer Architecture. ACM Press, 1995. [14] Mark P. Jones. A system of constructor classes: \nOverloading and implicit higher-order polymorphism. Journal of Functional Programming, 5(1), 1995. [15] \nMark P. Jones. Type classes with functional dependencies. In Proceedings of the 9th European Symposium \non Programming (ESOP 2000), number 1782 in Lecture Notes in Computer Science. Springer-Verlag, 2000. \n[16] Simon Peyton Jones, Geoffrey Washburn, and Stephanie Weirich. Wobbly types: type inference for generalised \nalgebraic data types. http://research.microsoft.com/Users/simonpj/papers/ gadt/index.htm, 2004. [17] \nOleg Kiselyov. Functions with the variable number (of vari\u00adously typed) arguments. http://okmij.org/ftp/Haskell/ \nvararg-fn.lhs, 2004. [18] Oleg Kiselyov, Ralf L\u00a8ammel, and Keean Schupke. Strongly typed heterogeneous \ncollections. In Haskell 04: Proceedings of the ACM SIGPLAN Workshop on Haskell, pages 96 107, New York, \nNY, USA, 2004. ACM Press. [19] J. W. Klop. Term rewriting systems. In S. Abramsky D. M. Gabbay and T. \nS. E. Maibaum, editors, Handbook of Logic in Computer Science, volume 2, pages 1 116. Oxford University \nPress, 1992. [20] Nathan C. Myers. Traits: a new and useful template technique. C++ Report, June 1995. \n[21] Matthias Neubauer and Peter Thiemann. Type classes with more higher-order polymorphism. In ICFP \n02: Proceedings of the seventh ACM SIGPLAN international conference on Functional programming, pages \n179 190, New York, NY, USA, 2002. ACM Press. [22] Matthias Neubauer, Peter Thiemann, Martin Gasbichler, \nand Michael Sperber. Functional logic overloading. In POPL 02: Proceedings of the 29th ACM SIGPLAN-SIGACT \nsymposium on Principles of programming languages, pages 233 244. ACM Press, 2002. [23] Martin Odersky, \nMartin Sulzmann, and Martin Wehr. Type inference with constrained types. Theory and Practice of Object \nSystems, 5(1), 1999. [24] Didier R\u00b4emy. Extending ML type system with a sorted equational theory. Research \nReport 1766, INRIA Rocquencourt, 1992. [25] Tim Sheard. Languages of the future. In OOPSLA 04: Companion \nto the 19th Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages, and Applications, \npages 116 119, New York, NY, USA, 2004. ACM Press. [26] Tim Sheard and Simon Peyton Jones. Template meta-programming \nfor Haskell. ACM SIGPLAN Notices: PLI Workshops, 37(12):60 75, 2002. [27] Jeremy Siek and Andrew Lumsdaine. \nEssential language support for generic programming. SIGPLAN Not., 40(6):73 84, 2005. [28] Jeremy G. Siek, \nLie-Quan Lee, and Andrew Lumsdaine. The Boost Graph Library User Guide and Reference Manual. Addison-Wesley, \n2001. [29] A. A. Stepanov and M. Lee. The standard template library. Technical Report X3J16/94-0095, \nWG21/N0482, ISO Programming Language C++ Project, 1994. [30] Peter J. Stuckey and Martin Sulzmann. A \ntheory of overloading. ACM Transactions on Programming Languages and Systems, 2004. To appear. [31] The \nGHC Team. The Glasgow Haskell Compiler. http://haskell. org/ghc/documentation.html. [32] Hongwei Xi, \nChiyan Chen, and Gang Chen. Guarded recursive datatype constructors. In Proceedings of the 30th ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 224 235. ACM Press, 2003. \n\t\t\t", "proc_id": "1086365", "abstract": "Haskell programmers often use a multi-parameter type class in which one or more type parameters are functionally dependent on the first. Although such functional dependencies have proved quite popular in practice, they express the programmer's intent somewhat indirectly. Developing earlier work on <i>associated data types</i>, we propose to add functionally dependent types as type synonyms to type-class bodies. These <i>associated type synonyms</i> constitute an interesting new alternative to explicit functional dependencies.", "authors": [{"name": "Manuel M. T. Chakravarty", "author_profile_id": "81408595395", "affiliation": "University of New South Wales", "person_id": "P187027", "email_address": "", "orcid_id": ""}, {"name": "Gabriele Keller", "author_profile_id": "81100011375", "affiliation": "University of New South Wales", "person_id": "PP39023133", "email_address": "", "orcid_id": ""}, {"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research Ltd., Cambridge, UK", "person_id": "PP43121273", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086397", "year": "2005", "article_id": "1086397", "conference": "ICFP", "title": "Associated type synonyms", "url": "http://dl.acm.org/citation.cfm?id=1086397"}