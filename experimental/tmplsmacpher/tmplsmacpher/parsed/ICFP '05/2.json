{"article_publication_date": "09-12-2005", "fulltext": "\n Acute: High-Level Programming Language Design for Distributed Computation Peter Sewell* James J. Leifer \nKeith Wansbrough* Francesco Zappa Nardelli Mair Allen-Williams* Pierre Habouzit Viktor Vafeiadis* *University \nof Cambridge INRIA Rocquencourt http://www.cl.cam.ac.uk/users/pes20/acute Abstract Existing languages \nprovide good support for typeful programming of standalone programs. In a distributed system, however, \nthere may be interaction between multiple instances of many distinct pro\u00adgrams, sharing some (but not \nnecessarily all) of their module struc\u00adture, and with some instances rebuilt with new versions of certain \nmodules as time goes on. In this paper we discuss programming\u00adlanguage support for such systems, focussing \non their typing and naming issues. We describe an experimental language, Acute, which extends an ML core \nto support distributed development, deployment, and execution, allowing type-safe interaction between \nseparately-built programs. The main features are: (1) type-safe marshalling of ar\u00adbitrary values; (2) \ntype names that are generated (freshly and by hashing) to ensure that type equality tests suf.ce to protect \nthe in\u00advariants of abstract types, across the entire distributed system; (3) expression-level names generated \nto ensure that name equality tests suf.ce for type-safety of associated values, e.g. values carried on \nnamed channels; (4) controlled dynamic rebinding of marshalled values to local resources; and (5) thunki.cation \nof threads and mu\u00adtexes to support computation mobility. These features are a large part of what is needed \nfor typeful distributed programming. They are a relatively lightweight exten\u00adsion of ML, should be ef.ciently \nimplementable, and are expressive enough to enable a wide variety of distributed infrastructure layers \nto be written as simple library code above the byte-string network and persistent store APIs. This disentangles \nthe language runtime from communication intricacies. This paper highlights the main de\u00adsign choices in \nAcute. It is supported by a full language de.nition (of typing, compilation, and operational semantics), \nby a prototype implementation, and by example distribution libraries. Categories and Subject Descriptors \nD.3.3 [Programming Lan\u00adguages]: Language Constructs and Features General Terms Languages, Design Keywords \nprogramming languages, distributed programming, marshalling, serialisation, abstract types, modules, \nrebinding, ver\u00adsion control, type theory, ML Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 05 September 26 28, 2005, Tallinn, Estonia. Copyright c &#38;#169; \n2005 ACM 1-59593-064-7/05/0009. . . $5.00. 1. Introduction Distributed computation is now pervasive, \nwith execution, software development, and deployment spread over large networks, long timescales, and \nmultiple administrative domains. Because of this, distributed systems cannot in general be deployed or \nupdated atom\u00adically. They are not necessarily composed of multiple instances of a single program version, \nbut instead of many versions of many pro\u00adgrams that need to interoperate, perhaps sharing some libraries \nbut not others. Moreover, the intrinsic concurrency and nondetermin\u00adism of distributed systems, and the \ncomplexity of the underlying network layers, makes them particularly hard to understand and debug, especially \nwithout type safety. Existing programming lan\u00adguages, such as ML, Haskell, Java and C, provide good support \nfor local computation, with rich type structures and (mostly) static type-safety guarantees. When it \ncomes to distributed computation, however, they fall short, with little support for its many system\u00addevelopment \nchallenges. In this work we seek to remedy this lack, concentrating on what must be added to ML-like \n(typed, call-by-value, higher-order) lan\u00adguages to support typed distributed programming. We have de.ned \nand implemented a programming language, Acute, which extends an OCaml core with features for type-safe \nmarshalling and naming in the distributed setting. Our extensions are lightweight changes to ML, but \nsuf.ce to enable sophisticated distributed infrastructure, e.g. substantial parts of JoCaml [JoC], Nomadic \nPict [SWP99], and Ambient primitives [CG98], to be programmed as simple li\u00adbraries. Acute s support for \ninteraction between programs goes well beyond previous work, allowing type-safe interaction between different \nruntime instances, different builds, and different versions of programs, whilst respecting modular structure \nand type abstrac\u00adtion boundaries in each interacting partner. In a distributed system it will often be \nimpossible to detect all type errors statically, but it is not necessary to be completely dynamic errors \nshould be detected as early as possible in the development, deployment, and execution process. We show \nhow this can be done. Acute has a full de.nition [SLW+04], covering syntax, typing, compilation, and \noperational semantics. A prototype implementa\u00adtion is also available [SLW+05], which is ef.cient enough \nto run moderate examples but which closely mirrors the structure of the operational semantics. This paper \nis devoted to an informal presen\u00adtation of the main design points, with small but executable exam\u00adples. \nFor details of the many semantic subtleties, and for discussion of further design points, we refer the \nreader to [SLW+04]. 1.1 Acute overview: the main design points Type-safe marshalling (\u00a72, \u00a73) Our basic \naddition to ML is type-safe marshalling: constructs to marshal arbitrary values to byte-strings, with \na type equality check at unmarshal-time guaran\u00adteeing safety. We argue that this is the right level of \nabstraction for a general-purpose distributed language, allowing complex commu\u00adnication infrastructure \nalgorithms to be coded (type-safely) as li\u00adbraries, above the standard byte-string network and persistent \nstore APIs, rather than built in to the language runtime. We recall the different design choices for \ntrusted and untrusted interaction. Dynamic linking and rebinding (\u00a74) When marshalling and unmarshalling \ncode values, e.g. to communicate ML functions be\u00adtween machines, it may be necessary to dynamically rebind \nthem to local resources at their destination. Similarly, one may need to dynamically link modules. There \nare many questions here: how to specify which resources should be shipped with a marshalled value and \nwhich dynamically rebound; what evaluation strategy to use; when rebinding takes effect; and what to \nrebind to. In this section our aim is to articulate the design space; for Acute we make in\u00adterim choices \nwhich suf.ce to bring out the typing and versioning issues involved in rebinding while keeping the language \nsimple. A running Acute program consists roughly of a sequence of module de.nitions (of ML structures), \nimports of modules with speci.ed signatures, which may or may not be linked, and marks which in\u00addicate \nwhere rebinding can take effect; together with running pro\u00adcesses and a shared store. Type names (\u00a75) \nType-safe marshalling demands a runtime no\u00adtion of type identity that makes sense across multiple versions \nof differing programs. For concrete types this is conceptually straight\u00adforward for example, one can \ncheck the equality between type int from one program instance and type int from another. For abstract \ntypes more care is necessary. Static type systems for ML modules involve non-trivial theories of type \nequality based on the source-code names of abstract types (e.g. M.t), but these are only meaningful within \na single program. We generate globally\u00admeaningful runtime type names for abstract types in three ways: \nby hashing module de.nitions, taking their dependencies into account; or freshly at compile-time;or freshly \nat run-time. The .rst two en\u00adable different builds or different programs to share abstract type names, \nby sharing their module source code or object code respec\u00adtively; the last is needed for modules with \neffect-full initialisation. In all three cases the way in which names are generated ensures that type \nname equality tests suf.ce to protect the invariants of abstract types. Expression-level names (\u00a76) Globally-meaningful \nexpression\u00adlevel names are needed for type-safe interaction, e.g. for communi\u00adcation channel names or \nRPC handles. They can also be constructed as hashes or created fresh at compile time or run time; we \nshow how these support several important idioms. The ways in which expression-level names are generated \nensure that name equality tests suf.ce to guarantee that any associated values (e.g. any val\u00adues passed \non named channels) have the right types. The polytypic support and swap operations of Shinwell, Pitts, \nand Gabbay s FreshOCaml [Shi05, SPG03] are included to support swizzling of local names during communication. \nVersions and version constraints (\u00a77, \u00a78) In a single-program development process one ensures the executable \nis built from a co\u00adherent set of versions of its modules by controlling static linking often, simply \nby building from a single source tree. With dynamic linking and rebinding more support is required: we \nadd versions and version constraints to modules and imports respectively. Al\u00adlowing these to refer to \nmodule names gives .exibility over whether code consumers or producers have control. There is a subtle \ninterplay between versions, modules, imports, and type identity, requiring additional structure in modules \nand imports. A mechanism for looking through abstraction boundaries is also needed for some version-change \nscenarios. Local concurrency and thunki.cation (\u00a79) Local concurrency is important for distributed programming. \nAcute provides a mini\u00admal level of support, with threads, mutexes and condition variables. Local messaging \nlibraries can be coded up using these, though in a production implementation they might be built-in for \nperformance. We also provide thunki.cation (loosely analogous to call/cc), al\u00adlowing a collection of \nthreads (and mutexes and condition vari\u00adables) to be atomically captured as a thunk that can then be \nmar\u00adshalled and communicated or stored; this enables various constructs for mobility and checkpointing \nto be coded up. Acute is not intended as a proposal for a full-scale language, but rather a vehicle for \nexperimentation and a starting point for debate several necessary but relatively straightforward features \nhave been omitted, and substantial problems remain for future work (especially some of the questions \nof \u00a74). Nonetheless, we believe that our examples demonstrate that the combination of the above features \nis a large part of what is needed to bring the bene.ts of ML-like languages to the programming of large-scale \ndistributed systems.  1.2 Semantics, Implementation, and Examples Most of the Acute grammar is standard, \na fragment of OCaml.For concreteness we summarise the new constructs in Figure 1. The remainder of the \npaper explains the main aspects of their meaning and usage (not all details of the grammar will be covered). \nSemantics The Acute static type system for source programs is based on an OCaml core and a second-class \nmodule system, with singleton kinds for expressing abstract and manifest type .elds in modules. Module \ninitialisation can involve arbitrary computation. The core does not have standard ML-style polymorphism, \nas our distributed infrastructure examples need .rst-class existentials (e.g. to code up polymorphic \nchannels) and .rst-class universals (for marshalling polymorphic functions). We therefore have explicit \nSystem F style polymorphism (the implementation does some ad\u00adhoc partial inference). The de.nition of \ncompilation describes how global type-and expression-level names are constructed, including the details \nof hash bodies. Our semantics for rebinding rests on the redex-time evaluation strategy, introduced in \n[BHS+03] for simply-typed .-calculus and here adapted to a second-class module system to express rebind\u00ading \nthe semantics must preserve the module structure throughout computation instead of substituting it away. \nThe semantics also preserves abstraction boundaries throughout computation, with a generalisation of \nthe coloured brackets of Grossman et al [GMZ00] to the entire Acute language (except, to date, the System \nF constructs). This is technically delicate (and not needed for implementations, which can erase all \nbrackets) but provides useful clarity in a setting where abstraction boundaries may be complex, with \nabstract types shared between programs. The semantics preserves also the internal structure of hashes. \nThis too can be erased in implementations, which can implement hashes and fresh names with literal bit-strings \n(e.g. 160-bit SHA1 hashes and pseudo-random numbers), but is needed to state type preservation and progress \nproperties. The abstraction-preserving semantics makes these rather stronger than usual. Implementation \nThe Acute implementation is written in FreshOCaml, as a meta-experiment in using the Fresh features for \na medium-scale program (some 25 000 lines). It is a prototype: de\u00adsigned to be ef.cient enough to run \nmoderate examples while re\u00admaining rather close in structure to the semantics. The runtime in\u00adterprets \nan intermediate language which is essentially the abstract syntax extended with closures. Performance \nis roughly 300 times slower than OCaml bytecode. T ::= int |bool |string |unit |char |void |T1 *.. *Tn \n|T1 + .. + Tn |T .T' |T list |T option |T ref |exn |MM .t |t |.t.T |.t.T |T name |T tie |thread |mutex \n|cvar |thunkifymode |thunkkey | thunklet | h.t | n e ::= ... |marshal e1 e2 : T |unmarshal e as T | marshalling \nfreshT |cfreshT |hash(MM .x)T |hash(T, e2)T, |hash(T, e2, e1)T, | nT | h.x name creation and names namecase \ne1 with {t, (x1, x2)}when x1 = e .e2 otherwise .e3 | namecase create thread |... |thunkify | [e]T |... \nthreads, thunkify, coloured brackets eqs sourcede.nition ::= module mode MM : Sig version vne = Str \nwithspec | module import mode MM : Sig version vce likespec by resolvespec = Mo | import mark MK mark \nFigure 1. Acute syntax: the full type grammar and the main non-standard expression and module forms. \nHere h is a module name, hash-or fresh-generated, n is a freshly-generated name, t is a module type .eld \nexternal identi.er, MM is a module external/internal identi.er pair, and MK is a string constant. The \ntype subscripts are typically inferred. The highlighted forms are only in the semantics, not source programs. \nThe de.nition is too large (on the scale of the ML de.nition rather than an idealised .-calculus) to \nmake proofs of soundness properties feasible with the available resources and tools. To in\u00adcrease con.dence \nin both semantics and implementation, therefore, our implementation is designed to optionally type-check \nthe entire con.guration after each reduction step. This has been extremely useful, identifying delicate \nissues in both the semantics and the code. Examples (\u00a710) We demonstrate that Acute does indeed support \ntypeful distributed programs with several medium-scale examples, all written as libraries in Acute above \nthe byte-string TCP Sockets API: a typed distributed channel library, an implementation of the Nomadic \nPict [SWP99] primitives for communication and mobility, and an implementation of the Ambient primitives \n[CG98]. These require and use most of the new features. Relationship to previous work (\u00a711, \u00a712) Acute \nbuilds on previous work, in which we introduced new-bound type names for abstract types [Sew01], hash-generated \ntype names [LPSW03], and controlled dynamic rebinding in a lambda-calculus [BHS+03], all in simple variants \nfor for small calculi. Our contribution here is threefold: discussion of the design space and identi.cation \nof features needed for high-level typed distributed programming, the synthesis of those features into \na us\u00adable experimental language, and their detailed semantic design. The main new technical innovations \nare: a uniform treatment of names created by hash, fresh, or compile-time fresh, both for type names \nand (covering the main usage scenarios) for expression names, dealing with module initialisation and \ndependent-record modules; explicit versions and version constraints, with their delicate inter\u00adplay with \nimports and type equality; module-level dynamic link\u00ading and rebinding; support for thunki.cation; and \nan abstraction\u00adpreserving semantics for all the above. Other related work is discussed in \u00a711, and we \nconclude in \u00a712.  2. Distributed abstractions: language vs libraries A fundamental question for a distributed \nlanguage is what commu\u00adnication support should be built in to the language runtime and what should be \nleft to libraries. The runtime must be widely deployed, and so is not easily changed, whereas additional \nlibraries can eas\u00adily be added locally. In contrast to some previous languages (e.g. Facile [TLK96], \nObliq [Car95], and JoCaml [JoC]), we believe that a general-purpose distributed programming language \nshould not have a built-in commitment to any particular means of interac\u00adtion. The reason for this is \nessentially the complexity of the dis\u00adtributed environment: system designers must deal with partial fail\u00adure, \nattack, and mobility of code, of devices, and of running computations. This complexity demands a great \nvariety of com\u00admunication and persistent store abstractions, with varying perfor\u00admance, security, and \nrobustness properties. At one extreme there are systems with tightly-coupled computation over a reliable \nnet\u00adwork in a single trust domain. Here it might be appropriate to use a distributed shared memory abstraction, \nimplemented above TCP. At another extreme, interaction may be intrinsically asyn\u00adchronous between mutually-untrusting \nruntimes, e.g. with crypto\u00adgraphic certi.cates communicated via portable persistent storage devices (smartcards \nor memory sticks), between machines that have no network connection. In between, there are systems that \nrequire asynchronous messaging or RMI but, depending on the network .rewall structure, tunnel this over \na variety of network protocols. To attempt to build in direct support for all the required ab\u00adstractions, \nin a single general-purpose language, would be a never\u00adending task. Rather, the language should be at \na level of abstraction that makes distribution and communication explicit, allowing dis\u00adtributed abstractions \nto be expressed as libraries. Acute has constructs marshal and unmarshal to convert arbi\u00adtrary values \nto and from byte strings; they can be used above any byte-oriented persistent storage or communication \nAPIs. This leaves the questions of (a) how these should behave, espe\u00adcially for values of functional \nor abstract types, and (b) what other local expressiveness is required, especially in the type system, \nto make it possible to code the many required libraries. The rest of the paper is devoted to these. \n3. Basic type-safe distributed interaction In this section we establish our basic conventions and assumptions, \nbeginning with the simplest possible examples of type-safe mar\u00adshalling. We .rst consider one program \nthat sends the result of mar\u00adshalling 5 on a .xed channel: IO.send( marshal \"StdLib\" 5 : int ) (ignore \nthe \"StdLib\" for now) and another that receives it, adds 3 and prints the result: IO.print_int(3+(unmarshal(IO.receive()) \nas int)) Compiling the two programs and then executing them in paral\u00adlel results in the second printing \n8. This and subsequent exam\u00adples are executable Acute code. For brevity they use a simple address-less \nIO library, providing primitives send:string->unit and receive:unit->string1. Below we write the parallel \nexe\u00ad 1 To emphasise that interaction might be via communication or via persis\u00adtent store, there are two \nimplementations of IO, one using TCP and one using .le IO; either can be used for these examples. cution \nof two separately-built programs vertically, separated by a dash . For safety, a type check is obviously \nneeded at run-time in the second program, to ensure that the type of the marshalled value is compatible \nwith the type at which it will be used. For example, the second program here IO.send( marshal \"StdLib\" \n\"five\" : string ) IO.print_int(3+(unmarshal(IO.receive()) as int)) should raise an exception. Allowing \ninteraction via an untyped medium inevitably means that some dynamic errors are possible, but they should \nbe restricted to clearly-identi.able program points, and detected as early as possible. Here we should \ndo that type check at unmarshal-time, but in some scenarios one may be able to exclude such errors at \ncompile-time, e.g. when communicating on a typed channel; we return to this in \u00a76. The unmarshal dynamic \ncheck might be of two strengths. We can: (a) include with the marshalled value an explicit representa\u00adtion \nof the type at which it was marshalled, and check at unmarshal-time that that type is equal to the type \nexpected by the unmarshal in the examples above, int=int and string=int respectively; or (b) additionally \ncheck that the marshalled value is a well-formed representation of something of that type.  In a trusted \nsetting, where one can assume that the string was created by marshalling in a well-behaved runtime (which \nmight be assured by network locality or by cryptographically-protected interaction with trusted partners), \noption (a) suf.ces for safety. If, however, the string might have been created or modi.ed by an attacker, \nthen we should choose (b), to protect the integrity of the local runtime. Note, though, that this option \nis not always available: when we consider marshalled values of an abstract type, it may not be possible \nto check at unmarshal-time that the intended invariants of the type are satis.ed. They may have never \nbeen expressed explicitly, or be truly global properties. In this case one should marshal only values \nof concrete types.2 In Acute we focus on the trusted case, with option (a), and the problems of distributed \ntyping, naming, and rebinding it raises. A full language should also support the untrusted case, e.g. \nwith marshalling to ASN.1 or XML, and type-or proof-carrying code for marshalled functions. We do not \ndiscuss the design of the concrete wire format for marshalled values the Acute semantics presupposes \njust a par\u00adtial raw unmarshal function from strings to abstract syntax of con.gurations, including module \nde.nitions and store fragments; the prototype implementation simply uses canonical pretty-prints of abstract \nsyntax. 4. Dynamic linking and rebinding to local resources 4.1 References to local resources Marshalling \nclosed values, such as the 5 and \"five\" above, is con\u00adceptually straightforward. The design space becomes \nmore inter\u00adesting when we consider marshalling a value that refers to some local resources. For example, \nthe source code of a function (it may be useful to think of a large plug-in software component) might \nmention identi.ers for: 2 One could imagine an intermediate point, checking the representation type but \nignoring the invariants, but the possibility of breaking key invariants is in general as serious as the \npossibility of breaking the local runtime. (1) ubiquitous standard library calls, e.g., print int; (2) \napplication-speci.c library calls with location-dependent se\u00admantics, e.g., routing functions; (3) application \ncode that is not location-dependent but is known to be present at all relevant sites; and (4) other \nlet-bound application values.  In (1 3) the function should be rebound to the local resource where and \nwhen it is unmarshalled, whereas in (4) the de.nitions of resources must be copied and sent along before \ntheir usages can be evaluated. There is another possibility: a local resource could be con\u00adverted into \na distributed reference when the function is marshalled, and usages of it indirected via further network \ncommunication. In some scenarios this may be desirable, but in others it is not, where one cannot pay \nthe performance cost for those future invocations, or cannot depend on future reliable communication \n(and do not want to make each invocation of the resource separately subject to communication failures). \nMost sharply, where the function is marshalled to persistent store, and unmarshalled after the original \nprocess has terminated, distributed references are nonsensical. Fol\u00adlowing the design rationale of \u00a72, \nwe do not support distributed references directly, aiming rather to ensure our language is expres\u00adsive \nenough to allow libraries of remotable resources to be written above our lower-level marshalling primitives. \n 4.2 What to ship and what to rebind Which de.nitions fall into (2 3) (to be rebound) and (4) (to be \nshipped) must be speci.ed by the programmer; there is usually no way for an implementation to infer the \ncorrect behaviour. We adapt the mechanism proposed in [BHS+03] (from a lambda-calculus setting to an \nML-style module language) to indicate which re\u00adsources should be rebound and which shipped for any marshal \nop\u00aderation. An Acute program consists roughly of a sequence of mod\u00adule de.nitions, interspersed with \nmarks, followed by running pro\u00adcesses; those module de.nitions, together with implicit module def\u00adinitions \nfor standard libraries, are the resources. Marks essentially name the sequence of module de.nitions preceding \nthem. Marshal operations are each with respect to a mark; the modules below that mark are shipped and \nreferences to modules above that mark are re\u00adbound, to whatever local de.nitions may be present at the \nreceiver. The mark \"StdLib\" used in \u00a73 is declared at the end of the stan\u00addard library; this mark and \nlibrary are in scope in all examples. In the following example the sender declares a module M with a \ny .eld of type int and value 6. It then marshals and sends the value fun ()->M.y. This marshal is with \nrespect to mark \"StdLib\", which lies above the de.nition of module M, so a copy of the M de.nition is \nmarshalled up with the value fun ()->M.y. Hence, when this function is applied to () in the receiver, \nthe evaluation of M.y can use that copy, resulting in 6. module M : sig val y:int end = struct let y=6 \nend IO.send( marshal \"StdLib\" (fun ()->M.y))  (unmarshal (IO.receive ()) as unit -> int) () On the other \nhand, references to modules above the speci.ed mark can be rebound. In the simplest case, one can rebind \nto an iden\u00adtical copy of a module that is already present on the receiver (for (3) or (1)). In the example \nbelow, the M1.y reference to M1 is re\u00adbound, whereas the .rst de.nition of M2 is copied and sent with \nthe marshalled value. This results in () and ((6,3),4) for the two programs. module M1:sig val y:int \nend = struct let y=6 end mark \"MK\" module M2:sig val z:int end = struct let z=3end IO.send( marshal \n\"MK\" (fun ()-> (M1.y,M2.z)) : unit->int*int)  module M1:sig val y:int end = struct let y=6 end module \nM2:sig val z:int end = struct let z=4 end ((unmarshal(IO.receive()) as unit->int*int)(),M2.z) Note that \nwe must permit running programs to contain multiple modules with the same source-code name and interface \nbut with different de.nitions (avoiding DLL hell ) here, after the un\u00admarshal, the receiver has two \nversions of M2 present, one used by the unmarshalled code and the other by the original receiver code. \nIn more interesting examples one may want to rebind to a local de.nition of M1 even if it is not identical, \nto pick up some truly location-dependent library. The code below shows this, terminating with () and \n(7,3). module M1:sig val y:int end = struct let y=6 end import M1:sig val y:int end version * = M1 mark \n\"MK\" module M2:sig val z:int end = struct let z=3end IO.send( marshal \"MK\" (fun ()-> (M1.y,M2.z)) : unit->int*int \n) module M1:sig val y:int end = struct let y=7 end module M2:sig val z:int end = struct let z=4 end \n(unmarshal (IO.receive ()) as unit->int*int) () The sender has two modules, M1 and M2, with M1 above \nthe mark MK. It marshals a value fun ()-> (M1.y,M2.z), that refers to both of them, with respect to that \nmark. This treats M2.z statically and M1.y dynamically at the marshal/unmarshal point: a copy of M2 is \nsent along, and on unmarshalling at the receiver the value is rebound to the local de.nition of M1, in \nwhich y=7. To permit this rebinding we use an explicit import import M1 : sig val y:int end version * \n= M1 An import introduces a module identi.er (the left M1) with a sig\u00adnature; it may or may not be linked \nto an earlier module or import (this one is, to the M1 module de.nition earlier in the example). The \nversion * overrides the default behaviour, which would constrain rebinding only to identical copies of \nM1. Marks are simply string constants, not binders subject to alpha equivalence, as they need to be dynamically \nrebound. For example, if one marshals a func\u00adtion that has an embedded marshal with respect to \"StdLib\", \nand then unmarshals and executes it elsewere, one typically wants the embedded marshal to act with respect \nto the now-local \"StdLib\". 4.3 Evaluation strategy: the relative timing of variable instantiation and \nmarshalling A language with rebinding cannot use a standard call-by-value op\u00aderational semantics, which \nsubstitutes out identi.er de.nitions as it comes to them, as some de.nitions may need to be rebound later. \nTwo alternative CBV reduction strategies were developed in [BHS+03] in a simple lambda-calculus setting: \nredex-time,in which one instantiates an identi.er with its value only when the identi.er occurs in redex-position, \nand destruct-time where instan\u00adtiation occurs even later, when the identi.er appears in a context which \nneeds to destruct the outermost structure of the value. The destruct-time semantics permits more rebinding, \nbut is also rather complex. We therefore use the redex-time strategy for module ref\u00aderences (local expression \nreduction remains standard CBV). For example, the .rst occurrence of M.y in the .rst program be\u00adlow will \nbe instantiated by 6 before the marshal happens, whereas the second occurrence would not appear in redex-position \nuntil a subsequent unmarshal and application of the function to (); the second occurrence is thus subject \nto rebinding. The results are () and (6,2). module M:sig val y:int end = struct let y=6 end import M:sig \nval y:int end version * = M mark \"MK\" IO.send( marshal \"MK\" (M.y, fun ()-> M.y) : int * (unit->int) ) \n module M:sig val y:int end = struct let y=2 end let ((x:int),(f:unit->int)) = (unmarshal(IO.receive()) \nas int*(unit->int)) in (x, f ())  4.4 Controlling when rebinding happens We have to choose whether or \nnot to allow execution of partial programs, which are those in which some imports are not linked to any \nearlier module de.nition (or import). Partial programs can arise in two ways. First, they can be written \nas such, as in conventional programs that use dynamic linking, where a library is omitted from the statically-linked \ncode, to be discovered and loaded at runtime. For example: import M : sig val y:int end version * = unlinked \nfun () -> M.y Secondly, they can be generated by marshalling, when one mar\u00adshals a value that depends \non a module above the mark (intending to rebind it on unmarshalling). For example, the .nal state of \nthe receiver in module M:sig val y:int end = struct let y=6 end import M:sig val y:int end version * \n= M mark \"MK\" IO.send( marshal \"MK\" (fun ()->M.y) : unit->int )  unmarshal (IO.receive ()) as unit->int \nis roughly the program below. import M : sig val y:int end version * = unlinked fun ()-> M.y If we disallow \nexecution of partial programs then, when we un\u00admarshal, all the unlinked imports that were sent with \nthe marshalled value must be linked in to locally-available de.nitions; the unmar\u00adshal should fail if \nthis is not possible. Alternatively, if we allow execution of partial programs, we must be prepared to \ndeal with an M.x in redex position where M is declared by an unlinked import. For any particular unmarshal, \none might wish to force linking to occur at unmarshal time (to make any errors show up as early as possible) \nor defer it until the imported modules are actually used. The latter allows successful execution of a \nprogram where one happens not to use any functionality that requires libraries which are not present \nlocally. Moreover, the us\u00adage point could be expressed either explicitly (as with a call to the Unix \ndlopen dynamic loader) or implicitly, when a module .eld appears in redex-position. A full language should \nsupport this per-marshal choice, but for simplicity Acute supports only one of the alternatives: it allows \nexecution of partial programs, and no linking is forced at unmarshal time. Instead, when an unlinked \nM.x appears in redex position we look for an M to link the import to. 4.5 Controlling what to rebind \nto How to look for such an M is speci.ed by a resolvespec that can (optionally) be included in the import. \nBy default it will be looked for just in the running program, in the sequence of modules de.ned above \nthe import. Sometimes, though, one may wish to search in the local .lesystem (e.g. for conventional shared-object \nnames such as libc.so.6), or even at a web URI. In Acute we make an ad-hoc choice of a simple resolvespec \nlanguage: a resolvespec is a .nite list of atomic resolvespecs, each of which is either Static Link, \nHere Already or a URI. Lookup attempts proceed down the list, with Static Link indicating the import \nshould already be linked, Here Already prompting a search for a suitable module (with the right name, \nsignature and version) in the running program, and a URI prompting a .le to be fetched and examined for \nthe presence of a suitable module. There is a tension between a restricted and a general resolvespec \nlanguage. Sometimes one may need the generality of arbitrary com\u00adputation (as in Java classloaders), \ne.g. in browsers that dynamically discover where to obtain a newly-required plugin. On the other hand, \na restricted language makes it possible to analyse a program to discover an upper bound on the set of \nmodules it may require necessary if one is marshalling it to a disconnected device, say. A full language \nshould support both, though the majority of programs might only need the analysable sublanguage. This \nresolvespec data is added to imports, for example: import M : sig val y:int end version * by \"http://www.cl.cam.ac.uk/users/pes20/acute/M.ac\" \n= unlinked M.y +3 Here the M.y is in redex-position, so the runtime ex\u00adamines the resolvespec list associated \nwith the im\u00adport of M. That list has just a single element, the URI http://www.cl.cam.ac.uk/users/pes20/acute/M.ac. \nThe .le there will be fetched and (if it contains a de.nition of M with the right signature) the modules \nit contains will be added to the running program just before the import, which will be linked to the \nde.nition of M. The M.y can then be instantiated with its value. Note that this mechanism is not an exception \n after M is loaded, the M.y is instantiated in its original evaluation context ( +3). It could perhaps \nbe encoded (with exceptions and af.ne continuations, or by encoding imports as option references) but \nhere we focus on the user language. 4.6 The structure of marks and modules A running Acute program has \na linear sequence of evaluated def\u00adinitions (marks, module de.nitions and imports) scoping over the running \nprocesses. Imports may be linked only to module de.ni\u00adtions (or imports) that precede them in this sequence. \nWhen a value is unmarshalled, any additional module de.nitions carried with it are added to the end of \nthe sequence. This linear structure suf.ces as a setting to explore the typing and naming issues in the \nremainder of the paper, but it is probably not ideal. For example, one might want cyclic linking (involving \nthe complexities of recursive modules or mixins); or support for two endpoints to negotiate about what \nmodules are already shared and what need to be shipped; or explicit control over what must not be shipped, \ne.g. due to license restrictions or security concerns. We leave these for future work.  5. Naming: global \nmodule and type names We now turn to marshalling and unmarshalling of values of abstract types. In ML, \nand in Acute, abstract types can be introduced by modules. For example, the module module EvenCounter \n: sig = struct type t type t=int val start:t let start = 0 val get:t->int let get = fun (x:int)->x val \nup:t->t let up = fun (x:int)->2+x end end provides an abstract type EvenCounter.t with representation \ntype int; this representation type is not revealed in the signature above. The programmer might intend \nthat all values of this type satisfy the even invariant; they can ensure this, no matter how the module \nis used, simply by checking that the start and up operations preserve evenness. Now, for values of type \nEvenCounter.t, what should the unmarshal-time dynamic type equality check of \u00a73 be? It should ensure \nnot just type safety with respect to the representation type, but also abstraction safety respecting \nthe invariants of the mod\u00adule. Within a single program, and for communication between pro\u00adgrams with \nidentical sources, one can compare such abstract types by their source-code paths, with EvenCounter.t \nhaving the same meaning in all copies (this is roughly what the manifest type and singleton kind static \ntype systems of Leroy [Ler94] and Harper et al [HL94] do). For distributed programming we need a notion \nof type equality that makes sense at runtime across the entire distributed system. This should respect \nabstraction: two abstract types with the same representation type but completely different operations \nwill have different invariants, and should not be compatible. Moreover, we want common cases of interoperation \nto just work : if two pro\u00adgrams share an (effect-free) module that de.nes an abstract type (and share \nits dependencies) but differ elsewhere, they should be able to exchange values of that type. We see three \ncases, with corresponding ways of constructing globally-meaningful type names. Case 1 For a module such \nas EvenCounter above that is effect\u00adfree (i.e. evaluation of the structure body involves no effects) \nwe can use module hashes as global names for abstract types, gener\u00adalising our earlier work [LPSW03] \nto dependent-record modules. The type EvenCounter.t is compiled to h.t, where the hash h is (roughly) \nhash( module EvenCounter : sig = struct type t type t=int val start:t let start = 0 val get:t->int let \nget = fun (x:int)->x val up:t->t let up = fun(x:int)->2+x end end ) i.e. the hash of the module de.nition \n(in fact, of the abstract syntax of the module de.nition, up to alpha equivalence and type equal\u00adity, \ntogether with some additional data). If one unmarshals a pair of type EvenCounter.t * EvenCounter.t the \nunmarshal type equality check will compare with h.t*h.t. This allows interoper\u00adation to just work between \nprograms that share the EvenCounter source code, without further ado. In constructing the hash for a \nmodule M we have to take into account any dependencies it has on other modules M , replacing any type \nand term references M .t and M .x. In our earlier work we did so by substituting out the de.nitions of \nall manifest types and terms (replacing abstract types by their hash type name). Now, to avoid doing \nthat term substitution in the implementation, we replace M .x by h .x, where h is the hash of the de.nition \nof M . This gives a slightly .ner, but we think more intuitive, notion of type equality. We still substitute \nout the de.nitions of manifest types from earlier modules. This is forced: in a context where M.t is \nmanifestly equal to int, it should not make any difference to subsequent types which is used. Case 2 \nNow consider effect-full modules such as the NCounter module below, where evaluating the up expression \nto a value in\u00advolves an IO effect. module fresh NCounter : sig = struct type t type t=int val start:t \nlet start = 0 val get:t->int let get = fun (x:int)->x val up:t->t let up = let step=IO.read_int() in \nfun (x:int)->step+x end end This reads an int from standard input at module initialisation time, and \nthe invariant that all values of type NCounter.t are a multiple of that int depends on that effect. \nFor such effect\u00adfull modules a fresh type name should be generated each time the module is initialised, \nat run-time, to ensure abstraction safety. Case 3 Returning to effect-free modules, the programmer may \nwish to force a fresh type name to be generated, to avoid acciden\u00adtal type equalities between different \nbut overlapping runs of the distributed system. A fresh name could be generated each time the module \nis initialised, as in the second case, or each time the module is compiled. This latter possibility, \nas in our earlier work [Sew01], enables interoperation between programs linked against the same compiled \nmodule, while forbidding interoperation between differ\u00adent builds. For abstract types associated with \nmodules it suf.ces to generate hashes or fresh names h per module, using the various h.t as the global \ntype names for the abstract types of that module. We let the programmer specify which of the three behaviours \nis required with a hash, fresh,or cfresh mode in the module de.nition, writing e.g. module hash EvenCounter. \nIn general it would be abstraction-breaking to specify hash or cfresh for an effect-full module. To prevent \nthis requires some kind of effect analysis, for which we use coarse but simple notions of valuabil\u00adity, \nfollowing [HS00], and of compile-time valuability. The mode defaults to the most liberal possible if \nomitted, and hash! and cfresh! modes allow valuability to be overridden where neces\u00adsary. Acute also \nprovides .rst-class System F existentials, as the ex\u00adperience with Pict [PT00] and Nomadic Pict [SWP99, \nUS01] demonstrates these are important for expressing messaging infras\u00adtructures. For these a fresh type \nname will be constructed at each unpack, to correspond with the static type system. 6. Naming: expression \nnames Globally-meaningful expression-level names are also needed, pri\u00admarily as interaction handles \ndispatch keys for high-level interaction constructs such as asynchronous channels, location\u00adindependent \ncommunication, reliable messaging, multicast groups, or remote procedure (or function/method) calls. \nFor any of these an interaction involves the communication of a pair of a handle and a value. Taking \nasynchronous channels as a simple example, these pairs comprise a channel name and a value sent on that \nchan\u00adnel. A receiver dispatches on the handle, using it to identify a local data structure for the channel \n(a queue of pending messages or of blocked readers). For type safety, the handle should be associated \nwith a type: the type of values carried by the channel. (RPC is sim\u00adilar except that an additional af.ne \nhandle must also be communi\u00adcated for the return value.) In Acute we build in support for the generation \nand typing of name expressions, leaving the various and complex dynamics of interaction constructs to \nbe coded up above marshalling and byte\u00adstring interaction. As in FreshOCaml, for any type T we have a \ntype T name of names associated with it. Values of these types (like type names) can be generated freshly \nat runtime, freshly at compile-time, or de\u00adterministically by hashing, with expression forms fresh, cfresh, \nhash(M.x), hash(T,e ), and hash(T,e,e ). We detail these forms below, showing how they support several \nimportant scenar\u00adios. In each, the basic question is how one establishes a name shared between sender \nand receiver code such that testing equality of the name ensures the type correctness of communicated \nvalues (and hence that there will be no unmarshal failures in the communica\u00adtion library). For clarity \nwe focus on distributed asynchronous messag\u00ading, supposing a module DChan which implements a distributed \nDChan.send by sending a marshalled pair of a channel name and a value across the network. module hash \nDChan : sig val send : forall t. t name * t -> unit val recv : forall t. t name * (t -> unit) -> unit \nend This uses names of type T name as channel names to communicate values of type T .3 Scenario 1 The \nsender and receiver both arise from a single execution of a single build of a single program. The execution \nwas initiated on machine A, and the receiver is present there, but the sender was earlier transmitted \nto machine B (e.g. within a marshalled lambda abstraction). Here the sender and receiver can originate \nfrom a single lexical scope and a channel name can be generated at runtime with a fresh expression. This \nmight be at the expression level, e.g. let (c : int name) = fresh in with sender code DChan.send %[int] \n(c,v) and re\u00adceiver DChan.recv %[int] (c,f), for some v:int and f:int->unit4, or a module-level binder \nmodule M : sig val c : int name end = struct let c = fresh end These generate the fresh name when the \nlet is evaluated or the module is initialised respectively. This .rst scenario is basically that supported \nby JoCaml and Nomadic Pict. Commonly one might have a single receiver function for a name, and tie together \nthe generation of the name and the de.nition of the function, with an additional DChan .eld val fresh_recv \n: forall t. (t -> unit) -> t name implemented simply as Function t -> fun f -> let c=fresh in DChan.recv \n%[t] (c,f); c and used as below. module M : sig val c : int name end = struct let c = DChan.fresh_recv \n%[int] (fun x -> IO.print_int x+1) end Note that this M is an effect-full module, creating the name \nfor c at module initialisation time. Scenario 2 The sender and receiver are in different programs, but \nboth are statically linked to a structure of names that was built previously, with expression cfresh \nfor compile-time fresh generation. Here one has a repository containing a compiled instance of a module \nsuch as 3 Acute does not yet support user-de.nable type constructors. If it did we would de.ne an abstract \ntype constructor Chan.c:Type->Type and have send : forall t. t Chan.c name * t -> unit. 4 The %[int] \nis an explicit type application, and later %[] are placeholders for inferred types. module cfresh M : \nsig val c : int name end = struct let c = cfresh end in a .le m.aco, which is included by the two programs \ncontaining the sender and receiver: includecompiled \"m.aco\" DChan.send %[int] (M.c,v) includecompiled \n\"m.aco\" DChan.recv %[int] (M.c,f) Different builds of the sender and receiver programs will be able to \ninteract, but rebuilding M creates a fresh channel name for c,so builds of the sender using one build \nof M will not interact with builds of the receiver using another build of M. This can be regarded as \na more disciplined alternative to the programmer making use of an explicit off-line name (or GUID) generator \nand pasting the results into their source code. Scenario 3 The sender and receiver are in different programs, \nbut both share the source code of a module that de.nes the function f used by the receiver; the hash \nof that module (and the identi.er f) is used to generate the name used for communication. This covers \nthe case in which the sender and receiver are dif\u00adferent execution instances of the same program (or \nminor variants thereof), and one wishes typed communication to work without any (awkward) prior exchange \nof names via the build process or at run\u00adtime. The shared code might be module hash N : sig val f : int \n-> unit end = struct let f = fun x->IO.print_int (x+100) end module hash M : sig val c : int name end \n= struct let c = hash(int,\"\",hash(N.f) %[]) %[] end in a .le nm.ac, included by the two programs containing \nthe sender and receiver: includesource \"nm.ac\" DChan.send %[int] (M.c,v) includesource \"nm.ac\" DChan.recv \n%[int] (M.c,N.f) The hash(N.f) gives a T name where T = int->unit is the type of N.f; the surrounding \nhash coercion hash(int,\"\", ) con\u00adstructs an int name from this.5 This involves a certain amount of boiler-plate, \nwith separate structures of functions and of the names used to access them, but it is unclear how that \ncould be improved. It might be preferable to regard the hash coercion as a family of poly\u00admorphic operators, \nindexed by pairs of type constructors .t.T 1 and .t.T 2 (of the same arity), of type .t.T 1 name . T \n2 name. Scenario 4 The sender and receiver are in different programs, sharing no source code except a \ntype and a string; the hash of the pair of those is used to generate the name used for communication. \nlet c = hash(int,\"foo\") %[] in DChan.send %[int] (c,v) let c = hash(int,\"foo\") %[] in DChan.recv %[int] \n(c,f) This idiom requires the minimum shared information between the two programs. It can be seen as \na disciplined, typed, form of the use of untyped traders to establish interaction media between separate \ndistributed programs. Scenario 5 The sender and receiver have established by some means a single typed \nshared name c, but need to construct many 5 Such coercions support Chan.c type constructors too, e.g. \nto construct an int Chan.c name from an (int->unit) name. shared names for different communication channels. \nThe hash co\u00adercion can be used for this also, constructing new typed names from old names, new types, \nand arbitrary strings. Whether this will be a common idiom is unclear, but it is easy to provide and \nseems inter\u00adesting to explore. 7. Versions and version constraints In a single-executable development \nprocess, one ensures the exe\u00adcutable is built from a coherent set of versions of its component modules \nby choosing what to link together in simple cases, by working with a single code directory tree. In \nthe distributed world, one could do the same: take suf.cient care about which modules one links and/or \nrebinds to. Without any additional sup\u00adport, however, this is an error-prone approach, liable to end \nup with semantically-incoherent versions of components interoperat\u00ading. Typechecking can provide some \nbasic sanity guarantees, but cannot capture these semantic differences. One alternative is to permit \nrebinding only to identical copies of modules that the code was initially linked to. Usually, though, \nmore .exibility will be required to permit rebinding to modules with small or backwards-compatible changes \nto their seman\u00adtics, and to pick up intentionally location-dependent modules. It is impractical to specify \nthe semantics that one depends upon in interfaces (in general, theorem proving would be required at link \ntime, though there are intermediate behavioural type systems). We therefore introduce versions as crude \napproximations to semantic module speci.cations. We need a language of versions, which will be attached \nto modules; a language of version constraints, which will be attached to imports; a satisfaction relation, \nchecked at static and dynamic link times; and an implication relation between con\u00adstraints, for chains \nof imports. Now, how expressive should these languages be? Analogously to the situation for resolvespecs, \nthere is a tension between allow\u00ading arbitrary computation in de.ning the relations and supporting compile-time \nanalysis. Ultimately, it seems desirable to make the basic module primitives parametric on abstract types \nof version and constraint languages in a particular distributed code environ\u00adment, one may want a particular \nlocal choice for these. For Acute once again we choose not the most general alternative, but instead \none which should be expressive enough for many examples, and which exposes some key design points. Scenario \n1 It is common to use version numbers which are supplied by the programmer, with no checked relationship \nto the code. As an arbitrary starting point, we take version numbers to be nonempty lists of natural \nnumbers, and version constraints to be similar lists possibly ending in a wildcard * or an interval; \nsatis\u00adfaction is what one would expect, with a * matching any (possibly empty) suf.x. The meanings of \nthese numbers and constraints is dependent on some social process: within a single distributed de\u00advelopment \nenvironment one needs a shared understanding that new versions of a module will be given new version \nnumbers commen\u00adsurate with their semantic changes. Scenario 2 To support tighter version control than \nthis, we can make use of the global module names (hash-or freshly-generated) introduced in \u00a75: equality \ntesting of these names is an imple\u00admentable check for module semantic identity. We let version num\u00adbers \ninclude myname and version constraints include module iden\u00adti.ers M (those in scope, obviously). In each \ncase the compiler or runtime writes in the appropriate module name. This supports a useful idiom in which \ncode producers declare their exact iden\u00adtity as the least-signi.cant component of their version number, \nand consumers can choose whether or not to be that particular. For example, a module M might specify \nit is version 2.3.myname, compiled to 2.3.0xA564C8F3; an import in that scope might re\u00adquire 2.3.M, compiled \nto 2.3.0xA564C8F3, or simply 2.3.*; both would match it. A key point is the balance of power between \ncode producers and code consumers. The above leaves the code producer in control, who can lie about which \nversion a module is instead of writing myname they might write a name from a previous build. This is \ndesirable if they know there are clients out there with an exact\u00adname constraint but also know that their \nsemantic change from that previous build will not break any of the clients. Scenario 3 Finally, to give \nthe code consumer more control, we allow constraints not only on the version .eld of a module but also \non its actual name (which is unforgeable within the language). Typically one would have a de.nition of \nthe desired version avail\u00adable in the .lesystem (in Acute bringing it into scope as M with an include) \nand write name=M. (These exact-name constraints are also used to construct default imports when marshalling.) \nOne could also cut-and-paste a name in explicitly: name=0xA564C8F3. To guarantee that only mutually-tested \ncollections of modules will be executed together, e.g. when writing safety-critical software, this would \nbe the desired idiom everywhere, perhaps with development\u00adenvironment support. In constructing hashes \nfor modules we also take into account their version expressions, to prevent any accidental equalities. \nThat version expression can mention myname, and, as we do not wish to introduce recursive hashes, the \nhash must be calculated before compilation replaces myname with the hash. 8. Interplay between abstract \ntypes, rebinding and versions 8.1 De.nite and inde.nite references With conventional static linking, \nmodule references such as M.t are de.nite, in the terminology of [HP05]: in any fully-linked executable \nthere is just a single such M, though (with separate compilation) it may be unknown at compile-time which \nmodule de.nition for M it will be linked to. In contrast, the possibility of rebinding makes some references \ninde.nite during a single distributed execution, they may be bound to different modules. For example, \nconsider a module that declares an abstract type that depends on the term .elds of some other module: \nmodule M : sig val f:int->int end = struct let f=fun(x:int)->x+2 end module EvenCounter : sig = struct \ntype t type t=int val start:t let start = 0 val get:t->int let get = fun (x:int)->x val up:t->t let up \n= fun (x:int)->M.f x end end In the absence of any rebinding, the runtime type name for the abstract \ntype EvenCounter.t would be the hash of the EvenCounter abstract syntax with M.f replaced by h.f, where \nh is the hash of the abstract syntax of M. This dependence on the M operations guarantees type-and abstraction-preservation. \nNow, however, if there is a mark between the two module de.\u00adnitions, a marshal can cut and rebind to \nany other module with the same signature, perhaps breaking the invariant of EvenCounter.t that its values \nare always even. The M.f module reference below is inde.nite. module M : sig val f:int->int end = struct \nlet f=fun (x:int)->x+2 end import M : sig val f:int->int end version * = M mark \"MK\" module EvenCounter \n: sig = struct type t type t=int val start:t let start = 0 val get:t->int let get = fun (x:int)->x val \nup:t->t let up = fun (x:int)->M.f x end end IO.send(marshal \"MK\" (fun ()->EvenCounter.get (EvenCounter.up \nEvenCounter.start)):unit->int) module M : sig val f:int->int end = struct let f=fun (x:int)->x+3end \n(unmarshal (IO.receive ()) as unit->int) () To prevent this kind of error one can use a more restrictive \nversion constraint in the import of M that EvenCounter uses, either by using an exact-name constraint \nname=M to allow linking only to de.nitions of M that are identical to the de.nition in the sender, or \nby using some conventional numbering. If no import is given explicitly, an exact-name constraint is assumed. \nThe version constraint should be understood as an assertion by the code author that whatever EvenCounter \nis linked with, so long as it satis.es that constraint (and also has an appropriate signature, and is \nobtained following any resolvespec present), the intended invariants of EvenCounter.t will be preserved. \nNow, what should the global type name for EvenCounter.t be here? Note that the original author might \nnot have had any M module to hand, and even if they did (as above), that module is not privileged in \nany way: EvenCounter may be rebound during com\u00adputation to other M matching the signature and version \nconstraint. In generating the hash for EvenCounter, analogously to our replace\u00adment of de.nite references \nM .x by the hash of the de.nition of M , we replace inde.nite import-bound references such as M.f by \nthe hash of the import. This names the set of all M implementations that match that signature and version \nconstraint. In the case above this hash would be roughly hash(import M:sig val f:int->int end version \n* ) and where one imports a module with an abstract type .eld import M : sig type t val x:t end version \n2.4.7-... the hash h = hash(import M : sig type t val x:t end version 2.4.7-...) provides a global \nname h.t for that type. In the EvenCounter example, the imported module had no ab\u00adstract type .elds. \nIn cases where there are such, for type soundness we have to restrict the modules that the import can \nbe linked to, to ensure that they all have the same representation types for these ab\u00adstract type .elds. \nWe do so by requiring imports with abstract type .elds to have a likespec (in place of the ... above), \ngiving that information. A compiled likespec is essentially a structure with a type .eld for each of \nthe abstract type .elds of the import. At .rst sight this is quite unpleasant, requiring the importers \nof a module to know representation types which one might ex\u00adpect should be hidden. With inde.nite references \nto modules with abstract types, however, some such mechanism seems to be forced, otherwise no rebinding \nis possible. Moreover, in practice one would often have available a version of the imported library from \nwhich the information can be drawn. For example, one might be import\u00ading a graphics library that exists \nin many versions, but for which all versions that share a major version number also have common rep\u00adresentations \nof the abstract types of point, window, etc. A typical import might have the form import Graphics:sig \ntype t end version 2.3.* like Graphics2_0 (with more types and operations) where Graphics2 0 is the \nname of a graphics module implementation, which is present at the de\u00advelopment site, and which can be \nused by the compiler to construct a structure with a representation for each of the abstract types of \nthe signature. While the abstraction boundaries are not as rigid as in ML, this should provide a workable \nidiom for dealing with large modular evolving systems, supporting rebinding but also allowing one to \nrestrict type representation information to particular layers. The only alternative seems to be to make \nall types fully concrete at interfaces where rebinding may occur. To correctly deal with abstract types \nde.ned by modules fol\u00adlowing an import, which use abstract type .elds of the imported module in their \nrepresentation types, compiled likespecs must be included in the hashes of imports. On the other hand, \nwe choose not to include resolvespecs in import hashes. This is debatable the argument against including \nthem is that it is useful to be able to change the location of code without affecting types, and so without \nbreaking interoperation (e.g. to have a local code mirror, to change a web code repository to avoid a \ndenial-of-service attack etc.). Note that the inde.nite character of our imports makes them quite different \nfrom module imports that are resolved by static link\u00ading, where typing can simply use module paths to \nname any abstract types and no likespec machinery is required. Both mechanisms are needed. 8.2 Breaking \nabstractions With changing versions, sometimes one must allow new code to see through the abstraction \nboundaries of earlier abstract types, either to make new types compatible with old (if their invariants \nare essentially the same) or to express conversion functions. In [Sew01, LPSW03] we proposed a strong \ncoercion with! to do this, and Acute includes a variant thereof. By analogy with ML sharing speci.cations, \nwe allow a module de.nition to have a withspec,a list of equalities between abstract types and representation \ntypes from modules constructed earlier (often this will be of previous builds of the same module). The \ncompiler checks the representation type of these M.t are equal to the types speci.ed (respecting any \ninternal abstraction boundaries); if they are, the type equalities can be used in typechecking this de.nition. \n 8.3 Exact matching or version .exibility? In \u00a76 we focussed on name-based dispatch, delivering an incoming \nmessage by demultiplexing on a name it contains. An alternative Acute idiom for remote invocation simply \nmakes use of its dynamic rebinding facilities, e.g. by marshalling a thunk mentioning an identi.er N.f. \nThis involves dynamic subsignature and version checks much more costly than name equality, but also \nmuch more .exible.  9. Mobility, thunkify, and local concurrency We want to make it possible to checkpoint \nand move running com\u00adputations for fault-tolerance, for working with intermittently\u00adconnected devices, \nand for system management, e.g. to move services to replacement hardware. Several calculi and languages \n(JoCaml, Nomadic Pict, Ambients, etc.) provided a linear migra\u00adtion construct, which moved a computation \nbetween locations. It is more generally useful to support marshalling of computations, which can then \nbe communicated, checkpointed etc., using what\u00adever communication and persistent store constructs are \nin use. Tak\u00ading a step further, as we have marshalling of arbitrary values, mar\u00adshalling of computations \nrequires only the addition of a primi\u00adtive for converting a running computation into a value. We call \nthis thunki.cation. Checkpointing a computation can then be im\u00adplemented by thunkifying it, marshalling \nthe resulting value, and writing it to disk. Migration can be implemented by thunki.cation, marshalling, \nand communication. Note that these are not in general linear operations if a computation has been checkpointed \nto disk it may be restarted multiple times. Distributed programming also requires support for local con\u00adcurrency, \nwith threads and constructs for interaction between them. In large programs we expect both shared-memory \nand message\u00adpassing interaction to be required. In Acute we initially provide shared-memory interaction \nbetween language-level threads, as in OCaml: references can be accessed from multiple threads, with atomic \ndereferencing and assignment, and mutexes and condition variables can be used for synchronization. These \nenable certain forms of message-passing interaction to be expressed as library modules. (Some forms of \nmessage passing, e.g. Join patterns with their multi-way binding construct, would need direct language \nsup\u00adport.) Thunki.cation for a single thread would be close to call/cc, but in the concurrent setting \nthere are many possible forms: asyn\u00adchronous or synchronous, with different atomicity, and with dif\u00adferent \ninteractions with naming, blocking system calls, and mod\u00adule initialisation. The choices and our rationale \nare discussed in [SLW+04]; here we note only that we have an asynchronous thunkify that can atomically \ncollect a group of named threads, mutexes, and condition variables. It is a dangerous operation, as one \nmight for example separate a thread from a mutex on which it is blocked, but this seems to be inescapable, \narising ultimately from the possibility of disconnection between subcomputations. We ex\u00adpect it to be \nused to implement libraries that simultaneously pro\u00advide computation mobility (or checkpointing) and \nsafe distributed interaction mechanisms. 10. Pulling it all together: examples We have written three \nexample distributed communication libraries in Acute: a distributed message-passing library; an implementation \nof the Nomadic Pict constructs for migration of mobile computa\u00adtions and communication between them; \nand an implementation of the Ambient calculus primitives. There are also two games that mostly exercise \nlocal computation, blockhead and minesweeper; the latter using marshalling to save and restore the game \nstate. The distributed message-passing library shows how many of the Acute features are needed and used. \nIt has the following modules: Tcp connection management maintains TCP connections to TCP addresses (IP \naddress/port pairs), creating them on demand. Tcp string messaging uses that to provide asynchronous \nmes\u00adsaging of strings to TCP addresses. These are both hash modules, with abstract types of handles; \nthey spawn daemons to deal with incoming communications. Separately, a module Local channel provides \nlocal (within a runtime) asynchronous messaging, again with an abstract type of channel management handles \nand with polymorphic send:forall t. t name * t -> unit and recv:forall t. t name*(t->unit) -> unit (to \nregister a handler). Channel states are stored as existential packages of lists of pending messages or \nreceptors; a namecase operation is used to unpack existential name/value packages, allowing a new type \nequality to be used in the true branch of a name equality test. Mutexes are needed for protection. Distributed \nchannel pulls these together, with send:forall t.string->(Tcp.addr*t name)->t-> unit (and a similar recv) \nfor distributed asynchronous messaging to TCP addresses. The string names the mark to marshal with respect \nto. For a local address this simply uses Local channel. For a remote address the send marshals its t \nargument and uses Tcp string messaging; the recv unmarshals and generates a local asynchronous output. \nThis deals with the non-mobile case active receivers cannot be moved from one runtime to another. However, \ncode that uses this module, e.g. functions that invoke send and recv, can be marshalled and shipped between \nruntimes; the module initialisation state includes the TCP messaging handles and so rebinding to different \ninstances of send and recv works correctly. Finally, a simple RFI module implements remote function invocation \nabove distributed channels. Clients of this library can use any of the various ways of creating shared \ntyped names discussed in \u00a76 and \u00a78.3. Moreover, the use of .rst-class marks means that clients have the \nsame .exible control over the marshalling that goes on as direct users of marshal. The Nomadic Pict library \nsupports mobility of running com\u00adputations, with named groups of threads, each with a local chan\u00adnel \nmanager, that can migrate between machines. Migration uses thunkify to capture the group s channel and \nthread state. Threads within a group can interact via local channels; groups can inter\u00adact with a location-dependent \nsend remote that sends a message to a channel of a group assumed to be at a particular TCP ad\u00address. \nThe location-independent messaging algorithms of JoCaml or high-level Nomadic Pict should be easy to \nexpress above this (the former requiring the polytypic support and swap operations to manipulate the \nfree channel names of a communicated value). The Ambient library implements the mobility primitives of \nthe Ambient calculus. An ambient is a collection of running threads and resources (including other ambients) \nthat migrates as a unit: mobility amounts to restructuring the nesting tree of the ambients. In a distributed \nworld, this nested structure is shared among differ\u00adent runtimes. Interactions between ambients in the \nsame run-time are resolved using local concurrency, mutexes and cvars. Interac\u00adtion between remote machines \nmay cause an ambient to migrate to another runtime: this is implemented using thunki.cation and marshalling, \non top of the TCP string messaging library. Each of these libraries is around 1000 lines of Acute code, \nin\u00adcluding comments and utility functions. They took a few days or weeks to write, in sharp contrast \nto the many months required for the original Nomadic Pict implementation. Much of the remaining complexity \nis related to local concurrency and locking. The dis\u00adtributed aspects were rather straightforward, with \nthe Acute rebind\u00ading semantics used to ensure that communicated code is correctly rebound to the local \nstate of the libraries at the receiver. 11. Related work There is extensive related work on module systems, \ndynamic bind\u00ading, dynamic type tests, and distributed process calculi. For most of this we refer the \nreader to the discussion in our earlier papers [Sew01, LPSW03, BHS+03], con.ning our attention here to \nsome of the most relevant distributed programming language develop\u00adments. Many address distributed execution, \nwith type-safe interac\u00adtion within a single program that forks across the network, but there has been \nlittle work on distributed development, on typed interac\u00adtion between programs6, or on version change. \nEarly work on adding local concurrency to ML resulted in Concurrent ML [Rep99] and the initial Facile, \nboth based on the SML/NJ implementation. Facile was later extended with rich support for distributed \nexecution, including a notion of location and computation mobility [TLK96]. Erlang [AVWW96] supports \nconcurrency, messaging and distribution, but without static typing. The Pict experiment [PT00] investigated \nhow one could base a usable programming language purely on local concurrency, with a p-calculus core \ninstead of primitive functions or objects. The Dis\u00adtributed Join Calculus [FGL+96] and subsequent JoCaml \nimple\u00admentation [JoC] modi.ed the p primitives with a view to distri\u00ad 6 Several, including JoCaml and \nNomadic Pict, have ad-hoc traders for establishing initial connections between programs. bution, and \nadded location hierarchies and location migration. The runtime involved a complex forwarding-pointer \ndistributed infras\u00adtructure to ensure that, in the absence of failure, communication was location-independent. \n(Polyphonic C [BCF02] adds the Join Calculus local concurrency primitives to a class-based language.) \nOther work in the 1990s was also aimed at providing distribution transparency, notably Obliq [Car95], \nwith network-transparent re\u00admote object references above Modula3 s network objects. Distribution transparency, \nwhile perhaps desirable in tightly\u00adcoupled reliable networks, cannot be provided in systems that are \nunreliable or span administrative boundaries. Work on Nomadic Pict [SWP99, US01] adopted a lower level \nof abstraction, showing how a wide variety of distributed infrastructure algorithms, includ\u00ading one similar \nto that of the JoCaml implementation, could be expressed in a high-level language; one was proved correct. \nThe low level of abstraction means the core language can have a clean and easily-understood failure semantics; \nthe work is a step towards the argument of \u00a72. A distinct line of work has focussed on typing the entire \ndistributed system to prevent resource access failures, for Dp [HRY04] and with modal types [MCHP04]. \nEven where this is pos\u00adsible, however, one must still deal with low-level network failure. Work on Alice \n[BRS+05, Ros03] is perhaps closest to ours, with ML modules, support for marshalling ( pickling ) arbitrary \nvalues, and run-time fresh generation of abstract type names, but without rebinding, our distributed \ntype and term naming, or version control. Furuse and Weis supports type-safe, but not abstraction\u00adsafe, \nmarshalling of non-functional values in OCaml [FW00]. Both Java and .NET have some versioning support, \nthough neither is integrated with the type system. Java serialisation, used in RMI, includes serialVersionUIDs \nfor classes of any se\u00adrialised objects. These default to (roughly) hashes of the method names and types, \nnot including the implementation. Class authors can override them with hashes of previous versions. Linking \nfor Java, and in particular binary compatibility, has been studied by Drossopoulou et al. [DEW99]. The \n.NET framework supports ver\u00adsioning of assemblies [Dot03]. Sharable assemblies must have strong names, \nwhich include a public key, .le hashes, and a ma\u00adjor.minor.build.revision version. Compile-time assembly \nreferences can be modi.ed before use by XML policy .les of the application, code publisher, and machine \nadministrator; the semantics is com\u00adplex [BMED05]. Explicit versioning is common in package management, \nhow\u00adever. For example, both RedHat and Debian packages can contain version constraints on their dependencies, \nwith numeric inequal\u00adities and capability-set membership. ELF shared objects express certain version \nconstraints using pathname and symlink conven\u00adtions. Vesta [Ves] provides a rich con.guration language. \nAs discussed in \u00a73 Acute addresses the case in which complex values must be communicated and the interacting \nruntimes are not malicious. Much other work applies to the untrusted case, with various forms of proof-carrying \ncode and wire-format ASN.1 and XML typing. 12. Conclusions and future work We have addressed key issues \nin the design of high-level program\u00adming languages for distributed computation, discussing the lan\u00adguage \ndesign space and presenting the Acute language. Acute is a synthesis of an OCaml core with several novel \nfeatures: dynamic rebinding, global fresh and hash-based type and term naming, ver\u00adsions, type-and abstraction-safe \nmarshalling, etc. It is an experi\u00admental language, not a proposal for a full production language, but \n(as demonstrated by our examples) it shows much of what is needed for higher-order typed distributed \ncomputation. The new constructs should also admit an ef.cient implementa\u00adtion. The two main points are \nthe tracking of runtime type informa\u00adtion, and the implementation of redex-time reduction and rebind\u00ading. \nFor the .rst, note that an implementation does not need to have types for all runtime values, but only \n(hashes of) the types that reach marshal and unmarshal points. The second would be a smooth ex\u00adtension \nof OCaml s existing CBV implementation: OCaml cur\u00adrently maintains each .eld reference M.x as a pointer \nuntil it is in redex position, whereupon it is dereferenced. Since .eld references inside a thunk remain \nas pointers, they could easily be rebound with only modest changes to the run-time. Of course compile-time \ninlin\u00ading optimisations between parts of code separated by a mark would no longer be possible. A great \ndeal of future work remains. In the short term, more practical experience in programming in Acute is \nneeded, and there are unresolved semantic issues in the interaction between explicit polymorphism, coloured \nbrackets, and marshalling. Straightfor\u00adward extensions would ease programming: user de.nable type op\u00aderators \nand recursive datatypes, .rst-order functors, and richer ver\u00adsion languages. A more ef.cient implementation \nruntime may be needed for larger examples. Improved tool support for the seman\u00adtics would be of great \nvalue, for meta-typechecking, for confor\u00admance testing, and for proofs of soundness. More fundamentally: \nwe must study more re.ned low-level linking, for negotiation and for access control (revisiting the lin\u00adear \nmark/module structure); subtyping is needed for many version\u00adchange scenarios, perhaps with corresponding \nsubhash relations; and the constructs we have presented should be integrated with sup\u00adport for untrusted \ninteraction. Expressing libraries of distributed references with distributed garbage collection is also \na challenge. This combination would support a wide range of distributed pro\u00adgramming well. Acknowledgements \nWe acknowledge a Royal Society Univer\u00adsity Research Fellowship (Sewell), a St Catharine s College Heller \nResearch Fellowship (Wansbrough), an INRIA grant post-doc `etranger (Zappa Nardelli), EPSRC grants GRN24872 \nand al \u00b4 GRT11715, EC FET-GC project IST-2001-33234 PEPITO, and APPSEM 2. We thank Vilhelm Sj\u00a8oberg and \nChristian Steinr\u00a8ucken for their early implementation work and Gilles Peskine for dis\u00adcussions on coloured \nbrackets. Andrew Appel, Matthew Fairbairn, Jean-Jacques L\u00b4evy, Luc Maranget, Mark Shinwell, Gilles Peskine, \nFrancois Pottier, and Alisdair Wren provided helpful comments.   References [AVWW96] J. Armstrong, \nR. Virding, C. Wikstrom, and M. Williams. Concurrent Programming in Erlang. Prentice Hall, 1996. 2nd \ned. [BCF02] N. Benton, L. Cardelli, and C. Fournet. Modern concurrency abstractions for C .In Proc. ECOOP, \nLNCS 2374, 2002. [BHS+03] G. Bierman, M. Hicks, P. Sewell, G. Stoyle, and K. Wans\u00ad brough. Dynamic rebinding \nfor marshalling and update, with destruct-time ..In Proc. ICFP, 2003. [BMED05] Alex Buckley, Michelle \nMurray, Susan Eisenbach, and Sophia Drossopoulou. Flexible bytecode for linking in .NET. In Proc. BYTECODE \n2005, April 2005. [BRS+05] D. Le Botlan, A. Rossberg, C. Schulte, G. Smolka, and G. Tack, 2005. www.ps.uni-sb.de/alice/. \n[Car95] L. Cardelli. A language with distributed scope. In Proc. 22nd POPL, pages 286 297, 1995. [CG98] \nL. Cardelli and A. D. Gordon. Mobile ambients. In Proc. FoSSaCS, LNCS 1378, 1998. [DEW99] S. Drossopoulou, \nS. Eisenbach, and D. Wragg. A fragment calculus towards a model of separate compilation, linking and \nbinary compatibility. In Proc. LICS, 1999. [Dot03] Packacking and deploying .Net framework applications \n(.Net framework tutorials, msdn), 2003. [FGL+96] C. Fournet, G. Gonthier, J.-J. L\u00b4evy, L. Maranget, and \nD. Remy. \u00b4A calculus of mobile agents. In Proc. 7th CONCUR, LNCS 1119, 1996. [FW00] Jun Furuse and Pierre \nWeis. Entr\u00b4 ees/sorties de valeurs en Caml. In J. Francophones des Langages Applicatifs, 2000. [GMZ00] \nD. Grossman, G. Morrisett, and S. Zdancewic. Syntactic type abstraction. ACM TOPLAS, 22(6):1037 1080, \n2000. [HL94] R. Harper and M. Lillibridge. A type-theoretic approach to higher-order modules with sharing. \nIn Proc. 21st POPL, 1994. [HP05] R. Harper and B. C. Pierce. Design issues in advanced module systems, \n2005. Chapter in Advanced Topics in Types and Programming Languages, B. C. Pierce, editor. [HRY04] M. \nHennessy, J. Rathke, and N. Yoshida. Safedpi: A language for controlling mobile code. In Proc. FOSSACS, \nLNCS 2987, 2004. [HS00] R. Harper and C. Stone. A type-theoretic interpretation of standard ML. In Proof, \nLanguage and Interaction: Essays in Honour of Robin Milner. 2000. [JoC] JoCaml. http://pauillac.inria.fr/jocaml/. \n[Ler94] X. Leroy. Manifest types, modules, and separate compila\u00adtion. In Proc. 21st POPL, 1994. [LPSW03] \nJ. J. Leifer, G. Peskine, P. Sewell, and K. Wansbrough. Global abstraction-safe marshalling with hash \ntypes. In Proc. 8th ICFP, 2003. [MCHP04] T. Murphy, K. Crary, R. Harper, and F. Pfenning. A symmetric \nmodal lambda calculus for distributed computing. In Proc. LICS, 2004. [PT00] B. C. Pierce and D. N. Turner. \nPict: A programming language based on the pi-calculus. In Proof, Language and Interaction: Essays in \nHonour of Robin Milner. 2000. [Rep99] J. H. Reppy. Concurrent Programming in ML. Cambridge Univ Press, \n1999. [Ros03] A. Rossberg. Generativity and dynamic opacity for abstract types. In Proc. 5th PPDP, August \n2003. [Sew01] P. Sewell. Modules, abstract types, and distributed versioning. In Proc. 28th POPL, 2001. \n[Shi05] M. R. Shinwell. The Fresh Approach: functional program\u00adming with names and binders. Technical \nReport UCAM-CL\u00adTR-618, University of Cambridge, Computer Laboratory, 2005. [SLW+04] P. Sewell, J. J. \nLeifer, K. Wansbrough, M. Allen-Williams, Francesco Z. Nardelli, P. Habouzit, and V. Vafeiadis. Acute: \nHigh-level programming language design for distributed computation. design rationale and language de.nition. \nTechnical Report 605, University of Cambridge Computer Laboratory, October 2004. Also published as INRIA \nRR\u00ad5329. 193pp. [SLW+05] P. Sewell, J. J. Leifer, K. Wansbrough, M. Allen-Williams, F. Zappa Nardelli, \nP. Habouzit, and V. Vafeiadis. Source release of the Acute system, January 2005. Available from http://www.cl.cam.ac.uk/users/pes20/acute/. \n[SPG03] M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: Programming with binders made simple. \nIn Proc. 8th ICFP, pages 263 274, 2003. [SWP99] P. Sewell, P. T. Wojciechowski, and B. C. Pierce. Location\u00adindependent \ncommunication for mobile agents: a two-level architecture. In Internet Programming Languages, LNCS 1686, \npages 1 31, 1999. [TLK96] B. Thomsen, L. Leth, and T.-M. Kuo. A Facile tutorial. In CONCUR 96, LNCS 1119, \n1996. [US01] A. Unyapoth and P. Sewell. Nomadic Pict: Correct communication infrastructure for mobile \ncomputation. In Proc. POPL, pages 116 127, January 2001. [Ves] Vesta. http://www.vestasys.org/. \n\t\t\t", "proc_id": "1086365", "abstract": "Existing languages provide good support for typeful programming of standalone programs. In a distributed system, however, there may be interaction between multiple instances of many distinct programs, sharing some (but not necessarily all) of their module structure, and with some instances rebuilt with new versions of certain modules as time goes on. In this paper we discuss programminglanguage support for such systems, focussing on their typing and naming issues.We describe an experimental language, Acute, which extends an ML core to support distributed development, deployment, and execution, allowing type-safe interaction between separately-built programs. The main features are: (1) type-safe marshalling of arbitrary values; (2) type names that are generated (freshly and by hashing) to ensure that type equality tests suffice to protect the invariants of abstract types, across the entire distributed system; (3) expression-level names generated to ensure that name equality tests suffice for type-safety of associated values, e.g. values carried on named channels; (4) controlled dynamic rebinding of marshalled values to local resources; and (5) thunkification of threads and mutexes to support computation mobility.These features are a large part of what is needed for typeful distributed programming. They are a relatively lightweight extension of ML, should be efficiently implementable, and are expressive enough to enable a wide variety of distributed infrastructure layers to be written as simple library code above the byte-string network and persistent store APIs. This disentangles the language runtime from communication intricacies. This paper highlights the main design choices in Acute. It is supported by a full language definition (of typing, compilation, and operational semantics), by a prototype implementation, and by example distribution libraries.", "authors": [{"name": "Peter Sewell", "author_profile_id": "81100511814", "affiliation": "University of Cambridge", "person_id": "PP14177906", "email_address": "", "orcid_id": ""}, {"name": "James J. Leifer", "author_profile_id": "81337490961", "affiliation": "INRIA Rocquencourt", "person_id": "PP43121732", "email_address": "", "orcid_id": ""}, {"name": "Keith Wansbrough", "author_profile_id": "81100225284", "affiliation": "University of Cambridge", "person_id": "PP38023996", "email_address": "", "orcid_id": ""}, {"name": "Francesco Zappa Nardelli", "author_profile_id": "81100512653", "affiliation": "INRIA Rocquencourt", "person_id": "PP38025669", "email_address": "", "orcid_id": ""}, {"name": "Mair Allen-Williams", "author_profile_id": "81100528280", "affiliation": "University of Cambridge", "person_id": "P745802", "email_address": "", "orcid_id": ""}, {"name": "Pierre Habouzit", "author_profile_id": "81100532454", "affiliation": "INRIA Rocquencourt", "person_id": "P745804", "email_address": "", "orcid_id": ""}, {"name": "Viktor Vafeiadis", "author_profile_id": "81100493655", "affiliation": "University of Cambridge", "person_id": "PP14172721", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086370", "year": "2005", "article_id": "1086370", "conference": "ICFP", "title": "Acute: high-level programming language design for distributed computation", "url": "http://dl.acm.org/citation.cfm?id=1086370"}