{"article_publication_date": "09-12-2005", "fulltext": "\n A Principled Approach to Operating System Construction in Haskell Thomas Hallgren Mark P Jones OGI \nSchool of Science &#38; Engineering Oregon Health &#38; Science University http://www.cse.ogi.edu/~hallgren/ \nhttp://www.cse.ogi.edu/~mpj/ Abstract We describe a monadic interface to low-level hardware features \nthat is a suitable basis for building operating systems in Haskell. The interface includes primitives \nfor controlling memory management hardware, user-mode process execution, and low-level device I/O. The \ninterface enforces memory safety in nearly all circumstances. Its behavior is speci.ed in part by formal \nassertions written in a programming logic called P-Logic. The interface has been imple\u00admented on bare \nIA32 hardware using the Glasgow Haskell Com\u00adpiler (GHC) runtime system. We show how a variety of simple \nO/S kernels can be constructed on top of the interface, including a sim\u00adple separation kernel and a demonstration \nsystem in which the ker\u00adnel, window system, and all device drivers are written in Haskell. Categories \nand Subject Descriptors D.3.2 [Programming Lan\u00adguages]: Language Classi.cations Applicative (functional) \nlan\u00adguages; D.4.0 [Operating Systems]: Organization and Design; D.4.5 [Operating Systems]: Reliability \nVeri.cation General Terms Languages,Design,Veri.cation Keywords Operating systems, Haskell, hardware \ninterface, mon\u00adads, programming logic, veri.cation  1. Introduction Systems software often contains \nbugs that cause system failures, security violations, or degraded performance. One reason for the high \nbug rate is that most of this software is written in C or C++, which lack strong static typing and memory \nsafety. For example, many security failures are due to buffer over-runs that could have been avoided \nsimply by using a programming language that en\u00adforced type safety and bounds checking. Writing systems \nsoftware in a relatively low-level implementa\u00adtion language makes it hard to assure that the software \nobeys key speci.cations. For example, we might wish to verify formally that an operating system maintains \nstrict data separation between its processes. If the O/S is written in C, this will be a very challeng\u00ading \ntask, because reasoning about the program must be performed Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 05 September 26-28, 2005, Tallinn, Estonia. \nCopyright c . 2005 ACM 1-59593-064-7/05/0009. . . $5.00. Rebekah Leslie Andrew Tolmach Department of \nComputer Science Portland State University http://www.cs.pdx.edu/~rebekah/ http://www.cs.pdx.edu/~apt/ \nat a very low level. Again, using a programming language with a cleaner and safer semantics would ease \nthe reasoning task. Given these goals, Haskell is an attractive language for systems programming. The \ncore of Haskell is type-safe and memory-safe, which prevents many classes of bugs, and also pure, which \neases reasoning about program behavior. In addition, Haskell s highly expressive type system can be used \nto capture important program properties without the need for additional proofs. Systems software needs \nto interact directly with machine hard\u00adware, which can be accomplished in Haskell by using the built-in \nIO monad and the Foreign Function Interface (FFI) extensions. Un\u00adfortunately, this extended system includes \nraw pointers and pointer arithmetic, which allow writes to arbitrary memory locations and can corrupt \nthe Haskell heap. It also includes unsafePerformIO, which can be used to manufacture unsafe type casts. \nOf course, just as in C, these problems can be addressed by careful coding, but we would like a safer \ninfrastructure instead. In this paper, we describe the design, implementation, and ap\u00adplication of a \nrestricted monadic framework that achieves this goal. The monad provides access to hardware facilities \nneeded to build an operating system on the Intel IA32 architecture [13], including virtual memory management, \nprotected execution of arbitrary user binaries, and (low-level) I/O operations. The interface is memory\u00adsafe \nin almost all circumstances; the only possible safety violations are ones that occur via abuse of a device \nDMA controller. More\u00adover, unlike the full IO monad, it is small enough that we can enu\u00admerate useful \nproperties about it as a basis for reasoning about the behavior of its clients. For example, we can assert \nthat executing a program in user space has no impact on kernel data structures. Such properties can be \nviewed as part of the speci.cation of the in\u00adterface. We give them as formulas in P-Logic [18], a programming \nlogic for Haskell that has been developed as part of the Progra\u00admatica project [22], which is an on-going \ninvestigation into using Haskell for high-assurance development. We are using this hardware monad as \nthe basis for some ex\u00adperimental operating system kernels that exploit Haskell s strengths: House is \na small operating system coded almost entirely in Haskell. It builds on the previous hOp project conducted \nby S\u00b4ebastien Carlier and Jeremy Bobbio [4]. The system includes device drivers, a simple window system, \na network protocol stack, and a command shell window in which a.out .les can be loaded (via TFTP) and \nexecuted in user-mode. To our knowl\u00adedge, this is the .rst functional-language operating system that \nsupports execution of arbitrary user binaries (not just programs written in the functional language itself). \n Osker, currently in development, is a microkernel coded in Haskell, based on L4 [25], for which we \nhope to prove some key  security properties, including a strong notion of separation be\u00adtween multiple \ndomains and/or virtual machines that are hosted on a single computer. We expect these proofs to be based \non a combination of type-based and ad-hoc reasoning. The hardware monad properties will be key axioms \nin the ad-hoc proofs. The architecture of this kernel makes heavy use of Haskell s type classes, especially \nto describe monad transformers. We have implemented the hardware monad directly on top of IA32 hardware. \nOur implementation uses a modi.ed version of the Glasgow Haskell Compiler (GHC) runtime system [10], \nbased on that of hOp. We retain most services of the runtime system, including the garbage collector \nand, optionally, the Concurrent Haskell multi-threading primitives. In place of the usual .le-based I/O, \nwe provide direct access to the IA32 s I/O ports and memory\u00admapped regions, and we add support for direct \naccess to paging hardware and protection mode switching. In effect, this combines the runtime system \nand the operating system in a single entity. In addition to this real implementation, we have developed \na model implementation of (most of) the hardware monad entirely in pure Haskell 98. This version is built \non an abstract model of mod\u00adern CPUs that uses a combination of state and continuation mon\u00adads to implement \nthe mechanisms of virtual memory and protected mode execution [16]. The pure Haskell implementation provides \nus with a more formal setting in which to validate the consistency of the properties that we have speci.ed \nfor the hardware monad. For example, others in our group are working towards mechanized proofs for many \nof these properties using Isabelle, and based on the semantics of Haskell instead of informal assumptions \nabout any speci.c CPU platform. However, we omit further discussion of this work from the current paper. \nRelated work The idea of applying functional languages to sys\u00adtems programming has a long history. Early \nexamples of operating systems implemented in functional languages include Nebula [17] and the Kent Applicative \nOperating System [24, 6]. A more recent project, Hello [9], implements an operating sys\u00adtem in Standard \nML and addresses various language design and ef.ciency issues, like how to access hardware devices and \nhow to handle interrupts in a garbage-collected language. It builds on the results of the Fox project,where \nStandard ML was used for systems programming. In particular, it includes FoxNet, an ef.cient imple\u00admentation \nof the TCP/IP protocol stack [2]. Compared to these projects, one new feature of our hardware monad is \nits support for controlling memory management hardware, which allows us to run code written in other \nlanguages safely. Functional languages have also been applied when real-time constraints are an issue. \nEmbedded Gofer [27] has an incremen\u00adtal garbage collector in addition to other language features needed \nto program embedded controllers [28]. We have not seriously ad\u00addressed real-time issues in our project \nyet, but if we do, then we might .nd it necessary to switch to a version of GHC that uses an incremental \ngarbage collector [5]. Our goal of making systems programming safer is shared by projects using other \nhigh-level languages. SPIN [23] takes advan\u00adtage of the type safety of Modula-3 [3] to ensure safety \nin an ex\u00adtensible O/S kernel. Cyclone [14, 7] is a language deliberately de\u00adsigned as a safe replacement \nfor C. Modern PC hardware is complex, and building an operating system to control it can be a daunting \ntask. Abstraction layers that provide reusable, higher-level, simpler and safer interfaces to the hardware \ncan be useful in many contexts. In this sense, our hardware monad has something in common with OSKit \n[21], except that we go a step further by equipping our hardware interface with formal assertions.We \nexpect this to facilitate formal reasoning about software built on top of the interface. The design of \nappropriate abstraction layers within operating systems is also currently receiving attention from researchers \ninter\u00adested in virtualizing the underlying processor. A good summary of this topic can be found in a \nrecent publication by the Xen group [8]. Outline We assume reading knowledge of Haskell throughout. Section \n2 introduces the P-Logic notation used in the remainder of the paper. Section 3 describes the Hardware \n(H) monad interface using type signatures and P-Logic assertions. Section 4 gives the complete code for \na simple demand-paging kernel for single user processes built on top of H. Section 5 outlines the features \nof House and Section 6 sketches some of the ideas of the Osker kernel. Section 7 gives some details of \nthe real hardware implementation. Section 8 concludes. 2. The Programatica Approach and P-Logic Much \nof the work described in this paper has been carried out in the context of the Programatica project, \nwhich, at a high-level, is concerned with general methodologies, tools, and foundations to support development \nand certi.cation of secure and reliable soft\u00adware systems [22]. As part of this work, we are building \nOsker, a new microkernel written in Haskell. We are using Osker as a case study to evaluate and demonstrate \nour tools and techniques. At the same time, to establish the feasibility of building a working operat\u00ading \nsystem in Haskell, we have been working on the House demon\u00adstration operating system. Both Osker and \nHouse have in.uenced the design of the Hardware monad interface. One of our main goals is to prove that \nOsker satis.es some key security properties. With this in mind, we are developing formal models for Osker \nand its components, including the Hardware in\u00adterface. The speci.cation and behavior of the the kernel \nare cap\u00adtured by annotating the source code with properties that are written using an extension of Haskell \nsyntax called P-Logic [18]. In the remainder of this section, we summarize the fragment of P-Logic that \nis needed to understand the properties that appear in later sections. Well-formed formulas The core syntax \nof P-Logic uses the sym\u00adbols /\\, \\/, ==>, and -/ for conjunction (and), disjunction (or), implication, \nand negation, respectively. (Note that -/ was chosen as an ASCII rendering of the \u00ac symbol.) Universal \nquanti.cation over nvariables is written in the form All v1, ..., vn.formula. Existential quanti.cation \nuses the Exist keyword instead of All. Predicates Predicates are written using expressions for the form \nPe1 ... en where P is a property name and e1 through en are program terms. To avoid potential confusion \nbetween the prop\u00aderty and the programming language notations, compound Haskell terms must be enclosed \nin braces when they appear inside a P-Logic formula. For example, the predicate P {x+1} {y+2} asserts \nthat the values of the expressions x+1 and y+2 are related by the property P. Braces are not required \naround simple Haskell expres\u00adsions such as variables and literals. For example, we might write All x,y. \nP xy==> P yx to specify that P is symmetric. Semantic equalities are written using two-place predicates \nof the form e1===e2. The syntax e1=/=e2 is also used as a convenient shorthand for -/(e1===e2). Note \nthat these are different from the standard == and /= operators, which can only be used inside a Haskell \nterm and not directly in a P-Logic formula. A Haskell expression eof type Bool can be lifted into a P-Logic \nformula using a predicate of the form True{e}, which asserts that ewill evaluate to True. Of course, \nthe Haskell Bool type includes a bottom value, ., in addition to False and True, so the lifting of an \nexpression to a formula of the logic in this way and, indeed, the general treatment of bottom in P-Logic \nrequires special care and attention. The details of this can be found elsewhere [18]. Predicates as sets \nIt is often useful to identify a unary predicate with the set of values for which it is true. With this \nin mind, the syntax of P-Logic allows us to write a predicate Pe1 ... en e (with n+1arguments) in the \nform e ::: Pe1 ...en. For exam\u00adple, given a two place predicate MultipleOf n m, which asserts that m \nis a multiple of n, we might choose instead to write this in the form m ::: MultipleOf n and to think, \nat least informally, of MultipleOf n as a re.nement of the Int type that contains only the multiples \nof n. In this way, the triple colon symbol, :::, is used here in much the same way that the double colon \nsymbol is used in Haskell expressions e::T to indicate that ehas type T. P-Logic also provides a comprehension-like \nnota\u00adtion, {| x1,...,xn | formula |}, for an n-place pred\u00adicate over the variables x1 through xn. For \nexample, the MultipleOf n property mentioned previously can be written as {| m | Exists k. m==={n*k} \n|}. Continuing the view of predicates as sets, P-Logic syntax over\u00adloads /\\ and \\/ as intersection and \nunion operators on (partially applied) predicate expressions. For example, assuming the standard de.nitions \nfor arithmetic, MultipleOf 2 /\\ MultipleOf 3 is equivalent to MultipleOf 6. De.ning new properties The \nProgramatica tools allow new prop\u00aderty names to be introduced by including property de.nitions in the \nsource of a Haskell program, each of which takes the form: property Pa1 ... an = predicateExpression \nThe variables a1,...,an here represent (optional) arguments to P. Figures 1 and 2 show several examples \nthat will also be used in later sections. The properties in Figure 1 describe the usual behavior that \nwe would expect of set and get operations in a stateful monad. The StateGetGet property, for instance, \nspeci.es that multiple reads from the state using get should return the same value. Note that the get \nidenti.er used here is a placeholder for a predicate argument, and not a reference to some globally de.ned \nget opera\u00adtor. The Returns property that appears in Figure 1 speci.es that a monadic computation returns \na given value. It is de.ned as follows: property Returns x = {| m | m==={m>>return x} |} Figure 2 de.nes \nsome independence (or non-interference) prop\u00aderties. For example, Commute c d speci.es that c and d can \nbe executed in either order, without a change in behavior. Commute is used to de.ne IndependentSetSet \nset set , which asserts that the two set operators do not interfere with each other (be\u00adcause, presumably, \nthey operate on distinct components of the state). The predicate m ::: PostCommute c d speci.es the weaker \nprop\u00aderty that execution of c and d will commute if we execute the m command .rst. We often use quanti.cation \nover m to express state\u00addependent properties. For example, we can specify that c and d commute in any \nstate where the monadic computation q would re\u00adturn True, by writing: property Q = {| m | {do m; q} ::: \nReturns {True} |} assert All m. m ::: Q ==> m ::: PostCommute c d Finally, as illustrated here, our tools \nsupport the use of assert declarations to indicate that a particular P-Logic formula should be true. \nDeclarations like these can be used to record program speci.\u00adcations and also to capture expectations \nabout program behavior.  3. A Hardware Monad The raw hardware facilities needed to build an operating \nsystem within Haskell can be compactly and conveniently speci.ed as the operations of a monad, which \nwe call H (for Hardware ). H should be thought of as a specialized version of the usual Haskell IO monad, \nsuitable for supporting programs that run in the machine s privi\u00adleged (supervisor) mode. Since such \nprograms are usually (though not necessarily) operating systems, we refer to them throughout this paper \nas kernels. The main program of a kernel has type H(). Like IO, the H monad provides primitives for expressing \nstate\u00adful computations and for interacting with the real world, but at a lower level. For example, IO \nhas primitives for allocating, read\u00ading, and writing mutable reference cells in the garbage-collected \nHaskell heap, whereas H provides only primitives for reading and writing raw physical memory locations \ndisjoint from the Haskell heap. Similarly, IO provides stream I/O operations on terminals and .les, whereas \nH provides operations to read and write the machine s programmed I/O ports. Some versions of IO have \nsupport for asyn\u00adchronous signal and exception handling; H gives direct access to the machine s interrupt \nmechanism. H also provides facilities un\u00adlike any found in IO; in particular, it provides safe access \nto the machine s virtual memory mechanisms, and supports safe execu\u00adtion of arbitrary machine binaries \nin user-mode. Another important characteristic of H is that it is small: only a dozen types and about \ntwenty operations. This relatively small size makes it possible for us to formalize many of its properties \nusing P-Logic, which would be extremely dif.cult for the huge IO monad (often described as containing \neverything but the kitchen sink. ) We are particularly interested in documenting independence properties \nof the interface. H supports several kinds of memory-like entities: physical memory for user processes; \nvirtual memory page maps; programmed I/O ports; and memory-mapped I/O locations. These kinds of memory \nare all essentially distinct. For example, writes to physical memory or to a memory-mapped location do \nnot normally affect reads from the page maps or I/O ports. Many of the P-Logic properties that we introduce \nbelow are intended to formalize this intuition. It is dif.cult to imagine expressing similar independence \nproperties for the operations of the standard IO monad. A key design goal for H is safety. With the exception \nof certain I/O operations (as discussed in Section 3.4), no operations in H can cause corruption of the \nHaskell heap. The remainder of this section describes the types and opera\u00adtors of the H interface in \ndetail. Our description is divided into four major areas: physical memory access; virtual memory; user-space \nprocess execution; and physical I/O. Much of the interface is es\u00adsentially machine-independent. When \na dependency is exposed, we will assume that the underlying hardware is an IA32 machine. With each operator \nwe provide example properties that help specify its behavior. Note that many of these properties fail \nin the presence of implicit concurrency; we discuss this further in Section 3.5. 3.1 Physical Pages \nand Addresses The type PAddr represents byte addresses in the machine s raw physical memory. type PAddr \n= (PhysPage,POffset) type PhysPage --instance of Eq, Show type POffset = Word12 pageSize = 4096 :: Int \nIt is composed from an abstract type PhysPage, representing a physical page, and a numeric POffset, representing \nthe offset of a byte within that page. Type Word12 behaves analogously to the standard unsigned integer \ntypes (e.g., Word8); thus, arithmetic operations are performed modulo pageSize. PhysPages correspond \nto physical pages that are available for allocation to user-mode processes. New physical pages are allo\u00adcated \nfrom (a subset of) the raw physical memory that is installed in the machine using: property StateGetGet \nget = {do x<-get; y<-get; return x} === {do x<-get; y<-get; return y} property StateSetSet set = All \nx, x . {do set x; set x } === {do set x } property StateSetGet set get = All x. {do set x; get} ::: Returns \nx property Stateful set get = StateGetGet get /\\ StateSetSet set /\\ StateSetGet set get Figure 1. Stateful \nproperties for set and get operations. property Commute c d = {do x<-c; y<-d; return (x,y)} === {do y<-d; \nx<-c; return (x,y)} property PostCommute c d = {| m | {do m; x<-c; y<-d; return (x,y)} === {do m; y<-d; \nx<-c; return (x,y)} |} property IndependentSetSet set set = All x, x . Commute {set x} {set x } property \nIndependentSetGet set get = All x. Commute {set x} {get} property Independent set get set get = IndependentSetSet \nset set /\\ IndependentSetGet set get /\\ IndependentSetGet set get Figure 2. Non-interference properties \nfor set and get operations. allocPhysPage :: H (Maybe PhysPage) A call to allocPhysPage returns Nothing \nif no more pages are available. Each allocated page is distinct: property JustGenerative f = All m. {do \nJust x <-f; m; Just y <-f; return(x==y)} ::: Returns {False} assert JustGenerative allocPhysPage There \nis no explicit mechanism to free PhysPages; this guarantees that any value of type PhysPage is usable \nat any point. An imple\u00admentation for H may choose to free physical pages implicitly by using GHC s weak \npointers1 to track when pages are no longer ref\u00aderenced by the kernel. In addition, a kernel can recycle \npages by maintaining its own free list. The contents of individual addresses can be read and written \nusing getPAddr and setPAddr, respectively. getPAddr :: PAddr -> H Word8 setPAddr :: PAddr -> Word8 -> \nH () By construction, every value of type PAddr is a valid address, so these functions are total. (We \ndo not attempt to model hardware failures such as parity errors.) Each physical address acts like an \nindependent store element with the usual state-like semantics. Us\u00ading the auxiliary properties from Figures \n1 and 2, we can formalize this intuition with the following assertion: assert All pa, pa . pa =/= pa \n==> Stateful {setPAddr pa} {getPAddr pa} /\\ Independent {setPAddr pa} {getPAddr pa} {setPAddr pa } {getPAddr \npa }  3.2 Virtual Memory The virtual memory facilities in the H monad support writing and reading of \npage maps, which de.ne the translation of virtual ad\u00ad 1 A weak pointer to an object is not traced by \nthe garbage collector and hence does not by itself keep the object alive. It can be tested to see whether \nthe object is still alive or not. dresses to physical addresses, with associated access permissions and \nhistory. Execution of user space code is performed in the ad\u00address space de.ned by a particular page \nmap. Although the raw hardware supports only one current page map, the H interface sup\u00adports multiple \nsimultaneous page maps, each of which typically corresponds to a different user process. VAddr is a concrete \ntype representing virtual addresses. type VAddr = Word32 minVAddr, maxVAddr :: VAddr minVAddr = 0x10000000 \nmaxVAddr = 0xffffffff vaddrRange = (minVAddr,maxVAddr) It wouldn t make sense to treat virtual addresses \nas abstract types, because user code often references these addresses directly. Not all 32-bit words \nare valid virtual addresses, because part of every user address space (currently the .rst 256MB) is reserved \nfor the kernel. The range of valid addresses is given by minVAddr and maxVAddr, but, because user code \nmust already be compiled with the range of valid addresses in mind, these parameters are not very useful \nto the kernel, except for sanity checking. They do allow us to de.ne a validity property: property ValidVAddr \n= {| v | True{inRange vaddrRange v} |} New page maps, represented by the abstract type PageMap, are \nobtained using allocPageMap. The number of available page maps may be limited; allocPageMap returns returns \nNothing if no more maps are available. type PageMap --instance of Eq, Show allocPageMap :: H (Maybe PageMap) \nEach allocated map is distinct: assert JustGenerative allocPageMap As for PhysPages, there is no explicit \nmechanism to free PageMaps, but the H implementation may do implicit freeing, and a kernel may keep a \nfree list. Page map entries are indexed by valid virtual addresses; all addresses on the same page share \na single entry. The entry for an unmapped page contains Nothing; the entry for a mapped page contains \na value, Just p, where p is of type PageInfo. data PageInfo = PageInfo { physPage::PhysPage, writable, \ndirty, accessed::Bool } deriving (Eq,Show) Here, the writable .ag indicates whether the user process \nhas write access to the page. Fields physPage and writable are writ\u00adten by the kernel using setPage; \nthey are not changed during user\u00admode execution. The dirty and accessed .ags record the history of page \nuse by the user process. Roughly speaking, dirty indicates that the page has been written; accessed indicates \nthat it has been read or written. These .elds are typically initialized to False by the kernel using \nsetPage, subsequently updated during user pro\u00adcess execution (in ways we make more precise below), and \nread back by the kernel using getPage. setPage :: PageMap -> VAddr -> Maybe PageInfo ->H () getPage :: \nPageMap -> VAddr -> H (Maybe PageInfo) Note that PageMaps are simple, one-level mappings; the IA32 hardware \nactually uses a two-level paging scheme, but we choose to hide this detail underneath the H interface. \nPage maps are initially empty, so every valid virtual page address maps to Nothing. Each page map entry \nbehaves like an independent store element. property OnSamePage va va = {va div (fromIntegral pageSize)} \n=== {va div (fromIntegral pageSize)} assert All pm, pm , va, va . va:::ValidVAddr /\\ va :::ValidVAddr \n/\\ (pm =/= pm \\/ -/ OnSamePage va va ) ==> Stateful {setPage pm va} {getPage pm va} /\\ Independent {setPage \npm va} {getPage pm va} {setPage pm va }{getPage pm va } Moreover, page map entries and physical addresses \nare mutually independent. assert All pm, pa, va . va ::: ValidVAddr ==> Independent {setPage pm va} {getPage \npm va} {setPAddr pa} {getPAddr pa} 3.3 User-space Execution The operator for executing code in a user \naddress space is execContext :: PageMap -> Context -> H (Interrupt,Context) The Context type describes \nthe state of the processor, including the values of program-accessible registers and control .ags; it \nes\u00adsentially plays the role of a continuation. For the IA32: data Context = Context { edi,esi,ebp,esp,ebx, \nedx,ecx,eax,eip,eflags :: Word32 } Here, edi, esi, and ebx through eax are general-purpose regis\u00adters; \nesp is the stack pointer; ebp is (typically) the frame pointer; eip is the instruction pointer; and eflags \nis the control .ag regis\u00adter (of which only certain bits are accessible to user programs). The context \nshould really also include the .oating point registers and other user-visible registers associated with \nIA32 extensions such as MMX; our current system omits these for simplicity. Similar con\u00adtext structures \ncould be de.ned for other processor architectures. Invoking execContext installs the speci.ed page map \nand con\u00adtext into the appropriate hardware registers and puts the proces\u00adsor into user mode. User code \nthen executes (starting at the eip recorded in the Context) and can access the physical addresses visible \nto it through its page map. When user-mode execution is in\u00adterrupted the processor records the new current \ncontext and returns to supervisor mode; execContext then returns with that Context and the nature of \nthe Interrupt. For the IA32, we have data Interrupt = I_DivideError | I_NMIInterrupt | ... | I_GeneralProtection \nErrorCode | I_PageFault PageFaultErrorCode VAddr | ... | I_ExternalInterrupt IRQ | I_ProgrammedException \nWord8 Interrupt constructors (of which only a selection are shown here) correspond to fault vector addresses, \nand fall into three classes: Processor-detected faults, such as I DivideError and I Page-Fault; the latter \nis parameterized by the kind of fault and by the virtual address where the fault occurred.  Externally-generated \ninterrupts with an associated IRQ channel number. For example, timer interrupts generate I External-Interrupt \nIRQ0.  Software exceptions with an associated interrupt number. For example, executing an INT 0x80 machine \ninstruction, which is often used to enter system calls, generates I Programmed-Exception 0x80.  A similar \ntype could be de.ned for other processor architectures. This elegant, continuation-like model for user-space \ncomputa\u00adtions supports simple and ef.cient kernel designs. For example, in Section 4, we will outline \na simple demand-paging kernel that can be built using these primitives. In the remainder of this subsection, \nwe provide some simple assertions that capture essential features of execContext. Most of these are independence \nproperties. Clearly, the behavior of execContext will be determined by the way that the page map parameter \nis con.gured before the function is called. To begin, we can characterize all of the programs m that \nleave physi\u00adcal address pa inaccessible in the page map pm using this predicate: property NotMapped pm \npa = {| m | All va . (va ::: ValidVAddr) ==> {do m; isMappedTo pm va pa} ::: Returns {False} |} Here \nisMappedTo pm va pa is a simple auxiliary Haskell func\u00adtion (not shown here) that is True iff pm provides \nread access through the virtual address va to the page containing physical ad\u00address pa. We can de.ne \na similar predicate NotMappedWritableTo to specify that a physical page is inaccessible for writing. \nNow we can give some key properties of execContext: Changing the contents of an unmapped physical address \ncannot affect execution. assert All pm, pa, c, x, m. m ::: NotMapped pm pa ==> m ::: PostCommute {setPAddr \npa x} {execContext pm c} Execution can only change the contents of a physical address that is mapped \nwritable. assert All pm, pa, c, m. m ::: NotMappedWritable pm pa ==> m ::: PostCommute {getPAddr pa} \n{execContext pm c} Changing one page map does not affect execution under another page map: assert All \npm, pm , va, c, x. pm =/= pm /\\ va ::: validVAddr ==> Commute {setPage pm va x} {execContext pm c} Executing \nunder a page map does not affect the page mapping or writable status of any entry in that map and has \nno effect at all on any other page map. assert All pm, va, c. va ::: validVAddr ==> Commute {getPageField \nphysPage pm va} {execContext pm c} assert All pm, va, c. va ::: validVAddr ==> Commute {getPageField \nwritable pm va} {execContext pm c} getPageField field pm va = liftM (fmap field) (getPage pm va) assert \nAll pm, pm , va, c. pm =/= pm /\\ va ::: validVAddr ==> Commute {getPage pm va} {execContext pm c} If \nexecution under a page map changes some physical address, then that map must contain an entry that maps \nthe page as writable and has its dirty and access .ags set. property Changed pa pm c ={| m | {do m; \nx <-getPAddr pa; execContext pm c; y <-getPAddr pa; return (x == y)} ::: Returns {False} |} property \nDirty pa pm c = {| m | Exist va . va ::: ValidVAddr /\\ {do m; execContext pm c; getPage pm va} ::: Returns \n{Just PageInfo { physPage = fst pa, writable = True, dirty = True, accessed = True}} |} assert All pa, \npm, c, m. m ::: Changed pa pm c ==> m ::: Dirty pa pm c Note that the last assertion only partially \nspeci.es how dirty and access bits behave; it gives suf.cient, but not necessary conditions for them \nto be set after execution. In particular, we do not specify that access bits should be set when a user \nprocess reads from a page. In fact, we have no way to state such an assertion, because we (deliberately) \ndon t model the instruction-level behavior of user processes. Fortunately, the kernel properties we are \ninterested in proving do not rely on having accurate access bit information. 3.4 I/O and Interrupts \nThe H interface supports the use of IA32 programmed I/O ports, memory-mapped I/O, and external interrupts \ndelivered by a pro\u00adgrammable interrupt controller. Inevitably, this part of the H inter\u00adface is highly \nIA32-speci.c. Designing a general-purpose interface to I/O hardware is not straightforward. To allow \n.exible programming of drivers for a wide range of devices, the abstraction level must be fairly low. \nThis, however, allows interface primitives to be misused. On the other hand, a more restrictive, higher-level \ninterface would necessarily be less .exible about what kinds of devices were supported, and lots of trusted, \ndevice-speci.c code would have to move underneath the interface. Currently, we have implemented a fairly \nlow-level inter\u00adface that provides no guarantees about correct usage of I/O devices, but does enforce \nmemory safety in almost all circumstances. We may experiment with higher-level interfaces in the future. \nProgrammed I/O Many PC devices (including timers, the CMOS and real-time clock devices, the keyboard \nand mouse, network in\u00adterfaces, etc.) are controlled by reading and writing data and control information \nto speci.ed ports via special in and out instructions. These are available through H via the following \nfunctions: type Port = Word16 inB :: Port -> H Word8 outB :: Port -> Word8 -> H () ...similar functions \nfor Word16 and Word32... This interface is very .exible, but also easy to abuse: The ports for a device \nare .xed by the hardware or assigned dynamically during system start-up, depending on the device controller \ns capabilities. Currently, the H interface makes no attempt to check that the Port argument is valid \nin any way (e.g., that it corresponds to an installed device).  Device ports can be used to do very \ndisruptive things, some\u00adtimes in surprising ways. For example, writing a certain com\u00admand word to the \nkeyboard controller can reset the whole com\u00adputer! The H interface makes no attempt to check that meaning\u00adful \ncontrol arguments are passed to a given device, much less that they are constrained to desirable behaviors. \n Devices using DMA sometimes specify the address of the in\u00admemory buffer by writing it to a control \nport. A rogue kernel could use this feature to make the device overwrite arbitrary parts of memory, including \nthe Haskell heap. This is the only potential hole in H s memory safety.  Because of these problems, \nassertions about well-behavedness of H can only be valid modulo an assumption that IO device com\u00admands \nare being used properly. In principle, it might be desir\u00adable to formalize this assumption, and make \nit an explicit proof obligation within the P-Logic framework. Unfortunately, any such formalization will \nbe device-dependent and probably very compli\u00adcated. In practice, therefore, we believe it is best to \ntreat the as\u00adsumption informally and implicitly. With this understanding, we can make some assertions \nabout the independence of the port space relative to user physical memory, and to page tables, as in \nthe fol\u00adlowing examples (for the byte versions): assert All p, pa . Independent {outB p} {inB p} {setPAddr \npa} {getPAddr pa} assert All p, pm, va . va ::: validVAddr ==> Independent {outB p} {inB p} {setPage \npm va} {getPage pm va} Note that the ports do not themselves behave like store elements. For example, \noutB is not idempotent, and inB will not usually return a value just written with outB. Memory-mapped \nI/O Some devices make their control and status registers available at special physical memory locations \nthat can be read and written using ordinary load and store instructions. Video cards usually make their \nframe buffers accessible in the same way. The physical addresses for this pseudo-memory are .xed by the \ndevice or negotiated by software executed at system initialization; they can then be mapped to any convenient \nvirtual memory locations. To make access to these devices safe, memory\u00admapped locations must be kept \nabstract by the H interface, with access only by special-purpose get and set functions that perform bounds \nchecks. type MemRegion type Offset setMemB :: MemRegion -> Offset -> Word8 -> H () getMemB :: MemRegion \n-> Offset -> H Word8 validMemB:: MemRegion -> Offset -> Bool ...similar functions for Word16 and Word32... \n(The validMem functions can be used to test validity of an offset; they are primarily used to formulate \nproperties.) For example, the H interface currently includes primitives for accessing the frame buffers \nfor a basic text video mode or a VBE\u00adcompliant graphics video mode. Each of these video devices gets \nits own buffer, and perhaps additional device-speci.c information. textVideoRegion :: H (Maybe MemRegion) \ngfxVideoRegion :: H (Maybe FrameBufferInfo) data FrameBufferInfo = FBInfo { width, height, bitsPerPixel \n:: Int, frameBuffer :: MemRegion, maskSizes, fieldPositions :: (Int,Int,Int) } To perform text video \noutput, individual characters (with graphic attributes) are written using setMemW textVideoRegion. To \nper\u00adform graphic video output, individual pixels are written using setMemB (frameBuffer gfxVideoRegion). \nAgain, we have the expected independence properties with re\u00adspect to user physical memory and to page \ntables: assert All mr, off, pa . True{validMemB mr off} ==> Independent {setMemB mr off} {getMemB mr \noff} {setPAddr pa} {getPAddr pa} assert All mr, off, pm, va . va ::: ValidVAddr /\\ True{validMemB mr \noff} ==> Independent {setMemB mr off} {getMemB mr off} {setPage pm va} {getPage pm va} However, we cannot \nexpect a general property asserting inde\u00adpendence of memory-mapped and programmed I/O operations, as \nmany devices support both, with complex, intertwined semantics. Additional memory-mapped I/O regions \ncan easily be accom\u00admodated by extending the interface, and DMA buffers could also be treated in a similar \nway. The obvious drawback of this scheme, however, is that the interface must be altered for each new \ndevice; a more generic mechanism would obviously be desirable. Interrupts Most devices attached to an \nIA32 signal interrupts through the programmable interrupt controller, which associates each interrupt \nsource with an interrupt request channel (IRQ). On a PC, some IRQs are statically assigned (e.g., IRQ0 \ncorresponds to the hardware timer, IRQ1 to the keyboard, etc.); others may be dynamically assigned (e.g., \nto PCI bus devices). data IRQ = IRQ0 | IRQ1 | ... | IRQ15 deriving (Bounded, Enum)  Individual IRQs \ncan be enabled or disabled: enableIRQ, disableIRQ :: IRQ -> H () Interrupts can also be globally enabled \nor disabled, independently of the per-IRQ settings. enableInterrupts, disableInterrupts :: H () Interrupts \nare handled in two fundamentally different ways, de\u00adpending on whether they are received while the the \nprocessor is in user mode or in supervisor mode. Interrupts occurring in user mode cause a switch back \nto supervisor mode and an immediate return from execContext with a suitable I ExternalInterrupt value. \nThe kernel can then handle the exception however it sees .t. Treatment of interrupts received in supervisor \nmode is described in the next section. 3.5 Concurrency Any realistic kernel must simulate concurrency: \nkernel code, multi\u00adple user processes, and pending interrupt handlers must time-share the processor2 \nso that they appear to be running at the same time. We are exploring two basic approaches to achieving \nthis: Implicit Concurrency. The kernel uses Concurrent Haskell multi\u00adthreading primitives, as implemented \nin the GHC library and RTS. For example, each user process can be set to run in a sep\u00adarate thread. (This \nimplies that H primitive operations must be thread-safe, i.e., any mutable data structure is protected \nby a lock.) Interrupts received while in supervisor mode can also be handled in separate threads (see \nbelow). Our House implemen\u00adtation (Section 5) uses this approach.  Explicit Concurrency. The kernel \nsimulates concurrency using queues of continuations (Context values). If interrupts are al\u00adlowed in supervisor \nmode, they must be polled for explicitly by kernel code. Our Osker implementation (Section 6) implements \nthis approach.  In many Haskell implementations, Haskell code can only be paused at certain safe points \nin GHC, for example, at garbage collec\u00adtion heap-check points. Thus, interrupts occurring in supervisor \nmode (while the processor is running Haskell code) cannot be han\u00addled immediately. Instead we associate \nthese interrupts with a small handler (written in C) that just sets a .ag to indicate that a particu\u00adlar \nIRQ was signaled. In the explicit concurrency model, the kernel must poll these .ags periodically, using \na function pollInterrupts :: H [IRQ] that returns a list of pending interrupts; it can then invoke appropri\u00adate \n(Haskell) handlers if needed. In the implicit model, this polling is done by the Concurrent Haskell RTS \ncode at safe points; we ex\u00adtend H with a function installHandler :: IRQ -> H() -> H() that registers \na Haskell handler which the RTS is to run (in a separate thread) if the interrupt .ag for the given IRQ \nis set. There are pros and cons to each approach. Using implicit con\u00adcurrency allows kernel code to be \nwritten without explicit attention to timing issues; for example, there is no need to bound the execu\u00adtion \ntime of a pure sub-computation because an interrupt will even\u00adtually cause a thread switch if necessary. \nHowever, under this ap\u00adproach, many of the state-based assertions given in this section are not really \ntrue because another thread may execute in between two apparently consecutive operations. The explicit \nconcurrency ap\u00adproach doesn t have this problem. Moreover, the explicit approach 2 Of course, multiprocessor \nsystems are truly concurrent; we don t consider them in this paper. is better for kernels that need to \nmanage thread priorities (e.g., to run interrupt handlers .rst), because the current GHC implementa\u00adtion \ndoes not permit control over the thread scheduling algorithm.  4. A Simple Executive for User Programs \nThis section shows how the H monad interface can be used to con\u00adstruct a simple demand-paging kernel \nfor executing IA32 user bi\u00adnaries. Binaries are assumed to have a conventional memory layout with code, \ndata, heap, and stack regions. To keep the presentation brief, we allow binaries to use just two system \ncalls: exit and brk. Hence, they cannot do I/O (except to return a result value at exit); to illustrate \nthe use of interrupts and I/O operations, we use an in\u00adterval timer to track the binary s execution time \nand abort it after a speci.ed number of milliseconds. As a further simpli.cation, the kernel can run \nonly one binary at a time. More realistic and elabo\u00adrate kernels are described in Sections 5 and 6. We \ndescribe both static and dynamic characteristics of an exe\u00adcuting binary using a UProc (user process) \nrecord. data UProc = UProc { entry :: VAddr, codeRange, dataRange :: VRange, startBss, brk :: VAddr, \nstackRange :: VRange, codeBytes, dataBytes :: [Word8], pmap :: PageMap, ticks :: Int } type VRange = \n(VAddr, VAddr) We assume that the kernel is given a UProc with all .elds except pmap and ticks already \n.lled in with a static description of the binary. The .eld codeRange delimits the program s code region; \ndataRange does the same for the data region. The contents of these regions are given by codeBytes and \ndataBytes; for simplicity we model these as lists although a real implementation would probably use unboxed \narrays. The entry .eld holds the initial instruction pointer. The stack grows down from the end of stackRange, \nthe start of which provides a .xed bottom limit. The bss/heap region begins at startBss and grows up \nto brk. All these VAddrs must be valid in the sense of Section 3.2. The brk limit can be arbitrarily \naltered by a system call (see below) as long as it remains between startBss and the start of stackRange. \nThere are no restrictions on the nature of user code; it can (try to) do anything at all! Of course, \ndirect attempts to perform privi\u00adleged or illegal operations, such as writing to I/O ports or dividing \nby zero, will cause a fault that immediately returns control to the kernel. User code can request a kernel \nservice by making a system call. To do so, it places the call number (0 for exit, 1 for brk)in register \neax and the argument in ebx, and issues an INT 0x80 in\u00adstruction, which causes a software interrupt. \nThis protocol for mak\u00ading system calls is normally encapsulated in library procedures. The entry point \nfor the executive is shown in Figure 3. The pa\u00adrameters specify that the binary represented by uproc \nis to be run for a maximum of msecs milliseconds. The executive allocates a fresh page map (initially \nempty), and constructs an appropriate ini\u00adtial Context value. After the timer has been initialized (discussed \nfurther below), the UProc is updated to record the page map and the number of timer ticks to be allowed \nbefore terminating the pro\u00adgram, and control passes to the exec loop, which is the heart of the executive \n(see Figure 4). The loop is parameterized by the cur\u00adrent uproc and context. At each iteration, control \nis passed to the user code by execContext, which returns only when that code s execution is interrupted \nin some way. This may be because of a system call, page fault, timer interrupt, or unexpected fault of \nsome runUProc :: UProc -> Int -> H String runUProc uproc msecs = do Just pmap <-allocPageMap initTimer \n10 --interrupt every 10msec exec uproc{pmap=pmap,ticks=msecs div 10} context where context = Context \n{eip=entry uproc, esp=snd (stackRange uproc)+1, edi=0,esi=0,ebp=0,ebx=0, edx=0,ecx=0,eax=0,eflags=0} \nFigure 3. runUProc provides the entry point to our executive. exec :: UProc -> Context -> H String exec \nuproc context = do (interrupt,context ) <\u00adexecContext (pmap uproc) context case interrupt of I_ProgrammedException(0x80) \n-> ---system call --\u00adlet callnum = eax context arg = ebx context in case callnum of 0 -> ---exit --\u00ad \nreturn(\"Successful completion \" ++ \"with result \" ++ show arg) 1 -> ---brk --\u00ad...details omitted... _ \n-> exec uproc context {eax=(-1)} I_PageFault _ faultAddr -> ---page fault --\u00addo fixOK <-fixPage uproc \nfaultAddr if fixOK then exec uproc context else return (\"Fatal page fault at \" ++showHex faultAddr \"\") \nI_ExternalInterrupt 0x00 -> ---timer interrupt --\u00addo let ticks = ticks uproc -1 uproc = uproc{ticks=ticks \n} if ticks > 0 then exec uproc context else return (\"Time exhausted\") _-> return (\"Unexpected Fault or \nInterrupt: \" ++ show interrupt) Figure 4. The heart of a simple demand-paging executive. kind. After \nthe interrupt is processed, either exec is called tail\u00adrecursively to re-enter user code at the point \nwhere the interrupt oc\u00adcurred, or execution terminates, returning a suitable text message. System calls \nare handled by dispatching on the call number. The only non-trivial call is brk, which alters the brk \n.eld in the uproc; we omit the details here. If an invalid system call number is requested, the error \ncode -1 is returned (by placing it in eax). fixPage :: UProc -> VAddr -> H Bool fixPage uproc vaddr | \ninRange (codeRange uproc) vaddr = do setupPage uproc vbase (drop offset (codeBytes uproc)) False return \nTrue where vbase = pageFloor vaddr offset = fromEnum (vbase -fst (codeRange uproc)) fixPage uproc vaddr \n| inRange (dataRange uproc) vaddr = ...similar... fixPage uproc vaddr | vaddr >= startBss uproc &#38;&#38; \nvaddr < brk uproc || inRange (stackRange uproc) vaddr = do setupPage uproc vbase (repeat 0) True return \nTrue where vbase = pageFloor vaddr fixPage uproc vaddr | otherwise = return False setupPage:: UProc -> \nVAddr -> [Word8] -> Bool ->H() setupPage uproc vbase src writable = do page <-newPhysPage let pi = PageInfo \n{physPage=page, writable=writable, dirty=False, accessed=False} setPage (pmap uproc) vbase (Just pi) \nzipWithM_ (curry setPAddr page) [0..pageSize-1] src Figure 5. Auxiliary functions fixPage and setupPage \nWhen the timer interrupts, the kernel executes a miniature han\u00addler which decrements the number of allowed \nticks remaining for the user code, and terminates execution if the tick count is zero. Page faults are \ndispatched to auxiliary function fixPage (see Figure 5), which returns True iff the missing page has \nbeen suc\u00adcessfully loaded. Note that no pages are mapped at all when ex\u00adecution begins; the system relies \non page faults to force them in when needed. In particular, the very .rst call to execContext will always \ncause a fault on the page containing the initial eip address. fixPage analyzes the faulting virtual address \nand attempts to set up the missing page appropriately according to the region it belongs to. pageFloor \nreturns the nearest aligned virtual address below its argument. The contents of code pages are obtained \nfrom codeBytes and they are marked read-only; similarly, data pages are obtained from dataBytes and are \nmarked writable. Stack and heap pages are zeroed. If the fault address is outside any region, fixPage \ndoes nothing and returns False. The auxiliary routine setupPage is used to obtain a fresh physical page, \ninstall it in the page map, and load its contents with the requested access rights. Finally, if execContext \nreturns any other kind of interrupt, user code execution is terminated and an appropriate error message \nis returned. Before the user code runs, it is important to initialize the pro\u00adgrammable interrupt timer; \notherwise the kernel may never get con\u00adtrol back. This is done by the call to initTimer, which writes \nan appropriate value to the timer s control port and enables its inter\u00adrupt line. initTimer :: Int -> \nH () initTimer msPerTick = do --set timer interrupt frequency... outB timerPort (ticks .&#38;. 0xff) \n--... in two steps: outB timerPort (ticks shiftR 8) enableIRQ timerIRQ where ticks = fromIntegral (1193190 \n* msPerTick div 1000) timerIRQ = IRQ0 timerPort = 0x40 :: Port 5. House: A Working Demonstration System \nHaving a safe, high-level language like Haskell at our disposal, it is natural to explore the possibility \nof using it to build an entire sys\u00adtem, including kernel, system programs, and applications. Building \non the work of the hOp project and some other existing projects, we have constructed a prototype for \nsuch a system, which we call House. The system includes the following features, all written in Haskell \nand built on H: Device drivers, including interrupt handlers, for some useful PC hardware devices: keyboard, \nmouse, graphics and a network card. (The keyboard and text mode video drivers were provided by hOp.) \n A simple window system, including some demo applications. (This is the Gadgets system [20], originally \nimplemented in Component Gofer, and ported by us to Concurrent Haskell.)  A network protocol stack with \nbasic support for the following protocols: Ethernet, ARP, IPv4, ICMP, UDP and TFTP.  A command shell \nwindow, where separate a.out binaries can be loaded via TFTP or by GRUB and run as protected user\u00adspace \nprocesses.  Support for multiple simultaneous user processes and interrupt handling, using Concurrent \nHaskell extensions (threads, chan\u00adnels, MVars)  The system is freely available for download [12]. Networking \nThe largest House component we have developed ourselves is a simple network protocol stack. We use a \nuniform representation of interfaces at each network protocol layer, with parsing/unparsing combinators \nto convert between uninterpreted and structured representations of packets. This may turn out to be a \nbad idea from a performance perspective; we don t yet have any performance data. We have implemented \na driver for NE2000 compatible network cards, because this is the card model supported by our development \nemulator, QEMU [1]. (At present, we don t have a physical card to drive.) The network driver is implemented \nas a single thread that handles the communication with both the network device and the client. We install \na simple interrupt handler that just sends a message to the handler thread when the card has .nished \nreceiving an incoming packet or transmitting an outgoing packet. The overall structure of our network \nprotocol stack implemen\u00adtation is fairly conventional. We have aimed to make it easy to add support for \nmore protocols (e.g., IPv6 and TCP) and link layers (e.g., PPP). Graphics and the Gadgets window system \nThe Gadgets imple\u00admentation [20] relies on a few simple graphics primitives that we have implemented \nin Haskell by writing to the linear frame buffer interface through the VBE [26] interface (see Section \n3.4). This solution is simple, portable and ef.cient enough for demonstration purposes. In the future, \nwe might, of course, want to take advantage of hardware accelerated graphics routines. 6. Towards Osker: \nModeling a Separation Kernel We are also using the H interface as a basis for the implementa\u00adtion of \na kernel called Osker (the Oregon Separation Kernel ) that is designed to support concurrent execution \nof multiple user pro\u00adcesses with controlled interactions between them. Unlike House, the implementation \nof Osker adopts the explicit approach to con\u00adcurrency that was described in Section 3.5. Speci.cally, \nthe ker\u00adnel maintains Haskell data structures that describe the set of active processes in the system \nat any given time, and it uses these to make scheduling decisions between the available threads. Osker \nalso sup\u00adports IPC (interprocess communication), which provides a mecha\u00adnism for synchronous message \npassing between threads; its design is closely based on the well-known L4 microkernel [25]. Our long-term \ngoal is to establish strong guarantees of separa\u00adtion for Osker by proving, formally, that concurrent \nprocesses run\u00adning on the same system can only interfere with one another to the degree permitted by \nan explicit system security policy. This is work in progress, but it seems clear that such a proof will \ndepend on the independence properties of H described in Section 3. In the hopes of simplifying the veri.cation \neffort, we are lever\u00adaging compile-time type checking in Haskell to ensure that key system invariants \nare maintained. We are also using Haskell type classes and monad transformers to support modular construction \nof the kernel and, we hope, to facilitate a correspondingly modu\u00adlar proof of separation. The speci.c \ntechniques that we are using here are similar to those previously applied in the construction of modular \ninterpreters [15, 19]. The remainder of this section describes some of these aspects of our current prototype \nin more detail and show hows the H interface is used in this context. Domains and Threads In the terminology \nof Osker, a system is organized as a collection of domains, each of which has a distinct user-mode address \nspace that is shared by multiple threads. type System = [Domain] data Domain = Domain { uproc :: UProc, \nrunnable :: [Thread Runnable], blocked :: [Thread Blocked] } The uproc .eld holds information about the \naddress space and user code, just as in Section 4. The remaining .elds store informa\u00adtion about threads \nbelonging to the domain: runnable is a queue of threads waiting to execute (maintained in priority order), \nand blocked is a list of threads waiting to send or receive a message. Every thread has an identi.er, \nan associated scheduling priority, and details re.ecting its current state: data Thread s = Thread { \nthreadId :: ThreadId, priority :: Int, state ::s} The information that we need for a thread that is runnable \n(i.e., awaiting execution in a scheduling queue) is different from the details that are needed for a \nthread that is blocked (i.e., waiting to transfer a message). We re.ect this by making the state type \na parameter s of Thread, and by instantiating it, as appropriate, to one of the following types: data \nRunning = Running data Runnable = Runnable { ctxt :: Context } data Blocked = Sending ThreadId Context \n| Receiving ThreadId Context A running thread has no state-speci.c data, so the Running type does not \ncarry any extra information. For a runnable or blocked thread, the kernel must record the user-space \ncontinuation from the thread s last execution, represented by a Context. Blocked also carries information \nabout the pending message transfer, which the kernel uses to detect when a thread should be unblocked. \nParameterizing the Thread types with a state has many useful consequences. For example, with this approach, \nthe type system will prevent us from inadvertently scheduling a Blocked thread or from placing a Runnable \nthread in the blocked list of a domain. Tracking Effects At runtime, the kernel and the hardware main\u00adtain \nseveral state components, including, for example, a list of all the current domains. Some parts of the \nsystem, however, do not re\u00adquire access to all of these components. For example, one system call might \nonly require access to the virtual memory operations of H, while another requires access to the state \nof the running domain, but nothing else. If we can capture and limit the impact of such dependencies \nautomatically using types, then we can also hope to limit the number of side-effects we must reason about \nin corre\u00adsponding sections of our proof. In general terms, for example, the code for handling each of \nthe system calls in Osker is described by a function of type: Thread Running -> Context -> Handler () \nThe two parameters describe the thread that made the system call and the associated context. The Handler \ntype is a monad that is constructed on top of the H interface, using a state monad trans\u00adformer called \nStateT [15, 19]. type Kernel = StateT System H type Handler = StateT Domain Kernel The resulting monad \nincludes state components for the domain of the current thread and for the list of active domains in \nthe system. For completeness, the following code fragments show some details of the implementation of \nStateT, and also a generic StateMonad type class that encapsulates the notion of a stateful monad. newtype \nStateT s m a = StateT (s -> m (a, s)) instance Monad m => Monad (StateT s m) where ... class StateMonad \ns m where get ::ms set ::s-> m() update ::(s -> s)-> m () instance (Monad m) => StateMonad s (StateT \ns m) where ... Suppose now that we add a simple system call, yield, which the calling thread can use \nto yield the remainder of its timeslice. The implementation of yield does not modify the list of active \ndomains or use operations from the H interface; it only modi.es the data structure of the running domain. \nTo capture this, we de.ne the handler for yield as a function of the following type, without explicitly \nmentioning the Handler monad: (StateMonad Domain m) => Thread Running -> Context -> m () This type uses \na predicate (StateMonad Domain m) to specify a constraint on the choice of the monad m (speci.cally, \nthat it must have a state component of type Domain). We can also see that the implementation of yield \ndoes not require any features from the H interface because there is no mention of H in its type. As a \nsecond example, consider the implementation of a spawn system call that takes a start address and an \nidenti.er for a new thread in the current domain as parameters. In this case, the handler has type: (HMonad \nm, StateMonad Domain m) => VAddr -> ThreadId -> Thread Running -> Context -> m () The implementation \nof spawn requires operations from the H inter\u00adface to allocate thread-local space for the new thread. \nThis is re\u00ad.ected in the type by the use of the HMonad class, which is a wrap\u00adper that provides access \nto all of the operations of H and allows them to be lifted implicitly and automatically through arbitrary \nlayers of monad transformers. class Monad h => HMonad h where allocPhysPage :: h (Maybe PhysPage) getPAddr \n:: PAddr -> h Word8 setPAddr :: PAddr -> Word8 -> h () ... instance HMonad H where ... instance HMonad \nm => HMonad (StateT s m) where ... Note that the declaration of the HMonad class includes a signature \nfor each of the operations in the H interface, but replaces each use of the H type constructor with the \ntype variable h. The two instance declarations describe how these functions are implemented for H (by \nbinding the overloaded names to the non-overloaded primitives introduced earlier) and for transformed \nversions of the monad like Kernel and Handler (by applying suitable liftings). Although we have omitted \nsome details, these examples illus\u00adtrate the use of type classes and monads to provide a form of effects \nanalysis that can capture dependencies explicitly in inferred types. Scheduling and Exception Handling \nOsker implements round\u00adrobin scheduling for domains and priority-based scheduling for threads. The domain \nscheduler selects a domain to run from the list of active domains and passes it to the thread scheduler, \ncalled tScheduler, which selects the thread to be run. tScheduler :: (HMonad m, StateMonad System m) \n=> Domain -> m () tScheduler dom = case runnable dom of [] -> return () (t:ts) -> do dom <\u00ad execThread \n(uproc dom) t runStateTs dom{runnable=ts} update (insertDomain dom ) If the queue is empty, the domain \nis .nished or deadlocked, and is not rescheduled. Otherwise, the thread at the head of the queue is selected \nand executed using execThread. The runStateTs operator used here is part of the library that de.nes StateT: \nrunStateTs :: Monad m => StateT sm a-> s-> ms runStateTs (StateT c) s = do (a,s ) <-c s return s In \nthis speci.c case, runStateTs is used to embed an execThread computation from the Handler monad into \na computation in the Kernel monad by passing in an additional Domain parameter. The thread scheduler \nuses the update call to insert the modi.ed version of the current domain back into the list of active \ndomains. At this point, tScheduler returns to the domain scheduler, which will loop back to execute a \nthread from the next active domain. The execThread function replaces the execution loop, exec, of the \nkernel in Section 4. Notice how the type of execThread ensures that we can only execute Runnable threads. \nexecThread :: (HMonad m, StateMonad Domain m, StateMonad System m) => UProc -> Thread Runnable -> m () \nexecThread u t = do (intr, ctxt ) <\u00adexecContext (pmap u) (ctxt (state t)) handle t{state=Running} ctxt \nintr This de.nition uses the execContext function from the H inter\u00adface to run the continuation stored \nin the ctxt .eld in the state of thread t. The result is an Interrupt value and a modi.ed Context. To \nservice the interrupt, we change the thread state to Running and call the function handle. This works \nin a similar way to the case expression in the de.nition of exec (Figure 4) and passes control to our \nsystem call handlers where necessary.  7. Implementing the Hardware Monad We have implemented the H \ninterface directly on top of real IA32 hardware. The implementation consists of about .fteen small mod\u00adules, \namounting to about 1200 lines of Haskell, supported by about 250 lines of C code (with a few lines of \nembedded assembler) ac\u00adcessed via the Foreign Function Interface (FFI). An additional 500 lines of C \nand 150 lines of assembler were added to version 6.2 of the standard Glasgow Haskell Compiler (GHC) runtime \nsystem (RTS) to support booting on a bare machine and to set up paging. Our current implementation can \nsafely be used with Concurrent Haskell threads, which are speci.c to GHC; in particular, we use QSems \nto protect critical sections. Except for this, our Haskell code could probably be ported to a different, \nFFI-compliant Haskell 98 implementation without too much dif.culty. The lower levels of our implementation \nare based heavily on the hOp Haskell microkernel [4]. hOp can be viewed as a port of the GHC RTS to a \nbare IA32-based PC. The standard RTS start-up code is extended to initialize the bare machine. The remainder \nof the RTS is scrubbed to remove any dependencies on an underlying operating system. The standard C library \nis replaced by a minimal version that suf.ces to support compiled Haskell code and output to the text-mode \ndisplay. There is a small library of device drivers written in Haskell, using the IO monad and FFI facilities \nto access the hardware (this is straightforward since the entire system runs in privileged mode). The \ndrivers make heavy use of GHC s Con\u00adcurrent Haskell thread mechanism for intra-kernel communication and \nfor interrupt handling. A simple Haskell main program exer\u00adcises the drivers. All the Haskell code, including \nrelevant parts of the Haskell standard library, is compiled and linked by GHC in the ordinary way. The \nresulting microkernel is then converted to a boot image that can be loaded and started by the GRUB boot \nloader [11]. To implement H, we have modi.ed and extended the hOp work by adding support for virtual \nmemory and user-mode process ex\u00adecution in a protected address space. We have also implemented a simpler \nand more .exible approach to interrupt handling, reduced the dependence of the system on Concurrent Haskell \nthreads, and added support for memory-mapped I/O (e.g., for graphics/video). The remainder of this section \ngives some details of these features. Physical Memory Figure 6 shows a typical physical memory layout, \nassuming (for simplicity) a total installed memory size of 64MB. The C stack and heap are used by the \ncode in the GHC RTS, our initialization code, and in the foreign functions called as part of our H implementation. \nThe kernel (main program) executable image contains all compiled Haskell code, the GHC RTS, and our C \nand assembler extensions. (Although 7MB is set 0 640KB 1MB 8MB 8MB+64KB 12MB 32MB 64MB 0xf0000000 0xf02fffff \n4GB C Stack Video RAM and BIOS Kernel + GHC RTS Kernel page tables C heap Haskell Heap User process pdirs/ptables \nand physical pages  Figure 6. Physical Memory Layout (not to scale!) aside for this image, our current \nimplementations use much less; for example, the complete House system described in Section 5 occupies \nless than 3MB.) The Haskell heap is used to store Haskell data structures in the usual way; it is managed \nby the standard GHC garbage collector. Kernel page tables describe the page mapping used by kernel code; \nthis is incorporated as part of every user-mode page map too (see below). User page directories, page \ntables, and physical pages holding code and data are allocated out of a single large memory pool. In \naddition to the regions we allocate, certain regions of phys\u00adical address space are associated with speci.c \ndevices to support memory-mapped I/O. The low-memory region at 640KB contains a text video buffer and \nBIOS RAM on all PC s. The graphics frame buffer in high memory is shown as an example: a typical system \nwill have one or more such buffers at device-speci.c addresses. Recall that both buffers are exported \nvia the H interface. Virtual Memory Page Maps The IA32 supports a fairly straight\u00adforward two-level paging \nscheme. (It also has a separate, mostly or\u00adthogonal memory protection scheme based on segments; like \nmost modern operating systems, we ignore segments almost entirely.) A page table contains entries mapping \nindividual virtual pages to physical pages. A page directory maps contiguous ranges of virtual pages \nto page tables. Crucially, both page tables and (especially) page directories can be sparsely populated: \na zero entry means the corresponding virtual addresses are unmapped. The H interface s PageMap corresponds \nto a page directory and its subsidiary page tables. Virtual-to-physical translation is performed using \nthe cur\u00adrent directory, which is pointed to by processor control register CR3. Page directories for user \nprocesses are installed into CR3 by the execContext routine. All the virtual address spaces have the \nsame general layout. As\u00adsuming the 64MB memory size shown in Figure 6, the .rst 64MB of virtual addresses \nare mapped directly to identical physical ad\u00addresses, and marked as accessible only to supervisor mode; \ni.e., user-mode processes cannot see them. Any memory-mapped I/O regions living at high physical memory \naddresses (e.g. the graphics frame buffer) are mapped to virtual addresses immediately above 64MB, again \nmarked for supervisor-only access. Virtual addresses starting at 256MB (0x100000000) are mapped for access \nby user processes according to calls made to setPageMap. This scheme permits kernel code to access all \nphysical memory (and any memory\u00admapped I/O regions) regardless of which page directory is current, so \nthere is no need to switch back to a special page map when re\u00adturning from user to supervisor mode. It \nis ef.cient to implement because page tables can be shared between multiple page directo\u00adries; in this \ncase, we arrange for every page directory to map the supervisor-accessible addresses to the same set \nof page tables. Function allocPageMap simply grabs a page from the user\u00adprocess page pool, zeroes it, \nand returns a pointer to it. Function setPageMap is a bit more complicated because it must take ac\u00adcount \nof the two-level page map structure. If the virtual address being mapped lives in a range that is already \nmapped to a page ta\u00adble, then the corresponding entry in that table is written. If there is no appropriate \npage table, a fresh page must be taken from the pool, initialized, and entered in the page directory \n.rst. User page tables are never shared, as this would expose the two-level structure above the H interface. \nChanges to a page map will normally become visible the next time the page directory is set into CR3. \nHowever, if the target page directory of setPageMap is already installed in CR3, the function issues \na invlpg instruction to invalidate (just) the changed mapping in the TLB. The H interface deliberately \nlacks functions for freeing Page-Maps; instead, we use GHC s weak pointers to detect when a Page-Map \nis no longer referenced by the kernel. The page directory and all its subsidiary page tables can then \nbe returned to the pool. (However, care must be taken not to free a page directory that is still installed \nin CR3!) Individual page tables are also reclaimed when they no longer contain any mappings. Similar \ntechniques are used to allocate PhysPages from the user-process page pool, and to free them automatically \nwhen they are no longer referenced. Executing Code in User Space Each call to execContext causes a transfer \nfrom supervisor to user mode and (eventually) back again. Implementing these mode transfers is an arcane \naffair; we give only a high-level description here. To transfer control to user mode, execContext begins \nby copying the .elds of the Context record parameter into a C-level context structure (whose layout is \ndictated by the hardware) and setting CR3 to point to the speci.ed page di\u00adrectory (if different from \nthe current one). It then saves its stack pointer in memory, sets esp to point to the context structure, \nand executes a return-from-interrupt (rti) instruction, which loads the user process state from the context \nstructure and jumps to the eip recorded in that context. Control returns to the kernel when the user \nprocess is interrupted by a hardware fault, an external hardware in\u00adterrupt, or a software exception \ninstruction; all these cause the hard\u00adware to dump the current process state into the context structure \nand transfer control to a C exception handler. This handler copies the context structure to a new Haskell \nContext record, restores the saved stack pointer from memory, and returns from execContext. I/O Implementation \nBecause most of the I/O facilities in the H interface are relatively low-level, their implementation \nis quite simple. For example, the various functions to read and write I/O ports are implemented as single \nIA32 instructions. As noted in Section 3.5, special processing is needed if an inter\u00adrupt occurs while \nthe processor is in supervisor mode. If install-Handler has been used to specify a (Haskell) handler \nfor the rele\u00advant IRQ, we must arrange for this handler to be run as soon as pos\u00adsible. To achieve this, \nwe make use of an existing GHC RTS mech\u00adanism for delivering signals. The RTS maintains a queue of signal \nhandlers to be activated (in fresh Concurrent Haskell threads) the next time that the garbage collector \ngains control because a heap limit check has failed. Our C handler simply inserts the registered Haskell \ninterrupt handler into this queue. If no Haskell handler is registered, the C handler just sets an IRQ-speci.c \n.ag that can be read by pollInterrupts. Memory-mapped I/O regions and DMA buffer regions must be allocated \nas part of the system initialization process. For example, our current implementation uses information \nobtained from the BIOS via the GRUB boot loader to determine the physical memory address frame buffer, \nwhich it then remaps to a convenient virtual address and exposes (along with other graphics device information) \nthrough the H interface.  8. Conclusion and Future Work We have successfully designed and implemented \na monadic inter\u00adface to the low-level hardware features of the IA32 architecture, and used it to build \npreliminary versions of a new, all-Haskell op\u00aderating system (House) and also of an L4-compatible microkernel \n(Osker). This paper has focused on the challenges of building a real implementation of the interface. \nAs another part of our ongo\u00ading research, we are also building formal models of the interface. These \ntwo threads of work will eventually come together as we build a validated Osker system. But even now, \nat an early stage in our project, they are already having signi.cant in.uence on each another. The long \nterm goal of formal validation has encouraged us to think carefully about the interfaces that we build. \nThis had led us to consider, not just the types and the operations that should be provided, but also \nthe properties that we expect or require them to satisfy. We have used P-Logic assertions of these properties \nto give a rich and precise de.nition of the interface. Although we believe our current set of assertions \nto be both valid and useful, it is likely to be expanded and re.ned as we con\u00adtinue work on both sides \nof the H interface. Completing the formal model of H will allow us to verify the consistency of assertions \nand will suggest new ones. As we continue to develop Osker code, we will also be building proofs of key \nproperties such as separa\u00adtion; this process will undoubtedly lead to further re.nement of H s properties \nas well. Our experience using Haskell as a systems implementation lan\u00adguage has been largely positive \nso far. We have found its type sys\u00adtem and support for monads to be especially useful. The speed of compiled \ncode has proved adequate for the purposes of the House system. However, key issues about performance \nremain to be an\u00adswered. In particular, we have not yet determined whether devices requiring high bandwidth \nand low latency (e.g., network cards) can be adequately serviced in a Haskell runtime environment particularly \nin the presence of garbage collection. Haskell s type-based separation between pure and effectful com\u00adputations \nis useful for documenting function interfaces, and we ex\u00adpect it to be helpful in simplifying proofs. \nOtherwise, there is no particular reason why this work could not be done in a different functional language. \nWe have made no essential use of laziness in our code, so an eager language such as ML might seem a more \nnatural choice. On the other hand, laziness does not appear to be costing us much in terms of time or \nspace performance. A more compelling advantage of ML, especially for the speci.cation work reported in \nthis paper, may be that it supports proper module inter\u00adfaces in the form of signatures. Because our \nultimate goal is high-assurance systems software, we need to be able to validate every component of our \nsystem, including the compiler and runtime system. We currently rely on the GHC compiler and RTS, which \nare large and complex, making such validation challenging. Because H (if used without implicit concurrency) \nmakes no essential use of GHC-speci.c features, we expect to be able to port to a much simpler RTS (e.g., \none providing just garbage collection). We are actively investigating mechanisms for building high-assurance \ncollectors. Acknowledgments S\u00b4ebastien Carlier and Jeremy Bobbio implemented hOp, which was one of our \nmain inspirations. The code for Gadgets is due to Rob Noble. Iavor Diatchki wrote the NE2000 Ethernet \nand mouse drivers, and made many other helpful contributions. Other members of the Programatica team \nand the anonymous reviewers made useful suggestions about the presentation of this paper. References \n[1] F. Bellard. QEMU. http://fabrice.bellard.free.fr/qemu/. [2] E. Biagioni, R. Harper, and P. Lee. A \nNetwork Protocol Stack in Standard ML. Higher Order Symbol. Comput., 14(4):309 356, 2001. [3] L. Cardelli, \nJ. Donahue, L. Glassman, M. Jordan, B. Kalsow, and G. Nelson. Modula-3: Language de.nition. http://www. \nresearch.compaq.com/SRC/m3defn/html/complete.html. [4] S. Carlier and J. Bobbio. hOp. http://www.macs.hw.ac.uk/ \n~sebc/hOp/, 2004. [5] A. Cheadle, T. Field, S. Marlow, S. Peyton Jones, and L. While. Exploring the Barrier \nto Entry: Incremental Generational Garbage Collection for Haskell. In Int. Symp. on Memory Management, \npages 163 174, 2004. [6] J. Cupitt. A brief walk thourgh KAOS. Techical Report 58, Computing Laboratory, \nUniv. of Kent at Canterbury, February 1989. [7] Cyclone. http://www.research.att.com/projects/cyclone/. \n[8] K. Fraser, S. Hand, R. Neugebauer, I. Pratt, A. War.eld, and M. Williamson. Safe hardware access \nwith the Xen virtual machine monitor. In Proc. OASIS ASPLOS Workshop, 2004. [9] G. Fu. Design and implementation \nof an operating system in Standard ML. Master s thesis, University of Hawaii, August 1999. [10] Glasgow \nhaskell compiler. http://www.haskell.org/ghc. [11] Grub. http://www.gnu.org/software/grub/. [12] T. Hallgren. \nThe House web page. http://www.cse.ogi.edu/ ~hallgren/House/, 2004. [13] Intel Corp. IA-32 Intel Architecture \nSoftware Developer s Manual Volume 3: System Programming Guide, 2004. [14] T. Jim, G. Morrisett, D. Grossman, \nM. Hicks, J. Cheney, and Y. Wang. Cyclone: A Safe Dialect of C. In USENIX Annual Technical Conference, \npages 275 288, June 2002. [15] M. P. Jones. Functional programming with overloading and higher\u00adorder \npolymorphism. In Advanced Functional Programming, 1st Int. Spring School on Advanced Functional Programming \nTechniques-Tutorial Text, pages 97 136, London, UK, 1995. Springer-Verlag. [16] M. P. Jones. Bare Metal: \nA Programatica model of hardware. In High Con.dence Software and Systems Conference, Baltimore, MD, March \n2005. [17] K. Karlsson. Nebula: A functional operating system. Technical report, Programing Methodology \nGroup, University of G\u00a8oteborg and Chalmers University of Technology, 1981. [18] R. B. Kieburtz. P-logic: \nProperty veri.cation for Haskell programs. ftp://ftp.cse.ogi.edu/pub/pacsoft/papers/Plogic.pdf, August \n2002. [19] S. Liang, P. Hudak, and M. Jones. Monad transformers and modular interpreters. In POPL 95: \nProc. 22nd ACM Symp. on Principles of programming languages, pages 333 343, 1995. [20] R. Noble. Lazy \nFunctional Components for Graphical User Interface. PhD thesis, University of York, November 1995. [21] \nThe OSKit Project. http://www.cs.utah.edu/flux/oskit/. [22] The Programatica Project home page. www.cse.ogi.edu/PacSoft/ \nprojects/programatica/, 2002. [23] The SPIN project. http://www.cs.washington.edu/research/ projects/spin/www/, \n1997. [24] W. Stoye. Message-based functional operating systems. Science of Computer Programming, 6:291 \n311, 1986. [25] L. Team. L4 eXperimental Kernel Reference Manual, January 2005. [26] Video Electronics \nStandards Association. VESA BIOS EXTENSION (VBE) Core Functions Standard, Version: 3.0, September 1998. \nwww.vesa.org. [27] M. Wallace. Functional Programming and Embedded Systems. PhD thesis, Dept of Computer \nScience, Univ. of York, UK, January 1995. [28] M. Wallace and C. Runciman. Lambdas in the Liftshaft \nFunctional Programming and an Embedded Architecture. In FPCA 95: Proc. 7th Int. Conf. on Functional Programming \nLanguages and Computer Architecture, pages 249 258, 1995.  \n\t\t\t", "proc_id": "1086365", "abstract": "We describe a monadic interface to low-level hardware features that is a suitable basis for building operating systems in Haskell. The interface includes primitives for controlling memory management hardware, user-mode process execution, and low-level device I/O. The interface enforces memory safety in nearly all circumstances. Its behavior is specified in part by formal assertions written in a programming logic called P-Logic. The interface has been implemented on bare IA32 hardware using the Glasgow Haskell Compiler (GHC) runtime system. We show how a variety of simple O/S kernels can be constructed on top of the interface, including a simple separation kernel and a demonstration system in which the kernel, window system, and all device drivers are written in Haskell.", "authors": [{"name": "Thomas Hallgren", "author_profile_id": "81100269494", "affiliation": "Oregon Health & Science University", "person_id": "P280750", "email_address": "", "orcid_id": ""}, {"name": "Mark P. Jones", "author_profile_id": "81100557950", "affiliation": "Oregon Health & Science University", "person_id": "PP31047626", "email_address": "", "orcid_id": ""}, {"name": "Rebekah Leslie", "author_profile_id": "81100575103", "affiliation": "Portland State University", "person_id": "PP14198850", "email_address": "", "orcid_id": ""}, {"name": "Andrew Tolmach", "author_profile_id": "81100247872", "affiliation": "Portland State University", "person_id": "P18423", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086380", "year": "2005", "article_id": "1086380", "conference": "ICFP", "title": "A principled approach to operating system construction in Haskell", "url": "http://dl.acm.org/citation.cfm?id=1086380"}