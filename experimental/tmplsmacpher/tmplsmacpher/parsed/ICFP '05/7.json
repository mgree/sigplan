{"article_publication_date": "09-12-2005", "fulltext": "\n A Step-Indexed Model of Substructural State Amal Ahmed Matthew Fluet * Greg Morrisett * Harvard University \nCornell University Harvard University amal@eecs.harvard.edu .uet@cs.cornell.edu greg@eecs.harvard.edu \n Abstract The concept of a unique object arises in many emerging program\u00adming languages such as Clean, \nCQual, Cyclone, TAL, and Vault. In each of these systems, unique objects make it possible to perform \noperations that would otherwise be prohibited (e.g., deallocating an object) or to ensure that some obligation \nwill be met (e.g., an opened .le will be closed). However, different languages provide different interpretations \nof uniqueness and have different rules regarding how unique objects interact with the rest of the language. \nOur goal is to establish a common model that supports each of these languages, by allowing us to encode \nand study the interac\u00adtions of the different forms of uniqueness. The model we provide is based on a \nsubstructural variant of the polymorphic .-calculus, augmented with four kinds of mutable references: \nunrestricted, rel\u00adevant, af.ne, and linear. The language has a natural operational semantics that supports \ndeallocation of references, strong (type\u00advarying) updates, and storage of unique objects in shared refer\u00adences. \nWe establish the strong soundness of the type system by constructing a novel, semantic interpretation \nof the types. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and \nTheory Semantics; D.3.3 [Pro\u00adgramming Language]: Language Constructs and Features General Terms Languages \nKeywords substructural type system, mutable references, step\u00adindexed model 1. Introduction Consider the \nfollowing imperative code fragment, written with SML syntax: 1. fun f(r1:int ref, r2:int ref):int = \n2. (r1 := true ;  3. !r2+42) At line 1, we assume ref cells r1 and r2 whose contents are integers. At \nline 2, we update the .rst cell with a boolean. Then, * This material is based upon work supported by \nthe Air Force Of.ce of Scienti.c Research under Award No. F49620-03-1-0156 and Award No. F49620-01-1-0298 \nand by the Of.ce of Naval Research under Award No. N00014-01-1-0968. Any opinions, .ndings, and conclusions \nor recommen\u00addations expressed in this publication are those of the author and do not necessarily re.ect \nthe views of these organizations or the U.S. Government. Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. ICFP 05 September 26 28, 2005, Tallinn, Estonia. \nCopyright c . 2005 ACM 1-59593-064-7/05/0009. . . $5.00. at line 3, we read the second cell, using the \ncontents in a context expecting an integer. If the function is called with actual arguments that are \ndifferent ref cells, then there is nothing in the function that will cause a run-time type error.1 Yet, \nif the same ref cell is passed for each formal argument, then the update on line 2 will change the contents \nof both r1 and r2, causing a run-time type error to occur at line 3. SML (and most imperative languages) \nreject the above program, because references are unrestricted, that is, they may be freely aliased. In \ngeneral, reasoning about unrestricted references is hard because we need additional information to understand \nwhat other values are affected by an update. In the absence of this information, we must be conservative. \nFor instance, in SML, we must assume that an update to an int ref could affect any other int ref.To ensure \ntype soundness, we must therefore require the type of the ref s contents be preserved by the update. \nIn other words, most type systems can only track invariants on refs, instead of program-point\u00adspeci.c \nproperties. As a result, we are forced to weaken the type of the ref to cover all possible program points. \nIn the example above, we must weaken r1 s type to (int + bool) ref and pay the costs of tagging values, \nand checking those tags when the pointer is dereferenced. Unfortunately, in many settings, this weakened \ninvariant is in\u00adsuf.cient. Hence, researchers have turned to more powerful sys\u00adtems that do provide a \nmeans of ensuring exclusive access to state. In particular, many projects have introduced some form of \nlinearity to tame state. Linear logic [15] and other substructural logics give rise to more expressive \ntype systems, because they are designed to precisely account for resources. For instance, the Clean programming \nlanguage [26] relies upon a form of uniqueness to ensure equational reasoning in the pres\u00adence of mutable \ndata structures. The Cyclone programming lan\u00adguage [17] uses unique pointers to allow .ne-grained memory \nmanagement. For example, a unique pointer may be updated from uninitialized to initialized, and its contents \nmay also be deallocated: 1. x = malloc(4); // x: ---* U 2.*x=3; // x: int * U 3. free(x); // x: undefined \nIn both of these languages, a unique object may be implicitly discarded, yielding a weak form of uniqueness \ncalled af.nity. The Vault programming language [13] uses tracked keys to en\u00adforce resource management \nprotocols. For example, the following interface speci.es that opening a .le returns a new tracked key, \nwhich must be present when reading the .le, and which is con\u00adsumed when closing the .le: 1. interface \nIO { 2. type FILE; 3. tracked($F) FILE open(string) [ +$F ]; 4. char read (tracked($F) FILE) [ $F \n]; 5. void close (tracked($F) FILE) [ -$F ]; }  1 We assume that values are represented uniformly so \nthat, for instance, unit, booleans, and integers all take up one word of storage. Because tracked keys \nmay be neither duplicated nor discarded, Vault supports a strong form of uniqueness technically termed \nlinearity, which ensures that an opened .le must be closed exactly once. Other projects [32, 12] have \nalso incorporated linearity to ensure that memory is reclaimed. Both forms of uniqueness (linearity and \naf.nity) support strong updates, whereby the type of a stateful object is changed in re\u00adsponse to stateful \noperations. For example, the Cyclone code frag\u00adment above demonstrates the type of the unique pointer \nchanging from uninitialized to initialized (with an integer) in response to the assignment. The intuitive \nunderstanding is that a unique object can\u00adnot be duplicated, and thus there are no aliases to the object; \nhence, no other portion of the program may observe the change in the ob\u00adject s type, so it is safe to \nperform a strong update. Yet, programming in a language with only unique (i.e., linear or af.ne) objects \nis much too painful. In such a setting, one can only construct tree-like data structures. Hence, it is \nnot surprising that both Cyclone and Vault allow a programmer to put unique objects in shared objects, \nwith a variety of restrictions to ensure that these mixed objects behave in a safe manner. In fact, understanding \nthe various mechanisms by which unique objects (with strong updates) may safely coexist and mix with \nshared objects is currently an active area of research [5], though much of it has focused on high-level \nprogramming features, often without a complete formal account. Therefore, it is natural to study a core \nlanguage with mutable references of all sorts mentioned above: linear, af.ne, and unre\u00adstricted. The \nstudy of substructural logics immediately suggests one more sort relevant, which describes data that \nmay be dupli\u00adcated but not implicitly discarded. Having made these distinctions, a number of design questions \narise: What does it mean to duplicate or to discard a reference? What operations may be safely performed \nwith the different sorts of references? What combinations of sorts for a reference and its contents are \nsafe? A major contribution of this paper is to answer these questions, giving an integrated design of \nreferences for all of these substruc\u00adtural sorts (Section 3). Our design allows unique (linear and af.ne) \nvalues to be stored in shared (unrestricted and relevant) references, while preserving the desirable \nfeature that resources are tracked accurately. Our language extends a core .-calculus with a straight\u00adforward \ntype system that provides data of each of the substruc\u00adtural sorts mentioned above (Section 2). The key \nidea, present in other substructural type systems, is to break out the substructural sorts as type quali.ers. \nRather than prove soundness via a syn\u00adtactic subject-reduction proof, we adopt an approach compatible \n 2. .URAL: A Substructural .-Calculus Advanced type systems for state rely upon limiting the ordering \nand number of uses of data and operations to ensure that state is handled in a safe manner. For example, \n(safely) deallocating a data structure requires that the data structure is never used in the future. \nIn order to establish this property, a type system may ensure that the data structure is used at most \nonce; after one use, the data structure may be safely deallocated, since there can be no further uses. \nA substructural type system provides the core mechanisms nec\u00adessary to restrict the number and order \nof uses of data and opera\u00adtions. A conventional type system, such as that employed by the simply-typed \n.-calculus, with a typing judgement like G f e : t , satis.es three structural properties: Exchange If \nG1,x:tx,y:ty,G2 f e : t, then G1,y:ty,x:tx,G2 f e : t. Contraction If G1,x:tz,y:tz,G2 f e: t, then G1,z:tz,G2 \nf e[z/x][z/y]: t. Weakening If G f e: t, then G,x:tx f e: t.  / /// In contrast, a substructural type \nsystem is designed so that one or more of these structural properties do not hold in general. Among the \nmost widely studied substructural type systems are the linear type systems [29, 24], derived from Girard \ns linear logic [15], in which all variables satisfy Exchange, but linearly typed variables satisfy neither \nContraction nor Weakening. In this section, we present a substructural polymorphic .\u00adcalculus, similar \nin spirit to Walker s linear lambda calculus [30]. In our calculus, types and variables are quali.ed \nas unrestricted (U), relevant (R), af.ne (A), or linear (L). All variables will sat\u00adisfy Exchange, while \nonly unrestricted variables will satisfy both Contraction and Weakening, allowing such variables to be \nused an arbitrary number of times. We will require linear variables to satisfy neither Contraction nor \nWeakening, ensuring that such variables are used exactly once,  af.ne variables to satisfy Weakening \n(but not Contraction), ensuring that such variables are used at most once, and  relevant variables to \nsatisfy Contraction (but not Weakening),  ensuring that such variables are used at least once.2 The \ndiagram below demonstrates the relationship between these quali.ers, inducing a lattice ordering .. linear \n(L) af.ne (A) relevant (R) with that used in Foundational Proof Carrying Code [6, 7]. We con\u00ad struct \na step-indexed model (Section 4) where types are interpreted as sets of store description / value pairs, \nwhich are further re.ned using an index representing the number of steps available for future evaluation. \nWe believe this model improves on previous models of mutable state, contributing a compositional notion \nof aliasing and ownership that directly addresses the subtleties of allowing unique values to be stored \nin shared references. Furthermore, we achieve a simple model, in comparison to denotational and domain-theoretic \napproaches, that easily extends to impredicative polymorphism and .rst-class references. Constructing \na (well-founded) set-theoretic model means that our soundness and safety proofs are amenable to formalization \nin the higher-order logic of Foundational PCC. Hence, our work provides a useful foundation for future \nextensions of Foundational PCC, which currently only supports unrestricted references, but is an attractive \ntarget for source languages wishing to carry high-level security guarantees, enforced by type states \nand linear resources, through to machine code. / ///  unrestricted (U) 2.1 Syntax Figure 1 presents \nthe syntax for our core calculus, dubbed the .URAL-calculus. Most of the types, expressions, and values \nare based on a traditional polymorphic .-calculus. Kind and Type Levels We structure our types t as a \nquali.er . applied to a pre-type t , yielding the four sorts of types noted above. The quali.er of a \ntype dictates the structural operations that may be applied to values of the type, while the pre-type \ndictates the introduction and elimination forms. The pre-types 1\u00ae, t1 \u00ae t2, and t1 -t2 correspond to \nthe unit, pair, and function types of the polymorphic .-calculus. 2 In the logic community, it is perhaps \nmore accurate to use the quali.er strict for such variables. However, strict is already an overloaded \nterm in the functional programming community; so, like Walker [30], we use relevant. Kind Level: Kinds \n. ::= QUAL |* |* Type Level: Constant Quali.ers q . Quals = {U,R,A,L} Quali.ers . ::= a |q PreTypes t \n::= a |1\u00ae |t1 0 t2 |t1 -t2 |.a:..t Types t ::= a |.t Type-level Terms . ::= . |t |t Expression Level: \nValues v ::= x |()|(v1,v2)|.x.e |..e Expressions e ::= v |let ()= e1 in e2 |let (x1,x2)= e1 in e2 |e1 \ne2 |e[] Figure 1. .URAL Syntax Polymorphism over quali.ers, pre-types, and types is provided by a single \npre-type . a:.. t ; we introduce a kind level to distin\u00adguish among the type-level terms that may be \nused to instantiate a polymorphic pre-type (with kinds QUAL, *, and * for quali.ers, pre-types, and types, \nrespectively). In an accompanying technical report [3], we show that it is also easy to extend our results \nto include sum (t1 E t2), existential (. a:.. t ), and recursive (\u00b5a:*. t ) pre-types and recursive func\u00adtions \nin the calculus, though we elide such constructs in this pre\u00adsentation. This structuring of types as \na quali.er applied to a pre-type fol\u00adlows that of Walker [30], but differs from other presentations of \nlinear lambda calculi that use exactly one modality (!t ) to distin\u00adguish unrestricted from linear types. \nIt seems possible to introduce alternative modalities (e.g, - t for af.ne and +t for relevant), but then \nwe would have to consider their interaction (e.g., what does - !+t denote?). Also, with four distinct \nquali.ers, it is natural to introduce qual.er polymorphism, which is best formulated by sep\u00adarating quali.ers \nfrom pre-types. Expression Level Each pre-type has an associated value intro\u00adduction form. The pattern \nmatching expression forms let () = e1 in e2 and let ( x1,x2) = e1 in e2 are used to eliminate units (1\u00ae) \nand pairs (\u00ae), respectively. As usual, a function with pre-type t1 -t2 is eliminated via application \ne1 e2, while a type-level ab\u00adstraction . a:.. t is eliminated via instantiation e []. Note that expressions \nare not decorated with type-level terms. This simpli.es the semantic model presented in Section 4, where \nsoundness is with respect to typing derivations, and is appropriate for an expressive internal language. \nWe leave as an open problem the formulation of appropriate inference and elaboration algorithms yielding \nderivations in the type system of the next section, which would likely require some type-level annotations \non expressions in a surface language.  2.2 Static Semantics The goal of the type system for .URAL is \nto approximate the re\u00adquirements of languages like Vault and Cyclone, which ensure that linear values \nare used exactly once, af.ne values are used at most once, and relevant values are used at least once. \nDually, the type system should ensure that only unrestricted and relevant values are duplicated and only \nunrestricted and af.ne values are discarded. To prevent values from being implicitly copied or dropped \nwhen their containing value is duplicated or discarded, the type system must also ensure that a (functional) \nvalue with a quali.er lower in the lattice may not contain values with quali.ers higher in the lattice. \nFor example, an af.ne (A) pair may not contain linear (L) compo\u00adnents, since we could end up dropping \nthe linear components by dropping the pair, so the type sytem must rule out expressions of type A(Lt1 \n\u00ae Lt 2). . f.1 .2 . fa : QUAL q1 q2 . fa : QUAL . fU a . fq1 q2 . fa L . f. : QUAL . f.1 .' . f.' .2 \n. f. . . f.1 .2 . ft . . fa : * . ft' : * . f.' . . fa L . f.( t' . . fG . . f. : QUAL . fG . . ft . \n. f . . fG,x:t Figure 4. .URAL Statics (Sub-Qual Rules) Despite these requirements, the type system is \nrelatively simple. .URAL typing judgements have the form .; G f e : t where the contexts . and G are \nde.ned as follows: Type-level Term Context . ::= |.,a:. Value Context G ::= |G,x:t Thus, . is used to \ntrack the set of type-level variables in scope (along with their kinds), whereas G, as usual, is used \nto track the set of (expression-level) variables in scope (along with their types). There may be at most \none occurrence of a type-level variable a in . and, similarly, at most one occurrence of a variable x \nin G. Figure 2 presents the .URAL kinding rules and Figure 3 presents the .URAL typing rules. In order \nto ensure the correct relationship between a data structure and its components, we extend the lattice \nordering on constant quali.ers to types and contexts (see Figure 4). In the presence of quali.er and \ntype polymorphism, we include the rules . f U a and . f a L, a conservative extension, since U and L \nare the bottom and top of the lattice. A more general approach would incorporate bounded quali.er constraints, \nwhich we believe is straightforward, but doing so does not add to the discussion at hand. As is usual \nin a substructural setting, our type system relies upon a judgement . f G . G1 E G2 that splits the assumptions \nin G between the contexts G1 and G2 (see Figure 5). Splitting the context is necessary to ensure that \nvariables are used appropriately by sub-expressions. Note that E ensures that an A or L assumption appears \nin exactly one sub-context. On the other hand, U and R assumptions may appear in both sub-contexts, corresponding \nto implicit duplication of the variables. . f. : .  a:... . f. : QUAL . ft : * (VarKn) . fa : . (Qual) \n. fq : QUAL (Type) . f.t : * . ft1 : * . ft2 : * . ft1 : * . ft2 : * .,a:.ft : * (MUnitPTy) (MPairPTy) \n(FnPTy) (AllPTy)  . f1\u00ae : * . ft1 0 t2 : * . ft1 -t2 : * . f.a:..t : * Figure 2. .URAL Statics (Kinding \nRules) .; G fe: t . fG . G1 . G2 . f. : QUAL .; G1 fv1 : t1 . ft1 . . ft : * . f. : QUAL .; G2 fv2 : \nt2 . ft2 . (Var) (MUnit) (MPair) .; ,x:t fx: t .; f(): .1\u00ae .; G f(v1,v2): .(t1 0 t2) . f. : QUAL . fG \n. .; G,x:t1 fe: t2 . f. : QUAL . fG . .,a:.;G fe: t (Fn) (All) .; G f.x.e: .(t1 -t2) .;G f..e : ..a:..t \n. fG . G1 .G2 . fG . G1 . G2 .; G1 fe1 : .1\u00ae .; G2 fe2 : t .; G1 fe1 : .(t1 0 t2) .;G2,x1:t1,x2:t2 fe2 \n: t (Let-MUnit) (Let-MPair) .; G flet ()= e1 in e2 : t .; G flet (x1,x2)= e1 in e2 : t . fG . G1 .G2 \n.; G1 fe1 : .(t1 -t2) .;G2 fe2 : t1 .; G fe: ..a:..t . f. : . (App) (Inst) .; G fe1 e2 : t2 .; G fe[] \n: t[./a] . fG . G1 .G2 .; G1 fe: t . fG2 A (Weak) .; G fe: t Figure 3. .URAL Static Semantics (Typing \nRules) . fG . G1 .G2 . fG . G1 . G2 . ft : * . f . . . fG,x:t . G1,x:t . G2 . fG . G1 .G2 . ft : * . \nfG,x:t . G1 . G2,x:t . fG . G1 . G2 . ft R . fG,x:t . G1,x:t . G2,x:t Figure 5. .URAL Statics (Context \nSplit Rules) The rule (MPair) is representative: the context is split by E to type each of the pair components, \nand the types of each component are bounded by the quali.er assigned to the pair. Intuitively, the L \nand A assumptions in the context are exclusively owned by exactly one of the two components. Likewise, \nin the rule (Fn), the free variables of G, which constitute the closure of the function, must be bounded \nby the quali.er assigned to the function. Note that the quali.er assigned to a function type is unrelated \nto the types of the argument and result; rather, it is related to the abstracted components that are \nused when the function is executed. The rule (Weak) splits the context into a sub-context used to type \nthe expression e and a discardable sub-context, consisting of U and A variables, that are not required \nto type the expression. Note that the rule (Weak) acts as a strengthened Weakening property, allowing \nan arbitrary number of U and A variables to be dropped at once. The corresponding strengthened Contraction \nproperty is incorporated into the judgement . f G . G1 E G2, which allows an arbitrary number of U and \nR variables to be copied at once.  3. .refURAL: A Substructural .-Calculus with References Languages \nlike Vault and Cyclone include objects that change state (e.g., .le descriptors), so it is natural to \ninclude some stateful values. We consider the dif.cult case of references, which can serve as mutable \ncontainers for both functional values and stateful values. Hence, we extend the .URAL-calculus with mutable \nreferences, to yield the .refURAL-calculus. The reference pre-type ref t may be combined with a quali.er \n. to yield the four sorts (U, R, A, L) of references discussed earlier. We also introduce operations \nto allocate (newq ) and deallocate (free) references, as well as to read (rd), write (wr), and swap (sw) \ntheir contents. Not all of these operations can be safely performed with all sorts of references, as \nwe discuss in Section 3.2. The syntactic extensions to support references are as follows: Type Level: \nPreTypes t ::= ... |ref t Expression Level: Locations l . Locs Values v ::= ... |l Expressions e ::= \n... |newq e |free e | rd e |wr e1 e2 |sw e1 e2 3.1 Operational Semantics Figure 6 gives the small-step \noperational semantics for .refURAL as a relation between con.gurations of the form (s, e), where Store \ns ::= { l1 . (q1,v1),...,ln . (qn,vn)} (let-munit) (s, let () = () in e) -. (s, e) (let-mpair) (s, let \n( x1,x2) = ( v1,v2) in e) -. (s, e[v1/x1][v2/x2]) (app) (s, (.x. e) v) -. (s, e[v/x]) (inst) (s, (..e) \n[]) -. (s, e) (new) (s, newq v) -. (s l{ l . (q, v)} ,l) (free) (s l{ l . (q, v)} , free l) -. (s, v) \n(read) (s l{ l . (q, v)} , rd l) -. (s l{ l . (q, v)} , ( l, v) ) (write) (s l{ l . (q, v1)} , wr lv2) \n-. (s l{ l . (q, v2)} ,l) (swap) (s l{ l . (q, v1)} , sw lv2) -. (s l{ l . (q, v2)} , ( l, v1) ) ' (s, \ne) (s ' ) -. ,e (ctxt) ' (s, E[e]) (s ,E[e ' ]) -. Figure 6. .refURAL Operational Semantics s is a global \nstore mapping locations to quali.ers and values.3 The notation s1 l s2 denotes the disjoint union of \nthe stores s1 and s2; the operation is unde.ned if the domains of s1 and s2 are not disjoint. We use \nevaluation contexts E (omitted in this presentation) to lift the primitive rewriting rules to a standard, \nleft\u00adto-right, innermost-to-outermost, call-by-value interpretation of the language. Most of the rules \nare standard, so we highlight only those in\u00advolving references. The expressions newq e and free e perform \nthe complementary actions of allocating and deallocating mutable references in the global store. Speci.cally, \nthe expression newq e evaluates e to a value v, allocates a fresh (unallocated) location l to store the \nquali.er q and value v, and returns l. The expression free e performs the reverse: it evaluates e to \na location l, deallo\u00adcates l, and returns the value previously stored at l. The expressions for reading \nand writing a mutable reference implicitly duplicate and discard (respectively) the contents of the reference. \nThe expression rd e evaluates e to a location l, duplicates the value v stored at l, and returns (l, \nv), leaving the value stored at l unchanged. Meanwhile, wr e1 e2 evaluates e1 to a location l and e2 \nto value v2, stores v2 at location l, discards the value previously stored at l, and returns l. In languages \nwith only unrestricted (ML-style) references, it is customary for rd to return only the contents of l \nand for wr to re\u00adturn (). However, we do not wish to consider reading or writing a linear (resp. af.ne) \nreference as the exactly-one-use (resp. at-least\u00adone-use) of the value. Therefore, the rd and wr (and \nsw) operations return the location l that was read or written, which remains avail\u00adable for future use. \nThe behavior of ML-style references may be recovered by implicitly discarding the returned location. \nThe expression sw e1 e2 combines the operations of dereferenc\u00ading and updating a mutable reference, but \nhas the attractive property that it neither duplicates nor discards a value. Notice that perform\u00ading \na write or swap operation on a location may change the type of the location s contents. The static semantics \nwill permit weak (type-invariant) updates on all references (with some additional caveats), but will \nrestrict strong (type-varying) updates to unique references. qual(l) and s 3 We write sval(l) for the \nrespective projections of s(l). Ref Ops Contents and Ops URAL rd newU wr U wr XX (weak updates) sw sharedsw \nrd newR rd wr R wr sw (weak updates) sw sw sw newA rd A free wr X wr X sw (strong updates) sw unique \n{{{{ {{{{{ {{{{{{  {{{{{ newL rd rd wr L free wr sw sw sw (strong updates) sw Figure 7. Operations \nfor Substructural State The reader may well wonder why each reference is stamped with a quali.er at its \nallocation when the remainder of the opera\u00adtional rules are entirely agnostic with respect to a reference \ns qual\u00adi.er. Essentially, the quali.er is a form of instrumentation, which, when combined with the semantic \nmodel presented in Section 4, allows us to guarantee that linear and relevant references cannot be implicitly \ndiscarded. Such a property is dif.cult to capture exclu\u00adsively in the operational semantics (i.e., by \nensuring that the ab\u00adstract machine gets stuck when a linear or relevant reference is implicitly dropped). \nOn the other hand, the abstract machine does get stuck when attempting to access a reference after it \nhas been deallocated. 3.2 Static Semantics As with the type system for .URAL, we would like the type \nsystem for .refURAL to ensure the property that no linear or af.ne value is implicitly duplicated and \nno linear or relevant value is implicitly discarded. With that in mind and noting that only unrestricted \nand relevant references may be implicitly copied (by the . f G . G1 E G2 judgement), while only unrestricted \nand af.ne references may be implicitly dropped (by the (Weak) rule) we now answer the questions we laid \nout in Section 1: What operations may be safely performed with the different sorts of references? What \ncombinations of sorts for a reference and its contents are safe? These answers are summarized in Figure \n7. First, consider what it means to duplicate a reference. Opera\u00adtionally, a reference is a location \nin the global store. Therefore, du\u00adplicating an unrestricted or relevant reference l, simply yields two \ncopies of l while the value stored at l is not duplicated. Since duplicating a shared reference does \nnot alter the uniqueness of its contents, it is not only reasonable but also extremely useful to al\u00adlow \nshared references to store unique values. In particular, it per\u00admits the sharing of (large) unique data \nstructures without expensive copying. On the other hand, dropping an unrestricted or af.ne reference \nl effectively drops its contents, since this reference may (must, in the case of af.ne) have been the \nonly copy of l. If the contents were a linear or relevant value, then the exactly-one-use and at-least-one\u00aduse \ninvariants (respectively) would be violated. Hence, we cannot allow linear and relevant values (which \ncannot be discarded) to be stored in unrestricted or af.ne references (which can be discarded). Considering \nyet another axis, we note that linear and af.ne references must be unique. Hence, we can free unique \nreferences, and also perform strong updates on them. Shared references, on the other hand, can never \nbe deallocated and can only support weak updates. As we noted above, the rd operator induces an implicit \ncopy while the wr operator induces an implicit drop. Therefore, whether . f . : . . f t : * (RefPTy) \n. f ref t : * .; G f e : t q A .; G f e : t . f t A (New(U,A)) .; G f newq e : q ref t .; G f e : .ref \nt . f A . (Free) .; G f free e : t . f G . G1 .G2 .; G1 f e1 : .ref t1 . f t1 A . f A . .; G2 f e2 : \nt2 . f t2 . (Write(Strong)) .; G f wr e1 e2 : .ref t2 . f G . G1 . G2 .; G1 f e1 : .ref t1 . f A . .; \nG2 f e2 : t2 . f t2 . (Swap(Strong)) .; G f sw e1 e2 : L(.ref t2 0 t1) R q .; G f e : t (New(R,L)) .; \nG f newq e : q ref t .; G f e : .ref t . f t R (Read) .; G f rd e : L(.ref t 0 t) . f G . G1 .G2 .; G1 \nf e1 : .ref t . f t A .; G2 f e2 : t (Write(Weak)) .; G f wr e1 e2 : .ref t . f G . G1 . G2 .; G1 f \ne1 : .ref t .; G2 f e2 : t (Swap(Weak)) .; G f sw e1 e2 : L(. ref t 0 t) Figure 8. .refURAL Static Semantics \n(Kinding and Typing Rules) we can read from or write to a reference depends entirely on the quali.er \nof its contents: rd is permitted if the contents are unrestricted or relevant (i.e., duplicable), wr \nis permitted if the contents are unrestricted or af.ne (i.e., discardable). The operation sw is permitted \non any sort of reference, regardless of the quali.er of its contents. As noted above, strong writes and \nstrong swaps, which change the type of the contents of the location, are only permitted on unique references. \nFigure 8 gives the additional typing rules for .refURAL. We note that the typing rules for core .URAL \nterms remain unchanged. There is no rule for locations, as locations are not allowed in the external \nlanguage. Also note that the (New) and (Free) rules act as the in\u00adtroduction and elimination rules for \n.ref t types, while the (Read), (Write), and (Swap) rules maintain an exactly-one-use invariant on references \nby consuming a value of type .ref t1 and by producing a value of type .ref t2 (possibly with t1 = t2). \nFinally, we note that wr may be encoded using an explicit sw and an implicit drop:4 . f G . G1 . G2 .; \nG1 f e1 : .ref t . f t A .; G2 f e2 : t (Write(Weak)) .; G f wr e1 e2 : .ref t def = let (r, x) = sw \ne1 e2 in // using (Swap(Weak)) // drop x, noting . f t A r However, rd may not be encoded using an explicit \nsw and an implicit copy, as a suitable (discardable) dummy value cannot in general be synthesized. .; \nG f e : .ref t . f t R (Read) .; G f rd e : L(. ref t 0 t) def = let (r, x) = sw e ? in // where .; \nG f ?: t // copy x, noting . f t R let (r, y) = sw rx in // using (Swap(Weak)) // drop y, but not necessarily \n. f t A (r, x) 4 The encoding of a wr typed by the (Write(Strong)) rule makes use of the same term, but \nan alternate typing derivation.  4. A Step-Indexed Model We prove the type soundness of .refURAL in \na manner similar to that employed by Appel s Foundational PCC project [6]. The technique uses syntactic \nlogical relations (that is, relations based on the op\u00aderational semantics) where relations are further \nre.ned by an index that, intuitively, records the number of steps available for future evaluation. This \nstrati.cation is essential for modeling the recur\u00adsive functions (available via backpatching unrestricted \nreferences) and impredicative polymorphism present in the language. 4.1 Background: A Model of Unrestricted \nReferences Our model is based on the indexed model of ML-style references by Ahmed, Appel, and Virga \n[1, 4], henceforth AAV. In their model, the semantic interpretation T[t. of a (closed) type t is a set \nof triples of the form (k, .,v), where, k is a natural number (called the approximation index or step \nindex), . is a (global) store typing that maps locations to (the interpretation of) their designated \ntypes, and v is a (closed) value. Intuitively, (k, .,v) .T[t. says that in any computation running for \nno more than k steps, v cannot be distinguished from values of type t. Furthermore, since dereferencing \na location consumes an execution step, in order to determine whether v has type t for k steps it suf.ces \nto know the type of each store location for k -1 steps; hence, . need only specify each location s type \nto approximation k -1. We use a similar indexing approach which is key to ensuring that our model is \nwell-founded (as we shall demonstrate in Section 4.3).  4.2 Towards a Model of .refURAL Aliasing and \nOwnership Though our model is similar to AAV, the presence of shared and unique references places very \ndiffer\u00adent demands on the model, which we illustrate by considering the interpretation of product types \nin various settings. In a lan\u00adguage with only unrestricted references (e.g. AAV), one would say (k, ., \n(v1,v2)) .T[t1 \u00ae t2. if and only if (k, .,v1) .T[t1. and (k, .,v2) .T[t2], where the store typing . describes \nevery location allocated by the program thus far. In this setting, every lo\u00adcation (in .) may be aliased; \nhence, the model allows v1 and v2 to point to data structures that overlap in the heap.  ;; l1 L l1 \nL l6 / L , / , / , / , / , l2 A l2 A / ,  / ,  /, ,  l3 U l3 U l3 U l4  A l4 A l4 A \nl5 A l5 A l5 A (b) (k, ., .2,y) .T [t2] (a) (k, ., .1,x) .T [t1] (c) Problem: .1 l.2 = unde.ned Figure \n9. Unique References in Shared References: Aliased or Owned? In a language with only linear references \n[23, 2], however, one must ensure that the set of (linear) locations reachable from v1 is disjoint from \nthe set of locations reachable from v2. This mirrors the fact that we can only construct tree-like data \nstructures in this setting. Furthermore, it guarantees the safety of strong updates by providing a notion \nof exclusive ownership. Hence, to model a language with only linear references, it is useful to replace \nthe global store description .with a description of only the accessible (reachable) locations in the \nstore, say .. Intuitively, when we write (k, .,v).T [t], we intend for .to describe only the subset of \nstore locations that are accessible from, and hence, owned by v. Thus, one would say (k, ., (v1,v2)).T \n[t1 \u00ae t2] if and only if (k, .1,v1).T [t1] and (k, .2,v2).T [t2], where the .is the disjoint union of \n.1 and .2. For the .refURAL-calculus, we tried to build a model that supports both aliasing and ownership \nas follows. We de.ned the semantic interpretation of a type T [t] as the set of tuples of the form (k, \n., .,v)where .describes every U and R location allocated by the program and .describes only those A and \nL locations that are reachable from (and owned by) v. The interpretation of t1 \u00ae t2 then naturally yields: \n(k, ., ., (v1,v2)).T [t1 \u00ae t2] if and only if (k, ., .1,v1).T [t1] and (k, ., .2,v2).T [t2], where the \n.is the disjoint union of .1 and .2. Unfortunately, the above model did not suf.ce for .refURAL , since \nit assumes that every unique location reachable from v is ex\u00adclusively owned by v, which is not the case \nwhen unique references may be stored in shared references. Unique References in Shared References: Aliased \nor Owned? Consider the situation depicted in Figure 9(a) where x maps to l1 and locations l1 through \nl5 are reachable from x. Locations owned by x are shaded. Notice that l1 and l2 are unique locations \nowned by x, while l4 and l5 are unique locations that x must consider aliased, since they can be reached \n(from other program subexpressions) via the unrestricted location l3. Figure 9(b) depicts such a subexpression, \ny. Note that y maps to l6 whose contents alias l3, making l4 and l5 reachable from y. In .refURAL we \nmay safely construct the pair (x, y)(shown in Figure 9(c)), but the interpretation of t1 \u00ae t2 that we \nproposed above prohibits such a pair since locations l4 and l5 occur in both .1 and .2, violating the \nrequirement that their domains be disjoint. To model the .refURAL-calculus, we tried to further re.ne \nour model so that the interpretation of a type T [t] is a set of tuples of the form (k, ., ., T,v)where \n.is as before, but now .describes unique owned locations, (i.e., those reachable from v without in\u00addirecting \nthrough a shared reference), while T describes unique aliased locations, (i.e., those that cannot be \nreached without indi\u00adrecting through a shared cell). The intuition is that the interpretation of t1 \u00ae \nt2 splits .into disjoint pieces for each component of the pair, but allows each component to use .and \nTunchanged. This proposal, however, is fraught with complications. In par\u00adticular, whether a unique location \nbelongs in .or Tdepends on the con.guration of the entire program, rather than just the type of the location. \nThis limits the compositionality of the model. For in\u00adstance, consider l5 in Figure 9(c). Clearly l5 \nmust appear in Tas it is reachable from an unrestricted location. However, if locations l1, l2, l3, and \nl6 did not exist, then l5 could appear in .. In the next section, we propose a far simpler solution that \nwe consider one of the main technical contributions of our work.  4.3 A Model with Local Store Descriptions \nIn our model of the .refURAL-calculus, the semantic interpretation of a type T [t] is a set of tuples \nof the form (k, q, ., v), where the local store description . describes only a part of the global store. \nIntuitively, . is the set of beliefs about the locations that appear as sub-expressions of the value \nv. Such locations are said to be directly accessible from the value v. Conversely, locations that are \nindirectly accessible from the value v are those locations that are reachable from v only by indirecting \nthrough one (or more) references. The local store description . says nothing about these indirectly-accessible \nlocations. This enhances the compositionality of our model, making it straightforward to combine local \nstore descriptions with one another. 4.3.1 De.nitions We use the meta-variable . to denote sets of tuples \nof the form (k, q, ., v)and the meta-variable . to denote partial maps from locations l to tuples of \nthe form (q, .).5 When . corresponds to the semantic interpretation of a type and (k, q, ., v) . ., we \nintend that q is the quali.er of v, . is the local store description of v, and v is a closed value. When \n. corresponds to a local store description and .(l)=(q, .), we intend that q is the quali.er of the reference \nand . is the semantic interpretation of the type of its contents. 5 We write .qual (l) and .type (l) \nfor the respective projections of .(l). (a) PreType/Type Interpretation (Notation) . ::= {(k, q, ., \nv),...}Local Store Description (Notation) . ::= {l .(q, .),...} (b) CandAtomk CandUberTypek CandLocalStoreDesck \nCandAtom. CandUberType. CandLocalStoreDesc. def = {(j, q, ., v) .N \u00d7Quals \u00d7CandLocalStoreDescj \u00d7CValues \n| j<k j<k .. .CandLocalStoreDescj} def 2CandAtomk = def = Locs . Quals \u00d7CandUberTypek def =k=0 CandAtomk \ndef 2CandAtom. = .k=0 CandUberTypek def = Locs . Quals \u00d7CandUberType. .k=0 CandLocalStoreDesck (c) l.Jk \ndef = . {(j, q, ., v) | j< k .(j, q, ., v) ..}CandUberType. .CandUberTypek l.Jk def = . {l .(q, l.Jk) \n| l .dom(.) ..(l)= (q, .)}CandLocalStoreDesc. .CandLocalStoreDesck P(q, .) def = . .l .dom(.)..qual (l) \nq Quals \u00d7CandLocalStoreDesc. .P R(.) def = . .l .dom(.). (.qual (l) A ..( ,q ' , , ) ..type (l).q ' CandLocalStoreDesc. \n.P A) def (d) Atomk = {(j, q, ., v) .CandAtomk | . .LocalStoreDescj .P(q, .)}. CandAtomk def PreTypek \n= {. .2Atomk |.(j, q, ., v) ... .i =j. (i, q, l.Ji,v) ..}. CandUberTypek def '' Typek = {. .PreTypek \n|.q .Quals. .( ,q, , ) ... q = q }. CandUberTypek def LocalStoreDesck = {. .Locs . Quals \u00d7Typek |R(.)}. \nCandLocalStoreDesck def PreType = {. .CandUberType. |.k =0. l.Jk .PreTypek}.PreTypek k=0 def Type = \n{. .CandUberType. |.k =0. l.Jk .Typek}.Typek k=0 Figure 10. .refURAL Model (De.nitions) Well-Founded \n&#38; Well-Behaved Interpretations If we attempt to na\u00a8ively construct a set-theoretic model based on \nthese intentions, we are led to specify: 2N\u00d7Quals\u00d7LocalStoreDesc\u00d7CValues Type = LocalStoreDesc = Locs \n. Quals \u00d7Type However, there is a problem with this speci.cation: a simple di\u00adagonalization argument \nwill show that the set Type of type inter\u00adpretations has an inconsistent cardinality (i.e., it s an ill-founded \nrecursive de.nition). We can eliminate the inconsistency by stratifying our de.ni\u00adtions, making essential \nuse of the approximation index. To simplify the development, we .rst construct candidate sets, which \nare well\u00adfounded sets of our intended form. Next, we de.ne some useful functions and predicates on these \ncandidate sets. Finally, we con\u00adstruct our semantic interpretations by .ltering the candidate sets, making \nuse of the functions and predicates de.ned in the previous step. Our semantic interpretations impose \na number of constraints (e.g., relating the quali.er of a reference to the quali.er of its con\u00adtents) \nthat are ignored in the construction of the candidate sets. Figure 10(b) de.nes our candidate sets by \n(strong) induction on k. Note that elements of CandAtomk are tuples with approxima\u00ad tion index j strictly \nless than k. Hence, our de.nitions are well\u00adde.ned at k =0: CandAtom0 = \u00d8 CandUberType0 = {\u00d8}CandLocalStoreDesc0 \n= Locs . Quals \u00d7{\u00d8} While our candidate sets establish the existence of sets of our in\u00adtended form, our \nsemantic interpretations will need to be well\u00adbehaved in other ways. There are key constraints associated \nwith atoms, pre-types, types, and local store descriptions that will be en\u00adforced in our .nal de.nitions. \nFunctions and predicates supporting these constraints are given in Figure 10(c). For any set ., we de.ne \nthe k-approximation of the set (written L.Jk) as the subset of its elements whose indices are less than \nk;we extend the notion pointwise to local store descriptions . (written L.Jk). Note that L.Jk and L.Jk \nnecessarily yield elements of CandUberTypek and CandLocalStoreDesck. Figure 10(c) de.nes our semantic \ninterpretations, again by (strong) induction on k. Note that our semantic interpretations can be seen \nas .ltering their corresponding candidate sets. Next, we examine each of these .ltering constraints. \nRecall that we intend for Atomk to de.ne tuples of the form (j, q, ., v)where q is the quali.er of v \nand . is the local store K[QUAL] T [. fa : .] d = T [. fq : QUAL] d = T [. f1\u00ae : *] d = T [. ft1 0 t2 \n: *] d = T [. ft1 -t2 : *] d = T [. f.a:..t : *] d = T [. fref t : *] d = T. f.t : *d = def Comp(k,.s,es,.)= \n = Quals K[*] = PreType K[*] = Type d(a) q {(k,q,{},())} {(k,q,.,(v1,v2)) | . =(.1 8k .2) . (k,q1,.1,v1) \n.T [. ft1 : *] d.q1 q. (k,q2,.2,v2) .T [. ft2 : *] d.q2 q} {(k,qc,.c,.x.e) | .c .LocalStoreDesck .P(qc,.c) \n. .j< k,qa,.a,va. (j,qa,.a,va) .T [. ft1 : *] d.(.c 8j .a) de.ned . Comp(j,(.c 8j .a),e[va/x],T [. ft2 \n: *] d)} {(k,q,.,..e) | . .LocalStoreDesck .P(q,.) . .j<k,I.K[.] . Comp(j,l.Jj ,e,T [.,a:.ft : *] d[a \n.I])} {(k,q,{l .(q,.)},l) | . = lT [. f t : * ] d Jk . '' (q A ..( ,q, , ) ...q A)} {(k,q,.,v) | q = \nT [. f. : QUAL] d. (k,q,.,v) .T [. ft : *] d} .j< k,ss,.r,sf ,ef . ss :k (.s 8k .r) .(ss,es) -.j (sf \n,ef ) .irred(sf ,ef ) . .qf ,.f . sf :k-j (.f 8k-j .r) .(k-j,qf ,.f ,ef ) .. Figure 11. .refURAL Model \n(Interpretations) description of v. Filtering CandAtomk by the predicate P(q, .) enforces the requirement \nthat if v is a value with quali.er q, then each location directly accessible from v must have a quali.er \nq ' such that q ' q. We further require the local store description . to be a member of LocalStoreDescj. \nWe de.ne PreTypek as those . . 2Atomk . CandUberTypek that are closed with respect to a decreasing step-index. \nWe de.ne Typek by further requiring that all values in . share the same quali\u00ad.er. Looking ahead, we \nwill need to extend our semantic interpreta\u00adtions to a predicate Comp(k, ., e, T [t]), where e is a (closed) \nex\u00adpression. Intuitively, an expression e that is indistinguishable from a value of type t for k steps \nmust also be indistinguishable for j<k steps. Since we will de.ne the predicate Comp(\u00b7, \u00b7, \u00b7, \u00b7) on elements \nof Type, we incorporate this closure property into the de\u00ad.nition of PreTypek. Finally, we de.ne LocalStoreDesck \nusing the predicate R(.), which requires that every unrestricted or af.ne location in . is mapped to \na type with only unrestricted and af.ne values. The predicate R(.) disallows relevant or linear values \nas the contents of unrestricted or af.ne locations (recall Figure 7).  4.3.2 Semantic Interpretations \nFigure 11 gives our semantic interpretation of kinds K [.], quali\u00ad.ers T [q], pre-types T [t], and types \nT [t].6 The interpretation of the kinds * and * are the semantic interpretations PreType and 6 Since \nour language supports polymorphic types, we must give the inter\u00adpretations of type-level terms with free \nvariables. While, technically, we should write T [. f. : .] d, where the substitution d is in the interpreta\u00adtion \nof the term context . (see D[.] in Figure 17), we will use the more concise notation T [.] in the text. \n Type respectively, while the interpretation of the kind QUAL is the set of (constant) quali.ers Quals. \nUnits: No Location Beliefs Consider the interpretation of the pre-type 1\u00ae . Clearly, no locations appear \nas sub-expressions of the value (); hence, the interpretation of 1\u00ae demands an empty local store description \n{}. Furthermore, the value () may be ascribed any quali.er q. References: Single Location Beliefs Next, \nconsider the interpre\u00adtation of the pre-type ref t. From the value l, the only directly\u00adaccessible location \nis l itself. Hence, the local store description . for the location l in the interpretation of ref t must \ntake the form {l . (q, .)}. Furthermore, ., the semantic interpretation of the type of l s contents, \nmust match T [t]. Figure 12 graphically depicts the local store description . = {l (q, T [t])} (slightly \nabusing notation in the interest of . brevity). Our intention is to express the idea that . believes \nthat l is allocated with quali.er q and contents of type t,but . believes nothing about any other location \nin the store, represented by ? . (k,q,. = {l .(q,T [t])},l) .T [ref t] . ? ? ? ?   l .(q,T [t]) ? \n? ? ? Figure 12. A Local Store Description in T [ref t] Note that the de.nition of T [ref t] requires \nthat if l is an unrestricted or af.ne location, then . should never contain local {l.l.1Jk(l)| l .dom(.1)ndom(.2)} \nif .l .dom(.1)ndom(.2).l.1Jk(l)=l.2Jk(l){ l{l .l.1Jk(l)|l .dom(.1)\\dom(.2)} and .l .dom(.1).A .qual (l).l/.dom(.2) \ndef 1 l{l .l.2Jk(l)|l .dom(.2)\\dom(.1)} qual .1 8k .2 = and .l .dom(.2).A .(l).l/.dom(.1) 2 {  unde.ned \notherwise Figure 13. .refURAL Model (Join Partial Function) (a) (k,q1,.1 ={l1 .(q1,T [t1])},l1).T [q1 \nref t1](k,q2,.2 ={l2 .(q2,T [t2])},l2).T [q2 ref t2] (b) (k,U,.1 ={l .(U,T [t])},l).T Uref t (k,U,.2 \n={l .(R,T [t ' ])},l).T Rref t '  .1 .1 .1 8.1   ? l .(U,T [t])  ? l .(U,T [t])  ? l.(U,T [t]) \n =  ??  ?? ??  .1 .2   ? l .(U,T [t])  ? l .(R,T [t ' ])  = unde.ned  ??  ??  (c) (k,L,.a \n={l1 .(U,T [t1]),l2 .(L,T [t2]),va =(l1,l2)).T L(Uref t1 0 Lref t2) (k,L,.b ={l1 .(U,T [t1]),l3 .(L,T \n[t3]),vb =(l1,l3)).T L(Uref t1 0 Lref t3) (k,L,.c ={l3 .(L,T [t3]),vc =(l3,())).T L(Lref t3 0 U1\u00ae) .a \n.b .a 8.b   ? l1 .(U,T [t1])  ? l1 .(U,T [t1])  ? l1 .(U,T [t1]) = l2 .(L,T [t2])? ? l3 .(L,T [t3]) \nl2 .(L,T [t2]) l3 .(L,T [t3]) .b .c ? l1 .(U,T [t1]) = unde.ned   ? l3 .(L,T [t3]) ? l3 .(L,T [t3]) \n  Figure 14. .1 ..2 Examples store descriptions that include relevant or linear locations; i.e., the \nde.nition of T[ref t] incorporates the predicate R(\u00b7) specialized to {l .(q,.)}. Pairs: Compatible Location \nBeliefs A pair (v1,v2)(such that (k,q1,.1,v1) .T[t1] and (k,q2,.2,v2) .T[t2]) is in the interpretation \nof t1 \u00ae t2 if and only if the pair is ascribed a quali.er greater than that of its components and the \ntwo sets of beliefs about the store, .1 and .2, can be combined into a single set of beliefs suf.cient \nfor safely executing ksteps (written .1 .k .2, see Figure 13). Informally, local store descriptions can \nbe combined only if they are compatible; that is, if the beliefs in one local store description do not \ncontradict the beliefs in the other store description. Clearly, if .1 and .2 have disjoint sets of beliefs \nabout the store, then .1 .k .2 is de.ned and equal to the union of their beliefs (see Figure 14(a)). \nIn the more general case, where the same location may be found in the domain of both .1 and .2, there \nare two requirements enforced by the de.nition of .1 .k .2. First, we require that for any location lthat \nis described by both .1 and .2, it must be the case that .1 and .2 have identical beliefs about l to \napproximation k. Note that .1 and .2 must agree on both the quali.er of the location as well as the type \nof the location s contents (see Figure 14(b)). The second requirement is more subtle, having to do with \nthe notion of directly-accessible locations. Suppose that l3 is a linear or af.ne location mapped by \n.b. Therefore, a value vb with local store description .b must contain l3 as a sub-expression. Since \nl3 is linear or af.ne, this occurrence of l3 in the value vb must be the one (and only) occurrence of \nl3 in the entire program state. Now, sup\u00adpose that l3 is also in the domain of a local store description \n.c.As before, a value vc with local store description .c must contain l3 as a sub-expression. If we were \nto attempt to form the value (vb,vc), then we would have a value with two distinct occurrences of l3, \nviolating the uniqueness of the location l3. Hence, we consider .b and .c to represent incompatible (contradictory) \nbeliefs about the current store (see Figure 14(c)). Functions &#38; Abstractions: Closure Location Beliefs \nSince functions and abstractions are suspended computations, their in\u00adterpretations are given in terms \nof the interpretation of types as computations (see below). A function .x.e with quali.er qc and local \nstore description .c (where .c describes the locations di\u00adrectly accessible from the function s closure \nand, hence, must sat\u00adisfy P(qc,.c)) is in the interpretation of t1 -t2 for ksteps if, at some point in \nthe future, when there are j<ksteps left to execute, and there is an argument va such that (j, ,.a,va) \n.T [t1] and the beliefs .c and .a are compatible, then e[va/x] looks like a computation of type t2 for \nj steps. The interpretation of .a:..t is analogous, except that we quantify over (type-level term) interpre\u00adtations \nI.K [.]. Store Satisfaction: Tracing Location Beliefs The interpretation of types as computations (Comp) \nmakes use of an auxiliary relation s :k . (given in Figure 15), which says that the store s satis.es \nlocal store description . (to approximation k). We motivate the de.nition of s :k . by drawing an analogy \nwith the speci.cation of a tracing garbage collector (see Figure 16). As described above, . corresponds \nto (beliefs about) the portion of the store directly accessible from a value (or multiple values, when \n. corresponds to .k-ed store descriptions). Hence, we can consider dom(.) as a set of root locations. \nIn the de.nition of s :k ., S corresponds to the set of reachable (root and non-root) locations in the \nstore that would be discovered by the garbage collector. The function F. maps each location in S to a \nlocal store description, while the function Fq maps each location to a quali.er. It is our intention \nthat, for each location l, Fq(l) is an appropriate quali.er and F.(l) is an appropriate local store description \nfor the value s val (l). Hence, we can consider dom(F.(l)) as the set of child locations traced from \nthe contents of l. Having chosen the set S and the functions F. and Fq,we require that they satisfy three \ncriteria. The congruity criteria en\u00adsures that our choices are both internally consistent and consistent \nwith the store s. The global store description .* combines the local store descriptions of the roots \nwith the local store descrip\u00adtions of the contents of every reachable location; the implicit re\u00adquirement \nthat .* is de.ned ensures that the local beliefs of the roots and individual store contents are all compatible. \nThe clause dom(.*)= S requires that S and F. are chosen such that S includes all the reachable locations \n(and not just some of the reachable locations), while the clause dom(s) .S requires that all of the reachable \nlocations are actually in the store. Finally, val(l)) .L.type (j,Fq ,LF.(l)Jj,s * (l)Jk ensures that \nthe contents of l, with the quali.er assigned by Fq and local store description assigned by F., is in \nthe type assigned by the global store descrip\u00adtion .* (for j<ksteps). The minimality criteria ensures \nthat our choice for the set S does not contain any locations not reachable from the roots. For exam\u00adple, \nin Figure 16, including l11 in S would not violate congruity, but would violate minimality. Finally, \nthe reachability criteria en\u00adsures that every linear and relevant location is reachable from the roots \n(and, hence, has not been implicitly discarded). Computations: Relating Current to Future Beliefs Informally, \nthe interpretation of types as computations Comp(k,.s,es,.) (see Figure 11) says that if the expression \nes (with beliefs .s, again, corresponding to the locations appearing as sub-expressions of es) reaches \nan irreducible state in less than k steps, then it must have reduced to a value vf (with beliefs .f ) \nthat belongs to the type interpretation .. More precisely, we pick a starting store ss such that ss :k \n(.s .k .r), where .r is the set of beliefs about the store held by the rest of the computation (alternatively, \nthe set of beliefs held by es s continuation). If (ss,es) steps to an irreducible con.guration (sf ,ef \n) in j<ksteps, then the following conditions D[ ] = {\u00d8}D[.,a:.] = {d[a .I] | d .D[.] .I.K[.]} G[. f ] \nd = {(k,q,{},\u00d8)}G[. fG,x:t] d = {(k,q,.,.[x.v]) |. =(.G 8k .x) . (k,qG,.G,.) .G[. fG] d.qG q. (k,qx,.x,v) \n.T [. ft : *] d.qx q} def [.; G fe: t] = .k =0..d,qG,.G,.. d .D[.] .(k,qG,.G,.) .G[. fG] d . Comp(k,.G,.(e),T \n[. ft : *] d) Figure 17. .refURAL Model (Additional Interpretations) hold. First, ef must be a value \nwith a quali.er qf and a set of beliefs .f such that (k- j,qf ,.f ,ef ) . .. Second, the following two \nsets of beliefs must be compatible: .f (what ef believes) and .r (what the rest of the computation believes \n note that these beliefs remain unchanged). Third, the .nal store sf must satisfy the combined set of \nthese beliefs. Note that since .r is an arbitrary set of beliefs compatible with .s, one instantiation \nof .r is the local store description that includes all of the shared locations of .s. By requiring that \n.f and sf are compatible with .r, we ensure that the types and quali.ers and allocation status of shared \nlocations are preserved. Judgements: Type Soundness Finally, the semantic interpreta\u00adtion of a typing \njudgement [.; G f e: t] (see Figure 17) asserts that for all k = 0,if d is a mapping from type-level \nvariables to an element of the appropriate kind interpretation, and . is a mapping from variables to \nclosed values, and .G is a local store description for the values in the range of ., then (k,.G,.(e)) \nis in the inter\u00adpretation of t as a computation (Comp(k,.G,.(e),T [t])). Our extended technical report \n[3] gives the proof of the follow\u00ading theorem which shows the soundness of the .refURAL typing rules \nwith respect to the model. THEOREM 1. (.refURAL Soundness) If .; G f e : t, then [.; G f e: t]. An immediate \ncorollary is type-safety of .refURAL. Another in\u00adteresting corollary is that if we evaluate a closed, \nwell-typed term of base type (e.g., q1\u00ae) to a value, then the resulting store will have no linear or \nrelevant references. COROLLARY 2. (.refURAL Safety) If ; f e1 : t and ({},e1) -. * (s2,e2), then either \n.v2.e2 = v2 or .s3,e3.(s2,e2) -. (s3,e3). COROLLARY 3. (.refURAL Collection) If ; f e1 : q1\u00ae and ({},e1) \n-. * (s2,v2), qual then .l . dom(s2).s2 (l) A. Proof (.refURAL Safety) Suppose ; f e1 : t and ({},e1) \n-. * (s2,e2). If \u00acirred(s2,e2), then .s3,e3.(s2,e2) -. (s3,e3). If irred(s2,e2), then .i.({},e1) -.i \n(s2,e2). Theorem 1 applied to ; f e1 : t yields [ ; f e1 : t]. [ ; f e1 : t] instantiated with i+1 = \n0, \u00d8.D [ ], and (i+1,U,{},\u00d8) .G [ ] \u00d8 yields Comp(i+1,{},e1,T [ f t : *] \u00d8). Comp(i+1,{},e1,T [ f t : \n*] \u00d8) instantiated with i<i+1, s1 :i+1 ({} .i+1 {}), ({},e1) -.i (s2,e2), def Locs s:k . = .S:2. .F. \n:S.LocalStoreDesc. .Fq :S.Quals.  let .* =(.8k l.S F.(l))in k dom(.*)=S.dom(s).S. { } .l .S. congruity \nval (l)).l.type .j<k.(j,Fq (l),lF.(l)Jj ,s(l)Jk . qual (l)=.type * { l s(l). * l .S .S. minimality dom(.).S \n.(.l .S .dom(F. (l)).S ).S=S . .l .dom(s). qual (l).l .S reachability R s Figure 15. .refURAL Model \n(Store Satisfaction) s.  l0 .(q0,T [t0]) ???  l1 .(q1,T [t1]) ??? :  l2 .(q2,T [t2]) ???  l 3 \n .   ( q 3 , T  [ t 3 ] )  ???  = dom(.)  dom(.*)=S where F.(l1) F.(l5)   ?? l7 .(q7,T \n[t7]) ? ? l4 .(q4,T [t4])??   ???? ? ? ?? etc. ? ? ??  l3 .(q3,T [t3])? ? ?       Figure 16. \ns : . Example and irred(s2,e2) yields q2 and .2 such that s2 :1 (.2 .1 {}) and (1,q2,.2,e2) .T [ ft : \n*] \u00d8. Recall that T [ ft : *] \u00d8.Type =2CandAtom. and Type .CandUberType. . . Hence, (1,q2,.2,e2) .CandAtom. \n= k=0 CandAtomk, which implies that e2 .CValues and .v2.e2 =v2. D Proof (.refURAL Collection) Suppose \n; fe1 : q1\u00ae and ({},e1) -. * (s2,v2). By the reasoning above, (1,q2,.2,v2) .T [ fq 1\u00ae : *] \u00d8, which implies \nthat q2 = q, .2 = {}, and v2 = (). Recall that s2 :1 ({}.1 {}) =s2 :1 {}=.S,F.,Fq ..... The minimality \ncriteria of s2 :1 {}instantiated with \u00d8.S, dom({}) .\u00d8, and (.l .\u00d8.dom(F.(l)) .\u00d8) yields S= \u00d8. The reachability \ncriteria of s2 :1 {} qual yields .l .dom(s2).R s2 (l) .l .\u00d8, qual which implies .l .dom(s2).s2 (l) A. \nD  4.4 Discussion A key difference in the model presented here, as compared to previ\u00adous models of \nmutable state, is the localization of the store descrip\u00adtion. Recall that we identify the local store \ndescription of a value with those locations that are directly accessible from the value. This is in contrast \nto the AAV model of unrestricted references [1, 4], where the global store description of any value describes \nevery lo\u00adcation that has been allocated. It is also in contrast to our previous model of linear references \n[23, 2], where the store description of a value describes the reachable locations from that value. The \ntransition from a global store description to a local store de\u00adscription is motivated by the insight \nthat storing a unique object in a shared reference hides the unique object in some way. Note that the \nshared reference must mediate all access to the unique object. The authors have found it hard to construct \na model where the store description of a value (in the interpretation of a type) describes the entire \nstore or even the store reachable from the value. When one attempts to describe the entire store, there \nis a dif.culty identify\u00ading where the real occurrence of a unique location is to be found. When one attempts \nto describe the reachable store, there is a dif.\u00adculty de.ning the .relation; it cannot be de.ned point-wise, \nand one is required to formally introduce the notions of directly-and indirectly-accessible locations. \nFurthermore, the reachable store is a property of the actual store, not of the type; hence, it seems \nbet\u00adter to con.ne reachability to the store satisfaction relation. We fur\u00adther note that the model of \nmutable references given in this paper subsumes the models of mutable references cited above. Hence, \nthe technique of localizing the store description subsumes the tech\u00adniques used by previous approaches. \nAlthough our model of substructural references is different from the previous model of unrestricted references, \nour model retains the spirit of the step-indexed approach used in Foundational PCC [6, 7] and may be \napplicable in future extensions of FPCC. This ap\u00adproach, in which the model mixes denotational and operational \nsemantics, offers a number of distinct advantages over a purely syntactic approach to type soundness. \nOne obvious advantage of this approach is that it gives rise to a simpler set of typing rules; note that \nour typing judgement requires neither a store description component nor a rule for locations. A less \nobvious advantage of this approach is that it gives rise to stronger meta-theoretic results. For example, \nthe impredicative polymorphism of .refURAL implies a strong parametricity theorem: an element of T [.a: \n*.t] behaves uniformly on all elements of Type, which includes elements that do not correspond to the \ninterpretation of any syntactic type. This ap\u00adproach also naturally extends to union and intersection \ntypes and to an inclusion interpretation of subtyping. Finally, a (well-founded) set-theoretic model \nmeans that soundness and safety proofs are amenable to formalization in the higher-order logic of FPCC. \nWhile we are partial to the step-indexed approach, we acknowl\u00adedge that there is no fundamental dif.culty \nin adopting a purely syntactic approach to proving the type soundness of substructural state. However, \nwe believe that any proof of type soundness must adopt many of the insights presented here. For example, \nwe conjec\u00adture that the typing rule for well-typed con.gurations would natu\u00adrally take the form: l.S \n.* =. 8F.(l) dom(.*)=S dom(s).S val(type .l .S. \u00b7;\u00b7;F.(l)fsl):.(l). qual(qual * sl)=.(l) * fs :. \u00b7;\u00b7;. \nfe :t f(s, e):t Note that the judgement fs: .mirrors the store satisfaction pred\u00adicate given in Figure \n15. The store typing component complicates the judgement .; G; . f e : t, which must further rely upon \nan operator .1 ..2 = .to split the locations in .between the store typings .1 and .2. Splitting the store \ntyping is necessary to ensure that a given unique location is used by at most one sub-expression. The \n. operator in the syntactic approach would need to satisfy many of the same properties as the .k operator \nin the step-indexed approach (e.g., identical beliefs about locations in the common do\u00admain and no unique \nlocations in the common domain).  5. Related Work Our .URAL is most directly in.uenced by the presentation \nof sub\u00adstructural type systems by Walker [30], which in turn draws upon the work of Wansbrough and Peyton-Jones \n[33] and Walker and Watkins [32]. Relative to that work, we have added both relevant and af.ne quali.ers, \nwhich is necessary to account for the var\u00adied forms of linearity found in higher-level programming-language \nproposals. A related body of work is that on type systems used to track resource usage [28, 22, 33, 21, \n16, 19]. We note that the usage subsumption found in these systems (e.g., a possibly used many times \nvariable may be subsumed to appear in a context requiring a used exactly once value) is not applicable \nin our setting (e.g., it is clearly unsound to subsume Uref t to Lref t), due to differences in the interpretation \nof type quali.ers. Section 1 noted a number of projects that have introduced some form of linearity to \ntame state. An underlying theme is that linearity and strong updates can be used to provide more effective \nmemory management (c.f. [10, 18, 9, 8]). More recent research has explored other ways in which unique \nand shared data may be mixed. For example, Cyclone s alias construct [17] takes a unique pointer and \nreturns a shared pointer to the same object, which is available for a limited lexical scope. Vault s \nfocus and CQuals s restrict constructs [14, 5] provide the opposite behavior: temporarily giving a linear \nview of an object of shared type. Both behaviors are of great practical signi.cance. Our model s semantic \ninterpretations seem strongly related to the logic of Bunched Implications (BI) [20] and Reynolds separa\u00adtion \nlogic [25]. In particular, our interpretation of \u00ae and -resem\u00adble the resource semantics for the *and \n-*connectives in BI. Finally, Boyland and Retert have recently proved the soundness of a variation of \nVault by giving an operational semantics of adop\u00adtion [11]. The authors note that adoption may be used \nto embed a unique pointer within another object; their notion of uniqueness most closely resembles our \naf.ne references, as access keys may be dropped. 6. Conclusion and Future Work We have presented the \n.refURAL-calculus, a substructural polymor\u00adphic .-calculus with mutable references of unrestricted, relevant, \naf.ne, and linear sorts. We motivated the design decisions, gave a type system, and constructed a step-indexed \nmodel of .refURAL , where types are interpreted as sets of store description / value pairs, which are \nfurther re.ned using an index representing the number of steps available for future evaluation. In previous \nwork [23, 2], we separated the typing components of a mutable object into two pieces: an unrestricted \npointer to the object and a linear capability for accessing the contents of the object. We believe that \nwe can extend the current language and model in the same way. The advantage of this approach is that \nseparating the name of a reference from what it currently holds gives us a model of alias types [27, \n31]. As noted in the previous section, allowing a unique pointer to be temporarily treated as shared \n(and vice versa) can be useful in practice. Understanding how to model these advanced features is a long-term \ngoal of this research. A promising aproach is to model regions as a linear capability to access objects \nin the region and allow changes in reference quali.ers to be mediated by this capability.  Acknowledgments \nWe would like to thank Dan Grossman, Aleks Nanevski, and Dan Wang for their helpful comments. References \n[1] Amal Ahmed, Andrew W. Appel, and Roberto Virga. An indexed model of impredicative polymorphism and \nmutable references. Available at http://www.cs.princeton.edu/~ appel/papers/ impred.pdf, January 2003. \n[2] Amal Ahmed, Matthew Fluet, and Greg Morrisett. L3: A linear language with locations. Technical Report \nTR-24-04, Harvard University, October 2004. [3] Amal Ahmed, Matthew Fluet, and Greg Morrisett. A step-indexed \nmodel of substructural state. Technical Report TR-16-05, Harvard University, July 2005. [4] Amal Jamil \nAhmed. Semantics of Types for Mutable State. PhD thesis, Princeton University, 2004. [5] Alex Aiken, \nJeffrey S. Foster, John Kodumal, and Tachio Terauchi. Checking and inferring local non-aliasing. In Proc. \nProgramming Language Design and Implementation (PLDI), pages 129 140, June 2003. [6] Andrew W. Appel. \nFoundational proof-carrying code. In Proc. Logic in Computer Science (LICS), pages 247 258, June 2001. \n[7] Andrew W. Appel and David McAllester. An indexed model of recursive types for foundational proof-carrying \ncode. ACM Transactions on Programming Languages and Systems, 23(5):657 683, September 2001. [8] David \nAspinall and Adriana Compagnoni. Heap bounded assembly language. Journal of Automated Reasoning, 31:261 \n302, 2003. [9] David Aspinall and Martin Hofmann. Another type system for in-place update. In Proc. European \nSymposium on Programming (ESOP), pages 36 52, March 2002. [10] Henry Baker. Lively linear LISP look ma, \nno garbage. ACM SIGPLAN Notices, 27(8):89 98, 1992. [11] John Tang Boyland and William Retert. Connecting \neffects and uniqueness with adoption. In Proc. Principles of Programming Languages (POPL), pages 283 \n295, January 2005. [12] James Cheney and Greg Morrisett. A linearly typed assembly language. Technical \nReport 2003-1900, Department of Computer Science, Cornell University, 2003. [13] Robert DeLine and Manuel \nF\u00a8ahndrich. Enforcing high-level protocols in low-level software. In Proc. Programming Language Design \nand Implementation (PLDI), pages 59 69, June 2001. [14] Manuel F\u00a8ahndrich and Robert DeLine. Adoption \nand focus: Practical linear types for imperative programming. In Proc. Programming Language Design and \nImplementation (PLDI), pages 13 24, June 2002. [15] Jean-Yves Girard. Linear logic. Theoretical Computer \nScience, 50:1 102, 1987. [16] J\u00a8orgen Gustavsson and Josef Svenningsson. A usage analysis with bounded \nusage polymorphism and subtyping. In Proc. International Workshop on Implementation of Functional Languages \n(IFL), pages 140 157, September 2001. [17] Michael Hicks, Greg Morrisett, Dan Grossman, and Trevor Jim. \nExperience with safe manual memory-management in Cyclone. In Proc. International Symposium on Memory \nManagement (ISMM), pages 73 84, October 2004. [18] Martin Hofmann. A type system for bounded space and \nfunctional in-place update. In Proc. European Symposium on Programming (ESOP), pages 165 179, March 2000. \n[19] Atsushi Igarashi and Naoki Kobayashi. Resource usage analysis. In Proc. ACM Principles of Programming \nLanguages (POPL), pages 331 342, January 2002. [20] Samin Ishtiaq and Peter O Hearn. BI as an assertion \nlanguage for mutable data structures. In Proc. Principles of Programming Languages (POPL), pages 14 26, \nJanuary 2001. [21] Naoki Kobayashi. Quasi-linear types. In Proc. Principles of Programming Languages \n(POPL), pages 29 42, January 1999. [22] Torben \u00c6. Mogensen. Types for 0, 1 or many uses. In Proc. International \nWorkshop on Implementation of Functional Languages (IFL), pages 112 122, 1998. [23] Greg Morrisett, Amal \nAhmed, and Matthew Fluet. L3: A linear language with locations. In Proc. International Conference on \nTyped Lambda Calculi and Applications (TLCA), pages 293 307, April 2005. [24] Peter W. O Hearn and John \nC. Reynolds. From Algol to polymorphic linear lambda-calculus. Journal of the ACM, 47(1):167 223, 2000. \n[25] John C. Reynolds. Separation Logic: A Logic for Shared Mutable Data Structures. In Proc. Logic in \nComputer Science (LICS), pages 55 74, July 2002. [26] Sjaak Smetsers, Erik Barendsen, Marko C. J. D. \nvan Eekelen, and Rinus J. Plasmeijer. Guaranteeing safe destructive updates through a type system with \nuniqueness information for graphs. In Dagstuhl Seminar on Graph Transformations in Computer Science, \nvolume 776 of Lecture Notes in Computer Science, pages 358 379. Springer-Verlag, 1994. [27] Fred Smith, \nDavid Walker, and Greg Morrisett. Alias types. In Proc. European Symposium on Programming (ESOP), pages \n366 381, March 2000. [28] David N. Turner, Philip Wadler, and Christian Mossin. Once upon a type. In \nProc. Functional Programming Languages and Computer Architecture (FPCA), pages 1 11, June 1995. [29] \nPhilip Wadler. Linear types can change the world! In Programming Concepts and Methods, April 1990. IFIP \nTC 2 Working Conference. [30] David Walker. Substructural type systems. In Benjamin Pierce, editor, Advanced \nTopics in Types and Programming Languages, chapter 1, pages 3 43. MIT Press, Cambridge, MA, 2005. [31] \nDavid Walker and Greg Morrisett. Alias types for recursive data structures. In Proc. Workshop on Types \nin Compilation (TIC), pages 177 206, September 2000. [32] David Walker and Kevin Watkins. On regions \nand linear types. In Proc. International Conference on Functional Programming (ICFP), pages 181 192, \nSeptember 2001. [33] Keith Wansbrough and Simon Peyton-Jones. Once upon a polymor\u00adphic type. In Proc. \nPrinciples of Programming Languages (POPL), pages 15 28, January 1999.  \n\t\t\t", "proc_id": "1086365", "abstract": "The concept of a \"unique\" object arises in many emerging programming languages such as Clean, CQual, Cyclone, TAL, and Vault. In each of these systems, unique objects make it possible to perform operations that would otherwise be prohibited (e.g., deallocating an object) or to ensure that some obligation will be met (e.g., an opened file will be closed). However, different languages provide different interpretations of \"uniqueness\" and have different rules regarding how unique objects interact with the rest of the language.Our goal is to establish a common model that supports each of these languages, by allowing us to encode and study the interactions of the different forms of uniqueness. The model we provide is based on a substructural variant of the polymorphic &#955;-calculus, augmented with four kinds of mutable references: unrestricted, relevant, affine, and linear. The language has a natural operational semantics that supports deallocation of references, strong (type-varying) updates, and storage of unique objects in shared references. We establish the strong soundness of the type system by constructing a novel, semantic interpretation of the types.", "authors": [{"name": "Amal Ahmed", "author_profile_id": "81100287263", "affiliation": "Harvard University", "person_id": "P414176", "email_address": "", "orcid_id": ""}, {"name": "Matthew Fluet", "author_profile_id": "81100181338", "affiliation": "Cornell University", "person_id": "PP17009813", "email_address": "", "orcid_id": ""}, {"name": "Greg Morrisett", "author_profile_id": "81339518683", "affiliation": "Harvard University", "person_id": "PP43136279", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086376", "year": "2005", "article_id": "1086376", "conference": "ICFP", "title": "A step-indexed model of substructural state", "url": "http://dl.acm.org/citation.cfm?id=1086376"}