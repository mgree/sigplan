{"article_publication_date": "09-12-2005", "fulltext": "\n Type Inference, Principal Typings, and Let-Polymorphism for First-Class Mixin Modules * Henning Makholm \nJ. B. Wells Technical University of Denmark Heriot-Watt University http:// henning.makholm.net/ http:// \nwww.macs.hw.ac.uk/~jbw/ Abstract A mixin module is a programming abstraction that simultaneously generalizes \n.-abstractions, records, and mutually recursive de.ni\u00adtions. Although various mixin module type systems \nhave been de\u00adveloped, no one has investigated principal typings or developed type inference for .rst-class \nmixin modules, nor has anyone added Milner s let-polymorphism to such a system. This paper proves that \ntypability is NP-complete for the naive approach followed by previous mixin module type systems. Be\u00adcause \na .-calculus extended with record concatenation is a simple restriction of our mixin module calculus, \nwe also prove the folk be\u00adlief that typability is NP-complete for the naive early type systems for record \nconcatenation. To allow feasible type inference, we present Martini, a new system of simple types for \nmixin modules with principal typings. Martini is conceptually simple, with no subtyping and a clean and \nbalanced separation between uni.cation-based type inference with type and row variables and constraint \nsolving for safety of linking and .eld extraction. We have implemented a type inference algo\u00adrithm and \nwe prove its complexity to be O(n2),or O(n) given a .xed bound on the number of .eld labels.1 To prove \nthe complex\u00adity, we need to present an algorithm for row uni.cation that may have been implemented by \nothers, but which we could not .nd written down anywhere. Because Martini has principal typings, we successfully \nextend it with Milner s let-polymorphism. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: \nLanguage Constructs and Features Data types and struc\u00adtures; modules, packages; polymorphism General \nTerms Design, theory, algorithms Keywords Type systems, mixin modules, record concatenation, row uni.cation, \npolymorphism * Supported by EC FP5/IST/FET grant IST-2001-33477 DART , and Sun Microsystems equipment \ngrant EDUD-7826-990410-US. Work done while at Heriot-Watt University. 1 Technically, there is also a \nfactor of a(n),but a(n) = 4 for n < 1010100 (a googolplex ). Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 05 September 26 28, 2005, Tallinn, Estonia. \nCopyright c . 2005 ACM 1-59593-064-7/05/0009. . . $5.00. 1. Introduction The goal of this work is to \nproduce a type system for .rst-class mixin modules that would have principal typings and thus support \ncompositional type analysis. As a programming tool, .rst-class mixin modules are aimed not only at programming-in-the-large \nissues such as generic modules and dynamic linking, but also at programming-in-the-small issues, because \nthey combine the features of .-abstractions (.rst-class functions), records, environments with mutually \nrecursive de.ni\u00adtions, and namespaces [31]. A mixin module consists of named components; some are exports \nthat the module de.nes for other modules, some are imports to be supplied by other modules, and some \nare locals, i.e., private to the module. Once all imports are satis.ed by linking modules, the exports \ncan be extracted. Linking is symmetric: when A and B are linked together, A s ex\u00adports can satisfy B \ns imports and vice versa. For example, consider the following two modules, where N(g, i) stands for some \nexpres\u00adsion containing the identi.ers g and i and so forth for O, P, Q: A = {[export f = N(g, i); import \ng, h; local i = O(h)]} B = {[import f; export g = P(f, i); local i = Q]} Linking A and B produces this \ncombined module: A . B = {[export f = N(g, j), g = P(f, k); import h; local j = O(h), k = Q]} Because \nthe local de.nitions of i in A and B are independent, they (or at least one) must be renamed in A . B \nto avoid con.icts. Also note that f and g in the linked module are mutually recursive, though no recursion \nis apparent in A or B alone. This behavior is like compilation unit linking in C (and indeed, most languages) \nand is quite different from the asymmetric link\u00ading of the ML family s structures and functors. However, \nunlike C modules , the mixin modules we investigate are .rst-class, i.e., they can be stored in data \nstructures, passed as arguments, returned as results, nested using variables that are in scope, etc., \nand which modules are linked may depend on arbitrary run-time computa\u00adtions. In fact, modern programs \nin C and other languages do dy\u00adnamically link modules at run-time (sometimes entire libraries that are \nalso loaded at run-time). However, this is generally outside the language de.nitions and the type systems \ndo not prevent linking failures due to missing or multiple de.nitions for a name. We focus instead on \na strongly typed situation with better static guarantees. Type analysis is compositional when each program \nfragment s analysis result does not depend on its lexical context. Composition\u00adality simpli.es type inference \nalgorithms and helps with issues like separate compilation and accurate type error reporting. The main \nproblem in compositional type inference for mixin modules is en\u00adsuring that the type system contains \nprincipal typings for expres\u00adsions like .xy. x . y, which links two unknown modules. In this ex\u00adample, \nthe type system must not allow modules given as x and y to both export the same name. But to be compositional, \nwe must ana\u00adlyze .xy.x.y without any knowledge about its eventual arguments. The problem for mixin modules \nis similar to compositional analysis of calculi with record concatenation. Records are the spe\u00adcial case \nof mixin modules with no imports and no internal recur\u00adsion, and record concatenation is just a special \ncase of linking mixin modules. The fundamental problem in analyzing record concatena\u00adtion turns out to \nbe similar to that for linking mixin modules, al\u00adthough mixin modules have more complications. Record \nconcate\u00adnation has been intensively investigated as a potentially useful pro\u00adgramming feature and also \nas one possible way to model object\u00adoriented multiple inheritance. (Note that type inference for record \nconcatenation is much harder than single-.eld record extension.) Our approach to types for mixin modules \nis inspired in some re\u00adspects by previous work on type inference for record concatenation. However, we \ncould not build directly on a type system for record concatenation, because the most successful such \nsystems use sub\u00adtyping polymorphism. For technical reasons, we .nd this undesir\u00adable for mixin modules; \nfor example, we would need different type rows for a module s imports and exports, which is problematic \nin our favored family of mixin module calculi where the externally visible names of imports and exports \nuse the same namespace. Thus, while our type system Martini for mixin modules has some features in common \nwith record concatenation systems, it also exhibits interesting properties of its own which become ap\u00adparent \nwhen it is restricted to work with a .-calculus with records. The restriction, which we call Bowtie, \ndoes not type as many terms as some previous systems, but it has some other advantages, among which is \na fast and conceptually simple type inference algorithm, which runs in almost linear time. In contrast, \namong record con\u00adcatenation type inference algorithms with complexity analyses, the next best runs in \ncubic time [19]. Along the way to our main goal, we prove that the most obvious straightforward systems \nof simple types for mixin modules and record concatenation have NP-complete typability problems. Martini \n(and its restriction Bowtie) has principal typings [29], which is a precondition for compositional analysis \nand is also needed for adding Milner s let-polymorphism. Principal typings should not be confused with \nthe weaker notion of principal types which is usually all that remains after let-polymorphyism is added. \nMartini is a simple type system that does not yet include poly\u00admorphism, which is needed for a serious \nstrongly typed language. We present the simply typed version Martini .rst, because the ma\u00adchinery of \npolymorphism would obscure the novel features that handle mixin module linking. Sect. 7 shows how to \nextend Martini to Martini. that has Milner s let-polymorphism, as used in ML and other languages. This \nought to be enough to support programming\u00adin-the-small. For programming-in-the-large, further work is \nneeded to add to Martini encapsulation and parameterization capabilities like those of the ML module \nlanguage. Our type inference implementation for Martini can be found at (URL:http://www.macs.hw.ac.uk \n/ DART / software / Martini / ) as a web application and as source code. 2. Notation These notations \nare fairly standard: A function f is a set of pairs, where we write each pair in the form a. b , such \nthat {(a . b),(a.c)}. f implies b = c. In this section, let f and g range over functions and let A and \nB range over sets. The domain of f is Dom f = {x |(x .y) . f }. The range of f is Rng f = {y |(x = {x.y \n|(y. x) . f }. . y) . f }. The inverse of f is f -1 The expression f (A) is { f (a) | a . A nDom f } \nif A ./Dom f . Composition is given by ( f .g)(x)= f (g(x)). P (A) is the set of  See Section 2 for \nsome essential notation used here, such as \u00b7 , .n., E,# , et cetera. Variables: x ::= x |y |z | \u00b7\u00b7\u00b7 Field \nlabels: e::= f0 |f1 |f2 | \u00b7\u00b7\u00b7 Label sets: L . P.n( e ) External parts: E . e .n inj. x Internal parts: \nI . x .n. M Values: V ::= {[E;I]}Terms: M,N ::= V |x |M .N |M.e |M \\ L To be closer to the notation in \nearlier module calculi, we allow writing E functions as e1 Cx1,...,en Cxn instead of {e1 . x1,...,en \n. xn} and I functions as y1 = N1,...,yk = Nk instead of {y1 .N1,...,yk .Nk} . M '.M' M .N '.M'.N RC1 \nN '.N' M .N '.M .N' RC2 M '.N M.e '.N.e RCdot M '.N M \\ L '.N \\ L RChide FV(Rng I1) # X2 X1 # X2 FV(Rng \nI2) # X1 where Xi = Rng Ei .(Dom Ii \\Rng E) for i = 1,2 {[E EE1;I1]}.{[E EE2;I2]}'.{[E EE1 EE2; I1 EI2]} \nRLink Rng E .Dom I S = {x .{[f Cx;I]}.f |x .Dom I }{[E;I]}.e '.[S](I(E(e))) RExtract Dom E1 # L Dom E2 \n.L Rng E2 .Dom I {[E1 EE2; I]}\\\\L '.{[E1;I]} RHide Figure 1. Syntax and semantics of the m-calculus \nall subsets of A. The set difference A \\B is {a . A |a . B}. The disjoint union A tB is A.B if AnB = \n\u00d8, and unde.ned otherwise. These notations are less common: For any metavariable symbol X, X is the set \nthat X ranges over. P.n(A) is the set of all .nite subsets of A. The statement A # B abbreviates A nB \n= \u00d8. The expression A .n.B is the set of all .nite functions f .A \u00d7B, and A .n .B is the set of all injective \nfunctions in A .n.B. The expression injf Eg means f .g if Dom f # Dom g, and is unde.ned otherwise. If \nX is a set of syntactic entities that can contain (concrete) variables in the set .  , then any (partial \nor total) function f from to can be used as a substitution. The application of f to an entier X is de.ned \nin the usual way by recursive descent through X, replacing each variable x by f (x) whenever x . Dom \nf and renaming bound variables in X as needed to avoid name capture. We identify syntactic entities modulo \nrenaming of bound variables. We sometimes enclose f in square brackets (like [ f ]) in order to emphasize \nthat it is being used as a substitution. This happens in particular when f is given by listing its elements, \nin which case we omit the set braces and write just [x1 .X1,...,xn.Xn].  3. The m-calculus of mixin \nmodules Our goal is to create a type system with compositional type in\u00adference for the simple mixin module \ncalculus de.ned in Figure 1, called the m-calculus. Its syntax is essentially isomorphic to that of the \nm-calculus of Wells and Vestergaard [31]. The key difference is a simpli.ed call-by-name semantics, because \nthe more sophisti\u00adcated semantics (and equational theory) of the m-calculus are irrel\u00adevant for the typing \nissues this paper investigates. Hirschowitz et al. [13] give a similar calculus with a call-by-value \nsemantics. The m-calculus is in a family of mixin module calculi where imports and exports share a single \nnamespace; an alternative family with separate import and export namespaces starts from CMS [4]. The \nbasic construct is a mixin module, written {[E; I]}, where E (the external part) maps .eld labels to \nvariables and I (the internal part) maps variables to terms. The module expression {[e1 Cx1,...,en Cxn; \ny1 = N1,...,yk = Nk]} binds all of the vari\u00adables x1 to xn and y1 to yk within the Ni s. Thus the free \nvariables (S) of {[E; I]} are FV({[E; I]})= N.Rng I FV(N)\\(Rng E .Dom I) and all other cases of FV(M) \njust collect free variables componen\u00adtwise. Each bound name x falls in one of three classes: (eCx) . \nE is an import with external name e and internal name x iff there is no (x = N) . I. When the module \nis linked with a module that has an export with name e, references to x in the Ni s become bound to the \nexported expression.  (eCx) .E together with (x = N) .I is an export. The exported expression N can \nbe used from outside via the .eld extraction operation M.e, but only once all imports have been satis.ed \nvia linking. Then N will be evaluated in the context of the other de.nitions in I. The exported term \nN can satisfy imports of the name eby other modules via linking. The internal name x can be mentioned \nin all of the Ni s, and the de.ned value can thereby be directly or indirectly recursive.  (x = N) .I \nis a local iff there is no (eCx) .E. Local de.nitions can be used in all of the Ni s. They can be directly \nor indirectly recursive, but are not observable outside their containing mod\u00adule except by being referred \nto by an export.  Field labels (i.e., external names) are .xed, but bound variables (i.e., internal \nnames) are subject to a-conversion (which must keep them distinct from other bound variables of the same \nmodule) and the actual names of the bound variables are not visible outside the module expression. We \nidentify a-equivalent terms. The fundamental mixin operation is linking, written M1 .M2. Its reduction \nrule RLink is intuitively simple; linking two mod\u00adules puts their internal parts side by side (choosing \nappropriate a\u00advariants to avoid wrong name captures), and joins their external parts. The rule divides \neach of the two incoming external parts into a common part E and a separate part Ei. The separate parts \nare un\u00adtouched by the linking. The linking happens in the common part E, containing the labels mentioned \nby both operands; such labels can\u00adnot be in E1 and E2, because then E1 E E2 would be unde.ned on the \nright-hand side (RHS) of the rule RLink. A label occur\u00adring in E maps to the same internal name in both \noperands; this is always possible by a-conversion. No label can be exported by both operands; otherwise \nI1 EI2 would be unde.ned on the RHS of RLink. A label exported by one module and imported by the other \nis forced by the common E to have the same internal name (vari\u00adable) in both operands, so importing variable \nreferences in one Ii can become bound to de.nitions from the other after the linking. The premises of \nRLink ensure that wrong name captures do not occur. Xi is the set of internal names in operand i that \ndo not participate in the link. The names in Xi will be bound on both sides post-linking, so they must \nbe disjoint from the other side s internal names and free variables. For example, the linking {[f Cx,g \nCy; y = x]}.{[h Cz; x = 13,z = x -6]} (where the com\u00admon E is empty) does not proceed with the shown \na-variants of the operands because of the premise X1# X2 where both sets contain x. Without this premise, \nthe result would be a module that (wrongly) exported 13 as f. To avoid this, the rule forces us to .rst \na-convert one or both of the x s. Another example needing a-conversion is {[f Cx; x = 42]}.{[g Cy; y \n= x]} where the x on the left must be a-renamed to avoid wrongly capturing the (free) x on the right. \nThe .eld extraction rule RExtract extracts the export with the given label while unfolding into the .eld \nbody the implicit letrec of the module M to achieve call-by-name semantics. The hiding operator M \\ L \nremoves exported .elds if they exist in the operand. A hidden export turns into a local because the internal \npart I is kept unchanged. If none of the .elds in L are exported or imported the hiding is simply a no-op. \nIt is a run-time error to try to link two modules that both export the same label e, as well as to try \nto extract a .eld from a module that does not export it or has imports, or to try to hide an import. \nOur task is designing a type system that prevents these errors while also allowing compositional type \ninference. 3.1 Syntactic sugar for mixin modules and records The representation of a mixin module as \nseparate E and I parts is formally convenient in that it allows our type and reduction rules to be stated \nrelatively compactly. However, it is not very intuitive for actual programming, so our implementation \nalso supports a more readable notation (which we have used already in the example in the introduction): \nValues: V ::= \u00b7\u00b7\u00b7 |{[.1;...;.k]} Module groups: . ::= import e1 Cx1,...,ek Cxk | export e1 Cx1 = M1,...,ek \nCxk = Mk | local x1 = M1,...,xk = Mk The construct {[.1;...; .k]} is sugar for {[[.1]E E\u00b7\u00b7\u00b7E[.k]E; [.1]I \nE\u00b7\u00b7\u00b7E[.k]I]}, where [import e1 Cx1,...,ek Cxk]E = {ei .xi |1 =i =k }[export e1 Cx1 = M1,...,ek Cxk = \nMk]E = {ei .xi |1 =i =k }[local x1 = M1,...,xk = Mk]E = \u00d8 [import e1 Cx1,...,ek Cxk]I = \u00d8 [export e1 \nCx1 = M1,...,ek Cxk = Mk]I = {xi .Mi |1 =i =k }[local x1 = M1,...,xk = Mk]I = {xi .Mi |1 =i =k } and \nwhere it is required that Rng [.i]E # Dom [.j]I for i = j. (Note that syntactic correctness of the result \nfollows from implicit constraints imposed by the de.nition of E and the fact that each mixin external \npart E is a bijection.) For additional compactness, eCx in import and export groups can be written as \njust e if x and e are textually identical (even though they belong to different namespaces). We further \nde.ne a fourth form of module group (distinguished by its lack of keyword): . ::= \u00b7\u00b7\u00b7|e1 = M1,...,ek \n= Mk, which is syntactic sugar for export e1 Cy1 = M1,...,ek Cyk = Mk , where the yi s are chosen fresh. \nThis allows modules that have neither imports nor local de.nitions nor internal references to their own \nexports to be written with a record-like syntax. For example, the record-like expression {[f = 5, g = \ntrue]}abbreviates {[export f Cx = 5, g Cy = true]}, which in turn ab\u00adbreviates {[f Cx,g Cy; x = 5,y = \ntrue]}, which .nally abbreviates {[{f .x,g .y};{x .5,y .true}]}.  3.2 Encoding of the .-calculus The \nreader may wonder how interesting the m-calculus is given that its only data constructor is the mixin \nmodule. It is natural to assume that one would need an additional language layer for manipulating mixin \nmodules programatically. However, this turns out to be unneeded, because we can encode the .-calculus \nusing only mixin constructions. A function .x.M can be represented as Rows: S . e .n. t Types: t ::= \na | b | c | ... |{[S /L ]}Environments: G . x .n. t Typings: T ::=(G lt) x : (G lG (x)) Dom G =Rng E \n.Dom I I(x): (G0 EG lG (x)) for all x .Dom I L =E-1(Dom I) (G .E)=S {[E;I]}: (G0 l{[S /L ]}) M : (G l{[S \n/ L ]}) L =Dom S M.e : (G lS(e)) L1 # L2 M : (G l{[S ES1 / L1 ]}) N : (G l{[S ES2 / L2 ]})M .N : (G l{[S \nES1 ES2 /L1 .L2 ]}) M : (G l{[S1 ES2 / L ]})Dom S1 # L0 Dom S2 .(L0 nL) M \\ L0 : (G l{[S1 / (L \\L0)]}) \nLemma 4.2. M . N : (G l t) iff there exists a type t ' such that both M : (G lt ')and N : (G lt ).  \nFigure 2. Riviera: Naive simple types for the m-calculus {[import arg Cx; export res Cy =M]}, and an \napplication NM as (N .{[export arg Cy =M]}).res, where arg (argument) and res (result) are globally .xed \nlabels and in both cases we choose y ./FV(M). It is easy to see that an application of RLink followed \nby a number of RExtract will simulate a \u00df-reduction in the .-calculus. This is not a new result [31, \n4], but is essential for understanding how the m-calculus can be used. We will freely use this translation \nas syntactic sugar in examples and constructions. Let .. denote the fragment of m-calculus that can be \nwritten using only the constructions from the following grammar, some of which use the syntactic sugar \nfor .-calculus and records: M ::=.x.M |MN |{[e1 =M1,...,ek =Mk]}|M1 .M2 |M.e We will use .. when comparing \nMartini with earlier record con\u00adcatenation type systems.  4. Riviera: Naive simple types for mixin \nmodules A natural .rst attempt at de.ning a (Curry-style) simple type sys\u00adtem for the m-calculus is the \nnaive type system called Riviera shown in Figure 2. Following [29], we write typing judgements as M : \n(G lt) rather than using the older convention of G lM : t . A Riviera type has the shape {[S /L ]}where \nL .Dom S, and denotes a module that exports every label in L and imports every label in (Dom S)\\L, with \nthe types of the exports and imports given by the row S. (In the context of Riviera, a row is just a \n.nite map from labels to types. Later in our type system Martini in Section 5 we will consider partially \nunknown rows, which will use different metavariables.) Of course, we could equally well have written \n{[S1 .S2]}where S1 and S2 partition the .eld types into imports and exports, but the {[S /L ]}syntax \nmakes the typing rules more compact (and we do not intend to actually use Riviera as we will prove it \nhas unfeasible type inference). An expression written with the syntactic sugar .x.M de.ned in Section \n3.2 will always have a type that can be written {[{arg . t1,res .t2}/ {res}]}. We will abbreviate such \na type t1 .t2. 4.1 Typability in Riviera is NP-hard Riviera can be proven sound (i.e., programs it accepts \ndo not go wrong ), but that about exhausts its nice formal properties. In particular, even though it \nis only at the level of simple types, type inference is provably hard. Theorem 4.1. Typability2 for Riviera \nis NP-complete. We de.ne the construction that proves this in several stages. Let M . N abbreviate (.x.N) \nM, and let M ~N abbreviate (.x.(xM).(xN))(.y.y), where for both we choose x ./FV(MN). Lemma 4.3. M ~N \n: T if and only if M : T and N : T. Call canonical the following two .xed types: Off ={[\u00d8 / \u00d8 ]}and On \n={[{a .{[\u00d8 /\u00d8 ]}}/ {a}]}. Let Nand(x1,...,xn)abbre\u00ad () viate .y1 ....yn.(y1 .x1).a .\u00b7\u00b7\u00b7.(yn .xn).a.b. \nLemma 4.4. In an environment that maps each xi to a canonical type, Nand(x1,...,xn)has a type iff the \ntype of some xi is Off. Let P(x,y)=Nand(x,y). (x .y)~(y .x)~{[a ={[\u00d8]}]}. Lemma 4.5. P(x,y)has a type \nexactly in environments where one of x and yhas type Off and the other has type On. We will be reducing \nfrom Boolean formula satis.ability, so let a countable set of Boolean variables P be given, and select \na .xed correspondence that assigns a unique m-calculus variable vP to each Boolean variable. An environment \nnaturally corresponds to a Boolean valuation for those P such that it assigns vP either type On or Off. \nThe corresponding valuation makes P true if vP has type On and false if vP has type Off. Now de.ne a \ntranslation from formulae to terms by [P]=.t..f.P(t,f).vP ~t [\u00acA]=.t..f.[A]ft [A .B]=.t..f..t1..f1..t2..f2. \nP(t,f). [A]t1 f1 . [B]t2 f2. Nand(t1,f). Nand(t2,f). Nand(t,f1,f2) [A .B]=[\u00ac(\u00acA .\u00acB)] Lemma 4.6. [A] \nhas a type exactly in environments that corre\u00adspond to valuations for A s variables. The types of [A]in \nsuch an environment have the shape On .Off .t if A is true under the corresponding valuation and Off \n.On .t if A is false. (There may be one or more t s that can appear in a valid type for [A].) Proof. \nBy a straightforward induction over the structure of A. Proof of Theorem 4.1. It is clear that typability \nis in NP; given an oracle which tells for each variable which .elds its type imports and exports, type \ninference is like for the simply typed .-calculus. For NP-hardness, we reduce from satis.ability of arbitrary \nBoolean formulae. A formula A is satis.able exactly if the term MA =[A]tf . Nand(f)is Riviera-typable. \nIt follows from Lem\u00adma 4.6 that any typing for MA implies a satisfying truth assignment for A. Conversely, \nany satisfying truth assignment corresponds to an environment G such that [A]: (G lOn .Off .t) for some \nt. From there one easily gets MA : (G ,t : On,f : Off lt ). 4.2 Asymmetric variants In a calculus with \nasymmetric linking, M .N succeeds even when M and N both de.ne some label e, in which case the result \nwill use the de.nition from N. One can construct a Riviera-like type system RivieraA for such a calculus \nby replacing the .typing rule with: 2 Typability means deciding for a given term M whether there exists \na typing T such that M : T . Note that specifying the G part of T would not make the problem easier: \none can just abstract over M s free variables and set G =\u00d8. Dom S11 = L1 nL2 M : (G l{[S ES1 ES11 / L1 \n]}) N : (G l{[S ES2 / L2 ]})M .N : (G l{[S ES1 ES2 / L1 .L2 ]}) Another possible variant of linking allows \nasymmetric linking, but requires that a .eld that is de.ned in both linked modules must have the same \ntype even though at run-time one of them is discarded. This gives rise to a Riviera variant with this \nlinking rule: M : (G l{[ S ES1 / L1 ]}) N : (G l{[S ES2 / L2 ]})M .N : (G l{[S ES1 ES2 / L1 .L2 ]}) We \ncall this variant join-like, and name it RivieraJ, because the type behavior of this rule is identical \nto the type-level behavior of the join operator N in relational algebras [15, 25]. It is not common for \nmodules or records (an exception is the Church-style calculus of [32]), but we mention it to highlight \nthe similarities between type problems in relational calculi and in calculi with concatenation and linking. \nFurther, the simplest variation of our system Martini (introduced later in Section 5) which allows overwriting \nlinking would have a join-like typing rule. Theorem 4.7. Typability for RivieraA and RivieraJ is NP-complete. \nThe proof for Theorem 4.1 has been constructed to work verba\u00adtim for RivieraA and RivieraJ. (This does \nmake it more complex, however. Simpler constructions for Riviera and RivieraA can be found in the long \nversion of this paper [14]). 4.3 Other calculi Riviera is very similar to Typed CMS as de.ned by Ancona \nand Zucca [4], except that Typed CMS is a Church-style system with mandatory type annotations in terms. \nThere are also minor differ\u00adences, such that the fact the CMS has different namespaces for import and \nexport labels, and uses a special freeze operator to connect imports with exports. However, the proof \nof Theorem 4.1 does not use imports at all, except in the syntactic sugar for trans\u00adlating . abstractions. \nIf one uses the . translation for CMS (de.ned in [4]), our proof directly yields NP-completeness of typability \nin the Curry-style variant of Typed CMS (i.e., Typed CMS with type annotations removed), a previously \nunknown result. We believe our proof of NP-completeness of typability can also be adapted to the implicitly \ntyped systems CMSv [12], MM [13] and Mix [11], although we have not checked this formally. If one restricts \nRivieraA to (asymmetric) .., one gets a type system equivalent to Wand s type system for record concatena\u00adtion \n[28]. Because the proof of Theorem 4.1 uses only the .. frag\u00adment of the m-calculus, we get as a bonus \nresult a direct proof of the folk belief that typability in Wand s system is NP-hard. 4.4 Discussion \nNP-completeness may not sound bad when one compares it to the familiar result that typability for the \nHindley/Milner type system is DEXPTIME-complete. However, it should be kept in mind that Riviera is a \nsimply typed system where polymorphism has yet to be added. Thus the proper comparison would be the simply \ntyped .-calculus, where typability is almost linear (i.e., O(na(n))). Our result suggests that type inference \nfor mixin modules is hard independently of the details of the calculus. A feasible type system for mixin \nmodules (or record concatenation) must introduce complications that are not aimed solely at strengthening \nthe type system itself (in the sense of enlarging the set of typable programs) but serve to make type \ninference a tractable problem. A related result was achieved by Palsberg and Zhao [16], who prove NP-completeness \nof typability for a typed object calcu\u00adlus with symmetric record concatenation and subtyping. It is not \nclear to us whether this proof can be easily adapted to record\u00adconcatenation type systems without subtyping. \nVansummeren [25] proved NP-completenes of typability in various fragments of a naively typed relational \nalgebra. Ohori and Buneman [15] proved NP-completeness of typability in a lambda calculus with primitive \nsets of records and join operator. Their system is de.ned in terms of constraints, but appears to be \nequivalent in expressive power to a RivieraJ-like type system.  5. Martini: A better type system for \nmixin modules Figure 3 show our type system Martini for the m-calculus. It is de\u00adsigned to simultaneously \nreach two goals in addition to the usual basic safety. (1) It should have feasible type inference. (2) \nIt should have principal typings [29], which are needed to express intermedi\u00adate results in a compositional \ninference algorithm using Martini s own type language. Also, principal typings allow adding Milner s \nlet-polymorphism (as we do in Section 7). A mixin module type in Martini has the shape {[R / Q .S ]}, \nwhere Q represents the set of import labels and S represents the set of export labels. The row R gives \nthe type of both inputs and outputs, like S in Riviera; however a Martini row may de.ne types for .elds \nthat the module neither imports nor exports. For example, given obvious extensions with integers and \nbool\u00adeans, the term M = {[f C x,g C y; x = y > 5]} has the typing (\u00d8 l {[f:bool, g:int, r / {g}.{f}]}| \n\u00d8) (r is a row variable whose role will be described shortly). This is also a typing for N = {[f C x; \nx = true]}, even though N does not import g it is allowed for a Q to overapproximate the true set of \nimports. This allows construc\u00adtions such as if \u00b7\u00b7\u00b7then M else N to be typed without requiring a dummy \nimport of g in N. In Riviera it was essentially an arbitrary choice to use a single row for imports as \nwell as exports. In contrast, the same decision in Martini is essential for our type inference strategy. \nIn order to facilitate type inference with principal typings, the three parts R, Q and S of a mixin type \n{[R / Q.S ]} have a more elaborate internal structure than the monolithic S and L of Riviera in particular, \neach part can be a variable. Wand [26] introduced row variables for manipulating partial knowledge about \nmappings from .eld labels to types. Using the same row variable at the end of different row expressions \ncan express that the two rows agree at some but not all labels, as happens in the rule THide. Adding \nmore .elds to the row part of a module type does not change the type s meaning if the set expression \npart stays the same. Therefore Martini needs no syntax for an empty row ; a row variable can always be \nused for this. Typings now contain constraint sets, which assert relations be\u00adtween label sets that are \nnot known yet. As a concrete example, the term {[import f C x,g C y; h = x .y]} has the Martini typing \n. . f:{[r / q1 .s1 ]}, s3 = s1 ts2, l{[.g:{[r / q2 .s2 ]}, . / {f,g}.{h}]} q3 .q1 \\s2,. h:{[r / q3 .s3 \n]}, r0 q3 .q2 \\s1 The recurrence of r in all three .eld types means that if one of the imports contains \na .eld e at all, its type must be the same as that expected for e in the result. The constraint s3 = \ns1 ts2 says that every .eld de.ned in the result must be de.ned in exactly one of the arguments. This \nparticular typing is not principal; Martini also allows the term to have the type {[ \u00b7\u00b7\u00b7/ {f,g, k}.{h}]}even \nthough it does not import k. A principal typing for the term would have {[\u00b7\u00b7\u00b7/ q .{h}]} as its type part \nand an extra constraint q .{f, g}. Martini s strategy for escaping the NP-hardness of Riviera is to consider \nthe constraint s3 = s1 ts2 good for as long as we have no information about s1 or s2, regardless of whether \ninformation Type variables: a ::= a | b | c | ... Row variables: r ::=r0 |r1 |r2 | \u00b7\u00b7\u00b7 Import set variables: \nq ::=q0 |q1 |q2 |\u00b7\u00b7\u00b7 Export set variables: s ::=s0 |s1 |s2 | \u00b7\u00b7\u00b7 Type rows: R ::=r |e:t, R Import set \nexpressions: Q ::=q |L Export set expressions: S ::=s |L |. Types: t ::=a |{[R / Q.S ]}Environments: \nG . x .n. t Constraints: c ::=S =S1 tS2 |S =S1 \\L | Q .Q1 \\S |Q # L Const. sets: C . P.n(c ) Typings: \nT ::=(G lt |C) We forbid as ill-formed rows that de.ne any label e more than once and we consider types \n(etc.) modulo this row structure equation: (e1:t1,e2:t2, R)=(e2:t2,e1:t1, R) when e1 =e2 For S ={e1 .t1,...,en \n.tn}. e .n. t , let S R abbreviate e1:t1,...,en:tn, R. Let S1 =S2, Q1 .Q2, and Q .S abbreviate the constraints \nS1 =S2 t\u00d8, Q1 .Q2 \\\u00d8, and \u00d8 .Q \\S, respectively. We allow omitting the set braces around concrete environments \nand constraint sets in typings. Let T range over type substitutions, which are functions that map q to \nQ , s to S , r to R , and a to t , such that only .nitely many variables do not map to themselves. Type \nsubstitutions are extended componentwise to map each of the classes Q , S , R , t , G , c , C , and T \nto itself. A constraint c is solved, written Ic,iff either c is a true statement of set theory (L =L1 \ntL2 is true iff L =L1 .L2 and L1 # L2) or c contains .to the right of the relation sign (that is, to \nthe right of =, .,or .). Let IC abbreviate .c .C : Ic, and let C1 . C2 abbreviate .T : IT (C1).IT (C2). \nWrite t1 t2 iff t1 and t2 are identical except for import and export set expressions. Let C . t1 =t2 \nabbreviate t1 t2 ..T : IT (C).T (t1)=T (t2). Let C . G1 =G2 mean that Dom G1 =Dom G2 and C . G1(x)=G2(x)for \nx .Dom G1. C . G (x)=t x : (G lt |C) TVar Dom G =Rng E .Dom I I(x): (G0 EG lG (x)|C) for all x .Dom I \nL =E-1(Dom I) L' =Dom E \\L C . {Q .L' , S =L}{[E;I]}: (G0 l{[(G .E) R /Q.S ]}|C) TMixin M : (G l{[R / \nQ1 .S1 ]}|C) N : (G l{[R / Q2 .S2 ]}|C)C . {Q .Q1 \\S2, S =S1 tS2, Q .Q2 \\S1}M .N : (G l{[R /Q.S ]}|C) \nTLink M : (G l{[e:t , R / \u00d8 .S ]}|C) C . {{e}.S}M.e: (G lt |C) TExtract Dom S1 =Dom S2 =L M : (G l{[S1 \nR /Q.S1 ]}|C) C . {Q # L, S2 =S1 \\L}M \\ L : (G l{[S2 R / Q.S2 ]}|C) THide Figure 3. Our type system \nMartini for the m-calculus about s3 shows up later. Thus, e.g., .x.(x .x).f is typable in Mar\u00adtini even \nthough there is no value that it can safely be applied to. This is still sound, as Martini will reject \nattempts to actually call it. Thus, Martini does not reject some nonsensical (but dynamically safe) programs \nas type errors, but also escapes NP-hardness of typability. Theorem 4.1 depends on being able to ask \nthe type system: Can any possible call to this function be proved error\u00adfree? . Martini refuses to answer \nuntil we re.ne the question to Will this particular call be error-free? . The term .x.(x .x).f has a \nprincipal typing with the shape (\u00d8 l{[arg:{[f: a,r / q .s ]},res: a,r0 / q0 .{res}]}| s1 = s ts,{f}.s1,...). \nThis typing is good because we can solve its constraint set by substituting the special set expression \n.for each of s and s1. This is the role of .; it allows a constraint to be solved as long as we have \nno evidence that a use of the linking or .eld extraction operation that the constraint corresponds to \nwill actually go wrong at run-time. Principal typings never need to contain .. Effectively, {[R / Q..]}is \na type that describes no values at all. An expression with such a type must be either dead (its result \nwill never be used, perhaps because its evaluation diverges) or sleeping (its result will not be used \nunless the program is put into a larger context). Martini accepts mistakes in dead or sleeping code that \nare hard to check for until a concrete calling context is provided, but it still rejects mistakes that \nare easy to .nd in dead or sleeping code. Now return to the typing for {[import f Cx,g Cy; h =x .y]}and \nconsider its triple occurrence of r. Because r appears in the arguments as well as in the result, Martini \ncan begin to resolve their connection before enough information to solve the constraint arrives. This \nlets some internal errors in sleeping code be caught early and also gives more readable principal typings \nby express\u00ading more relations between types without constraints. However, some strength is sacri.ced: \nEach module type must contain the .eld types of any module it may be linked with. (The programmer need \nnot write them as they will be inferred.) Thus Martini will reject, for example, .x.{[a =x .{[f =5]},b \n=x .{[f =true]}]}, because the type of x must predict a single type for f in all of its descen\u00addants. \nOne way to mitigate this row pollution problem is to use let-polymorphism (Section 7) instead of . to \nbind x, to allow poly\u00admorphism in the type of f. Another is to insert dummy hiding oper\u00adators: .x.{[a \n=x \\\\{f}.{[f =5]},b =x \\\\{f}.{[f =true]}]}is ty\u00adpable. Since this solution depends on guessing which \n.elds will be de.ned by the other operand to ., it cannot be applied fully auto\u00admatically; it can be \nconsidered a programmer-supplied typing hint. 5.1 Soundness Proving type soundness for Martini proceeds \nas usual, except for the details of handling constraint sets. Lemma 5.1 (weakening). Assume M : (G lt \n|C). For any C ' IC and G '.G it holds that M : (G 'lt | C '). A constraint set C is solvable iff IT \n(C) for some substitution T . A typing is called solvable iff its constraint set component is. Lemma \n5.2. Assume C . t1 = t2 and C . G1 = G2. Then M : (G1 l t1 | C)implies M : (G2 lt2 | C). Lemma 5.3 (substitution). \nIf M : T , then M : T (T ). Lemma 5.4 (term substitution). Assume M : (G E {x . t '}lt | C)and N : (\u00d8 \nlt '| C). Then [x .N]M : (G lt | C). Theorem 5.5 (subject reduction). If M '.N and M : (\u00d8 lt |C)for solvable \nC, then N : (\u00d8 lt | C). Theorem 5.6 (progress). If M : (\u00d8 lt | C) for solvable C, then either M is a \nvalue or M '.N for some N. Theorem 5.7 (type soundness). Programs (closed terms) with solvable typings \ndo not get stuck. 5.2 Testing constraint set solvability To make Thm. 5.7 useful, this section develops \nan algorithm to identify solvable constraint sets. De.ne the relation C . T by: 1. .C,s,L1, L2: C .{s=L1 \ntL2}. [s .(L1 .L2)] if L1# L2, 2. .C,s,L1,L2: C .{s = L1 \\L2}. [s .(L1 \\L2)]. Lemma 5.8. If C . T , then \nC is solvable if and only if T (C) is. Lemma 5.9. Assume that there is no T such that C . T , and let \nT0 map every export set variable in C to . (and every other variable to itself). Then C is solvable if \nand only if T0(C) is. Proof. The if direction is obvious. For only if , assume that C is solved by some \nT1. We claim that T1 also solves T0(C). For otherwise there would be a c .C such that T1(c) is solved \nbut T1(T0(c)) is not. Their only difference is that T1(T0(c)) may contain .in a place where T1(c) has \nanother (input) set expression. The only place .can appear without solving T1(T0(c)) is to the left of \n= , so c must have the form s=L1 \\L2 or s=L1 tL2 (where in the latter case L1 and L2 must be disjoint, \nbecause T1(c) is solved). But in either of these two cases we could .nd a T such that C . T , contradicting \nthe assumption. For any constraint set C and any e that occurs in C, let QC be e the least subset of \nq such that 1. When (q .L1 \\L2) .C with e .(L1 \\L2), then q .QC, and e 2. When (q2 .q1 \\L) .C with e \n.L, then q1 .QC .q2 .QC . ee Computing QC for a given C and e is a simple O(n) graph reacha\u00ad e bility \nproblem. The intended intuition is that QC is the set of q s e that e can reach according to C and {e \n|q .QC }is a lower bound e on the possible values of q in all ground solutions of C. Let C . T hold when \nT (q)= {e |q .QC } for all q mentioned in C and T e maps all other variables to themselves. Lemma 5.10. \nIf C . T and C is solvable and free of export set variables, then T (C) is solved. Proof. Because C is \nassumed solvable, any constraint in C that does not contain at least one q variable must be solved already, \nand can therefore be ignored. Constraints of the form Q2 .Q1 \\.are also solved, so the only constraints \nwe need to consider are those of the forms Q2 .Q1 \\L and Q # L. Given an arbitrary T ' that solves C, \nwhenever q .QC it must e hold that e .T '(q); this follows directly from the inductive con\u00adstruction \nof QC. Also, if we let T '(q) be T '(q) \\{e} for q .QC ee e and T '(q) otherwise, then T ' still solves \nC it would contradict e the construction of QC if this change caused an unsolved constraint e to appear. \nNow, if any solution to C exists at all, then T is also a solution, because an arbitrary solution can \nbe transformed into T label for label by the preceding remarks. Theorem 5.11. Constraint sets can be \ntested for solvability in time O(nm), where n is the number of constraints and m is the number of distinct \nlabels in the constraints. Proof. The testing procedure consists of .rst rewriting as much as possible \nby Lemma 5.8, and then eliminating the remaining export set variables by Lemma 5.9. The constraint set \nnow contains only q variables, and solvability can therefore be decided by Lemma 5.10. Complexity bound: \nIn the Lemma 5.8 phase, each constraint is processed at most four times: Once to see if it can be rewritten \nimmediately, up to twice when set variables on its left-hand side are instantiated, and once to check \nwhether T (c) is solved. If L s are represented as bit vectors, each visit of the constraint takes O(m) \ntime. Lemma 5.9 can obviously be completed in time O(n).For Lemma 5.10, the QC s and T can be straightforwardly \nconstructed e in time O(mn); checking IT (C) takes O(mn) time.  5.3 Type inference De.ne the relation \nC between typings by: (G1 lt1 | C1)C ' (G2 lt2 | C2) iff there exists a type substitution T and G2 .G2 \n' such that C2 . G2 = T (G1) and C2 . t2 = T (t1) and C2 . T (C1). Lemma 5.12. If M : T1 and T1 CT2, \nthen M : T2. ' Let T =T ' (T is at least as precise as T ') mean M : T .M : T for all M. A typing T is \nprincipal [29] for M iff M : T and M : T '.T =T ' for all T '. A typing T is syntactically principal \n' for M iff M : T and M : T '.T CT ' for all T '. Because T CT implies T =T ', a syntactically principal \ntyping for M is principal. The de.nitions directly imply that if T1 CT2 and T2 is solvable, then T1 is \nalso solvable. Therefore a syntactically principal typing for a term M is solvable unless M has no solvable \ntypings at all. Theorem 5.13. The algorithm TYPEINF de.ned in Figure 4 com\u00adputes a syntactically principal \ntyping for every typable term. The algorithm runs in time O(nma(n)) where n is the size of the ana\u00adlyzed \nterm and m is the number of distinct .eld labels in it. As a corollary, Martini has principal typings. \nBefore we prove the theorem, here are some high-level remarks about the algorithm. In our description \nit consists of two phases. The COLLECT phase processes the input term to collect type equa\u00adtions and \nconstraints; the RUNIFY phase solves the type equations by a uni.cation algorithm extended to deal with \nrows. The col\u00adlected constraints are not touched (except for the side effects of the uni.cation step); \nthey appear directly in the principal typing. Im\u00adplementations will usually perform the two phases in \nparallel as co-processes, and check constraint solvability using Thm. 5.11 af\u00adterward; we leave such \nre.nements to the reader s imagination. The recursive syntax-directed COLLECT phase takes two in\u00adputs: \na term M and a type environment G that maps all of M s free variables to distinct type variables. It \nproduces a triple COLLECT(M,G )=(W,t,C), where W is a set of type equations COLLECT(x,G )=(\u00d8,G (x),\u00d8) \nCOLLECT({[E; I]}, G )= let X =Rng E .Dom I ; let L =E-1(Dom I)and L' =Dom E \\L; let r, q, s, and ax for \neach x .X be fresh; let G '(x)be ax for x .X , and G (x)otherwise; let (Wx,tx,Cx)=COLLECT(I(x),G ')for \nall x .Dom I; let W =Sx.Dom I (Wx .{tx =ax}); let S ={e .G '(E(e))|e .Dom E }in (W,{[S r / q.s]}, Sx.Dom \nI Cx .{q .L' , s =L}). COLLECT(M1 .M2, G )= let r, q, q1, q2, s, s1, and s2 be fresh; let (Wi, ti,Ci)=COLLECT(Mi,G \n)for i .{1, 2}; let C =C1 .C2 .{q .q1 \\s2, s =s1 ts2, q .q2 \\s1}; let W =W1 .W2 .{t1 ={[r / q1 .s1 ]}, \nt2 ={[r / q2 .s2 ]}}in (W,{[r / q.s]},C). COLLECT(M.e,G )= let a, r, s be fresh; let (W,t ,C)=COLLECT(M,G \n) in (W .{t ={[e:a, r / \u00d8 .s]}},a,C .{{e}.s}). COLLECT(M \\ L,G )= let r, q, s0, s, and ae and a ' e for \neach e .L be fresh; let S0 ={e .a ' e |e .L }and S ={e .ae |e .L }; let (W,t ,C)=COLLECT(N,G ); let W \n' =W .{t ={[S0 r / q.s0 ]}}in (W ' , {[S r / q.s]},C .{q # L, s =s0 \\L}). TYPEINF(M)= let G map each \nfree variable of M to a fresh type variable; let (W,t ,C)=COLLECT(M,G ); let T =RUNIFY(W ) in (T (G )lT \n(t )| T (C)). Lemma 5.15. Assume that (W,t ,C)=COLLECT(M,G ) where G maps each free variable in M to \na unique type variable. Let T =(G lt | C). For each uni.er T forW, it holds that M : T (T ). Conversely, \nwhenever M : T ' , it holds that there is a uni.er T for  Figure 4. The de.nition of the type inference \nalgorithm. The sub\u00adalgorithm RUNIFY(W )will be de.ned in Section 6. (of the form t1 = t2), t is a type \nexpression, and C is a con\u00adstraint set. Note that the input G is only used to map term variables to type \nvariables (not arbitrary types) and it is never changed by COLLECT, although the equations in the produced \nW may give rise to substitutions for the type variables in Dom G later. REMARK 5.14. In a strictly compositional \ninference algorithm, the type environment G should be an output instead of an input. How\u00adever, computing \nthe principal environment for any subexpression bottom-up will incur possibly large reconciliation costs \nwhen the principal environments for two sibling expressions meet each other, and would therefore destroy \nthe advertised O(nm a(n))complexity. The best type inference solution that we could .nd that produced \nG only as output had complexity O(nlogn +nma(n)) (which is worse when m is small), but even that depended \n(as our current algorithm does) on a mutable union-.nd data structure shared by all the subcomputations.3 \nOne possible solution could be to start by a-renaming all variables away from each other and then deriv\u00ad \n3 Incidentally, this suggests that a consistently compositional type infer\u00adence algorithm cannot achieve \nthe folklore O(na(n))behavior on programs where the number of free variables in a subexpression may be \nlarge. How\u00adever, that is not a real problem; the main point of compositional inference is that the analysis \ncan be broken at any point in the expression tree, but there is no obligation to actually break the analysis \nat every point. ing the type variable name G (x)from the name of x. However, this does not work in practice, \nwhere type variables are represented by heap-allocated union-.nd elements to facilitate uni.cation. A \nuni.er for a type equation set W is a type substitution T such that every equation in T (W )is an identity \n(remembering that types are already identi.ed modulo the row structure equation). ' W such that T (T \n)CT. Lemma 5.16. COLLECT(M,G )can be computed in time linear in the size of M. Proof. The only parts \nof the computation for which this is not obviously the case are lookups and additions in G . If we represent \nG as a trie, the operations are all linear in the length of the variable name, so the total time spent \nhere is linear in the size of M.4 A most general uni.er (MGU) for W is a uni.er T for W such that every \nother uni.er for W can be written as T '.T for some T . The second phase of type inference computes an \nMGU of the .nal equation set W . Section 6 will construct a function RUNIFY such that RUNIFY(W )computes \none of the MGUs of W , if it has any, in time O(nma(n)), where n is the size of W and m is the number \nof distinct .eld labels mentioned in W . Proof of Thm. 5.13. The correctness of the result of TYPINF \nfol\u00adlows from Lemma 5.15 and the property that RUNIFY computes most general uni.ers. According to Lemma \n5.16, the COLLECT phase completes in time O(n), so the size of W is O(n)too. Therefore, the computation \n(and, implicitly, application) of MGU(W )can be completed in time O(nma(n)) a detailed argument for this \nwill be given in Section 6. Thus the entire computation has complexity O(nm a(n)).  5.4 Incremental \nconstraint simpli.cation Super.cially, it seems that we have solved type analysis for Marti\u00adni. To analyze \na term, one computes its principal typing (Thm. 5.13) and then checks whether its constraint part is \nsolvable (Thm. 5.11). Each step is ef.cient and relatively simple. So are we happy? Not entirely. Postponing \nconstraint solving until the end has practical and theoretical disadvantages. One problem is that the \nconstraint parts of the inferred typings can grow quite large, be\u00adcause they can track each module operation \nin the term, even those that are irrelevant for observable behavior. For example, the term ({[f =5]}.{[]}).f \ngets the inferred typing (\u00d8 lint | s ={f}, {f}.s) rather than the more concise (\u00d8 lint | \u00d8) which, inciden\u00adtally, \nis also syntactically principal for it. Instead, we want to interleave the constraint solving (Section \n5.2) with other type inference steps. But we must be a little careful; if we blindly applied the entire \nconstraint solving procedure from 4 A reader of early drafts of this explanation complained that this \nassumes that variable names are represented with a .xed .nite alphabet in the input, whereas the rest \nof our complexity analysis assumes a constant-cost RAM with a word length that expands with the input \nsize such that all parts of the input can be addressed. The reader complained that it was not fair not \nto allow the representation of variable names to take advantage of this increasing word length, and that \nthe complexity bounds ought to include a logarithmic factor to take account of this. We disagree with \nthis objection; we believe it is a common convention in complexity theory to measure the size of the \ninput in bits even when one is working with a cost model where internal operations can work with larger \npieces of data at once. This means we are measuring our algorithm the same way other algorithms in the \nliterature are measured, so comparisons will be meaningful. Section 5.2, a simple term such as x.f would \nget its original princi\u00adpal typing (x : {s ] [f: a, r / q .}l a |{f}.s, \u00d8 .q)rewritten to (x : {[f: a,r \n/\u00d8 ..}l] a |\u00d8)which is far from principal. To preserve principality we must make sure that whenever we \nrewrite ' '' T to T it holds that T CT and T CT , in which case we say it is ' safe to rewrite T to T \n. In this section we identify some rewritings that are safe. First, constraints that are already solved \ncan be dropped: ' Lemma 5.17. Let T =(G lt |C)and T =(G lt |{c .C | ' \u00acIc }). Then it is safe to rewrite \nT to T . Second, it is safe to perform the .-less solving of s variables described by Lemma 5.8: Lemma \n5.18. Let T =(G lt |C)and assume C . T . Then it is safe to rewrite T to T (T ). The construction in \nLemma 5.9 is not safe. The one in Lemma 5.10 is only partially safe; C . T sets all q s to a lower bound \non the possible values of q. We should only use this lower bound when that entails no restriction on \nset variables that are visible in the type and environment parts of the typing. We should also exclude \nvariables where the lower bound cannot yet be computed because the S part of a Q .Q \\S constraint is \nstill a variable. Lemma 5.19. Let T =(G lt |C), and let Q be the least subset of q such that 1. If q \nappears anywhere in G or t , then q .Q. 2. If (q .Q \\s).C, then q .Q. 3. If (q .q '\\L).C then q '.Q \n.q .Q.  Let C . T , and let T '(q)be T (q)when q .Q and q otherwise. Then it is safe to rewrite T to \nT '(T ). As a simple example of incremental constraint simpli.cation, consider the term (x .{[f Cy,h \nCz; y =z]}).g. Its inferred but not simpli.ed typing is (x : {s ]| C) [f: a, g: b, h: a,r / q .}l b where \n{} q1 .{h}, s1 ={f}, \u00d8 .q1 \\s, C = s2 =s ts1, \u00d8 .q \\s1, {g}.s2 We .rst reduce for s variables by Lemma \n5.8. The only reduction in this case is C . [s1 .{f}]; after this we have the same typing but with constraint \nset {} q1 .{h}, {f}={f}, \u00d8 .q1 \\s, C ' = s2 =s t{f}, \u00d8 .q \\{f}, {g}.s2 We now compute the various QC' \ns and get C ' . [q .\u00d8, q1 . e {h}]. In Lemma 5.19, Q is {q}(as q appears in the type assumption for x), \nso we apply just the substitution [q1 .{h}]to get {} {h}.{h}, {f}={f}, \u00d8 .{h}\\s, C '' = s2 =s t{f}, \u00d8 \n.q \\{f}, {g}.s2 After dropping solved constraints and using abbreviations for the unsolved ones, we get \nthe simpli.ed typing I() ) f: a, g: b, {h}.s, s2 =s t{f}, x : {[s ] / q .}l b h: a, r q .{f}, {g}.s2 \n 5.5 Discussion Martini allows compositional type inference for mixin modules without type annotations. \nPrevious typed mixin module calculi [7, 4, 1, 12, 13] have not considered type inference, and several \nexpect full type annotations for dif.cult operations. Because of the row pollution problem, Martini sometimes \nfails to type some terms unless the programmer switches to let-polymorphism (not always possible) or \ninserts dummy hiding operations. In contrast, previous mixin module systems tend to need full type annotations \nfor these problem terms. Also, as Section 4.4 points out, the naive approach of previous type systems \nleads to unfeasible NP-complete typability in the absence of full type annotations. Some previous mixin \ncalculi have features not supported by the m-calculus or Martini. Duggan and Sourelis [5] allow different \ncases of a function that operates by pattern matching to come from different modules. Ancona et al. [2] \nallow extracting an export from a mixin module with imports, if the types prove that the export does \nnot depend on the imports. If we restrict Martini to the .. fragment of the m-calculus that we de.ned \nin Section 3.2, we can derive a type system for the .\u00adcalculus with record concatenation. We call this \nsystem Bowtie;it arises by adding a primitive type constructor .for function types and then .xing the \nQ part of all remaining record types to \u00d8. Our entire development for Martini, including the type infer\u00adence \nalgorithm and its complexity analysis, carries over to Bowtie without change (except that of course constraint \nsolving for q vari\u00adables can be omitted). Bowtie is not the .rst type system for a .-calculus with record \nconcatenation that supports type inference, but to the best of our knowledge there are no previous systems \nwith a published type\u00adinference complexity bound as low as O(nma(n)). One system by R\u00b4emy [21] can probably \nbe implemented within this bound; unfortunately the types in this system are excessively in.exible and \nit can not reasonably be used for programming. A series of systems have been de.ned by Pottier [17, 18, \n19], but the only one of these that has a complexity analysis [19] has complexity O(n3mlog m), which \nis signi.cantly more than Bowtie s O(nm a(n)). Previous type systems for record concatenation include \nwork by Wand [27, 28], Harper and Pierce [8, 9], R\u00b4emy [21, 23], Zwanen\u00adburg [32], Pottier [17, 18, 19], \nand Palsberg and Zhao [16]. R\u00b4emy s system in [23] is the earliest to tolerate type errors in dead and \nsleeping code. The Bot concept in Pottier s system in [17] is very similar to the . in Bowtie (and Martini). \n  6. Row uni.cation In this section we describe an ef.cient algorithm for computing most general uni.ers \nmodulo the row structure equation (e1:t1, e2:t2,R)=(e2:t2,e1:t1,R). This is used in our type inference \nprocedure, but we also believe it has some general interest. This row uni.cation problem has a standard \nalgorithm (see for exam\u00adple [20]), but a direct implementation of this is too slow to .t within the O(nma(n))complexity \nwe need. The more ef.cient procedure we de.ne here may have been independently developed by many implementers, \nbut appears never to have been written down explic\u00aditly. We think it deserves to be recorded. The key \nidea is to handle an entire row equation (e1:t1, '' ''' ...,ek:tk, r)=(e1:t1,...,e k':tk', r ) in a single \nstep. Whenever '' ei =ej, a uni.cation of ti =t j must be scheduled; labels that ap\u00adpear only on one \nside must have corresponding entries added to the end of the list of the other side. The standard algorithm \nuses up to .(m2)label commutation steps to bring the elements on either side of the equation into the \nsame order. This corresponds to linear searches through the two row expressions; with a monolithic solu\u00adtion \nwe are free to use more ef.cient data structures such a search trees or arrays for this purpose. The \nonly point where our algorithm differs from an implemen\u00adtation of the standard algorithm for row uni.cation \nis in steps (b) and (c) of the RECUNIF operation in Figure 6. We describe the al\u00adgorithm at a more concrete \nlevel than most uni.cation descriptions in the literature. It is usual for such description to allow \nwholesale manipulation of type terms and substitutions; but working at that level would reduce our complexity \nanalysis to pure handwaving. 6.1 Data representation During row uni.cation (and type inference in general) \nlabels will be represented as small integers between 1 and m, the number of distinct labels in the program. \nThis allows representing label\u00adindexed maps as arrays. In the original input labels are usually strings \nthat must be interned to small integers before type inference; this can be done in a linear-time pass \nover the program using a trie recording indexes for already-seen labels. In the algorithm type expressions \nare represented as a di\u00adrected acyclic graph of pointer-linked memory blocks. We use the metavariable \nX for pointers to nodes in the type graph. Each node has a sort from the set {TYPE,ROW,QSET,SSET}, correspond\u00ad \ning to the syntactic categories t , R , Q and S , respectively. The sorts need not be explicitly present \nin the graph at run-time, but it is useful to imagine that they are. Each node also has a con\u00adtents which \nis either VAR or .(X1,...,Xn) where . is one of the following type constructors:5 {[\u00b7 / \u00b7.\u00b7]} with kind \nROW \u00d7 QSET \u00d7 SSET . TYPE.  e:\u00b7, \u00b7, for any e, with kind TYPE \u00d7 ROW . ROW.  . with kind SSET.  L, for \nany L, with kind SSET or QSET.  When the contents of a node X is .(X1,...,Xn), the number and sorts \nof nodes X1 through Xn, as well as the sort of X itself, must be as speci.ed by the kind of .. A node \nwith contents VAR represents a type (or row or set) variable of the appropriate sort. Each such variable \nis represented by exactly one node; we can thus identify the variable with the node and do not need explicit \nnames for type variables until and unless we want to output the inferred type textually. The nodes in \nthe type graph are elements of a union-.nd data structure, which provides the following four primitives: \nEQUAL (X1,X2)tests whether X1 and X2 refer to the same node. READ(X) produces the contents of node X. \nFUSE(X1,X2,.)creates a single node with contents . and destructively redirects all existing refer\u00adences \nto either X1 or X2 such that they now refer to the new node. (The uni.cation algorithm only performs \nthis operation when X1 and X2 have the same sort, so the sort of the new node is unam\u00adbiguous.) Finally, \none may CREATE a new node with a given sort and contents. It is well known that k operations in the union-.nd \nstructure can be done in total time at most O(k a(k)), where a is an extremely slow-growing function.6 \n 6.2 Consistent graphs The exposed nodes of the type graph are all nodes of sort ROW that are mentioned \nin the contents of a node whose sort is not ROW. That is, the only ROW nodes that are not exposed are \nthose that are linked to either not at all or only from ROW nodes. The state of the algorithm is consistent \niff there exists a function . . X . e )such that .(X)=\u00d8 for all exposed nodes X, and whenever P.n( ' \nREAD(X)=e:X ,X '' it holds that .(X '')=.(X)t{e} (and .(X) can be unde.ned if X is not of sort ROW). \nConsistency means that each row variable always appears after the same set of labels (although they may \nappear in different orders). It is an invariant of the algorithm that its state is consistent. This ensures \nthat we will not have to worry about creating ill-formed rows that de.ne the same label twice; the map \n. in the de.nition 5 For other type systems than Martini it is easy to add more type construc\u00adtors, for \nexample . of kind TYPE . TYPE . TYPE. The only .xed part of the signature is the constructors for ROW \nwhich must be exactly e:\u00b7,\u00b7 and nothing else. 6 A possible de.nition is: a(k) is the least i = 1 such \nthat A(i,4)> log k, where A is a variant of Ackermann s function [24]. 1. For each type, row or set variable \n\u00df in W , CREATE a node with the appropriate sort and contents VAR. Let . be the map from each \u00df to its \ncorresponding node. 2. Replace each (t,t ') in W with the pair (BUILD.(t ), BUILD.(t ')). 3. Do steps \n(4)-(10) for as long as W is not empty. Go to step (11) when W becomes empty. 4. Select an equation \n(X,X ')from W and remove it from W . 5. If EQUAL(X,X '), then discard the pair and start over from \n step (3). 6. If READ(X)= VAR, then execute FUSE(X,X ' , READ(X ')), and start over from step (3). If \nREAD(X ')= VAR, then execute FUSE(X,X ' , READ(X)), and start over from step (3). '' 7. Set .(X1,...,Xk)= \nREAD(X) and set . '(X1,...,Xk' )= READ(X '). (This step will not be reached unless the con\u00adtents of \nthe two nodes have this form.) 8. If . =. ', then the uni.cation problem is intrinsically un\u00adsolvable. \nReport failure and terminate the algorithm. (Mar\u00adtini has only one constructor of sort TYPE, but this \ncan happen for SSET and QSET.)  ' 9. Execute FUSE(X,X ,.(X1,...,Xk)). ' 10. Execute RECUNIF(Xi,Xi ), \nde.ned below, for 1 = i = k, and start over from step (3). 11. (This step is reached when W becomes \nempty.) Search for cycles in the type graph, for example by a depth-.rst traversal looking for back edges. \nIf any are found, then stop and report failure. 12. If this step is reached, then the uni.cation has \nsucceeded. Return the substitution {READOUT(.(\u00df))| \u00df . Dom . }.  Figure 5. De.nition of the uni.cation \nalgorithm RUNIFY(W ) corresponds to the kinding discipline of [20, pp. 647ff]. In particu\u00adlar, the initial \nstate produced by the caller must be consistent or the algorithm will not work. Fortunately, it is easy \nsee that the equa\u00adtion sets produced by the COLLECT procedure of Section 5.3 will naturlly be represented \nby consistent graphs. (Each recursive invo\u00adcation of COLLECT constructs an isolated component of the \ngraph that is initially connected to other components solely through the uni.cation queue W , which has \nno in.uence on consistency.) 6.3 The algorithm The uni.cation algorithm is de.ned in Figures 5 and 6. \nThe algo\u00adrithm keeps a queue W of waiting equalities, represented as pairs (X1,X2). It is an invariant \nthat when (X1,X2). W , then X1 and X2 must have the same sort, which must not be ROW. In step (4), the \nstrategy for picking an equation to remove is not important; the usual recursive uni.cation algorithm \ncorresponds to a LIFO queue that coincides with the implementation language s call stack. Step (11) implements \nthe occurs check, which is usually de\u00adscribed as being part of step (6), but the latter is executed too \noften to afford doing it there if we want almost-linear complexity. If (con\u00adtrary to most real-world \ntype checkers that want to report errors to the user in a readable way) we are not interested in knowing \nwhy the uni.cation failed, it suf.ces to check the type graph for cycles once after the uni.cation queue \nbecomes empty. Notice that part (b) and (c) of RECUNIF is the only place in the algorithm that speci.cally \nconcerns rows. All other steps appear unchanged in the well-known .rst order uni.cation algorithm. Theorem \n6.1. The RUNIFY algorithm produces a most general uni.er whenever its input has any uni.er. If the input \ndoes not have a uni.er it will terminate with a failure report. This is the RECUNIF(X,X ') procedure \nused in step (10) of RUNIFY: a. If the sort of X and X ' is not ROW, just add (X,X ') to W and return. \nb. (If this step is reached, both of X and X ' are exposed ROW nodes.) Let (.,X0)=GETROW(X)and (. ' ,X \n' 0)= GETROW(X '). For each e . (Dom . . Dom . ') (in some arbitrary order), do 1. If e . (Dom . n Dom \n. '), add (.(e),. '(e))to W . 2. Otherwise, if e . Dom .: CREATE a new node X ' 1 with sort ROW and contents \nVAR. Then execute FUSE(X ' 0,X ' 0,(e:.(e), X ' 1)), and set X ' 0 :=X ' 1. 3. Otherwise, if e . Dom \n. ' : CREATE a new node X1 with sort ROW and contents VAR. Then execute FUSE(X0,X0,(e:. '(e), X1)), and \nset X0 :=X1. c. Execute FUSE(X0,X' 0,VAR) and return. BUILD.(t) is a side-effecting function from type \nterms t to node names, parameterized by a map . from variables to X : BUILD.(\u00df)=.(\u00df). BUILD.(.(t1,...,tn))= \nlet Xi =BUILD.(ti) for 1 = i = n in CREATE a node with contents .(X1,...,Xm) and return its name. GETROW(X) \nis de.ned when X is a node of sort ROW and the uni.cation graph is consistent: GETROW(X)= case READ(X)of \ne:X ' , X '' . let (.,X ''')=GETROW(X '') in ({e . X ' } E.,X ''') | VAR . (\u00d8,X) READOUT maps a node \nname in an acyclic graph to a type term. It depends on a .xed injective mapping . from node names to \nvariables of appropriate sorts. READOUT(X)= case READ(X)of .(X1,...,Xn) . .(READOUT(X1),...,READOUT(Xn)) \n| VAR . .(X) Figure 6. Helper de.nitions for RUNIFY Theorem 6.2. The RUNIFY algorithm, except for the \n.nal READ-OUT operations, runs in time O(nm a(n)), where n is the total size of the input and m is the \nnumber of different .eld labels mentioned in it. Proof. Let N be the largest number of operands of any \ntype con\u00adstructor; this is assumed to be a constant. When . s are represented as arrays, each GETROW \noperation uses at most O(m) time plus m union-.nd operations. Each RECUNIF operation uses at most O(m) \ntime plus 4m +1 union-.nd operations. It may add up to m pairs to W . The total number of RECUNIF operations \nis at most Nn, because step (10) is always done together with (9), which de\u00adcreases by one the number \nof non-ROW nodes (which are never created after step (2)). Therefore, at most Nnm pairs are added to \nthe O(n) initial pairs in W during the algorithm. Steps (1) (10) of the main algorithm are executed at \nmost O(Nnm)+O(n)=O(nm) times. Each execution spends constant time plus a constant num\u00adber of union-.nd \noperations outside RECUNIF. Step (11) uses a Terms: M,N ::=\u00b7\u00b7\u00b7 | let x =N in M Generalized t-vars: \u00df \n::=s | q | r | a Variable sets: B . P.n( \u00df ) Type schemes: s ::=.B.(t |C)Environments: G . x .n. t . \ns let x =N in M '. [x . N]M RLet G (x)=.B.(t |C) .\u00df . B : T (\u00df)=\u00df x : (G l T (t) | T (C).C' ) TPoly N \n: (G l t | C) B =FTV(t ,C)\\ FTV(G ) M : (G E{x ..B.(t |C)} l t ' | C ' )let x =N in M : (G l t ' | C' \n) TLet Figure 7. Adding Hindley/Milner polymorphism to Martini to make Martini.. Things not de.ned here \nare in Figure 3. constant number of union-.nd operations for each graph edge. The number of edges is \nbounded by the number of operations already performed (each edge must have been added at some time), \nso be\u00adcause step (11) happens only once, it can at most increase the num\u00adber of operations performed \nby a constant factor. In total, O(nm)+O(Nn(4m +1)) = O(nm) union-.nd opera\u00adtions are executed. The work \nexcept for these is also O(nm),so the total time complexity of the uni.cation algorithm is O(nm)+ O(O(nm)a(O(nm)))=O(nm \na(n)), as required.  7. Let-polymorphism Because Martini has principal typings, we can add to it Milner \ns let\u00adpolymorphism to get a type system Martini. that is to Martini what the Hindley/Milner (HM) type \nsystem (used by languages like ML) is to the simply typed .-calculus. Figure 7 shows the completely conventional \nadditions that do this. Note that type schemes have a constraint component, as is often done in HM extensions \ninvolving constraints. We know that the additional rules in Figure 7 correctly im\u00adplement let-polymorphism, \nbecause Martini. types the same pro\u00adgrams as would be typed by Martini extended with the single rule \n' N : (G l t | C) [x . N]M : (G l t | C ')' let x =N in M : (G l t | C') which deliberately ignores t \nand C and is well known to cor\u00adrectly characterize the power of Milner s let-polymorphism. Prin\u00adcipal \ntypes relative to a given G in Martini. can be computed by the obvious extension of the standard algorithm \nW or one of its variants. Interleaved constraint simpli.cation yields ground princi\u00adpal types. Note that, \nas usual for systems extended with Milner s let-polymorphism, Martini. has only the weaker principal \ntypes, not principal typings. Note that let-polymorphism is not enough for ML-style mod\u00adules. Entire \nmixin modules can be polymorphic, but not individual module components, unlike ML structures and functors, \nwhich also have features addressing type abstraction and the diamond import problem such as type components \nin structures and type sharing speci.cations. More work is needed to add such features to Marti\u00adni. \n8. Conclusion 8.1 Summary of contributions This paper makes these novel contributions: 1. Section 4 proves \nthat typability is NP-complete for Riviera, the straightforward system of simple types for the m-calculus, \na calculus of .rst-class mixin modules with symmetric linking. Riviera roughly corresponds to previous \nmixin module type systems. We point out that the expense comes from the type system checking constraints \nfrom dead or sleeping code. 2. Because our NP-completeness proof (1) works for the restric\u00adtion of Riviera \nto the .. subset of the m-calculus and (2) is in\u00adsensitive to whether linking is symmetric or asymmetric \n(over\u00adriding), we have also proven that type inference is NP-complete for Wand s type system for the \n.-calculus with record concate\u00adnation [28]. The only similar previous NP-completeness result is by Palsberg \nand Zhao [16] for a more complicated system with subtyping. 3. Section 5 develops Martini, a system \nof simple types for the m\u00adcalculus. Martini is conceptually simple, with no subtyping and a clean and \nbalanced separation between (1) traditional simple types with type and row variables for determining \n.eld types and (2) constraints for safety of linking and .eld extraction. 4. Section 5 also develops \ntype inference for Martini, and proves that Martini has principal typings [29]. Martini is the .rst type \nsystem for .rst-class mixin modules with a type inference algorithm. Its time complexity is O(nm a(n)), \nwhere the input has size n and m distinct .eld labels, and a(n) is negligible. 5. By restricting Martini \nto the .. subset of the m-calculus, we achieve type inference for a .-calculus with symmetric record \nconcatenation with the same complexity, better than the previ\u00adously best published complexity for any \ntype inference algo\u00adrithm for record concatenation. (Some previous type inference algorithms for record \nconcatenation without published com\u00adplexity analyses may have comparable complexities.) 6. Section 6 \npresents an ef.cient implementation of row uni.ca\u00adtion with a rigorous complexity analysis. 7. We have \nimplemented inference of principal typings for Mar\u00adtini; our implementation can be downloaded or used \non-line at (URL:http://www.macs.hw.ac.uk/DART/software/Martini/). 8. Section 7 shows how to extend Martini \nwith Milner s let\u00adpolymorphism to make Martini., which we believe is the .rst polymorphic type system \nfor .rst-class mixin modules.  8.2 Acknowledgements We are grateful to Davide Ancona, Sonia Fagorzi, \nand Elena Zucca for discussions during a visit by us to Genova which led directly to this work. We thank \nFranc\u00b8ois Pottier and James Cheney for enlight\u00adening electronic discussions of the complexity of row \nuni.cation, and Elena Zucca, Tom Hirschowitz, G\u00b4erard Boudol, and anony\u00admous referees for helpful comments. \n  References [1] D. Ancona, S. Fagorzi, E. Moggi, E. Zucca. Mixin modules and computational effects. \nIn Proc. 30th Int l Coll. Automata, Languages, and Programming, vol. 2719 of LNCS. Springer-Verlag, 2003. \n[2] D. Ancona, S. Fagorzi, E. Zucca. A calculus with lazy module operators. In IFIP TC1 3rd Int l Conf. \nTheoret. Comput. Sci. (TCS 04). Kluwer Academic Publishers, 2004. [3] D. Ancona, E. Zucca. A primitive \ncalculus for module systems. In Proc. Int l Conf. Principles &#38; Practice Declarative Programming, \nvol. 1702 of LNCS. Springer-Verlag, 1999. [4] D. Ancona, E. Zucca. A calculus of module systems. J. Funct. \nProgramming, 12(2), 2002. Extended version of [3]. [5] D. Duggan, C. Sourelis. Mixin modules. In Proc. \n1996 Int l Conf. Functional Programming. ACM Press, 1996. [6] Programming Languages &#38; Systems, 9th \nEuropean Symp. Program\u00adming, vol. 1782 of LNCS. Springer-Verlag, 2000. [7] M. Flatt, M. Felleisen. Units: \nCool modules for HOT languages. In Proc. ACM SIGPLAN 98 Conf. Prog. Lang. Design &#38; Impl., 1998. [8] \nR. Harper, B. C. Pierce. A record calculus based on symmetric concatenation. Technical Report CMU-CS-90-157R, \nCarnegie Mellon Univ., 1991. [9] R. Harper, B. C. Pierce. A record calculus based on symmetric concatenation. \nIn Conf. Rec. 18th Ann. ACM Symp. Princ. of Prog. Langs., 1991. [10] T. Hirschowitz. Mixin Modules, Modules, \nand Extended Recursion in a Call-by-Value Setting. PhD thesis, Universit\u00b4e Paris 7, 2003. [11] T. Hirschowitz. \nRigid mixin modules. In Seventh International Symposium on Functional and Logic Programming (FLOPS 2004), \n2004. [12] T. Hirschowitz, X. Leroy. Mixin modules in a call-by-value setting. In Programming Languages \n&#38; Systems, 11th European Symp. Programming, vol. 2305 of LNCS. Springer-Verlag, 2002. [13] T. Hirschowitz, \nX. Leroy, J. B. Wells. Call-by-value mixin modules: Reduction semantics, side effects, types. In Programming \nLanguages &#38; Systems, 13th European Symp. Programming, vol. 2986 of LNCS. Springer-Verlag, 2004. More \ndetails can be found in [10]. [14] H. Makholm, J. B. Wells. Type inference, principal typings, and let\u00adpolymorphism \nfor .rst-class mixin modules. Technical report, Heriot-Watt Univ., School of Math. &#38; Comput. Sci., \n2005. [15] A. Ohori, P. Buneman. Type inference in a database programming language. In Proc. 1988 ACM \nConf. LISP Funct. Program., Snowbird, Utah, U.S.A., 1988. [16] J. Palsberg, T. Zhao. Type inference for \nrecord concatenation and subtyping. Inform. &#38; Comput., 189, 2004. [17] F. Pottier. A 3-part type \ninference engine. In ESOP 00 [6]. [18] F. Pottier. A versatile constraint-based type inference system. \nNordic Journal of Computing, 7(4), 2000. [19] F. Pottier. A constraint-based presentation and generalization \nof rows. In Proc. 18th Ann. IEEE Symp. Logic in Comput. Sci., 2003. [20] F. Pottier, D. R\u00b4emy. The essence \nof ML type inference. In B. C. Pierce, ed., Advanced Topics in Types and Programming Languages, chapter \n10. MIT Press, Cambridge, Massachusetts, 2005. [21] D. R\u00b4emy. Typing record concatenation for free. In \nConf. Rec. 19th Ann. ACM Symp. Princ. of Prog. Langs., 1992. A later version is [22]. [22] D. R\u00b4emy. \nTyping record concatenation for free. In C. A. Gunter, J. C. Mitchell, eds., Theoretical Aspects Of Object-Oriented \nProgramming: Types, Semantics and Language Design. MIT Press, 1993. [23] D. R\u00b4emy. A case study of typechecking \nwith constrained types: Typing record concatenation. Presented at the workshop on Advances in Types for \nComputer Science at the Newton Institute, Cambridge, UK, 1995. [24] R. E. Tarjan. Ef.ciency of a good \nbut not linear set union algorithm. J. ACM, 22(2), 1975.  [25] S. Vansummeren. On the complexity of \ndeciding typability in the relational algebra. Acta Informatica, 200X. To appear. [26] M. Wand. Complete \ntype inference for simple objects. In Proc. 2nd Ann. Symp. Logic in Comput. Sci., 1987. A corrigendum \nappeared at LICS 1988. [27] M. Wand. Type inference for record concatenation and multiple inheritance. \nIn Proc. 4th Ann. Symp. Logic in Comput. Sci., Paci.c Grove, CA, U.S.A., 1989. IEEE Comput. Soc. Press. \n[28] M. Wand. Type inference for record concatenation and multiple inheritance. Inform. &#38; Comput., \n93, 1991. [29] J. B. Wells. The essence of principal typings. In Proc. 29th Int l Coll. Automata, Languages, \nand Programming, vol. 2380 of LNCS. Springer-Verlag, 2002. [30] J. B. Wells, R. Vestergaard. Con.uent \nequational reasoning for linking with .rst-class primitive modules (long version). A short version is \n[31]. Full paper, 3 appendices of proofs, 1999. [31] J. B. Wells, R. Vestergaard. Equational reasoning \nfor linking with .rst-class primitive modules. In ESOP 00 [6]. A long version is [30]. [32] J. Zwanenburg. \nA type system for record concatenation and subtyping. In K. Bruce, G. Longo, eds., Third Workshop on \nFoundations of Object Oriented Languages (FOOL 3), Rutgers Univ., NJ, USA, 1996. \n\t\t\t", "proc_id": "1086365", "abstract": "A <i>mixin module</i> is a programming abstraction that simultaneously generalizes &#955;-abstractions, records, and mutually recursive definitions. Although various mixin module type systems have been developed, no one has investigated <i>principal typings</i> or developed <i>type inference</i> for first-class mixin modules, nor has anyone added Milner's <i>let-polymorphism</i> to such a system.This paper proves that typability is NP-complete for the naive approach followed by previous mixin module type systems. Because a &#955;-calculus extended with <i>record concatenation</i> is a simple restriction of our mixin module calculus, we also prove the folk belief that typability is NP-complete for the naive early type systems for record concatenation.To allow feasible type inference, we present Martini, a new system of <i>simple types</i> for mixin modules with <i>principal typings</i>. Martini is conceptually simple, with no subtyping and a clean and balanced separation between unification-based type inference with type and row variables and constraint solving for safety of linking and field extraction. We have implemented a type inference algorithm and we prove its complexity to be <i>O</i>(<i>n</i><sup>2</sup>), or <i>O</i>(<i>n</i>) given a fixed bound on the number of field labels. To prove the complexity, we need to present an algorithm for <i>row unification</i> that may have been implemented by others, but which we could not find written down anywhere. Because Martini has principal typings, we successfully extend it with Milner's let-polymorphism.", "authors": [{"name": "Henning Makholm", "author_profile_id": "81100240164", "affiliation": "Technical University of Denmark", "person_id": "P109335", "email_address": "", "orcid_id": ""}, {"name": "J. B. Wells", "author_profile_id": "81341498152", "affiliation": "Heriot-Watt University", "person_id": "PP42052708", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086386", "year": "2005", "article_id": "1086386", "conference": "ICFP", "title": "Type inference, principal typings, and let-polymorphism for first-class mixin modules", "url": "http://dl.acm.org/citation.cfm?id=1086386"}