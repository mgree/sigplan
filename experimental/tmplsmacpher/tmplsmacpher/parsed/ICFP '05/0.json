{"article_publication_date": "09-12-2005", "fulltext": "\n Invited Talk From ML Type Inference to Stratified Type Inference Fran\u00e7ois Pottier INRIA Francois.Pottier@inria.fr \n Abstract Hindley and Milner s type system, in its purest form, allows what one might call full type \ninference. Even when a program contains no explicit type information, its very structure gives rise to \na conjunction of type equations (or, more generally, to a constraint) whose resolution allows reconstructing \nthe type of every variable and of every sub-expression. Actual programming languages based on this type \nsystem, such as Standard ML, Objective Caml, and Haskell, do allow users to provide explicit type information \nvia optional type annotations. Yet, this extra information does not make type inference any easier: it \nsimply gives rise to extra equations, leading to a more specific constraint. There are extensions of \nHindley and Milner s type system where full type inference becomes undecidable or intractable. Then, \nit is common to require explicit type information, via mandatory type annotations. Polymorphic recursion \nis a simple and well-known instance of this phenomenon. This talk presents two more elaborate instances, \ncommonly known as arbitrary-rank polymorphism and generalized algebraic data types. In both cases, type \ninference is made tractable thanks to mandatory type annotations. There is a twist, though: these required \nannotations are often numerous and redundant. So, it seems desirable to make them optional again, and \nto set up a distinct mechanism to guess some of the elided annotations. This mechanism, referred to as \nelaboration, can be heuristic. It must be predictable. In the two cases considered in this talk, it is \na form of local type inference. This approach leads to a so-called stratified type inference system, \nwhere type information is propagated first in a local, ad hoc manner during elaboration, then in a possibly \nnonlocal, but well\u00adspecified manner during constraint solving. This appears to be one of the less displeasing \nways of describing type inference systems that are able to exploit optional type annotations to infer \nbetter (or different) types. Bio The speaker is a researcher at INRIA in Rocquencourt, France. He received \na Ph.D. in Computer Science from the University of Paris. His primary research interests include type \nsystems and type inference as well as the semantics and design of programming languages. Copyright is \nheld by the author/owner(s). ICFP 05, September 26 28, 2005, Tallinn, Estonia. ACM 1-59593-064-7/05/0009. \n \n\t\t\t", "proc_id": "1086365", "abstract": "Hindley and Milner's type system, in its purest form, allows what one might call full type inference. Even when a program contains no explicit type information, its very structure gives rise to a conjunction of type equations (or, more generally, to a constraint) whose resolution allows reconstructing the type of every variable and of every sub-expression. Actual programming languages based on this type system, such as Standard ML, Objective Caml, and Haskell, do allow users to provide explicit type information via optional type annotations. Yet, this extra information does not make type inference any easier: it simply gives rise to extra equations, leading to a more specific constraint.There are extensions of Hindley and Milner's type system where full type inference becomes undecidable or intractable. Then, it is common to require explicit type information, via mandatory type annotations. Polymorphic recursion is a simple and well-known instance of this phenomenon. This talk presents two more elaborate instances, commonly known as arbitrary-rank polymorphism and generalized algebraic data types.In both cases, type inference is made tractable thanks to mandatory type annotations. There is a twist, though: these required annotations are often numerous and redundant. So, it seems desirable to make them optional again, and to set up a distinct mechanism to guess some of the elided annotations. This mechanism, referred to as elaboration, can be heuristic. It must be predictable. In the two cases considered in this talk, it is a form of local type inference.This approach leads to a so-called stratified type inference system, where type information is propagated first in a local, ad hoc manner during elaboration, then in a possibly nonlocal, but well-specified manner during constraint solving. This appears to be one of the less displeasing ways of describing type inference systems that are able to exploit optional type annotations to infer better (or different) types.", "authors": [{"name": "Fran&#231;ois Pottier", "author_profile_id": "81100490085", "affiliation": "INRIA", "person_id": "PP14171513", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086367", "year": "2005", "article_id": "1086367", "conference": "ICFP", "title": "From ML type inference to stratified type inference", "url": "http://dl.acm.org/citation.cfm?id=1086367"}