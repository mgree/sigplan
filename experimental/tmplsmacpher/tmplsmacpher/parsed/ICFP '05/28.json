{"article_publication_date": "09-12-2005", "fulltext": "\n Aspectual Caml: an Aspect-Oriented Functional Language * Hidehiko Masuhara Hideaki Tatsuzawa Akinori \nYonezawa Graduate School of Arts and Sciences, Department of Computer Science, Department of Computer \nScience, University of Tokyo University of Tokyo University of Tokyo masuhara@acm.org hideaki@is.s.u-tokyo.ac.jp \nyonezawa@is.s.u-tokyo.ac.jp Abstract We propose an aspect-oriented programming (AOP) language called \nAspectual Caml based on a strongly-typed functional lan\u00adguage Objective Caml with two AOP mechanisms \nsimilar to those in AspectJ language. This paper describes the design and imple\u00admentation issues of those \nAOP mechanisms that give us insights into the interaction between AOP features and common features in \nstrongly-typed functional languages such as type inference, poly\u00admorphic types and curried functions. \nWe implemented a prototype compiler of the language and used the language for separating crosscutting \nconcerns in application programs, including for sepa\u00adrating descriptions of a type system from compiler \ndescriptions. Categories and Subject Descriptors D.3.2 [Language Classi.ca\u00adtions]: Applicative (functional) \nlanguages; D.3.3 [Language Con\u00adstructs and Features]: Data types and structures, Modules, pack\u00adages, \nPolymorphism General Terms Languages Keywords Aspect-oriented programming, Objective Caml, point\u00adcut \nand advice.  1. Introduction Aspect-Oriented Programming (AOP)[10, 19] is a programming paradigm for \nmodularizing crosscutting concerns, which can not be well modularized with existing module mechanisms. \nSeveral research and industrial projects have proven the usefulness of AOP for modularizing crosscutting \nconcerns such as enforcement of error-handling, optimizations, and authentication in large-scale software \nsystems including operating systems and commercial ap\u00adplication servers[5, 6, 7]. Although AOP is claimed \nto be useful to programming languages with module mechanisms, it has been mostly studied in the contexts \nof object-oriented programming lan\u00adguages such as Java[3, 4, 17, 18], C++[24], and Smalltalk[9, 16]. \nIn this paper, we propose an AOP language called Aspectual Caml based on a functional language Objective \nCaml. The goal of development of Aspectual Caml is twofold. First, we aim to assist development of practical \nfunctional programs with AOP. Even with * An earlier version of the paper was presented at Workshop on \nFoundations of Aspect-Oriented Languages (FOAL 05), March, 2005. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 05 September 26 28, 2005, Tallinn, Estonia. \nCopyright c &#38;#169; 2005 ACM1-59593-064-7/05/0009...$5.00. sophisticated module systems of functional \nlanguages, it would not be easy to modularize concerns like debugging, logging, optimiza\u00adtions and security. \nWe believe AOP mechanisms equally useful to those kinds of concerns in functional languages. Second, \nwe aim to provide Aspectual Caml as a basis of further theoretical stud\u00adies on AOP features. Strongly-typed \nfunctional languages, such as ML and Haskell, offer many powerful language features based on solid theoretical \nfoundations. Aspectual Caml, which incorporates existing AOP language features into a strongly-typed \nfunctional language, would help theoretical examination of the features. Aspectual Caml is an AOP extension \nto Objective Caml, a dialect of ML functional language. We design its AOP features by adapting the AOP \nfeatures in AspectJ, including the pointcut and advice mechanism and the inter-type declaration mechanism, \nfor a functional language with polymorphic types and type inference. We also design the AOP features \nso that they would .t key properties of strongly-typed functional programming including type safety, \ntype inference, and curried functions. The language is implemented as a translator to Objective Caml \nby extending the parser and type checker of the Objective Caml compiler. The rest of the paper is organized \nas follows. Section 2 intro\u00adduces the AOP features of Aspectual Caml. Section 3 presents our current \nimplementation. Section 4 shows case studies of modular\u00adization of crosscutting concerns in some application \nprograms with Aspectual Caml. Section 5 discusses related work. Section 6 con\u00adcludes the paper. 2. AOP \nMechanisms in Aspectual Caml This section describes the language design of Aspectual Caml. First we brie.y \nintroduce basic notions of AOP. We then overview problems of introducing AOP features into functional \nlanguages and solutions to those problems. Next, we present an example of extending a small program (which \nis called a base program in this paper) with an aspect. We then discuss the design of the AOP features, \nnamely the pointcut and advice mechanism and the type extension mechanism with emphases on the differences \nfrom AspectJ. 2.1 Static and Dynamic AOP Mechanisms An AOP language has one or more language mechanisms \nfor mod\u00adularizing crosscutting concerns. Each mechanism can be explained by using a join point model[19, \n21], in which the join points are the set of elements that can be treated by the mechanism. A typical \nAOP language has two AOP mechanisms: one is for dynamic program behavior, and the other is for static \nprogram structure. For example, AspectJ has the pointcut and advice mecha\u00adnism and the inter-type declarations \nmechanism. The former mech\u00adanism employs points in program execution, such as method calls and .eld accesses, \nas join points so that aspects can modify the dynamic behavior. The latter mechanism employs elements \nof pro\u00adgram structure, such as classes, methods and .elds, as join points so that aspects can change \nclass hierarchy. Aspectual Caml also has two AOP mechanisms, namely the pointcut and advice mechanism \nand the type extension mechanism. This is because we found that the combinations of two AOP mech\u00adanisms \nare crucial in many practical AOP programs, and found no reason to discard one in functional programming. \n 2.2 Design Issues Although the AOP features of Aspectual Caml are similar to the ones in AspectJ, designing \nthose features was not a trivial task. Unique features in the base language (i.e., Objective Caml), com\u00adpared \nfrom Java, such as higher-order functions, variant types (also known as algebraic types), and polymorphic \ntypes, require recon\u00adsideration of most AOP features. Below, we brie.y discuss some of the notable issues \nin the de\u00adsign of AOP features in Aspectual Caml, and our proposed solu\u00adtions: Type inference: ML (including \nObjective Caml) and Haskell pro\u00adgrams usually omit types in expressions thanks to the type infer\u00adence \nsystem, whereas types are more explicitly written in Java and AspectJ program. Aspectual Caml has a type \ninference sys\u00adtem for pointcut and advice descriptions. Polymorphic types: Strongly typed languages such \nas ML and Haskell often have polymorphic types. We found that polymor\u00adphic types in pointcuts sometimes \nbreak programmers intu\u00adition. This is coped with two types of pointcuts, namely poly\u00admorphic and monomorphic \npointcuts. Curried functions: Functional programs often use curried func\u00adtions to receive more than one \nparameters. If the semantics of call pointcut were merely capture one application to functions, it would \nbe inconvenient to identify second or later applications to curried functions. To cope with this problem, \nAspectual Caml offers curried pointcuts. Static AOP mechanism: Although AOP mechanism similar to the \ninter-type declarations in AspectJ would be useful, they should be carefully designed because functional \nprograms usually rep\u00adresent structured data by using variant types, whereas object\u00adoriented programs \ndo by using classes. In particular, the inter\u00adtype declarations in AspectJ relies on the type compatibility \nof classes with additional instance variables and methods, which is not guaranteed for the variant types. \nThe type extension mecha\u00adnism in Aspectual Caml therefore has limited scope to preserve type compatibility. \n 2.3 Example: Extending Simple Interpreter This section shows a program with an aspect to give an overview \nof the AOP mechanisms in Aspectual Caml. The base program is an interpreter of a simple language written \nin Objective Caml. The simple language merely has numbers, variables, additions and let\u00adterms. The aspect \nadds a new kind of terms subtractions into the simple language without directly changing original interpreter \nde.nitions. 2.3.1 Simple Language Interpreter The interpreter de.nition begins with de.nitions for variables \nwhich are of type id, an identi.er type: type id = I of string let get_name (I s) = s A term is of variant \ntype t, which can vary over number (Num), variable (Var), addition (Add), and let (Let) terms: type t \n=Num of int aspect AddSubtraction type+ t= ...| Sub oft *t pointcut evaluation env t = call eval env; \nt advice eval_sub = [around evaluation env t] match t with Sub(t1, t2) -> (eval env t1) -(eval env t2) \n| _ -> proceed t end Figure 1. An aspect that adds subtraction to interpreter | Var of id | Add oft *t \n| Let ofid * t*t There are a couple of functions and a variable for manipulating environments, whose \nde.nitions are omitted here: let extend = (* env -> id -> int -> env *) let lookup = (* id -> env -> \nint *) let empty_env = (* env *) The interpreter eval is a recursive function that takes an environ\u00adment \nand a term and returns its value: let rec eval env t = match t with | Num(n) -> n | Var(id) -> lookup \nid env | Add(t1, t2) -> let e= eval env in(e t1) + (e t2) | Let(id, t1, t2) -> eval (extend env id (eval \nenv t1)) t2 For example, the following expression represents evaluation of let x=3+4 in x+x, which yields \n14. eval empty_env (Let(I(\"x\"), Add(Num(3),Num(4)), Add(Var(I(\"x\")),Var(I(\"x\"))))) 2.3.2 Adding Subtraction \nto the Simple Language Figure 1 shows an aspect de.nition in Aspectual Caml that extends the interpreter \nto support subtractions. The .rst line declares the beginning of an aspect named AddSubtraction, which \nspans until keyword end. The body of the aspect consists of an extension to the data structure and a \nmodi.cation to the evaluation behavior. The second line is type extension that adds an additional con\u00adstructor \nSub to type t so that extended interpreter can handle sub\u00adtraction terms. Within AddSubtraction aspect, \nthe type t has a constructor Sub as well as other constructors de.ned in the base program. Section 2.5 \nexplains this mechanism in detail. The third line de.nes a pointcut named evaluation that speci\u00ad.es any \napplication of an environment and a term to eval function. The pointcut also binds variables env and \nt to the parameters of eval. This is also an example of curried pointcut that can specify applications \nto curried functions. Section 2.4.2 will explain this in detail. Lines 4 7 are an advice declaration \nnamed eval_sub that eval\u00aduates subtraction terms augmented above. The keyword around on the right hand \nside at the fourth line speci.es that the body of the advice runs instead of a function application matching \nthe pointcut evaluation. The lines 5 7 are the body of the advice, which sub\u00adtracts values of two sub-terms \nwhen the term is a Sub constructor. Otherwise, it lets the original eval interpret the term by apply\u00ading \nthe term to a special variable proceed, which is bound to a function that represents the rest of the \ncomputation at the function application. Note that the pointcut and the body of the advice have no type \ndescriptions, which is similar to other function de.nitions Table 1. Kinds of Join Points in Aspectual \nCaml and AspectJ Table 2. Summary of Primitive Pointcuts syntax matching join points function call \nmethod call function execution method execution construction of a variant constructor call pattern matching \n.eld get in Objective Caml. The type system infers appropriate types and guarantees type safety of the \nprogram.  2.4 Pointcut and Advice Mechanism Aspectual Caml offers a pointcut and advice mechanism for \nmod\u00adularizing crosscutting program behavior. The following three key elements explains the mechanism: \n join points are the points in program execution whose behavior can be augmented or altered by advice \ndeclarations.  pointcuts are the means of identifying join points, and  advice declarations are the \nmeans of effecting join points.  The design is basically similar to those in AspectJ-like AOP lan\u00adguages. \nWe mainly explain the notable differences below. 2.4.1 Join Points Similar to AspectJ-like languages, \nAspectual Caml has a dynamic AOP mechanism, in which join points are the points in program execution, \nrather than the points in a program text. There are four kinds of join points in Aspectual Caml, which \nare listed in Table 1 with their AspectJ counterparts. Those join points are conserva\u00adtively selected \nby considering those in AspectJ and hypothetical aspect de.nitions written for Objective Caml programs. \nAlthough there are variety of additional kinds of join points, such as construc\u00adtion of function closures \nand access to reference cells, we believe that further experience of writing aspects in Aspectual Caml \nwould give us a better insight into an appropriate set of join points. Note that the correspondences \nbetween Aspectual Caml and AspectJ are rather subjective as functional programs and Java\u00adlike object-oriented \nprograms often express similar concepts in different ways. For example, functional programs often use \nvariant types to represent compound data while object-oriented programs use objects. Therefore we place \nthe pattern matching (which takes .eld values out of a variant) and .eld get join points in the same \nrow. There are no .eld-set-like join points in Aspectual Caml since values of variant types are immutable1. \nA join point holds properties of program execution, such as the name of the function to be applied to \nand values and types of argu\u00adments. The names of functions are those directly appear in program text. \nFor example, evaluation of let lookup = List.assoc in lookup var env generates a function call join point \nwhose func\u00adtion name is lookup, rather than List.assoc. We believe that pro\u00adgrammers give meaningful \nnames to functions even if the higher\u00adorder functions make renaming of functions quite easy in functional \nprogramming 2. We distinguish functional call and execution join points, sim\u00adilar to AspectJ s method \ncall and execution join points. The dis\u00adtinction would be useful for coping with aliasing in functional \n1 Many functional programming languages offer references for representing mutable data. The operations \nover references are also the candidates of join points in future version of Aspectual Caml. 2 In contrast, \nmodels of AOP languages should be tolerant with renaming of variables. MiniAML [26], for example, distinguishes \nbetween variable names and signatures that pointcuts match by introducing labels into the calculus. call \nNP1 ; ...; Pn function call exec NP1 ; ...; Pn function execution new N(P1,...,Pn) construction of a \nvariant match P pattern matching (before se\u00adlecting a variant) within N all join points within a static \nscope speci.ed N  programming. A call join point represents application to a func\u00adtion at caller s side, \nwhich might use aliased name (e.g., lookup for List.assoc in the above example). On the other hand, an \nexecution join point represents evaluation of a function body at callee s side, which contains an original \nname of the function (e.g., List.assoc in the above example). A pattern matching join point represents \nan operation to access a value of type a variant record regardless super.cial syntax in a program. Even \nwhen a match with expression with many cases (i.e., pairs of a pattern and an expression), it creates \nonly one join point. Therefore, there is no direct means to advise in the middle of pattern matching. \nFuture work would relax this limitation, but we have not encountered examples that require precise control \nover the order of pattern matching thus far. Note that function call join points include those to anonymous \nfunctions such as (fun x -> x+1) 3. 2.4.2 Pointcuts A pointcut is a predicate over join points. It tests \njoin points based on the kinds and properties of join points, and binds values in the join point to variables \nwhen matches. Primitive Pointcuts: Similar to AspectJ, Aspectual Caml has a sublanguage to describe pointcuts. \nTable 2 lists the syntax of prim\u00aditive pointcuts and kinds of join points selected by respective point\u00adcuts. \nIn the table, Ndenotes a name pattern and Pi denotes a pa\u00adrameter pattern. A name pattern Nis a string \nof alphabets, numbers, and wild\u00adcards followed by a type expression. It matches any function or constructor \nwhose name matches the former part, and whose type matches the latter part. When call or exec pointcuts \nuse a wild\u00adcard in a name pattern N, they match calls or executions of any function including an anonymous \nfunction. The type expression can be omitted for matching functions of any type. A parameter pattern \nPis a pattern that used to describe a formal parameter of a function in Objective Caml3. It is either \na variable name, or a constructor with parameter patterns, followed by a type expression. It matches \nany value of the speci.ed type, or any value that is constructed with the speci.ed constructor and the \n.eld val\u00adues that match respective the parameter patterns. Again, the type expression can be omitted. \nFor example, x:int matches any in\u00adteger. Add(Num(x),Var(y)) matches any Add term whose .rst and second \n.elds are any Num and Var terms, respectively. Note that parameter patterns with constructors are basically \nruntime con\u00additions. This is similar to args, this and target pointcuts in As\u00adpectJ which can specify \nruntime types of parameters. Pointcut within(N) matches any join point that is created by an expression \nappearing in a lexical element (e.g., a function de.nition) matching N. In order to specify function \nde.nitions nested in other function de.nitions, the pattern Ncan use a path expression, which is not \nexplained in the paper. 3 In Objective Caml, it is simply called a pattern , but we refer it to as a \nparameter pattern for distinguishing from the name patterns. Table 3. Summary of Combined Pointcuts syntax \nmatches join points when C1 or C2 either C1 or C2 matches C1 and C2 both C1 and C2 match not C C does \nnot match cflow C C or cflowbelow C match cflowbelow C there exists a calling-context matching C I0 I1 \n...In named pointcut I0 matches Parameter Binding: The parameter patterns in a primitive point\u00adcut also \nbind parameters to variables. For example, when string \"abc\" is applied to function lookup and there \nis a pointcut call lookup name, the pointcut matches the join point and binds the string \"abc\" to the \nvariable name so that the advice body can ac\u00adcess to the parameter values. When a pattern has an underscore \ncharacter ( ) instead of a variable name, it ignores the parameter value. Combining and Reusing Pointcuts: \nAs summarized in Table 3, Aspectual Caml offers various means of combining and reusing pointcuts similar \nto AspectJ. In the table, C denotes a pointcut and I denotes pointcut name or variable name. There are \nthe operators for combining pointcuts, namely and, or, not, and cflow. It also supports named pointcuts. \nFor example, the line 3 in Figure 1 names a pointcut expression (call eval env; t) evaluation, pointcut \nevaluation env t = call eval env; t which can be used in a similar manner to primitive pointcuts in the \nsubsequent pointcut expressions, like evaluation env t at line 4 in the same .gure. Pointcuts for Curried \nFunctions: The call and exec pointcuts also support curried functions. For example, call eval env; t \nmatches the second partial application to function eval. There\u00adfore, when an expression eval empty_env \n(Num 0) is evalu\u00adated, the pointcut matches the application of (Num 0) to the func\u00adtion returned by the \nevaluation of eval empty_env. The pointcut matches even when the partially applied function is not immedi\u00adately \napplied. As a result, when let e=eval envin (e t1) + (e t2) is evaluated, the applications of t1 and \nt2 to e match the above call pointcut. The following de.nition gives more precise meaning to call pointcuts: \n call NP1 matches evaluation of an expression (e0 e1) when the expression e0 matches the name pattern \nN and the expression e1 matches the parameter pattern P1.  call NP1; ...; Pn matches evaluation of an \nexpression (e0 e1) when the evaluated value of e0 is returned from a join point matching call NP1; ...; \nP(n-1) and the ex\u00adpression e1 matches the parameter pattern PN .  In the above example, since the evaluation \nof eval env matches call env and e binds its evaluated value, evaluations of (e t1) and (e t2) match \ncall eval env; t. Similarly, exec pointcuts support curried functions on the callee s side. Section 3.4 \npresents how this advice declarations with a curried pointcut can be implemented. Type Inference for \nPointcuts: When types are omitted in a point\u00adcut expression, they are automatically inferred from the \nadvice body in which the pointcut is used. This .ts with the programming style in Objective Caml, where \ntypes can be omitted as much as possible. For example, the advice eval_sub in Figure 1 has no type expressions \nin the pointcut evaluation env t. However, it is inferred from the expressions in the advice body, that \nthe types of the variables env and t and the return type of the function are the types env, t and int, \nrespectively. As a result, the pointcut, whose de.nition is call eval env; t, matches applications to \na function named eval and of type env . t . int. The type inference gives the most general types to the \nvariables in the pointcuts. In the following advice de.nition, the system gives fresh type variables \na and \u00df to variables env and t, respectively: advice tracing = [around call eval env; t] let result = \nproceed t in print_int result; result As a result, the pointcut matches any applications to functions \nwhose type is more speci.c than a . \u00df . int. As a result, this advice captures applications to eval as \nwell as other eval functions that takes two parameters and returns integer values. Polymorphic and Monomorphic \nPointcuts: Aspectual Caml pro\u00advides a mechanism that programmers can make the types in a named pointcut \neither polymorphic or monomorphic. This is use\u00adful when there are more than one advice de.nition that \nuses the same named pointcut. When a named pointcut is de.ned with the keyword concrete, itisa monomorphic \npointcut whose type vari\u00adables can not be further instantiated. Otherwise, it is a polymorphic pointcut \nwhose type variables are instantiated when the pointcut is used in an advice de.nition4. For example, \nthe evaluation pointcut in Figure 1 is poly\u00admorphic. It hence matches any function applications eval \nof type .a\u00df..a . \u00df . .. When evaluation used in advice eval_sub, the type system instantiates a, \u00df, and \n. and then infers the types with respect to the advice body. Therefore, another advice de.ni\u00adtion that \nuses evaluation with different types do not con.ict with the previous advice de.nition: advice tracing \n= [before evaluation env t] print_string env; print_string t This mechanism is quite similar to the let-polymorphism \nin ML languages. Although the polymorphic pointcuts are useful to de.ne gen\u00aderalized pointcuts, they \nare sometimes inconvenient when the pro\u00adgrammer wants to specify the same set of join points at any ad\u00advice \nthat uses the same pointcut. Monomorphic pointcuts are use\u00adful in such a situation. Consider the following \naspect de.nition that prints messages at the beginning and end of any function applica\u00adtion (Note that \n??$ is a wildcard that matches any name): aspect Logging pointcut logged n = call ??$ n advice log_entry \n= [before logged n] print_string (\"\\nenters with \"^(string_of_int n)) advice log_exit = [after logged \nn] print_string \"\\nexits\" end Since logged is a polymorphic pointcut that matches any applica\u00adtion to \nfunctions of type .a\u00df.a . \u00df, the type system instantiates type variables for each advice declaration. \nHence the .rst advice matches only functions that take integer values as their parameter, whereas the \nsecond matches any function. By declaring logged pointcut with the keyword concrete and type expression \nto the variables that are used in the advice: 4 Note that polymorphic pointcuts instantiate type variables \nonly when types are omitted in the pointcut descriptions. It is possible to give concrete types to some \nparameters in a pointcut, while leaving other parameters polymorphic. concrete pointcut logged n = call \n??$ (n:int) logged pointcut becomes monomorphic that matches any applica\u00adtion to functions of type int \n. a. With this pointcut de.nition, the two advice de.nitions are guaranteed to advise the same set of \njoin points because the types in the pointcut will not be instantiated further.  2.4.3 Advice An advice \nde.nition includes the name, timing keyword, pointcut, and body expression. The timing keyword, either \naround, before, and after, speci.es that the advice body runs instead of, before or after each join point \nmatching the pointcut. In the body of advice, the programmer can use all top-level variables, variables \nbound by the pointcut, and the special function proceed (available only in around advice). Since proceed \nmeans the original behavior, it resumes the original execution when it is applied with an argument. For \npreserving type safety, the body expression of around ad\u00advice must have the same type as returning values \nof speci.ed join points. In addition, that of before and after advice must have the type unit. In the \nexample of subtraction extension, the body of eval_sub has the type int that is the same type as a result \nvalue of eval.  2.5 Type Extension Mechanism The type extension mechanism allows aspects to de.ne extra \n.elds or constructors in variant types (also known as algebraic types) in a base program. The former \nmechanism can be seen as a rough equiv\u00adalent to the inter-type instance variable declarations in AspectJ. \nDespite the simplicity of the mechanism, we believe that it is as crucial as the pointcut and advice \nmechanism. As you can observe in example programs in AspectJ, not a few crosscutting concerns contain \nnot only behavior (which is implemented by the pointcut advice mechanism) but also data structures (which \nare implemented by the inter-type declarations). 2.5.1 De.ning Extra Constructs One of the abilities \nof the type extension mechanism is to de.ne additional constructors to existing variant types. A variant \ntype de.nition type+ T = ... | C adds constructor C to existing type whose type name is T. In Figure \n1, we have already seen an example that adds Sub constructor to the type t. The constructors added to \na variant type by aspects often make pattern matching non-exhaustive. In other words, a base program \nthat originally de.ned the variant type usually has functions that process for each constructor differently \n(e.g., eval in the simple interpreter). Therefore, an aspect that added a constructor to a variant type \nwould also need to advise such functions so as to process the case for the additional constructor. In \nthe example Figure 1, the advice eval_sub processes the constructor Sub for the function eval, which \notherwise reports non-exhaustiveness warnings.  2.5.2 De.ning Extra Fields The type extension mechanism \ncan also allow to de.ne additional .elds to constructors of existing variant types. A variant type de.\u00adnition \ntype+ T0 = C of ... * T1{e1}* \u00b7\u00b7\u00b7 * Tn{en} adds .elds of type T1,...,Tn to a constructor C of type T0. \nThe expressions e1,...,en in the curly brackets specify default values to the respective .elds. For example, \nassume we want to associate a number (e.g., a line number in a source program) to each variable in the \nsimple language of Section 2.3. A solution with the type extension mecha\u00adnism is to add an integer .eld \nto ident type by writing the follow\u00ading de.nition: type+ ident = I of ... * int{0} As the base program \noriginally de.nes ident type as type ident = I of string, a value created by the constructor I has a \npair of string and integer. The extended .elds are visible only in the aspects that de.ne the extension. \nThis means that a value of the extended type looks differently inside and outside of the aspect: Inside \nthe same aspect, the extended type is seen with the extended .elds. Therefore, I (\"x\",1) is a correct \nexpression in the aspect.  Outside the aspect, although values of the extended type have extended .elds, \nthe extended .elds are hidden. Therefore, a value created by I (\"x\",1) inside the aspect is seen as I \n\"x\" outside the aspect. Conversely, evaluation of I \"y\" outside the aspect uses the default value 0 for \nthe value of the extended .eld, which actually yields I (\"y\",0) when viewed from in\u00adside the aspect. \n   3. Implementation We implemented a compiler, or a weaver of Aspectual Caml as a translator to Objective \nCaml. Many parts of the compiler are implemented by modifying internal data structures and functions \nin an Objective Caml compiler as the AOP features deeply involve with the type system. The compiler .rst \nparses a given program to build a parse tree. Then the next .ve steps process the parse tree: 1. infers \ntypes in the base function de.nitions; 2. infers types in the aspect de.nitions; 3. modi.es variant \ntype de.nitions in the base program by pro\u00adcessing type extensions; 4. simplify advice de.nitions; and \n 5. inserts applications to advice bodies into matching expressions.  Finally, it generates Objective \nCaml program by unparsing the modi.ed parse tree. Below, those .ve steps are explained by using the example \nin Section 2.3. 3.1 Type Inference for Base Functions The types in the base function de.nitions are inferred \nby using the internal functions in the original Objective Caml compiler. After the type inference, all \nvariables in the functions are annotated with types (or type schemes): type id = I of string let (get_name:id->string) \n= fun (I(s:string)) -> s type t = (* omitted *) let extend = (* ibid. *) let lookup = (* ibid. *) let \nempty_env = (* ibid. *) let rec (eval:env->t->int) = fun (env:env) -> fun (t:t) -> match t with | Num(n:int) \n-> n | Var(id:id) -> lookup id env | Add((t1:t), (t2:t)) -> let (e:t)->int = eval env in (e t1) + (e \nt2) | Let((id:id), (t1:t), (t2:t)) -> eval (extend env id (eval env t1)) t2  3.2 Type Inference for \nAspects The types in aspect de.nitions are inferred in a similar manner to the type inference for the \nbase functions. Notable points are the treatments of polymorphic/monomorphic pointcuts, and scope of \nthe variables. The type of a pointcut is a type of join points that can match the pointcut and a type \nenvironment for the variables in the pointcut. The type of matching join points is decided by the shapes \nof primitive pointcuts in the pointcut and the types of the variables. The variables bound by the pointcuts \nhave unique type variables otherwise explicitly speci.ed. For polymorphic pointcuts, those type variables \nare quanti.ed with universal quanti.ers that can be instantiated at the advice de.nitions. Monomorphic \npointcuts use the special type variables that can not be instantiated in the later processes. For example, \nevaluation pointcut in Figure 1 has, type of .a\u00df..a . \u00df . . for the matching join points with a type \nenvironment env : \u00df, t : . for variables bound by the pointcut. Note that the type inference of pointcuts \ndoes not use the types of function names; e.g., the type of eval in the base program. This is because \nthe function names in pointcuts do not necessarily refer to speci.c functions in the base program, but \nthey rather refer to any function that have matching name. The type inference of an advice de.nition \nis basically sim\u00adilar to the type inference of a function de.nition, but it takes types of parameters \nfrom the types of the pointcut, and gives a type to proceed variable that is implicitly available in \nthe advice body. Given an advice de.nition advice a = [around call p] e where p is a pointcut of join \npoint type a1 .\u00b7\u00b7\u00b7 . an . \u00df and type environment G, the type of e is inferred under the global type environment \nextended with G, proceed : an .\u00df. For example, type inference of eval_sub advice uses a global type environment \nextended with env : a, t : \u00df, proceed : \u00df .., and assigns types as follows: (* global type environment \nhas Sub:t*t->t, eval:env->t->int *) advice eval_sub = [around evaluation (env:env) (t:t)] (* let proceed:t->int \n*) match t with Sub((t1:t), (t2:t)) -> (eval env t1) -(eval env t2) | _ -> proceed t Note that the types \nof eval and Sub are taken from the global type environment, which eventually instantiates the types of \nother variables including those in the pointcut. 3.3 Re.ect Type Modi.cations in Base Programs In this \nphase, type extensions are re.ected in the base programs. The de.nition of types are changed according \nto the aspects. Ad\u00additionally, the default values are added to expressions whose .elds are extended by \nthe aspects.  3.4 Simplify Advice De.nitions The next step is to transform the advice de.nitions into \nsimpler ones in order to make the later weaving process easier. First, it transforms every before and \nafter advice de.nition into around advice, by simply inserting an application to proceed at the beginning \nor end of the advice body. Second, it transforms an advice declaration that uses curried pointcuts so \nthat all call or exec pointcuts takes exactly one parameter. The next is a translated advice de.nition \nfrom eval_\u00adsub (inferred types are omitted for readability): advice eval_sub = [around call eval env] \nlet proceed = proceed env in fun t -> match t with Sub(t1, t2) -> (eval env t1) -(eval env t2) | _ -> \nproceed t When an environment is applied to eval, the transformed advice runs and returns a function \nthat runs the body of the original advice when it takes a term. In other words, eval is advised to return \na function that runs the original advice body. Generally, it transforms an advice de.nition with a curried \npointcut by iteratively removing the last parameter in the curried pointcut by using the following rule \nthat transforms an advice de.\u00adnition: advice a = [around call fv1; \u00b7\u00b7\u00b7; vn] e into the next one: advice \na = [around call fv1; \u00b7\u00b7\u00b7; vn-1] let proceed = proceed vn-1 in fun vn -> e There is a subtle problem \nwith this approach when curried pointcuts are used with a disjunctive (or) operator, which is left for \nfuture research. The problem is a con.ict with advice execution policy in AspectJ-like languages. In \nAspectJ, an advice de.nition runs at most once for each (dynamic) join point. In other words, when there \nis an advice de.nition that prints a message, and a program calls a function, the advice should print \nonly one message. In Aspectual Caml, the following advice de.nition with curried pointcut causes the \nproblem: advice trace_eval_or_e = [around (call eval _; t) || (call e t)] print_string \"eval\"; proceed \nt When we evaluate eval empty_env (Add(Num(0), Num(1))) with this advice, evaluation of each subexpression \nof Add is advised twice if the advice declaration is translated by following the above rule. This is \nbecause the advice is translated into the following two advice declarations: advice trace_eval_or_e_1 \n= [around (call eval env)] let proceed = proceed env in fun t -> print_string \"eval\"; proceed t advice \ntrace_eval_or_e_2 = [around (call e t)] print_string \"eval\"; proceed t Since eval has a subexpression \nlet e =eval env in (e t1) + (e t2), the .rst advice modi.es the value of e to run the body of the advice, \nand the second advice runs the body of the advice at et1 and et2, respectively. Consequently, evaluation \nof et1 and et2 runs the body of advice twice. 3.5 Weave Advice De.nitions The last step is to insert \nexpressions that runs advice bodies at appropriate times in the base functions. It .rst transforms each \nadvice de.nition into a function de.nition. It then walks through all expressions (i.e., join point shadows) \nin the function de.nitions, and inserts an application to an advice function when it matches the pointcut \nof the advice. Given an advice de.nition, the .rst step is to simply generate a recursive function that \ntakes proceed parameter followed by the parameters to the advice. For example, it generates the following \nfunction for eval_sub advice (again, types are omitted for read\u00adability): let rec eval_sub proceed env \n= let proceed = proceed env in fun t -> match t with Sub(t1, t2) -> (eval env t1) -(eval env t2) | _ \n-> proceed t The second step is to rewrite the bodies of the base functions5 so that they call advice \nfunctions at appropriate places. By traversing the expressions in the given program, for each expression \ntype of function application, lambda abstraction, constructor application, or pattern matching for structured \nvalues, it looks for advice de.\u00adnitions that have the respective kind of primitive pointcuts. When the \nname pattern of the pointcut matches the name in the expres\u00adsion, and the type of the pointcut is more \ngeneral than the type of the expression, it replaces the expression with an application to the advice \nfunction. For example, eval function in the base program has a sub\u00adexpression (eval env) where eval:env->t->int \nand env:env. This application sub-expression matches the call pointcut in eval_sub as the types of the \njoin point and the pointcut are the same. In this case, it replaces the expression with ((eval_sub) eval \nenv) where (eval_sub) is an expression that references the advice function (explained below). It is a \nlittle tricky to de.ne and reference advice functions due to recursiveness introduced by advice. An advice \nde.nition has a global scope; it can advise any execution in any module and it also can use global functions \nde.ned in any module. Consequently, ad\u00advice de.nitions can introduce recursion into non-recursive func\u00adtions \nin the original program. For example, the following code frag\u00adment recursively computes factorial numbers \nby advising the non\u00adrecursive function fact[1]: let fact n =1 aspect Fact advice realize = [around exec \nfact n] if n=0 then proceed n else n*(fact (n-1)) end In order to allow advice to introduce recursion, \nwe proposed two solutions: De.ne advice functions in a recursive module[20] in Objective Caml. As recursive \nmodules allow mutual recursion between functions across modules, this would directly solve the prob\u00adlem. \n Reference advice functions via mutable cells. In this solution, the translated program begins with \nde.nitions of mutable cells that hold advice functions. The subsequent function de.nitions run advice \nfunctions by dereferencing from those mutable cells. Finally, after de.ned advice functions, the program \nstores the advice functions into the mutable cells.  Although trickier, our current implementation uses \nthe latter solu\u00adtion. We will consider the former one in our future version. After .nished above processes, \nthe compiler generates the fol\u00adlowing translated code for the example program: (* define mutable cells \nfor advice functions *) let eval_sub_ref = ref (fun _ -> failwith \"\") (* definitions for id, t and env \nare omitted *) let rec eval env t = match t with | Num(n) -> n | Var(id) -> lookup id env | Add(t1, t2) \n-> let e = !eval_sub_ref eval env in (e t1) +(e t2) 5 Precisely, the base functions also include the \nadvice bodies. This enables to advise execution of advice as well as execution of function. | Let(id, \nt1, t2) -> !eval_sub_ref eval (extend env id (!eval_sub_ref eval env t1)) t2 (* advice function *) let \nrec eval_sub proceed env = let proceed = proceed env in fun t -> match t with Sub(t1, t2) -> (!eval_sub_ref \neval env t1) \u00ad (!eval_sub_ref eval env t2) | _ -> proceed t (* store advice function into mutable cell \n*) let _ = eval_sub_ref := eval_sub Note that all applications to eval function, including those in the \nadvice body, are replaced with applications to !eval_sub_\u00adref eval. The eval_sub_ref is de.ned at the \nbeginning of the program with a dummy value, and assigned eval_sub function at the end of the program. \n 3.6 Implementation Status Thus far, we developed a prototype implementation6 of Aspectual Caml. Although \nsome of the features discussed in the paper are not available yet, it supports essential features for \nvalidating our concept, including the type extension, around advice, and most kinds of primitive pointcuts \nexcept for wildcarding. In fact, the next section introduces an example that can be compiled by our prototype \nimplementation. The current implementation has approximately 24,000 lines of Objective Caml program (of \nwhich 2,000 lines are modi.ed or added for implementing Aspectual Caml), including the parser and type \ninference system that are modi.ed from the ones in the orig\u00adinal Objective Caml compiler. Although it \nwould be theoretically possible to directly pass the translated parse tree to the back-end Objective \nCaml compiler, our compiler generates source-level pro\u00adgram by unparsing the parse tree. This is mainly \nfor the ease of development and for debugging.  4. Application Programs Among several small application \nprograms that we have written in Aspectual Caml, we brie.y sketch two of them. The one is, as we have \nseen thought the paper, to augment an interpreter of a simple language with additional kinds of terms, \nsuch as subtraction. Although it is a very small program, the aspect illustrates its usefulness for pluggable \nextension; since the aspect does not require to change the original interpreter de.nitions, we can easily \nfall back to the original language. The second application program is larger. It extends a compiler of \nan untyped language to support static type system. The base part of the program de.ne types for the parse \ntrees of the source and intermediate languages and functions that translate the parse tree in the source \nlanguage into the intermediate language called K\u00adnormal forms. The aspects extend the type of the source \nparse tree with type information, and modi.es the transformation functions to carry out type inference \nduring the transformation. The aspects in the program can improve comprehensibility of the compiler implementation \nin particular educational purposes. Since the translation rules in the original can be complicated by \nthe types, separating the compiler into the one for untyped language 6 Available at http://www.graco.c.u-tokyo.ac.jp/ppp/projects/ \nacaml/. and the extension for types would clarify both the core translation rules and the interaction \nbetween translations and type system. The second program, which consists of approximately 100 lines of \nbase program and 100 lines of aspect de.nitions, is shown in Appendix A.  5. Related Work AspectJ[17, \n18] is the .rst AOP language that offers both the point\u00adcut and advice and inter-type declaration mechanisms. \nAspectual Caml is principally designed by following those mechanisms. How\u00adever, we see AspectJ-family \nof languages might be too complicated to theoretically study the AOP features as they primarily aim prac\u00adtical \nlanguages. For example, AspectJ 1.2 compiler does not report type errors for the following advice declaration: \nObject around() : call(Integer *.*(..)) { return new Float(0); } even though it could cause a runtime \nerror if applied to an expres\u00adsion like Integer.decode(\"0\").intValue(). A simpler lan\u00adguage that yet \nhas a notion of polymorphism would help to reason about such a situation. There are several proposals \nof theoretical models of AOP fea\u00adtures. As far as the authors know, most work merely on the pointcut \nand advice mechanism. Aspect SandBox[27] describes a seman\u00adtics of an dynamically-typed procedural language \nwith a point\u00adcut and advice mechanism. Tucker and Krishnamurthi presented a pointcut and advice mechanism \nin dynamically-typed func\u00adtional languages[25]. MiniAML is a core calculus for expressing the pointcut \nand advice mechanism in strongly-typed functional languages[26]. Such a calculus would be suitable to \ndescribe the language design of Aspectual Caml, which is currently explained at the source language level. \nTinyAspect is a model of pointcut and advice mechanism for strongly-typed languages with ML-like modules[1]. \nIt proposes a module system for aspects so as to pro\u00adtect join points in a module from aspects outside \nthe module. From the application programmers viewpoint, Aspectual Caml has several unique language features \nthat can not be found in those theoretical models, including polymorphism in pointcuts and ad\u00advice, various \nkinds of pointcuts other than function calls, and the type extension mechanism. On the other hand, those \nmodels are theoretically sound; i.e., they come with static and dynamic se\u00admantics with proven type soundness. \nThose properties of Aspectual Caml are to be shown in future. AspectML is an AOP extension to Standard \nML with the point\u00adcut and advice mechanism[26]. The semantics of AspectML is de.ned as a translation \ninto MiniAML. PolyAML is a polymor\u00adphic aspect-oriented functional language[8]. While both Aspectual \nCaml and PolyAML provide polymorphism in pointcuts and ad\u00advice declarations, there are several differences \nin the other AOP features: PolyAML has a formal type system that has been proven sound.  Pointcuts \nin PolyAML are .rst-class data, which can be consid\u00adered generalized mechanism of named pointcuts in \nAspectual Caml and other AspectJ-like languages.  PolyAML can reify calling-contexts so that the programmer \ncan change advice behavior by examining into the context informa\u00adtion. This powerful mechanism could \nbe used for cflow point\u00adcuts in AspectJ. However, it is not clear how ef.cient imple\u00admentation techniques[15, \n22] and optimizations based on static analysis[2, 23] can be applied with this mechanism.  PolyAML provides \ncase-advice mechanism that runs advice declarations based on runtime types of parameters, which is essential \nfor de.ning universal aspects like tracing. Aspectual Caml does not offer mechanisms to examine runtime \ntypes  yet. We believe such a feature should be carefully designed in strongly-typed languages like \nObjective Caml in which types of values are not always available at runtime for ef.ciency reasons. PolyAML \npointcuts specify join points by names in scope; i.e., a pointcut {f}:(t1,t2) speci.es function f in \nthe lexical scope in which the pointcut declared, and types t1 and t2 are merely used for type checking. \nIt is not clear how PolyAML can advise anonymous functions and locally de.ned functions with\u00adout invasively \ninserting advice declarations into original func\u00adtion de.nitions. Pointcuts in Aspectual Caml are different \nin that they match join points in all scope, they can use wildcards for function names, and they can \nuse types for matching. For example, a pointcut call ??f$ (x:int) in Aspectual Caml matches any function \ncalls when the name of the function be\u00adgins with f and the type of the .rst parameter is int,even ifthe \nfunctions are de.ned locally.  In addition to above differences, Aspectual Caml provides sev\u00aderal unique \nfeatures that are not available in PolyAML, such as support for curried functions and variant types (both \nin terms of static extension and dynamic advising). We presume those features would also be useful in \nPolyAML.  There are several studies for adding .elds or constructors into existing types, but not in \nthe context of aspect-oriented program\u00adming. Type-safe update programming provides a means of ex\u00adtending \nexisting data types[11], which inspired the type extension mechanism in Aspectual Caml. Polymorphic variants[13] \nallow to de.ne functions that manipulate variant records without prior dec\u00adlaration of the variant type. \nThis can improve code re-usability of a program when it uses polymorphic variants instead of ordinary \nvariants[14]. Since there have been many programs that developed with ordinary variants, we believe that \nthe polymorphic variants and our type extension mechanism would complement each other. 6. Conclusion \nThis paper presented the design and implementation of Aspec\u00adtual Caml, an AOP functional language. The \nlanguage design aims at developing practical applications by adapting many AOP fea\u00adtures in existing \nAOP languages. In order to .t for the program\u00adming styles in strongly-typed functional languages, we \nreconsid\u00adered AOP features, including type inference of aspects, polymor\u00adphism in pointcuts, and type \nextension mechanisms. We believe that those features would serve a good basis for further theoretical \ndevelopment of AOP features such as type safety. A compiler of an Aspectual Caml subset is implemented \nas a translator to Objective Caml. It is capable to compile non-trivial application programs in which \nbase and aspect de.nitions deeply interact. Those application programs would also demonstrate that AOP \nis as useful in functional programming as in object-oriented programming. We plan to work more on the \ndesign and implementation of As\u00adpectual Caml. We so far informally de.ned the language seman\u00adtics and \ncompilation processes, which should be de.ned more for\u00admally. A module system for aspects that would \nnicely work with the ML module system would be investigated. We also consider further polymorphism in \nadvice bodies so as to easily de.ne type universal aspects like tracing. One idea is to integrate the \nlanguage with G Caml[12] so that advice can use functions that can examine values in different types. \n Acknowledgments We would like to thank Jun Furuse for his expert knowledge on the implementation of \nObjective Caml as well as his comments on the language design. We would also like to thank the members \nof the Yonezawa s research group, the members of PoPL meeting, and the members of Kumiki meeting at University \nTokyo for helpful dis\u00adcussion. We thank the anonymous reviewers of an earlier versions of the paper for \ntheir helpful comments. References [1] J. Aldrich. Open modules: Modular reasoning about advice. In \nC. Clifton, R. L\u00a8ammel, and G. T. Leavens, editors, Foundations of Aspect-Oriented Langauges (FOAL2004), \nTechnical Report TR#04 04, Department of Computer Science, Iowa State University, Mar. 2004. [2] P. Avgustinov, \nA. S. Christensen, L. Hendren, S. Kuzins, J. Lhot\u00b4ak, O. Lhot\u00b4ak, O. de Moor, D. Sereni, G. Sittampalam, \n, and J. Tibble. Optimising AspectJ. In PLDI2005, June 2005. [3] J. Bon\u00b4er. What are the key issues for \ncommercial AOP use: how does AspectWerkz address them? In AOSD 04: Proceedings of the 3rd international \nconference on Aspect-oriented software development, pages 5 6. ACM Press, 2004. Invited Industry Paper. \n[4] B. Burke and A. Brok. Aspect-oriented programming and JBoss. Published on The O Reilly Network, May \n2003. http:/ /www.oreillynet.com/pub/a/onjava/2003/05/28/aop_\u00adjboss.html. [5] Y. Coady, G. Kiczales, \nM. Feeley, N. Hutchinson, and J. S. Ong. Structuring operating system aspects: using AOP to improve OS \nstructure modularity. Communications of the ACM, 44(10):79 82, Oct. 2001. [6] Y. Coady, G. Kiczales, \nM. Feeley, and G. Smolyn. Using AspectC to improve the modularity of path-speci.c customization in operating \nsystem code. In Proceedings of the 8th European software engineering conference held jointly with 9th \nACM SIGSOFT symposium on Foundations of software engineering, pages 88 98, Vienna, Austria, 2001. [7] \nA. Colyer and A. Clement. Large-scale AOSD for middleware. In G. Murphy and K. Lieberherr, editors, Proceedings \nof the 3rd international conference on Aspect-oriented software development, pages 56 65. ACM Press, \n2004. [8] D. S. Dantas, D. Walker, G. Washburn, and S. Weirich. PolyAML: A polymorphic aspect-oriented \nfunctional programmming language. In ICFP 2005, Sept. 2005. [9] B. de Alwis and G. Kiczales. Apostle: \nA simple incremental weaver for a dynamic aspect language. Technical Report TR-2003-16, Dept. of Computer \nScience, University of British Columbia, 2003. [10] T. Elrad, R. E. Filman, and A. Bader. Aspect-oriented \nprogramming. Communications of the ACM, 44(10):29 32, Oct. 2001. [11] M. Erwig and D. Ren. Type-safe \nupdate programming. In ESOP 2003, volume 2618 of Lecture Notes in Computer Science, pages 269 283, 2003. \n[12] J. Furuse. Extensional Polymorphism: Theory and Application. PhD thesis, Universit\u00b4e Denis Diderot, \nParis, Dec. 2002. [13] J. Garrigue. Programming with polymorphic variants. In ML Workshop, 1998. [14] \nJ. Garrigue. Code reuse through polymorphic variants. In Workshop on Foundations of Software Engineering, \nSasaguri, Japan, Nov. 2000. [15] E. Hilsdale and J. Hugunin. Advice weaving in AspectJ. In Proceedings \nof the 3rd international conference on Aspect-oriented software development, pages 26 35. ACM Press, \n2004. [16] R. Hirschfeld. AspectS -AOP with Squeak. In Workshop on Advanced Separation of Concerns in \nObject-Oriented Systems (OOPSLA 2001), Oct. 2001. [17] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, \nJ. Palm, and W. Griswold. Getting started with AspectJ. Communications of the ACM, 44(10):59 65, Oct. \n2001. [18] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. G. Griswold. An overview \nof AspectJ. In ECOOP 2001, pages 327 353, 2001. [19] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda, \nC. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-oriented programming. In M. Aks\u00b8it and S. Matsuoka, editors, \nECOOP 97 Object-Oriented Programming 11th European Conference, number 1241 in Lecture Notes in Computer \nScience, pages 220 242, Jyv\u00a8askyl\u00a8a, Finland, 1997. Springer-Verlag. [20] X. Leroy. A proposal for recursive \nmodules in Objective Caml, May 2003. http://cristal.inria.fr/~xleroy/publi/ recursive-modules-note.pdf. \n[21] H. Masuhara and G. Kiczales. Modeling crosscutting in aspect\u00adoriented mechanisms. In L. Cardelli, \neditor, Proceedings of European Conference on Object-Oriented Programming (ECOOP2003), volume 2743 of \nLecture Notes in Computer Science, pages 2 28, Darmstadt, Germany, July 2003. Springer-Verlag. [22] H. \nMasuhara, G. Kiczales, and C. Dutchyn. A compilation and optimization model for aspect-oriented programs. \nIn Proceedings of 12th International Conference on Compiler Construction (CC2003), volume 2622 of Lecture \nNotes in Computer Science, pages 46 60, 2003. [23] D. Sereni and O. de Moor. Static analysis of aspects. \nIn M. Aksit, editor, Proceedings of the International Conference on Aspect-Oriented Program Development, \npage ., Boston, Mar. 2003. [24] O. Spinczyk, A. Gal, and W. Schroder-Preikschat. AspectC++: An aspect-oriented \nextension to C++. In Proceedings of the 40th International Conference on Technology of Object-Oriented \nLanguages and Systems (TOOLS Paci.c 2002), pages 18 21, Sydney, Australia, Feb. 2002. [25] D. B. Tucker \nand S. Krishnamurthi. Pointcuts and advice in higher\u00adorder languages. In Proceedings of the 2nd International \nConference on Aspect-Oriented Software Development (AOSD2003), pages 158 167. ACM Press, 2003. [26] \nD. Walker, S. Zdancewic, and J. Ligatti. A theory of aspects. In ICFP2003, 2003. [27] M. Wand, G. Kiczales, \nand C. Dutchyn. A semantics for advice and dynamic join points in aspect-oriented programming. In R. \nCytron and G. T. Leavens, editors, Foundations of Aspect-Oriented Langauges (FOAL2002), Technical Report \nTR#02 06, Department of Computer Science, Iowa State University, pages 1 8, Enschede, The Netherlands, \nApr. 2002.  A. An Example of Compiler written in Aspectual Caml A.1 Base Program: A Simple Compiler \n(*type of (untyped) identifiers*) type ident = I of string (*type of immediate values*) type imm = | \nInt of int | Float of float (*terms in the source language*) type syntax = | S_Let of ident * syntax \n* syntax | S_Var of ident | S_LetRec of s_fundef list * syntax | S_App of syntax * syntax list | S_NegInt \nof syntax | S_SubInt of syntax * syntax | S_IfLEInt of syntax * syntax * syntax * syntax | S_Imm of \nimm (*mutually recursive functions*) and s_fundef = { s_name : ident; s_args : ident list; s_body : syntax \n} (*target: untyped K-normal terms*) type knormal = | K_Let of ident * knormal * knormal | K_Var of \nident | K_LetRec of k_fundef list * knormal | K_App of ident * ident list | K_NegInt of ident | K_SubInt \nof ident * ident | K_IfLEInt of ident * ident * knormal * knormal | K_Imm of imm and k_fundef = { k_name \n: ident; k_args : ident list; k_body : knormal } (*return a fresh identifier*) let fresh_knormal = letr= \nref0in fun () -> (incr r; I((\"_knormal_\" ^ (string_of_int !r)))) (*K normalizing for the constructor \nLetRec*) let rec knormal_letrec fundef = match fundef with [] ->[] | {s_name = ident; s_args = ident_list; \ns_body = exp}::tl -> {k_name = ident; k_args = ident_list; k_body = (knormal exp)} ::(knormal_letrec \ntl) (*K normalizing for the constructor App*) and knormal_app exp explist = let rec arg_knormal fresh_fun \nexplist id_list = let rec sub el il = match el with [] -> K_App(fresh_fun, il) | exp::tl -> begin match \nknormal exp with K_Var(x) -> sub tl (il@[x]) | kexp -> let fresh_arg = fresh_knormal () in K_Let(fresh_arg, \nkexp, sub tl (il@[fresh_arg])) end in sub explist id_list in insert_let (knormal exp) (fun x -> arg_knormal \nx explist []) (*K normalizing*) and knormal = function S_Var(x) -> K_Var(x) | S_NegInt(exp) -> let f \nx = K_NegInt(x) in insert_let (knormal exp) f | S_SubInt(exp1, exp2) -> insert_let (knormal exp1) (fun \nx -> insert_let (knormal exp2) (fun y -> K_SubInt(x, y))) | S_IfLEInt(exp1, exp2, exp3, exp4) -> insert_let \n(knormal exp1) (fun x -> insert_let (knormal exp2) (fun y -> K_IfLEInt(x, y, knormal exp3, knormal exp4))) \n| S_Let(ident, exp1, exp2) -> K_Let(ident, knormal exp1, knormal exp2) | S_LetRec(fl, exp) -> K_LetRec(knormal_letrec \nfl, knormal exp) | S_App(exp, explist) -> knormal_app exp explist | S_Imm(i) -> K_Imm(i) and insert_let \ne c = match e with K_Var(x) -> c x | exp -> let fresh = fresh_knormal () in K_Let(fresh, exp, c fresh) \n(*K normalizing main*) let knormal_main s_exp = knormal s_exp A.2 An Aspect to Add Typing aspect AddType \n(*a type of an expression*) type typ = Tint | Tfloat | Tvar of typ option ref | Tfun of typ list * typ \n (*type extension to indentifiers. NOTE: the *) (*extended field can only be seen in this aspect*) type+ \nident = I of ... * typ{Tvar(ref None)} (*return fresh variables with types*) let fresh_knormal_with_type \n= let r =ref 0in fun typ -> (incr r; I((\"_knormal_\" ^ (string_of_int !r)), typ)) (*find concrete type \nby resolving Tvars*) let rec get_type = function Tvar({contents = Some(t)}) -> get_type t | Tfun(t_list, \nt) -> Tfun(List.map get_type t_list, get_type t) |t-> t (*occur check*) let rec occur r1 = function Tint \n| Tfloat -> false | Tfun(t2s, t2 ) -> List.exists (occur r1) t2s || occur r1 t2 | Tvar(r2) when r1 == \nr2 -> true | Tvar({ contents = None }) -> false | Tvar({ contents = Some(t2) }) -> occur r1 t2 (*unification \nof two types*) exception Unify of typ * typ let rec unify t1 t2 = match t1, t2 with Tint, Tint | Tfloat, \nTfloat -> () | Tfun(t1s, t1 ), Tfun(t2s, t2 ) -> (try List.iter2 unify t1s t2s with Invalid_argument(\"List.iter2\") \n-> raise (Unify(t1, t2))); unify t1 t2 | Tvar(r1), Tvar(r2) when r1 == r2 -> () | Tvar({contents = Some(t1 \n)}), _ -> unify t1 t2 | _, Tvar({contents = Some(t2 )}) -> unify t1 t2 | Tvar({ contents = None } as \nr1), _ -> if occur r1 t2 then raise (Unify(t1, t2)); r1 := Some(t2) | _, Tvar({ contents = None } as \nr2) -> if occur r2 t1 then raise (Unify(t1, t2)); r2 := Some(t1) | _, _ -> raise (Unify(t1, t2)) (*typing \nexpressions after K normalization *) (*NOTE: this function uses the extended type*) (*field in identifiers \n*) let rec id_typing k_exp t_env = match k_exp with K_Var(I(x, typ)) -> begin try let typ1 = List.assoc \nx t_env in unify typ typ1; typ with Not_found -> failwith (\"unbound_variable: \" ^ x) end | K_NegInt(I(_, \ntyp)) -> unify typ Tint; typ | K_SubInt(I(_, typ1), I(_, typ2)) -> unify typ1 Tint; unify typ2 Tint; \nTint | K_Let(I(name, typ), k_e1, k_e2) -> let typ1 = id_typing k_e1 t_env in unify typ1 typ; id_typing \nk_e2 ((name, typ1)::t_env) | K_LetRec(k_fundef_list, k_e) -> let new_t_env = id_typing_letrec k_fundef_list \nt_env in id_typing k_e new_t_env | K_App(id, id_list) -> id_typing_app id id_list t_env | K_IfLEInt(I(_, \ntyp1),I(_, typ2),k_e1,k_e2) -> unify typ1 Tint; unify typ2 Tint; let ke1_typ = id_typing k_e1 t_env in \nlet ke2_typ = id_typing k_e2 t_env in unify ke1_typ ke2_typ; ke1_typ | K_Imm (Int _) -> Tint | K_Imm \n(Float _) -> Tfloat (*typing LetRec after K normalization*) and id_typing_letrec k_fundef_list t_env \n= let rec make_tmp_t_env = function {k_name = I(fun_name, typ); k_args = id_list; k_body = _}::tl -> \n let args_type = List.map (fun (I(_, t)) -> t) id_list in unify typ (Tfun(args_type, Tvar(ref None))); \n(fun_name, typ)::(make_tmp_t_env tl) | [] -> t_env in let tmp_t_env = make_tmp_t_env k_fundef_list in \nlet rec id_typing_k_fundefs = function {k_name = I(_, fun_type); k_args = id_list; k_body = k_exp}::tl \n-> let new_t_env = (List.map (fun (I(name, typ)) -> name, typ) id_list)@tmp_t_env in let args_type = \nList.map (fun (I(_, t)) -> t) id_list in let exp_type = id_typing k_exp new_t_env in unify fun_type (Tfun(args_type, \nexp_type)); id_typing_k_fundefs tl |[]->() in id_typing_k_fundefs k_fundef_list; tmp_t_env  (*typing \nApp after K normalization*) and id_typing_app fun_id arg_ids t_env = let id_type id = id_typing (K_Var \nid) t_env in let fun_type = id_type fun_id in let arg_types = List.map id_type arg_ids in let result_type \n= Tvar(ref None) in unify fun_type (Tfun(arg_types, result_type)); result_type (*perform typing after \nK normalization*) let rec advising = (*a flag to detect*) ref false (*top-level calls *) advice knormal_with_typing \n= [around (call knormal s_exp)] if not !advising then (*top call to knormal*) let _ = advising := true \nin let k_exp = proceed s_exp in let _ = id_typing k_exp [] in let _ = advising := false in k_exp else \nlet k_exp = proceed s_exp in k_exp  end  \n\t\t\t", "proc_id": "1086365", "abstract": "We propose an aspect-oriented programming (AOP) language called <i>Aspectual Caml</i> based on a strongly-typed functional language Objective Caml with two AOP mechanisms similar to those in AspectJ language. This paper describes the design and implementation issues of those AOP mechanisms that give us insights into the interaction between AOP features and common features in strongly-typed functional languages such as type inference, polymorphic types and curried functions. We implemented a prototype compiler of the language and used the language for separating crosscutting concerns in application programs, including for separating descriptions of a type system from compiler descriptions.", "authors": [{"name": "Hidehiko Masuhara", "author_profile_id": "81100316935", "affiliation": "University of Tokyo", "person_id": "PP14115613", "email_address": "", "orcid_id": ""}, {"name": "Hideaki Tatsuzawa", "author_profile_id": "81100065518", "affiliation": "University of Tokyo", "person_id": "P745795", "email_address": "", "orcid_id": ""}, {"name": "Akinori Yonezawa", "author_profile_id": "81100439203", "affiliation": "University of Tokyo", "person_id": "PP15032269", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086405", "year": "2005", "article_id": "1086405", "conference": "ICFP", "title": "Aspectual Caml: an aspect-oriented functional language", "url": "http://dl.acm.org/citation.cfm?id=1086405"}