{"article_publication_date": "09-12-2005", "fulltext": "\n An Expressive Language of Signatures Norman Ramsey Kathleen Fisher Paul Govereau Division of Engineering \nand Applied Sciences AT&#38;T Labs Research Division of Engineering and Applied Sciences Harvard University \n Abstract Current languages allow a programmer to describe an interface only by enumerating its parts, \npossibly including other interfaces wholesale. Such languages cannot express relationships between interfaces, \nyet when independently developed software components are combined into a larger system, signi.cant relationships \narise. To address this shortcoming, we de.ne, as a conservative exten\u00adsion of ML, a language for manipulating \ninterfaces. Our language includes operations for adding, renaming, and removing compo\u00adnents; for changing \nthe type associated with a value; for making manifest types abstract and vice versa; and for combining \ninter\u00adfaces. These operations can express useful relationships among in\u00adterfaces. We have de.ned a formal \nsemantics in which an interface denotes a group of four sets; we show how these sets determine a subtyping \nrelation, and we sketch the elaboration of an interface into its denotation. Categories and Subject Descriptors \nD.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Modules, packages General Terms Design, \nLanguages Keywords Objective Caml, Standard ML, signatures, interfaces, signature manipulation, programming \nin the large 1. Introduction It is convenient if not quite correct for a programmer to think of an interface \nas a set of named components, where a component is typically a value or a type. Surprisingly, however, \nprogramming languages offer few means of manipulating interfaces in the ways we usually manipulate sets. \nWhile some languages make it pos\u00adsible to add components to an existing interface, we know of no language \nthat enables a programmer to remove or change an ex\u00adisting component, or to take the union of two sets \nof components. Most languages can de.ne an interface only by enumerating all its components. Despite \ntheir limitations, existing interface languages serve many programmers well. These languages can become \nawkward, however, when software is composed of multiple components over which no single group has control. \nEven then, provided the compo\u00adnents .t together nicely, existing languages will do. The problem and the \nneed to manipulate interfaces as sets of components arises when components do not .t together. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 05 September \n26 28, 2005, Tallinn, Estonia. Copyright c &#38;#169; 2005 ACM 1-59593-064-7/05/0009. . . $5.00. Harvard \nUniversity To take a simple example, there is an inconsistency between the ORD SET interface called a \nsignature in the Standard ML of New Jersey Library and the LIST signature in the Standard ML Basis Library. \nFor years, the only way to add an element to an ordered set was to use an add function with the following \ntype: val add : set * item -> set But add s type .ts badly with foldr in the LIST signature: val foldr \n: ( a * b -> b) -> b -> a list -> b The dif.culty is that the arguments to add come in the wrong order, \nso add cannot be passed to foldr. This dif.culty is easy to work around; for example, we can de.ne a \nsignature ORD SET2, which is just like ORD SET except that add has type val add : item * set -> set Regrettably, \nthe signature language of Standard ML cannot de.ne ORD SET2 concisely: one must enumerate, by hand, all \nthe compo\u00adnents in ORD SET2. And when ORD SET changes, ORD SET2 must be updated by hand. This strategy \nof clone and modify leads to dif.culties in maintaining software. The example of the add function illustrates \na general problem: when two interfaces are closely related, we would like to express that relationship \nformally in the interface language, rather than write out both interfaces and indicate the relationship \ninformally. For example, we would like to write something like signature ORD_SET2 = ORD_SET as S rebinding \nval S.add : S.item * S.set -> S.set In this paper, we present a language that solves this problem. We \nmake the following contributions: Our language expresses a useful algebra of operations on sets of components. \nThe language is a conservative extension of Leroy s (1994) calculus, which forms the foundation of the \nmodule language of Objective Caml.  We show by example how our language can describe groups of signatures \nin ways that are dif.cult or impossible to do in existing languages.  We show that for ML-like languages, \nthere is no greatest lower bound in the subtype ordering for signatures. That is, given two signatures \nS and S' , even if there is a third signature that is a subtype of both S and S' , there is no least \nspeci.ed signature I that is a subtype of both S and S' . This result implies that there is no signature \nI such that a module M implements both S and S' if and only if it implements I. Our result holds even \nin Leroy s calculus. If, however, we exclude code that implements a signature only by being more polymorphic \nthan the signature requires, then we can compute greatest lower bounds for ML signatures.  Our language \nis implemented for a simple core language based on ML. 2. Motivation and background Our goal is to help \nprogrammers express nontrivial relationships among signatures, the better to explain and understand the \nstruc\u00adture of complex software. To meet this goal, we introduce a new language design. To enable use \nby programmers, we have made the language fairly rich. We have also paid attention to concrete syntax. \nOur work is a bit different from other work on language fea\u00adtures for modules. In most other work, such \nfeatures are typically studied in the context of a small core calculus; we use a surface language. This \ndecision makes our formalism atypical: unlike the description of a typical calculus, our formal description \ncovers the full translation from unannotated syntax to semantic objects. Our formal descriptions are \ntherefore more detailed and complex than usual. For this reason, almost all of our formalism is relegated \nto a companion technical report (Ramsey, Fisher, and Govereau 2005): the point of this paper is not that \nwe can analyze our language for\u00admally, but that a modest extension to ML solves a signi.cant class of \nprogramming problems. We had hoped to de.ne our new language in terms of an exist\u00ading semantic framework, \nsuch as that of Leroy (1994), of Harper and Stone (2000), of Dreyer, Crary, and Harper (2003), of Milner \net al. (1997), or of Russo (2001). But these frameworks do not meet our needs: Although they are well \nsuited to describing the meaning of a single signature, they are not appropriate for describing compu\u00adtations \nthat manipulate signatures. The .rst three frameworks pre\u00adserve too much of the original syntactic structure \nof the signature. In particular, they totally order the components of a signature. This total ordering \nensures that important dependencies are preserved, but makes it awkward to manipulate the many independent \ncompo\u00adnents.1 The last two frameworks support abstract types through the use of special names, which \nare introduced by binding constructs that do not appear in the source code. These hidden binding con\u00adstructs \nmake it dif.cult to manipulate signatures. Because existing frameworks did not meet our needs, we devel\u00adoped \na new framework, which we designed to satisfy these criteria: To help a programmer know when one signature \ncan be used in place of another, we want two signatures to be deemed equiva\u00adlent if and only if any module \nthat implements one also imple\u00adments the other. To meet this criterion, we de.ne equivalence using Leroy \ns (1994) technique of principal signatures and sig\u00adnature subtyping.  We want a form of referential \ntransparency, such that if two sig\u00adnatures are equivalent, one can be used for the other in any con\u00adtext. \nThis criterion means that operations such as rebinding cannot use certain syntactic tricks based on names. \nFor exam\u00adple, the following two ML signatures are equivalent:  signature S1 = sig signature S2 = sig \ntypet=int typet=int val x:t val x:int end end If S1 appears in a context where its type t is rebound \nto bool, for example, the type of x should not change (cf. Section 5.4). Instead of giving semantics \nonly for an internal language, we want to give semantics to surface syntax, so as to help program\u00admers \nunderstand the language. 1 The Dreyer/Crary/Harper calculus not only enforces order but also dis\u00adcards \nthe names used in the source code. This calculus would make a good foundation for the internal language \nof a compiler, but it is not so good when we want to manipulate signatures using the names originally \npresent in the source. declaration . module type signature-name = sig .\u00af sig . sig binding end | functor \n(module-name:sig) -> sig | sig with type p = a | signature-name binding . type name :: e = a | val name \n: a | module name : sig | include sig p . Path (quali.ed name) a . Core-language type e . Core-language \nkind Figure 1. Syntax of current ML signature language To leverage strengths of existing languages, we \nstart with ML, which among languages in wide use has the most powerful con\u00adstructs for programming with \ninterfaces. In both major dialects (Standard ML and Objective Caml), the unit of implementation is the \nmodule; a module is either a structure or a functor. A structure is a collection of named components; \na component may de.ne a value,a type, or a nested submodule. A functor is a mapping from one module to \nanother. An ML module is described by its signature, which can be thought of as an interface or a type. \nThe signature for a structure de\u00adscribes each component of the structure. A value is described by its \ntype, and a nested submodule is described by its signature. A type may be described by its kind alone, \nin which case it is abstract, or by its de.nition, in which case it is manifest. The signature for a \nfunctor gives the signatures for the argument and result of the func\u00adtor. To make it possible for components \nof the result signature to depend on types declared in the argument signature, the argument signature \nis given a name. Figure 1 gives a grammar for ML signatures.2 Figure 1 also shows a notational convention \nwe use throughout this paper: when a symbol could stand either for abstract syntax or for a semantic \nobject, we write abstract syntax with a tilde over it. For example, a is a semantic type, but a is the \nsyntax for a type. ML includes only two constructs for manipulating signatures: with type and include. \nThe with type construct enables a pro\u00adgrammer to make an abstract type manifest. The include construct \nis a syntactic way to combine two signatures; it is as if the compo\u00adnents of the included signature appeared \nin place of the include. In Section 5.4, we present a more semantically grounded way of combining signatures. \nBecause of differences between dialects, Figure 1 is not a com\u00adplete story about all module-level features \nof all ML dialects. In Objective Caml, the unit of compilation is the structure, whereas in Standard \nML, true separate compilation is not possible. (Tools such as CM (Blume and Appel 1999) provide a reasonable \nfacsim\u00adile.) In Standard ML, the argument or result of a functor must be a structure, whereas in Objective \nCaml, an argument or result may also be a functor. In addition to with type, Objective Caml pro\u00advides \nan analogous with structure, which is syntactic sugar for a collection of with type constraints. 2 For \nsimplicity, Figure 1 ignores an important distinction; in ML, there are two sorts of core-language types: \nthose that can appear in a type de.nition and those that can appear in a value declaration. For example, \na type of kind *= * can appear in a type de.nition but not in a value declaration, and a polymorphic \ntype can appear in a value declaration but not in a type de.nition. Of the two major dialects, Objective \nCaml is closer to the design we would like to reach: it supports .rst-class, nested functors, and it \nomits sharing constraints. (We discuss in Section 6.1 how our more general construct subsumes both with \ntype and sharing.) For this reason, we use Objective Caml as our representative of existing languages. \n 3. Examples of the problem Before we present our language of signatures (Section 4), we present examples \nof ways in which current languages are .awed. Because such examples require discussion of relationships \namong modules, we present a nontrivial collection of signatures, which takes substantial space. But the \nexamples do double duty: we use them here to illustrate .aws, and in Section 4 we use them again to show \nhow our language addresses the .aws. Rather than contrive examples to illustrate our language, and rather \nthan use standard abstract data types such as stacks, sets, and .nite maps, we have chosen to use examples \nderived from real software. Such examples may require more effort to understand, and they run the risk \nof con.ating software-design issues with language-design issues, but they help show that our proposal \nis grounded in real problems. Readers who are already familiar with the limitations of ML signatures \nmay prefer to skip these examples and continue with Section 4. To focus our presentation, we have chosen \nour examples from just one software system: an embedded interpreter intended for scripting. The idea \nis simple: a complex application is linked with a small, reusable interpreter that is used at run time \nto drive or con\u00adtrol the application. Reuse requires extension; an embedded inter\u00adpreter is extended \nby adding application-speci.c values and code. For example, the popular computer game Baldur s Gate is \nlinked with an embedded interpreter for the programming language Lua (Ierusalimschy 2003). The game extends \nLua s built-in values with application-speci.c values representing monsters, weapons, and so on. The \ngame includes Lua code that is interpreted to help deter\u00admine how monsters and other non-player characters \nbehave. The combination of parts of the Lua interpreter with independently de\u00adveloped extensions leads \nto interesting problems in the description of interfaces. Our examples are divided into three groups. \nEach group begins with one or more signatures that are required for background, then goes on to present \nsignatures that illustrate problems with the ML signature language. At the end of each group, problems \nare summarized with bullet points. Solutions appear in Section 4. Deriving one interface from another \nA Lua interpreter is pre\u00adsented to a game engine using a single interface, expressed as the ML signature \nINTERP. This signature de.nes type value, which includes all values that the interpreter can manipulate: \nbuilt\u00adin values such as strings, numbers, and hash tables, as well as application-speci.c values, which \nhave type usert. The INTERP signature also includes many useful functions: for example, create an instance \nof the interpreter or evaluate a script. The INTERP signature is derived from another signature, EVALUATOR, \nwhich is itself almost derived from a third signature, CORE. All three signa\u00adtures depend on VALUE, which \nde.nes the types that represent Lua values and the state of a Lua interpreter. module type VALUE = sig \ntype value (* a Lua value *) type state (* the state of a Lua interpreter *) type usert (* a user-defined \nvalue *) ... end Here are the de.nitions of CORE and EVALUATOR and the deriva\u00adtion of INTERP. module \ntype CORE = sig module V : VALUE val apply : V.value -> V.state -> V.value list -> V.value (* apply function \nf in state s to list of args *) val setglobal : V.state -> string -> V.value -> unit *.ve more functions \ncommon to core and evaluator. end module type EVALUATOR = sig module Value : VALUE module Ast : AST with \nmodule Value = Value type state = Value.state type value = Value.value exception Error of String val \ncompile : Ast.program -> ... val setglobal : state -> string -> value -> unit *.ve more functions common \nto core and evaluator. *additional de.nitions in evaluator but not core. end module type INTERP = sig \ninclude EVALUATOR module Parser : PARSER with type chunk = Ast.chunk val dostring : state -> string -> \nvalue list val mk : unit -> state end We .nd nothing wrong with the VALUE signature, but the other signatures \nexhibit several defects: Because INTERP is derived from EVALUATOR, a programmer who needs to understand \nINTERP must also consult the def\u00adinition of EVALUATOR. Because INTERP is the only signature that a user \nof the library really needs to understand, we would prefer to derive EVALUATOR from INTERP but this is \nnot pos\u00adsible. (An alternative would be to write out both INTERP and EVALUATOR in full, but this alternative \nwould not only create a maintenance headache but also obscure the close connection between the two signatures.) \n For two reasons, we are forced to duplicate the components that are common to CORE and EVALUATOR. First, \napply appears in CORE but not in EVALUATOR. Second, the value module is named Value in EVALUATOR but \nV in CORE. We could work around the .rst reason by adding apply to EVALUATOR, which would do no harm. \nBut the second reason should not be worked around: The name Value is used in INTERP (and therefore also \nin EVALUATOR) because INTERP is intended for a programmer who does not know all the details of the system, \nso full names are appropriate. The name V is used in CORE because CORE is intended for a different programmer \none who is de.ning an extension to the system and who will use the V module extensively.  A better structure, \nwhich we show in Section 4, would be to de\u00ad.ne INTERP by writing out all the components in a form suit\u00adable \nfor understanding by a fairly na\u00a8ive programmer, then to de\u00adrive EVALUATOR from INTERP and CORE from \nEVALUATOR. (Pro\u00adgrammers might disagree about whether to derive EVALUATOR from INTERP or INTERP from \nEVALUATOR; the main point is that we want a language that allows the programmer to decide.) Describing \nproperties of extensions A Lua interpreter is useful largely because it can manipulate values of the \nunderlying game engine, such as monsters and weapons. Such manipulation is en\u00adabled by adding the monster \nand weapon types to the interpreter. Each such addition (or extension) must satisfy several properties. \nIdeally we would de.ne each property using a signature, then com\u00adbine the signatures, but doing so using \nML is awkward. To add a type, the game engine must provide an equality test and a string-conversion function. \nThis requirement is described by the USERTYPE signature. module type USERTYPE = sig type t valeq :t->t->bool \nval to_string : t -> string end The USERTYPE signature is .ne as it is; we need it only for back\u00adground. \nExtensions are compiled separately, then combined into a sin\u00adgle type, which becomes the usert type mentioned \nin the VALUE signature. To get access to a single extension, we need an appro\u00adpriate view, which provides \na bidirectional mapping between the combined type combined and the single extension t. module type TYPEVIEW \n= sig type combined type t val map : (combined -> t) * (t -> combined) end In our running example, the \ncombined type might be the usert in a VALUE module, and the type t might be monster or weapon. Like USERTYPE, \nTYPEVIEW is a perfectly good signature that we need for background. Because different parts of the game-engine \ncode might need access to any or all application-speci.c extensions, we need a signature that provides \naccess to views of all the extensions that go into making up a combined type. Here is a signature that \ncombines just two extensions: module type COMBINED_COMMON = sig type also_t module TV1 : TYPEVIEW with \ntype combined = also_t module TV2 : TYPEVIEW with type combined = also_t end Here, the type also t might \nbe the usert type, type TV1.t might be monster, and type TV2.t might be weapon. An application may need \narbitrarily many extensions. For ex\u00adample, the game engine might need not only monsters and weapons but \nalso armor. To support unlimited extension, our Lua interpreter makes it possible to treat combined extensions \nas a new exten\u00adsion, which can then itself be combined. We would like to express this possiblity by de.ning \na signature COMBINED TYPE that has all the properties of both COMBINED COMMON and USERTYPE. Here is \nhow we have to do it in ML: module type COMBINED_TYPE = sig include COMBINED_COMMON include USERTYPE \nwith type t = also_t end Here the new type t might represent weapons or armor while the two views TV1.t \nand TV2.t might represent weapons and armor, respectively. ML s mechanism for combining signatures is \nugly: In COMBINED COMMON, we use the annoying name also t in\u00adstead of the idiomatic name t. We do this \nbecause we use include to combine signatures, and we have to avoid a col\u00adlision on the name t. Then we \nneed the additional with type to make t and also t the same type. The problem with also t goes beyond \nugliness: the program\u00admer who wrote the COMBINED COMMON signature had to be pre\u00adscient, knowing in advance \nthat because COMBINED COMMON would be combined with USERTYPE, the standard name t could not be used. \nIn Section 4, we show how to combine two signa\u00adtures without advance planning. Re.ning description of \na functor Application-speci.c code is linked into a Lua-ML interpreter when the interpreter is boot\u00adstrapped \nfrom a CORE interpreter. The application-speci.c code takes the form of an ML functor that matches signature \nBARECODE: module type BARECODE = functor (C : CORE) -> sig val init : C.V.state -> unit end Such a functor \nreceives a CORE and provides an init function. When called, the init function uses the core s setglobal \nto add new Lua-ML code to the interpreter s state. For example, the Baldur s Gate game adds a create \nweapon function which can be invoked at run time to create a new instance of a weapon. This function \nis used by developers to debug and by players to cheat. The BARECODE signature is perfectly good by itself, \nbut if the create-weapon code needs access to the application-speci.c weapon type, BARECODE is not expressive \nenough. Here s the problem: the application-speci.c code needs a TYPEVIEW for its application-speci.c \ntype, and the combined type in that TYPEVIEW must be the same as the usert type in the core s VALUE module. \nBut given the signature BARECODE above, there is no way for any\u00adthing outside of BARECODE to name the \ncore s VALUE module. We therefore de.ne a more elaborate signature for application-speci.c code. module \ntype USERCODE = sig type usert module M : functor (C : CORE with type V.usert = usert) -> sig val init \n: C.V.state -> unit end end Using the USERCODE signature, we can name the appropriate type. For example, \nhere is the signature of a putative weapons library. module type WEAPON_LIB = sig type t = Weapon.t module \nT : USERTYPE with type t = t module Make : functor (TV : TYPEVIEW with type t = t) -> USERCODE with type \nusert = TV.combined end The surprising annotation with type t = t is a frequently used idiom. It says \nsomething nontrivial because the terms on the two sides of the equals sign are elaborated in different \nenvironments. For example, to read USERTYPE with type t = t, we must know that on the left of the equals \nsign, all the components of USERTYPE are implicitly included in the environment. But on the right of \nthe equals sign, these components are not included. What the phrase says is that module T implements \na re.nement of USERTYPE in which the abstract type t is revealed to be identical to the type Weapon.t \n(which we assume is de.ned elsewhere). The signatures above show two problems: One cannot name a type \nthat appears in the argument or result of a functor.  In the syntactic form sig with type p = a , the \nterms on either side of the = sign are elaborated in different environments. This semantics leads to \nconfusing idioms such as with type t =t. It also limits the expressive power of with type (see Sec\u00adtion \n6.1).  Grammar . . pat . X pat -> pat S . sig Cs end . `. \u00b4 | functor (X:S) -> S cpt . type . val \n. module p . .. | T . .. p . X xtX.p | S ms | S andalso S Terminal and nonterminal symbols | S sealing \nwith S .\u00af C A component (binding) used to de.ne a signature Cs . C .\u00af Cs A sequence of components (between \nsig... end) ms . m cpt An existing component identi.ed by path .\u00af m . revealing type p = a and type \np = a e Syntax for a kind .\u00af '' | revealing module p = p and type p = p m A signature modi.er (e.g., \nadding...) .\u00af ms A sequence of modi.ers | adding pC and pC .\u00af p Syntax for a path | removing cpt and \ncpt .\u00af pC A path component, used to extend or change an | rebinding pC and pC .\u00af existing signature \n| moving cpt => p and cpt => p S A signature | with p as pat t The name of a type  C . type t :: e \n= a T The name of a top-level signature | val x : aa Syntax for a type | module X : Sx The name of a \nvalue  X The name of a submodule pC . type p :: e = a | val p : a | module p : S The metalanguage is \nWirth s EBNF: square brackets for optional, braces for zero or more. The grammar is ambiguous; a sequence \nof .\u00af modi.ers m binds as tightly as possible, and the pat arrow binds as in ML types. Parentheses can \nbe used around S and pat. Figure 2. Syntax of an expressive language of signatures 4. An expressive \nlanguage of signatures In each of the examples above, a problem arises because there is a relationship \namong signatures that cannot easily be expressed for\u00admally. To solve such problems, we have devised a \nmore expressive language of signatures. Our language is an extension of Leroy s (1994, 2000) version \nof ML. Our design extends signatures with operations analogous to set operations. We aim for two kinds \nof completeness: If we provide an operation that can make a small change in a signature, we also provide \nan inverse operation that can undo the change. And if we provide an operation that can change one component \nof a signature, we make sure it can change any component of the signature. We also try to make it easy \nfor a programmer to understand when signatures or types are the same. Our design is summarized in Figure \n2. As in ML, signatures can be formed by sig... end and functor constructs, and they can be looked up \nby name T . In addition, a signature can be modi.ed by modi.ers ms, and two signatures can be combined \nusing the andalso and sealing with operations. Changing translucency The .rst modi.ers are revealing \ntype and revealing module, whose inverse is sealing with. In the terminology of Harper and Lillibridge \n(1994), these operations change the degree of translucency of a signature. In the termi\u00adnology of Leroy \n(1994), revealing makes abstract types mani\u00adfest (comparable to OCaml s with type and with module) while \nsealing makes manifest types abstract. Like OCaml s with type, revealing type is used not only to give \na de.nition to an ab\u00adstract type but also to force two abstract types to be the same. Unlike with type, \nour revealing type is also powerful enough to express equalities that would otherwise require Standard \nML s sharing constraints. The revealing module modi.er reveals all of a structure s abstract types at \none go. Finally, sealing is the in\u00adverse of revealing. We discuss these modi.ers in more detail in Section \n5.4, where we discuss their elaboration. Adding, removing, and changing components The adding and removing \nmodi.ers are provided by analogy with set operations. They are more restricted than actual set operations; \nfor example, one cannot remove the declaration of an abstract type on which another declaration depends. \nThe rebinding modi.er is a bit like removing followed by adding, except that it can rebind in place an \nabstract type or submodule on which something else depends. The moving modi.er is more of an analogy \nwith .lesystems than with sets: it provides the ability not just to change the name of a value, type, \nor submodule, but even to move it to a different place in the signature, e.g., as in S moving type TV1.combined \n=> TV2.t . Unlike removing followed by adding, moving can move an abstract type to which other components \nrefer. Returning to our running example, these modi.ers make it possible to de.ne INTERP by explicit \nenumeration and to derive EVALUATOR from INTERP: module type INTERP = sig module Value : VALUE * . . \n. all components explicit . . . . end module type EVALUATOR = INTERP removing module INTERP.Parser and \nval INTERP.dostring and val INTERP.mk To refer to components of a signature being modi.ed, we use fully \nquali.ed names such as INTERP.mk. Some alternatives are discussed in Section 6.1. Introducing new module \nnames The last modi.er, with p as pat, does not actually modify a signature; instead, it introduces one \nor more new names for the signature s components. The initial with p selects a component of the modi.ed \nsignature; if with p is omit\u00adted, it selects the entire signature. The pattern pat matches the se\u00adlected \ncomponent and introduces one or more new module names. A newly introduced module name X can be used in \nlater modi.ers to refer to a component of that module, even if the component is the argument or result \nof a functor. The with p as pat modi.er can be used for mere convenience, as shown in this derivation \nof CORE from EVALUATOR. We rename the Value component, add the declaration of the apply function, and \nremove unwanted components. So that we don t have to write EVALUATOR every time, we omit the with p and \nuse as E to de.ne an abbreviation E. module type CORE = EVALUATOR as E moving module E.Value => E.V adding \nval E.apply : ... removing val E.compile and module E.Ast and *additional components. If we want to \nre.ne the description of a functor, with p as pat is required. For example, the modi.er as(C -> I) enables \nus to manipulate BARECODE directly; the ugly signature USERCODE becomes unnecessary. module type BARECODE \n= functor (C : CORE) -> sig val init : C.V.state -> unit end module type WEAPON_LIB = sig type t = Weapon.t \nmodule T : USERTYPE as U revealing type U.t = t module Make : functor (TV : TYPEVIEW as TV revealing \ntype TV.t = t) -> (BARECODE as (C -> I) revealing type C.V.usert = TV.combined) end Our revealing type \nis subtly different from Objective Caml s with type or Standard ML s where type: the terms on either \nside of the equals sign are elaborated in the same environment. This difference eliminates the unfortunate \nwith type t = t from the original de.nition of WEAPON LIB. Combining signatures The last extension we \nprovide is the andalso operation. The andalso operation is analogous to a union of components, but it \nis motivated from a more semantic model based on the implementation relation: informally, a mod\u00adule M \nimplements the signature S andalso S ' if and only if it implements both signature S and signature S \n' . The effect is some\u00adwhat like taking the union of components in S and S ' , except that if a name \nis declared in both S and S ' , the two declarations must be consistent. We discuss the precise de.nition \nin Section 5.4. By using andalso, we can easily and concisely state that a COMBINED TYPE has all the \nproperties of both USERTYPE and COMBINED VIEWS. And because andalso correctly handles situ\u00adations in \nwhich type t is de.ned in both signatures, we don t have to plan ahead and use an ugly name like also \nt: module type COMBINED_VIEWS = sig type t module TV1 : TYPEVIEW revealing type TYPEVIEW.combined = t \nmodule TV2 : TYPEVIEW revealing type TYPEVIEW.combined = t end module type COMBINED_TYPE = USERTYPE andalso \nCOMBINED_VIEWS As another example, it is possible to use a signature to specify a single interesting \nproperty of a type, then combine properties using andalso: signature EQUATABLE = sig typet valeq:t->t->bool \nend signature COMPARABLE = sig type t val compare : t -> t -> order end signature HASHABLE = sig type \nt val hash : t -> word end signature SHOWABLE = sig type t val show : t -> string end signature HEAVILY_FEATURED \n= COMPARABLE andalso HASHABLE andalso SHOWABLE Similar signatures are found in commonly used ML libraries. \nThese signatures offer possibilities for reuse; for example, if they were standard, we would probably \nchange the de.nition of USERTYPE to be EQUATABLE andalso SHOWABLE.  5. Formal de.nitions To make the \nmeaning of our language clear, we have developed a formal semantics. Because our language manipulates \nand computes with signatures, our formal semantics is somewhat different from those used in related work \n(see Section 2). The main idea is that a signature denotes a set of components, divided into four subsets \nof different kinds. The details of elaborating abstract syntax into a denotation are less important and \nso are relegated to the companion technical report. Before getting to the main idea, we introduce some \nterminology and supporting concepts. 5.1 Preliminaries Identi.ers An identi.er is simply a name. As \nmetavariables, we use the identi.er x to stand for the name of a value, t to stand for the name of a \ntype, X to stand for the name of a module, and T to stand for the name of a signature. Unlike Leroy (1994, \n2000), we do not require that an identi.er be decorated or stamped with the location at which it is de.ned. \nWe do assume, in order to simplify this paper, that module names X are disjoint from type names t. Paths \nA path (sometimes called a quali.ed name ) selects a component from a module; every component can be \nidenti.ed uniquely by its path. Considered as a semantic object, a path p is de.ned inductively as follows: \n.... . .... . p . 1 xtX.p ARG.p RES.p Depending on whether it ends in 1, x, or t, a path can name a module, \na value, or a type. To select a part of a module, a module name X selects a submodule of a structure; \nan ARG or RES selects the argument or result of a functor. When notating paths, we omit a trailing .1. \nWe also use the dot to concatenate paths; when used this way, the dot is associative and has 1 as a left \nand right identity. We reassociate dots as needed. By the obvious homomorphic embedding, a syntactic \npath p is also a semantic path, and we use it as such. As shown in Figure 2, however, the set of syntactic \npaths does not include the empty path or any path that uses an ARG or RES selector. By not letting a \nprogrammer write ARG or RES, we preserve the existing syntax of paths, and we use the ML style of programming \nby pattern matching. Core-language requirements Like Leroy (2000), we intend our work to apply to more \nthan one core language, so we wish to min\u00adimize assumptions about the core language. Because our signature \nlanguage is much richer than Leroy s, we have assumed a simpler core language: one in which there are \nno nontrivial relations among Core-language judgments 0,D . as n a In context 0,D, syntax a elaborates \nto core-language type a . Our context 0,D may look a bit strange, but it is straightforward: 0 is a mapping \nfrom identi.ers to paths, which gives the path at which each in-scope identi.er is de.ned. D is the denotation \nof the parts of the signature elaborated so far. The substitution 0 and denotation D are used only to \nlook up paths of abstract types, so the core-language judgment 0,D . a n a . asn a can be implemented \nby a function of type (p n a option) n . e sn e Syntax e elaborates to core-language kind e. a . a ' \nCore-language types a and a ' are equivalent a <: a ' Core-language subtyping Core-language functions \nfreePaths(a ) The set of abstract types mentioned in type a . kind(a ) The kind of type a substTy (a \n' , p, a ) Substitute a ' for p in type a . ' ' For every abstract type in a whose name begins with \np, replace the pre.x p with new pre.x p replacePre.xTy (p ,p,a ) . Selected signature-language judgments \n 0 . ps n p In context 0, path p is an abbreviation for p. a @p Every abstract type in type a may be \nmentioned in a declaration at path p. D wf Denotation D is well formed. Figure 3. Judgments and functions \nkinds. Our assumptions apply to ML and some ML-like languages, but they would need to be relaxed to accomodate \nobject-oriented languages described with power kinds. We express our assumptions as formal judgments, \nproof rules for which or implementations of which must be provided by the designer of the core language. \nThese judgments are discussed below and summarized at the top of Fig\u00adure 3. Some judgments in Figure \n3 involve a denotation D, which is introduced in Section 5.2 below. We assume that the core language \nprovides semantic objects representing types a and kinds e, and that for each there is corre\u00adsponding \nsyntax a and e . We assume that there is a core-language judgment for type equality a . a ' . We also \nassume there is a core\u00adlanguage judgment for subtyping a<: a ' . (In core ML, subtyping is the at least \nas polymorphic as relation.) Finally, we assume the function kind(a ) can compute the core-language kind \nof any core-language type. In addition to these requirements, a core language must be ex\u00adtended with \nabstract types. As far as the core language is concerned, an abstract type is simply a path for which \na real core-language type may be substituted later. The path is annotated with a kind, and any substitution \nmust respect the kind. Our abstract type is slightly different from what programming experience might \nlead one to expect: it is a name that can be ab\u00adstracted over, not a type whose de.nition is hidden. \nIn excruci\u00adating detail, our abstract type is a type in an interface whose de.\u00adnition is unspeci.ed; \nit is represented by a path and kind. A type in an implementation whose de.nition is hidden is represented \nnot as an abstract type but as a fresh type constructor, written \u00b5. A fresh type constructor can never \nby introduced be a signature; a fresh type constructor can be introduced only by a structure. The abstract \ntypes that appear in a core-language type a are called the free paths of a . We require that the semantic \nrepresenta\u00adtion of types support two functions that help substitute for the free paths of a type. First, \nif e maps paths to core-language types, then function mapabs e performs the corresponding simultaneous \nsub\u00adstitution on a type. Second, the pre.x replacement of p with p ' in a , written replacePre.xTy (p, \np ' ,a ), replaces every abstract type of '' ''' the form p.p :: e with the new type p .p :: e. Abstract \ntypes not of the form p.p '' :: e are unchanged. This operation is useful in de.ning the moving modi.er, \namong others. A .nal requirement on the core language is that it be possible to discover substitutions \nfor abstract types by unifying lists of core-language types, as explained in the discussion of andalso \nin Section 5.4. Our core-language type-equality judgment a . a ' differs from the corresponding judgment \nin Leroy (1994, 2000). The difference is that Leroy s core language has to consult an environment to \n.nd de.nitions of manifest types. We handle manifest types in our elaboration step 0,D . asn a , so by \nthe time we get to judging equality, we no longer need the environment that keeps de.nitions of manifest \ntypes. Our handling of core-language types parallels that in the De.ni\u00adtion of Standard ML (Milner et \nal. 1997). Our distinction between abstract type and type constructor is handled in the De.nition using \nbinders. Our abstract type corresponds to the De.nition s .exible name, i.e., one that is bound in a \nsignature. Our type construc\u00adtor corresponds to a rigid name, i.e., one that is free in a sig\u00adnature. \nCreating a fresh type constructor corresponds to creating a new generative stamp. Our substitution for \nan abstract type cor\u00adresponds to the De.nition s type realization.  5.2 The denotation of a signature \nOur semantic framework builds on the intuition that a signature is a set of components. Unfortunately, \na real signature cannot be treated as a simple set a semantics must account for dependencies. Because \nthe type of a value can mention abstract types declared in the same signature, the declaration of a value \ncan depend on one or more abstract types. (Syntactically, the type of a value can also mention manifest \ntypes, but elaboration replaces manifest types with their de.nitions, so semantically, a value cannot \ndepend on a manifest type.)  Because the de.nition of a manifest type can mention abstract types declared \nin the same signature, the de.nition of a manifest type can depend on one or more abstract types. As \nfor a value declaration, elaboration replaces each use of a manifest type by  its de.nition, so there \nis no dependence on other manifest types. Figure 4. Structure of a SAMV denotation D Rules on dependencies \nare further complicated by the presence of functors: unlike a nested structure, a nested functor cannot \nintroduce types on which declarations in other components can depend. There is one exception: the argument \nsignature of a functor can introduce types on which the result signature of that functor depends. We \ndeal with these issues by de.ning the denotation of a signature to be not a single set of bindings, but \nfour sets of bindings: Sub\u00admodules, Abstract types, Manifest types, and Values. We call such a denotation \na SAMV form, pronounced sam-vee, and we write it as D. The four sets are DS, DA, DM , and DV . Each \nbinding in the set DS maps a path p to a tag that identi.es a module at that path. The tag is either \nstructure or functor. Given a binding (p, tag) in DS, we may instead write tag p. A binding in DS is \nindependent of all other bindings.  Each binding in the set DA maps a path p to a core-language kind \ne. The path uniquely identi.es an abstract type. Given a binding (p, e) in DA, we may instead write type \np :: e. A binding in DA is independent of all other bindings.  Each binding in the set DM maps a path \np to a manifest core\u00adlanguage type a . Given a binding (p, a ) in DM , we may instead write type p = \na .  The bindings in DM induce a substitution on core-language types. As noted above, we write this \nsubstitution mapabs DM . Such substitutions play a crucial role in subtyping of signatures. Because a \ncore-language type a may mention abstract types in DA, a binding in DM may depend on bindings in DA, \nbut it is independent of all other bindings. Each binding in the set DV maps a path p to a core-language \ntype a . An implementation of the signature promises to deliver, at that path, a value of type a (or \npossibly a core-language subtype of a ). Given a binding (p, a ) in DV , we may instead write val p : \na . Because a core-language type a may mention abstract types in DA, a binding in DV may depend on bindings \nin DA, but it is independent of all other bindings. Figure 4 shows the structure of a denotation, with \narrows to show possible dependencies. As a very simple example of a denotation, the signature signature \nS1 = sig type t= int val x:t end from Section 2 has the denotation .DS = {structure 1},DM = {type t \n= int}, DA = {},DV = {val x : int}). As an example of a denotation that includes an abstract type, here \nis the denotation of the USERTYPE signature: .DS = {structure 1}, DA = {type t :: *}, DM = {}, DV = {val \neq : t -t -bool, val to string : t -string}). As an example that includes nested structures and a mix \nof ab\u00adstract and manifest types, here is the denotation of signature COMBINED VIEWS: .DS = {structure \n1, structure TV1, structure TV2}, DA = {type t :: *, type TV1.t :: *, type TV2.t :: *}, DM = {type TV1.combined \n= t, type TV2.combined = t}, DV = {val TV1.map :(t n TV1.t) \u00d7 (TV1.t n t), val TV2.map :(t n TV2.t) \u00d7 \n(TV2.t n t)}). Finally, to show a functor, here is the denotation of BARECODE: .DS = {functor 1, structure \nARG, structure ARG.V, structure RES}, DA = {type ARG.V.value :: *, type ARG.V.state :: *, type ARG.V.usert \n:: *}, DM = {}, DV = {val ARG.apply : \u00b7\u00b7\u00b7 , val ARG.setglobal : \u00b7\u00b7\u00b7 , val RES.init : ARG.V.state n unit}). \nEach set in a denotation is .at, which is a signi.cant depar\u00adture from previous work. In previous work, \na language is typically de.ned using a term calculus with a reduction semantics; the deno\u00adtation of a \nsignature is a term in normal form. But components in a term are inherently ordered, and in many signatures \nthe order of most components is irrelevant. Using a .at denotation frees the se\u00admanticist (and the programmer!) \nfrom having to reason about order, e.g., by introducing a permutation. And splitting the denotation into \nfour sets simpli.es the treatment of dependency. As compared with forms containing explicit binders (Milner \net al. 1997; Russo 2001), we also make it easier to modify and compute with denotations. The price we \npay for the simplicity of a .at representation is that not every .at representation is meaningful. We \nrequire that a deno\u00adtation be well formed. Well-formedness requires that DA and DM be disjoint, so that \nno type is identi.ed as both abstract and mani\u00adfest, and that the free paths of DM and DV be in DA, so \nthat every abstract type mentioned in a signature is de.ned in the signature. But it is not enough to \nsay that every abstract type mentioned in the signature is de.ned in the signature. Although we are as \nliberal as possible in allowing a type or value declared in one submodule to depend on an abstract type \ndeclared in another submodule, we must impose restrictions for functors: An abstract type declared in \na functor s argument may be referred to only within that argument or within the corresponding result. \nAn abstract type declared in a functor s result may be referred to only within that result. These restrictions \nare checked by the judgment a @p, which is pronounced type a may be mentioned at path p. A type a may \nbe mentioned at path p if and only if for every ' '' abstract type p that a depends on, p @p. The rules \nfor p @p limit access to types declared in functors argument and result signatures. p ' does not contain \nARG or RES p.p ' @p.p '' p ' does not contain ARG or RES p.ARG.p ' @p.RES.p '' D ' 'p . dom(D ' : p \n. dom DS DS (p)= S (p) S ) 'p . dom(D ' : p . (dom DA * dom DM ) kindp(D)= A(p) D ' A) 'p . dom(DM \n' ): p . (dom DA * dom DM ) mapabs DM p . mapabs DMM (p)) (D ' 'p . dom(DV ' ): p . dom DV DV (p) <: \nmapabs DM (DV ' (p)) D<: D' D<: D ' 'p . dom(DV ' ): p . dom DV DV (p) . mapabs DM (DV ' (p)) D ;: \nD ' Figure 5. Rules for subtyping and tight subtyping In other words, either the two paths are in the \nsame structure, or the mentioning path is the result of a functor of which the mentioned path is the \nargument. Mentioning is transitive, so if p1 @p2 and p2 @p3 , then p1 @p3 . Putting these conditions \ntogether, we get a rule that says when a denotation is well formed. The judgment DS well-parented en\u00adsures \nthat DS faithfully describes the nested structure of submod\u00adules; its de.nition appears in the companion \ntechnical report. dom DA . dom DM = {} freePaths(rng DM * rng DV ) . dom DA '(p, a ) . DM * DV : a @p \nDS well-parented D wf A well-formed denotation need not have quite all its parts. In partic\u00adular, because \na functor s argument signature is elaborated before its result signature, a well-formed denotation may \nhave a functor s ar\u00adgument without the corresponding result. When elaboration is .n\u00adished, however, all \nparts are present. We express this property by the judgment DS complete. Our de.nition of well-formedness \nis more liberal than the syn\u00adtactic de.nition of well-formedness used by Leroy (1994, 2000). In particular, \nour de.nition permits mutual dependencies between submodules of a structure. For example, we can write \nmodule type MUTUAL = sig module M : sig type t end module N : sig type t val v:M.t end end as S adding \nval S.M.v : S.N.t This strange signature contains two nested submodules, each of which de.nes an abstract \ntype and a value. The value in each submodule is of the type de.ned in the other. Although such a signature \nseems strange at .rst (and is impossible to write in ML), it has a perfectly good denotation: D = .DS \n= {structure 1, structure M, structure N}, DA = {type M.t :: *, type N.t :: *}, DM = {}, DV = {val N.v \n:: M.t, val M.v :: N.t}) This denotation is in no way monstrous; there are plenty of struc\u00adtures that \nimplement it. Signatures with mutually recursive com\u00adponents are used by Crary, Harper, and Puri (1999) \nto introduce a special context which enables the elaboration of an implementation that contains mutually \nrecursive substructures. Our de.nition of well-formedness does exclude mutually recur\u00adsive manifest-type \nde.nitions; for example, there is no way to cre\u00adate a denotation that contains a pair of substructures \nM and N in which type M.t = N.u * N.u and type N.u = M.t * M.t.  5.3 Subtyping of denotations Subtyping \nplays a crucial role in determining whether an imple\u00admentation matches the corresponding interface: following \nLeroy (1994, 2000), one computes a principal signature for the imple\u00admentation, and if this signature \nis a subtype of the interface, the two match. In module subtyping, a functor s argument is contravariant. \nWe handle contravariance by identifying covariant and contravariant paths within each denotation. To \nkeep this paper simple, we present only the covariant case, which de.nes subtyping without functors. \nFull details for functors are in the companion technical report. The rules for signature subtyping appear \nin Figure 5. It may help to think of D as an implementation and D ' as an interface. To determine the \nkind of a type de.ned at path p in denotation D, we de.ne 8 < e if (p, e) . DA kindp(D) = kind(a ) if \n(p, a ) . DM : unde.ned otherwise Ignoring functors, the only tricky parts of subtyping involve manifest \ntypes. Essentially, when examining a manifest type in one signature, we must account for the manifest-type \nde.nitions in the other signature. We do this by treating a DM component as a substitution using the \nmapabs function. Here is a small but tricky example; each of these signatures is a subtype of the other: \nmodule type S = sig type t type u = t end module type S = sig type u type t = u end For this example, \nthe interesting subtyping conditions are D ' u . dom DM kind(DM (u)) = A(u) (D ' t . dom DA t :: * \n= mapabs DMM (t)). The .rst condition is trivially true (* = *), and the second holds because mapabs \nDM (u :: *)= t :: *. As shown in Figure 5, a val binding in a subtype need not pro\u00advide exactly what \nis called for in the supertype. For a supertype con\u00adtaining val x : a ' , it suf.ces for the subtype \nto provide val x : a where a satis.es the core-language subtyping judgment a<: a ' . For example, the \nempty list, which has type 'a.a list, could be used to satisfy a speci.cation calling for a value of \ntype int list. This ability is essential for implementors, but as explained below, it creates an ugly \nwart on the lattice structure of signatures. To remove this wart, we introduce tight subtyping, written \nD ;: D ' , which is also de.ned in Figure 5. Informally, we can interpret D ;: D ' to mean that an implementation \nmatching D satis.es the speci.ca\u00adtion D ' without resorting to core-language subtyping. 5.4 Elaboration \nOur language consists of a sequence of top-level declarations of the form signature T = S. Elaborating \na declaration may require that we elaborate a signature S, a component C, a sequence of components Cs, \na modi.er m, or a sequence of modi.ers ms. The elaboration rules themselves are too detailed for discussion \nhere; we describe some techniques below, but full details are relegated to the companion technical report. \nThe most important property of the elaboration rules is that if a top-level signature is elaborated successfully, \nthe resulting denotation is well formed and complete. Moreoever, our rules are consistent with those \nof Leroy (1994, 2000). To be precise, Leroy s rules judge a source-language signature to be well formed \nif and only if our rules elaborate it successfully. The two systems of rules also de.ne the same subtyping \nrelationship on signatures. Our language is therefore a conservative extension of Leroy s. The key idea \nbehind the proof is to choose the stamps used in Leroy s system such that each identi.er is stamped with \nthe path p at which it is declared. Because the two systems use different core-language judgments, the \nproof also requires a fairly ugly relation between the core-language judgments of our system and the \ncore-language judgments of Leroy s system. Our elaboration rules also support a universality property: \ngiven a well-formed, complete denotation, we can produce a source term that elaborates to it. Elaborating \npaths, components, and simple modi.ers When a component of a signature is introduced, it can be referred \nto by its identi.er. For example, in the result signature of BARECODE, the argument module C is referred \nto by its identi.er. Such identi.ers are also introduced by with p as pat. Like Leroy (2000), we track \nthese identi.ers using a substitution 0. The substitution is used mostly to elaborate paths: the judgment \n0 . psn p says that the .rst name in p appears in 0, and that by replacing that name using 0, we get \npath p. Elaboration of a component or modi.er takes place in a particu\u00adlar context, which is identi.ed \nby a path p. When elaboration adds a new component, rules rules check that new types may be men\u00adtioned \nat p, that new components are at paths not already occupied, and so on. For a component added by a modi.er, \nwhich may in\u00adclude an arbitrary path, rules check that the component is added to the signature being \nmodi.ed and not to some other signature. Removing components is easy; the only real restriction is that \none may not remove an abstract type without also removing every\u00adthing on which that type depends. Rebinding \na value or manifest type is equivalent to removing the old component, then adding the new one. Rebinding \nan abstract type is possible, but if anything depends on the type, its kind must not change. Rebinding \na submodule is more complicated but the spirit is the same. Moving components is also easy; the interesting \naspect is that moving or renaming an abstract type updates everything that de\u00adpends on it. Moving rules \nalso check that restrictions on mentioning remain satis.ed. The most interesting rules are for changing \ntranslucency and combining signatures. Changing translucency To make an abstract type manifest, that \nis, to reveal type p = a , there are a variety of side conditions on a : it must not depend on p, it \nmust have the right kind, and it must be mentionable at path p. The revealing module modi.er is essentially \na shorthand for revealing a collection of abstract types. But when we elaborate revealing module p = \np ' , we also check to see that the denotations at p and p ' have the same components at the same types \n(once type revelations are accounted for). This check is stricter than checks found in existing dialects \nof ML; we discuss alternatives in detail in Section 6.1. Making a manifest type abstract is a more complicated \nproblem. Consider signature S = sig type t = int val a :int -> int valb:t ->t end If we make the manifest \ntype t abstract, what are we to do with the value bindings? As pointed out by Mitchell and Plotkin (1988), \neach value binding could legitimately be given type int -> int, int -> t, t -> int, or t-> t. What we \nwant not to do is depend on the way the bindings are written syntactically. Values a and b have exactly \nthe same type and should get exactly the same treat\u00adment; it shouldn t matter if their types are written \nwith int or t. By default, we keep the original denotations of value bindings, so each binding above \nwould get type int -> int. If a programmer wants a more abstract type, the abstract version of the binding \nmust be put into the signature used for sealing. For example, we could write signature S = S sealing \nwith sig type t val a: int -> t end Signature S is equivalent to signature S _Equiv = sig type t val \na :int -> t val b :int -> int end This example shows the difference between sealing and ascription: if \na binding does not appear in the sealing signature, it shines through into the result. Combining signatures \nThe andalso operation computes a great\u00adest lower bound, that is, the most abstract signature that is \nan im\u00adplementation of the two input signatures. This operation is writ\u00adten D n D ' , and one might hope \nto de.ne it with respect to the signature-subtype ordering, but unfortunately, if the core language is \nML, there is no greatest lower bound in this ordering, even when two signatures have a common lower bound. \nThe reason is that an ML programmer can create an implementation either by using module-language mechnisms \nor by using polymorphism in the core language. For example, consider the following signatures: signature \nT = sig signature V = sig type t type t type u type u val x : t list val x : u list end end A programmer \ncan re.ne these two signatures to a common lower bound in two incomparable ways: by making t and u equal, \nor by giving x the polymorphic type a list. signature L1 = sig signature L2 = sig type t type t typeu=t \ntypeu valx:tlist valx: alist end end It is easy to show that L1 <: T, L1 <: V, L2 <: T, L2 <: V, and \nthere does not exist an M such that L1 <: M and L2 <: M , M<: T, and M<: V. The insight is that in writing \nL2, the pro\u00adgrammer has achieved signature subtyping by using core-language subtyping. If we rule out \ncore-language subtyping, however, then we can compute greatest lower bounds. For this reason, we consider \nthe partial order de.ned by the tight subtyping relation de.ned in Figure 5. Using this order and the \nde.nition of n below, we have shown that if T n V is well formed, then M ;: T n V if and only if M ;: \nT and M ;: V . Here is how we compute T n V . As for subtyping, we ignore the contravariance introduced \nby functors. The computations of \u00b0 A, E, and e are explained below. A\u00b0 =(TA * mapr kind TM ) *\u00b7(VA * \nmapr kind VM ) E = {p :: kind(a )= a | (p, a ) . TM }* {p :: kind(a )= a | (p, a ) . VM }* {a1 = a2 | \n(p, a1 ) . TV (p, a2 ) . VV } e= MGU (E) dom e . freePaths(rng e) = {} 'a : kind(mapabs e a )= kind(a \n) DS = TS *\u00b7VS DA = {(p, e) | (p, e) . A\u00b0 p/. dom e} DM =e DV = {(p, mapabs e a ) | (p, a ) . TV }* {(p, \nmapabs e a ) | (p, a ) . VV } D = T n V The function mapr kind replaces each type in TM and VM with its \ncorresponding kind. The *\u00b7symbol is consistent union: if :p :(p, v1 ) . A (p, v2 ) . B v1 .v2 , then \nA \u00b7 = *B is unde.ned; otherwise A *\u00b7B = A * B. The key to computing a greatest lower bound is to .nd \nas many manifest-type de.nitions as are necessary, but no more. We .nd these de.nitions through uni.cation; \nthe set E lists all of the equal\u00adities that have to hold for a common tight subtype of T and V , and \nwe .nd a most general uni.er e that will become the manifest\u00adtype de.nitions of the greatest lower bound. \nThe uni.cation is not the same as core-language uni.cation such as is used to implement Hindley-Milner \ntype inference. Our uni.cation allows us to substi\u00adtute a manifest type for an abstract type; there is \nno substitution for type variables.3 Substitution for type variables makes a signature smaller, and we \nare computing the largest signature that is below both T and V . Once we have the substitution, computing \nthe great\u00adest lower bound is easy. To prove that n is a greatest lower bound requires one key lemma: \nif M ;: T and M ;: V , and if D = T n V is de.ned, then mapabs MM = mapabs MM . mapabs DM . The lemma \nholds because M must satisfy all the equations in E. The de.nition above assumes there are no functors. \nWe have extended our de.nition to signatures that include functors, but only for the positive tight subtyping \nrelation on signatures. That is, for T n V to be de.ned, we require that the functor arguments be equivalent. \nExtension to fully contravariant functor arguments, like the dual greatest-upper-bound operation, awaits \nfuture work. 5.5 Scaling to realistic inputs In this paper, we focus on elaboration of correct signatures. \nBut we want to handle programs that have structures and functors, as well as programs that contain errors. \nStructures and functors We have written and implemented rules that elaborate structures and functors \nto their principal signatures; syntax and semantics appear in the companion technical report. The rules \nare similar to the rules for signatures, with two kinds of additions: naming and generativity. 3 There \nare restrictions; for example, the type that is substituted must be a de.nable type in ML, not polymorphic. \nA signi.cant difference from core-language uni.cation is that in our uni.cation problem, each equality \nconstraint is associated with one or two named bindings. Therefore if the uni.cation fails, it should \nbe easy to explain what went wrong. When we refer to a structure by name, we preserve identity of abstract \ntypes. For example, suppose we have structure M = ... structure N = M The denotation at path N is like \nthe denotation at path M, except that every abstract type must be made manifestly equal to the cor\u00adresponding \ntype at path M (unless the abstract type appears under a functor). This operation corresonds to Leroy \ns (1994) strengthen\u00ading operation. When we ascribe a signature to a structure, we replace each abstract \ntype with a fresh type constructor: ascription is generative. If the ascription takes place in the body \nof a functor, generation of fresh type constructors is delayed until the functor is applied. Error messages \nIt is not enough to elaborate well-typed pro\u00adgrams successfully; when a program fails to elaborate, a \ncompiler must issue a reasonable error message. In our system, if a construct does not elaborate, the \ncompiler has a context that includes a path and a denotation. Given this context, issuing reasonable \nerror mes\u00adsages is easy. Here are a few examples: If a condition such as p.x /. dom DV fails, we can \nissue a message such as multiple declarations of value p.x.  If a condition such as D<: D ' fails, one \nor more of the univer\u00adsally quanti.ed predicates in Figure 5 is unsatis.ed. For each path not satisfying \na predicate, we can issue a message such as value p.x expected but not provided or type a of value p.x \ndoes not match the expected type a ' .  If a condition such as a @p fails, we can report that the type \na appearing outside a functor refers to an abstract type de.ned in that functor s argument or result \nsignature.  If we fail to form T nV , we can issue a message such as in sig\u00adnatures joined with andalso, \nvalue p.x has incompatible types a and a ' or type p.t has incompatible de.nitions a and a ' .  In \nall cases, we can issue messages that refer not to whole deno\u00adtations but to individual components of \nsignatures; we hope a pro\u00adgrammer could understand such messages without diving into de\u00adtails of SAMV \nform.  6. Discussion To conserve space, we limit discussion to two topics: alternatives to the operations \nwe propose and potential applications of our operations to structures and functors. 6.1 Design alternatives \nThe operations we propose may not be canonical or de.nitive we intend them as a basis for discussion \nand re.nement. In this section we discuss some design alternatives and motivations. Environments and \nthe expressive power of modi.ers To make an abstract type manifest, Standard ML and Objective Caml of\u00adfer \na where type or with type operation. This operation dif\u00adfers from our proposal primarily in its use of \nenvironments. In our revealing type p = a , the path on the left and the type on the right are evaluated \nin the same environment. In the exist\u00ading languages, the path on the left is evaluated inside the sig\u00adnature \nbeing modi.ed, where the type on the right is evaluated outside the signature. Thus ML s idiomatic with \ntype t =t is not a tautology. Our operation evaluates both sides outside the signature, requiring a quali.ed \npath name to refer to any com\u00adponent of the signature. A seasoned ML programmer may .nd revealing type \nS.t = int ugly when compared with the more familiar with type t = int. And it would certainly be possible \nto change our proposal to be more consistent with ML. But we have two reasons to prefer our design. The \n.rst is a religious preference: we believe that the most appropriate way to use the equals sign is to \nelaborate left and right sides in the same environment, so a pro\u00adgrammer can conclude that in the given \nenvironment, both sides mean the same thing. The second reason is more substantial: by making both internal \nand external environments available on each side of the equals sign, we make revealing type expressive \nenough that it can subsume Standard ML s sharing constraints. As an example, Dave Mac-Queen provided \na Standard ML version of the following signature: signature WHERE_POWER = sig module A : sig type t type \ns end module B : sig val x : A.t type u type v= ulist end (* SML: sharing type A.s = B.v *) end as S \nrevealing type S.A.s = S.B.v The two submodules A and B have a mutual dependency: value B.x depends on \ntype A.t, and manifest type A.s depends on type B.u. This dependency can be seen in the denotation: .DS \n= {structure 1, structure A, structure B}, DA = {type A.t :: *, type B.u :: *}, DM = {type B.v = B.u \nlist, type A.s = B.u list}, DV = {val B.x : A.t}) As the source-code comment shows, expressing this dependency \nin Standard ML requires a sharing type constraint. But a sharing type constraint simply equates two paths \nthat are elaborated inside the signature, and because in our language the internals of the signature \nare available on both sides of the equals sign, we can express such constraints using only revealing \ntype. The price is that we must use quali.ed names. For consistency, we use such names even for the removing \nmodi.er, which can never refer to anything outside the signature. An alternative that might be more attractive \nto an ML tradition\u00adalist would be to de.ne revealing type so that it would have the expressive power \nof our version without requiring quali.ed names everywhere. The critical requirement is that the signature \ns inter\u00adnals be accessible on the right side of the equals sign; our tradi\u00adtionalist could provide such \naccess using special syntax while oth\u00aderwise keeping the environments as they are now. Families of signatures \nWhy, if we wish to de.ne an expressive language of signatures, do we not include a lambda-like parame\u00adterization \nmechanism, so a signature may be parameterized over a type, for example? In short, because we don t need \nto: the same ends can be achieved by putting an abstract type in a signature and later revealing that \ntype. This design, called .bration, is prefer\u00adable for other reasons (Harper and Pierce 2005, \u00a7\u00a78.7 8.8). \nUsing .bration, one need not identify certain abstract types as param\u00adeters in advance; as in the example \nwhere we re.ne BARECODE, one can simply modify an abstract type after the fact. Equally im\u00adportant, as \nexplained by Harper and Pierce, .bration scales better when programs are built using deep hierarchies \nof functors. Fibration of structures The revealing module modi.er can be thought of as a sort of syntactic \nshorthand that applies revealing type to all the abstract types (DA) of the signature being modi.ed. \nIn designing a semantics for revealing module, however, there are many choices what to do about other \ncomponents. We begin by reviewing what happens in existing languages. Objective Caml provides similar \nfunctionality in the form of with module. The only requirement stated in the manual is that given S with \nmodule p = p ' , each abstract type in the submod\u00adule at p must have a corresponding type component (abstract \nor manifest) in the module at p ' . The implementation, however, ap\u00adpears to check consistency of other \ncomponents of p, including val\u00adues and manifest types. The module at p ' may have additional value and \ntype components that are not present at p. Although it supports .bration via where type, Standard ML \nlacks a corresponding operation for structures. Such an operation has been added as an extension to Standard \nML of New Jersey; documentation is thin, but experiments with the implementation show that it is more \npermissive than in Caml. In particular, manifest types need not be the same in modules at p and p ' . \nStandard ML also has sharing, which as noted above, performs some of the same functions as revealing. \nThe semantics of sharing has an interesting history. When Standard ML was formalized in 1990, the semantics \nof sharing guaranteed identity of the two structures being shared. When Standard ML was revised in 1997, \nthe notion of structure identity was dropped from the semantics, and a sharing con\u00adstraint became syntactic \nsugar for a collection of sharing type constraints. The De.nition (Milner et al. 1997, \u00a7G.3) notes that \nsharing was seldom used to enforce identity of values, and that dropping structure identity greatly simpli.ed \nthe semantics. Unfor\u00adtunately, the expansion of sharing into sharing type has a prop\u00aderty perhaps best \nregarded as a bug: it is de.ned only when the DM components of both signatures are empty. Some compilers \nignore this restriction, but because portable code must respect it, structure sharing is often inadequate \nto express requirements of complex Standard ML programs. In.uenced by the original de.nition of sharing, \nwhich en\u00adforced structure identity, we have chosen to impose strict require\u00adments on revealing module \np = p . When the denotations of the corresponding substructures are D and D ' , we consider all four \nSAMV parts: For abstract types in DA, we have the same treatment as Ob\u00adjective Caml: each abstract type \nis made manifestly equal to the corresponding type in D ' , which may be abstract or manifest. We substitute \naccordingly in DM and DV .  For DS , DM , and DV , we enforce consistency with the cor\u00adresponding components \nin D ' . Here consistency means that both denotations have the same components, and after appro\u00adpriate \nsubstitutions have been applied, corresponding types are equal.  These requirements can be expressed \nconcisely using subtyping: D ' <: D, and the domains of submodule, type, and value parts are equal. Our \nrequirements are close to those of Objective Caml, but unlike Caml, we do not permit extra components \nin D ' . Our requirements do not go so far as to enforce structure identity, but by being so restrictive, \nthey increase the chances that revealing module on non-identical structures will cause a type error. \nSealing Unlike our other operations, sealing is grounded in theoretical considerations, not practical \nones. Following Mitchell and Plotkin (1988), we believe that the appropriate way to make a manifest type \nabstract is to seal the type and its operations as a unit; only in this way can we decide what type should \nbe given to each operation. This design makes sealing asymmetric with revealing; revealing the de.nition \nof an abstract type also reveals the types of all the operations, so the programmer has no decisions \nto make about the types of operations. One alternative would separate a type from its operations and \nprovide a more symmetric sealing operation that would simply make a manifest type abstract without changing \nthe type of any op\u00aderation. To make the types of some operations more abstract, a pro\u00adgrammer could use \nrebinding. For example, if we call the sym\u00admetric sealing operation hiding, we might express the sealing \nexample from Section 5.4 as signature S = S hiding type S.t rebinding val S.a : int -> t For two reasons, \nthis alternative makes us uneasy: The alternative assumes that when we wish to make a type and a set \nof operations abstract, we are willing to write out new types for all the operations explicitly. This \nassumption reminds us of the current situation in ML, in which the way to write a signature is to write \nout all its components. Our preferred design makes it possible to seal with a pre-existing signature, \nor to seal multiple signatures with some common third signature. But because we have not been able to \nshow that these possibilities are useful in real programs, this objection may not have much force.  \nThe symmetry of the alternative is more apparent than real. In particular, if a programmer were to reveal \nthe de.nition of an abstract type, then hide it again using the alternative operation, any operations \nthat originally used the abstract type would still use the revealed representation, so the result would \nnot necessarily be the same as the original signature.  Conclusions on the merits of sealing await practical \nexperience. Combining signatures The most useful way we have found to combine signatures is with andalso: \nthe result signature has all the components of both argument signatures. But signatures could also be \ncombined in other ways. For example, one could consider taking an intersection of components. This operation, \nwhich might be called orelse, would have the property that a module M would implement the signature S \norelse S ' iff it implemented either signature S or signature S ' . The orelse operation presents some \ntechnical challenges, and because we have not found a use for it, we have postponed work on it. We also \nconsidered de.ning an operation analogous to set dif\u00adference, so that given signatures S and S ' , it \nmight be possible to .nd an S '' such that S =(S andalso S ' ) minus S '' . But in the interesting cases, \nS '' is not a complete signature, so we have not looked further into set difference. Concrete syntax \nRegarding concrete syntax, we have borrowed existing ML forms and keywords where we could. In particular, \nwe have used post.x modi.ers to change the meaning of a signature; we have used as for pattern matching; \nand we have kept close to the standard type, val, and module syntax for components. Where no existing \nform or keyword seemed to serve, we have aimed for regular, orthogonal syntax by making each new keyword \nthe gerund form of a verb. What we have not tried to do is keep new keywords to a minimum; for this reason, \nour concrete syntax may be ill suited to adoption in an existing language. 6.2 Extension to implementations \nModi.cation of signatures is only a beginning; programmers will want to combine implementations as well \nas interfaces. Although we have not formalized operations on implementations, we believe that most of \nour language should extend nicely to implementations. Preliminary observations Implementations include \nboth struc\u00adtures and functors, but we would like to take modi.cation of struc\u00adtures as fundamental. We \nhope to treat modi.cation of functors by sinking any modi.cation inside the functor, where it would be \napplied to the functor s body. Loosely speaking, we hope to de.ne a functor modi.cation m in terms of \na structure modi.cation m ' such that (F m)(Arg) would be equivalent to (F(Arg)) m ' . When we speak \nof modifying a structure, we are really speak\u00ading of modying the interface to that structure the internals \nremain unchanged. In core-language terms, a structure modi.cation might hide old bindings and add new \nones, but internal references be\u00adtween existing components should never be affected. In implemen\u00adtation \nterms, if a structure is represented as a record of values, struc\u00adture modi.cations should build new \nrecords from old, but no values should be changed. After all functors have been applied, the denotation \nof a struc\u00adture has no abstract types: signature ascription and functor appli\u00adcation replace abstract \ntypes with fresh type constructors. Keeping this property in mind helps us think about modifying structures. \nAs in our language of signatures, we hope to help programmers reason about equality. But reasoning about \nequality of structures is more dif.cult: to decide when two signatures are the same, we need only reason \nabout equality of types, but to decide when two structures are the same, we must reason about equality \nof values. Applying our operations to structures Many of our operations should extend to structures without \nmuch thought, but there are a few cases where care should be taken. We consider each group of operations \nin turn. Changing translucency Because a structure has no abstract types, only fresh type constructors, \nthe operations that change translu\u00adcency don t apply. But the sealing operation has a close analog: signature \nascription, which can replace existing types with fresh type constructors. To reduce the notational burden \nin cases where most bindings are unchanged, we could extend sealing to struc\u00adtures. But if a structure \nalready has an explicit signature, it is just as expressive to modify that signature using sealing and \nthen use ascription with the result. Looking for an analog of revealing would be a bad move, since it \nwould break the abstraction imposed by ascription. We want not to support such things. Adding, removing, \nand changing components Adding, removing, and moving (renaming) a structure s components appear to present \nno problems. Rebinding values is also simple. Rebinding types or modules would have to be restricted \nto avoid changing a type on which other types or values might depend. Combining structures Combining \nstructures with andalso should be very useful: several simple components could be merged to im\u00adplement \na complex absraction. Deciding which structures should be combinable exposes some interesting design \nchoices. These choices arise when the two structures have components in com\u00admon. When such components \nare types, we can require them to be equal, or if we want to exploit polymorphism, we can take the least \nupper bound of two types. Values offer more choices. The choice most consistent with our philosophy is \nto require common value components to be equal, but if the type of such components is not an equality \ntype, this requirement cannot be checked. If having value components in common is mostly accidental, \nwe could ask the programmer to remove con.icting components before combining the structures. But if we \nthink it is likely that combined structures will often have value components in common, and if those \ncomponents are likely to include functions or other values that can t be compared for equality, it makes \nmore sense to de.ne andalso to be asymmetric (as it is in the term language) and to prefer value components \nfrom its left-hand argument.  7. Conclusion Large software systems are built from modules, many of which \nmay be provided and maintained by separate groups. The relation\u00adships among the signatures of these modules \nare important enough to be expressed formally, but existing languages are not expres\u00adsive enough. We \nhave designed a signi.cantly more expressive lan\u00adguage, proven that it is a conservative extension of \nML, and shown its use in an extended example. We have also implemented the lan\u00adguage and have mechanically \nchecked the indented examples from this paper. In future work, we hope to make our language part of the \nMoby programming language (Fisher and Reppy 1999).  Acknowledgments J\u00a8urgen P.tzenmaier extended the \nimplementation of Objective Caml to support an earlier version of our language. Greg Morrisett provided \nseveral helpful comments on an earlier draft. Matthew Fluet suggested several signatures intended to \nbe combined with andalso. Anonymous referees contributed materially to the im\u00adprovement of this paper; \nwe are especially grateful to the referee who called our attention to issues with Standard ML sharing \nconstraints. Several referees were unusually generous with their time and effort; we regret not being \nable to keep up with all of their suggestions. This work was supported in part by NSF grants CCR-0311482 \nand ITR-0325460 and by an Alfred P. Sloan Re\u00adsearch Fellowship, References Matthias Blume and Andrew \nW. Appel. 1999 (July). Hierarchical modularity. ACM Transactions on Programming Languages and Systems, \n21(4):813 847. Karl Crary, Robert Harper, and Sidd Puri. 1999 (May). What is a recursive module? Proceedings \nof the ACM SIGPLAN 99 Con\u00adference on Programming Language Design and Implementation, in SIGPLAN Notices, \n34(5):50 63. Derek Dreyer, Karl Crary, and Robert Harper. 2003 (January). A type system for higher-order \nmodules. Conference Record of the 30th Annual ACM Symposium on Principles of Programming Languages, in \nSIGPLAN Notices, 38(1):236 249. Kathleen Fisher and John Reppy. 1999 (May). The design of a class mechanism \nfor Moby. Proceedings of the ACM SIGPLAN 99 Conference on Programming Language Design and Imple\u00admentation, \nin SIGPLAN Notices, 34(5):37 49. Robert Harper and Mark Lillibridge. 1994 (January). A type\u00adtheoretic \napproach to higher-order modules with sharing. In Conference Record of the 21st Annual ACM Symposium \non Prin\u00adciples of Programming Languages, pages 123 137. Robert Harper and Benjamin C. Pierce. 2005. Design \nconsider\u00adations for ML-style module systems. In Benjamin C. Pierce, editor, Advanced Topics in Types \nand Programming Languages, chapter 8. MIT Press. Robert Harper and Christopher Stone. 2000. A type-theoretic \ninter\u00adpretation of Standard ML. In Gordon Plotkin, Colin Stirling, and Mads Tofte, editors, Proof, Language \nand Interaction: Essays in Honour of Robin Milner. MIT Press. Roberto Ierusalimschy. 2003 (December). \nProgramming in Lua. Lua.Org. ISBN 85-903798-1-7. Xavier Leroy. 1994 (January). Manifest types, modules, \nand separate compilation. In Conference Record of the 21st Annual ACM Symposium on Principles of Programming \nLanguages, pages 109 122. Xavier Leroy. 2000 (May). A modular module system. Journal of Functional Programming, \n10(3):269 303. Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. 1997. The De.nition of Standard \nML (Revised). MIT Press, Cambridge, Massachusetts. John C. Mitchell and Gordon D. Plotkin. 1988 (July). \nAbstract types have existential type. ACM Transactions on Programming Languages and Systems, 10(3):470 \n502. Norman Ramsey, Kathleen Fisher, and Paul Govereau. 2005 (September). An expressive language of interfaces \n extended version. Technical report, Division of Engineering and Applied Sciences, Harvard University. \nTo appear. Claudio V. Russo. 2001 (October). Recursive structures for Stan\u00addard ML. Proceedings of the \nSixth ACM SIGPLAN Interna\u00adtional Conference on Functional Programming (ICFP 01), in SIGPLAN Notices, \n36(10):50 61.  \n\t\t\t", "proc_id": "1086365", "abstract": "Current languages allow a programmer to describe an interface only by enumerating its parts, possibly including other interfaces wholesale. Such languages cannot express relationships between interfaces, yet when independently developed software components are combined into a larger system, significant relationships arise.To address this shortcoming, we define, as a conservative extension of ML, a language for manipulating interfaces. Our language includes operations for adding, renaming, and removing components; for changing the type associated with a value; for making manifest types abstract and vice versa; and for combining interfaces. These operations can express useful relationships among interfaces. We have defined a formal semantics in which an interface denotes a group of four sets; we show how these sets determine a subtyping relation, and we sketch the elaboration of an interface into its denotation.", "authors": [{"name": "Norman Ramsey", "author_profile_id": "81100300481", "affiliation": "Division of Engineering and Applied Sciences, Harvard University", "person_id": "PP14110628", "email_address": "", "orcid_id": ""}, {"name": "Kathleen Fisher", "author_profile_id": "81331492634", "affiliation": "AT&T Labs Research", "person_id": "PP43124113", "email_address": "", "orcid_id": ""}, {"name": "Paul Govereau", "author_profile_id": "81100380486", "affiliation": "Division of Engineering and Applied Sciences, Harvard University", "person_id": "P745803", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086371", "year": "2005", "article_id": "1086371", "conference": "ICFP", "title": "An expressive language of signatures", "url": "http://dl.acm.org/citation.cfm?id=1086371"}