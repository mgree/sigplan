{"article_publication_date": "09-12-2005", "fulltext": "\n Scrap your Nameplate (Functional Pearl) James Cheney University of Edinburgh Edinburgh, United Kingdom \n jcheney@inf.ed.ac.uk Abstract Recent research has shown how boilerplate code, or repetitive code for \ntraversing datatypes, can be eliminated using generic program\u00adming techniques already available within \nsome implementations of Haskell. One particularly intractable kind of boilerplate is name\u00adplate, or code \nhaving to do with names, name-binding, and fresh name generation. One reason for the dif.culty is that \noperations on data structures involving names, as usually implemented, are not regular instances of standard \nmap, fold, or zip operations. How\u00adever, in nominal abstract syntax, an alternative treatment of names \nand binding based on swapping, operations such as a-equivalence, capture-avoiding substitution, and free \nvariable set functions are much better-behaved. In this paper, we show how nominal abstract syntax techniques \nsimilar to those of FreshML can be provided as a Haskell library called FreshLib. In addition, we show \nhow existing generic pro\u00adgramming techniques can be used to reduce the amount of name\u00adplate code that \nneeds to be written for new datatypes involving names and binding to almost nothing in short, how to \nscrap your nameplate. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs \nand Features General Terms Languages Keywords generic programming, names, binding, substitution 1. Introduction \nMany programming tasks in a statically typed programming lan\u00adguage such as Haskell are more complicated \nthan they ought to be because of the need to write boilerplate code for travers\u00ading user-de.ned datatypes. \nGeneric programming (the ability to write programs that work for any datatype) was once thought to require \nsigni.cant language extensions or external tools (for ex\u00adample, Generic Haskell [20]). However, over \nthe last few years it has been shown by several authors that a great deal of generic pro\u00adgramming can \nbe performed safely using well-understood existing extensions to Haskell (using Hinze and Peyton Jones \nderivable Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n05 September 26 28, 2005, Tallinn, Estonia. Copyright c . 2005 ACM 1-59593-064-7/05/0009. . . $5.00. \ntype classes [13], or L\u00a8ammel and Peyton Jones scrap your boiler\u00adplate (SYB) approach [17, 18, 19]) or \neven entirely within Haskell 98 (using Hinze s generics for the masses [12]). Using these tech\u00adniques \nit is possible to eliminate many forms of boilerplate code. One form of boilerplate that is especially \nannoying is what we shall call nameplate: code that deals with names, fresh name gen\u00aderation, equality-up-to-safe-renaming, \nfree variables, and capture\u00adavoiding substitution. The code to accomplish these tasks usu\u00adally seems \nstraightforward, even trivial, but nevertheless apparently must be written on a per-datatype basis. The \nmain reason for this is that capture-avoiding substitution, FV (-), and a-equivalence are, as usually \nwritten, not uniform instances of map, fold, or zip. Al\u00adthough most cases are straightforward, cases \ninvolving variables or name-binding require special treatment. Despite the fact that it in\u00advolves writing \na lot of repetitive nameplate, the classical .rst-order approach to programming abstract syntax with \nnames and binding is the most popular in practice. One class of alternatives is name-free techniques \nsuch as de Bruijn indices [9] in which bound names are encoded using point\u00aders or numerical indices. \nWhile often a very effective and prac\u00adtical implementation or compilation technique, these approaches \nare tricky to implement, hard for non-experts to understand, and do not provide any special assistance \nwith open terms, fresh name generation or exotic forms of binding, such as pattern-matching constructs \nin functional languages. Also, for some tasks, such as inlining, name-free approaches seem to require \nmore implementa\u00adtion effort while not being much more ef.cient than name-based approaches [15]. Another \nalternative is higher-order abstract syntax [24]: the technique of encoding object-language variables \nand binding forms using the variables and binding forms of the metalanguage. This has many advantages: \nef.cient implementations of a-equivalence and capture-avoiding substitution are inherited from the metalan\u00adguage, \nand all low-level name-management details (including side\u00adeffects) are hidden, freeing the programmer \nto focus on high-level problems instead. While this is a very powerful approach, most in\u00adteresting programming \ntasks involving higher-order abstract syntax require higher-order uni.cation, which is common in higher-order \nlogic programming languages such as .Prolog [23] but not in func\u00adtional languages, Haskell in particular. \nTherefore, using higher\u00adorder abstract syntax in Haskell would require signi.cant language extensions. \nAlso, like name-free approaches, higher-order abstract syntax does not provide any special support for \nprogramming with open terms, fresh name generation, or exotic forms of binding. A third alternative, \nwhich we advocate, is nominal abstract syn\u00adtax, the swapping-based approach to abstract syntax with bound \nnames introduced by Gabbay and Pitts [10, 11, 25] and employed in the FreshML (or FreshOCaml) [26, 30] \nand aProlog [7] languages. This approach retains many of the advantages of .rst-order abstract syntax \nwhile providing systematic support for a-equivalence and fresh name generation. Moreover, as we shall \nshow, nominal ab\u00adstract syntax can be implemented directly in Haskell using type classes, and the de.nitions \nof nameplate functions such as capture\u00adavoiding substitution and free variables can be generated automat\u00adically \nfor user-de.ned types. Thus, nominal abstract syntax and generic programming techniques can be fruitfully \ncombined to pro\u00advide much of the convenience of higher-order abstract syntax with\u00adout sacri.cing the \nexpressiveness of .rst-order abstract syntax and without any language extensions beyond those needed \nalready for generic programming in Haskell. The purpose of this paper is to show how to scrap your name\u00adplate \nby combining nominal abstract syntax with existing generic programming techniques available in Haskell \nimplementations such as ghc. As illustration, we develop a small library called FreshLib for FreshML-style \nprogramming with nominal abstract syntax in Haskell. The main technical contribution of this paper over \nprevious work on FreshML is showing how generic program\u00adming techniques already available in ghc can \nbe used to eliminate most of the work in implementing capture-avoiding substitution and free-variables \ncomputations. Although our implementation uses advanced features currently present only in ghc, we believe \nour technique to be applicable in other situations as well. The remainder of the paper is structured \nas follows. Sec\u00adtion 2 provides a high-level overview and three examples of using FreshLib from the user \ns point of view, emphasizing the fact that the library just works without the user needing to understand \nnominal abstract syntax or generic programming a priori or being obliged to write reams of boilerplate \ncode. Section 3 introduces the key concepts of nominal abstract syntax and describes an ini\u00adtial, type \nclass-based implementation of FreshLib. Section 4 shows how FreshLib can be made completely generic using \nHinze and Peyton Jones derivable type classes [13] and L\u00a8ammel and Peyton Jones scrap your boilerplate \nwith class [19]; this section is very technical and relies heavily on familiarity with L\u00a8ammel and Peyton \nJones paper, so casual readers may prefer to skip it on .rst read\u00ading. Section 5 discusses extensions \nsuch as handling user-de.ned name types and alternative binding forms. Section 6 and Section 7 discuss \nrelated work and conclude. 2. FreshLib overview and examples 2.1 FreshLib basics In nominal abstract \nsyntax, it is assumed that one or more special data types of names is given. FreshLib provides a data \ntype Name of string-valued names with optional integer tags: data Name = Name String (Maybe Int) with \ninstances for Eq, Show, and other standard classes. By con\u00advention, user-provided names (written a, b, \nc) have no tag, whereas names generated by FreshLib (written a0, b1, etc.) are tagged. The next ingredient \nof nominal abstract syntax is the assump\u00adtion that all types involved in abstract syntax trees possess \nan a\u00adequivalence (==a) relation (in addition to some other functions which the casual user doesn t need \nto know about): class Nom a where - ==a - :: a . a . Bool --other members discussed in Section 3 Any \ndatatype involving Names and name-binding needs to be an instance of Nom; however, FreshLib provides \ninstances for Name, the abstraction constructor (see below), and all of Haskell s built-in types and \nconstructors. Moreover, generic instances for user-de.ned datatypes can be derived automatically. As \na result, the library user only needs to provide instances for Nom when the default behavior is not desired, \ne.g. when implementing a datatype with exotic binding structure (Section 5.3). In addition, FreshLib \nprovides a type constructor a \\ b for name-abstractions, or data with binding structure: data a \\ b = \na \\ b Syntactically, this is just pairing. However, when a is Name and b is an instance of Nom, Name \n\\ b has special meaning: it repre\u00adsents elements of b with one bound Name. The provided instance declarations \nof Nom for Name \\ b de.ne (==a) as a-equivalence, that is, equivalence up to safe renaming of bound names. \nFor exam\u00adple, we have > a \\ a ==a b \\ b True > a \\ (a, b) ==a b \\ (a, b) False > a \\ b ==a b \\ a False \n> c \\ (a, c) ==a b \\ (a, b) True Other types besides Name can also be treated as binders, but we will \nstick with Name-bindings only for now; we will discuss this further in Section 5.3. The Name and - \\ \n- types are meant to be incorporated into user-de.ned datatypes for abstract syntax trees involving names \nand binding. We will give examples in Section 2.2 and Section 2.3. Another important component of nominal \nabstract syntax is the ability to generate fresh names. In Haskell, one way of accomplish\u00ading this is \nto use a monad. Rather than .xing a (probably too spe\u00adci.c) monad and forcing all users of FreshLib to \nuse it, FreshLib provides a type class of freshness monads that can rename existing names to fresh ones: \nclass Monad m . FreshM m where renameFM :: Name . m Name One application of the freshness monad is to \nprovide a monadic destructor for Name \\ a that freshens the bound name: unAbs :: FreshM m . Name \\ a \n. m (Name, a) Unlike in FreshML, pattern matching against the abstraction con\u00adstructor \\ does not automatically \nfreshen the name bound by the abstraction; instead, we need to use the unAbs destructor to explic\u00aditly \nfreshen names.1 In addition to providing a-equivalence, FreshLib also pro\u00advides type classes Subst and \nFreeVars{|-|} that perform capture\u00adavoiding substitution and calculate sets of free names: class Subst \nt u where [- . -] - :: FreshM m . Name . t . u . mu class FreeVars{|t|} u where FV {|t|}(-) :: u . [Name \n] Intuitively, Subst t u provides a substitution function that replaces variables of type t in u; similarly, \nFreeVars{|t|} u provides a func\u00adtion that calculates a list of the free variables of type t in u. Note \nthat for Subst, we may need to generate fresh names (e.g. when substituting into an abstraction), so \nwe need to work in some fresh\u00adness monad m. For FreeVars{|t|}, fresh name generation is not needed; however, \nwe do need to specify the type t whose free vari\u00adables we seek.2 Appropriate instances of Subst and FreeVars{|-|}for \nName, \\ , and all built-in datatypes are provided. 1 We could hide the constructor \\ using Haskell s \nmodule system and in\u00adstead only export a constructor abs :: a . b . a \\ b and the destructor unAbs; this \nwould legislate that abstractions can only be unpacked using unAbs. But, this would force freshening \n(and require computation to take place in a monad) even when unnecessary. For the same reason, the current \nversion of FreshML also provides two ways of pattern matching abstrac\u00adtions, one that freshens and one \nthat does not. 2 Explicit type-passing f {|t|} is not allowed in Haskell, but can be simulated by passing \na dummy argument of type t (for example, unde.ned :: t) module Lam where import FreshLib data Lam = Var \nName | App Lam Lam | Lam (Name \\ Lam) deriving (Nom, Eq, Show) instance HasVar Lam where is var (Var \nx)= Just x is vary = Nothing Figure 1. Nameplate-free implementation of Lam cbn eval :: FreshM m . Lam \n. m Lam cbn eval (App t1 t2)= do w . cbn eval t1 case w of Lam (a \\ u) . do v . [a . t2]u cbn eval v \n. return (App w t2) cbn eval x = return x Figure 2. Call-by-name evaluation Note that substitution and \nfree variable sets are not completely type-directed calculations: we need to know something about the \nstructure of t in each case. Speci.cally, we need to know how to extract a Name from a variable of type \nt. Therefore, FreshLib provides a class HasVar providing a function is var that tests whether the t value \nis a variable, and if so, extracts its name: class HasVar t where is var :: t . Maybe Name Once HasVar \nt is instantiated, instances of Subst t u and FreeVars{|t|} u are derived automatically. FreshLib provides \nan instance of HasVar Name; a name can be considered as a variable that could be replaced with another \nname. For example, > FV {|Name|}(a \\ (a, b)) [b ] > runFM ([b . a](a \\ (a, b))) a0 \\ (a0, a) where runFM \nis a function that evaluates a monadic expression in a particular FreshM FM . (Recall that names of the \nform a0,a1, ... are names that have been freshly generated by the FreshM .) 2.2 The lambda-calculus \nWe .rst consider a well-worn example: implementing the syn\u00adtax, a-equivalence, capture-avoiding substitution, \nand free vari\u00adables functions of the untyped lambda-calculus. The idealized3 Haskell code shown in Figure \n1 is all that is needed to do this using FreshLib. First, we consider a-equivalence on Lam-terms: > Lam \n(a \\ Var a) ==a Lam (b \\ Var b) True > Lam (a \\ Lam (a \\ Var a)) ==a Lam (b \\ Lam (a \\ Var b)) False \n> Lam (a \\ Lam (a \\ Var a)) ==a Lam (b \\ Lam (a \\ Var a)) True Here are a few examples of substitution: \n> runFM ([a . Var b](Lam (b \\ Var a))) Lam b0 \\ (Var b) > runFM ([a . Var b](Lam (b \\ Lam (a \\ Var a)))) \n3 There are a few white lies, which we will discuss in Section 4.3. module PolyLam where import FreshLib \ndata Type = VarTy Name | FnTy Type Type | AllTy (Name \\ Type) deriving (Nom, Show, Eq) data Term = Var \nName | App Term Term | Lam Type (Name \\ Term) | TyLam (Name \\ Term) | TyApp Term Type deriving (Nom, \nShow, Eq) instance HasVar Type where is var (VarTy x)= Just x is var = Nothing instance HasVar Term where \nis var (Var x)= Just x is var = Nothing Figure 3. Nameplate-free polymorphic lambda-calculus in FreshLib \nLam b0 \\ (Lam a1 \\ (Var a1)) Note that in the .rst example, capture is avoided by renaming b0, while \nin the second, the substitution has no effect (up to a\u00adequivalence) because a is not free in the term. \nHere are some examples of FV {|-|}(-): > FV {|Lam|}(Lam (a \\ App (Var a)(Var b))) [b ] > FV {|Lam|}(App \n(Var a)(Var b)) [a, b ] Finally, we show how call-by-name evaluation can be implemented using FreshLib \ns built-in substitution operation in Figure 2. Here is a small example: > runFM (cbn eval (App (Lam (a \n\\ Lam (b \\ App (Var a)(Var b)))) (Var b))) Lam (b0 \\ App (Var b)(Var b0)) 2.3 The polymorphic lambda-calculus \nWhile the above example illustrates correct handling of the sim\u00adplest possible example involving one \ntype and one kind of names, real languages often involve multiple types and different kinds of names. \nWe now consider a more involved example: the polymor\u00adphic lambda-calculus (or System F), in which names \nmay be used for either term variables or type variables. The FreshLib code for this is shown in Figure \n3. Here are some examples: > let t1 = AllTy (a \\ FnTy (VarTy a)(VarTy b)) > let t2 = AllTy (b \\ FnTy \n(VarTy a)(VarTy b)) > let t3 = AllTy (c \\ FnTy (VarTy c)(VarTy b)) >t1 ==a t2 False >t1 ==a t3 True In \naddition, since we indicated (via HasVar instances) that Type has a variable constructor VarTy and Term \nhas a variable con\u00adstructor Var, appropriate implementations of [- . -]- and FV {|-|}(-) are provided \nalso. > let tm = Lam (VarTy c)(a \\ App (Var a)(Var b)) > FV {|Term|}(tm) [b ] > FV {|Type|}(tm) class \nFreshM m . PolyTCM m where bindTV :: Name . ma . ma bindV :: Name . Type . ma . ma lookupTV :: Name . \nm Bool lookupV :: Name . m (Maybe Type) errorTC :: String . ma wfTy :: PolyTCM m . Type . m () wfTy (VarTy \nn)= do b . lookupTV n if b then return () else errorTC \"Unbound variable\" wfTy (FnTy t1 t2)= do wfTy \nt1 wfTy t2 wfTy (AllTy abs)= do (a, ty) . unAbs abs bindTV a (wfTy ty) eqTy :: PolyTCM m . Type . Type \n. m () eqTy ty1 ty2 = if ty1 ==a ty2 then return () else errorTC \"Type expressions differ\" unFnTy :: \nPolyTCM m . Type . m (Type, Type) unFnTy (FnTy ty1 ty2)= return (ty1, ty2) unFnTy = errorTC \"Expected \nfunction type\" unAllTy :: PolyTCM m . Type . m (Name \\ Type) unAllTy (AllTy abs)= return abs unAllTy \n= errorTC \"Expected forall type\" Figure 4. Type well-formedness and utility functions inferTm :: PolyTCM \nm . Term . m Type inferTm (Var x)= do ty . lookupV x case ty ' of Just ty' . return tyNothing . errorTC \n\"Unbound variable\" inferTm (App t1 t2)= do ty1 . inferTm t1 (argty, resty) . unFnTy ty1 ty2 . inferTm \nt2 eqTy argty ty2 return resty inferTm (Lam ty abs)= do (a, t) . unAbs abs ' ty. bindV a ty (inferTm \nt) return (FnTy ty ty' ) inferTm (TyApp tm ty)= ' do ty. inferTm tm wfTy ty abs . unAllTy ty' '' (a, \nty) . unAbs abs '' [a . ty]tyinferTm (TyLam abs)= do (a, tm) . unAbs abs ty . bindTV a (inferTm tm) return \n(AllTy (a \\ ty)) Figure 5. Type checking for the polymorphic lambda-calculus [c ] > FV {|Name|}(tm) [c, \nb ] > runFM ([c . AllTy (c \\ VarTy c)]tm) Lam (AllTy (c \\ Var c)) (a0 \\ App (Var a0)(Var b)) > [b . Var \na]tm Lam (VarTy c)(a0 \\ App (Var a0)(Var a)) Finally, we give a complete implementation of type checking \nfor PolyLam. Since PolyLam terms are type-annotated, type check\u00ading is wholly syntax directed. Figure \n4 shows the monadic interface to the typechecker (PolyTCM ) and the type well-formedness and utility \nfunctions, and Figure 5 shows the type checker proper. The only thing that is missing is an instance \nof PolyTCM ; the details of an implementation, say, TCM , are not particularly enlighten\u00ading so are omitted. \nHere is a quick example: inferring the type of .a..x:a.a..y:a.x y: > runTCM (inferTm (TyLam (t \\ Lam \n(FnTy (VarTy t)(VarTy t)) (a \\ Lam (VarTy t) (b \\ App (Var a)(Var b))))))) AllTy (t0 \\ FnTy (FnTy (VarTy \nt0)(VarTy t0)) (FnTy (VarTy t0)(VarTy t0))) We stress that the code in Figure 3, Figure 4, and Figure \n5 is a complete FreshLib program. No boilerplate code whatsoever needs to be written to make the above \nprogram work (unless you count instantiating PolyTCM ). On the other hand, since there is just one type \nName of names, this implementation allows some nonsensical expressions to be formed that blur the distinction \nbetween type variables and term variables. This can be .xed by allowing multiple name-types. We return \nto this issue in Section 5.2. 2.4 A record calculus As a .nal example, we sketch how the abstract syntax \nof a simple record calculus (an untyped fragment of part 2B of the POPLMark Challenge [5]) can be implemented \nin FreshLib. This calculus pro\u00advides record constructors {l1 = e1,...,ln = en}, .eld lookups e.l, and \npattern matching let p = ein e' , where patterns p consist of either pattern variables x or record patterns \n{l1 : p1,...,ln : pn}. In both record expressions and record patterns, labels must be distinct; in patterns, \nvariables must be distinct. The pattern vari\u00ad ' ables in let p = e in e' are considered bound in e. To \nrepresent this abstract syntax, we augment the Lam type as follows: data Lam = ... | Rec [(Label, Lam)] \n| Deref Lam Label | Let Lam (Pat \\ Lam) data Pat = PVar Name | PRec [(Label, Pat)] 'The Let constructor \nencodes the syntax let p = e in eas Let e (p \\ e' ). So far, we have not given any special meaning to \nt \\ u except when t is Name. In fact, FreshLib provides a type class BType for those types that can be \nbound on the left-hand size of an abstraction. So, to provide the desired behavior for pat\u00adtern binding, \nwe only need to instantiate BType Pat. The internal workings of the BType class and implementation of \nthe instance BType Pat are deferred to Section 5.3. This technique does not automatically equate expressions \n(or patterns) up to reordering of labels in record expressions, but this behavior can be provided by \nsuitable specializations of Nom, BType, and Eq.  3. Implementation using type classes In this section, \nwe will show how a .rst approximation of FreshLib can be implemented using type classes in Haskell. The \nimplementa\u00adtion in this section requires liberal amounts of boilerplate per user\u00adde.ned datatype; however, \nthis boilerplate can be eliminated using advanced generic programming techniques, as shall be shown in \nSection 4. 3.1 Names and nominal types As described earlier, Name consists of strings with optional integer \ntags: data Name = Name String (Maybe Int) The aforementioned convention that user-provided names are \nun\u00adtagged helps avoid collisions with names generated by FreshLib. This could be enforced by making Name \nabstract. A key ingredient of nominal abstract syntax (which we glossed over earlier) is the assumption \nthat all types of interest possess a name-swapping operation ( ), which exchanges two names within a \nvalue, and a freshness operation (#), which tests that a name does not appear free in a value. These \ntwo operations can be used as building blocks to formalize a-equivalence (==a) in a particularly convenient \nway: in particular, it is not necessary to de.ne a-equivalence in terms of capture-avoiding renaming \nand fresh name generation. The Nom type class includes the four functions: class Nom a where - - :: Trans \n. a . a -.- :: Perm . a . a p . x = foldr (- -) x p - # - :: Name . a . Bool - ==a - :: a . a . Bool \nwhere the types data Trans =(Name.Name) type Perm =[Trans ] indicate pairs or lists of pairs of names \nconsidered as transposi\u00adtions or permutations respectively. The notation (a.b) indicates a transposition \n(swapping) of two names a and b. Note that the permutation-application function (.) just applies each \nof the trans\u00adpositions in a list from right to left; it is convenient in the BType class in Section 5.3. \nObviously, the instance Nom Name needs to spell out how name-swapping, freshness and a-equivalence behave \nfor names: instance Nom Name where (a.b) c | a == c = b | b == c = a | otherwise = c a # b = a /= b \na ==a b = a == b We also provide a number of instance declarations for built-in datatypes and type constructors. \nFor base types, these functions are trivial; for built-in type constructors such as lists and pairs, \nwe just proceed recursively: instance Nom Int where t i = i a # i = True i ==a j = i == j instance \nNom a . Nom [a ] where t l = map (t -) l a # l = all (a # -) l l ==a l ' = all (map (.(x, y) . x ==a \ny)(zipl l ' ) instance (Nom a, Nom b) . Nom (a, b) where t (x, y) =(t x,t y) a #(x, y)= a # x . a \n# y ' '' (x, y) ==a (x , y ' )= x ==a x . y ==a y --etc... 3.2 Abstraction types So far none of the \ntypes discussed binds any names. We now consider the type constructor \\ for name-abstractions, i.e. values \nwith one bound name. Recall that the abstraction type was de.ned as: data a \\ t = a \\ t Structurally, \nthis is just a pair of an a and a t. However, we provide an instance declaration for Nom (Name \\ t) that \ngives it a special meaning: instance Nom t . Nom (Name \\ t) where t (a \\ x) =(t a) \\ (t x) a #(b \\ \nt)= a == b . a # t (a \\ x) ==a (b \\ y)=(a == b . x ==a y) . (a # y . x ==a (a.b) y) Swapping is purely \nstructural, but freshness and a-equivalence are not. In particular, a name is fresh for an abstraction \nif it is bound immediately or if it is fresh for the body of the abstraction. Similarly, two abstractions \nare a-equivalent if they are literally equal or if the name bound on one side is fresh for the body on \nthe other side, and the bodies are equal modulo swapping the bound names. This de.nition of a-equivalence \nhas been studied by Gabbay and Pitts [10, 11, 25] and shown to be equivalent to the classical de.nition; \nearlier, a swapping-based de.nition was used by McK\u00adinna and Pollack [22] in a formal veri.cation of \nproperties of the .-calculus. A key advantage (from the point of view of Haskell pro\u00adgramming) is that \nunlike the classical de.nition, our de.nition does not require performing fresh name generation and capture-avoiding \nrenaming in tandem with a-equivalence testing. As a result, (==a) can be given the same type as (==), \nand can be used as an equality function for nominal abstract syntax trees.  3.3 Freshness monads The \nability to swap names and test for freshness and a-equivalence is not enough for most applications. For \nexample, to de.ne capture\u00adavoiding substitution, we need to be able to choose fresh names so that substitutions \ncan be safely pushed inside abstractions. In Haskell, name-generation is usually performed using a monad \n[4]. In fact, different applications (e.g., parsing, typechecking, code generation) typically employ \ndifferent monads. For example, it is not unusual to use a single monad for both maintaining a type\u00adchecking \nor evaluation environment and generating fresh names. For our purposes, we only need to know how to generate \nfresh names. Therefore, we de.ne a type class of freshness monads (cf. Section 2) in which any computation \ninvolving a choice of fresh names can take place. class Monad m . FreshM m where renameFM :: Name . m \nName Functions such as capture-avoiding substitution can then be param\u00adeterized over all freshness monads, \nrather than needing to be spe\u00adcialized to a particular one. We also de.ne the monadic destructor unAbs \nfor unpacking an abstraction and freshening the bound name: unAbs :: FreshM m . Name \\ a . m (Name, \na) unAbs (a \\ x)= do b . renameFM a return (b, (a.b) x) Finally, we provide a default freshness monad \nFM that simply maintains an integer counter: data FM a = FM (Int . (a, Int)) instance Monad FM where \n--omitted instance FreshM FM where gensymFM s = FM (.n . (Name s (Just n), n + 1)) runFM :: FM a . a \nrunFM m = let FM (a, )= m 0 in a  3.4 Capture-avoiding substitution and free variables We now show how \nto implement the type classes for capture\u00adavoiding substitution and calculating sets of free variables. \nFor Subst, recall that the class de.nition was: class Subst t u where [- .-] - :: FreshM m . Name . t \n. u . mu We .rst provide instances for built-in types. In all cases, capture\u00adavoiding substitution commutes \nwith the existing structure. Note that no renaming needs to be performed in any of these cases. instance \nSubst t Int where [n . t]i = return i instance Subst t a . Subst t [a ] where [n . t]l = mapM ([n . t]-) \nl instance (Subst t a, Subst t b) . Subst t (a, b) where [n . t](a, b)= do a ' . [n . t]a b ' . [n . \nt]b return (a ' , b ' ) --etc... Next, we provide an instance of Subst Name Name: that is, a name can \nbe substituted for another name. instance Subst Name Name where [a . b]c = if a == c then b else c Finally, \nwe provide an instance for abstractions: if we know how to substitute for t in a, then we can also substitute \nfor t in Name \\ a, .rst using unAbs to freshen the bound name. instance Subst t a . Subst t (Name \\ a) \nwhere [n . t]abs = do (a, x) . unAbs abs x ' . [n . t]x return (a \\ x ' ) The class FreeVars{|-|} is \nde.ned as follows: class FreeVars{|t|} u where FV {|t|}(-) :: u . [Name ] As explained in Section 2, \nthe type parameter t is realized as a dummy argument unde.ned :: t needed only as a typechecking hint. \nWe can now implement the basic cases for built-in types: instance FreeVars{|t|} Int where FV {|t|}(i) \n=[] instance FreeVars{|t|} a . FreeVars{|t|} [a ] where FV {|t|}(l)= foldl union [] (map (FV {|t|}(-)) \nl) instance (FreeVars{|t|} a, FreeVars{|t|} b) . FreeVars{|t|} (a, b) where FV {|t|}(x, y)= FV {|t|}(x) \n. FV {|t|}(y) Next, we provide an instance of FreeVars{|Name|} Name: instance FreeVars{|Name|} Name where \nFV {|Name|}(x)=[x ] Finally, for abstractions, we compute the free variables of the body and then .lter \nout the bound name: instance (Nom a, FreeVars{|t|} a) . FreeVars{|t|} (Name \\ a) where FV {|t|}(a \\ x)= \nFV {|t|}(x) \\\\ [a ] Note that in this approach, the HasVar class is not used. As a result, instances \nof Subst and FreeVars{|-|} for user-de.ned datatypes must be provided instead. Such instances have special \nbehavior only for cases involving variables of type t; all other cases are straightforward recursion \nsteps (see Figure 6). instance Nom Lam where t (Var c)= Var (t c) t (Appt u)= App (t t)(t u) t \n(Lam abs)= Lam (t abs) a #(Var c)= a # c a #(Appt u)= a # t . a # u a #(Lam abs)= a # abs (Var n) ==a \n(Var m)= n == m (App t1 t2) ==a (App u1 u2)= t1 ==a u1 . t2 ==a u2 (Lam abs1) ==a (Lam abs2)= abs1 ==a \nabs2 instance Subst Lam Lam where [n . t](Var m)= if n == m then return t else return (Var m) [n . t](App \nu1 u2)= do t1 ' . [n . t]u1 t2 ' . [n . t]u2 return (App t1 ' t2' ) [n . t](Lam abs)= do abs ' . [n . \nt]abs return (Lam abs ' ) instance FreeVars{|Lam|} Lam where FV {|Lam|}(Var m) =[m ] FV {|Lam|}(App \nu1 u2)= FV {|Lam|}(u1) . FV {|Lam|}(u2) FV {|Lam|}(Lam abs)= FV {|Lam|}(abs) Figure 6. The nameplate \ncode for Lam  3.5 Limitations of this approach We have now described a working type class-based implementation \nof FreshLib, culminating in de.nitions of capture-avoiding substi\u00adtution and free variable sets for which \nmany cases are automatically provided. However, so far this approach has simply reorganized the name\u00adplate \nthat must be written for a new user-de.ned datatype involving names and binding. This reorganization \nhas some code reuse and convenience bene.ts: for example, we can override and reuse the - ==a -, [- .-]- \nand FV {|-|}(-) notations; we don t have to write trivial cases for pushing substitutions inside lists, \npairs, etc.; and for many datatypes, the remaining cases that need to be written down are very uniform \nbecause the tricky case for - \\ - is provided by FreshLib. Nevertheless, although the nameplate code \nis simpler, we still have to write just as much boilerplate for a new datatype. In fact, we may have \nto write more code because Nom needs to be instantiated for user-de.ned datatypes. For example, Figure \n6 shows the additional code one would have to write to implement a-equivalence, substitution, and free \nvariables for the Lam type using the type class-based version of FreshLib. Fortunately, existing techniques \nfor boilerplate\u00adscrapping now can be applied, because Nom turns out to be a perfect example of a derivable \ntype class, and [- .-]- and FV {|-|}(-) are examples of generic (monadic) traversals or generic queries \nof the SYB approach. In the next section we de\u00adscribe how to make FreshLib completely generic, so that \nsuitable instances of Nom, Subst, and FreeVars{|-|} are derived automat\u00adically for datatypes built up \nusing standard types and constructors or using Name and - \\ -.  4. Implementation using generic programming \nWe will employ two different approaches to scrap the remaining nameplate in FreshLib. First, we use derivable \ntype classes [13] to provide generic default de.nitions of the methods of Nom that class Nom a where \n- - :: Trans . a . a t {|Unit|} Unit = Unit t {|a.b|} (Inl x)= Inl (t x) t {|a.b|} (Inr x)= Inr (t \nx) t {|a.b|} (x . y) =(t x) . (t y) - # - :: Name . a . Bool a #{|Unit|} Unit = True a #{|a.b|} (Inl \nx)= a # x a #{|a.b|} (Inr y)= a # y a #{|a.b|} (x . y)= a # x . a # y - ==a - :: a . a . Bool {|Unit|} \nUnit ==a Unit = True {|a.b|} ' (Inl x) ==a (Inl x ' )= x ==a x {|a.b|} ' ' (Inr y) ==a (Inr y )= y ==a \ny {|a.b|} ==a = False {|a.b|} '' '' (x . y) ==a (x . y )= x ==a x . y ==a y Figure 7. Nom as a derivable \ntype class are suitable for most user-de.ned datatypes. Unfortunately, this ap\u00adproach does not work for \nSubst and FreeVars{|-|}, so instead we employ the latest version of L\u00a8 ammel and Peyton Jones scrap \nyour boilerplate (SYB) library [19]. In particular, we make essential use of a recent innovation that \nsupports modular generic traversals (i.e., traversals for which special cases can be provided using type \nclass instances). This was not possible in previous versions of SYB. Warning. This section (especially \nSection 4.2) depends rather heavily on derivable type classes and the new version of the SYB library. \nThe papers [13] and [19] are probably prerequisite to un\u00adderstanding this section. However, these details \ndo not have to be mastered by casual users of FreshLib. 4.1 Nom as a derivable type class In a derivable \ntype class [13] (also called generic class in the ghc documentation), we may specify the default behavior \nof a class method by induction on the structure of a type, expressed in terms of generic unit types Unit, \nsum types a . b, and product types a .b. To instantiate a derivable type class to a particular type (con\u00adstructor), \nwe write a structural description of the type using existing type constructors, Unit for units, . for \nsums, . for products, . for type-level abstraction and \u00b5 for recursion. For example, the struc\u00adture of \nthe Lam type is \u00b5a.Name.(a.a).Name \\ a, whereas the structure of the list type constructor [] is .\u00df.\u00b5a.Unit \n. \u00df . a. A derivable type class declaration is specialized to a type by follow\u00ading the structural type \ndescription. The provided cases for Unit, ., and . in the declaration are used for the corresponding \ncases in the type; type-level recursion is translated to term-level recursion; and type-level abstraction \nis translated to class dependences in instance declarations. Few generic functions are purely structure-driven, \nso specialized behavior can also be provided as usual by providing appropriate type class instances. \nThese instances take precedence over the default instance provided by the derivable type class dec\u00adlaration. \nIf an empty instance is provided, the default behavior is inherited. Nom turns out to be a prime example \nof a derivable type class. Figure 7 shows how to de.ne Nom as a derivable type class whose methods can \nbe derived automatically for user-de.ned datatypes simply by providing an empty instance of Nom. For \nexample, for Lam, the declaration specializes to exactly the instance of Nom Lam in Figure 6. For the \nlist type constructor, the default instance declaration for Nom a . Nom [a ] is essentially the same \nas the one shown in Section 3.1. The behavior of Nom for built-in types such as Int, Char, etc. and for \nspecial FreshLib types - \\ - and Name is provided by the instances given in Section 3; no changes are \nneeded. 4.2 Subst and FreeVars{|-|} as modular generic traversals While derivable type classes work \nvery well for Nom, they do not help scrap the remaining boilerplate involved in Subst and FreeVars{|-|}. \nOne reason is that these classes take multiple pa\u00adrameters, and multiple-parameter derivable type classes \nare not supported by ghc. Also, these classes provide behavior that is constructor-dependent, not just \ntype-dependent. Derivable type classes work well when a function s behavior is dependent only on the \nstructure of its argument type, but they are not suitable for writing functions with different behavior \nfor different constructors of the same type. One possible solution would be to use a more powerful generic \nprogramming system such as Generic Haskell that does allow generic functions to display constructor-dependent \nbehavior. This would work, but users of FreshLib would then also need to become familiar with Generic \nHaskell. Another approach that supports constructor-dependent generic functions is L\u00a8ammel and Peyton \nJones SYB library [17, 18]. This approach provides powerful facilities for almost generic func\u00adtions \nwhich traverse the data structure generically except for a few special cases. We assume familiarity with \nthis approach in the rest of this section. Capture-avoiding substitution is almost an example of a generic \ntraversal in the original SYB library. A na\u00a8ive approach would be to implement a Lam-speci.c substitution \nfunction substLam as a generic (monadic) traversal by lifting the following substVar function to one \nthat works for any datatype: substVar :: Name . Lam . Lam . Lam substVar a t (Var b)= if a == b then \nreturn t else return (Var b) substVar a t x = return x substLam :: Name . Lam . a . a substLam a t = \neverywhereT (mkT (substVar a t)) Of course, this implements capturing substitution, which is not what \nwe want. The natural next thing to try is to make substVar and substLam monadic, de.ne a function substAbs \nthat gives the behavior of substitution for abstractions (performing freshening using a FreshM ), and \nthen use the extension function ext1M of the Scrap More Boilerplate paper [18] to extend substLam so \nthat it freshens bound names appropriately. Unfortunately, this approach does not quite work. The reason \nis that the function substAbs needs to know that the type of the body is in Nom, not just Data; thus, \nsubstAbs is not polymorphic enough to be used in a generic traversal. One way to solve this would be \nto make Nom a superclass of Data, but this is very unsatisfactory because Data is part of a library. \nMoreover, even if this approach did work, it would still have disadvantages: for example, we would have \nto repeat the tricky (though admittedly shorter) de.nition of substitution for each user-de.ned type, \nand even worse, these de.nitions would have to be modi.ed if we ever added new binding types. In fact, \nthese are examples of more general limitations of the SYB library. As observed by L\u00a8 ammel and Peyton \nJones [19], the original SYB approach has two related disadvantages relative to type classes. First, \ngeneric functions are closed (cannot be ex\u00adtended) once they are de.ned, whereas type classes are open \nand can be extended with interesting behavior for new datatypes by providing instances. Second, SYB can \nonly generalize completely polymorphic functions of the form .a.Data a . a . a; al\u00adthough type-speci.c \nbehavior is made possible using cast, class\u00adspeci.c behavior is not, and in particular, we cannot generalize \nfunctions that rely on knowing that a is an instance of some class other than Data. As a result, though \nSYB-style generics are very powerful, they lack some of the modularity advantages of type classes and \ncannot be integrated with existing type class libraries very easily. L\u00a8 ammel and Peyton Jones [19] have \ndeveloped a new version of SYB that addresses both problems by, in essence, parameterizing the Data type \nclass by another type class C , so that elements of Data{|C |}can be assumed to belong to C . This form \nof parameterization is not allowed in Haskell proper, but may be simulated in ghc using other extensions, \nbased on a technique due to Hughes [14]. We refer to the current SYB library as SYB3. Using SYB3, we \ncan implement [- .-]- and FV {|-|}(-) once and for all , rather than on a per-datatype basis. Each case \nin the de.nition of [- .-]- and FV {|-|}(-) is essentially the same except for the variable constructor. \nIdeally, we would like to be able to parameterize the de.nitions of [- .-]- and FV {|-|}(-) by this constructor. \nHaskell does not, of course, allow this kind of parameterization either, but we can simulate it using \nthe HasVar type class: class HasVar a where is var :: a . Maybe Name Now, using SYB3, we can implement \nSubst and FreeVars{|-|}as shown in Figure 8 and Figure 9. Following L\u00a8ammel and Peyton Jones [19], this \ncode contains some more white lies (namely, the use of class parameters to Data{|-|} and explicit type \narguments to gfoldl{|-|}) that hide details of the actual encoding in Haskell. The real version is available \nonline;4 however, this code is likely to change to match modi.cations in the SYB3 library as it evolves. \nThe .rst instance declaration for Subst speci.es the default behavior. For most types, substitution just \nproceeds structurally, so we use the monadic traversal combinator gmapM from SYB. 4.3 White lies We \nmentioned earlier that the picture painted of FreshLib in Sec\u00adtion 2 was a little unrealistic. This is \nmostly because the underlying generic programming techniques used by FreshLib are still work in progress. \nWe now describe the (mostly cosmetic) differences be\u00adtween the idealized code in Section 2 and what one \nactually has to do in the current implementation to use FreshLib for a user-de.ned datatype T . First \noff, FreshLib depends on several extensions to Haskell present in ghc. The following declarations therefore \nneed to be added to the beginning of any ghc source .le making use of FreshLib: {-# OPTIONS -fglasgow-exts \n#-} {-# OPTIONS -fallow-undecidable-instances #-} {-# OPTIONS -fallow-overlapping-instances #-} {-# OPTIONS \n-fgenerics #-} {-# OPTIONS -fth #-} We also need to import parts of the SYBnew library:5 import SYBnew \nimport Basics import Derive Next, even though Nom is a derivable type class, it is not one of Haskell \n98 s built-in derivable type classes, that is, one of the built\u00adin classes (Eq, Ord, etc.) permitted \nin a deriving clause. So, we cannot actually write 4 http://homepages.inf.ed.ac.uk/jcheney/FreshLib.html \n5 available from http://www.cwi.nl/~ralf/syb3/ instance Data{|Subst a|} t . Subst a t where [a . t]x \n= gmapM {|Subst a|} ([a . t]-) x instance (HasVar a, Data{|Subst a|} a) . Subst a a where [n . t]x = \nif is varx == Just n then return t else gmapM {|Subst a|} ([n . t]-) x Figure 8. Substitution using \nmodular generics instance Data{|FreeVars{|a|}|} t . FreeVars{|a|} t where FV {|a|}(x)= gfoldl{|FreeVars{|a|}|} \n(.fvsf y . fvs f . FV {|a|}(y)) (. . [ ]) x instance (HasVar a, Data{|FreeVars{|a|}|} a) . FreeVars{|a|} \na where FV {|a|}(x)= case is varx of Just n . [n ] Nothing . gfoldl{|FreeVars{|a|}|} (.fvsf y . fvs f \n. FV {|a|}(y)) (. . [ ]) x Figure 9. Free names using modular generics data T = ...deriving (Nom, ...) \nto automatically derive Nom T , but instead we need to write an empty instance instance Nom T where --generic \nin order to instantiate the derivable type class Nom to T . An\u00adother cosmetic difference is that as noted \nearlier, Haskell does not support explicit type parameters, which we have been writing as f {|t|}. However, \ntype parameter passing can be coded in Haskell us\u00ading dummy arguments and ascription (e.g. writing f \n(unde.ned :: t)). Finally, because the latest version of the SYB library [19] relies on Template Haskell \n[29] to derive instances of the SYB library s Data and Typeable classes, we need to write a Template \nHaskell directive: $(derive [ T]) However, these changes introduce at most a .xed overhead per .le and \nuser-de.ned datatype. All of the changes are minor and most can be expected to disappear in future versions \nof ghc as support is added for the modular version of the SYB library.  5. Extensions 5.1 Integrating \nwith other type classes One subtle problem arises if one wishes to de.ne (==) directly as a-equivalence \nwithout having to write additional boilerplate code. In an early version of FreshLib, Nom only contained \n(- -) and (- # -). We de.ned (==) as a-equivalence for \\ and let nature take its course for other instances \nof (==), by de.ning: instance (Eq a, Nom a) . Eq (Name \\ a) where a \\ x == b \\ y =(a == b . x == y) . \n(a # y . x == (a.b) y) This was unsatisfactory because (as discussed earlier) Nom cannot be mentioned \nin a deriving clause, so Eq cannot be mentioned either (because it is dependent on Nom for any type containing \n- \\ -). Thus an explicit boilerplate instance of Eq Lam had to be provided after Nom Lam was instantiated: \ninstance Nom Lam where --generic instance Eq Lam where (Var n) == (Var m)= n == m --more boilerplate \ncases To get rid of this boilerplate, we put a Nom-speci.c version of equality (namely, (==a)) into Nom, \nthat can be used to provide a two-line instantiation of Eq whenever desired. However, to in\u00adtegrate Nom \nwith other existing type classes (for example, to pro\u00advide an instance of Ord compatible with a-equivalence), \nwe would have to put additional Nom-speci.c versions of their members into Nom. We would prefer to be \nable to use our original, more modular approach; this would be possible if derivable type classes could \nbe used in deriving clauses. 5.2 User-de.ned name-types FreshLib provides a one size .ts all type of \nstring-valued Names that is used for all name types. Often we wish to have names that carry more (or \nless) information than a String; for example, a sym\u00adbol table reference, location information, namespace \ninformation, or a pointer to a variable s value. In addition, the use of a single Name type for all names \ncan lead to subtle bugs due to Names of one kind shadowing or cap\u00adturing Names of another kind. For example, \nin Haskell, ordinary variables and type variables are separate, so there is no confusion resulting from \nusing a as both a type and as a term variable. How\u00adever, doing this in FreshLib leads to disaster: > \nLam (a \\ TyApp (Var b)(VarTy a)) ==a Lam (a \\ TyApp (Var a)(VarTy a)) False that is, the term-level \nbinding of a in Lam captures the type variable a. This is not desired behavior, and to avoid this, we \nhave to take care to ensure that term and type variable names are always distinct. Using different name \ntypes for type and term variables would rule out this kind of bug. One way to support names of arbitrary \ntypes n is to parameter\u00adize Name and other types by the type of data n carried by Names: data Name n \n= Name n (Maybe Int) type Trans n =(Name n, Name n) type Perm n =[Trans n ] class Nom a where - - :: \nTrans n . a . a - # - :: Name n . a . Bool --etc... An immediate dif.culty in doing this is that the \nold instance of Nom Name does not work as an instance of Name String, or for any other type t. The reason \nis that we would need to provide functions - - :: Trans n . Name t . Name t - # - :: Name n . Name t \n. Bool However, in each case the behavior we want is non-parametric: if n and t are the same type, we \nswap names or test for inequality, other\u00adwise swapping has no effect and freshness holds. One adequate \n(but probably inef.cient) solution is to require n and t to be Typeable, so that we can test whether \nn and t are the same type dynamically using cast: class Nom a where - - :: Typeable n . Trans n . a . \na - # - :: Typeable n . Name n . a . Bool - ==a - :: a . a . Bool instance (Typeable n, Eq n) . Nom (Name \nn) where t n = case cast t of Just (a.b) . if a == n then b else if b == n then a else n Nothing . n \na # n = case cast a of Just a ' . a ' /= n Nothing . True a ==a b = a == b The instances for Nom for \nbasic datatypes are unchanged. For - \\ -, it is necessary to use cast when testing for freshness: instance \n(Typeable n, Eq n, Nom a) . Nom ((Name n) \\ a) where a #(b \\ t)=(case cast a of Just a ' . a ' == b \nNothing . False) . a # t The FreshM , HasVar, Subst, and FreeVars{|-|} classes also need to be modi.ed \nslightly but are essentially unchanged. Another possibility would be to abstract out the type Name itself, \nand parameterize Nom, FreshM , and the other classes over n. There are two problems with this. First, \nghc does not support multi-parameter generic type classes; and second, to avoid variable capture it is \nimportant that a FreshM knows how to freshen all kinds of names, not just a particular kind. In the approach \nsuggested above, this is not a problem because renameFM :: FreshM m . Name n . m (Name n) is parametric \nin n.  5.3 User-de.ned binding forms The name-abstraction type Name \\ a can be used for a wide variety \nof binding situations, but for some situations it is awkward. For example, let-bindings let x = e1 in \ne2, typed .-quanti.ers x(y) .x : t.f, and binding transitions p . q in the p-calculus can be represented \nusing Name \\ a, but the representation requires rearranging the natural syntax, for example as Let e1 \n(x \\ e2), Forall t (x \\ f), or BndOutTrans p x (y \\ q). To provide better support for the .rst two forms \nof binding, we can provide instances of - \\ - that allow binding types other than Name. The following \ncode permits binding a name-value pair: data a c b = a c b instance (Nom a, Nom b) . Nom ((Name c a) \n\\ b) where a # ((b c x) \\ y)= a # x . (a == b . a # y) ((a c x) \\ y) ==a ((b c x ' ) \\ y ' )= x == x \n' . (a == b . y == y ' . a # y ' . y == (a.b) y ' ) Then we can encode let-binding as Let ((x ce1) \n\\ e2) and typed quanti.ers as Forall ((x ct ) \\ f). In addition, custom instances of Subst and FreeVars{|-|} \nare needed, but not dif.cult to derive. More exotic binding forms such as the p-calculus binding transi\u00adtions \ncan be handled in a similar fashion by de.ning customized instances of Nom, Subst, and FreeVars{|-|}. \nThere are other common forms of binding that cannot be han\u00addled at all using Name \\ a. Some examples \ninclude binding a list of names, e.g. the list of parameters in a C func\u00adtion;  binding the names in \nthe domain of a typing context, e.g. G f  e : t is considered equal up to renaming variables bound in \nG within e and t ; binding the names in a pattern-matching case, e.g. p . e is considered equal up to \nrenaming of bound variables in p within e; and  binding several mutually recursive names in a recursive \nlet.  In each case we wish to simultaneously bind all of an unknown number of names appearing in a value. \nWe sketch a general mechanism for making a type bindable (that is, allowing it on the left side of - \n\\ -). For a type a to be bindable, we need to be able to tell which names are bound by a a-value and \nwhether two a-values are equal up to a permutation of names. Thus, we introduce a type class for bindable \ntypes: class Nom a . BType a where BV (-) :: a . [Name ] -.- :: a . a . Maybe Perm The .rst member, \nBV (-), computes the set of names bound by a BType, whereas the second, -.-, tests whether two values \nare equal up to a permutation, and returns such a permutation, if it ex\u00adists. Now we can provide a very \ngeneral instance for Nom (a \\ b): instance (BType a, Nom b) . Nom (a \\ b) where a #(x \\ y)= a . BV (x) \n. a # y (x \\ y) ==a (x ' \\ y ' )= (x ==a x ' . y ==a y ' ) . (case x . y of Just p . (all (.a . a # \ny ' )(BV (x) \\\\ BV (y))) . (x ' ==a p . y ' ) Nothing . False The a-equivalence test checks whether the \nbound data structures are equal up to a permutation, then checks that all names bound on the left-hand \nside but not on the right-hand side are fresh for the body on the right-hand side, and .nally checks \nthat the permutation that synchronizes the bound names also synchronizes the bodies. This is a natural, \nif complicated, generalization of a-equivalence for a single bound name. In the class instance for substitution, \nwe calculate the names bound by the left-hand side, generate fresh names, and rename the bound names \nto the fresh names. In the class instance for free variables, instead of subtracting the singleton list \n[a ], we subtract BV (x). The details are omitted. Then, for example, we can make contexts newtype Ctx \n= Ctx [(Name, Type)] bindable by implementing BV (-) as map fst and -.- as a func\u00adtion that constructs \nthe simplest permutation p such that ctx1 == p .ctx2, if it exists. Similarly, pattern-based binding \ncan be imple\u00admented by providing the corresponding functions for patterns. Note that we can replace the \nearlier instances of Nom (Name \\ a) and Nom ((Name c a) \\ b) by providing the following instance dec\u00adlarations: \ninstance BType Name where BV (a)=[a ] a . b = Just [(a.b)] instance (BType a, Nom b) . BType (a c b) \nwhere BV (a c b)= BV (a) '' '' (a c b) . (a c b )= if b ==a b then a . a else Nothing As promised, we \nshow how to implement the abstract syntax of pattern matching sketched in Section 2.4 as follows: instance \nBType Pat where BV (PVar n) =[n ] BV (PRec []) =[] BV (PRec (( : x): xs)) = BV (x)+ BV (xs) (PVar n) \n. (PVar m)= Just [(n.m)] (PRec [ ]) . (PRec []) = Just [] (PRec ((l, p): r1 )) . (PRec ((l ' : q): r2 \n)) | l == l ' = do p . p . q t . (PRec r1 ) . (PRec (p . r2 )) return (t + p) . = Nothing Note that \nthis implementation assumes, but does not enforce, that labels and pattern variables are distinct; thus, \nexpressions like {l : e1,l : e2} and patterns like {l1 : x, l2 : x} need to be excluded manually. Unfortunately, \ncombining user-de.ned name types with user\u00adde.ned binding forms appears to be nontrivial. We are currently \nworking on combining these extensions.  5.4 Other nominal generic functions Capture-avoiding substitution \nand free variables sets are just two among many possible interesting generic operations on abstract syntax \nwith names. A few other examples include a-equivalence\u00adrespecting linear and subterm orderings; conversion \nto and from name-free encodings like de Bruijn indices or binary formats; syn\u00adtactic uni.cation [21, \n33]; and randomized test generation as in QuickCheck [8]. Using the SYB3 library, it appears possible \nto de.ne nominal versions of the gfoldl, gmap, gzip, and other combinators of Data, such that names are \nfreshened by default when passing through a name-abstraction. In this approach, many interesting generic \nfunc\u00adtions besides the ones we have considered would be expressible as nominal generic traversals or \nqueries. We leave exploration of this possibility for future work. 5.5 Optimizations Substitution and \nfree variable computations are basic operations that need to be ef.cient. Currently FreshLib is written \nfor clar\u00adity, not ef.ciency; in particular, it follows a sledge hammer ap\u00adproach [15] in which all bound \nnames are renamed and all subterms visited during capture-avoiding substitution. While Haskell s built\u00adin \nsharing, laziness, and other optimizations offer some assistance, faster techniques for dealing with \nsubstitution are well-known, and we plan to investigate whether they can be supported in FreshLib. Some \nminor optimizations are easy to incorporate. For ex\u00adample, our implementation of substitution always \ntraverses the whole term, but we can easily modify the instance declaration for Subst t (Name \\ a) to \nstop substitution early if we detect that the name for which we are substituting becomes bound. Similarly, \nwe can improve the ef.ciency of simultaneous substitution and FV {|-|}(-) using ef.cient FiniteMap or \nSet data structures. Another possible optimization would be to use the rapier ap\u00adproach to capture-avoiding \nsubstitution used in the ghc inliner and described by Peyton Jones and Marlow [15, Section 4.2]. In this \napproach, the set of all variables in scope is computed simultane\u00adously with capture-avoiding substitution, \nand fresh names are not generated using a monad, but by hashing the set of names to guess a name that \nis (with high probability) not already in scope. In this approach, substitution is a pure function, so \nthe use of monads for name-generation can be avoided. On the other hand, the hashing step may need to \nbe repeated until a fresh name is found. 5.6 Parallelization The order in which fresh names are generated \nusually has no ef\u00adfect on the results of computation, so theoretically, substitution operations could \nbe reordered or even be performed in parallel. (We have in mind a .ne-grained approach to parallel programming \nsuch as GPH [1]). However, the classical approach based on side\u00adeffects hides these optimization opportunities \nbecause fresh names are generated sequentially. In our approach, substitution can be per\u00adformed in parallel \nas long as separate threads generate distinct fresh names. One way to do this is to replace the single-threaded \nfreshness monad with one that can always split the source of fresh names into two disjoint parts. For \nexample, fresh names could be generated using the technique of Augustsson et al. [4], in which the fresh \nname source is an in.nite lazy tree which can be split into two disjoint fresh name sources as needed. \n  6. Related and Future Work FreshML [26, 30] was an important source of inspiration for this work. \nAnother source was logic programming languages such as .Prolog [23] and Qu-Prolog [32], which provide \ncapture-avoiding substitution as a built-in operation de.ned on the structure of terms. We are aware \nof at least two other implementations of FreshML\u00adlike functionality as a Haskell library [35, 28], all \nbased on essen\u00adtially the same idea as ours: use type classes to provide swapping, freshness, and a-equivalence. \nThe alternative attempts of which we are aware seem to include roughly the same functionality as dis\u00adcussed \nin the .rst half of Section 3, but not to use generic program\u00adming, or to consider substitution or free \nvariable set computations at all. Sheard s library in particular inspired our treatment of fresh\u00adness \nmonads and user-de.ned binding forms. Urban and Tasson [34] have used Isabelle/HOL s axiomatic type classes \nto develop a formalization of the lambda-calculus. Our techniques for generic programming with nominal \nabstract syntax may be relevant in this setting. Recently, Pottier [27] has developed Caml, a source-to-source \ntranslation tool for OCaml that converts a high-level type speci.ca\u00adtion including a generalization of \nFreshML-like name and abstrac\u00adtion types. Interestingly, this approach also provides more advanced declarative \nsupport for exotic binding forms, including letrec. In Caml, although capture-avoiding substitution is \nnot built-in, it is easy to implement by overriding a visitor operation on syntax trees that is provided \nautomatically. This is further evidence that nomi\u00adnal abstract syntax is compatible with a variety of \ngeneric program\u00adming techniques, not just those provided by ghc. One advantage of implementing nominal \nabstract syntax as a language extension (as in FreshML and aProlog) rather than as a library is that \nbuilt-in equality is a-equivalence, so even though name-generation is treated using side-effects or nondeterminism \nin these languages, capture-avoiding substitution is a pure function (i.e., has no observable side-effects \nup to a-equivalence). Such language extensions also have the advantage that providing user\u00adde.ned name-types \nis straightforward; the lack of good support for the latter is probably the biggest gap in FreshLib. \nAlthough FreshLib provides fewer static guarantees, it is more .exible in other important respects: for \nexample, it is possible for users to de.ne their own binding forms (Section 5.3). Another advantage of \nFreshLib is that the underlying representations of names are accessible; for example, names can be ordered, \nand so can be used as keys in ef.cient data structures, whereas in FreshML and aProlog this is not allowed \nbecause there is no swapping-invariant ordering on names. There is a large literature on ef.cient representations \nof .\u00adterms and implementations of capture-avoiding substitution in a variety of settings; for example, \nexplicit substitutions [2], optimal reduction [3], and .-DAGs [31]. We plan to attempt to integrate some \nsuch techniques into FreshLib. L\u00a8ammel [16] proposed using generic programming, and in par\u00adticular, generic \ntraversals, as the basis for refactoring tools (that is, tools for automatic user-controlled program \ntransformation). In this technique, refactorings can be described at a high level of general\u00adity and \nthen instantiated to particular languages by describing the syntax and binding structure. This approach \nhas much in common with the use of the HasVar and BType classes, and we are inter\u00adested in exploring \nthis connection further. An important difference is that in refactoring, renaming and fresh name generation \nis ex\u00adpected to be performed by the user. Thus, refactorings simply fail if a name clash is detected, \nwhereas FreshLib needs to be able to generate fresh names automatically in such situations. The FreshLib \napproach is a lightweight but powerful way to incorporate the novel features of FreshML inside Haskell. \nIt seems particularly suitable for prototyping, rapid development, or educa\u00adtional purposes. But is it \nsuitable for use in real Haskell programs? We are optimistic that there is some way of reconciling ef.ciency, \nmodularity, and transparency, but this is an important direction for future work. One recent development \nthat may help in this respect is Chakravarty et al. s extension of Haskell type classes to support associated \ntypes [6]. We speculate that associated types may be useful for providing better support for user-de.ned \nname and bind\u00ading types in FreshLib. 7. Conclusion This paper shows that recent developments in two \nactive research areas, generic programming and nominal abstract syntax, can be fruitfully combined to \nprovide advanced capabilities for program\u00adming abstract syntax with names and binding in Haskell. In \nnom\u00adinal abstract syntax, functions for comparing two terms up to re\u00adnaming, calculating the set of free \nvariables of a term, and safely substituting a term for a variable have very regular de.nitions so regular, \nin fact, that they can be expressed using generic program\u00adming techniques already supported by extensions \nto Haskell such as derivable type classes and the SYB library. Moreover, these def\u00adinitions can be provided \nonce and for all by a library; we have developed a proof of concept library called FreshLib. All of the \ncode for chores such as a-equivalence, substitution, and free vari\u00adables are provided by FreshLib and \ncan be used without having to .rst learn nominal abstract syntax or generic programming, or master some \nexternal generic programming tool. The ability to provide capture-avoiding substitution as a built-in \noperation is often cited as one of the main advantages of higher\u00adorder abstract syntax over other approaches. \nWe have shown that, in the presence of generic programming techniques, this advantage is shared by nominal \nabstract syntax. In addition, our approach provides for more exotic forms of user-de.ned binding, including \npattern-matching binding forms. In contrast, name-free or higher\u00adorder abstract syntax techniques provide \nno special assistance for this kind of binding. On the other hand, this paper has focused on clarity \nover ef.\u00adciency. There are many optimization techniques that we hope can be incorporated into FreshLib. \nThe fact that FreshLib works at all is encouraging, however, because it suggests that nominal ab\u00adstract \nsyntax, like higher-order abstract syntax, is a sensible high\u00adlevel programming interface for names and \nbinding. It remains to be determined whether this interface can, like higher-order abstract syntax, be \nimplemented ef.ciently. We believe that FreshLib is a promising .rst step towards an ef.cient generic \nlibrary for scrap\u00adping your nameplate.  Acknowledgments I wish to thank Ralf L\u00a8ammel and Simon Peyton \nJones for answer\u00ading questions about the new Scrap your Boilerplate library and associated paper. I also \nwish to thank Tim Sheard for sharing his FreshML-like Haskell library, some of whose ideas have been \nin\u00adcorporated into FreshLib. This work was supported by EPSRC grant R37476.  References [1] Glasgow \nParallel Haskell, June 2005. http://www.macs.hw.ac.uk/\u00ad~dsg/gph/. [2] M. Abadi, L. Cardelli, P.-L. Curien, \nand J.-J. L\u00b4evy. Explicit substitutions. Journal of Functional Programming, 1(4):375 416, 1991. [3] Andrea \nAsperti and Stefano Guerrini. The Optimal Implementation of Functional Programming Languages. Cambridge \nUniversity Press, 1999. [4] Lennart Augustsson, Mikael Rittri, and Dan Synek. On generating unique names. \nJ. Funct. Program., 4(1):117 123, 1994. [5] Brian E. Aydemir, Aaron Bohannon, Matthew Fairbairn, J. Nathan \nFoster, Benjamin C. Pierce, Peter Sewell, Dimitrios Vytiniotis, Geoffrey Washburn, Stephanie Weirich, \nand Steve Zdancewic. Mechanized metatheory for the masses: The POPLmark Challenge. In Proceedings of \nthe Eighteenth International Conference on Theorem Proving in Higher Order Logics (TPHOLs 2005), 2005. \nTo appear. [6] Manuel M. T. Chakravarty, Gabriele Keller, Simon Peyton Jones, and Simon Marlow. Associated \ntypes with class. In POPL 05: Proceedings of the 32nd ACM SIGPLAN-SIGACT symposium on Principles of Programming \nLanguages, pages 1 13, New York, NY, USA, 2005. ACM Press. [7] J. Cheney and C. Urban. Alpha-Prolog: \nA logic programming language with names, binding and alpha-equivalence. In Proc. 20th Int. Conf. on Logic \nProgramming (ICLP 2004), number 3132 in LNCS, pages 269 283, 2004. [8] Koen Claessen and John Hughes. \nQuickCheck: a lightweight tool for random testing of Haskell programs. In Proceedings of the 2000 ACM \nSIGPLAN International Conference on Functional Programming (ICFP 2000), pages 268 279. ACM, 2000. [9] \nN. G. de Bruijn. Lambda-calculus notation with nameless dummies, a tool for automatic formula manipulation. \nIndagationes Mathemati\u00adcae, 34(5):381 392, 1972. [10] M. J. Gabbay and A. M. Pitts. A new approach to \nabstract syntax involving binders. In Giuseppe Longo, editor, Proceedings of the 14th Annual IEEE Symposium \non Logic in Computer Science, pages 193 202, Washington, DC, 1999. IEEE, IEEE Press. [11] M. J. Gabbay \nand A. M. Pitts. A new approach to abstract syntax with variable binding. Formal Aspects of Computing, \n13:341 363, 2002. [12] Ralf Hinze. Generics for the masses. In ICFP 04: Proceedings of the ninth ACM \nSIGPLAN International Conference on Functional Programming, pages 236 243, New York, NY, USA, 2004. ACM \nPress. [13] Ralf Hinze and Simon Peyton Jones. Derivable type classes. In Graham Hutton, editor, Proceedings \nof the 2000 ACM SIGPLAN Haskell Workshop, volume 41.1 of Electronic Notes in Theoretical Computer Science. \nElsevier, 2001. [14] J. Hughes. Restricted data types in Haskell. In E. Meijer, editor, Proceedings of \nthe 1999 Haskell Workshop, number UU-CS-1999-28 in Technical report, Utrecht University, Department of \nComputer Science, 1999. [15] Simon Peyton Jones and Simon Marlow. Secrets of the Glasgow Haskell Compiler \ninliner. Journal of Functional Programming, 12(4):393 434, July 2002. [16] Ralf Lammel.\u00a8Towards generic \nrefactoring. In Proc. of Third ACM SIGPLAN Workshop on Rule-Based Programming RULE 02, Pittsburgh, USA, \n2002. ACM Press. 14 pages. [17] Ralf L\u00a8ammel and Simon Peyton Jones. Scrap your boilerplate: a practical \ndesign pattern for generic programming. In TLDI 03: Proceedings of the 2003 ACM SIGPLAN international \nworkshop on Types in Language Design and Implementation, pages 26 37, New York, NY, USA, 2003. ACM Press. \n[18] Ralf L\u00a8ammel and Simon Peyton Jones. Scrap more boilerplate: re.ection, zips, and generalised casts. \nIn ICFP 04: Proceedings of the ninth ACM SIGPLAN International Conference on Functional Programming, \npages 244 255, New York, NY, USA, 2004. ACM Press. [19] Ralf L\u00a8 Scrap your boilerplate ammel and Simon \nPeyton Jones. with class. In Benjamin Pierce, editor, Proceedings of the 10th International Conference \non Functional Programming (ICFP 2005), Tallinn, Estonia, 2005. [20] Andres L\u00a8oh and Johan Jeuring (editors). \nThe Generic Haskell user s guide, version 1.42 -coral release. Technical Report UU-CS-2005\u00ad004, Utrecht \nUniversity, 2005. [21] Conor McBride. First-Order Uni.cation by Structural Recursion. Journal of Functional \nProgramming, 13(6):1061 1075, 2003. [22] James McKinna and Robert Pollack. Some lambda calculus and type \ntheory formalized. J. Autom. Reason., 23(3):373 409, 1999. [23] G. Nadathur and D. Miller. Higher-order \nlogic programming. In D. M. Gabbay, C. J. Hogger, and J. A. Robinson, editors, Handbook of Logic in Arti.cial \nIntelligence and Logic Programming, volume 5, chapter 8, pages 499 590. Oxford University Press, 1998. \n[24] Frank Pfenning and Conal Elliott. Higher-order abstract syntax. In Proc. ACM SIGPLAN Conf. on Programming \nLanguage Design and Implementation (PLDI 89), pages 199 208. ACM Press, 1989. [25] A. M. Pitts. Nominal \nlogic, a .rst order theory of names and binding. Information and Computation, 183:165 193, 2003. [26] \nA. M. Pitts and M. J. Gabbay. A metalanguage for programming with bound names modulo renaming. In R. \nBackhouse and J. N. Oliveira, editors, Proc. 5th Int. Conf. on Mathematics of Programme Construction \n(MPC2000), number 1837 in Lecture Notes in Computer Science, pages 230 255, Ponte de Lima, Portugal, \nJuly 2000. Springer-Verlag. [27] Franc\u00b8ois Pottier. An overview of Caml, June 2005. Avail\u00adable at http://cristal.inria.fr/~fpottier/publis/\u00adfpottier-alphacaml.pdf. \n[28] Tim Sheard, March 2005. Personal communication. [29] Tim Sheard and Simon Peyton Jones. Template \nmeta-programming for Haskell. In Haskell 02: Proceedings of the ACM SIGPLAN workshop on Haskell, pages \n1 16, New York, NY, USA, 2002. ACM Press. [30] M. R. Shinwell, A. M. Pitts, and M. J. Gabbay. FreshML: \nProgrammming with binders made simple. In Proc. 8th ACM SIGPLAN Int. Conf. on Functional Programming \n(ICFP 2003), pages 263 274, Uppsala, Sweden, 2003. ACM Press. [31] Olin Shivers and Mitchell Wand. Bottom-up \n\u00df-reduction: Uplinks and .-DAGs. In M. Sagiv, editor, Proceedings of the 14th European Symposium on Programming \n(ESOP 2005), number 3444 in LNCS, pages 217 232, 2005. [32] J. Staples, P. J. Robinson, R. A. Paterson, \nR. A. Hagen, A. J. Craddock, and P. C. Wallis. Qu-Prolog: An extended Prolog for meta level programming. \nIn Harvey Abramson and M. H. Rogers, editors, Meta-Programming in Logic Programming, chapter 23. MIT \nPress, 1996. [33] C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal uni.cation. Theoretical Computer Science, \n323(1 3):473 497, 2004. [34] C. Urban and C. Tasson. Nominal techniques in Isabelle/HOL. In Proceedings \nof the 20th International Conference on Automated Deduction (CADE 2005), 2005. To appear. [35] Phil Wadler, \nAndrew Pitts, and Koen Claessen, September 2003. Personal communication.  \n\t\t\t", "proc_id": "1086365", "abstract": "Recent research has shown how <i>boilerplate</i> code, or repetitive code for traversing datatypes, can be eliminated using generic programming techniques already available within some implementations of Haskell. One particularly intractable kind of boilerplate is <i>nameplate</i>, or code having to do with names, name-binding, and fresh name generation. One reason for the difficulty is that operations on data structures involving names, as usually implemented, are not regular instances of standard <i>map</i>, <i>fold</i>, or <i>zip</i> operations. However, in <i>nominal abstract syntax</i>, an alternative treatment of names and binding based on swapping, operations such as &#945;-equivalence, capture-avoiding substitution, and free variable set functions are much better-behaved.In this paper, we show how nominal abstract syntax techniques similar to those of FreshML can be provided as a Haskell library called <i>FreshLib</i>. In addition, we show how existing genericmprogramming techniques can be used to reduce the amount of nameplate code that needs to be written for new datatypes involving names and binding to almost nothing&#8212;in short, how to <i>scrap your nameplate</i>.", "authors": [{"name": "James Cheney", "author_profile_id": "81100057679", "affiliation": "University of Edinburgh, Edinburgh, United Kingdom", "person_id": "PP14031182", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086389", "year": "2005", "article_id": "1086389", "conference": "ICFP", "title": "Scrap your nameplate: (functional pearl)", "url": "http://dl.acm.org/citation.cfm?id=1086389"}