{"article_publication_date": "09-12-2005", "fulltext": "\n Continuations from Generalized Stack Inspection * Greg Pettyjohn John Clements Joe Marshall Northeastern \nUniversity Northeastern University Northeastern University Shriram Krishnamurthi Brown University Abstract \nImplementing .rst-class continuations can pose a challenge if the target machine makes no provisions \nfor accessing and re-installing the run-time stack. In this paper, we present a novel translation that \novercomes this problem. In the .rst half of the paper, we introduce a theoretical model that shows how \nto eliminate the capture and the use of .rst-class continuations in the presence of a generalized stack \ninspection mechanism. The second half of the paper explains how to translate this model into practice \nin two different contexts. First, we reformulate the servlet interaction language in the PLT Web server, \nwhich heavily relies on .rst-class continuations. Using our technique, servlet programs can be run directly \nunder the control of non-cooperative web servers such as Apache. Second, we show how to use our new technique \nto copy and reconstitute the stack on MSIL.Net using exception handlers. This establishes that Scheme \ns .rst-class continuations can exist on non-cooperative virtual machines. Categories and Subject Descriptors \nF.3.3 [Logics and Mean\u00adings of Programs]: Studies of Program Constructs Control prim\u00aditives; H.3.4 [Information \nStorage and Retrieval]: Systems and Software World Wide Web (WWW); I.2.2 [Arti.cial Intelli\u00adgence]: Automatic \nProgramming Program transformation; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming \nLanguages Operational semantics General Terms Languages, Theory Keywords A-normal form, continuation-passing \nstyle, stack in\u00adspection, Web programming, continuations, defunctionalization, Scheme 1. Motivation: \nContinuations, VMs, and the Web When an interactive Web program issues a query, a non-local trans\u00adfer \nof control takes place. It is now the user (possibly an intelligent * This research has been supported \nby NSF awards to Felleisen and Krish\u00adnamurthi as well as a Microsoft donation to Felleisen. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 05 September \n26-28, 2005, Tallinn, Estonia Copyright c &#38;#169; 2005 ACM 1-59593-064-7/05/0009. . . $5.00. Matthias \nFelleisen Northeastern University agent) who is in charge. This user may decide to respond to the query \nonce, twice or many times (or not at all), thus re-launching the rest of the program s computation once, \ntwice, or many times. Many people have therefore concluded that a language with .rst\u00adclass continuations \n(such as Scheme [19]) is a strong match for implementing this kind of interactive program [11, 18, 26, \n33]. Over the past several years, we have explored the continuation model of Web programming in two different \ndirections. Initially, we designed, implemented, and evaluated a Web server that imple\u00adments the run-time \nprimitives for Web interactions via Scheme s .rst-class continuations [14]. The investigation validated \nthat this approach is suitable for a variety of situations and even led to a commercial product [20]. \nSadly, only programs running on a cus\u00adtom Web server can bene.t from this approach. To address this concern, \nwe also experimented with a variant of the continuation-passing transformation (CPS) for automatically \nrestructuring interactive programs for the Web [13, 21]. In prin\u00adciple, this transformation can be used \nwith a wide range of pro\u00adgramming languages and should therefore help Web programmers in many situations. \nThe problem, however, is that the transforma\u00adtion affects the entire program. Since modern Web applications \nare often written in multiple languages, it is nearly impossible to perform a whole-program transformation \nof them. Worse, CPS re\u00adquires tail-call optimization or, in its absence, trampolines, a tech\u00adnique due \nto Jon L. White [personal communication June 2005], which can be much more expensive. It is therefore \neconomically impossible to use this idea with existing languages and run-time libraries. In short, we \nare left with the challenge of equipping con\u00adventional programming languages with the capabilities of \ngrabbing and reinstalling a continuation even if these languages run-time organizations do not support \nsuch actions. The very same problem comes up in a different context: the implementation of languages \nwith continuations on virtual ma\u00adchines such as Sun s JVM [34] or Microsoft s CLR [22]. Mirror\u00ading traditional \nprogramming languages, these machines do not pro\u00advide instructions for installing and saving the run-time \nstack. Usu\u00adally, Scheme-on-VM implementors give up on .rst-class continu\u00adations [1, 2], or they allocate \nthe control stack in the heap of the machine [23]. As Bres, et al. [2, section 2] point out, however, \nwith this second strategy, it might be expected that . . . JITs are far less ef.cient on codes that manages \ntheir own stack [sic]. Furthermore, allocating the stack on the heap effectively disguises the stack, \nhid\u00ading it from the rich set of programming tools such as steppers, de\u00adbuggers, and pro.lers, as well \nas contemporary security managers, which expect to .nd run-time information on the stack. In this paper, \nwe present a solution to this dilemma, .rst in the context of a theoretical model and then in the context \nof two pro\u00ad (de.ne (fact n) (if (= n 0) (begin (display (c-c-m)) 1) (w-c-m n (\u00d8 n (fact (- n 1)))))) \n(fact 3) .. console output: (123) computed value: 6 Figure 1. A factorial function with continuation \nmarks (de.ne (fact-tr n a) (if (= n 0) (begin(display (c-c-m)) a) (w-c-m n (fact-tr (- n 1)(\u00d8 na)))))(fact-tr \n31) .. console output: (1) computed value: 6 Figure 2. A tail-calling factorial function with continuation \nmarks totype implementations. The core idea is to translate Scheme pro\u00adgrams with call/cc into a language \nwith a generalized stack inspec\u00adtion mechanism. For our theoretical model and for one of our pro\u00adtotypes, \nwe use PLT Scheme s continuation mark mechanism; for the other prototype, we show how exception handlers \nand exception throws can collaborate to simulate continuation marks. The result\u00ading transformation is \nless radical than CPS, and it is thus natural to run the resulting program on the natively available \nstack. 2. Continuation Marks Most programming languages and programming environments in\u00adclude mechanisms \nfor manipulating the stack in some form or an\u00adother. Java, for example, implements a form of security \nvia stack inspection [35]. Programming environments such as Visual Studio have privileged access to the \nstack for various debugging tasks. The most ubiquitous examples of such mechanisms, though, are excep\u00adtion \nsignalers and handlers. They erase portions of the control stack and transfer control to exception handlers \nin a non-local manner. MzScheme [9], the implementation language of the DrScheme programming environment \n[7], provides a novel abstraction of all these mechanisms: continuation marks [4]. Roughly speaking, \ncon\u00adtinuation marks support a powerful form of stack inspection gen\u00aderalizing Java s mechanism with the \nsame name. Using the w-c-m language form (short for with continuation marks ), a program\u00admer can attach \nvalues to the control stack during the execution of a program. Later, the stack-walking primitive c-c-m \n( current con\u00adtinuation marks ) can retrieve these values from the stack. To preserve the spirit of Scheme, \nattaching continuation marks to the stack does not interfere with Scheme s tail-calling require\u00adment. \nFurthermore, MzScheme s marks are parameterized by keys. By choosing fresh keys, programmers can ensure \nthat adding marks to a computation does not affect the result of the computation, enabling the use of \nmarks for multiple purposes. In particular, MzScheme implements exceptions and a trace facility with \ncon\u00adtinuation marks, while the tools of DrScheme rely on them to im\u00adplement a stepper, a debugger, and \na performance pro.ler. The two programs in .gures 1 and 2 illustrate how a program\u00admer might use the \nw-c-m and c-c-m constructs to instrument func\u00adtions. Both de.nitions implement factorial; both mark the \ncontinua\u00adtion at the recursive call site; and both report the continuation-mark e ::= a | (we) | (letrec \n([.v]) e) | (call/cc w) | (case wl) l ::= (K x) = e a ::= w| (K a) w ::= v| x v ::= (A(x) e) | (K v) \n| ,.E| . x E Variables . E References where Variables . References = . E ::= [] | (vE) ::= .| [... v] \n(X denotes zero or more occurrences of X) Figure 3. SL Syntax list before returning. The one in .gure \n1 is properly recursive, while the one in .gure 2 is tail-recursive. For the properly recursive pro\u00adgram, \nthe console output shows that the continuation contains three mark frames. For the tail-recursive variant, \nonly one continuation mark remains; the others have been overwritten during evaluation.  3. Continuations \nfrom Continuation Marks Equipped with a basic understanding of MzScheme s continuation marks, we can \nnow show how to use this generalized stack inspec\u00adtion mechanism to eliminate call/cc from Scheme programs. \nWe present the idea in two steps. The .rst step is to translate programs with call/cc into semantically \nequivalent programs that use contin\u00aduation marks to store functional representations of continuations. \nThe second step replaces the marks with structures, using a variant of Reynolds defunctionalization [27]. \n 3.1 The Source Language The language in .gure 3, dubbed SL for source language, is a modi.ed version \nof A-Normal form (ANF) [8]. It uses Ainstead of let. Furthermore, we allow applications of arbitrary \nlength. The language is extended with call/cc, letrec and algebraic datatypes. The latter are needed \nin the target language for the operational semantics and are used during defunctionalization, the last \nstep of our translation. For consistency they are also included in the source language. Instances of \nalgebraic datatypes are constructed with construc\u00adtors (K, Km) and destructured with case. We leave the \nactual set of constructors unspeci.ed, though we assume it contains the standard list constructors cons \nand nil. For convenience, we use a shorthand for lists, where (list e0 e1 ...) stands for the aggregate \nconstruction (cons e0 (list e1 ...))and (list) stands for the empty list. The operational semantics is \nspeci.ed via the rewriting system in .gure 4. The .rst rule is the standard .v -rewriting rule for call\u00adby-value \nlanguages [24]. The second handles the destructuring of algebraic datatypes. Rules (3, 4, 5) specify \nthe semantics for letrec. Bindings es\u00adtablished by letrec are maintained in a global store, . For sim\u00adplicity, \nstore references (.) are distinct from variables bound in lambda expressions [6]. Rule 5 speci.es how \nbindings are estab\u00adlished by letrec. Furthermore, to simplify the syntax for evaluation contexts, store \nreferences are treated as values, and dereferencing is performed only when a store reference appears \nin application po\u00adsition (rule 4) or in the test position of a case expression (rule 5). E ::= (w-c-m \nv F) |F where F ::= [] | (v E) (1) /E[((A(x) e) v)] .TL /E[e[x .. v]] (2) /E[(case (K v) l)] .TL /E[e[x \n.. v]] where (K x) = e E l and is unique (3) /E[(letrec ([.v]) e)] .TL [. .. v]/E[e] /E[(.v)] (4)/E[e[x \n.. v]] where (.)= (A(x) e) .TL (5) /E[(case .l)] .TL /E[(case (.) l)] (6) /E[(abort e)] .TL /e (7) \nE' /E[(w-c-m v1 (w-c-m v2 e))] .TL /E[(w-c-m v2 e)] where En=[(w-c-m v3 [ ])] (8) E' /E[(w-c-m v1 v2)] \n.TL /E[v2] where En=[(w-c-m v3 [ ])] (9) /E[(c-c-m)] .TL /E[X (E)] where: X ([]) = (nil) X ((v E))= \nX (E) X ((w-c-m v F))= (cons v X (F)) Figure 6. TL Semantics (1) /E[((A(x) e) v)] .SL /E[(case (K v) \nl)] (2) .SL (3) /E[(letrec ([.v]) e)] .SL (4) /E[(.v)] .SL /E[(case .l)] (5) .SL (6) /E[(call/cc v)] \n.SL (7) /E[(,.E. v)] .SL /E[e[x .. v]] /E[e[x .. v]] s.t. (K x) = e E l and is unique [. .. v]/E[e] \n/E[e[x .. v]] where (.)= (A(x) e) /E[(case (.) l)] /E[(v ,.E)] /E'[v] Figure 4. SL Semantics Dereferencing \nstore locations and beta substitution are combined in order to simplify the treatment of defunctionalization. \nFirst-class continuations are captured using call/cc (rule 6). Capturing a continuation creates a continuation \nvalue, ,.E that records the context, E, of the call/cc expression. The argument to call/cc is then applied \nto this value. When a continuation value is eventually applied to another value (rule 7), the evaluation \ncon\u00adtext containing the application is discarded and replaced with the context contained in the continuation \nvalue. The hole in the new context is .lled with the argument part of the application.  3.2 The Target \nLanguage The target language in .gure 5, dubbed TL for target language, is also a modi.ed A-Normal form \nmuch like the source language. Instead of call/cc, TL contains a simple abort construct and two new forms: \nw-c-m and c-c-m. The operational semantics is speci.ed via the rewriting system in .gure 6. The .rst \n.ve rules are identical to the corresponding rules for the source language. In the source language, a \ncontinua\u00adtion replaces the context when it is invoked. In order to simulate such continuations, we include \nthe abort form in the target lan\u00adguage, which handles the task of abandoning the context. Continuation \nmarks implement a mechanism for manipulating contexts, which we exploit for the elimination of call/cc. \nIntu\u00aditively, (w-c-m ve) installs the value v into the continuation of the expression e, while (c-c-m) \nrecovers a list of all continuation marks embedded in the current continuation. To preserve proper tail-call \nsemantics, if a rewriting step results in more than one w-c-m, sur\u00adrounding the same expression, the \noutermost mark is replaced by the inner one. This requirement demands that an evaluation context interleaves \nw-c-m constructs with other kinds of expressions. We translate this interleaving requirement into a syntactic \ncon\u00adstraint with a grammar for evaluation contexts that consists of two non-terminals. The start symbol, \nE, enforces the interleaving re\u00adquirement, while F de.nes the usual evaluation contexts. Thus, multiple \nadjacent w-c-m expressions must be treated as a redex. When such a redex is encountered, the redundant \nmarks are re\u00admoved starting with the outermost (rule 7). Marks surrounding a e ::= a | (w e) | (letrec \n([. v]) e) | (w-c-m a e) | (c-c-m) | (abort e) | (case w l) l ::= (K x) = e a ::= w | (K a) w ::= v | \nx v ::= (A(x) e) | (K v) | . Figure 5. TL Syntax Variables and Values: CMT [ x] CMT [ .] CMT [ (A(x) \ne)] CMT [ ,.E] = = = = x . (A(x) CMT [ e] ) (A(x) (abort (resume X (CMT [ E]]) x))) (T1) (T2) (T3) (T4) \nCMT [ (K a)] = (K CMT [ a] ) (T5) Redexes: CMT [ (w)] = (CMT [ w] ) (T6) CMT [ (letrec ([. w]) e)] CMT \n[ (call/cc w)] = = (letrec ([. CMT [ w]]]) CMT [ e] ) (CMT [ w] ((A(m) (A(x) (abort (resume m x)))) (c-c-m))) \n(T7) (T8) CMT [ (case w l)] CMT [ (K x) = e] = = (case CMT [ w] CMT [ l] ) (K x) = CMT [ e] (T9) (T10) \nContexts: CMT [[[ ]] = [ ] (T11) CMT [ (w E)] = ((A(x)(CMT [ w] x)) (w-c-m (A(x) (CMT [ w] x)) CMT [ \nE] )) (T12) Compositions: CMT [ E[r]]] = CMT [ E]][CMT [ r]]] (T13) Figure 7. Translation from SL to \nTL (letrec ([resume (A(lv) (case l (nil) = v (cons v . l') = (v . (w-c-m v . (resume l. v)))))]) ...) \nFigure 8. De.nition of Resume value are discarded after the evaluation of a sub-term completes, i.e., \nany immediate enclosing w-c-m is removed from the result\u00ading value (rule 8). The side conditions for \nrules (7,8) guarantee the unique decomposition of a program into an evaluation context and a redex (or \na stuck term), which implies that the rewriting relation de.nes an evaluation function. Finally, c-c-m \nemploys the func\u00adtion X () to extract the marks from the evaluation context (rule 9). Marks are extracted \nin order, starting with the oldest.  3.3 Replacing Callcc Figure 7 speci.es a translation from SL to \nTL dubbed CMT , for continuation-mark transform that eliminates call/cc and continua\u00adtion invocations. \nThe non-structural translation decomposes a term into a context and redex: r ::= (w) [redex] | (letrec \n([. w]) e) | (call/cc w) | (case w l) E ::= [ ] | (v E) [context] LEMMA 1 (Unique Decomposition). Let \ne E SL. Either e E w, e E a or e = E[r] for some redex r. The translation rules for variables, values, \nand redexes are straightforward with the exception of call/cc applications and continuation values. Continuation \nvalues are transformed using rule T4. For call/cc, w-c-m is used to gather the requisite informa\u00adtion \nfrom the surrounding context to construct a function that also relies on resume to reconstruct the evaluation \ncontext (rule T8). Since continuation values do not appear in the target language, a suitable function \nmust be supplied. The function uses abort to oust the current context, and then calls a top-level function, \nresume, which builds a new evaluation context. The treatment of both call/cc and continuation values \nrelies on the systematic insertion of continuation marks. The strategy relies on the critical property \nof ANF terms that makes the continuation of every expression obvious. More precisely, evaluation contexts \nin the source language are built entirely from function applications; thus the A-expression in the function \nposition is always the contin\u00aduation. Hence, the translation can mark each application with the function \nthat is about to be applied. In turn, c-c-m collects all these functions in a list for storage and use \nat a later time. The resume function (.gure 8) faithfully reconstructs an evalu\u00adation context from such \na list of functions. It traverses the list and recursively applies the functions from the list. An instance \nof w-c\u00adm is wrapped around each function application so that the resulting evaluation context exactly \nmatches and thus facilitates any future call/cc operations.  3.4 Example The following lemma guarantees \nthat the decomposition is unique Let us illustrate the translation with a simple example. We start with \nand thus the translation is well-de.ned: an expression that captures a continuation from within a non-trivial \nevaluation context: CMT [ (fy (call/cc (A (k)(kz))))] Note, we ignore the details of the bindings for \nf , y, and z. Applying the translation yields: ((A (x0)(fy x0)) (w-c-m (A (x0 )(fy x0 )) ((A (k)(kz)) \n((A (m) (A (x1 )(abort (resume m x1)))) (c-c-m))))) The original expression can be decomposed into context \nand redex as: (fy [])[(call/cc (A (k)(kz)))] Observe that the evaluation context corresponding to the \ncontinu\u00adation of the call/cc is exactly (fy []), which can be rendered as the function (A (x0 )(fy x0 \n)). This function represents the .rst part of the continuation and is used as the continuation mark surround\u00ading \nthe call/cc-expression. When the result is evaluated, (c-c-m) returns a list of the continuation marks, \nwhich in this case is (list (A (x0)(fy x0))). This list becomes the .rst argument to resume, i.e., the \nactual continuation passed to (A (k)(kz)) is (A (x1) (abort (resume (list (A (x0)(fy x0))) x1))) After \nevaluation of resume, we get: ((A (x0)(fy x0)) (w-c-m (A (x0)(fy x0)) z)) Thus the evaluation context \ncaptured by call/cc has been com\u00adpletely reconstructed. In the implementation, this corresponds to a \nfaithful stack reconstitution.  3.5 Correctness Let { v if ./p .* v evalx(p)= : if ./p .* \u00b7\u00b7\u00b7 THEOREM \n1. CMT [ evalSL(p)] = evalTL(CMT [ p]]) To prove Theorem 1, we show that if a source term admits a re\u00adduction \nsequence of length k, then the translation of the source term admits a sequence of length at least k, \nsuch that result of the target sequence is the translation of the result of the source sequence. This \nis proved by induction on the length (k) of the reduction sequence. The base case is trivial. To prove \nthe induction step, we show that if a SL con.guration /e takes a single step of evaluation resulting \n' in /e', then the translation CMT [[ ]]/CMT [ e] admits only a .nite number of evaluation steps before \nproducing a term that is the translation of '/e'. This simulation argument is summarized in Lemma 2. \nLEMMA 2 (Simulation). If /E[e] .SL ' /E'[e' ] then '' CMT [[ ]]/CMT [ E[e]] .+ ] /CMT [ E']]] TL CMT \n[ [e The simulation lemma is proved by case analysis on the rela\u00adtion .SL. Recall that CMT [ \u00b7] is de.ned \nusing unique decompo\u00adsition. In proving this lemma, a pattern emerges. If the translation of a SL con.guration \ntakes a step of evaluation, then the resulting con.guration may not be the image of any suitable SL con.gura\u00adtion. \nLemma 3 guarantees that the target con.guration ultimately reaches a desirable state. D[ x] L = x D[ \n.] L = . D[ (K a)] L = (K D[ a] L) D[ (Am(x) e)] L = (Km y) where y = FV(Am(x) e) D[ (w0 w)] L = (apply \nD[ w0] L (list D[ w] L)) D[ (ve)] L = (app D[ v] L D[ e] L) D[ (abort e)] L = (abort D[ e] L) D[ (letrec \n([.w]) e)] L = (letrec ([.D[ w] L]) L[ e] ) D[ (w-c-m ae)] L = (w-c-m D[ a] L D[ e] L) D[ (c-c-m)] L \n= (c-c-m) D[ (case wl)] L = (case D[ w] L D[ l] L) D[ (K x) = e] L = (K x) =D[ e] L Figure 9. Defunctionalization \nLEMMA 3 (Compositionality). CMT [[ ]]/CMT [ E]][CMT [ e]]] . * TL CMT [[ ]]/CMT [ E[e]]] Two more technical \nresults are needed. First, resume restores the evaluation context represented by its .rst argument. LEMMA \n4 (Reconstitution). CMT [[ ]]/(resume X (CMT [ E']]) CMT [ v] ) .+ TL CMT [[ ]]/CMT [ E']][CMT [ v]]] \nSecond, substitution commutes with translation. LEMMA 5 (Substitution). CMT [ e[x .. v]]] = CMT [ e] \n[x .. CMT [ v]]]  3.6 Defunctionalization Defunctionalization1 (.gure 9) replaces functions with records. \nEvery such record belongs to exactly one variant of an algebraic datatype, which contains one variant \nfor each A expression in the program. Thus, we can view A expressions as constructors for functions. \nWe also need to know what to do when a function record appears in application position. For this, we \nde.ne a global apply function that dispatches on the type of the function record and invokes the appropriate \nexpression. To defunctionalize a program, we .rst choose a labeling strategy that assigns a unique label \nto each A expression in the program. This amounts to adding a superscript to each occurrence of A. Based \non the labeling, we can de.ne the algebraic datatype. We create one variant for each A, with .elds corresponding \nto the free-variables of the corresponding A expression. The corresponding apply function consumes a \nrecord and dis\u00adpatches on the record s constructor using case. The other argument to apply is a list \nof values representing the original function s argu\u00adments. There is a clause corresponding to each A \nexpression, and the right-hand-side is essentially the body of the original A expres\u00adsion. Once the appropriate \nde.nitions have been made, we can re\u00adplace every A expression in the program with an application of the \n1 Our treatment of defunctionalization was inspired by the work of Pottier et al. [25], though we depart \nfrom their treatment due to additional constructs in our language, such as abort, continuation marks \nand multi-argument functions (letrec ([apply (A(f vals)(case f cm)]) ...) where for each m, cm = (Km \ny) = (apply * (A (x0) ... (A (xn)(A () D[ em] L)) ... ) vals) (letrec ([apply * (A(f vals) (case vals \n(nil) = (f ) (cons val ' vals ' ) = (apply * (f val ' ) vals ' )))]) ...) (letrec ([app (A (fv)(apply \nf (list v)))]) ...) Figure 10. De.nition of Apply, Apply*, and App constructor of the corresponding variant. \nFinally, we rewrite each application with apply. The de.nition of apply is complicated because we support \nmulti-argument functions. If every function had only a single argu\u00adment, substitution for that argument \nwould happen automatically via the second argument to apply. For multi-argument functions, this breaks \ndown, because we are con.ned to a single arity speci.\u00adcation of apply. We therefore separate application \ninto two stages. The .rst stage dispatches on the function record as described. The second stage handles \nsubstitution of values for variables in the body of the original function. The multi-argument version \nof apply (.gure 10) lumps all of the function arguments into a single list. In the clause corresponding \nto a particular function, we use a curried version of the original function. This curried function is \npassed as the .rst argument to the auxiliary, apply*. The list of arguments is passed as the second argument \nto apply*. If the list argument to apply* is empty, the function argument should be a thunk, which is \nthus applied to no arguments. Otherwise, apply* applies the function to the .rst value in the list, producing \nanother function, and shorter argument list. An application of a function to a single arbitrary expression \nis a special case. These are the applications that make up the evaluation context. For all other applications, \nthe arguments are syntactic variables or values and can thus be collected in a list. For the special \ncase, we de.ne another apply-like function app.  4. Pragmatics Translating the theory into practice \nposes different challenges in different contexts. Thus far, we have gathered experience in two different \ncontexts: a language for servlets in the spirit of the PLT Web server [14] and an implementation of Scheme \non Microsoft s .Net IL [22]. In this section, we brie.y discuss how the translation works in these contexts \nand a few obstacles that we encountered. 4.1 Scheme and the Web Server The PLT Web server [14] acts \nas an operating system for its servlets. Most importantly, the server implements I/O primitives and, \nwhen a servlet is loaded, links those primitives into the servlet. The primary I/O primitive is2 send/suspend \n;; ((URL . Response) . Request) The function consumes a function that maps a URL to a Response; its result \nis the next Request from the client (if any). When the servlet calls send/suspend with a function f , \nthe PLT server grabs 2 With send/suspend, one can implement a variety of multi-dispatch inter\u00adaction \nfunctions [17]. (module add \"persistent-web-interaction.ss\" (require (lib \"url.ss\"\"net\")) ;; add2: . \nNumber ;; obtain two numbers from client and compute the sum ;; (+ (get-number \".rst\")(get-number \"second\")) \n(de.ne (add2) (let ((one (get-number \".rst\")) (two (get-number \"second\"))) (+ one two))) ;; get-number: \nString . Number ;; ask the user for a number (de.ne (get-number msg) (de.ne (generate-html k-url) (hmtl \n(head (title ,(format \"Get a number\" msg))) (body (form ([action ,(url->string k-url)] [method \"post\"] \n[enctype \"application/x-www-form-urlencoded\"]) ,(format \"Enter the a number to add: \" msg) (input ([type \n\"text\"][name \"number\"][value \"\"])) (input ([type \"submit\"])))))) (let ([req (send/suspend/url generate-html)]) \n(string->number (extract-binding/single number (request-bindings req))))) ;; run, servlet, run (let ([initial-request \n(start-servlet)]) (html (head (title \"Final Page\")) (body (h1 \"Final Page\") (p ,(format \"The answer \nis a\" (add2))))))) Figure 11. A PLT servlet for adding two numbers the current continuation k, creates \na unique URL, uses it as a key for indexing k in a hash-table, and then applies f to the URL. The resulting \nResponse is shipped to the client and the servlet is suspended. If the client visits the generated URL, \nthe server resumes the continuation from the hash-table and invokes it on the client s data. The major \nadvantage of this approach is that programmers do not have to understand the CGI protocol to get interactions \nwith clients correct. Instead the programmer may act as if she were implementing an ordinary interactive \nprogram. For an example, consider the add2 [26] function in .gure 11. It reads two numbers from some \ninput medium and adds them. The program is organized like a naive console-style program, and yet it works \nproperly even in the face of Web interactions such as back buttons and clone functions. An ordinary CGI \nscript or Java servlet could not use this stan\u00addard, 1960-ish organization. Because of the nested use \nof get\u00adnumber (and its input action), the program would have to be con\u00adtorted3 to match the Web interaction \nprotocol. More precisely, the script or servlet would consist of three distinct programs (roughly callbacks), \nthe .rst two for the inputs and the last one for the output. Naturally, the continuation-based approach \ncomes at a price. Every interaction allocates space for a continuation on the server. Since the dynamic \nextent of this interaction is inde.nite, it is impossible to garbage-collect this space in an ordinary \nmanner. Keeping with the garbage collection analogy, some method must 3 The contorted structure roughly \ncorresponds to GUI callbacks. This analogy is misleading, however, because the control .ow actions of \nordinary GUI programs never include capabilities such as going back, cloning the GUI and exploring actions \non the model in parallel, or bookmarking an interaction step. In contrast, the developer of a Web program \nmust be aware of these kinds of actions, because they are an ordinary part of any Web browser. For details \nsee our prior work [12]. be employed to determine the liveness of a URL. One possibility is to group \ninteractions temporally into some kind of session construct and clean up at the close of the session. \nThis approach precludes the bookmarking and emailing of URLs. Alternatively, continuations can be given \na timeout so that after a period of time, the URL expires and can be cleaned up. Once again, bookmarking \nand emailing cause problems in some cases, timeouts would have to be set to very large values. The timeout \nmodel degrades to the case where continuations are simply not cleaned up at all. In general, the approach \ndoesn t scale well because it places client\u00adoriented space on the server. Based on our framework of call/cc \nelimination, we can over\u00adcome this obstacle. Speci.cally, we have prototyped a new imple\u00admentation of \nour servlet interaction language, dubbed \"persistent\u00adweb-interaction.ss\". This prototype enables us to \nuse a standard Web server such as Apache [32] to execute the servlets.4 The servlet language is provided \nas a PLT module language [10]. To create a program fragment in this language, a programmer cre\u00adates a \nmodule, specifying the name of the module and the language: see the .rst line in .gure 11. Our language \ncomprises a subset of PLT Scheme, plus the send/suspend primitive. Furthermore, it is possible to import \nstandard libraries and other modules written in plain PLT Scheme into a servlet. In .gure 11, (require \n(lib \"url.ss\" \"net\")) imports the standard PLT libraries for manipulating URLs. A module language such \nas \"persistent-web-interaction.ss\" consists of a set of macros and library functions, also known as a \nrun-time library. The macros translate the code in the subject module. The generated code typically refers \nto the library functions from the language module. PLT Scheme s macro system suf.ces to implement the \ntrans\u00adlation from section 3 in an almost literal manner because PLT Scheme provides continuation marks. \nThe run-time environment for \"persistent-web-interaction.ss\" consists of two functions, one used by the \nserver and one used when writing servlets: 1. send/suspend, which builds on call/cc. This function collects \nthe continuation marks and serializes them. Of course, it must also terminate the servlet so that the \nserver can send the re\u00adsponse to the client. In short, this new implementation of send/suspend is completely \nconsistent with the standard CGI protocol, to ensure compliance with traditional servers. Since it is \nnot obvious where an interactive Web program should store the serialized continuation, our prototype \nactu\u00adally provides two send/suspend primitives: send/suspend/url, which creates a URL from the serialized \ncontinuation, and send/suspend/hidden, which stores it in a hidden .eld on the generated page. The URL-based \nversion accommodates the bookmarking facility of browsers; the Web-based version overcomes systems limitations, \nwhich sometimes restrict the amount of information that can be stored in URLs. We intend to experiment \nwith both primitives until we have de.nitive ex\u00adperimental data. 2. dispatch, used by the server, which \nuses a URL to reconstitute the embedded continuation, thus re-launching a servlet s com\u00adputation from \nthe last interruption point. The function is like resume from section 3, but also deals with the decoding \nof the URL and some other book-keeping details.  The rest of the section presents three speci.c problems \nand obstacles, how we have solved them for now, and what a general solution may look like. 4 To simplify \nthe prototyping effort, we actually implemented our own standard (continuation-free) Web server; in principle, \nhowever, our servlets could run on any standard server. 1. The .rst problem is due to the defunctionalization \nphase of the translation. Recall that the defunctionalization phase attaches a label to each A expression \nin the program. These labels become the structure tags for the function values that are published as \npart of the continuation. The theoretical treatment of defunc\u00adtionalization ignores the details of how \nthe labels are generated. Furthermore, it assumes that the labeling is .xed throughout the program s \nexecution. A Web-server may suspend and resume the same servlet several times during a single interaction \nwith a particular user. Thus if a continuation is published during the execution of a particular translated \nversion of a servlet then the same trans\u00adlated version must be used at the time when the continuation \nis invoked. Otherwise, the labeling chosen during the latter s defunctionalization would likely be inconsistent \nwith the labels that were generated during the earlier defunctionalization and that are now embedded \nin the URL. An obvious but naive solution is to simply compile the servlet, i.e., translate the servlet \nonce, storing the result in a .le, and then arrange for the server to load the compiled version for all \nrequests to the servlet s URL. Consider the case, how\u00adever, where the servlet is modi.ed and then recompiled. \nIt is critical that the set of labels chosen during defunctionalization of the new version be disjoint \nfrom the previous set of labels. Otherwise, outstanding continuations could be misinterpreted under the \nnew version. The opposite problem arises when the program s compiled code is kept in memory, rather than \nthe .le system. If an identical version of a servlet is compiled then the same labeling should be used. \nNotice that none of these problems arise if when given iden\u00adtical input, elaboration yields identical \noutput, i.e., if elabora\u00adtion is a function. This requires generating identical labels each time the \nservlet is defunctionalized. To achieve a consistent la\u00adbeling, the translator computes a message digest \nbased on the syntactic structure of the program. The translator stores the di\u00adgests in a database and \nassociates a unique small key with each digest. The key is then used as the pre.x for each label in the \nprogram. If the servlet is changed in some non-trivial way (com\u00adments and whitespace are trivial), the \ncomputed message-digest changes and a new key is generated. Values published with the old key become \nobsolete and the server can fail gracefully. Note that the digests are associated with program source \nversions, not with servlet invocations, so the space costs are negligible. One of the goals of this research \nwas to allow interoperability between translated code and existing untranslated libraries. Unlike CPS, \nour translation does not change the calling signature of trans\u00adlated functions, so in theory, it should \nbe possible for translated and untranslated modules to call each other s functions. The remaining two \nproblems illustrate the problems encountered when a servlet interoperates with untranslated code. Most \nof these problems arise when trying to use higher-order functions, so we will use the exam\u00adple in .gure \n12 for illustrative explanations. The program in .gure 12 consists of two modules: one in our new Web \nprogramming language and one in ordinary PLT Scheme. The purpose of the program is to ask a series of \nmultiple choice questions. When the servlet is loaded, it uses map to pose each question and to accumulate \nthe answers in a list. Afterwards, it tallies the results and presents them to the student. The questions \nare represented as instances of the mc-question structure; the quiz itself is a list of instances of \nthis structure. The function get-answer retrieves the answer for a single question from the client. 2. \nThe second problem concerns the interoperability between or\u00addinary Scheme functions and function application \nin our new Web programming language. The most intricate example is the (module quiz \"persistent-web-interaction.ss\" \n(require \"quiz-lib.ss\" (lib \"url.ss\"\"net\") (lib \"servlet-helpers.ss\"\"web-server\")) ;; get-answer: MC-Question \n-Number ;; get an answer for a multiple choice question (de.ne (get-answer mc-q) (let. ([req (send/suspend/hidden \n(make-cue-page mc-q))] [bdgs (request-bindings req)]) (if (exists-binding? answs bdgs) (string->number \n(extract-binding answs bdgs)) -1))) ;; tally: (Listof MC-Question)(Listof Number) -Number ;; count the \nnumber of correct answers (de.ne (tally mc-qs answs) \u00b7\u00b7\u00b7 ) ;; run, servlet, run: (let ([initial-request \n(start-servlet)]) (html (head (title \"Final Page\")) (body (h1 \"Quiz Results\") (p ,(format \"You got \na correct out of a questions.\" (tally quiz (map get-answer quiz)) (length quiz))) (p \"Thank you for taking \nthe quiz\"))))) (module quiz-lib mzscheme (require (lib \"serialize.ss\") (lib \"url.ss\"\"net\")) (provide \n;; type: MC-Question ;; = (make-mc-question String (Listof String) Number) (struct mc-question (cue answers \ncorrect-answer)) make-cue-page quiz) (de.ne-struct mc-question (cue answers correct-answer)) ;; make-cue-page: \nMC-Question -URL HiddenField -HtmlPage ;; generate the page for the question (de.ne (make-cue-page mc-q) \n(. (ses-url k-hidden) (hmtl (head (title \"Question\")) (body \u00b7\u00b7\u00b7 (form ([action ,ses-url]) \u00b7\u00b7\u00b7 ,k-hidden \n\u00b7\u00b7\u00b7 ))))) ;; the quiz: (Listof MC-Question) (de.ne quiz (list (make-mc-question \"Where do babies come \nfrom?\" (list \"The cabbage patch\" \"The stork\" \"A watermelon seed\" \"Wal-Mart\") 1) \u00b7\u00b7\u00b7 ))) Figure 12. \nA multi-module servlet underlined use of map on get-answer. Since get-answer is de\u00ad.ned in the servlet \nmodule, it is subject to elaboration. In the resulting code, get-answer is a structure that send/suspend \ncan serialize into a URL if it is found on the stack. In contrast, map is a standard library function \nand is therefore not translated. Fortunately, PLT Scheme provides structs that act as func\u00adtions. If \na structure de.nition speci.es its instances as proce\u00addural, it must provide an additional slot in which \nit stores the function to be used in function applications. Using such struc\u00adtures, our translation can \nactually represent the defunctionalized functions in a way that represent continuations as functions \nand serializable structs simultaneously. The call to map poses another problem due to calling its arguments \nin a higher-order context. Recall map s conventional de.nition: ;; map: (a . .)(Listof a) . (Listof .) \n(de.ne (mapf l) (cond [(empty? l) empty] [else (cons (f (.rst l)) (map f (rest l)))])) The de.nition \nreminds us that the callback to f takes place in a non-trivial evaluation context. Since native map is \nnot subject to translation, a call to send/suspend during the dynamic extent of the callback would miss \nthe context fragment (cons [] (map f (rest l))). The result would be a continuation with parts missing, \nresulting in unde.ned behavior. Fortunately, we can employ stack-inspection to detect the special circumstances \nthat would otherwise lead to unde.ned behavior and instead signal a runtime error with an informative \nerror message. To detect the special case, we must use a prop\u00aderty of PLT Scheme s continuation marks \nthat is not a part of the theoretical model from section 3. In particular, PLT Scheme supports the de.nition \nof multiple disjoint sets of continuation marks by allowing programs to associate marks with a key that \nuniquely identi.es the set to which the marks belong. Using this mechanism, we create a set of marks \nfor the sole purpose of an\u00adnotating possibly unsafe calls to higher-order functions; when a continuation \nis to be captured and serialized, send/suspend inspects this set for unsafe marks. If any such marks \nare en\u00adcountered, the function signals an error. For clari.cation, we illustrate the details of using \nsuch safety marks via our running example. For use as a key, asso\u00adciated with boolean values, we create \na unique value and bind it to the identi.er, safe?. The translator marks the body of ev\u00adery translated \nfunction using true and when it encounters an application of a possibly untranslated function it uses \nfalse. Af\u00adter safety annotations are added, the underlined call to map in .gure 12 becomes: (w-c-m safe? \nfalse (map get-answer quiz)) The translated version of get-answer is (de.ne (get-answer mc-q) (w-c-m \nsafe? true (let\u00d8\u00b7 \u00b7\u00b7 ))) And .nally, the following fragment of code results from reducing the now annotated \ncall to map: (w-c-m safe? false (cons (w-c-m safe? true (let\u00d8 ([req (send/suspend/hidden \u00b7\u00b7\u00b7 )]) . . \n. )) (map get-answer (rest quiz)))) The inner w-c-m is not in tail position with respect to the outer \nw-c-m, so both marks appear in the list associated with the safe? key. The presence of the false value \nin this list results in an error when send/suspend/hidden is invoked. Now our servlet always signals \nan error at the .rst interac\u00adtion with the user. To overcome this error, the servlet writer is forced \nto move the de.nition of map into the servlet module so that it becomes subject to translation. In the \ntranslated version, the outer mark is canceled by the mark around the body of the programmer-de.ned map \ndue to the tail-call optimization for continuation marks. int fact (int x) { int fact (int x) { int \nfact (int x) { if (x < 2) if (x < 2) if (x < 2) return 1; return 1; return 1; else else { else { return \nint temp0 int temp0; x * fact (x -1); = fact (x -1); try { } return x * temp0; temp0 = fact (x -1); } \n} } catch (SaveContinuation sce) { sce.Extend (new fact_frame0 (x)); throw; } return x * temp0; } } Figure \n13. Continuations and MSIL  Despite these complications, our translation is superior to CPS. In particular, \nour translated code can always interoperate with untranslated code whereas CPS breaks down in the pres\u00adence \nof higher-order functions. Furthermore, we have a general technique that discovers the mismatch and signals \nan error. Ide\u00adally, there would be no such error cases, so in this regard we claim only a partial solution. \nPragmatically, in the context of Web interactions, the cases involving unsafe continuation capture are \nprecisely those cases that require special treatment with regard to managing program state across interactions. \nObtaining .ner control over servlet state requires moving higher order code into the domain of the translation. \nThis can be problematic, as the next example illustrates. 3. The third problem becomes visible when we \neliminate the use of map by supplying our own de.nition (here called get\u00adanswers) and subjecting it to \ntranslation: ;; get-answers: ;; (Listof MC-Question) . (Listof Number) ;; get the answers to all the \nquestions in mc-qs (de.ne (get-answers mc-qs) (cond [(empty? mc-qs) empty] [else (cons (get-answer (.rst \nmc-qs)) (get-answers (rest mc-qs)))])) Thus, in place of (map get-answer mc-qs) we can write (get\u00adanswers \nquiz). Since get-answer uses send/suspend, it captures the contin\u00aduation of (get-answer (.rst mc-qs)), \nwhich is closed over mc-qs, the list of questions. This information is serialized into the URL transmitted \nto the user, which can lead to a signi.cant growth in the size of this URL. Furthermore, an implementation \nmay even leak sensitive information in this URL.5 Our partial solution would be complete but for the \nques\u00adtion of what to do when a Web-interaction is encountered from within the a call to a higher-order \nfunction. In a system that pro\u00advides native continuations, we can extend the partial solution to a full \nsolution by falling back to native continuations when unsafe marks are discovered on the stack. This \nproposal au\u00adtomatically places program state on the server in the case when 5 The continuation also includes \nthe user s answers to the questions that have already been completed; in this instance this is less problematic \nbe\u00adcause the information is being transmitted to its very author, but in general this requires a cryptographic \nsolution. it is not explicitly handled by the Web programmer. The use of native continuations is still \nsubject to the limitations discussed previously and thus the Web programmer must still be aware of the \nimplications of using higher order libraries. To overcome the limitations of native continuations, the \nWeb programmer will have to explicitly code certain higher order functions so that they will be subject \nto translation. In this case, continuations are closed over program data which can either be stored on \nthe server or encoded in the outgoing response. We are currently considering a memoization mechanism \nthat keeps immutable data, such as the list of questions in our example, on the server and then encodes \nan opaque reference in the URL. When the servlet is re-launched, the mechanism (re)computes the necessary \nvalue based on the reference.6  4.2 Scheme and MSIL The use of virtual machine languages as intermediate \nrepresenta\u00adtions has become the norm in recent compiler developments. Mi\u00adcrosoft s Common Language Runtime \n[22] and Sun s JVM [34] are prominent examples. Compiling a language to either of these VMs almost immediately \nequips the language with rich run-time libraries and with access to programming environment tools, in\u00adcluding \ndebuggers and pro.lers. Due to various reasons, however, these machines do not grant programs full access \nto their stacks. Compiling Scheme, Smalltalk, Ruby or any other language that uses .rst-class continuations \nto such an architecture thus poses a dilemma. At least at .rst glance, the compiler writer must either \nforego the implementation of continuations or manage a stack\u00adaway-from-the-VM stack. The .rst choice \nlimits the programmers of these languages, and the second gives up on many of the advan\u00adtages that these \nmachines supposedly offer. Our discovery that continuation marks can implement .rst-class continuations \nresolves this dilemma. Even though the widely used VMs don t implement continuation marking mechanisms \nin the spirit of PLT Scheme, they do implement means for installing ex\u00adception handlers, and those are \nsuitable for mimicking continuation marks. It is in this regard that we consider continuation marks as \na generalization of other stack inspection mechanisms. In this section, we illustrate how generalized \nstack inspection is adapted to the restricted virtual machine environment of the Com\u00admon Language Runtime \n[22]. Roughly speaking, marking a con\u00adtinuation (w-c-m) corresponds to the installation of an exception \nhandler; the inspection of the continuation marks (c-c-m) can be accomplished by raising an exception, \nthus transferring control to code that writes a representation of the mark to the heap as the 6 The idea \nof recomputing such values is also present in the WASH/CGI framework [33]. stack unwinds. To avoid the \ncomplexities of the machine language, we present our discussion in terms of C#. The use of C# makes it \neasier to convey the ideas behind the implementation without hid\u00ading any of the engineering problems \nthat we encounter. The chosen example is the fact program, shown on the left of .gure 13. As described, \nthe .rst step is to convert the program to ANF. This requires the introduction of local variables to \nhold the intermediate results of compound expressions. The normalized pro\u00adgram has the property that \nall compound expressions are composed only of primitive subexpressions and appear either on the right \nhand side of a new variable binding or as the expression in a return state\u00adment. For fact, this conversion \nis near-trivial and its result is the function in the center of .gure 13. Once the program is in ANF, \nwe wrap each function call with an exception handler: see the right-most code fragment in .gure 13. This \nuse of the try-catch construction is equivalent to w-c-m in the theoretical model. In the model, the \ncontinuation marks introduced by w-c-m are closures and are eagerly created when the function is entered. \nIn the C#-implementation, the analogous closures are only created as the stack is unwound by the special \nexception. In effect, the representation is created lazily. Next consider two scenarios. First, if the \nprogram must cap\u00adture a continuation during the dynamic extent of the try block, it throws an exception. \nSpeci.cally, it throws an exception SaveContinuation that only the newly inserted handlers know about \nand catch. Second, the try block returns normally. In this case, the continuation mark isn t needed and \nno extra work is performed. That is, a program that does not use .rst-class con\u00adtinuations pays only \nfor the establishment of exception handlers around (non-tail) function calls. Fortunately, the implementors \nof the virtual machine assume that exception handlers are established with some frequency and have therefore \nmade this a reasonably inexpensive operation. Following our model, a C#-implementation of call/cc must \nimplement a search of all continuation marks. A targeted throw of an exception takes control to the handlers \naround function calls. The handler then constructs the closure represented as objects that represents \nthe respective mark in the continuation: ... try { temp0 = fact (x -1); } catch (SaveContinuation sce) \n{ sce.Extend (new fact_frame0 (x)); throw; } ... Once the current frame has been added to the list of \ncontinuation marks, the program re-raises the exception so that it eventually stops the program. Naturally, \nwe can t let the throw of a SaveContinuation ex\u00adception stop the program. Instead, our implementation \nsurrounds the entire program with a handler that, according to the semantics of call/cc immediately resumes \nthe program with the current con\u00adtinuation and hands the continuation to the argument of call/cc. The \nimplementation of resume poses an additional complica\u00adtion. The raising of a SaveContinuation exception \n(and its re\u00adraising) collects the continuation marks in most-recent to the least\u00adrecent order. Because \nwe reconstruct the context from the least\u00adrecent .rst, the natural ordering is conveniently correct. \nIf a second continuation is captured within this restored context, however, we must ensure that the marks \ncommon to both continuations are not duplicated. Duplicating these marks would duplicate closures, both \ncausing problems with synchronization and changing the order of void Resume (Context frame, ContextList \nmoreRecentFrames) { object returnValue; if (moreRecentFrames == null) returnValue = null; else returnValue \n= Resume (moreRecentFrames.first, moreRecentFrames.rest); try { return frame.Invoke (returnValue); } \ncatch (SaveContinuation sce) { sce.AppendSharedContext ( frame.OlderContext); throw; } } Figure 14. \nThe implementation of resume for MS IL space usage. Obviously the former might affect correctness, and \nthe latter would signi.cantly hurt the performance of our strategy. For these reasons, we implement resume \nsuch that it avoids du\u00adplicating the shared parts of the continuation marks that represent the evaluation \ncontext: see .gure 14. More precisely, each frame in the context recursively reloads the more recent \nframes. Note that the recursive call returns to a try-catch block like the one in fact. The recursion \nterminates when the most recent frame is reloaded. Pending chains of calls to resume are not protected \nby an exception handler so that they aren t duplicated by the cap\u00adture. The exception handler is only \nestablished when a frame is about to continue execution (the remainder of Resume). The excep\u00adtion handler \nis different from the one we wrap around the original code. It uses the already computed representation \nof the evaluation context. When the SaveContinuation exception is thrown again, each newly created evaluation \ncontext saves its state, but the top\u00admost restored frame arranges for these to be linked to the previously \nsaved context.  5. Related Work Three pieces of past research bear a strong resemblance to ours: Cartwright \nand Felleisen s work on extensible denotational seman\u00adtics [3], Sekiguchi, Sakamoto and Yonezawa s work \non checkpoint\u00ading and transparent migration [29], and Tao s work on migrating Java threads [31]. Cartwright \nand Felleisen adapt Felleisen s work [5, 6] on an imperative extension of the lambda calculus to a denotational \nset\u00adting. In the traditional Scott-Strachey framework for denotational semantics [30], a language extension \ndeeply affects the structure of the mapping from syntax to semantics. For example, if a language designer \nwishes to add continuations to a functional language, a revision of the semantic mapping must introduce \na parameter that abstracts over the continuation of an expression (statement, de.\u00adnition). Worse, the \nchange to the denotational mapping radically changes the denotation of an expression in the original \nlanguage. In the Cartwright-Felleisen framework, the denotation of an expression may return either a \nvalue or an effect. Returning an effect is analogous to throwing an exception. Each denotation is equipped \nwith a handler-like function that augments the effect in an appropriate manner and passes it to the context. \nUltimately, an effect reaches a handler function, dubbed admin, at the root of the denotational tree. \nGiven this arrangement, a language designer can easily extend a language by injecting new effects and \nadding corresponding clauses in the admin function. A universal theorem governs such language extensions. \nSpeci.cally, for each language extension, there is a projection that can eliminate the relevant parts \nof a denotation for any expression in the core language and re\u00adcreate its original denotation. The call/cc-elimination \ntransformation of this paper is to the Cartwright-Felleisen framework what the CPS transformation is \nto the Scott-Strachey framework of denotational semantics. In other words, it is a syntactic analog of \nthe semantic mapping in Cartwright-Felleisen. From this perspective, the soundness theo\u00adrem in this paper \n.nally con.rms that the call/cc expressed in this framework is equivalent to the original call/cc, something \nthat Cartwright and Felleisen failed to con.rm. Sekiguchi et al. describe a method for implementing partial \ncon\u00adtinuations in Java and C++, with check-pointing and thread migra\u00adtion as possible applications. The \nmethod uses exception handling to construct continuation values as the stack unwinds. In lieu of call/cc, \nSekiguchi et al. use Gunter et al. s partial and delimited continuations [15]: cupto p as x in e capturing \nthe functional continuation set p in e delimiting the effect of cupto with the following evaluation rule \nfor cupto: set p in E[cupto p as x in e] . (Ax.e)(Ay.E[y]) Notice that evaluation of cupto abandons the \nsurrounding context, which more closely models the semantics of stack unwinding than other control-.ow \noperations such as call/cc. Our translation is de.ned on program source code, while Sekiguchi et al. \nde.ne their translation on byte-codes. Their translation also performs a fragmentation step analogous \nto A-Normalization. During resumption an extra parameter carries the control state and extra logic is \nadded to each function to distinguish between normal function calls and resumption. This amounts to an \nin-lining of resume. Sekiguchi et al., like us, are concerned with faithfully recon\u00adstructing the stack. \nMore critical to their choice of languages, Sekiguchi et al. are concerned about preserving the call-graph \nof the original program. The authors dismiss a potential solution based on CPS transformation, because \nCPS transformed code cre\u00adates an unbounded sequence of tail calls. Sekiguchi et al. do not go into much \ndepth with regards to how to combine translated and untranslated code. For example, they do not discuss \nthe problems associated with changing the calling signature of each method. They do recognize the problem \nwhere the call stack contains stack frames of non-transformed methods. We introduce safety marks as a \npartial solution to this case, while they have no solution and identify it as a limitation of their scheme. \nFinally, Sekiguchi et al. offer no theoretical treatment of their technique. Like Sekiguchi et al., Tao \ndescribes a method for thread persis\u00adtence and migration, leveraging Java s exception mechanism. Tao \nde.nes the translation for source code and byte-codes. Tao gives a minimal theoretical treatment of the \nmethod based on a denotational semantics for a small while-loop language. There is no theorem stating \nthe equivalence of the original and translated forms of the program, i.e., there is no correctness result. \nTao does attempt to prove that evaluating a program in the presence of any number of shutdown operations \nis equivalent to evaluating the program without interruptions. The proof is skeletal and relies on an \nunspeci.ed extension to the denotational semantics. Tao does not employ any kind of fragmentation before \nanno\u00adtating the source code. For example, statement sequences are not broken. Instead, her work maintains \nan index and adds extra logic to the code so that the resumption point can be relocated when a continuation \nis reinstated. A further complication is that Tao essen\u00adtially makes two versions of the program: a shutdown \nversion and a restart version. Extra logic needs to be sprinkled throughout the code to distinguish between \nnormal function calls and resumption. As with Sekiguchi et al., this is analogous to in-lining of resume. \nFor the source code version of the transformation, Tao makes the restriction that continuations cannot \nbe captured during the evaluation of an expression. This restriction is needed because it is supposedly \ndif.cult to save temporary variables at the source .le level [31, section 3.2.7]. This can be seen as \na consequence of not fragmenting the original program. Because there is no explicit closure identi.ed \nwith the continuation of each expression, it is dif.cult to reason about the free variables of that closure. \nFinally, Schinz and Odersky [28] use a small portion of our transformation to implement tail-call optimizations \nfor the JVM. Speci.cally, they install a handler (a.k.a., trampoline) at each tran\u00adsition from a properly \nnested call to a chain of tail-calls; if the depth of tail-calls gets too deep, they erase them with \na jump to the closest handler, which then reconstitutes the one stack frame for the prop\u00aderly nested \ncall. Schinz and Odersky did not recognize that their transformation could be generalized to deal with \n.rst-class contin\u00aduations. 6. Perspective and Conclusion We have presented a novel formal transformation \nfor explicating the continuation of a computation. Our transformation is de.ned using continuation marks, \nwhich we regard as a generalized form of stack inspection. We have also demonstrated that the transfor\u00admation \ncan be implemented using exceptions a stack inspection mechanism which can be regarded as standard on \nmodern virtual machines (and in a growing set of languages). By exploiting stack inspection, we show \nhow to capture and reconstruct the stack with\u00adout the need for CPS, which depends on tail calls (that \nmany virtual machines don t provide) and hides the stack (which is necessary not only for many debugging \nand program understanding tools, but also for contemporary security mechanisms). Our transformation has \ntwo immediate applications. First, it is valuable for continuation-based Web applications that need to \nrun in a stateless manner for greater scalability. Second, it helps imple\u00adment languages with continuations, \nsuch as Scheme, on traditional virtual machines without emasculating the language or making its code \nincompatible with the VM s assumptions (since virtual ma\u00adchines are not designed to assume the code they \nrun will be in CPS). We conjecture that there are deeper applications, which we have not yet explored \nin detail: The transformation could improve the usability of continuation\u00adbased Web applications. Currently, \nthe PLT Web server gener\u00adates a nonce for each captured continuation and embeds this in the URL. These \nnonces become invalid when the server re\u00adboots, making it useless to bookmark or distribute these URLs. \nIn contrast, like the CPS solution, our transformation can gener\u00adate more durable URLs by referring to \n(named) code fragments and placing the free variable values in an argument list, creating a form of Web \ncommand line .  The transformation makes it possible to employ a variety of techniques for implementing \n.rst-class continuations. For in\u00adstance, the scheme by Dybvig, et al. [16] enables constant-time continuation \ncapture and application, by making stack copy and restoration lazy. Our representation of the stack makes \nit easy to similarly reconstitute only a constant number of stack seg\u00adments, leaving a pointer to a function \nclosed over the rest of the stack that reconstitutes more of it on demand. Implementing a similar scheme \natop CPS would require customization of the  function charged with marshalling and unmarshalling closures \nto recognize the special case of the continuation argument. The transformation has implications for \nvirtual machine design\u00aders also. The Parrot virtual machine, which is intended to pro\u00advide a common platform \nfor scripting languages such as Perl, Python and Ruby, has considered using CPS just to support con\u00adtinuations; \nits developers have been evaluating the trade-off be\u00adtween the bene.ts of continuations and the (user) \ncost of pro\u00adgramming the entire system in CPS.7 Our transformation offers them a potential way out of \nthis quandary.  Current implementations of Scheme targeted at virtual ma\u00adchines do not interact with \nor exploit the underlying security mechanisms. Indeed, it would be dif.cult for those that use CPS to \ndo so, due to the (unfortunate) explicit reliance of these mechanisms on the stack. Our technique restores \nthe primacy of the stack, making it possible to provide these security features as language extensions. \nFurthermore, even Web applications running on these virtual machines may be able to use these se\u00adcurity \nextensions, because our transformation reconstitutes the stack.  Our immediate goal is to extend this \ntransformation to handle the full Scheme language, and to apply it to both our compiler and Web server. \nIn particular, we hope to use this to improve the performance of our conference management application. \n  References [1] Anderson, K., T. Hickey and P. Norvig. JScheme. http: //www.norvig.com/jscheme.html. \n [2] Bres, Y., B. Serpette and M. Serrano. Bigloo .NET: compiling Scheme to .NET CLR. Journal of Object \nTechnology, 3, October 2004. [3] Cartwright, R. and M. Felleisen. Extensible denotational language speci.cations. \nIn Theoretical Aspects of Computer Software, pages 244 272, 1994. [4] Clements, J., M. Flatt and M. Felleisen. \nModeling an algebraic stepper. In European Symposium on Programming, pages 22 37, 2001. [5] Felleisen, \nM. and D. Friedman. A syntactic theory of sequential state. In Theoretical Computer Science, pages 243 \n287, 1989. [6] Felleisen, M. and R. Hieb. The revised report on the syntactic theories of sequential \ncontrol and state. In Theoretical Computer Science, pages 235 271, 1992. [7] Findler, R. B., J. Clements, \nC. Flanagan, M. Flatt, S. Krishnamurthi, P. Steckler and M. Felleisen. DrScheme: A programming environment \nfor Scheme. Journal of Functional Programming, 12(2):159 182, March 2002. [8] Flanagan, C., A. Sabry, \nB. F. Duba and M. Felleisen. The essence of compiling with continuations. In ACM SIGPLAN Conference on \nProgramming Language Design and Implementation, pages 237 247. 1993. [9] Flatt, M. PLT MzScheme: Language \nmanual. http://www. plt-scheme.org/software/, 1996 2005. [10] Flatt, M. Composable and compilable macros: \nYou want it when? In ACM SIGPLAN International Conference on Functional Programming, 2002. [11] Graham, \nP. Beating the averages. http://www.paulgraham.com/ avg.html, April 2001. [12] Graunke, P., R. Findler, \nS. Krishnamurthi and M. Felleisen. Modeling web interactions. In European Symposium on Programming, pages \n238 252, April 2003. [13] Graunke, P. T., R. B. Findler, S. Krishnamurthi and M. Felleisen. Automatically \nrestructuring programs for the Web. In IEEE 7 Dan Sugalski, message to the Lightweight Languages mailing \nlist, May 7, 2003. International Symposium on Automated Software Engineering, pages 211 222, November \n2001. [14] Graunke, P. T., S. Krishnamurthi, S. van der Hoeven and M. Felleisen. Programming the Web \nwith high-level programming languages. In European Symposium on Programming, pages 122 136, April 2001. \n[15] Gunter, C. A., D. R\u00b4 A generalization of emy and J. G. Riecke. exceptions and control in ML. In \nProc. ACM Conf. on Functional Programming and Computer Architecture, June 1995. [16] Hieb, R., R. K. \nDybvig and C. Bruggeman. Representing control in the presence of .rst-class continuations. In ACM SIGPLAN \nConference on Programming Language Design and Implementation, 1990. [17] Hopkins, P. W. Enabling complex \nUI in Web applications with send/suspend/dispatch. In Scheme Workshop, 2003. [18] Hughes, J. Generalising \nmonads to arrows. Science of Computer Programming, 37(1 3):67 111, May 2000. [19] Kelsey, R., W. Clinger \nand J. Rees (Eds.). Revised5 report of the algorithmic language Scheme. ACM SIGPLAN Notices, 33(9):26 \n76, 1998. [20] Krishnamurthi, S. The CONTINUE server. In Symposium on the Practical Aspects of Declarative \nLanguages, pages 2 16, January 2003. [21] Matthews, J., R. B. Findler, P. Graunke, S. Krishnamurthi and \nM. Felleisen. Automatically restructuring programs for the Web. Automated Software Engineering, 11(4):337 \n364, 2004. [22] Microsoft Corporation. The .NET common language runtime. http://msdn.microsoft.com/net/. \n[23] Miller, S. SISC. http://sisc.sourceforge.net. [24] Plotkin, G. D. Call-by-name, call-by-value, and \nthe .-calculus. Theoretical Computer Science, pages 125 159, 1975. [25] Pottier, F. and N. Gauthier. \nPolymorphic typed defunctionalization and concretization. To appear in Higher-Order and Symbolic Computation, \nMay 2005. [26] Queinnec, C. The in.uence of browsers on evaluators or, contin\u00aduations to program web \nservers. In ACM SIGPLAN International Conference on Functional Programming, pages 23 33, 2000. [27] Reynolds, \nJ. C. De.nitional interpreters for higher-order program\u00adming languages. In Proceedings of the ACM Annual \nConference, pages 717 740. ACM Press, 1972. [28] Schinz, M. and M. Odersky. Tail call elimination on \nthe java virtual machine. In Proc. ACM SIGPLAN BABEL 01 Workshop on Multi-Language Infrastructure and \nInteroperability., volume 59 of Electronic Notes in Theoretical Computer Science, pages 155 168. Elsevier, \n2001. http://www.elsevier.nl/locate/entcs/ volume59.html. [29] Sekiguchi, T., T. Sakamoto and A. Yonezawa. \nPortable implementa\u00adtion of continuation operators in imperative languages by exception handling, volume \nAdvances in Exception Handling Techniques, pages 217 233. Springer-Verlag, 2001. [30] Stoy, J. E. Denotational \nSemantics: The Scott-Strachey Approach to Programming Language Theory. MIT Press, 1977. [31] Tao, W. \nA portable mechanism for thread persistence and migration. PhD thesis, University of Utah, 2001. [32] \nThe Apache Software Foundation. Apache HTTP Server Project. http://httpd.apache.org. [33] Thiemann, P. \nWASH/CGI: Server-side web scripting with sessions and typed, compositional forms. In Practical Applications \nof Declarative Languages, 2002. [34] Tim Lindholm and Frank Yellin. The Java Virtual Machine Speci.cation \n(Second Edition). Sun Microsystems, 1999. [35] Wallach, D., E. Felten and A. Appel. The security architecture \nformerly known as stack inspection: A security mechanism for language-based systems. ACM Transactions \non Software Engineering and Methodology, 9(4), October 2000. \n\t\t\t", "proc_id": "1086365", "abstract": "Implementing first-class continuations can pose a challenge if the target machine makes no provisions for accessing and re-installing the run-time stack. In this paper, we present a novel translation that overcomes this problem. In the first half of the paper, we introduce a theoretical model that shows how to eliminate the capture and the use of first-class continuations in the presence of a generalized stack inspection mechanism. The second half of the paper explains how to translate this model into practice in two different contexts. First, we reformulate the servlet interaction language in the PLT Web server, which heavily relies on first-class continuations. Using our technique, servlet programs can be run directly under the control of non-cooperative web servers such as Apache. Second, we show how to use our new technique to copy and reconstitute the stack on MSIL.Net using exception handlers. This establishes that Scheme's first-class continuations can exist on non-cooperative virtual machines.", "authors": [{"name": "Greg Pettyjohn", "author_profile_id": "81100321174", "affiliation": "Northeastern University", "person_id": "P745794", "email_address": "", "orcid_id": ""}, {"name": "John Clements", "author_profile_id": "81100279419", "affiliation": "Northeastern University", "person_id": "PP24013789", "email_address": "", "orcid_id": ""}, {"name": "Joe Marshall", "author_profile_id": "81547803556", "affiliation": "Northeastern University", "person_id": "PP30027328", "email_address": "", "orcid_id": ""}, {"name": "Shriram Krishnamurthi", "author_profile_id": "81100512233", "affiliation": "Brown University", "person_id": "PP43120749", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University", "person_id": "PP39037684", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086393", "year": "2005", "article_id": "1086393", "conference": "ICFP", "title": "Continuations from generalized stack inspection", "url": "http://dl.acm.org/citation.cfm?id=1086393"}