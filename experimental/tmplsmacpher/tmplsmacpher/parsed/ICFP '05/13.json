{"article_publication_date": "09-12-2005", "fulltext": "\n Quali.ed Types for MLF Daan Leijen Andres L\u00a8 oh Institute of Information and Computing Sciences, Utrecht \nUniversity P.O. Box 80.089, 3508 TB Utrecht, The Netherlands {daan,andres}@cs.uu.nl Abstract MLF is a \ntype system that extends a functional language with im\u00adpredicative rank-n polymorphism. Type inference \nremains possible and only in some clearly de.ned situations, a local type annotation is required. Quali.ed \ntypes are a general concept that can accom\u00admodate a wide range of type systems extension, for example, \ntype classes in Haskell. We show how the theory of quali.ed types can be used seamlessly with the higher-ranked \nimpredicative polymor\u00adphism of MLF, and give a solution to the non-trivial problem of evidence translation \nin the presence of impredicative datatypes. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: \nLanguage Constructs and Features General Terms Languages, Design, Theory Keywords quali.ed types, impredicativity, \nhigher-rank polymor\u00adphism, MLF 1. Introduction MLF [6] is a type system that extends a functional language \n(in the style of ML [9] or Haskell [10]) with impredicative rank\u00adn polymorphism. Type inference in the \nextended system remains possible, but in some clearly de.ned situations, code that makes use of polymorphic \narguments must be locally annotated with types. Applications that require rank-n polymorphism are surprisingly \ncommon in advanced functional programming. Shan [12] as well as Peyton Jones and Shields [11] present \nplenty of convincing exam\u00adples, such as dynamic types, datatype invariants, and generic (poly\u00adtypic) \nfunctions. Current Haskell implementations are therefore al\u00adready equipped with a type system that supports \na limited form of rank-n polymorphism. The excellent tutorial paper by Peyton Jones and Shields [11] \ndescribes the ideas behind the Haskell implementation in great detail and explains many of the design \ndecisions made. A signi.cant limitation of the Haskell implementation with re\u00adspect to the MLF system \nis that the former is predicative: a quan\u00adti.ed variable can only range over monomorphic types, whereas \nin MLF, a type variable can be instantiated to a polymorphic type again. Impredicativity is essential \nfor abstraction over polymorphic Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 05 September 26 28, 2005, Tallinn, Estonia. Copyright c . 2005 \nACM 1-59593-064-7/05/0009. . . $5.00. values and has a number of advantages for the programmer that make \nMLF more .exible and more intuitive to use. However, there are two reasons that currently prevent a wider \nadoption of the more general MLF approach: In MLF, quanti.ers have bounds that are all collected in \na pre.x at the beginning of the type. This requires the reader to perform an on-the-.y substitution, \nwhich makes it much harder to understand a complicated type. Also, it just looks plainly unfamiliar. \n Functional programming languages used in practice already possess other extensions to the type system \nbesides rank-n polymorphism. Many of these type system extensions, such as type classes, implicit parameters, \nor records, are based on the theory of quali.ed types [3]. Due to impredicativity, it is unclear how \nMLF can work in conjunction with such extensions.  We have the .rm belief that both doubts just raised \ncan be elimi\u00adnated, and we make the following contributions: In Section 2.6 we present a simple convention \nthat can be used to write MLF types in a more intuitive way. The additional notational complexity that \nbounded quanti.cation introduces is only imposed on the programmer when it plays a crucial role.  In \nSection 5 we introduce a variant of the MLF type inference algorithm which performs type-directed evidence \ntranslation to System F. The idea of this modi.cation is informally described in Section 4.3. The evidence \ntranslation is the key contribution of this paper, because it allows the addition of quali.ed types to \nMLF in a way that it can be used ef.ciently in an actual implementation.  With the addition of quali.ed \ntypes, we believe that this paper is a substantial step forward to making MLF .t for use in practical \nprogramming languages. The paper starts by introducing the two main topics that we want to connect: The \nMLF type system is explained by example in Sec\u00adtion 2, comparing it to a plain Hindley-Milner type system \nwith\u00adout rank-n polymorphism and the system used in current Haskell implementations. Section 3 introduces \nquali.ed types, giving ex\u00adamples of a number of different applications, including the Haskell type class \nsystem. We also show that the sum of the two features, rank-n and quali.ed types, is greater than its \nparts, by pointing out applications that are only possible with impredicative quali.ed types. Interestingly, \nthe dif.cult part in combining the features is not to extend the MLF type system with quali.ed types, \nbut how to imple\u00adment the resulting system. Quali.ed types are usually implemented using evidence translation, \nexplained in Section 4. We demonstrate why a na\u00a8ive extension of the standard translation scheme fails. \nIn Section 4.3, we present the core idea to overcome the problems with the standard translation. Following \nthe path outlined in Section 4.3, we present a variant of the MLF type inference algorithm that is augmented \nwith a type\u00addirected evidence translation to System F in Section 5. Adding actual quali.ed types to the \nsystem is then easy and explained in Section 6. In Section 7, we conclude and discuss future work. 2. \nA tour of MLF In this section, we introduce .rst-class polymorphism and analyze the advantages that MLF \noffers over Hindley-Milner and other implementations of higher ranked types. 2.1 Higher-ranked types \nThe Hindley-Milner type system [2] stands at the basis of almost all polymorphic programming language \ntype systems. An impor\u00adtant property of the Hindley-Milner type system is that there ex\u00adists a type inference \nalgorithm that automatically infers most gen\u00aderal types for expressions, and there is no need for extra \ntype an\u00adnotations. At the same time, the type system is sound, where the execution of a well-typed program \ncannot go wrong . The com\u00adbination of these features, together with a straightforward imple\u00admentation, \nmakes the Hindley-Milner type system well-suited for practical use. However, the Hindley-Milner type \nsystem has a signi.cant limi\u00adtation: polymorphic values are not .rst-class. In practice this means that \nonly values that are bound by a let construct can have a poly\u00admorphic type. It is not possible for the \nargument of a function to be used with a polymorphic type. Here is an example of a function that takes \na polymorphic argument1: f choose =(choose True False, choose a b ) The function f takes a function \nchoose and calls it on two booleans and two characters in the body of the function. Neither Haskell, \nnor ML, would accept this de.nition, because in the Hindley-Milner type system, lambda-bound variables \nsuch as choose can only have monomorphic types, which is equivalent to the property that universal quanti.ers \ncan only appear at the outermost level of a type. In contrast, explicitly typed languages such as System \nF allow universal quanti.ers to appear deep within a type. For example, if we know that choose has the \npolymorphic type .a. a . a . a, then the above de.nition makes sense, and f can be given the following \ntype: (.a. a . a . a) . (Bool, Char) This is a rank-2 type, as it contains quanti.ers to the left of \nthe function arrow. The Haskell implementations GHC and Hugs sup\u00adport higher-rank polymorphism such as \nit occurs in the de.nition of f above. If f is equipped with a type signature, the compiler accepts the \nde.nition. However, even though higher-ranked, the implementations are still limited due to a second \nrestriction of Hindley-Milner: quanti.ed variables can only be instantiated with a monomorphic type. \nSystems with this restriction are called pred\u00adicative. The MLF type system is an extension of Hindley-Milner \nthat fully supports .rst-class polymorphism: universal quanti.ers can appear anywhere in a type, and \nquanti.ed variables can be instan\u00adtiated with a polymorphic type. Because of the last feature, MLF is \nan impredicative type system. We believe that impredicativity is very important for abstraction and we \ndiscuss its advantages in more detail in Section 2.4. First, 1 Note that we adopt a Haskell-like notation \nthroughout this paper, even though we are talking about a type system that has been introduced as an \nextension of ML. we take a closer look at the difference between predicative and impredicative instantiation. \nTake for example the following two functions: choose :: .a. a . a . a id :: .\u00df. \u00df . \u00df Let us consider \nthe application choose id. In a predicative system, the type variable \u00df of id has to be instantiated \nto a fresh ., because as an argument to choose, id cannot have a polymorphic type. Consequently, we get: \nchoose id :: ... (. . .) . (. . .) This is the type derived by GHC for example. Impredicatively, we have \na choice. We can do the same as above, but we can also instantiate a to the polymorphic type .\u00df. \u00df . \n\u00df: choose id :: (.\u00df. \u00df . \u00df) . (.\u00df. \u00df . \u00df) However, the choose id example immediately reveals a problem \nwith impredicative polymorphism: neither of the two types above is an instance of the other. Indeed, \na na\u00a8ive implementation of impredicative polymorphism does not have principal types. 2.2 Principal types \nA type system is said to have principal types if each expression can be assigned a best possible type \n, of which all other types it could have are instances. Principal types are necessary for type inference \nto work ef.ciently, because it allows that optimal types are inferred by looking only at a part of the \nprogram, rather than having to perform a global analysis. The achievement of MLF is that it restores \nthe principal types property even in the presence of impredicativity. It does so by extending the type \nlanguage, so that we can assign a type to choose id of which both types above are instances. As a con\u00adsequence, \nMLF does support ef.cient type inference. The principal type for choose id in MLF is choose id :: .(a \n=.\u00df. \u00df . \u00df).a . a The quanti.cation on a gets a bound, meaning that it can be instantiated only with \ntypes that are an instance of .\u00df. \u00df . \u00df. Instantiating a with . . . for a fresh ., or with .\u00df. \u00df . \u00df, \nleads to the two types of choose id given above. 2.3 Type annotations Type inference in MLF never invents \npolymorphism: whenever a lambda-bound argument is used polymorphically, a type annotation is required. \nThe same holds for the Haskell implementation of higher-ranked polymorphism. All these systems, however, \nshare the property that type anno\u00adtations are only required for programs which actually make use of higher-ranked \npolymorphism. All other programs continue to work without type annotations. Therefore, switching the \nunderlying type system of an ML-like language to MLF will not break any existing programs. 2.4 Advantages \nof MLF Until now, we have seen that we can handle impredicative types by complicating the type language. \nWe will argue in Section 2.6 that this complication is not very serious. But .rst, we want to show what \nwe gain by having the MLF system rather than, for instance, the Haskell implementation of higher-ranked \ntypes. We will present two signi.cant examples. Function application is not a special construct Consider \nthe function ($) :: .a \u00df. (a . \u00df) . a . \u00df ($) = id de.ned in the Haskell prelude. This function replaces \nfunction application, such that we can write f $ x instead of fx to denote the application of f to x. \nFixity rules in Haskell specify that $ is right-associative and binds very weakly, whereas ordinary function \napplication is left-associative and binds very strongly. The operator ($) is often used to remove the \nneed for parentheses that would otherwise extend over large portions of code. In the context of higher-ranked \ntypes, however, ($) in Haskell is strictly weaker than normal function application, because the quan\u00adti.ed \nvariables a and \u00df in the type of ($) cannot be instantiated to polymorphic types. We demonstrate this \nwith the help of well\u00adknown higher-ranked function runST , which is part of the Haskell libraries: runST \n:: .a. (... ST .a) . a This function was one of the .rst motivations to consider higher\u00adranked types \nin Haskell. The function runST is used to evaluate a stateful computation of type ST .a, yielding a value \nof type a. The computation must be independent of the parameter ., which ensures that the state does \nnot escape from the computation and is not used in other stateful computations. Values of type ST .a \nare often complex and extend over multiple lines of code, therefore it would be tempting to write runST \n$ very complicated computation This, however, is rejected by all Haskell implementations. How\u00adever, the \nexpression runST (very complicated computation) is accepted. With the impredicative MLF type system, \nboth ver\u00adsions work without type annotations. This example stands for a whole class of applications of \nimpred\u00adicativity which leads to less type annotations required, or actually more programs becoming admissible. \nFor instance, id runST (very complicated computation) is not possible to write in Haskell either for \nmuch the same reason (id cannot be instantiated to runST s polymorphic type). In effect, the usual abstraction \nmechanism of polymorphism no longer works for higher-ranked types in Haskell. This means that the programmer \nneeds to de.ne speci.c versions of general functions like id and ($) for each kind of higher-rank type \noccurring in the program. The special role of function application is not merely an incon\u00advenience to \nthe programmer, it makes it also more dif.cult to prove theorems, perform program derivations, or any \nkind of source-to\u00adsource transformations. Many common transformations such as id x = x are suddenly subject \nto side conditions which require looking at the type of arguments that are involved! With MLF, neither \nprogram\u00admers nor tool developers need to consider rank-n types as some\u00adthing special, and the usual abstraction \nmechanism remain valid. Data structures over polymorphic types In a predicative system, not only function \napplication is special in being able to deal with polymorphic types, also the function space type constructor \n(.) takes a special role: it is the only type constructor that can be parameterized over polymorphic \ntypes. In an impredicative system, any parameterized datatype can be instantiated to polymorphic types \njust as it can be instantiated to monomorphic types. With MLF, we can build lists, tuples, trees, or \ncomplex abstract datatypes such as Haskell s IO monad which are parametrized over a polymorphic type. \nRecall the rank-2 polymorphic function runST: runST :: .a. (... ST .a) . a In Haskell, it is not possible \nto place this function in a list or a pair both of the expressions [runST ] (runST , a ) are rejected \nby the Haskell type checker, and this situation cannot be improved by providing type signatures. The \nreason is that the types would have to be [.a. (... ST .a) . a] (.a. (... ST .a) . a, Char) respectively, \nand these are just not legal in a predicative system. With MLF as type system, both expressions are accepted. \nIt should be mentioned that Haskell allows to place polymorphic values into data structures by hiding \nthe polymorphism within a datatype. One can de.ne newtype RunSTType = Pack (.a. (... ST .a) . a) unPack \n(Pack x)= x and then use Pack runST to store the value into a data structure, and unPack after we extract \nit from the data structure. The disadvantage of this approach is immediately obvious: while newtype can \nbe implemented ef.ciently and causes no runtime overhead, it is very tedious to use this technique as \na programmer. Separate datatypes to pack polymorphic values are needed for each polymorphic type. We \nbelieve that the current situation, while theoretically no less expressive, in practice prevents the \nprogrammer from adopting a solution which makes use of polymorphic types. The MLF type system encourages \nprogrammers to see polymorphic values as .rst\u00adclass values in every respect, that need not be avoided \nand require no special treatment. 2.5 MLF formally After having looked at the features of the MLF system, \nlet us now introduce the MLF type language more formally. The MLF type language distinguishes monomorphic \ntypes (monotypes) from polymorphic types (polytypes). The syntax of monotypes is de.ned as: t ::= g t1 \n..tn | a In other words, a monotype is either an applied constructor g, or a type variable. We assume \nthat the binary function space constructor (.) is among the possible constructors. A polytype is either \nbottom (.), or a monotype quanti.ed with a (possibly empty) pre.x Q: s ::= .|.Q.t A Pre.x is a list of \nconstraints that associate a type variable with a polytype. Each constraint is of the form: (a o s) Here, \no stands either for =, in which case the constraint is called a rigid bound, or it stands for ;, and \nthen we speak of a .exible bound. A bound (a o s) quanti.es the type variable a in the rest of the pre.x \nand the quali.ed type. The idea is that a rigid bound can only be instantiated with exactly the type \ngiven, whereas a .exible bound can be instantiated with any instance of the given type. We will not describe \nthe instance relation precisely, but will focus on some important properties of instantiation. First \nof all, the instance relation is transitive and re.exive, where every type is an instance of . (written \n.. s), thus if bottom is used in a .exible bound, this represents ordinary unbounded quanti.cation. For \nexample, the identity function has the MLF type .(a =.).a . a We abbreviate unbounded quanti.cation and \nwrite .a. a . a instead. We have seen a nontrivial MLF type for choose id, .(a =.\u00df. \u00df . \u00df).a . a where \na can be instantiated with both .\u00df. \u00df . \u00df itself and . . . for a fresh variable .. Formally, .(a =.\u00df. \n\u00df . \u00df).a . a ..(a = .\u00df. \u00df . \u00df).a . a .(a =.\u00df. \u00df . \u00df).a . a .... (. . .) . (. . .) Bounded quanti.cation \nallows us to express .exibility while at the same time maintaining a relation between different parts \nof the type that are represented by the same variable. Rigid bounds occur whenever a function requires \na polymorphic argument, such as runST , which has MLF type .a (\u00df = ... ST .a).\u00df . a Here, we can not \ninstantiate the type as a truly polymorphic type is required. Since this restricts instantiation, we \ncan turn .exible bounds into rigid bounds (but not the other way around), in other words: .(a = sa).s \n..(a = sa).s. Besides the instance relation on types there is also an equiva\u00adlence relation on polytypes, \nwritten =. For instance, the type ... (. . .) . (. . .) is equivalent to the more complicated .. (\u00df = \n. . .).\u00df . \u00df Equivalence preserves the free type variables in a type. Each MLF type has an equivalent \nnormal form. The algorithm to compute the normal form of a type is shown in Figure 1. The labels on the \nbounds v can be ignored for now they will only become rele\u00advant in Section 5 when these are used for \nthe type directed transla\u00adtion. The normal form algorithm basically simpli.es trivial bounds away. From \nthe de.nition we can see that there are three forms of trivial bounds: the quanti.ed variable is bound \nby a monotype, the variable does not occur in the body of the type, or if the body of the type is itself \na variable. THEOREM 1. The normal form of a type is always equivalent to the type itself, i.e., nf(s) \n= s For a more thorough explanation of the MLF theory including the exact de.nitions of instantiation \nand equivalence, the reader is referred to the MLF article [6] or thesis [5]. . nf(t )= t . nf(.)= . \n. nf(.(a ov sa).s)= nf(s) if a/. ftv(s) . nf(.(a ov sa).s)= nf(sa) if nf(s)= a . nf(.(a ov sa).s)= nf(s)[a \n. t ] if nf(sa)= t . nf(.(a ov sa).s)= .(a ov nf(sa)). nf(s) Figure 1. Normal form of MLF types 2.6 \nPresentation of MLF types MLF types put us in a dilemma: they are nice to work with from a theoretician \ns or an implementor s point of view, but they are awkward to read for a programmer. The reason for both \nis that MLF types, although higher-ranked, collect all the quali.ers in a pre.x, at the beginning of \nthe type. In some cases the normal form computation can help to simplify the presentation of a type: \nif a quanti.ed variable is bounded by a monotype, if a variable does not occur in the body of the type, \nor if the body of the type is itself a variable. But even the normal form can still be unexpectedly verbose. \nFor instance, the type of runST in MLF is .a (\u00df = ... ST .a).\u00df . a and this type is in normal form. Yet, \nthe originally given type .a. (... ST .a) . a would probably be considered to be much more readable by \nmost programmers. We therefore propose to adopt a simple heuristic when presenting types to users in \nMLF-based systems: types are .rst converted to normal form,  a .exible constraint (a = s) is inlined \nonly if there is a single occurrence of a in the scope of the constraint, and when that occurrence is \npositive (i.e., to the right of a function arrow),  a rigid constraint (a = s) is inlined only if there \nis a single occurrence of a in the scope of the constraint, and when that occurrence is negative (i.e., \nto the left of a function arrow).  For the purpose of this heuristic, only function arrows (but no other \ntype constructors) in.uence the sign of a position. This heuristic is loss-free: the original MLF type \ncan easily be recovered from the simpli.ed type. As an example, the following explicit MLF type .(\u00df = \n.a. a . a)(. =.a. a . a). [\u00df ] . [. ] can be presented according to this heuristic as: [.a. a . a] . \n[.a. a . a] The heuristic is used in the experimental Morrow compiler [7], which presents the above type \nand the type of runST in their sim\u00adpler form. Experience to the present day shows that it makes MLF much \neasier to work with, because the bounded quanti.cations that remain are the ones where the expressed \nsharing actually plays a crucial role in the type. Most simple functions, however, get the same types \nas they would in ML or Haskell. In the remainder of this article we will make use of this convention. \n  3. Quali.ed types Jones introduced the theory of quali.ed types [3] to generally describe a wide range \nof type system extensions, ranging from ad\u00adhoc overloading to record operations. The main reason to consider \nquali.ed types in conjunction with MLF is that it gives us a general framework to easily extend MLF with \nfeatures that are essential in practice. For example, the MLF type system is simply not feasible for \nlanguages such as Haskell if it does not support quali.ed types properly, because of the prominent position \nof type classes in the Haskell language. However, quali.ed types have several applications beyond type \nclasses, and the fact that MLF proves to be compatible with qual\u00adi.ed types says that MLF is a good underlying \nsystem for all lan\u00adguages that support any of these features. For instance, MLF forms the basis of the \ntype system for the experimental Morrow lan\u00adguage [7], which deals with records and employs MLF in the \nex\u00adpectation that it can use an ef.cient type-directed translation where predicates correspond to runtime \noffsets [1]. Furthermore, we show that adding quali.ed types to MLF is not just useful in its own right \nbut can also pro.t from impredicative types itself. This can lead to new applications of quali.ed types \nthat are not possible with current predicative type systems. 3.1 Predicates Quali.ed types extend the \ntype language with predicates. A quali\u00ad.ed type .p. s denotes those instances of s that satisfy the predi\u00adcate \np. For consistency with MLF we write predicates in the same way as bounds (instead of the more usual \np . s). The theory of quali.ed types makes just few assumptions of the language of pred\u00adicates p, and \nthere are many interesting instances. We discuss three of those extensions in this paper. One of the \nmost widely known is the type class system in Haskell.  3.2 Type classes A type class in Haskell denotes \na family of types (instances) on which a number of values (the member functions) are de.ned. Each predicate \nC t is an assertion that t is an instance of class C . For example, the class Eq denotes those types \nfor which equality (== ) is de.ned: (== ) :: .a (Eq a).a . a . Bool The predicate Eq a indicates that \nequality is not parametrically polymorphic, but only works for those types that are an instance of the \nEq class. In other words, type classes implement ad-hoc over\u00adloading where functions can behave differently \nfor different types. This normally requires some sort of global analysis. By adding predicates to the \ntypes, this analysis is provided automatically by the theory of quali.ed types: constraints are speci.ed \nlocally in the predicates of a type, and these predicates are propagated through expressions by the type \nsystem. Take for instance the following ex\u00adpression: (.a \u00df. if (a == \u00df) then \"yes\" else \"no\") :: .a (Eq \na).a . a . String  The equality predicate of (== ) is automatically propagated to the type of the entire \nexpression. Operationally, we can interpret pred\u00adicates as extra runtime parameters that give the runtime \nevidence that the predicate holds. For an Eq a predicate, this is would for example be a dictionary that \ncontains the implementation of the equality function for type a. It is not advisable to allow type schemes \nin type class predicates themselves as instance resolution would become much more com\u00adplicated, or even \nundecidable. However, the combination of MLF with type classes can still lead to new uses of overloading. \nThis is mostly because polymorphic functions become more useful. Take for example a plain MLF list that \ncontains the identity function: xs :: [.a. a . a] xs =[id ] This list is not very exciting as there \nsimply exist few functions that have such a polymorphic type (modulo unde.ned values, just the identity \nfunction). With a type class, we can assert that we can apply certain operations to a polymorphic type. \nHere is a more interesting example with a list of functions that work on any numeric type: let precise \n:: (.a (Num a).a . a) . Bool precise f =(f 1 . = round (f 0.9)) in map precise [id, (+1), negate, (*2)] \n This is also an example of how MLF scales with respect to pred\u00adicative systems: we can reuse the map \nabstraction on lists with polymorphic components without having to resort to packing and unpacking (cf. \nSection 2.4). 3.3 Implicit parameters Another instance of quali.ed types are implicit parameters [8]. \nA predicate ?x :: t asserts that the term can access an implicit argu\u00adment ?x with type t . This reduces \nthe burden on a programmer to pass this argument explicitly. A typical application for implicit pa\u00adrameters \nare options that can be used inside deeply nested functions without passing them explicitly through each \ncall site. For example, a pretty-printer may use the width of the screen deep inside the ren\u00adder function: \npretty :: .(?width :: Int). Doc . String pretty doc = ... if (i < ?width) ... The type signature of \npretty asserts that it expects an implicit argument width of type Int, and a normal argument of type \nDoc. Implicit arguments are bound using the with keyword: (pretty (text \"hi\") with ?width = 78) :: String \n An interesting advantage with respect to type classes is that we can bind an implicit argument of a \ncertain type to different values, while type classes only allow a single instance per type. Of course, \nwe may want to bind implicit arguments to polymor\u00adphic values. For example, we could pass monad operations \nas an implicit argument instead of using overloading, as is standard in Haskell. The function twice applies \nan implicit unit parameter to its argument: twice :: .m (?unit :: .\u00df. \u00df . m \u00df) a. a . m (m a) twice x \n=?unit (?unit x) Note that we use ?unit at two different types and that the type of ?unit must be polymorphic. \nAlas, the function twice will not type check in a predicative type system as the type of the implicit \nparameter predicate is instantiated to a type scheme. Here we see that the combination of an impredicative \ntype system like MLF and quali.ed types can lead to new applications of quali.ed types themselves. In \nthe next section, we give another example of this in the context of records. 3.4 Records Record operations \ncan also be elegantly typed with quali.ed types. For example, the has predicate (l :: t . r) asserts \nthat a record r contains a particular .eld l of type t . Using this predicate, we can give a type signature \nfor record selection: ( .l) :: .a r (l :: a . r). r . a The quali.ed type allows us to write functions \nthat work for any record containing a particular .eld. For example, the function len works for any record \ncontaining an x and y .eld of type Float. len :: .r (x :: Float . r)(y :: Float . r). r . Float len r \n= sqrt (r.x * r.x + r.y * r.y) Polymorphic predicates arise naturally with records. For example, the \ntype signature for monads m contains two polymorphic .elds: type Monad m = {unit :: .a. a . m a , bind \n:: .a \u00df. m a . (a . m \u00df) . m \u00df } We can now de.ne the function twice with an explicit monad record as \nits argument, which applies the unit .eld twice on its second argument: twice :: .m. Monad m . (.a. a \n. m (m a)) twice r x = r.unit (r.unit x) As before, twice uses the unit .eld polymorphically at two differ\u00adent \ntypes. The selection of unit from r gives rise to the predicate unit :: .a. a . m a . Monad m. This predicate \nobviously holds, but it is just not allowed in a predicative type system: the .eld type of the has predicate \nis instantiated here to a type scheme, and thus requires impredicative predicates. Record systems based \non lacks predicates [1] suffer from the same problem as the record type in the predicate is instantiated \nwith a record containing type schemes.  3.5 Quali.ed types and MLF Since MLF is already based on bounded \nquanti.cation, it is rela\u00adtively easy to extend the theory of MLF with quali.ed types. First of all, \nwe allow predicates to occur together with the bounds in a pre.x. Besides extending the equivalence relation \nwe just need to add two new instance rules for predicates: Q p (Q) s .p. s (Q) .p.s s The .rst rule states \nthat we make a type less polymorphic by adding a quali.er. The second rule goes in the other direction: \nif a predicate is entailed by the context, we can leave it out. Note that we generalize the entailment \nrelation of the theory of quali.ed types to work under a pre.x Q instead of a set of predicates.  4. \nEvidence translation Quali.ed types are usually implemented using a technique called evidence translation. \nDuring evidence translation, implicit infor\u00admation represented by the predicates is turned into explicit \nfunction arguments. The compiler automatically abstracts from and provides evidence where necessary. \nIn Section 4.1, we show how to use evidence translation for different sorts of quali.ed types. In Sec\u00adtion \n4.2, we discuss why a na\u00a8ive evidence translation for MLF fails. We then describe how to overcome this \nproblem in Section 4.3. This section contains the core idea of our translation, which is made equality \nand unequality functions for Int, because the Eq class in Haskell has precisely these two methods. Whenever \na let-de.ned value is overloaded, i.e., has a class constraint, its translation expects an additional \nargument, namely the dictionary. And whenever an overloaded function is called, the compiler supplies \nthe appropriate dictionary argument. For implicit parameters, the situation is simpler than for type \nclasses, as the evidence consists of only a single value, the implicit parameter itself. When dealing \nwith records, the evidence of a has constraint of the form (l :: t . r) can be the offset of label l \nin record r. In the following, we investigate how we can perform evidence translation in a system based \non MLF. 4.2 Evidence in MLF When adding quali.ed types to MLF, it is relatively straightforward to extend \nthe type rules in order to deal with predicates. However, higher rank and impredicativity makes it non-trivial \nto perform evidence translation. Consider the following four lists: xs1 = [] :: .a. [a] xs2 = const : \nxs1 :: [.a \u00df. a . \u00df . a] xs3 = min : xs2 :: [.a (Ord a).a . a . a] xs4 =(<): xs3 :: [Bool . Bool . Bool \n] where we assume: const :: .a \u00df. a . \u00df . a min :: .a (Ord a).a . a . a (<) :: .a (Ord a).a . a . Bool \nEach of the lists is obtained from the previous one by adding one additional element in the front, using \nthe cons -operation that is written (:) in Haskell. With each of the additions, the type of the list \nchanges. All the lists contain elements that are polymorphic. The types are thus different from the types \nthat Haskell would assign. In fact, the Haskell types of the four lists would be xs1 :: .a. [a] xs2 :: \n.a \u00df. [a . \u00df . a] xs3 :: .a (Ord a). [a . a . a] xs4 :: [Bool . Bool . Bool ] all instances of the MLF \ntypes given above. However, the Haskell types of x2 and x3 are strictly less general than their MLF counter\u00adparts. \nWith the MLF types, we can extract elements from the lists and use them polymorphically; with the Haskell \ntypes, we cannot. Consider a function let f ys =(head ys 23, head ys a b ) in f xs2 as an example of \na function which could not be typed (be it anno\u00adtated or not) in Haskell, because it really requires \nthe more general impredicative MLF type of xs2. The evidence translation of each of the lists in Haskell \nis easy, because evidence is only passed on the outside of a let-bound term. We can represent the lists \nat runtime as follows: precise in Section 5. * xs1 =.a. [] * a * * * 4.1 Examples of evidence translation \nxs2 =.a \u00df. const a\u00df : xs1 (a . \u00df . a) * * All three of the applications of quali.ed types discussed \nin the * * previous section can be translated in this fashion. With type classes, the class constraints \nare turned into dictio-Here, x * denotes the runtime term corresponding to the source term nary arguments. \nDictionaries are records containing all the meth-x. We are using System F as the runtime language in \nthis paper, ods of a class. For instance, a dictionary for Eq Int contains the because it is suf.ciently \npowerful to express the programs we are * ** * xs3 =... .(v3 :: (.a (Ord a) \u00b7 a . a . a) . .). v3 min \n* : xs2 . (.x. v3 (.a. .orda. x aa)) * * * xs4 =(<) * Bool ordBool : xs3 (Bool . Bool . Bool)(.x. x \nBool ordBool ) * Figure 2. Idea of the evidence translation for MLF with quali.ed types interested in, \nand it is fully typed; it is thus easy to see that the new transformation function. In effect, we thus \nsubstitute one trans\u00adevidence translation produces well-typed terms. To retain clarity, formation with \na new one, more speci.c than the .rst. however, we have omitted the type arguments of the (:) calls as \nApplying this idea, the runtime representations of the four lists well as the annotations for the dictionary \narguments, because they become as shown in Figure 2. Again, we have omitted irrelevant are uninteresting \nto the example at hand. annotations for (:) and dictionary arguments. To understand these This runtime \nrepresentation is, however, not adequate if we want representations, it is useful to look at the real \nMLF types of the to use the MLF types above, because in order to extract a value from lists not using \nthe presentation convention that we de.ned in such a list, we must .rst provide evidence .xing the type \nand the Section 2.5: dictionary. This way, xs2 cannot be used in function f above. xs1 :: .(a =.). [a] \n What we want is a representation of the lists where each element accepts the evidence, within the list. \nFor instance, xs2 :: .(. =.a \u00df. a . \u00df . a). [. ] xs3 :: .(. =.a (Ord a).a . a . a). [. ] * * xs2 = [.a \n\u00df. const a\u00df ] xs4 :: [Bool . Bool . Bool ] xs3 = [.a. .orda. min * a orda, .a. .orda. const aa] In xs3, \nboth elements now accept evidence for Ord a, but only min makes use of it. All list elements must have \nthe same runtime representation, because they are of the same type. But xs3 == min : xs2, so there must \nbe a way to construct * * A non-trivial .exible bound (. = s) is at runtime represented by an additional \nparameter of type s * . ., where s * is the runtime representation of s. This parameter can be used to \nadd, remove, or modify evidence deep down in the value, as is required by the MLF type system. In particular, \nfrom xs2 to xs3, we transform xs2 2! Similarly, we have to construct xs4, which as a * monomorphic list \nshould still have the same representation as given to xs4 we pass evidence for Ord Bool to xs3. These \ntwo steps * * from xs to accept evidence for Ord a which is ignored. And from xs3 xs 3 above, from xs \n 3. In this simple situation, we could map over xs2, parametrizing each element with an Ord a-dictionary \nthat is not used, and also map over xs3, providing evidence for Ord a by supplying the ordBool dictionary. \nBut in the general case, very complicated traversals of runtime values might be required, that are both \ndif.cult to get correct and inef.cient to perform. Interestingly, Peyton Jones and Shields have identi.ed \nthis problem in their discussion of design decisions, and argue that the necessity of such traversals \nmakes impredicative datatypes infeasible [11, Section 7.3]. 4.3 Evidence translation using transformation \nfunctions  * Wearenowgoingtopresentavariationofthestandardevidence translation that overcomes the \nproblem of traversing data structures in complicated ways at runtime. The variation presented here is \nthe basis of the evidence translation that is described formally in the context of MLF type inference \nin Section 5. Recall that the problem with the original approach is that the runtime representation of \nvalues is too static: if we learn more about the type of a polymorphic value, we may have to traverse \nthe data structure to .x the representation that has been chosen prema\u00adturely. Rather than to .x things \nafterwards, our idea is to build the necessary .exibility into the runtime representation of values from \nthe beginning. The core idea of our evidence translation for MLF is that polymorphic values, rather than \nbeing parametrized over a .xed amount of evidence, are parametrized over a transformation function. By \npassing a suitable transformation function to a poly\u00admorphic value, we can change the amount of evidence \nit expects. In particular, if we learn enough about a value that it becomes monomorphic, we can supply \na transformation function which pro\u00advides all evidence and thus removes all polymorphism. Often, how\u00adever, \nwe gain only partial information about a polymorphic type, such that two quanti.ed variables must be \nthe same. In such a case we have to chain transformation functions: we supply a transforma\u00adtion which \napplies the knowledge gained and subsequently calls a correspond to the instance rules that we have given \nfor quali.ed types in Section 3.5. Note that the list xs4 is no longer polymorphic, and does thus not \nexpect any further transformation function. In this simple example, the passing of transformation functions \nessentially amounts to mapping over the list multiple times, but in the general situation, we can apply \nexactly the same technique to perform complex transformations at low cost. Note that we are actually \nonly interpreting the concept of ev\u00adidence translation in a more rigorous way. The additional trans\u00adformation \nfunctions that are passed around are evidence on their own: evidence for the fact that quanti.ed types \nindeed respect their bounds! The actual translation that we introduce in the following section passes \na few more arguments for technical reasons, which will, however, all be instantiated to identity functions. \nA clever compiler can easily optimize the generated expressions statically to pass evidence and evidence \ntransformers only where they are actually needed, i.e., where bounded quanti.cations occur in the types. \n5. Type inference for MLF In this section, we present the type-inference algorithm taken from the MLF \npaper [6], augmented with a type-directed translation that produces a System-F term (also called runtime \nterm) from an MLF term. 5.1 Runtime types The difference between a term and its translation is that \nthe transla\u00adtion is fully type-annotated, and that evidence is passed explicitly. Since the evidence \nthat is required is dictated by the MLF types, it is not surprising that the types of the translated \nSystem-F terms are directly related to the types of the original MLF terms. Figure 3 shows how a System-F \ntype s * can be computed from an MLF type s. We call s * the runtime type of s. The de.nition is organized \nin such a way that the following property holds: . t * = t . . * = .a \u00b7 a . (.(a ov sa).s) * = s * if \na/. ftv(s) . (.(a ov sa).s) * = s * if nf(s)= a a . (.(a ov sa).s) * = s * [a . t ] if nf(sa)= t . (.(a \nov .).s) * = .a \u00b7 s * . a . a) . s * (.(a ov sa).s) * = .a \u00b7 (s * Figure 3. Translation of types THEOREM \n2. The runtime type of an MLF type s is the runtime type of its normal form2, i.e., s * =(nf(s)) * The \ntranslation of a monotype t is t itself. No quali.ed types can occur in monotypes, neither is there polymorphism, \nso we can safely reuse t, which is a valid System-F type. The type . is mapped to .a \u00b7 a. When dealing \nwith bounds, most cases are dictated by the de\u00adsired property given by Theorem 2. The next three cases \nare there\u00adfore directly based on the corresponding rules for normalization. A constraint for a variable \nthat does not occur in the rest of the type is irrelevant and can be dropped. No evidence is required, \nbecause it would not be used anyway. If we have a type .(a ov sa).s where nf(s)= a, then the type is \nequivalent to sa, and we can use the runtime representation of sa. Each monotype t in MLF has the property \nthat only t itself is an instance of t . Since we already argued that there is no need for evidence in \nrelation to monotypes, we can inline a constraint where the bound is equivalent to a monotype. The .nal \ntwo cases deal with non-trivial bounds. In the case of an unbounded quanti.cation, we introduce a quanti.cation \nin System F as well. Because any type argument will do, no further information is required. This is different \nin the .nal case: . = .a \u00b7 (s * (.(a ov sa).s) * a . a) . s * It shows that any bound that does not match \nany of the other cases is represented using a function argument. The argument provides evidence for the \nbound: for a .exible bound, it demonstrates that a is indeed an instance of sa by giving a transformation \nfrom any s * a value into an a value; for a rigid bound, the argument demonstrates that a is equivalent \nto sa. For the type inference algorithm to be correct, it must supply well-behaved functions for evidence \nparameters. The transforma\u00adtion functions may provide, remove, or reorder evidence, but not add any computation \nbeyond that. As an example of the type trans\u00adlation, consider the type of xs2 from Section 4: .(. =.a \n\u00df. a . \u00df . a). [. ] Let s. = .a \u00df. a . \u00df . a. Then .(. = s. ). [. ] matches the last case in the de.nition \nof () *, hence its translation is .. \u00b7 (s. * . .) . [. ] * The type [. ] is a monotype, its translation \nis thus also [. ]. It remains to translate s. . The quanti.cations on a and \u00df are un\u00adbounded, and abbreviations \nfor (a =.) and (\u00df =.). The next 2 Recall that Figure 1 describes how to compute the normal form of an \nMLF type. . app(t)= . app(.)= (.a \u00b7 a) . app(.(a ov sa).s)= app(s) if a/. ftv(s) . app(.(a ov sa).s)= \napp(sa) if nf(s)= a . app(.(a ov sa).s)= app(s) if nf(sa)= t . app(.(a ov .).s)= app(s)[ a] . app(.(a \nov sa).s)= app(s)[ a v ] . abs(t )= . abs(.) =.a. abs(.(a ov sa).s) . = let a . sa* ; v . I a in abs(s) \nif a/. ftv(s) . = let a . s * a; v . I a in (abs(sa)[abs(s)]) if nf(s)= a . = let a . s * if nf(sa)= \nt a; v . I a in abs(s) . abs(.(a ov .).s) =.a. let v . .x. x a in abs(s) . abs(.(a ov sa).s) a . a). \nabs(s) =.a. .(v : s * Figure 4. Type-directed application and abstraction to last case matches twice, \nhence s. * = .a\u00df \u00b7 a . \u00df . a, and consequently .. \u00b7 ((.a\u00df \u00b7 a . \u00df . a) . .) . [. ] If we return to the \nruntime representation given for x2 in Figure 2, namely ....(v2 :: (.a\u00df \u00b7 a . \u00df . a) . .). (v2 const \n* : xs1 * .) we see that it indeed has precisely this System-F type. In the term translation we refer \nto runtime evidence by name, like the v2 in the above example. In the translation algorithm we therefore \nmake use of labeled pre.xes where each bound is labeled. The runtime evidence for a bound (a ov s) is \nnow de.ned by the name v with type (s * . a). Of course, the labels are assigned internally by the compiler \nand are never exposed to the user. Fur\u00adthermore, just like the names of quanti.ers can be alpha-converted \nwithin a polytype s, the labels associated with the bounds of the quanti.ers can be converted as well, \nand we assume that this is im\u00adplicitly done in such a way that all bound variables and all labels in \na pre.x are always distinct. A slight complication to the translation algorithm is that we do not pass \nevidence for trivial bounds that are removed by normal\u00adizing the type. The type inference algorithm therefore \nmakes use of two helper functions app and abs, given in Figure 4, that sup\u00adply evidence parameters or \nabstract from evidence. Both functions turn an MLF type into a context that can be .lled with a proper \nSystem-F term. The function app supplies evidence arguments for a term of type s. It is structured exactly \nlike the cases of type translation and it behaves uniformly over normalized types: app(s)= app(nf(s)) \nFurthermore, we can check that it always supplies type-correct evidence for non-trivial bounds: * ** \ne :: (.Q.t ) * . app(.Q.t)[e ] :: t The interesting cases for app are again the last two cases. For an \nunconstrained bound (a ov .) we pass the type parameter a. This is the same as in a standard translation \nfrom Hindley-Milner types to System F. The last case supplies evidence for a non-trivial bound (a ov \ns). As signi.ed by the label, the evidence is bound in the environment by the name v, and we simply pass \nthe type parameter a and the evidence v. The abstraction function abs abstracts from evidence for non\u00adtrivial \nbounds, and binds the names and types of all trivial bounds. Again, this function is structured exactly \nlike type translation and app. However, it does not behave uniformly over normalized types since it explicitly \nbinds the names of non-trivial bounds that are eliminated during normalization. As we will see in the \nuni.cation algorithm, the function abs is always used under a certain pre.x. If a term e has a translation \nterm e * of type t * under a pre.x Q, then abs can lift it to the type (.Q.t) *. More formally: abs(.Q.t)[e \n* ] :: (.Q.t) * The abstraction algorithm needs to bind all evidence names and types in the pre.x. Trivial \nbounds can be satis.ed in only one way, we therefore substitute their labels and type arguments. It makes \nno sense to abstract over trivial evidence, we rather provide it immediately. Non-trivial bounds, however, \nare lambda bound, and have to be supplied later. The .rst two cases on monomorphic types and . have nothing \nto abstract. The next three cases deal with trivial bounds. The .rst of these three deals with a dead \nbinding a ./ftv(s). It is safe to treat a as sa, and to bind the evidence v to an identity transformation. \nWe use the notation let v . e in x to denote the substitution of v by e in the System-F term x. The next \ncase is a direct substitution where a can be bound to sa itself, and where v is again an identity transformation. \nThe last trivial bound concerns monomorphic types where the evidence can also be bound to an identity \nsince t * = t. The .nal two cases of abstraction handle non-trivial bounds where the evidence is passed \nat runtime. The unconstrained bound (a ov .) just abstracts over the type argument a the runtime evidence \nv is bound to a function that passes a as any type is trivially an instance of .a \u00b7 a. As apparent from \nthe corresponding rule in app, the bound (a ov sa) gets full evidence passed: both the type argument \na and the runtime evidence v are lambda bound, where v is bound to a function that transforms a type \ns * to its a instantiation type a. 5.2 Type inference We are now in the position to present the type \ninference algorithm for MLF, extended with type-directed translation, as shown in Figure 5. The expression \nQ | G e :(Q',s) -e * infers for a given expression e, under a pre.x Q and type environment G a type s \nthat holds under pre.x Q'. Furthermore, it derives a translated System-F term e *. Note that the algorithm \nis exactly the same as the standard type inference algorithm of MLF modulo the translation terms. THEOREM \n3. The type inference algorithm in Figure 5 derives a well-typed translation term: Q | G e :(Q',s) -e \n* . e * :: s * This can be proved by induction on the structure of types. Usually, Hindley-Milner based \ntype inference algorithms infer a type under a certain substitution. With MLF, the pre.x subsumes the \nrole of the substitution. In the pre.x, type variables can be bound to monomorphic and polymorphic types. \nThe type environ\u00adment G is standard and maps term variables x to polymorphic types s. The environment \nG is extended with a variable x as G, x :: s, x : s . G (inf-var) Q | G x :(Q,s) -x Q | G e1 :(Q1,s1) \n-e1 * Q1 | (G, x : s1) e2 :(Q2,s2) -e2 * (inf-let) Q | G(let x = e1 in e2) :(Q2,s2) \u00ad * ** (.(x : s1 \n). e2 ) e1 fresh(v, w, u, a, \u00df, .) Q | G e1 :(Q1,s1) -e1 * * ' Q1 | G e2 :(Q2,s2) -e2 Q=(Q2,a =v s1,\u00df \n=w s2,. =u .) ' (Q) a ~ \u00df . . :(Q3, L) (Q4, Q5)= Q3 . dom(Q) s = .Q5.. * ** e = abs(s)[L in (ve 1 )(we \n2 )] (inf-app) * Q | G(e1 e2) :(Q4,s) -e fresh(v, w, a, \u00df) (Q,a =v .) | (G, x : a) e :(Q1,s1) -e * (Q2, \nQ3)= Q1 . dom(Q) s = .(Q3,\u00df =w s1).a . \u00df f * = abs(s)[.(x : a). we * ] (inf-lam) * Q | G(.x. e) :(Q2,s) \n-f Figure 5. Type inference where the new binding of x shadows a previous binding of x in G. Initially, \nboth the pre.x Q and the environment G are empty. The rule (inf-var) infers the type of a variable x \nby simply look\u00ading up the type in the environment. The translated term is just x and the pre.x is unchanged. \nThe rule (inf-let) is also straightforward: it infers the type for the let bound expression e1 and then \nfor the body e2 with x bound to the inferred type of e1. The translated term is phrased as lambda expression \nsince the System-F language has no let bindings. The rule for let bindings is much more involved in Hindley-Milner \nsystems as it is the one place where generalization to polymorphic types takes place. In contrast, in \nMLF generaliza\u00adtion is performed as part of the rules for application and lambda, hence no special actions \nare necessary for let bindings. The rule for application (inf-app) .rst infers the types for the function \ne1 and the argument e2. After that, it extends the pre.x with fresh bindings for those types and uni.es \nthem using the uni.cation algorithm shown in Figure 7. The uni.cation algorithm is the core of MLF and \nwe discuss this in depth in the next section. For now, it is suf.cient to know that the expression (Q) \nt1 ~ t2 : (Q', L) uni.es two monomorphic types t1 and t2 under pre.x Q, returning a new pre.x Q' such \nthat (Q') t1 = t2. It also returns an evidence substitution L which is explained in the next paragraph. \nSince the MLF inference algorithm infers polymorphic types, it must generalize the result type .. Generalization \nworks by splitting the pre.x resulting from uni.cation (Q3) under the domain of original pre.x Q in the \npre.xes (Q4, Q5). The generalized type s of the application is simply (.Q5..) under the pre.x Q4. See \nAppendix A for a de.nition of the split function. The translation of the application terms is more involved. \nFirst of all, we need to use the translated term e1 * and e2 * at their in\u00adstantiated types, namely a \nand \u00df. Fortunately, as apparent from the bounds in Q', the runtime evidence for the conversion from s1 \n* to a is given by v, and w gives the evidence for s2 * . \u00df. A well\u00adtyped translated application is now \ngiven by (ve1 * )(we2 * ). Of course, we must be careful to ensure that the names v and w are actually \nbound somewhere. As we saw in the previous section, the abstraction function binds all evidence of a \ncertain s. In our case, abs(s)[(ve1 * )(we2 * )] binds all evidence in Q5. Since we work (Q1, (Q3,a ov \ns0, Q4)) = Q . ftv(s) (ov =(;)) . ((Q) s0 Es) fresh(w) -? L ' = let v . w . f in L (update) . (Q, L) \n< (a o s)f = ((Q1Q3,a ow s, Q4), L ' ) ((Q1,a1 ov1 s, Q2,a2 ov2 s, Q3)= Q . (Q1,a2 ov2 s, Q2,a1 ov1 s, \nQ3)= Q ) Q ' =(Q1,a1 ov1 s, a2 = w a1, Q2Q3) fresh(w) (merge) .' (Q, L) < (a1 . a2)=(Q , let v2 . w \n. v1 in L) (uni-var)(Q) a ~ a :(Q,E) (Qi-1) ti ~ ti ' :(Qi, Li) for i . 1..n L ' = Ln in ... in L1 (uni-con) \n(Q0) g t1 ...tn ~ g t1 ' ...t n ' :(Qn, L ' ) (a ov s) . Q s .V (Q) t ~ nf(s) :(Q ' , L) (uni-mvar-l) \n(Q) t ~ a :(Q ' , L) Figure 6. Update and merge under pre.x Q4 all evidence in Q4 and Q5, i.e., Q3 is \nbound. How\u00adever, we took v and w from Q ' and we can not be sure that Q3 is equal to Q '. That is where \nthe evidence substitution L resulting from uni.cation comes into play: the evidence substitution L is \na .nite map (written as a sequence of let-bindings) from labels to actual conversion functions that de.nes \nall evidence in Q ' in terms of evidence in Q3. By applying L to the translated application, we get a \nwell-formed System-F term: abs(s)[L in (ve 1 * )(we 2 * )]. The inference rule for lambda expression \n(inf-lam) infers a type for the body e under the assumption that argument x has type a, where the bound \non a is unconstrained (a =v .). Again, it generalizes the result type by splitting the inferred pre.x \nof the body Q1 under the original pre.x Q in the pre.xes (Q2, Q3). The inferred type of the lambda expression \ns is now .(Q3,\u00df =w s1).a . \u00df. This nicely shows that the result of the lambda expression can be polymorphic \nitself. As a practical example, the inferred type of the const function in MLF is: (.x..y. x) :: .a. \na . (.\u00df. \u00df . a) The translated term for a lambda expression uses the evidence w to instantiate the term \ne * of type s1 * to \u00df, resulting in the term (.(x : a). we * ) ::(a . \u00df). The abstraction function on \ns binds all evidence in (Q3,\u00df =w s1) and returns a well-formed System-F term of type s *, namely abs(s)[.(x \n: a). we * ]. 5.3 Update and merge Before we can describe the uni.cation algorithm, we de.ne two helper \nfunctions (update) and (merge) shown in Figure 6. These functions are used by uni.cation and are the \nonly functions that change the uni.cation pre.x. A consequence is that these are the only functions that \nchange the evidence substitution L. Note that up to the evidence substitution, the (update) and (merge) \nalgorithms are exactly the same as the standard MLF algorithms. The expression (Q, L) < (a o s)f updates \nthe pre.x Q and evidence substitution L returning a pair (Q ' , L ' ) where Q ' is the updated pre.x, \nand where L ' is the updated evidence substitution. As de.ned in Figure 6, the update operation updates \nthe bound (a ov s0) . Q with the bound (a ow s). It also prevents the update of rigid bindings with a \nless polymorphic type through the abstraction check algorithm (Q) s0 Es, which is described in -? the \nthesis of Le Botlan [5]. Since the bound of v disappears from the pre.x, we need to bind it in the evidence \nsubstitution L. The evidence term for v must have type s0 * . a. Since the newly bound evidence w has \ntype s * . a, we just need a runtime function of type s0 * . s * to be able to bind the evidence v in \nterms of the new pre.x. This function f is passed with the update expression as a subscript of the new \nbound and will be constructed during uni.cation. Therefore, we can substitute all occurrences of evidence \nv by the term w . f . The merge expression (Q, L) < (a1 . a2) merges the equal bounds of two type variables \na1 and a2 in the pre.x Q and (a ov s) . Q s .V (Q) nf(s) ~ t :(Q ' , L) (uni-mvar-r) (Q) a ~ t :(Q ' \n, L) (a ov s) . Q t/.A s/.V a/. dom(Q /t ) (Q) s ~m t :(Q0, L0, f ) (Q1, L1)=(Q0, L0) < (a o t)f (uni-mono-r) \n(Q) a ~ t :(Q1, L1) (a ov s) . Q t/.A s/.V a/. dom(Q /t ) (Q) s ~m t :(Q0, L0, f ) (Q1, L1)=(Q0, L0) \n< (a o t)f (uni-mono-l) (Q) t ~ a :(Q1, L1) (a1 ov1 s1) . Q (a2 ov2 s2) . Q a1 =.a2 s1 /s2 / .V .V a1 \n./dom(Q /s2) a2 ./dom(Q /s1) (Q) s1 ~p s2 :(Q0,s0, L0, f1, f2) (Q1, L1)=(Q0, L0) < (a1 o s0)f1 < (a2 \no s0)f2 < (a1 . a2) (uni-poly) (Q) a1 ~ a2 :(Q1, L1) Figure 7. Monomorphic uni.cation (mono-bot)(Q) .~m \nt :(Q, E,.x. x t * ) .Q1.t1 = s1 (QQ1) t1 ~ t :(Q2, L) (Q3, Q4)= Q2 . dom(Q) s = .Q4.t fs1 *.t* = .es* \n. abs(s)[L in app(s1)[e]] (mono-poly) 1 (Q) s1 ~m t :(Q3, L, f ) Figure 8. Mono-poly uni.cation (poly-bot-l)(Q) \n.~p s :(Q,s, E,.x. x s * , I s * ) (poly-bot-r)(Q) s ~p . :(Q, s, E, I s * ,.x. x s * ) .Q1.t1 = s1 .Q2.t2 \n= s2 disjoint(dom(Q), dom(Q1), dom(Q2)) (QQ1Q2) t1 ~ t2 :(Q0, L) (Q3, Q4)= Q0 . dom(Q) s = .Q4.t1 fs1 \n*.s* = .es* . abs(s)[L in app(s1)[e]] 1 gs2 *.s* = .es * . abs(s)[L in app(s2)[e]](poly-poly) 2 (Q) \ns1 ~p s2 :(Q3, s, L, f , g) Figure 9. Poly uni.cation evidence substitution L, returning an updated pre.x \nand evidence ' , L ' substitution as a pair (Q ). Since the evidence v2 disappears, we rede.ne it in \nterms of the new evidence w and v1. Since the evidence w transforms a1 . a2 and v1 transforms s * . a1, \nwe can substitute all occurrences of the evidence v2 by the term w .v1. 5.4 Uni.cation The algorithm \nfor uni.cation (~) is de.ned in Figure 7 and makes use of the helper functions for mono-poly uni.cation \n(~m) de.ned in Figure 8 and poly uni.cation (~p) de.ned in Figure 9. Again, the uni.cation algorithm \nis exactly like that of MLF modulo the evidence translation. Also, we have specialized the poly uni.cation \nwhere one argument is a mono type to the mono-poly uni.cation for ease of presentation. As stated before, \nthe expression (Q) t1 ~ t2 :(Q ' , L) uni\u00ad.es two monomorphic types t1 and t2 under pre.x Q, returning \na new pre.x Q ' such that t1 and t2 are equivalent under Q ', i.e., (Q ' ) t1 = t2. The evidence substitution \nL binds all evidence of Q in terms of evidence in Q ' . The uni.cation essentially follows the structure \nof standard .rst-order uni.cation, except that compu\u00adtation of the uni.er is replaced by the computation \nof a unifying pre.x. Furthermore, we need to do extra work for variables bound to polymorphic types. \nDuring uni.cation, we frequently have to perform a kind of occurs check , using the notation a ./dom(Q \n/s), where dom(Q /s) is de.ned in Appendix A. The .rst rule states that equal variables unify with an \nunchanged pre.x and an empty evidence substitution. Constructors unify if all their arguments unify. \nThe rules (uni-mvar-l) and (uni-mvar-r) unify bounds that are variables themselves. The next two rules, \n(uni-mono-l) and (uni-mono-r) unify monomorphic types with a possibly polymorphic bound using mono-poly \nuni.cation and up\u00addate the bound of a to the monomorphic type t. The last rule uni\u00ad.es two polymorphic \nbounds using poly uni.cation, updating and merging the bounds of a1 and a2 with the possibly polymorphic \ntype s that is a common instance of their bounds. The poly uni.cation (~p) algorithm is de.ned in Figure \n9. The expression (Q) s1 ~p s2 :(Q ' , s, L, f , g) uni.es two polymorphic types s1 and s2 under pre.x \nQ. The algorithm as\u00adsumes that s1 and s2 are in constructed form. The constructed form is a weak form \nof a normalization that just reveals the struc\u00adture of polymorphic type [6], given in Appendix A. Poly \nuni.ca\u00adtion returns a new pre.x Q ' under which the type s is a com\u00admon instance of s1 and s2. Furthermore, \npoly uni.cation returns an evidence substitution and two translations functions: f of type s1 * . s *, \nand g of type s2 * . s *. The latter functions are used by the (uni-poly) rule to update the bounds. \nThe .rst two rules (poly-bot-l) and (poly-bot-r) unify with unconstrained bounds and return trivial transformations. \nThings become more interesting in rule (poly-poly) where two non-trivial polymorphic types are uni\u00ad.ed. \nThe algorithm is exactly like that of MLF: .rst it instantiates both types and than generalizes over \nthe result. The interesting part is formed by the construction of the evidence transformers f and g. \nThe transformer f must have the runtime type s1 * . s *, and thus takes a runtime term e of type s1 *. \nThe term is instantiated to type t1 by using the app(s1) function. After binding the evidence under Q0 \nusing the evidence substitution L resulting from the mono uni.\u00adcation, we can use abstraction over s \nto transform to a runtime term of type s *, namely fs1 *.s* = .es* . abs(s)[L in app(s1)[e]]. 1 The construction \nof g is equivalent. Note that we rely essentially here on the law that app(s)= app(nf(s)), otherwise \nwe could not work on the constructed forms required by the poly uni.cation. The mono-poly uni.cation \nis basically just a specialization of poly uni.cation where one argument is a monomorphic type. Just \n. (.(pv ).s) * = p * . s * . app(.(pv ).s)= app(s)[ v ] . abs(.(pv ).s)= .(v : p * ). abs(s) Figure 10. \nQuali.ed type translation, application, and abstraction . simplify(Q,t ) =(t, E) . simplify(Q, .)=(.,E) \nQ p -e * (s ' , L)= simplify(Q,s) . simplify(Q, .(pv ).s)=(s ' , let v . e * in L) (s ' , L)= simplify(Q,s) \n' .' simplify(Q, .Q .s)=(.Q .s ' , L) Figure 11. Simpli.cation like poly uni.cation, it expects its arguments \nin constructed form. Instead of two functions that transform to a common instantiation, mono-poly uni.cation \njust returns a single evidence transformer f of type s * . t *, which is the main reason for creating \na specialized instance of poly uni.cation. 6. Adding predicates With all the evidence machinery in place, \nwe can now add evidence translation for quali.ed types. Since we store predicates as part of the pre.x, \nwe only need to extend the de.nitions of type transla\u00adtion () *, evidence application app, and evidence \nabstraction abs as shown in Figure 10. We assume here that each language of pred\u00adicates comes with a \nsuitable translation function from predicates p to runtime evidence of type p * . Picking up the examples \nfrom Section 4.1, a type class C could be represented by a proper runtime dictionary of type C * that \ncontains the member functions of C . An implicit argument predicate (?x :: s) is represented by a function \nof the same type: (?x :: s) * = s *. As a .nal example, a has predicate (l :: a . r) for records could \nbe represented by the runtime offset of l in r, in other words, (l :: a . r) * = Int. There is one other \nplace where we have to change the uni.\u00adcation algorithm. In the (update) function (Figure 6), the abstrac\u00adtion \ncheck veri.es if the new bound is polymorphic enough. The abstraction check algorithm needs to take predicates \ninto account, namely, it must test if the two type schemes contain exactly the same predicates. Fortunately, \npredicates come with an entailment relation ( ) that make this easy to verify. Since the type schemes \nin the abstraction check are already in an instance relation, we can consider two predicate sets equal \nwhen each predicate set entails the other. Normally, an implementation of quali.ed types performs sim\u00adpli.cation \nwhere constant predicates are resolved to known evi\u00addence. For example, once a predicate Num a is instantiated \nto Num Int, we can eliminate the predicate and supply constant evi\u00addence at runtime. We assume that the \nlanguage of predicates comes with an entailment relation that derives the evidence e of a predi\u00adcate \np under a pre.x Q: Q p -e For example, the expression Q Num Int -numInt asserts that we can derive evidence \nnumInt that Num Int holds under some pre.x Q. The derived evidence is in this case the runtime dictionary \nof the Num class for Int. Of course, the entailment relation should only derive well-typed evidence terms: \nQ p -e . e :: p * Since the entailment works under a pre.x instead of a set of pred\u00adicates, this also \nallows for a satisfactory treatment of improve\u00adment [4], but a full discussion is beyond the scope of \nthis paper. Using the entailment relation, we can de.ne a simpli.ca\u00adtion algorithm for types, as shown \nin Figure 11. The expression simplify(Q,s) simpli.es s under pre.x Q. It returns a pair of a simpli.ed \ntype s ' and an evidence substitution L. The evidence substitution will bind the evidence of predicates \nthat are resolved during simpli.cation. We assume that the argument to simplify is in normal form. The \n.rst two cases deal with mono types and .. The next case uses the entailment relation to simplify a resolved \npredicate. The evidence substitution is extended with the derived evidence for the predicate p. Since \nwe work on normal forms, the .nal case simply ignores a bound and leaves the type as it is. The type \ninference algorithm is now extended with the rule (simplify) that can be applied at any time to simplify \nthe type of an expression. Q | G e :(Q ' ,s1) -e * (s2, L)= simplify(Q ' , nf(s1)) e2 * = abs(s2)[L in \napp(s1)[e * ]] (simplify) Q | G e :(Q ' ,s2) -e2 * We use the abstraction and application algorithm \nto construct a well-typed runtime term with the simpli.ed type, where the ev\u00adidence substitution resulting \nfrom simpli.cation binds resolved predicates. Since we call simplify with the normalized form of s1, \nsimpli.cation can also speed up type inference without predicates as the abstraction and application \nfunctions can deal with simpler types. 7. Conclusion In this article, we have shown how to combine the \nMLF type system with quali.ed types, and given an evidence translation to System F that demonstrates \nhow to implement such a system ef.ciently. MLF with its impredicative .rst-class polymorphism has a number \nof advantages over comparable systems, and it seems so far that it scales well to programming languages \nwith other type system extensions. In the future, we plan to analyze interactions of MLF with other features \nsuch as existential types. We have given examples of MLF usage and demonstrated that it is convenient \nto use in practice, and that the added complexity can be kept hidden from the user most of the time. \nWe would like to see MLF more widely used. In particular, we believe that MLF with quali.ed types can \nbe seriously considered as an underlying type system for the Haskell programming language. Acknowledgements \nWe are indebted to Didier Le Botlan for his extensive and constructive comments on a draft of this paper. \nWe also thank the four anonymous referees for numerous comments and suggestions. References [1] B. R. \nGaster and M. P. Jones. A polymorphic type system for extensible records and variants. Technical Report \nNOTTCS-TR-96-3, Dept. of Computer Science, University of Nottingham, 1996. [2] J. Hindley. The principal \ntype scheme of an object in combinatory logic. Transactions of the American Mathematical Society, 146:29 \n60, Dec. 1969. [3] M. P. Jones. A theory of quali.ed types. In 4th. European Symposium on Programming \n(ESOP 92), volume 582 of Lecture Notes in Computer Science, pages 287 306. Springer-Verlag, Feb. 1992. \n[4] M. P. Jones. Simplifying and improving quali.ed types. Technical Report YALEU/DCS/RR-1040, Dept. \nof Computer Science, Yale University, 1994. [5] D. Le Botlan. MLF: Une extension de ML avec polymorphisme \nde second ordre et instanciation implicite. PhD thesis, INRIA Rocquencourt, May 2004. Available in English. \n[6] D. Le Botlan and D. R\u00b4emy. MLF: raising ML to the power of system F. In Proceedings of the eighth \nACM SIGPLAN international conference on Functional programming, pages 27 38. ACM Press, 2003. [7] D. \nLeijen. Morrow: a row-oriented programming language. http://www.cs.uu.nl/~daan/morrow.html, July 2004. \n [8] J. R. Lewis, M. B. Shields, E. Meijer, and J. Launchbury. Implicit parameters: Dynamic scoping with \nstatic types. In T. W. Reps, editor, Proceedings of the 27th Annual ACM SIGPLAN-SIGACT Symposium on Principles \nof Programming Languages, Boston, Massachusetts, pages 108 118, 2000. [9] R. Milner, M. Tofte, R. Harper, \nand D. MacQueen. The De.nition of Standard ML (Revised). The MIT Press, 1997. [10] S. Peyton Jones, editor. \nHaskell 98 Language and Libraries: The Revised Report. Cambridge University Press, 2003. [11] S. Peyton-Jones \nand M. Shields. Practical type inference for arbitrary\u00adrank types. Submitted to the Journal of Functional \nProgramming (JFP), 2004. [12] C. Shan. Sexy types in action. ACM SIGPLAN Notices, 39(5):15 22, 2004. \nA. Supplemental algorithms Useful domain: . dom(Q /s)= dom(Q / ftv(s)) a . dom(Q /\u00df1 ...\u00dfn ) ..Q =(Q1,a \no s, Q2) . a . ftv(.Q2.\u00df1 . \u00b7 \u00b7\u00b7 . \u00dfn . ()) Constructed forms: . cf(t )= t . cf(.)= . . cf(.(a o sa).s)= \ncf(sa) if nf(s)= a . cf(.(a o sa).s)= .(a o sa). cf(s) Free type variables: . ftv(a)= {a} . ftv(g t1 \n...tn)= ftv(t1) .\u00b7 \u00b7\u00b7. ftv(tn) . ftv(.)= \u00d8 . ftv(.(a o sa).s)=(ftv(s) -{a}) . ftv(sa) if a . ftv(s) . \nftv(.(a o sa).s)= ftv(s) if a/. ftv(s) Splitting a pre.x. The split algorithm takes a pre.x Q and a set \nof type variables a, and splits Q in two parts (Q1, Q2) such that the domain of Q1 is the domain of Q \nrelevant to a. . () . a = ((), ()) a . a (Q1, Q2)= Q . (a - a) . ftv(s) . (Q,a o s) . a = ((Q1,a o s), \nQ2) a/. a (Q1, Q2)= Q . a . (Q,a o s) . a =(Q1, (Q2,a o s))   \n\t\t\t", "proc_id": "1086365", "abstract": "MLF is a type system that extends a functional language with impredicative rank-<i>n</i> polymorphism. Type inference remains possible and only in some clearly defined situations, a local type annotation is required. Qualified types are a general concept that can accommodate a wide range of type systems extension, for example, type classes in Haskell. We show how the theory of qualified types can be used seamlessly with the higher-ranked impredicative polymorphism of MLF, and give a solution to the non-trivial problem of evidence translation in the presence of impredicative datatypes.", "authors": [{"name": "Daan Leijen", "author_profile_id": "81100572466", "affiliation": "Utrecht University, Utrecht, The Netherlands", "person_id": "PP39049120", "email_address": "", "orcid_id": ""}, {"name": "Andres L&#246;h", "author_profile_id": "81100364350", "affiliation": "Utrecht University, Utrecht, The Netherlands", "person_id": "PP17010026", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1086365.1086385", "year": "2005", "article_id": "1086385", "conference": "ICFP", "title": "Qualified types for MLF", "url": "http://dl.acm.org/citation.cfm?id=1086385"}