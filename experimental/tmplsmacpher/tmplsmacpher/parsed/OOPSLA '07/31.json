{"article_publication_date": "10-21-2007", "fulltext": "\n MOP: An Ef.cient and Generic Runtime Veri.cation Framework * Feng Chen Grigore Ros\u00b8u University of \nIllinois at Urbana-Champaign {fengchen,grosu}@cs.uiuc.edu Abstract Monitoring-Oriented Programming (MOP1) \n[21, 18, 22, 19] is a formal framework for software development and analy\u00adsis, in which the developer \nspeci.es desired properties using de.nable speci.cation formalisms, along with code to ex\u00adecute when \nproperties are violated or validated. The MOP framework automatically generates monitors from the spec\u00adi.ed \nproperties and then integrates them together with the user-de.ned code into the original system. The \nprevious design of MOP only allowed speci.cations without parameters, so it could not be used to state \nand mon\u00aditor safety properties referring to two or more related ob\u00adjects. In this paper we propose a \nparametric speci.cation\u00adformalism-independent extension of MOP, together with an implementation of JavaMOP \nthat supports parameters. In our current implementation, parametric speci.cations are translated into \nAspectJ code and then weaved into the appli\u00adcation using off-the-shelf AspectJ compilers; hence, MOP \nspeci.cations can be seen as formal or logical aspects. Our JavaMOP implementation was extensively evaluated \non two benchmarks, Dacapo [14] and Tracematches [8], showing that runtime veri.cation in general and \nMOP in particular are feasible. In some of the examples, millions of monitor instances are generated, \neach observing a set of related objects. To keep the runtime overhead of monitor\u00ading and event observation \nlow, we devised and implemented a decentralized indexing optimization. Less than 8% of the experiments \nshowed more than 10% runtime overhead; in most cases our tool generates monitoring code as ef.cient as \nthe hand-optimized code. Despite its genericity, JavaMOP is empirically shown to be more ef.cient than \nruntime veri.ca\u00adtion systems specialized and optimized for particular speci\u00ad * This material is based \nupon work supported by the National Science Foun\u00addation under Grant No. 0448501 and Grant No. 0509321. \nAny opinions, .ndings, and conclusions or recommendations expressed in this material are those of the \nauthor(s) and do not necessarily re.ect the views of the National Science Foundation. 1 Not to be confused \nwith meta-object protocol [34]. Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4eal, Qu\u00b4ebec, Canada. Copyright \nc . 2007 ACM 978-1-59593-786-5/07/0010. . . $5.00. .cation formalisms. Many property violations were \ndetected during our experiments; some of them are benign, others in\u00addicate defects in programs. Many \nof these are subtle and hard to .nd by ordinary testing. Categories and Subject Descriptors D.2.4 [SOFTWARE \nENGINEERING]: Software/Program Veri.cation General Terms Languages, Veri.cation Keywords runtime veri.cation, \naspect-oriented program\u00adming, monitoring-oriented programming 1. Introduction Runtime veri.cation [29, \n41, 11] aims at combining test\u00ading with formal methods in a mutually bene.cial way. The idea underlying \nruntime veri.cation is that system require\u00adments speci.cations, typically formal and referring to tem\u00adporal \nbehaviors and histories of events or actions, are rig\u00adorously checked at runtime against the current \nexecution of the program, rather than statically against all hypothetical executions. If used for bug \ndetection, runtime veri.cation gives a rigorous means to state and test complex temporal requirements, \nand is particularly appealing when combined with test case generation [5] or with steering of programs \n[35]. A large number of runtime veri.cation techniques, al\u00adgorithms, formalisms, and tools such as Tracematches \n[2], PQL [38], PTQL [27], MOP [19], Hawk/Eraser [23], MAC [35], PaX [28], etc., have been and are still \nbeing developed, showing that runtime veri.cation is increasingly adopted not only by formal methods \ncommunities, but also by program\u00adming language designers and software engineers. We present a parametric \nextension together with a ma\u00adture, optimized and thoroughly evaluated implementation of monitoring-oriented \nprogramming (MOP). MOP was .rst proposed in 2003 [21] as a software development and anal\u00adysis framework \nbased on runtime veri.cation intuitions and techniques. It was further described and extended in [18, \n22, 19], but, up to now, it was not able to handle parameters in speci.cations, and was not shown, through \nlarge-scale per\u00adformance tests measuring run-time overhead, to be feasible in practice. An implementation \nof JavaMOP was carried out to support these, together with decentralized monitor index\u00ading algorithms \nfor reducing the runtime overhead. As shown in this paper, MOP is expressive, generic, and ef.cient. \nMOP logic-plugins encapsulate monitor synthesis algorithms for logics of interest; these allow users \ncomfort\u00ad Figure 1. MOP speci.cation for resource safety able with formal notation to declare properties \nusing high\u00adlevel or application-speci.c requirements speci.cation for\u00admalisms. Speci.cations using any \nof the logic-plugins are allowed to have parameters; this way, multiple monitor in\u00adstances for the same \nproperty can coexist, one per collection of objects of interest. MOP also allows its users to imple\u00adment \nmonitors manually, using the full strength of the target language. In other words, MOP supports and encourages \nthe use of formal speci.cations, but it does not require it. 1.1 Examples Let us consider a simple and \ncommon safety property for a shared resource, namely that any access to the resource should be authenticated. \nFor simplicity, suppose that all the operations on the shared resource are implemented in the class Resource, \nincluding methods access() and authenticate(). Then the safety property can be speci\u00ad.ed as a trivial \nalways past linear temporal logic (LTL) formula over method invocations, namely access -> <*> authenticate, \nstating that if access then authenticate held in the past ( <*> reads eventually in the past ); the always \npart is implicit, since MOP properties are continuously monitored. Using MOP like in Figure 1, one can \nenforce this policy to hold in any system that manages the resource via the Resource class; by enforce \nwe mean that MOP ensures that the system will satisfy the property even though it was not originally \nprogrammed (intentionally or not) to satisfy it. The .rst line of the MOP speci.cation in Figure 1 states \nthat this property is a class invariant, i.e., it should hold in the scope of this class (speci.cation \nattributes are dis\u00adcussed in Section 4.1). The second line chooses a desired formalism to express the \ncorresponding formal requirement, in this case past-time LTL (PTLTL); MOP allows users to plug-and-play \nnew speci.cation formalisms, provided that they respect the standardized interface of logic-plugins (these \nare discussed in Section 3.2). The content enclosed by the curly brackets is speci.c to the chosen formalism. \nFor PTLTL, the user needs to .rst build an abstraction that maps runtime events into logical elements, \ne.g., the in\u00advocation of authenticate() being mapped to an event authenticate. Using the elements produced \nby the ab\u00ad class Resource { /*+MonitorAspect+*/ /*@ public aspect MonitorAspect { scope = class /*+ \nGenerated by JavaMOP for javamop.monitor PTLTL_0 */ logic = PTLTL public boolean[] Resource.PTLTL_0_pre \n= new boolean[1]; { public boolean[] Resource.PTLTL_0_now = new boolean[1]; event authenticate: end(exec(* \nauthenticate())); pointcut PTLTL_0_Init(Resource thisObject): event access: begin(exec(* access())); \nexecution(Resource.new(..)) &#38;&#38; target(thisObject); formula: access -> <*> authenticate; after(Resource \nthisObject): PTLTL_0_Init(thisObject) { } boolean authenticate = false; violation handler { @this.authenticate(); \n} boolean access = false; @*/ thisObject.PTLTL_0_now[0] = authenticate; void authenticate() {...} } void \naccess() {...} pointcut PTLTL_0_authenticate0(Resource thisObject): ... target(thisObject) &#38;&#38; \nexecution(* Resource.authenticate()); } after (Resource thisObject) returning: PTLTL_0_authenticate0(thisObject) \n{ boolean authenticate = false; boolean access = false; authenticate = true; thisObject.PTLTL_0_pre[0] \n= thisObject.PTLTL_0_now[0]; thisObject.PTLTL_0_now[0] = authenticate || thisObject.PTLTL_0_pre[0]; if \n(access &#38;&#38; ! thisObject.PTLTL_0_now[0]){ thisObject.authenticate(); } } pointcut PTLTL_0_access0(Resource \nthisObject): target(thisObject) &#38;&#38; execution(* Resource.access()); before (Resource thisObject): \nPTLTL_0_access0(thisObject) { boolean authenticate = false; boolean access = false; access = true; thisObject.PTLTL_0_pre[0] \n= thisObject.PTLTL_0_now[0]; thisObject.PTLTL_0_now[0] = authenticate || thisObject.PTLTL_0_pre[0]; if \n(access &#38;&#38; ! thisObject.PTLTL_0_now[0]){ thisObject.authenticate(); } } /* Generated code ends \n+*/ } Figure 2. Generated monitor for the property in Figure 1 straction, a PTLTL formula is given to \ndescribe the desired property. The last part of the MOP speci.cation contains the code that will be triggered \nwhen the speci.cation is violated and/or validated. It may be as simple as reporting errors, or as sophisticated \nas taking recovery actions to correct the execution to avoid crashes of the system. In this example, \nwhen the safety property is violated, i.e., when some access is not authenticated, we enforce the authentication \nsimply by making a call to authenticate(). The MOP tool is able to analyze this speci.cation, generate \nmonitoring code for the formula, and insert the monitor with the recovery handler into appropriate points \nof the program. There are two important observations regarding the ex\u00adample above, each re.ecting a crucial \naspect of MOP: 1. By synthesizing monitoring code from speci.cations and automatically integrating it \ntogether with the recovery code at relevant points in the program, the developer can and should have \nquite a high con.dence that the resource is used correctly throughout the system. In fact, if we trust \nthat the MOP tool generates and integrates the monitoring code correctly, then we can also trust that \nthe resulting system is correct w.r.t. this safety property, no matter how complicated the system is. \n /*@ this time is for extended regular expressions (ERE), that is, scope = class regular expressions \nextended with complement (no comple\u00ad logic = ERE { ment is needed here, but the ERE plugin generates \noptimal [static int counter = 0; int writes = 0;] monitors also for ordinary regular expressions). event \nopen : end(call(* open(..))) {writes = 0;}; Two auxiliary variables are de.ned as part of the MOP event \nwrite : end(call(* write(..))) {writes ++;} ; event close : end(call(* close(..))); speci.cation, a static \ncounter and a per-object writes.The formula : (open write+ close)* desired pattern to pro.le is (open \nwrite+ close)*,that } violation handler{ @RESET; } is, how many times we see an open followed by one \nor more validation handler{ synchronized(getClass()){ writes followedbya close. Each open event resets \nthe File.log((++counter) + \":\" + writes); } } @*/ writes, which is then incremented at each write event. \nThe validation handler, which in the case of EREs is triggered Figure 3. MOP speci.cation for .le pro.ling \nwhenever the automaton monitor reaches its .nal state, logs 2. Suppose that authentication-before-access \nwas not a re- the writes and increments the static counter; note that this quirement of the system originally, \nbut that it became a handler needs to synchronize on the class to avoid potential desired feature later \nin the development process (e.g., be-races. The violation handler, which for EREs is triggered cause \nof a larger number of clients). Suppose also that, whenever the automaton monitor cannot advance to a \nnext as a consequence, one wants to add authentication to state (in our case, that most likely happens \nwhen a .le is an initial implementation of the system that provided open then closed without any writes), \nresets the monitor to no support and no checking for authentication. Using its initial state using the \nMOP reserved command @RESET. MOP, all one needs to do is to add an (unavoidable) Both MOP speci.cations \nabove are class scoped: they re\u00adauthenticate() method, together with the MOP spec-fer to behaviors of \nindividual objects. There are, however, i.cation in Figure 1. This way, the MOP speci.cation to-many \nsafety properties of interest that refer to collections gether with its violation handler added non-trivial \nfunc-of two or more objects. Some of these are considered so tionality to the system, in a fast, elegant \nand correct way. important that language designers feel it appropriate to in\u00ad clude corresponding runtime \nsafety checks as built-in part Monitors corresponding to speci.cations may need to ob\u00ad of programming \nlanguages. For example, Java 5 raises a serve the execution of the program at many different points, \nConcurrentModificationException when running which can be scattered all over the system. In this sense, \nev- Vector v = new Vector(); ery monitor can be regarded as a crosscutting feature, like in v.add(new \nInteger(10)); aspect-oriented programming (AOP) [33]. MOP can be re-Iterator i = v.iterator(); v.add(new \nInteger(20)); garded as a specialized instance of AOP, in which aspects System.out.println(i.next()); \n are (formal) speci.cations. Existing AOP tools provide cru\u00adcial support for MOP to integrate generated \nmonitoring code That is because the Iterators returned by Vector s iterator as well as recovery code \ninto the system. From this point of methods are assumed fail-fast in Java: the Vector is not al\u00adview, \nMOP actsasa supplier of aspects:itconverts speci.-lowed to be modi.ed while the Iterator accesses its \nelements cations into concrete aspects that can be handled by existing However, the Enumerations returned \nby Vector s elements AOP tools. For instance, our MOP front-end for Java dis-method are not assumed fail-fast \nin Java 5, and, obviously, cussed in Section 3.3, JavaMOP, translates the speci.cation neither are any \nother user-de.ned iterator-like objects. One in Figure 1 into the AspectJ code in Figure 2 (that code \nis can easily imagine many other similar tight relationships further compiled using off-the-shelf AspectJ \ncompilers). among two or more objects, either language-speci.c as Comparing Figure 1 with Figure 2, one \ncan see that above or application-speci.c. For example, a security policy MOP provides an abstract programming \nenvironment, hid-in an application can be: for any password p, string s and .le ing underlying implementation \ndetails. Low-level error-f, it is never the case that s is the decrypted version of p (as prone tasks, \nsuch as transforming formulae into monitors or returned by some decrypt method) and s is written on f. \nchoosing appropriate join points to integrate monitors and To support such important properties referring \nto groups recovery code, are all automatically handled by the MOP of objects, MOP now provides a generic \nmechanism allow\u00adframework; this way, the user is freed to focus on the inter-ing for universal parameters \nto requirements speci.ed using esting and important aspects of the system. any of the logic-plugins. \nFigure 4 shows an MOP speci.- The example above shows an event-harmless MOP cation making enumeration \nobjects corresponding to vectors speci.cation, i.e., one that executes no auxiliary code when also fail-fast. \nNote that this time the MOP speci.cation is events are observed (except running the generated monitor), \nglobally scoped, because it refers to more than one object. with a violation handler encapsulating all \ndesired recovery The property to check, which is also given an optional name code. Figure 3 depicts a \nmore intrusive MOP speci.cation here, SafeEnum, has two parameters: a Vector v and an with both violation \nand validation handlers, also showing Enumeration+ e; the + says that the property (and its how MOP can \nbe used for pro.ling. The logic-plugin used monitors) is inherited by all subclasses of Enumeration. \n/*@ tems supporting parametric properties use centralized mon\u00adscope = global itors and indexing, that \nis, all monitors are stored in a com\u00ad logic = ERE mon pool and parametric events are resolved and dispatched \n SafeEnum (Vector v, Enumeration+ e) { [String location = \"\";] at this centralized level, incurring unavoidable \nruntime over\u00ad event create<v,e>: end(call(Enumeration+.new(v,..))) with (e); head when the pool contains \nmany objects. Our decentral\u00ad event updatesource<v>: end(call(* v.add*(..))) \\/ end(call(* v.remove*(..))) \n\\/ ... ized indexing technique is logic-independent, so it can be {location = @LOC;} adopted by any runtime \nveri.cation system. As empirically event next<e>: begin(call(* e.nextElement())); formula : create next* \nupdatesource+ next shown in Section 6, despite its genericity with regard to log\u00ad} ical formalisms, MOP \nwith decentralized indexing is more validation handler { System.out.println(\"Vector updated at \" + @MONITOR.location); \n} ef.cient than the current state-of-the-art runtime veri.cation @*/ systems specialized and optimized \nfor particular logics. Figure 4. MOP speci.cation for safe enumeration (2) New MOP language, raw MOP \nspeci.cations The event create<v,e> is parametric in both v and We de.ned a new MOP speci.cation language, \nwhich al\u00ade, and is generated whenever enumeration e is created for lows not only speci.cations of parametric \nproperties using vector v.The event updatesource<v> is generated when MOP logic-plugins, but also de.nitions \nof raw MOP spec\u00admethods that modify the vector are called; to save space, i.cations. Raw MOP speci.cations \nrequire no logic-plugin we did not list all of them in Figure 4. The location (.le and consequently no \nlogical formula, so they need to be ex\u00adand line number) of the update is also stored in the variable \nplicitly implemented by users in the target language (e.g., location, using the MOP reserved variable \n@LOC.An ERE Java); in this case, the MOP framework provides a useful formula expresses the faulty pattern: \nan updatesource abstraction allowing users to de.ne monitor variables and/or event is seen after create \nand before a next;events in event actions, to generate and handle violation or validation this pattern \nare assumed parameterized as above. signals, to use MOP reserved keywords and commands, etc.; The validation \nhandler here simply reports the location the developer of raw MOP speci.cations can fully utilize where \nthe vector was wrongly updated (this info is useful the strength of the target language. Raw MOP speci.cations \nfor debugging); the MOP reserved keyword @MONITOR gives may be preferred by users who are not comfortable \nwith for\u00ada reference to the corresponding monitor instance, which mal notation. We use them to write \nhand-optimized monitors has the declared monitor variables (only location here) as for the experiments \nin Section 6. Due to its new enriched .elds. MOP will create as many monitors for this property speci.cation \nlanguage, MOP now captures many other run\u00adas corresponding instances of v and e are generated during \ntime veri.cation frameworks as specialized instances (these the execution of the application, and will \ndispatch the events are discussed in Section 2); this genericity comes at no per\u00adcorrespondingly; for \nexample, if several enumerations are formance penalty (on the contrary). Therefore, MOP is now created \nfor the same vector v,thenan updatesource<v> a viable generic platform for runtime veri.cation projects, \nevent is sent to each instance monitor corresponding to each allowing experimentation with new logics \nfor monitoring, enumeration of v. JavaMOP generates about 200 lines of safety policies, monitor synthesis \nalgorithms, and so on. AspectJ code from the speci.cation in Figure 4. (3) Evaluation and Experiments \nA large number of experiments have been carried out to  1.2 Contributions evaluate the feasibility \nand effectiveness of MOP: we used As already mentioned, the basic idea of MOP and a .rst JavaMOP to check \nmore than 100 property-program pairs. JavaMOP prototype have already been discussed in several The results \nare encouraging: in most cases, the runtime over\u00adplaces [21, 18, 19, 22]. However, the previous design \nand im\u00ad head was negligible; only 8% of experiments showed noti\u00adplementation of MOP lacked parameters \nand thus had lim\u00ad cable slow-down of 10% or more. In some purposely de\u00adited practical use. In particular, \nthe safe enumerator example signed extreme cases, the runtime overhead was still less in Figure 4, the \nexamples supported by other runtime ver\u00ad than 200%, but we were able to write raw MOP speci.ca\u00adi.cation \nsystems such as Tracematches [2], PQL [38] and tions for the same properties, reducing the overhead below \nPTQL [27], as well as most of the examples in Sections 6 30%. We did not focus on error detection, in \nthe sense that were previously not possible to de.ne in MOP using formal no test generation techniques \nwere used. However, many vi\u00adspeci.cations. Our contributions in this paper are: olations of speci.ed \nproperties were revealed; some of these (1) Universal parameters, decentralized indexing are benign \n(but still interesting to be aware of), others in- We present a generic technique to add universal param-dicate \npossible defects of programs: an inappropriate us\u00adeters to trace-based logics, together with an optimized \nim-age of StringWriter leads to a write-after-close violation plementation based on decentralized indexing. \nLogical for-in Xalan [42]; possible resource leaks in Eclipse [25] GUI malisms used in runtime veri.cation \nand monitoring have packages; a violation of SafeEnum caused by concurrency traces as models; in particular, \nall our MOP logic-plugins in jHotDraw [32]; etc. (see Section 6.2). These subtle prob\u00adare trace-based. \nHowever, existing runtime veri.cation sys-lems are dif.cult to detect using ordinary testing, but Java\u00adMOP \nprovided good support to locate their root causes. Our experiments show that runtime veri.cation in general \nand MOP in particular are feasible and effective in practice. Both JavaMOP and the experiments are publicly \navailable at [20].  2. Related Work We next discuss relationships between MOP and other re\u00adlated paradigms, \nincluding AOP, design by contract, runtime veri.cation, and other trace monitoring approaches. Broadly \nspeaking, all the monitoring approaches discussed below are runtime veri.cation approaches; however, \nin this section only, we group into the runtime veri.cation category only those approaches that explicitly \ncall themselves runtime ver\u00adi.cation approaches. Interestingly, even though most of the systems mentioned \nbelow target the same programming lan\u00adguages, no two of them share the same logical formalism for expressing \nproperties. This observation strengthens our belief that probably there is no silver bullet logic (or \nsuper logic) for all purposes. A major objective in the design of MOP was to avoid hardwiring particular \nlogical formalisms into the system. In fact, as shown in Sections 3 and 4, MOP speci.cations are generic \nin four orthogonal directions: MOP[logic, scope, running mode, handlers]. The logic answers how to specify \nthe property. The scope answers where to check the property; it can be class invari\u00adant, global, interface, \netc. The running mode answers where the monitor is; it can be inline, online, of.ine. The handlers answer \nwhat to do if; there can be violation and validation handlers. For example, a particular instance can \nbe MOP[ERE, global, inline, validation], where the property is expressed using the ERE logic-plugin for \nextended regular expressions (EREs), the corresponding monitor is global and inline, and validation of \nthe formula (pattern matching in this case) is of interest. Most approaches below can be seen as such \nspecial\u00adized instances of MOP for particular logics, scopes, running modes and handlers. There are, of \ncourse, details that make each of these approaches interesting in its own way. 2.1 Aspect Oriented Programming \n(AOP) Languages Since its proposal in [33], AOP has been increasingly adopted and many tools have been \ndeveloped to support AOP in different programming languages, e.g., AspectJ and JBoss [31] for Java and \nAspectC++ [4] for C++. Built on these general AOP languages, numerous extensions have been proposed to \nprovide domain-speci.c features for AOP. Among these extensions, Tracematches [2] and J-LO [15] support \nhistory(trace)-based aspects for Java. Tracematches enables the programmer to trigger the ex\u00adecution \nof certain code by specifying a regular pattern of events in a computation trace, where the events are \nde.ned over entry/exit of AspectJ pointcuts. When the pattern is matched during the execution, the associated \ncode will be executed. In this sense, Tracematches supports trace-based pointcuts for AspectJ. J-LO is \na tool for runtime-checking temporal assertions. These temporal assertions are speci\u00ad.ed using LTL and \nthe syntax adopted in J-LO is similar to Tracematches except that the formulae are written in a different \nlogic. J-LO mainly focuses on checking at runtime properties rather than providing programming support. \nIn J-LO, the temporal assertions are inserted into Java .les as an\u00adnotations that are then compiled into \nruntime checks. Both Tracematches and J-LO support parametric events, i.e., free variables can be used \nin the event patterns and will be bound to speci.c values at runtime for matching events. Concep\u00adtually, \nJ-LO can be captured by MOP, because LTL is sup\u00adported by MOP and J-LO s temporal assertions can be easily \ntranslated into MOP speci.cations that contain only action events and validation handlers. Although MOP \nsupports regular expressions as part of its ERE logic plugin, they hold a different semantics from Tracematches \npatterns. More speci.cally, the MOP regu\u00adlar pattern speci.cations are checked against the whole exe\u00adcution \ntrace, while Tracematches patterns can be matched with partial traces. For example, for a pattern A* \nB , a se\u00adquence of events A B B will trigger the validation handler of the generated MOP monitor only \nat the .rst B event and then the violation handler at the second B . In Trace\u00admatches, the pattern will \nbe matched twice, once for each B event: the .rst matches either the whole trace A B or the partial trace \nconsisting of just the .rst B with zero oc\u00adcurrences of A , while the second matches the subsequent partial \ntrace B (the second B in the trace) with zero occurrences of A ; thus, the related advice will executed \ntwice. Both semantics are useful for different purposes. For example, in Tracematches one can count matches \nof a pat\u00adtern open close without a need to reset the monitor after each match as in MOP. On the other \nhand, total trace match\u00ading is more suitable for runtime veri.cation of formal prop\u00aderties, because it \nis also the semantics adopted by conven\u00adtional formal veri.cation techniques and tools. Note, however, \nthat it is relatively easy to support partial trace matching in a total matching and vice versa. For \nexam\u00adple, to capture partial matching in a total matching setting such as MOP s, all one needs to do \nis to maintain a set of states, while a new monitor state is produced at each event; the set will contain \nat most as many states as the property monitor can have. Conversely, to capture total trace match\u00ading \nin a partial matching setting such as Tracematches , all one needs to do is to generate an arti.cial \nevent only once at the beginning of the trace, say start , and then automati\u00adcally change any pattern \nP to start P . Event though partial and total trace semantics are ulti\u00admately equivalent as explained \nabove, the partial trace one is less conventional and thus can lead to confusing behav\u00adiors if one is \nnot careful. For example, let us re-consider the safety property in Figure 1. By exhaustively enumerating \nall the methods in the Resource class, one may use a pattern, class Resource { /*@ scope = class logic \n= ERE { // not-authenticate includes all methods other than // authenticate() and access() event not-authenticate: \nend(exec(* ...)); event authenticate: end(exec(* authenticate())); event access: begin(exec(* access())); \nformula: not-authenticate* access; } validation handler { @this.authenticate(); } @*/ void authenticate() \n{...} void access() {...} ... } Figure 5. Regular MOP speci.cation for resource safety not-authenticate* \naccess, to detect non-authenticated accesses, as in Figure 5. If the authentication is carried out before \nany access, this speci.ed pattern will not be matched by the monitor generated by MOP. Otherwise, when \nthe .rst unsafe access occurs, the MOP monitor will trigger the vali\u00addation handler, enforcing the authentication \nright before the access and ensuring all the following accesses safe. With\u00adout an explicit capturing \nof total trace matching in a partial trace matching setting as explained above, it is dif.cult, if not \nimpossible, to achieve the same behavior using Trace\u00admatches. For instance, the above pattern will be \nmatched even for a correct execution, e.g., authenticate access, because there exists a matching partial \ntrace consisting of only access. In addition to inline and global monitors currently sup\u00adported by Tracematches \nand J-LO, MOP also provides class\u00adscoped properties, outline and of.ine monitor settings, and more. Fixing \na logic allows for developing static analy\u00adsis and logic-speci.c optimizations. We have not attempted \nto devise any logic-speci.c optimizations yet in MOP, be\u00adcause we do not regard MOP s runtime overhead \nas a bot\u00adtleneck yet. In Section 6, we show that the MOP instance MOP[ERE, class/global, inline, validation] \nusing decentral\u00adized indexing adds signi.cantly less runtime overhead than Tracematches with static analysis \nenabled. It is also worth mentioning that Tracematches and J-LO are implemented using Java bytecode compilation \nand instrumentation, while MOP acts as an aspect synthesizer, making it easier to port to other target \nlanguages provided they have AOP tool support. 2.2 Runtime Veri.cation In runtime veri.cation, monitors \nare automatically synthe\u00adsized from formal speci.cations, and can be deployed of.ine for debugging, or \nonline for dynamically checking proper\u00adties during execution. MaC [35], PathExplorer (PaX) [28], and \nEagle [12] are runtime veri.cation frameworks for logic based monitoring, within which speci.c tools \nfor Java Java-MaC, Java PathExplorer, and Hawk [23], respectively are implemented. All these runtime \nveri.cation systems work in outline monitoring mode and have hardwired spec\u00adi.cation languages: MaC uses \na specialized language based on interval temporal logic, JPaX supports just LTL, and Ea\u00adgle adopts a \n.xed-point logic. Java-Mac and Java PathEx\u00adplorer integrate monitors via Java bytecode instrumentation, \nmaking them dif.cult to port to other languages. Our ap\u00adproach supports inline, outline and of.ine monitoring, \nal\u00adlows one to de.ne new formalisms to extend the MOP framework, and is adaptable to new programming \nlanguages. Temporal Rover [24] is a commercial runtime veri.cation tool based on future time metric temporal \nlogic. It allows programmers to insert formal speci.cations in programs via annotations, from which monitors \nare generated. An Auto\u00admatic Test Generation (ATG) component is also provided to generate test sequences \nfrom logic speci.cations. Temporal Rover and its successor, DB Rover, support both inline and of.ine \nmonitoring. However, they also have their speci.ca\u00adtion formalisms hardwired and are tightly bound to \nJava. Although our current JavaMOP prototype does not sup\u00adport all these techniques yet, it is expected \nthat all the RV systems would fall under the general MOP architecture, pro\u00advided that appropriate logic-plugins \nare de.ned. 2.3 Design by Contract Design by Contract (DBC) [39] is a technique allowing one to add \nsemantic speci.cations to a program in the form of assertions and invariants, which are then compiled \ninto runtime checks. It was .rst introduced by Meyer as a built\u00adin feature of the Eiffel language [26]. \nSome DBC extensions have also been proposed for a number of other languages. Jass [13] and jContractor \n[1] are two Java-based approaches. Jass is a precompiler which turns the assertion comments into Java \ncode. Besides the standard DBC features such as pre-/post-conditions and class invariants, it also provides \nre.nement checks. The design of trace assertions in Jass is mainly in.uenced by CSP [30], and the syntax \nis more like a programming language. jContractor is implemented as a Java library which allows programmers \nto associate con\u00adtracts with any Java classes or interfaces. Contract methods can be included directly \nwithin the Java class or written as a separate contract class. Before loading each class, jCon\u00adtractor \ndetects the presence of contract code patterns in the Java class bytecode and performs on-the-.y bytecode \ninstru\u00admentation to enable checking of contracts during the pro\u00adgram s execution. jContractor also provides \na support library for writing expressions using predicate logic quanti.ers and operators such as Forall, \nExists, suchThat,and implies.Us\u00ading jContractor, the contracts can be directly inserted into the Java \nbytecode even without the source code. Java modeling language (JML)[36] is a behavioral inter\u00adface speci.cation \nlanguage for Java. It provides a more com\u00adprehensive modeling language than DBC extensions. Not all features \nof JML can be checked at runtime; its runtime checker supports a DBC-like subset of JML, a large part \nof which is also supported by JavaMOP. Spec# [10] is a DBC\u00adlike extension of the object-oriented language \nC#. It extends the type system to include non-null types and checked ex\u00adceptions and also provides method \ncontracts in the form of pre-and post-conditions as well as object invariants. Us\u00ading the Spec# compiler, \none can statically enforce non-null types, emit run-time checks for method contracts and invari\u00adants, \nand record the contracts as metadata for consumption by downstream tools. We believe that the logics \nof assertions/invariants used in DBC approaches fall under the uniform format of our logic engines, so \nthat an MOP environment following our princi\u00adples would naturally support monitoring DBC speci.cations \nas a special methodological case. In addition, our MOP de\u00adsign also supports outline monitoring, which \nwe .nd impor\u00adtant in assuring software reliability but which is not provided by any of the current DBC \napproaches that we are aware of. 2.4 Other Related Approaches Acceptability-oriented computing [40] \naims at enhancing .awed computer systems to respect basic acceptability prop\u00aderties. For example, by \naugmenting the compiled code with bounds checks to detect and discard out-of-bound memory accesses, the \nsystem may execute successfully through attacks that trigger otherwise fatal memory errors. Acceptability-oriented \ncomputing is mainly a philosophy and methodology for software development; one has to de\u00advise speci.c \nsolutions to deal with different kinds of failures. We do believe though that MOP can serve as a platform \nto experiment with and support acceptability-oriented com\u00adputing, provided that appropriate speci.cation \nformalisms express the acceptability policy and appropriate recovery ensures that it is never violated. \nProgram Query Language (PQL) allows programmers to express design rules that deal with sequences of events \nassociated with a set of related objects [38]. Both static and dynamic tools have been implemented to \n.nd solutions to PQL queries. The static analysis conservatively looks for potential matches for queries \nand is useful to reduce the number of dynamic checks. The dynamic analyzer checks the runtime behavior \nand can perform user-de.ned actions when matches are found, similar to MOP handlers. PQL has a hardwired \nspeci.cation language based on context-free grammars (CFG) and supports only in\u00adline monitoring. CFGs \ncan potentially express more com\u00adplex languages than regular expressions, so in principle PQL can express \nmore complex safety policies than Trace\u00admatches. There is an unavoidable trade-off between the gen\u00aderality \nof a logic and the ef.ciency of its monitors; ex\u00adperiments performed by Tracematches colleagues [6] and \ncon.rmed by us (see Section 6) show that PQL adds, on average, more than twice as much runtime overhead \nas Tracematches. We intend to soon take a standard CFG-to\u00adpushdown-automata algorithm and to implement \nit as an MOP logic-plugin; then MOP will also support (the rare) CFG speci.cations that cannot be expressed \nusing para\u00admetric extended regular expressions or temporal logics, and MOP[CFG,global,inline,validation] \nwill provide an alterna\u00adtive and more general implementation of PQL. Program Trace Query Language (PTQL) \n[27] is a lan\u00adguage based on SQL-like relational queries over program traces. The current PTQL compiler, \nPartiqle, instruments Java programs to execute the relational queries on the .y. PTQL events are timestamped \nand the timestamps can be explicitly used in queries. PTQL queries can be arbitrary complex and, as shown \nin [27], PTQL s runtime overhead seems acceptable in many cases but we were unable to obtain a working \npackage of PTQL and compare it in our experi\u00adments because of license issues. PTQL properties are glob\u00adally \nscoped and their running mode is inline. PTQL provides no support for recovery, its main use being to \ndetect errors. It would be interesting to investigate the possibility of de\u00adveloping an SQL logic-plugin \nfor MOP and then to compare the corresponding MOP instance to Partiqle.  3. Overview of MOP and JavaMOP \nWe here brie.y introduce MOP and JavaMOP. Interested readers are referred to [19, 18] for more details, \nand also to [20] for tool downloads and the latest development news. 3.1 MOP Monitoring Model Many properties \ncan be monitored at the same time in MOP. The execution trace against which the various properties are \nchecked is extracted from the running program as a sequence of events taking state snapshots. Events \nproduce suf.cient information about the concrete program state in order for the monitors to correctly \ncheck their properties. A monitor is typically interested in a subset of events. Figure 6 illustrates \nthe monitoring model adopted by MOP. Figure 6. MOP Monitoring Model In MOP, the runtime monitoring process \nof each property consists of two orthogonal mechanisms: observation and veri.cation. The observation \nmechanism extracts property\u00adrelevant and .ltered system states at designated points, e.g., when property-speci.c \nevents happen. The veri.cation mechanism checks the obtained abstract trace against the (monitor corresponding \nto the) property and triggers desired actions in case of violations or validations. For instance, for \nthe simple global property always (x>0) , the events to observe are the updates of the variable x and \nthe rele\u00advant state information (or snapshot) to extract is the value Interfaces Figure 7. MOP architecture \nof x. This observation process yields a sequence of values of x: the relevant abstract trace. The corresponding \nmonitor checks whether the value of x is larger than zero. Observa\u00adtion and veri.cation are therefore \nindependent, in the sense that the algorithm used within the monitor does not affect how the execution \nis observed, and vice versa. MOP is a highly con.gurable and extensible runtime veri.cation framework. \nDepending upon con.guration, the monitors can be separate programs reading events from a log .le, from \na socket or from a buffer, or can be inlined within the program at the event observation points. The \nvarious MOP con.guration attributes are discussed in Section 4. 3.2 MOP: An Extensible Monitoring Framework \nMOP separates monitor generation and monitor integration by adopting the layered architecture in Figure \n7. This ar\u00adchitecture is especially designed to facilitate extending the MOP framework with new formalisms \nor new programming languages. By standardizing the protocols between layers, new modules can be added \neasily and independently. Mod\u00adules on lower layers can be reused by upper-level modules. The topmost \nlayer, called the interface layer, provides user friendly programming environments. For example, the \nreader is encouraged to try the web-based interface for Java-MOP at [20] (no download needed, examples \nprovided). The second layer contains speci.cation processors, which han\u00addle monitor integration. Each \nspeci.cation processor is spe\u00adci.c to a target programming language and consists of a pro\u00adgram scanner \nand a program transformer. The scanner ex\u00adtracts MOP speci.cations from the program and dispatches them \nto appropriate modules on the lower layer to process. The transformer collects the monitoring code generated \nby the lower layer and integrates it into the original program. AOP plays a critical role here: the program \ntransformer syn\u00adthesizes AOP code and invokes AOP compilers to merge the monitors within the program. \nIn particular, as discussed in Section 3.3, JavaMOP transforms generated monitoring code into AspectJ \ncode. The two lower layers contain the logic-plugins,which allow the user to add, remove, or modify speci.cation \nfor\u00admalisms. Logic-plugins are usually composed of two mod\u00adules: a language shell on the third layer \nand a logic engine on the bottom layer. The former generates programming lan\u00adguage and speci.cation formalism \nspeci.c monitoring code in a standardized format, which can be understood by the speci.cation processor \non the upper layer. The logic engine, acting as the core of monitor generation, synthesizes mon\u00aditors \nfrom speci.cations in a programming language inde\u00adpendent way, e.g., as state machines. This way, logic \nengines can be reused across different programming languages. 3.3 JavaMOP JavaMOP is an MOP development \ntool for Java. It pro\u00advides several interfaces, including a web-based interface, a command-line interface \nand an Eclipse-based GUI, provid\u00ading the developer with different means to manage and pro\u00adcess MOP speci.cations. \nTo .exibly support these various interfaces, as well as for portability reasons, we designed JavaMOP \nfollowing a client-server architecture(see [19]) as an instance of the general MOP architecture in Figure \n7. The client part includes the interface modules and the JavaMOP speci.cation processor, while the server \ncontains a message dispatcher and logic-plugins for Java. The speci.cation pro\u00adcessor employs AspectJ \nfor monitor integration. In other words, JavaMOP translates outputs of logic-plugins into As\u00adpectJ code, \nwhich is then merged within the original pro\u00adgram by the AspectJ compiler. The message dispatcher is \nre\u00adsponsible for the communication between the client and the server, dispatching requests to corresponding \nlogic-plugins. The communication can be either local or remote, depending upon the installation of the \nserver. An immediate advantage of this architecture is that one logic server can provide and cache monitor \ngeneration ser\u00advices, which can require intensive computation, to multiple clients. Also, our clients \nare implemented in Java to run on different platforms, while some of the logic engines are im\u00adplemented \nin non-conventional languages and consequently run best on Linux or Unix. Therefore, this architecture \nin\u00adcreases portability, since the client and the server are allowed to run on different platforms; also \nthe server can cache mon\u00aditors for common formulae. Four logic-plugins are currently provided with JavaMOP: \nJava Modeling Language (JML) [36], Extended Regular Ex\u00adpressions (ERE) and Past-Time and Future-time \nLinear Tem\u00adporal Logics (LTL) (see [19] for more details).  4. The MOP Speci.cation Language MOP provides \na speci.cation language to de.ne safety properties. The design of this language was driven by two factors: \nuniformity in supporting different formalisms and languages, and the ability to control monitor behaviors. \nLanguage-speci.c and logic-speci.c notations are carefully distinguished from other notations in MOP \nspeci.cations. The developer is also given the possibility to directly pro\u00adgram the monitor if she/he \nwants to fully control the mon\u00aditoring process (see Section 4.4). The MOP speci.cation language can be \nregarded as a specialized AOP language, tuned to support specifying monitors either formally using logics \nor informally by programming. MOP speci.cations can be either embedded into the source code as special \nannotations or stored in separate .les. Each format has different advantages. Annotations are more suitable \nfor properties related to speci.c positions in the source code, e.g., assertions and pre-/post-conditions \nfor methods. On the other hand, separate speci.cation .les are conceptually clearer when their corresponding \nproperties re\u00adfer to multiple places in the program, e.g., global properties. JavaMOP supports both kinds \nof speci.cations. .Speci.cation.::= /*@ .Header..Body..Handlers.@*/ .Header.::= .Attribute.*[scope =.Scope.][logic \n=.Logic.] .Attribute.::= static |outline |offline |centralized .Scope.::= global |class |interface |method \n.Name.::= .Identi.er. .Logic.::= .Identi.er. .Body.::= [.Name.][(.Parameters.)]{.LogicSpeci.cContent.} \n.Parameters.::= ( .Type..Identi.er.)+ .Handlers.::= [.ViolationHandler.][.ValidationHandler.] .ViolationHandler.::= \nviolation handler {.Code.} .ValidationHandler.::= validation handler {.Code.} Figure 8. Syntax of MOP \nspeci.cations Figure 8 shows the syntax of MOP speci.cations. An MOP speci.cation is composed of three \nparts: the header, the body and the handlers. We next discuss each of these. 4.1 Header: Controlling \nMonitor Generation and Integration The header contains generic information to control monitor generation \nand integration, consisting of optional attributes, the scope, and the name of the formalism (or logic-plugin) \nused in the speci.cation. Attributes are used to con.gure monitors with different in\u00adstallation capabilities. \nThey are orthogonal to the actual monitor generation but determine the .nal code generated by the MOP \ntool. Four attributes are available. One is static, which has an effect only upon class/interface scoped \nprop\u00aderties, and says that the speci.cation refers to the class, not to the object. For a static speci.cation, \nonly one monitor instance is generated at runtime and is shared by all the ob\u00adjects of the corresponding \nclass. By default, monitors are non-static, meaning that objects will be monitored individ\u00adually. In \nJavaMOP, the variables used to represent the state of the monitor are added to the corresponding class \nas ei\u00adther static or non-static .elds, according to staticness of the monitor; inserting new class .elds \nis done through the inter\u00adtype member declaration of AspectJ (e.g., the declaration of Resource.PTLTL \n0 pre in Figure 2). To avoid name con\u00ad.icts, these .elds are renamed by the speci.cation processor. Two \nother attributes, outline and offline,are used to change the running mode of the monitor. Different properties \nmay require different running modes. For example, a moni\u00adtor can be executed in the context (thread) \nof the monitored system, or it can run outside of the monitored system, as a standalone process or thread. \nWe call the former an inline monitor, which is also the default mode of the speci.cation, and the latter \nan outline monitor. An inline monitor can inter\u00adact with the system directly, facilitating information \nretrieval and error recovery, but some problems, e.g., deadlocks, can\u00adnot be detected by inline monitors. \nBesides, inline monitors may cause signi.cant runtime overhead when running the monitor involves intensive \ncomputation. An outline monitor provides a better solution for such cases. In the outline mode, the monitored \nsystem sends messages that contain relevant state information to the monitor. However, communication \nwith outline monitors may reduce the performance of the system and, equally importantly, an outline monitor \ncannot access the internal state of the monitored system, limiting its capability for error recovery. \nAnother way to check an execution trace, which can sometimes make expensive monitoring feasible by allow\u00ading \nrandom access to the trace, is of.ine monitoring: log the trace in a .le and make it available to the \nmonitor . Since such monitors can run after the monitored system ceases, they are called of.ine monitors. \nOf.ine monitors are suit\u00adable for properties that can be decided only after the system stops or properties \nthat require a backward traversal of the trace; they may also be useful for debugging and analysis. These \nrunning modes impose different requirements on monitor synthesis. In JavaMOP, inline monitors are merged \ninto the program by encapsulating the monitoring code as an aspect, such as the example in Figure 1 and \nFigure 2. For outline and of.ine monitors a standalone monitor class is synthesized, which can run independently \nas a new thread or process. The MOP tool then generates aspects contain\u00ading either message passing code \n(in outline mode) or event logging code (in of.ine mode). The last attribute, named centralized from \ncentral\u00adized indexing , can only be combined with global paramet\u00adric speci.cations. The default indexing \nis decentralized in MOP, that is the references to monitors are piggybacked into states of some objects \nin order to reduce the runtime over\u00adhead. This technique is discussed in Section 5. As seen also in Section \n6, there are situations when a centralized pool of monitors is more suitable; we therefore allow the \nusers the possibility to choose centralized indexing. The scope of speci.cations de.nes the working scope \nof monitors, determining the points where properties are checked. Five scopes are supported: global, \nclass, interface, method, and a default scope. Properties which are global may involve multiple components/objects \nin the system. The scope class says that the property is a class invari\u00adant; both global and class properties \nare checked when  .LogicBody. ::= [[.VarDeclaration.]].Event.* [.Formula.] .Event. ::= .EventHeader.:.EventDecl. \n[{.Code.}]; .EventHeader. ::= event.Identi.er.[<.Parameters.>] .EventDecl. ::= .EventPoint.[with(.Type..Name.)][ \n&#38;&#38; .BExp.] .EventPoint. ::= (begin | end)(.EventPattern.) .EventPattern. ::= (call|exec)(.Method.) \n| update(.Field.) .Formula. ::= formula : .LogicFormula. Figure 9. MOP syntax for trace-based logic \nformalisms the involved .elds are updated or the involved methods are called. The scope interface denotes \na constraint on the interface, and is checked at every observable state change, i.e., on boundaries of \npublic method calls; MOP interface\u00adscoped properties are therefore similar to class invariants in JML \n[36]. The scope method is used to specify constraints on the designated method: pre-, post-, and exceptional \ncon\u00additions. The default scope is assertion or check point : the generated monitoring code replaces the \nspeci.cation and is therefore checked whenever reached during the execution. The logic name designates \nthe formalism to use in the spec\u00adi.cation and also identi.es the corresponding logic-plugin. Logic-plugins \nshould have different names. Presently, the following logic names can be used in JavaMOP: JML, ERE, FTLTL \nand PTLTL. If no logic is designated, the speci.cation is regarded as a raw MOP speci.cation, where the \nuser pro\u00advides his/her own code to monitor the desired property. This is explained in detail in Section \n4.4. 4.2 Body: Describing Properties The body of an MOP speci.cation de.nes the desired prop\u00aderty, and \nis sent to the corresponding logic-plugin by the speci.cation processor. It starts with an optional name \nand an optional list of parameters. The name, if provided, can be useful for documentation purposes or \nas a reference; oth\u00aderwise, the MOP tool will generate a unique internal name. The parameters can only \nbe combined with global proper\u00adties. MOP provides a generic, logic-independent way to add parameters \nto speci.cations, discussed in Section 5. Considering the diversity of speci.cation formalisms, it is \ndif.cult, and also undesirable, to design a uniform syntax for all possible formalisms. So the syntax \nof the speci.ca\u00adtion body varies with the underlying formalism. For JML, we adopted its original syntax. \nSince formalisms used to ex\u00adpress properties over traces, such as ERE and LTL, show many common features, \nwe designed a general syntax for all of them, shown in Figure 9. The body is composed of an optional \nblock for local variable declarations, a list of event de.nitions and a formula specifying the desired \nproperty. As discussedinSection3.1, an execution trace is ab\u00adstracted as a sequence of events generated \ndynamically; they usually correspond to concrete actions, e.g., invocation of certain methods or updates \nof some variables, and contain relevant information about the state of the program, e.g., val\u00adues of \naccessed variables. Events are regarded atomic and unique. In other words, two events are different even \nwhen they are generated at the same point. When two events are generated at the same point, the user \nshould not assume any pre-determined order between them, even though the under\u00adlying instrumentation \nmechanism, e.g., AspectJ, may impose some implementation-speci.c ordering. Properties of traces are then \nde.ned in terms of events. For example, the property speci.ed in Figure 1 involves two types of events, \nnamely, the end of the execution of authenticate() and the begin\u00adning of the execution of access(). De.nitions \nof events are orthogonal to the particular formalism used for the property. Events are related to entries \nand exits of actions during the execution. An action can be one of calling a method (in the caller s \ncontext), executing a method (in the callee s context) and updating a variable. A with clause can be \nattached to an event to fetch the return value of the event, i.e., the value returned from a method call \nor a variable update. In parametric speci.cations, events can be parametric; the event parameters, if \nany, must be a subset of the parameters of the speci.cation. A boolean expression can be associated with \neach event, acting as a condition: the event is generated only if the boolean expression evaluates to \ntrue. To capture the de.ned events at runtime, MOP tools need to statically insert the monitors at appropriate \npoints in the original program. AOP plays a critical role here: the MOP tool chooses instrumentation \npoints according to the event de.nitions and then uses the AOP compiler to integrate the monitor into \nthe program. In order to ease the translation from event de.nitions to join points in AOP, the syntax \nof the .Method. and .Field. may adopt the syntax of the employed AOP tool. For example, JavaMOP uses \nAspectJ syntax. Events can be used as atoms in formulae. During monitor synthesis, the language shell \nextracts and sends the formula to the logic engine, which then generates the monitoring code from the \nformula. The monitor generated by the logic engine can use some pseudo code that is independent of any \nspeci.c programming language. It will then be translated into the target language by the language shell. \nTherefore, the syntax of the formula varies with the formalisms. No formula is needed for raw MOP speci.cations. \nThe developer can declare local variables in the speci.ca\u00adtion and associate actions to event de.nitions. \nThe declared variables are called monitor variables and are only visible inside the monitor. They can \nbe used in event actions and in handlers. Event actions can be any code and are executed upon occurrences \nof the corresponding events. Using moni\u00adtor variables and event actions, one can specify more com\u00adplex \nproperties and implement more powerful handlers. For example, one may add counters into regular expressions \nto express properties like AB3A. Events de.ned in the speci.\u00adcation body are also monitor variables: \nthey can be used in event actions and handlers as boolean variables. 4.3 Handlers: Taking Actions MOP \nusers can provide special code to be executed when the property is violated or validated. Although many \nerrors are related to violations, sometimes it is easier to de.ne pat\u00adterns of erroneous behaviors (e.g., \npatterns of security at\u00adtacks): the match, or validation, of the pattern means error . In MOP, handlers \ncan be associated not only to violations but also to validations of properties. Even though handlers \nsupport runtime error recovery, they need not necessarily be error recovery code. An MOP speci.cation \ncan therefore be regarded as a complex branch statement with the speci\u00ad.ed property (which can refer \nto past and future events) as the condition and the handlers as true/false branches. The handlers use \nthe target programming language and will be part of the generated monitoring code. Since mon\u00aditors are \nsynthesized and integrated into the program after one writes the handler code, the handlers do not have \nfull access to information about the context in which the mon\u00aditor will be executed. To mitigate this \nproblem, MOP pro\u00advides several built-in variables and commands: @this refers to the current object; @RESET \nresets the state of the monitor to the initial state; @LOC refers to the current location (.le and line \nnumber) different events take place at different locations. These variables are replaced with appropriate \nval\u00adues or pieces of code during monitor synthesis. For example, @this in Figure 1 is renamed to thisObject \nin Figure 2. 4.4 Raw MOP Speci.cations MOP encourages the use of logical formalisms to specify de\u00adsired \nsystem behaviors concisely and rigorously. However, there are cases where one may want to have full control \nover the monitoring process; for example, some properties can be dif.cult or impossible to specify using \nexisting logical for\u00admalisms, or existing logic-plugins generate inef.cient mon\u00aditoring code. Moreover, \nthere may be developers who wish to bene.t from monitoring but who are not trained to or are not willing \nto write formal speci.cations, preferring instead to use the programming language that they are familiar \nwith. MOP supports raw speci.cations to implement and con\u00adtrol the monitoring process exclusively by \nordinary program\u00adming, without any reference to or use of logic formalisms and/or logic-plugins. As an \nexample, Figure 10 shows a raw MOP speci.cation that detects SQL-injection attacks [3]: malicious users \ntry to corrupt a database by inserting unsafe SQL statements into the input to the system. In SQL injection, \na string is tainted when it depends upon some user input; when a tainted string is used as a SQL query, \nit should be checked to avoid potential attacks. In Figure 10, a HashSet is declared to store all tainted \nstrings. Three types of events need to be monitored: userInput occurs when a string is obtained from \nuser input (by calling ServletRequest.getParameter()); propagate occurs when a new string is created \nfrom another string; .nally, usage occurs at using a string as a query. Appropriate actions are triggered \nat observed events: at userInput, the user input string is added to the tainted set; at propagate, if \nthe new string is created from a tainted string then it is marked as tainted, too; at usage, /*@ scope \n= global { [Set taintedStrings = new IdentitySet();] event userInput : end(call(String ServletRequest.getParameter(..))) \nwith (String tainted) { taintedStrings.put(tainted); } event propagate : end(call(StringBuffer StringBuffer.new(String \ns))) with (StringBuffer newS) \\/ end(call(StringBuffer StringBuffer.append(String s))) with (StringBuffer \nnewS) ... { if (taintedStrings.contains(s)) taintedStrings.put(newS.toString()); } event usage : begin(call(* \nStatement.executeQuery(String s))) { if taintedStrings.contains(s) Util.checkSafeQuery(s); } } @*/ Figure \n10. Raw MOP speci.cation for SQL injection if the query string is tainted then a provided method, called \nUtil.checkSafeQuery, is called to check the safety of the query. Thus the safety check, which can be \nan expensive operation, is invoked dynamically, on a by-need basis. In particular, for ef.ciency and \nseparation of concerns reasons, a developer may even ignore the SQL injection safety aspect when writing \ncode; the raw MOP speci.cation above will take care of this aspect entirely. This example shows that \nthe event/action abstraction pro\u00advided by raw MOP speci.cations is easy to master and use\u00adful for de.ning \ninteresting safety properties compactly and ef.ciently. Event names were not needed here, so they could \nhave been omitted. No formulae or violation/validation han\u00addlers are needed in raw MOP speci.cations; \nthe developer fully implements the monitoring process by providing event actions using the target programming \nlanguage. All logical MOP speci.cations can be translated into raw speci.cations; in other words, each \nspeci.cation formalism can be regarded as syntactic sugar within the raw MOP spec\u00adi.cation language. \nMOP thus provides a focused and expres\u00adsive AOP language for specifying safety properties and en\u00adforcing \nthem by means of monitoring and recovery. How\u00adever, the correctness of raw speci.cations is solely based \non the capability of the developer to understand and implement the safety requirements. Formal speci.cations \nand their cor\u00adresponding logic-plugins, on the other hand, can be assumed (and even formally proved) \nto generate correct monitoring code for the speci.ed property. In Section 6 we use raw MOP speci.cations \nto implement hand-optimized monitors.  5. Adding Parameters to Speci.cations As discussed in Section \n1.1, many safety properties of in\u00adterest in OO applications refer to groups of objects rather than to \nindividual objects. It is, however, a nontrivial matter to support and ef.ciently monitor such parametric \nspeci.ca\u00adtions. A natural solution is to use powerful logics that allow universally quanti.ed formulae \n(.p.). and to treat paramet\u00adric speci.cations as particular formulae universally quan\u00adti.ed over the \nparameters. The challenge that techniques {v, e} Map {v} Map {e} Map based on this super-logic approach \nface is how to synthe\u00adsize an ef.cient monitor from a universally quanti.ed for\u00admula. Several runtime \nveri.cation systems follow this ap\u00adproach explicitly or implicitly, including Eagle/Hawk [23], Tracematches \n[2], and PQL[38]. MOP does not prevent the logic designer from employing logics with universal quanti\u00ad.ers: \nonce a logic-plugin is implemented for such a logic, the logic can be immediately used to specify parametric \nproper\u00adties in MOP. For example, Eagle or the publicly available monitoring algorithms of PQL and Tracematches \ncan be or\u00adganized as MOP logic-plugins with little effort. Synthesizing ef.cient monitors from formulae \nin logics allowing quanti.cation is hard. Such monitors need to keep track of all the instances of all \nthe quanti.ed variables. Large hash tables or other similar structures may need to be generated, nested, \ngarbage-collected and accessed multiple times per event, making it dif.cult to maintain an acceptably \nlow runtime overhead in real-life applications. Even if one disallows nested quanti.ers in formulae and \neven if one knows how to monitor an unquanti.ed formula . ef.ciently, it is still non-trivial to monitor \nthe quanti.ed formula (.p.).. We next describe a novel logic-independent technique to support universal, \nnon-nested parameters in speci.cations using any trace-related logics with no need to modify the existing \nmonitoring generation algorithm. One is then able to write parametric speci.cations using any of the \nexisting logic-plugins in MOP. One would expect that such a generic\u00adity must come at a performance price. \nHowever, as shown in Section 6, our generic technique presented next, when used with the ERE logic-plugin, \nproduces signi.cantly less run\u00adtime overhead than Tracematches with all its optimizations (including \nstatic ones) enabled (see Table 4). In our solution, a monitor instance checking the speci.ed property \nwill be created for every speci.c group of values of parameters; if a monitor instance m is created for \na group of values containing o, then we say that m is related to o. For the SafeEnum speci.cation in \nFigure 4, a monitor in\u00adstance will be created for every pair of concrete v and e if e is the enumeration \nof v. When a relevant event occurs, con\u00adcrete values are bound to the event parameters and used to look \nup related monitor instances; related monitors are then invoked to handle the observed event. Several \nmonitors can be triggered by an event since the event may contain fewer parameters than the parameters \nof the enclosing speci.ca\u00adtion. For the SafeEnum example, when an updatesource event occurs, the target \nVector object is bound to the pa\u00adrameter v and used to .nd all the related monitors to process updatesource \n(there may be several enumerations of v). The monitor lookup process is external to the monitor in our \napproach and makes no assumption on the implementa\u00adtion of the monitor; consequently, it is independent \nof the monitor generation algorithm. Also, the monitor does not need to be aware of the parameter information \nand can pro\u00adceed solely according to the observed event. Hence, the mon\u00aditoring process for parametric \nspeci.cations is divided into two parts in MOP: the logic-speci.c monitor (generated by the logic plugin) \nand the logic-independent lookup process (synthesized by the speci.cation processor). Consequently, given \nany logic-plugin, MOP allows one to write parametric speci.cations using that logic with no additional \neffort. Current runtime veri.cation approaches supporting log\u00adics with universal quanti.ers construct \na centralized monitor whose state evolves according to the parameter information contained in received \nevents. Our approach, on the contrary, creates many isolated monitor instances, but it maintains in\u00addexing \ninformation so that it can quickly .nd relevant mon\u00aditors. Experiments (Section 6) show that our decentralized\u00admonitoring \nstrategy performs overall better than the cen\u00adtralized ones. The rest of this section presents two instances \nof our decentralized monitoring technique, both supported by JavaMOP: one using centralized indexing \nand the other using decentralized indexing. 5.1 Centralized Indexing Ef.cient monitor lookup is crucial \nto reduce the runtime overhead. The major requirement here is to quickly locate all related monitors \ngiven a set of parameter instances. Recall that different events can have different sets of parameters: \ne.g., in Figure 4, all three events declare different param\u00adeter subsets. Our centralized indexing algorithm \nconstructs multiple indexing trees according to the event de.nitions to avoid inef.cient traversal of \nthe indexes; more speci.cally, for every distinct set of event parameters found in the speci\u00ad.cation, \nan indexing tree is created to map the set of param\u00adeters directly into the list of corresponding monitors. \nThe number and structure of indexing trees needed for a speci.cation can be determined by a simple static \nanalysis of event parameter declarations. For example, for the paramet\u00adric speci.cation in Figure 4, \nsince there are three different sets of event parameters, namely <v,e>, <v> and <e>,three indexing trees \nwill be created to index monitors, as illus\u00adtrated in Figure 11: the .rst tree uses a pair of v and e \nto .nd the corresponding monitor, while the other two map v and, respectively, e to the list of related \nmonitors. We use hash maps in JavaMOP to construct the indexing tree. Figure 12 shows the generated monitor \nlook up code Map SafeEnum_v_map = makeMap(); pointcut SafeEnum_updatesource0(Vector v) : call(* Vector.add*(..))&#38;&#38; \ntarget(v); after (Vector v) : SafeEnum_updatesource0(v) { Map m = SafeEnum_v_map; Object obj = null; \nobj = m.get(v); if (obj != null){ Iterator monitors = ((List)obj).iterator(); while (monitors.hasNext()) \n{ SafeEnumMonitor monitor=(SafeEnumMonitor)monitors.next(); monitor.updatesource(v); if (monitor.suceeded()) \n{ //validation handler } }//end of while }//end of if } Figure 12. Centralized indexing monitoring code \ngenerated by JavaMOP for updatesource (from spec in Figure 4) for the updatesource event in Figure 4. \nThis code is in\u00adserted at the end of every call to Vector.add or other vec\u00adtor changing methods, according \nto the event de.nition. One parameter is associated to this event, namely, the vector v on which we invoke \nthe method. A map, SafeEnum v map, is created to store the indexing information for v,i.e., the {v}Map \nin Figure 11. When such a method call is encoun\u00adtered during the execution, a concrete vector object \nwill be bound to v and the monitoring code will be triggered to fetch the list of related monitors using \nSafeEnum v map.Then all the monitors in the list will be invoked to process the event. An important question \nis when to create a new monitor instance. This is a non-trivial problem in its full general\u00adity, because \none may need to create partially instantiated monitors when events with fewer parameters are observed \nbefore events with more parameters. While this partial in\u00adstantiation can be achieved in a logic-independent \nmanner, motivated by practical needs we adopted a simpler solu\u00adtion in JavaMOP: we let the logic-plugin \ntell which events are allowed to create new monitors; these events are also required to be parametric \nby all the speci.cation parame\u00adters, such as the create<v,e> event in Figure 4. All MOP s logic-plugins \nhave been extended to mark their monitor\u00adinitialization events. Thus, if an event is generated and a \nmonitor instance for its parameters cannot be found, then a new monitor instance is created for its parameters \nonly if the event is marked; otherwise the event is discarded. This way, no unnecessary monitor instances \nare created; indeed, it would be pointless and expensive to create monitor instances for all vector updates \njust because they can be potentially as\u00adsociated with enumerations monitor instances are created only \nwhen enumerations are actually created. A performance-related concern in our implementation of JavaMOP \nis to avoid memory leaks caused by hash maps: values of parameters are stored in hash maps as key values; \nwhen these values are objects in the system, this might pre\u00advent the Java garbage collector from removing \nthem even when the original program has released all references to them. We use weakly referenced hash \nmaps in JavaMOP.   v.{e} Map v.List e.List   e3 e1 e2   The weakly referenced hash map only maintains \nweak ref\u00aderences to key values; hence, when an object that is a key in the hash map dies in the original \nprogram, it can be garbage collected and the corresponding key-value pair will also be removed from the \nhash map. This way, once a monitor in\u00adstance becomes unreachable, it can also be garbage collected and \nits allocated memory released. Note that a monitor instance will be destroyed only only when it will \nnever be triggered in the future. Since we have an indexing tree per event parameter set, if a monitor \nm can potentially be triggered in the future by some event e with a parameter set (p1, .., pn),where \nn can also be 0, then: 1. m appears in the indexing tree corresponding to the pa\u00adrameters (p1, .., pn); \nthat is also because of our assump\u00adtion/limitation that, when m is created, all its possible pa\u00adrameters, \nincluding p1, ..., pn but potentially more, were available; when m was created, it was added to all the \nin\u00addexing trees corresponding to (subsets of) its parameters, including that of (p1, .., pn);and 2. \nif e is ever generated in the future, m will be referred from the indexing tree for (p1, .., pn). This \nis because if e really occurs at some moment in the future, then p1,.., pn should all be live objects \nand thus the mapping in the corresponding indexing tree has not been destroyed.  Therefore, if a future \nevent can ever trigger m,then m is not garbage collectible. This guarantees the soundness of our usage \nof weak references. One interesting corner case here is when n is 0, i.e., when some event has no parameter. \nIn such case, the corresponding indexing tree (for the empty set of parameters) is actually a list instead \nof a map. Thus, even if all parameters die, the monitor will still be kept alive because there is a reference \nto it in that list. But this only happens when at least one of the events in the speci.cation has no \nparameters. 5.2 Optimization: Decentralized Indexing The centralized-indexing-decentralized-monitor \napproach above can be regarded as a centralized database of monitors. This solution proves to be acceptable \nwrt runtime overhead in many of the experiments that we carried out; in particular, List Vector.SafeEnum_v_List \n= null; pointcut SafeEnum_updatesource0(Vector v) : call(* Vector.add*(..))&#38;&#38; target(v); after \n(Vector v) : SafeEnum_updatesource0(v) { if (v.SafeEnum_v_List != null) { Iterator monitors = (v.SafeEnum_v_List).iterator(); \nwhile (monitors.hasNext()) { SafeEnumMonitor monitor=(SafeEnumMonitor)monitors.next(); monitor.updatesource(v); \nif (monitor.suceeded()) { //validation handler } }//end of while } } Figure 14. Decentralized indexing \nmonitoring code auto\u00admatically generated by JavaMOP for updatesource it compares favorably with centralized-monitor \napproaches (see Figure 15). However, reducing runtime overhead is and will always be a concern in runtime \nveri.cation. We next propose a further optimization based on decentralizing in\u00addexing. This optimization \nis also implemented in JavaMOP. In decentralized indexing, the indexing trees are piggy\u00adbacked into states \nof objects to reduce the lookup overhead. For every distinct subset of parameters that appear as a pa\u00adrameter \nof some event, JavaMOP automatically chooses one of the parameters as the master parameter and uses the \nother parameters, if any, to build the indexing tree using hash maps as before; the resulting map will \nthen be declared as a new .eld of the master parameter. For example, for the updatesource event in Figure \n4, since it has only the <v> parameter, v is selected as master parameter and a new .eld will be added \nto its Vector class to accommodate the list of related monitor instances at runtime. Figure 13 shows \nthe decentralized version of the centralized indexing example in Figure 11, and Figure 14 shows the generated \ndecentralized indexing monitoring code for the updatesource event. Comparing Figures 14 and 12, one can \nsee that the ma\u00adjor difference between the centralized and the decentralized indexing approaches is that \nthe list of monitors related to v can be directly retrieved from v when using decentralized indexing; \notherwise, we need to look up the list from a hash map. Decentralized indexing thus scatters the indexing \nover objects in the system and avoids unnecessary lookup oper\u00adations, reducing both runtime overhead \nand memory usage. It is worth noting that decentralized indexing does not af\u00adfect the behavior of disposing \nunnecessary monitor instances as discussed in the previous section: when an object is dis\u00adposed, all \nthe references to monitor instances based on this object will also be discarded, no matter whether they \nare stored in maps using weak references or whether they are embedded as .elds of the object. On the \nnegative side, decentralized indexing involves more instrumentation than the centralized approach, some\u00adtimes \nbeyond the boundaries of the monitored program, since it needs to modify the original signature of the \nmaster parameter: for the monitoring code in Figure 14, the Java li\u00adbrary class Vector has to be instrumented \n(add a new .eld). This is usually acceptable for testing/debugging purposes, but may not be appropriate \nif we use MOP as a development paradigm and thus want to leave monitors as part of the re\u00adleased program. \nIf that is the case, then one should use cen\u00adtralized indexing instead, using the attribute centralized. \nThe choice of the master parameter may signi.cantly af\u00adfect the runtime overhead. In the speci.cation \nin Figure 4, since there is a one-to-many relationship between vectors and enumerations, it would be \nmore effective to choose the enumeration as the master parameter of the create event. Presently, JavaMOP \npicks the .rst parameter encountered in the analysis of the MOP speci.cation as the master param\u00adeter \nfor each set of event parameters. Hence, the user can control the choice of the master parameter by putting, \nfor each set of parameters P , the desired master parameter .rst in the list of parameters of the .rst \nevent parametric over P . Decentralized indexing is not an entirely new technique for reducing monitoring \noverhead; it is actually a natural ex\u00adtension to our previous MOP framework [21], which stores monitors \nstates as .elds in objects when checking class in\u00advariants, i.e., one-parameter properties. Within the \ncontext of multiple parameters (the major concern of this paper), in\u00addexing information is embedded into \nthe objects instead of states. A similar idea of piggybacking the indexing informa\u00adtion into objects \nstates was proposed in [8], called inter-type declaration , but it had not been implemented when this \npa\u00adper was written.  6. Experiments and Evaluation We have applied JavaMOP on tens of programs, including \nseveral large-scale open source programs, e.g., the DaCapo benchmark suite [14], the Tracematches benchmark \nsuite [8], and Eclipse [25]. Our evaluation mainly focuses on two aspects: the expressivity of the speci.cation \nlanguage and the runtime overhead of monitoring. The properties used in our experiments come from two \nsources: properties used in other works (e.g., [27, 38, 8, 16]) and our own formalization of informal \ndescriptions in software documentation. With the currently supported logic-plugins and the generic support \nfor parameters, JavaMOP is able to formally and concisely express most of the collected properties. One \ninter\u00adesting exception is the SQL injection from PQL [38], which we implemented using the raw MOP speci.cation \nshown in Figure 10. A large portion, nearly half, of the properties that we have tried are recoverable/enforceable. \nMany violations of properties were revealed in our experiments, although we did not focus on error detection; \nwhen violations occurred, we were able to quickly locate their causes using JavaMOP. The rest of this \nsection focuses on performance evalua\u00adtion, on discussing some of the detected violations, and on current \nlimitations of our implementation. 6.1 Performance Evaluation The monitoring code generated by JavaMOP \ncaused low runtime overhead, below 10%, in most experiments even with centralized indexing. By turning \non the decentralized indexing, few experiments showed noticeable runtime over\u00adhead. In what follows, \nwe evaluate JavaMOP s runtime over\u00adhead using the DaCapo benchmark, and also compare Java-MOP with other \nruntime veri.cation techniques, namely, Tracematches and PQL, using the Tracematches benchmark. Our \nexperiments were carried out on a machine with 1GB RAM and P4 2.0Gz processor; the Sun Java HotSpot(TM) \nClient VM (1.5.0 10) on Windows XP professional was used as the running JVM. All the benchmark programs \nand prop\u00aderties discussed in this paper can be downloaded from Java-MOP s website [20]. We used the DaCapo \nbenchmark version 2006-10; it con\u00adtains eleven open source programs [14]: antlr, bloat, chart, eclipse, \nfop, hsqldb, jython, luindex, lusearch, pmd,and xalan. The provided default input was used to\u00adgether \nwith the -converge option to execute the benchmark multiple times until the execution time falls within \na coef.\u00adcient of variation of 3%. The average execution time is then used to compute the runtime overhead. \n6.1.1 Properties The following general properties borrowed from [16] were checked using JavaMOP: 1. SafeEnum: \nDo not update Vector while enumerating its elements using the Enumeration interface (Figure 4); 2. SafeIterator: \nDo not update a Collection when using the Iterator interface to iterate its elements; 3. HashMap: The \nhash code of an object should not be changed when the object is used as a key in a hash map; 4. HasNext: \nAlways call the hasNext() method of an iter\u00adator before calling its next() method; 5. LeakingSync: Only \naccess a Collection via its syn\u00adchronized wrapper once the wrapper is generated by the Collections.synchronized* \nmethods; 6. ClosedReader: Do not read from a Reader if it or its corresponding InputStream has been \nclosed;  More properties have been checked in our experiments; we choose these six properties to include \nin this paper be\u00adcause they generate a comparatively larger runtime over\u00adhead. We excluded those with \nlittle overhead. Three of these properties are recoverable: HashMap (the monitor can main\u00adtain a shadow \nmap based on IdentityHashMap as backup), HasNext (make a call to hasNext() before next()), and LeakingSync \n(redirect call to the synchronized wrapper). For every property, we provided three MOP speci.ca\u00adtions: \nan ERE formal speci.cation, the same formal speci.\u00adcation for centralized indexing, and a (hand-optimized) \nraw MOP speci.cation. The last one is supposedly the best mon\u00aditoring code for that property and was \nused to evaluate the effectiveness of our monitor generation algorithm. The As\u00adpectJ compiler 1.5.3 (AJC) \nwas used in these experiments to compile the generated monitoring AspectJ code.  6.1.2 Statistics and \nResults of the Evaluation Tables 1 and 2 show the instrumentation and monitoring statistics for monitoring \nthe above properties in DaCapo: Ta\u00adble 1 gives the number of points statically instrumented for monitoring \neach of the properties; Table 2 gives the num\u00adber of events and the number of monitor instances generated \nat runtime using centralized indexing. Both these numbers are collected from a single execution of the \nbenchmark. The .rst row in each table gives the names of the properties, and the .rst column in Table \n2 gives the programs. We do not split the static instrumentation points by different programs because \nthey are merged together in the benchmark suite; some of them even share common packages. Decentralized \nindexing does not change the number of generated events or monitor instances; it only affects the monitor \nindexing. These two tables show that the properties selected in our experiments imposed heavy runtime \nmonitoring on the pro\u00adgrams: a large number of points, ranging from one thou\u00adsand to twelve thousand, \nin the original programs were in\u00adstrumented to insert the monitoring code. The monitoring code was frequently \ntriggered during the execution, espe\u00adcially for those properties involving the Java Collection classes, \ne.g., SafeIterator, HashMap,and HasNext.Some properties generated numerous runtime checks but only a \nfew, even zero, monitor instances were created (e.g., SafeEnum and LeakingSync). The reason is that these \nproperties observe some frequently visited methods, but the events that we allowed to create monitor \ninstances rarely or never occurred. For example, LeakingSync checks all the method calls on the Collection \ninterface, but no calls to Collections.synchronized* methods happened in these experiments, so no monitor-initialization \nevents were created. Such experiments are particularly useful to evaluate the effectiveness of the generated \nmonitoring code to .lter dynamically irrelevant events, i.e., events that have no effect on the current \nmonitor states. Also, a big difference between the number of events and the number of created monitor \ninstances (e.g., jython-SafeEnum and bloat-Leakingsync) indicates a real potential for static analysis \noptimizations. Table 3 summarizes the runtime overhead measured in our experiments, represented as a \nslowdown percentage of the monitored program over the original program. For ev\u00adery property-program combination, \nthree monitoring run\u00adtime overhead numbers are given: with centralized indexing, with decentralized indexing, \nand using a hand-optimized raw MOP speci.cation. Among all 66 experiments (recall that we already excluded \nsome results with little overhead), only 11 (bold) caused more than 10% slow-down with centralized indexing; \nfor the decentralized indexing version, this number reduces to 4. Except for the 4 worst cases, with \ndecentralized indexing JavaMOP generates monitoring code almost as ef\u00ad.cient as the hand-optimized code. \n SafeEnum SafeIterator HashMap HasNext LeakingSync ClosedReader DaCapo 1147 5663 1729 2639 12855 2966 \n Table 1. Instrumentation statistics: instrumentation points in the DaCapo benchmark SafeEnum SafeIterator \nHashMap HasNext LeakingSync ClosedReader antlr 10K 0 1K 0 0 0 0 0 233K 0 3M 1K bloat 0 0 90M 1M 391K \n46K 155M 1M 6M 0 11K 0 chart 57 0 569K 815 8K 3K 6K 815 653K 0 208 2 eclipse 16K 0 38K 31 31K 19K 1K \n31 230K 0 29K 165 fop 7 1 49K 79 17K 6K 277 79 3M 0 1K 3 hsqldb 174 0 0 0 0 0 0 0 686 0 0 0 jython 50K \n0 174K 50 443 439 106 50 16M 0 1M 114 luindex 457K 14K 82K 8K 9K 9K 28K 8K 3M 0 19K 0 lusearch 335K 0 \n405K 0 416 416 0 0 1M 0 2M 0 pmd 717 0 25M 1M 11K 105 46M 8M 26M 0 28K 4 xalan 5K 0 119K 0 124K 78K 0 \n0 682K 0 98K 1K Table 2. Monitoring statistics: generated events(left column) and monitor instances(right \ncolumn). K = \u00d7103,M= \u00d7106 SafeEnum SafeIterator HashMap HasNext LeakingSync ClosedReader antlr 0.0 0.0 \n1.5 0.0 0.0 0.0 0.0 0.0 1.1 0.0 0.4 0.0 2.7 0.0 0.0 22.1 5.8 0.0 bloat 2.4 0.0 0.0 385 176 24.2 2.4 1.8 \n1.4 323 154 36.3 13.5 3.2 2.2 0.1 0.0 2.3 chart 0.0 0.0 0.0 0.3 0.0 0.0 4.8 3.6 4.8 0.0 0.0 0.0 0.1 0.5 \n0.0 0.0 0.0 0.0 eclipse 2.4 4.1 0.8 0.0 0.0 1.4 3.6 3.7 0.5 0.0 3.8 1.5 0.8 3.0 3.1 0.6 2.2 2.4 fop 0.4 \n1.2 0.6 1.7 1.5 0.0 0.0 0.0 0.0 1.7 0.8 1.5 14.7 0.5 1.0 1.9 0.0 0.0 hsqldb 0.0 3.3 0.0 0.0 0.9 1.2 0.0 \n0.0 2.1 0.0 0.8 0.0 1.1 1.4 1.4 1.6 0.0 0.0 jython 0.5 0.6 0.0 1.6 0.8 0.5 0.7 0.2 0.3 1.3 0.0 0.6 30.2 \n0.0 2.3 0.7 0.4 0.2 luindex 2.6 1.6 0.2 3.2 1.9 0.5 0.6 1.2 1.8 0.9 0.3 0.0 4.3 3.2 2.2 1.1 1.7 1.1 lusearch \n6.6 0.5 0.0 9.5 0.0 0.0 0.0 0.0 0.0 0.0 0.3 0.0 32.4 1.1 0.6 75.7 0.0 0.1 pmd 0.0 0.0 0.0 272 44.8 11.3 \n0.5 0.0 0.0 353 25.4 13.7 34.3 5.4 8.0 0.0 0.0 0.0 xalan 0.0 3.5 4.4 4.8 6.7 5.4 7.2 4.7 6.5 4.6 0.0 \n2.8 3.0 1.5 1.7 8.5 2.2 4.5 Table 3. Runtime overhead (in percentage; e.g., 14.7 means 14.7% slower) \nof JavaMOP: centralized | decentralized | raw Analyzing Tables 3 and 2, one can see that decentralized \nindexing handles the dynamically irrelevant events much better than centralized indexing, e.g., when \nchecking the LeakingSync property. This is caused by the fact that, when there is no related monitor \ninstance, decentralized index\u00ading only checks an object .eld, while centralized indexing needs to make \nan expensive hash map lookup. The run\u00adtime overhead is determined not only by the frequency of reaching \nmonitoring code, but also by the execution time of the monitored action. For example, HashMap required \nquite heavy monitoring on many programs but did not cause any noticeable performance impact. This is \nbecause the methods checked for HashMap, including put, remove,and contains, are relatively slow. On \nthe other hand, checking bloat and pmd against SafeIterator and HasNext is as bad as it can be: the monitored \nactions take very little time to execute (e.g., the hasNext and next methods of Iterator) and they are \nused very intensively during the execution (in\u00addicated by the massive numbers in Table 2). Even for such \nextreme cases, the monitoring code generated by JavaMOP with decentralized indexing may be considered \nacceptable: slowdown between 2 and 3 times. However, one can always choose to implement a hand-optimized \nraw MOP speci.ca\u00adtion for the property of interest; in our case, the raw MOP speci.cation reduced the \nruntime overhead to only 20-30%.  6.1.3 Comparing JavaMOP, Tracematches, and PQL Attempts have also \nbeen made to compare JavaMOP with other existing trace monitoring tools. However, some of them are not \npublicly available, others have limitations that prevented us from using them in our experiments. Con\u00adsequently, \nwe only succeeded to compare JavaMOP thor\u00adoughly with Tracematches and partially with PQL. As shown in \n[6], Tracematches is one of the most ef.cient and mature trace monitoring tools to date. A benchmark \nfor trace monitoring tools and experiments has been proposed by the Tracematches team in [8] (a March \n2006 version pro\u00advided with ABC 1.2.12), containing eight property-program combinations. Detailed explanations \nof these properties and programs can be found in [8, 9]; one of them had 0 runtime overhead and apparently \nwas not intended to measure run\u00ad 2 The Tracematches numbers in Table 4 were actually obtained using a \nrecent experimental Tracematches implementation provided to us by its developers before the .nal version \nof this paper. Property Program LOC Original (seconds) Hand Optimized JavaMOP JavaMOP-CI TM PQL Listener \najHotDraw 21.1K 1.3 0.0 6.7* 139.3 354.0 2193.3 SafeEnum jHotDraw 9.5K 3.3 0.1 136.3 509.1 1509.1 7084.8 \nNullTrack CertRevSim 1.4K 0.12 210.1 - 232.0 452.7 n/a Hashtable Weka 9.9K 2.8 3.3 3.3 6.7 15.2 n/a HashSet \nAprove 438.7K 560.0 21.2 23.9 51.9 124.3 n/a Reweave ABC 51.2K 7.0 11.1 - 20.2 63.5 n/a Table 4. Runtime \noverhead (in %) for JavaMOP, Tracematches, and PQL on the Tracematches Benchmark. (*: A class\u00adscoped \nspeci.cation was used. -: Decentralized indexing monitoring cannot be applied for these properties because \nit requires instrumentation on non-modi.able classes in Java, e.g., Object and String.) time overhead, \nand another makes use of an ABC-speci.c feature (stack access, not provided by AJC) that we de\u00adcided \nnot to support in order to keep JavaMOP compiler\u00adindependent. Table 4 shows the results that we obtained \nfor the other six property-program combinations. These experi\u00adments were run on the same machine mentioned \nabove. Each program was executed .ve times and the average running time was used in computing the runtime \noverhead. The .rst two columns in Table 4 list the properties and the programs; the third column gives \nthe sizes of the pro\u00adgrams; the fourth shows the running time of the original, unmonitored program; the \nremaining columns give the run\u00adtime overhead caused by hand-optimized monitors, (decen\u00adtralized indexing) \nJavaMOP monitors, centralized indexing JavaMOP monitors, Tracematches monitors, and PQL mon\u00aditors. We \ntake no credit for the hand-optimized code: it was implemented by Tracematches developers using AspectJ \nand offered with the benchmark. The Tracematches properties were also contained in the benchmark package. \nTo achieve a direct comparison, all the MOP speci.cations used the ERE logic-plugin and were essentially \nidentical to the Trace\u00admatches speci.cations. The Tracematches speci.cations and the monitoring code \ngenerated by JavaMOP were compiled with the ABC compiler [7] for direct comparison. Due to im\u00adplementation \nlimitations of PQL, only two properties could be speci.ed using PQL; we could not apply the static ana\u00adlyzer \nin the PQL distribution due to lack of documentation. Two properties in these experiments, NullTrack \nand Reweave, involve non-modi.able Java classes (Object and String) as parameters. Consequently, the \ngenerated decen\u00adtralized indexing code cannot be weaved into the original programs. In such cases, we \napplied only centralized index\u00ading monitoring. Also, for the Listener property, we used a class invariant \nfor the decentralized mode equivalent to the two-parameter speci.cation proposed by Tracematches (and \nchecked in the centralized mode), resulting in a signif\u00adicant performance difference between the two \nmodes. This strengthens our belief that one should be provided the free\u00addom to choose what suits one \ns needs most, in particular one should not have to write parametric speci.cations if the property is \nessentially a class invariant. Table 4 shows that JavaMOP generates more ef.cient monitoring code than \nTracematches and PQL, often close to the hand-optimized code when using decentralized indexing. Since \nJavaMOP generates standard AspectJ code, it gives us the freedom to choose off-the-shelf compilers. In \nour experiments, ABC tended to take more time to compile the code than AJC, e.g., it took ABC nearly \nan hour to compile Aprove but AJC needed only a few minutes. PQL and Tracematches have their own strengths \nand the above comparison should not be interpreted as an argument against them. PQL provides a general \nspeci.cation formal\u00adism extending context-free grammars; it is therefore not sur\u00adprising that it generates \na larger runtime overhead. Trace\u00admatches implements a sound and specialized algorithm to support universally \nquanti.ed regular patterns. The paramet\u00adric framework discussed in our paper is generic and logic\u00adindependent, \ntherefore the present JavaMOP implementation does not provide any logic-speci.c optimizations or special\u00adizations \nlike those in Tracematches. The paper [9] discusses in some depth differences be\u00adtween JavaMOP[ERE,inline,validation,centralized]and \nTrace\u00admatches, and also shows the results of their performance comparison between the two systems on \nthe same property\u00adprogram pairs as ours. However, their numbers are rather different. Brie.y, the results \nin [9] show that JavaMOP-CI and Tracematches overall have comparable runtime over\u00adheads, while our experiments \nshow that JavaMOP-CI pro\u00adduces signi.cantly less overhead than Tracematches. The explanation derived \nfrom discussions with the Tracematches developers is that these apparently con.icting results are mainly \ncaused by the different JVM implementations on Linux and Windows. However, it also appears that a new \nfeature, frequency , supported by an experimental, not-yet\u00adpublic implementation of Tracematches was \nutilized in their experiments. This feature allows one to manually tune a speci.cation to reduce the \nruntime overhead. Because the Tracematches benchmark suite does not make use of this feature, because \nof its limited bene.t (it only helps in the case of SafeEnum), and ultimately because it and an exam\u00adple \nusing it were made available to us only the day before the deadline for the .nal version of this paper, \nwe have not considered it in our experiments yet.  6.1.4 Comparing JavaMOP and Statically Optimized \nTracematches An important advantage of building a runtime veri.cation tool on top of an instrumentation \npackage, like Tracematches and PQL do, is that one can have more control over instru\u00admentation and thus \nfacilitate the use of static analysis. A static analyzer has been recently proposed for Tracematches \nin [16] 3 and it was also evaluated on the property-program combinations using the DaCapo benchmark. \nThis allows for another comparison, between JavaMOP and Tracematches with static analysis. The results \nare shown in Figure 15. Figure 15. Runtime overhead of JavaMOP and Trace\u00admatches on DaCapo (CI: centralized \nindexing; TM: Trace\u00admatches; TM-static: TM with static analysis). The runtime overhead is represented \nas the ratio of monitored execution over non-monitored execution; e.g., 1 means no overhead and 10 means \nten times slower. Figure 15 compares those examples with more than 10% overhead in Table 3 or more then \n20% for Tracematches without static analysis according to [16]. We did not re\u00adpeat the 16 experiments \nfor Tracematches in our environ\u00adment, and all the numbers for Tracematches are taken from [16]. Without \nusing static analysis, Tracematches caused less overhead than centralized JavaMOP monitors in four cases \n(Jython-LeakingSync, lusearch-ClosedReader, pmd-SafeIterator, and pmd-HasNext), and it was always less \n3 a newer static analysis was proposed [17] after our paper was .nalized ef.cient than decentralized \nJavaMOP monitors. After us\u00ading static analysis to eliminate unnecessary instrumentation points, there \nare still three cases (bloat-SafeIterator, bloat-HasNext, and pmd-HasNext) in which JavaMOP outper\u00adformed \nTracematches, while for the others both systems had similar performance. We are not arguing against static \nanalysis; on the contrary, we believe that static analysis can and should be combined with MOP to further \nreduce the runtime overhead, but that is out of the scope of this paper.  6.2 Violation Detection As \nmentioned, error detection was not the main focus in our experiments; we consider that, for error detection, \nruntime veri.cation needs to be combined with test case generation. However, we still encountered unexpectedly \nmany violations during the evaluation of JavaMOP. One reason is that many safety properties in our experiments \nwere devised for check\u00ading performance, and are therefore not strictly required to hold in all programs. \nConsequently, many violations do not lead to actual errors in the program. For example, violations of \nthe hasNext property were found in some Java library classes, e.g., AbstractCollection and TreeMap. It \nturned out that these implementations use the size of the collection instead of the hasNext method to \nguard the iteration of ele\u00adments. We also found violations indicating possible semantic problems of programs, \nwhich are subtle and thus dif.cult to .nd by ordinary testing. We next discuss some of these. 6.2.1 Potential \nErrors. There is a known problem in jHotDraw about using objects of Enumeration: one can edit a drawing, \nwhich may update a vector in the program, while making the animation for the drawing, which uses an enumerator \nof the vector. As expected, JavaMOP was able to .nd this problem. We also found violations of some interface \ncontracts, i.e., rules to use interfaces, in Eclipse. These can lead to resource leaks as pointed out \nin [27] and [38]. Three kinds of properties were checked in our Eclipse experiments: 1. The dispose method \nneeds to be called to release ac\u00adquired resources before a GUI widget is .nalized. 2. The remove*Listener \nshould be called by a host object to notify its listeners (registered by calling add*Listener) to release \nresources before it is .nalized. * represents the name of the listener. 3. Eclipse uses Lucene [37] \nas its search engine; in Lucene, it is required that, before a Dir object is closed (by calling its close \nmethod), all the .le readers created by the Dir object should be closed.  We instrumented the GUI package \nof Eclipse with these three properties and also the JDT package with the second property (note that there \nare many different add*Listener\u00adremove*Listener pairs in these two packages). Then we used the instrumented \nEclipse in our development work (no noticeable slow-down was experienced during the evalua\u00adtion). More \nthan 30 violations were detected in the GUI package, while none was found in the JDT package this may \nindicate the importance of the second property. In sum\u00admary, the GUI package, which is more complex and \nharder to test, seems less reliable w.r.t. to memory leaks. 6.2.2 Inappropriate Programming Practice \nSeveral unexpected violations were encountered during our experiments. For example, we ran into some \nviolations in Xalan [42] when checking a simple property about the Writer class in Java: no writes can \noccur after the writer is closed (by calling the close method). This is, according to the Java documentation \nwhich states that an exception should be raised, a must-have property. Despite these vio\u00adlations, no \nerrors occurred in Xalan. Using JavaMOP, we located the places causing the violations without much in\u00adsight \nof the program and a quick review showed that a pool of writer instances is used in Xalan to avoid unnecessary \nre\u00adcreations, but the writer can be closed before it is returned to the pool. However, the program uses \nStringWriter, whose close method happens to have no effect. Although it is not an error in this implementation, \nwe believe that it is inappro\u00adpriate programming practice: the writer should be cleared instead of closed \nwhen returned to the pool.  6.3 Limitations of MOP and JavaMOP The current MOP logic-plugins encapsulate \nmonitor synthe\u00adsis algorithms only for non-parametric trace logics. Even though the new MOP speci.cation \nlanguage allows univer\u00adsal parameters to be added to any of these logics, there is no way to add nested \nparameters, or existential ones. We intend to soon add a logic-plugin for Eagle [12], a super-logic generalizing \nboth ERE and LTL, and also allowing arbitrary quanti.cation and negation, but do not expect it to have \na stimulating runtime overhead. Our current JavaMOP implementation assumes that, in a parametric speci.cation, \nthe events marked by the logic\u00adplugin to create monitor instances contain all the parameters of the speci.cation. \nThis limitation can be avoided by imple\u00admenting a more complicated monitor creation strategy; how\u00adever, \nwe were not motivated to it because all the properties that we have checked so far fall under this restriction. \nThe gap between dynamic events for monitoring and static monitor integration based on AOP can lead to \nsome limitations of MOP tools. Ideally, for variable update events, the MOP tool should instrument all \nthe updates of involved variables. But, statically locating all such updates requires precise alias analysis. \nTherefore, JavaMOP only allows up\u00addate events for variables of primitive types. In addition, static instrumentation \nmay cause extra performance penalty of monitoring. For the speci.cation in Figure 4, one can see that \nthe monitor is not interested in next events af\u00adter create until an updatesource event is encountered. \nBut since we instrument the program statically, the monitor keeps receiving next events even when they \nare not needed. These limitations may be relaxed by utilizing dynamic AOP tools, but more discussion \non this direction is out of the scope of this paper. However, since MOP can also be used to add new functionality \nto a program, one may not want to miss any related event: some action may be executed even when the event \ndoes not affect the monitor state.  7. Conclusion We presented a generic, logic-independent approach \nto sup\u00adport parametric speci.cations in Monitoring-Oriented Pro\u00adgramming (MOP). A novel optimization \ntechnique, called decentralized indexing, was proposed to reduce the runtime overhead of monitoring parametric \nproperties. A new, en\u00adriched MOP speci.cation language was also proposed, that supports parameters and \nraw speci.cations; one can use raw MOP speci.cations to fully implement and control the de\u00adsired monitoring \nprocess using the target programming lan\u00adguage. An extensive evaluation of JavaMOP and compar\u00adisons with \nother runtime veri.cation tools have been car\u00adried out; results are encouraging: less than 8% experiments \nshowed more than 10% runtime overhead, and JavaMOP generated overall more ef.cient monitoring code than \nother runtime veri.cation tools. The techniques presented in this paper are purely dy\u00adnamic. Although \nwe showed that runtime veri.cation is fea\u00adsible, we also believe that static analysis can and should \nbe used to further reduce the runtime overhead of moni\u00adtoring: by statically analyzing the program against \nthe de\u00adsired property, one can eliminate irrelevant instrumentation points. Since static analysis is \nclosely related to the particu\u00adlar logic-plugin, to add static analysis to MOP we will prob\u00adably need \nstatic logic-plugins. Also, MOP can be combined with test generation techniques to provide an effective \ntest\u00ading framework for safety properties. Acknowledgments. We would like to warmly thank the cur\u00adrent \nTracematches team, namely Pavel Avgustinov, Julian Tibble, and Oege de Moor, for developing and making \npub\u00adlic the challenging Tracematches benchmark, as well as for a series of insightful discussions while \npreparing the .nal versions of our papers. We would also like to thank Eric Bodden, Laurie Hendren and \nOndrej Lhotak for their con\u00adtributions on the Dacapo-based benchmark suite that made the comprehensive \nevaluation of JavaMOP possible.  References [1] P. Abercrombie and M. Karaorman. jContractor: Bytecode \ninstrumentation techniques for implementing DBC in Java. In RV 02, volume 70.4 of ENTCS, 2002. [2] C. \nAllan, P. Avgustinov, A. S. Christensen, L. Hendren, S. Kuzins, O. Lhotak, O. de Moor, D. Sereni, G. \nSittampalam, and J. Tibble. Adding trace matching with free variables to AspectJ. In OOPSLA 05, 2005. \n[3] C. Anley. Advanced SQL injection in SQL server applica\u00adtions. NGSSoftware, 2002. [4] AspectC++. http://www.aspectc.org/. \n[5] C. Artho, D. Drusinsky, A. Goldberg, K. Havelund, M. Lowry, C. Pasareanu, G. Rosu, and W. Visser. \nExper\u00adiments with test case generation and runtime analysis. In ASM 03, volume 2589 of LNCS, pages 87 \n107, 2003. [6] P. Avgustinov, E. Bodden, E. Hajiyev, L. Hendren, O. Lhotak, O. de Moor, N. Ongkingco, \nD. Sereni, G. Sittampalam, J. Tibble, and M. Verbaere. Aspects for trace monitoring. In FATES/RV 06, \nvolume 4262 of LNCS, pages 20 39, 2006. [7] P. Avgustinov, A. S. Christensen, L. Hendren, S. Kuzins, \nJ. Lhotak, O. Lhotak, O. de Moor, D. Sereni, G. Sittampalam, and J. Tibble. ABC: an extensible AspectJ \ncompiler. In AOSD 05, 2005. [8] P. Avgustinov, J. Tibble, E. Bodden, O. Lhotak, L. Hendren, O. de Moor, \nN. Ongkingco, and G. Sittampalam. Ef.cient Trace Monitoring. Technical Report abc-2006-1, Oxford University, \n2006. [9] P. Avgustinov, J. Tibble, and O. de Moor. Making Trace Monitors Feasible. In OOPSLA 07, 2007. \nthis volume. [10] M. Barnett, K. R. M. Leino, and W. Schulte. The Spec# programming system: An overview. \nIn CASSIS 04, volume 3362 of LNCS, pages 49 69, 2004. [11] H. Barringer, B. Finkbeiner, Y. Gurevich, \nand H. Sipma. Runtime Veri.cation (RV 05). Elsevier, 2005. ENTCS 144. [12] H. Barringer, A. Goldberg, \nK. Havelund, and K. Sen. Rule-Based Runtime Veri.cation. In VMCAI 04, volume 2937 of LNCS, pages 44 57, \n2004. [13] D. Bartetzko, C. Fischer, M. Moller, and H. Wehrheim. Jass -Java with Assertions. In RV 01, \nvolume 55.2 of ENTCS, 2001. [14] S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, K. S. McKinley, \nR. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, H. Lee, \nJ. E. B. Moss, A. Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, D. von Dincklage, and B. Wiedermann. The \nDaCapo benchmarks: Java benchmarking development and analysis. In OOPSLA 06, 2006. [15] E. Bodden. J-LO, \na tool for runtime-checking temporal assertions. PhD thesis, RWTH Aachen University, 2005. [16] E. Bodden, \nL. Hendren, and O. Lhot\u00b4ak. A staged static program analysis to improve the performance of runtime monitoring. \nIn ECOOP 07, volume 4609 of LNCS, pages 525 549, 2007. [17] E. Bodden, P. Lam, and L. Hendren. Flow-sensitive \nstatic optimizations for runtime monitors. Technical Report abc\u00ad2007-3, Oxford University, 2007. [18] \nF. Chen,M.D Amorim, and G.Ros\u00b8u. A formal monitoring\u00adbased framework for software development and analysis. \nIn ICFEM 04, volume 3308 of LNCS, pages 357 373, 2004. [19] F. Chen,M.D Amorim, andG.Ros\u00b8u. Checking \nand correcting behaviors of Java programs at runtime with JavaMOP. In RV 05, volume 144(4) of ENTCS, \n2005. [20] F. Chen and G. Ros\u00b8u. JavaMOP. http://fsl.cs.uiuc.edu/javamop. [21] F. Chen and G. Ros\u00b8u. \nTowards monitoring-oriented program\u00adming: A paradigm combining speci.cation and implementa\u00adtion. In RV \n03, volume 89(2) of ENTCS, 2003. [22] F. Chen and G. Ros\u00b8u. Java-MOP: A monitoring oriented programming \nenvironment for Java. In TACAS 05, volume 3440 of LNCS, pages 546 550, 2005. [23] M. d Amorim and K. \nHavelund. Event-based runtime veri.cation of Java programs. In International Workshop on Dynamic analysis \n(WODA 05), 2005. [24] D. Drusinsky. Temporal Rover. http://www.time-rover.com. [25] Eclipse. http://eclipse.org. \n[26] Eiffel Language. http://www.eiffel.com/. [27] S. Goldsmith, R. O Callahan, and A. Aiken. Relational \nqueries over program traces. In OOPSLA 05, 2005. [28] K. Havelund and G. Ros\u00b8u. Monitoring Java programs \nwith Java PathExplorer. In RV 01, volume 55.2 of ENTCS, 2001. [29] K. Havelund and G. Ros\u00b8u. Runtime \nVeri.cation (RV 01, RV 02, RV 04). Elsevier, 2001, 2002, 2004. ENTCS 55, 70, 113. [30] C. Hoare. Communicating \nSequential Processes. Prentice-Hall Intl., New York, 1985. [31] JBoss. http://www.jboss.org. [32] jHotdraw. \nhttp://www.jhotdraw.org. [33] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda, C. Lopes, J.-M. Loingtier, \nand J. Irwin. Aspect-oriented programming. In ECOOP 97, volume 1241 of LNCS, pages 220 242, 1997. [34] \nG. Kiczales, J. D. Rivieres, and D. G. Bobrow. The Art of the Metaobject Protocol. MIT Press, 1991. [35] \nM. Kim, S. Kannan, I. Lee, and O. Sokolsky. Java-MaC: a Runtime Assurance Tool for Java. In RV 01, volume \n55.2 of ENTCS, 2001. [36] G. T. Leavens, K. R. M. Leino, E. Poll, C. Ruby, and B. Jacobs. JML: notations \nand tools supporting detailed design in Java. In OOPSLA 00, 2000. [37] Lucene. http://lucene.apache.org. \n[38] M. Martin, V. B. Livshits, and M. S. Lam. Finding application errors and security .aws using PQL: \na program query language. In OOPSLA 05, 2005. [39] B. Meyer. Object-Oriented Software Construction, 2nd \nedition. Prentice Hall, New Jersey, 2000. [40] M. Rinard. Acceptability-oriented computing. In Onward! \nTrack, OOPSLA 03, 2003. [41] O. Sokolsky and M. Viswanathan. Runtime Veri.cation (RV 03). Elsevier, 2003. \nENTCS 89. [42] Xalan. http://xml.apache.org/xalan-j/. \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Monitoring-Oriented Programming (MOP1) [21, 18, 22, 19] is a formal framework for software development and analysis, in which the developer specifies desired properties using definable specification formalisms, along with code to execute when properties are violated or validated. The MOP framework automatically generates monitors from the specified properties and then integrates them together with the user-defined code into the original system.</p> <p>The previous design of MOP only allowed specifications without parameters, so it could not be used to state and monitor safety properties referring to two or more related objects. In this paper we propose a <i>parametric specification formalism-independent extension of MOP</i>, together with an implementation of JavaMOP that supports parameters. In our current implementation, parametric specifications are translated into AspectJ code and then weaved into the application using off-the-shelf AspectJ compilers; hence, MOP specifications can be seen as formal or logical aspects.</p> <p>Our JavaMOP implementation was extensively evaluated on two benchmarks, Dacapo [14] and Tracematches [8], showing that runtime verification in general and MOP in particular are feasible. In some of the examples, millions of monitor instances are generated, each observing a set of related objects. To keep the runtime overhead of monitoring and event observation low, we devised and implemented a <i>decentralized indexing</i> optimization. Less than 8% of the experiments showed more than 10% runtime overhead; in most cases our tool generates monitoring code as efficient as the hand-optimized code. Despite its genericity, JavaMOP is empirically shown to be more efficient than runtime verification systems specialized and optimized for particular specification formalisms. Many property violations were detected during our experiments; some of them are benign, others indicate defects in programs. Many of these are subtle and hard to find by ordinary testing.</p>", "authors": [{"name": "Feng Chen", "author_profile_id": "81339493441", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL", "person_id": "PP40039801", "email_address": "", "orcid_id": ""}, {"name": "Grigore Ro&#351;u", "author_profile_id": "81100069676", "affiliation": "University of Illinois at Urbana-Champaign, Urbana, IL", "person_id": "P712925", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297069", "year": "2007", "article_id": "1297069", "conference": "OOPSLA", "title": "Mop: an efficient and generic runtime verification framework", "url": "http://dl.acm.org/citation.cfm?id=1297069"}