{"article_publication_date": "10-21-2007", "fulltext": "\n Type Quali.er Inference for Java David Green.eldboyce Jeffrey S. Foster University of Maryland, College \nPark University of Maryland, College Park dgreen.@cs.umd.edu jfoster@cs.umd.edu Abstract Java s type \nsystem provides programmers with strong guar\u00adantees of type and memory safety, but there are many im\u00adportant \nproperties not captured by standard Java types. We describe JQual, a tool that adds user-de.ned type \nquali.ers to Java, allowing programmers to quickly and easily incor\u00adporate extra lightweight, application-speci.c \ntype checking into their programs. JQual provides type quali.er inference, so that programmers need only \nadd a few key quali.er anno\u00adtations to their program, and then JQual infers any remaining quali.ers and \nchecks their consistency. We explore two ap\u00adplications of JQual. First, we introduce opaque and enum \nquali.ers to track C pointers and enumerations that .ow through Java code via the JNI. In our benchmarks \nwe found that these C values are treated correctly, but there are some places where a client could potentially \nviolate safety. Sec\u00adond, we introduce a readonly quali.er for annotating refer\u00adences that cannot be used \nto modify the objects they refer to. We found that JQual is able to automatically infer readonly in many \nplaces on method signatures. These results suggest that type quali.ers and type quali.er inference are \na useful addition to Java. Categories and Subject Descriptors D.2.4 [Software Engi\u00adneering]: Software/Program \nVeri.cation Validation; D.3.2 [Programming Languages]: Language Classi.cations Ob\u00adject-oriented languages; \nF.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages Program analysis General \nTerms Languages, Veri.cation Keywords JQual, Java, type quali.ers, readonly, muta\u00adble, opaque, transparent, \ntracked, context-sensitivity, .eld\u00adsensitivity, context-free language reachability Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, \n2007, Montr\u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; 2007 ACM 978-1-59593-786-5/07/0010. . . $5.00. \n1. Introduction The Java programming language has a strong type system that can be used to enforce useful \nprogram properties. How\u00adever, many important properties can be hard to encode as standard types, and \nit may be dif.cult to incorporate new properties into the type hierarchy of an existing program. To address \nthis problem we present JQual, a tool for in\u00adferring user-de.ned type quali.ers in Java. A type quali.er \nis an atomic property that re.nes a standard type. For exam\u00adple, we have used JQual to add opaque, a \nnew type quali.er, to programs that use the JNI. The opaque quali.er anno\u00adtates Java ints that actually \nrepresent C pointer values. Us\u00ading JQual, we can enforce the integrity property that ordinary Java integers, \nwhich we qualify with transparent, are never passed to opaque positions, since then they might mistak\u00adenly \nbe treated as pointers and dereferenced. This example is a fairly typical use of type quali.ers, in which \nthe pro\u00adgrammer knows some extra properties about certain values, but those values are not distinguished \nby the standard types. In JQual, type quali.ers can be applied to any type. For example, we also used \nJQual to infer a readonly quali.er, based on Javari [8, 47]. For any class C, a reference of type readonly \nC may not be used to modify the object it refers to, which is a particularly useful annotation for method \nargu\u00adments and results. One interesting feature of readonly is that it is sticky across .eld access: \nIf x is readonly, then so is x.f. Thus type quali.ers can propagate in ways that ordinary types do not, \nin this case from a reference to the object to which it refers. When users specify their type quali.ers \nto JQual, they supply a subtyping order that relates sets of quali.ers. For example, mutable references, \nwhich are ordinary, writable Java references, can be passed to readonly positions, but not vice-versa, \nand so mutable < readonly. The addition of sub\u00adtyping makes quali.er inference more .exible, and support\u00ading \nsubtyping on quali.ers in a language with subclassing seems very natural. The key feature of JQual is \ntype quali.er inference, which allows programmers to add a few quali.er annotations to their program, \nand then JQual infers the remaining quali.ers and checks their consistency. We formalize type quali.er \ninference as a system called Core JQual, which operates on a variant of Featherweight Java [22] with \noptional type quali.er annotations. Core JQual is context-insensitive and .eld-based, mean\u00ading all instances \nof a class share the same .eld types. We ex\u00adtend Core JQual to FS JQual, which adds .eld-sensitivity, \nin which each instance of an object has its own .eld types. The key feature of FS JQual is that .eld-sensitivity \nis selective the programmer speci.es which .elds should be treated .eld-sensitively, and which .elds \nshould not. This greatly improves performance over a full .eld-sensitive analysis, and we have generally \nfound it is easy to identify which .elds should be made .eld-sensitive. We further extend our formalism \nto CS/FS JQual, which supports both .eld-and context-sensitivity. We introduce context-sensitivity by \nen\u00adcoding it as a context-free language reachability problem on a constraint graph [36, 38]. Context-sensitivity \nis especially important for a .eld-sensitive analysis, so that object types are not con.ated by common \nconstructors and methods. We have implemented JQual as an Eclipse plug-in [17], and we used JQual for \nthe two applications mentioned above. First, we applied opaque inference to a number of libraries that \nuse the JNI, using a simple C analysis to add the necessary opaque quali.ers to native method signatures. \nFor this analysis, we also inferred enumi quali.ers, which mark integer values in the range [0..i], and \nwhich ensure that only integers in the expected range are passed to C enums. We found that context-and \n.eld-sensitivity were critical in reducing the warning counts to reasonable levels. Across our benchmarks, \nmost opaque and all enum-quali.ed inte\u00adgers were used safely, but we found several places where opaque \nintegers are exposed outside the library code, and hence could be compromised by careless clients. Second, \nwe applied readonly inference to a variety of Java programs, including SPEC benchmarks [2] and programs \ndownloaded from SourceForge [1]. We also inferred .nal an\u00adnotations on these programs at the same time. \nUsing context\u00adinsensitive, .eld-based analysis, JQual inferred that 48% of non-primitive method arguments \nand results are readonly, and 29% of .elds are .nal. Added .eld-sensitivity for library container classes \nand context-sensitivity increased readonly to 62% of the positions and .nal to 42% of the .elds. Over\u00adall, \nJQual was able to infer many interesting uses of readonly across the benchmarks. In summary, the main \ncontributions of this work are: We introduce opaque and transparent quali.ers to distin\u00adguish integers \nthat must be treated abstractly from ordi\u00adnary Java integers, and enumi quali.ers to track allowed ranges \nof integers. We also introduce readonly and mu\u00adtable quali.ers for Java to add reference immutability, \nbased on Javari [8, 47]. (Section 2)  We present Core JQual, a formal type quali.er inference system \nfor a simple object-oriented languages. We show how to extend this system to FS JQual, which includes \n .eld-sensitivity, and to CS/FS JQual, which adds context\u00adsensitivity. (Section 3) We describe JQual, \nour implementation for Java, and use JQual in our two applications: Inferring opaque, trans\u00adparent, and \nenumi quali.ers in code that uses the JNI, and inferring readonly in a range of Java programs. We found \nthat JQual was able to .nd several potential opaque violations in our benchmarks, as well as many occur\u00adrences \nof readonly and .nal. (Section 4) In prior work, we described CQual, a type quali.er system for C with \nmany applications [4, 9, 14, 15, 16, 18, 24, 42, 49]. In the current work, we show how to incorporate \ntype quali.ers into Java, and explore novel applications. Our results suggest that type quali.ers and \ntype quali.er inference are a useful framework for adding lightweight, application-speci.c checking to \nJava. 2. Applications Before presenting our type quali.er inference system for\u00admally, we discuss our \ntwo major applications of JQual in more depth, and sketch several other potential applications. 2.1 \nEnhanced Type Checking for the JNI The .rst application we explored is adding enhanced type checking \nfor the Java Native Interface (JNI). The JNI al\u00adlows Java code to call functions written in C, which \nis ex\u00adtremely useful but potentially unsafe. One particular prob\u00adlem can occur when a C program passes \npointer values to Java. For example, we examined libgtk-java [23], a JNI win\u00addowing toolkit whose interface \ncan be used to create various GUI entities, e.g., windows or buttons. Pointers to those ob\u00adjects are \nsent to Java as ints, so that the programmer can pass them back to the JNI library to manipulate the \nwindow com\u00adponents. However, since the ints are just ordinary integers as far as Java is concerned, the \nprogrammer could inadver\u00adtently pass bogus pointer values back to C, thereby poten\u00adtially causing memory \ncorruption. We can prevent this problem using type quali.ers. We in\u00adtroduce a quali.er opaque to mark \nintegers that are treated as pointers in C and a quali.er transparent to mark inte\u00adgers that have been \nmanipulated or created inside of Java. We want to forbid transparent integers from being used in opaque \npositions, so transparent opaque in the order\u00ad < ing on these quali.ers. On the other hand, it is safe \nto allow Java to manipulate opaque values it receives from C (e.g., by printing them), as long as they \nare never passed back to C. Thus the .nal quali.er ordering is opaque < transparent, so that opaque values \ncan be used in transparent positions, but not vice-versa. While this application is specialized for the \nJNI, the ba\u00adsic idea is quite general: We wish to enforce an integrity property, namely that transparent \ndata is not used in opaque positions. An analogous example is enforcing the security Then lines 7 9 declare \nthe C function corresponding to the native makeWin method note the mangled function name, which is part \nof the JNI speci.cation [28]. (We have hid\u00adden some other details of using the JNI for clarity.) Because \nthe C function is declared to take an enum windowType, the Java native method on line 2 takes an enum2 \nint as a param\u00adeter, to specify the three possible permitted values. Then on lines 8 9, we see that a \npointer type is passed back to Java, and hence on line 2, the return type of the method is marked as \nopaque. Similarly, lines 11 14 de.ne the C function cor\u00adresponding to the setFocus method. The function \ntakes an integer as an argument and casts it to a pointer, and hence setFocus s parameter is also opaque \non line 3. 1 2 class GUILib {public native static opaque int makeWin(enum2 int t); 3 public native static \nvoid setFocus(opaque int windowPtr); 4 } 5 struct window { ... }; 6 enum windowType { a = 0, b, c }; \n7 jint Java_GUILib_makeWin(enum windowType t) { 8 struct window *w = make_window(t); 9 return (int) w; \n10 } 11 void Java_GUILib_setFocus(int jwindow) { 12 struct window *w = (struct window *) jwindow; 13 \nset_focus(w); 14 } (a) Interface code to C library 15 16 17 class Client {public void m() {opaque int \nw = GUILib.makeWin(1); 18 // ok - 1 is enum1, which is = enum2 19 opaque int v = GUILib.makeWin(4); 20 \n// error - 4 is enum4, which is = enum2 21 setFocus(w); // ok - opaque int passed in 22 setFocus(42); \n// error - created ints are transparent 23 setFocus(w + 3); // error - manipulated ints are transparent \n24 transparent int t = w; // ok - opaque treated as transparent 25 t++; // ok - t is transparent 26 setFocus(t \n); // error - transparent not opaque 27 28 }} (b) Java client of GUILib Figure 1. Examples of JNI quali.er \nusage property that tainted (i.e., untrusted) data is never used in untainted (i.e., trusted) positions \n[42]. In addition to passing C pointers across the JNI, we found that native C code sometimes accepts \nintegers from Java that are treated as enums in C, meaning they should be within a certain range. For \nexample, an enum parameter might be used to select different attributes of a GUI widget. In this case, \nJava code could pass an out-of-range value to C, and although the C compiler itself may not complain \nabout this kind of problem, we can detect it with type quali.ers. We assume that enumerations are contiguous \nand start from 0. Then for an enum with maximum value i, we intro\u00ad duce a new quali.er enumi, which we \nalso assign to occur\u00ad rences of the integer i in Java. We add the subtype ordering enumi < enumj for \ni < j, since the range [0..i] is included in the range [0..j] for i < j. As before, our application is \nspecialized to the JNI, but this basic idea could be applied to enforce similar range-checking properties. \nFigure 1 shows an example of using opaque, transpar\u00ad ent, and enum quali.ers. Part (a) shows the glue \ncode that connects Java to a hypothetical C library. Lines 1 4 de.ne a class GUILib with two native methods, \nmakeWin and setFocus. The C code for these methods is shown on lines 5 14. Line 5 declares the C type \nstruct window, and line 6 declares enum windowType containing values 0 2. Figure 1(b) shows sample client \ncode that uses GUILib s methods correctly and incorrectly. On line 17, we call makeWin to create a new \nwindow, passing argument 1. This is allowed because 1 has the quali.er enum1, which is com\u00adpatible with \nthe quali.er enum2 of the formal parameter. The return value of makeWin is stored in an opaque inte\u00adger, \nsince it represents a C pointer. On line 19, the call to makeWin is forbidden, because we try to pass \nin an integer that is out of range. Next, on line 21, we pass w to setFocus, which is allowed because \nw is opaque. On the other hand, we may not pass setFocus an integer created (line 22) or manipulated \n(line 23) by Java. We are allowed to copy an opaque integer to a transparent integer, but since we then \nmay manipulate it (line 25), we cannot pass transparent in\u00adtegers back to C (line 26). In our experiments \n(Section 4.1), we found that C point\u00aders and enumerations are generally treated safely in Java code, \nbut there are some places where insuf.cient encap\u00adsulation allows opportunities for library clients to \npass Java integers to opaque positions.  2.2 Inferring Immutability Properties The second application \nwe explored is inferring immutabil\u00adity in Java. Immutability, the guarantee that particular mem\u00adory locations \nwill not be updated, is a useful property that can make programs easier to understand. For example, a \ncaller might want to know whether passing an object to a method could cause that object to change. In \nJava, the pro\u00adgrammer can use .nal to mark .elds whose values cannot be changed,1 but this enforces only \none aspect of immutabil\u00adity. Ernst et al have proposed a language extension called Javari [8, 47] that \nadds reference immutability to Java. In Javari, a variable marked with the quali.er readonly cannot be \nused to write to .elds of the object it refers to. Ordinary variables without this restriction have the \nquali.er mutable. We can use JQual to infer Javari-style quali.ers in Java and, at the same time, infer \n.nal. There are some differences between our quali.ers and Javari, which we discuss below. 1 The keyword \n.nal can also annotate classes and methods, in which case it prevents subclassing and overriding, respectively. \nWe ignore these uses of .nal in this paper. 1 class C { 2 non.nal mutable C c; 3 non.nal int x; 4 } \n5 class D { 6 void foo() { 7 .nal mutable Cf = new C(); 8 f.x = 17; // ok - writes .eld of .nal variable \n9 f= new C(); // error - assigns to .nal variable 10 11 non.nal readonly Cr = new C(); 12 r= new C(); \n// ok - assigns to non.nal 13 r.x = 17; // error - writes .eld of readonly reference 14 r.c.x = 17; // \nerror - writes .eld of readonly reference 15 16 non.nal mutable C m; 17 m = r; // error - assigns readonly \nto mutable 18 m.x = 17; // ... which would allow write to .eld 19 r =m; // ok - may assign mutable to \nreadonly 20 } 21 } 22 class E { 23 non.nal int x; 24 void bar() mutable { // bar() is mutable ... 25 \nx = 17; // ... because it modi.es a .eld of this 26 } 27 void baz() { 28 non.nal readonly r= 29 r .bar \n(); // error 30 } 31 non.nal readonly C f; 32 public E() { = new C(); - calls mutable method of readonly \nref . 33 f.x 17; // ok - may write to readonly .eld in constructor 34 } 35 } Figure 2. Examples of immutability \nquali.er usage We introduce four quali.ers for this application: readonly, mutable, .nal, and non.nal, \nwhere the last quali.er explic\u00aditly marks variables and .elds that are not .nal. We illustrate the desired \nbehavior for these quali.ers in Figure 2. Lines 1 4 de.ne a class C with two .elds, c and x. Both .elds \nare explicitly annotated with non.nal, which in Java would normally be denoted by the absence of .nal. \nThe .eld c is also mutable. Note that it would not make sense to mark x as mutable, because it contains \na primitive. The next part of the .gure shows a class D with a method foo. On line 7, we create a new \ninstance of C and store it in a .nal, mutable variable f. Since f is mutable, we may write through it \non line 8 to modify one of its .elds. However, the assignment on line 9 is forbidden, because it would \nmodify f itself, which is .nal. Notice that .nal and non.nal are properties of the location of .eld f, \nand thus we say that .nal and non.nal are reference level quali.ers. In particular, they specify whether \nwe can modify what is stored in f, but they do not place any constraints on what we can do with the contents \nof f (e.g., we can freely write through it). This contrasts with the quali.ers used in the JNI application, \nwhich all re.ne the types of values (in particular, integers), and so are value level quali.ers. Next \non line 11, we initialize r, which is non.nal and readonly. Therefore on line 12, we may modify r because \nit is non.nal, but on lines 13 and 14 we may not write to any of r s .elds, either directly or transitively. \nNotice that readonly and mutable are properties of the contents of r, and not of the location r itself, \nand thus readonly and mutable are value level quali.ers. Line 17 tries to write a readonly variable to \nthe muta\u00adble variable m declared on line 16. This must be forbidden, because otherwise on line 18 we \ncould write through m to change a .eld of r, which would break the property that start\u00ading from r we \ncan never write to any of the .elds. On the other hand, as line 19 shows, we may assign a mutable vari\u00adable \nto a readonly variable, because strictly fewer operations are permitted on readonly variables. Putting \nthese together, we choose the quali.er order mutable < readonly. There is no need to choose an order \namong .nal and non.nal, since .eld locations are not .rst-class values in Java. Finally, the last part \nof Figure 2 shows a class E that il\u00adlustrates some other features of readonly and mutable. Just as variables \nand .elds may be quali.ed, so too may be ar\u00adguments and return values. Moreover, we allow quali.ers on \nthis, written after the method. Lines 24 26 show an exam\u00adple, in which bar is marked as mutable because \nit writes to a .eld this. Therefore on line 29, we may not invoke r.bar(), because r was declared readonly \non line 28. Only readonly methods may be invoked on readonly objects. Fol\u00adlowing Javari, we do allow \nreadonly to be violated in con\u00adstructors. On line 33, the write through readonly .eld f is permitted. \nWe also allow writes to .nal .elds in construc\u00adtors. (Java technically allows only one write to a .nal \n.eld, whereas in JQual we permit multiple writes.) Differences from Javari As this example suggests, \nthese four quali.ers provide a concise but rich way of specifying immutability properties of variables \nand .elds. Our version of these quali.ers is slightly different than Ernst s Javari pro\u00adposal [47], which \nthey are modeled after. In Javari, classes may also be marked readonly to indicate that all of their \ninstances are as well, and JQual supports but does not in\u00adfer this behavior. Javari allows the programmer \nto explicitly add generic immutability annotations on classes. We support .eld-and context-sensitivity \nduring inference (Sections 3.2 and 3.3), which are equivalent, but currently do not include source-level \nnotation for them. Javari also allows somewhat .ner control of the writeabil\u00adity of .elds. In JQual, \na readonly reference cannot be used to modify any .elds of the object it refers to, while in Javari, \nthis behavior can be adjusted on a .eld-by-.eld basis. One of the more important differences between \nJQual and Javari is in method subtyping. Javari does not allow method overriding on the basis of immutability. \nInstead, a change to mutability between the method of a supertype and the method of a subtype causes \nthe method to be overloaded. In contrast, JQual ignores quali.ers when determining over\u00adriding versus \noverloading, since deciding between the two while inferring quali.ers would be dif.cult. JQual therefore \nallows quali.ers to be in a subtyping relationship among overriding and overridden methods. Lastly, Javari \ninserts runtime checks to allow for safe downcasts and re.ection. This is beyond the scope of the current \nwork on JQual, which focuses on static analysis rather than code transformation, and so we track quali.ers \nthrough casts and ignore calls to the re.ection API.  2.3 Other Potential Applications We believe type \nquali.er inference for Java has a wide vari\u00adety of applications. In general, JQual is effective for source\u00adsink \nproblems, which involve tracking the .ow of data from a set of sources to a set of sinks. To use quali.er \ninference for such problems, the programmer only needs to add qual\u00adi.er annotations to the sources and \nsinks, and then quali.er inference determines the intermediate quali.ers in the rest of the program. \nAssuming there are relatively few sources and sinks, the annotation burden for using quali.ers can be \nquite minimal. Also, for the applications in this paper, we use JQual as a whole program analysis. However, \nsince it is based on types, JQual can also be used to analyze a module in isolation, as long as quali.er \ninformation is provided at the module boundary. We discuss several potential applica\u00adtions of JQual brie.y. \nEarlier we mentioned that we could use JQual to track tainted data through Java and ensure it does not \nreach un\u00adtainted positions. This analysis could be especially useful for Java-based web applications \n[21], which are vulnerable to attacks using unchecked inputs, including SQL injection queries, cross-site \nscripting, cookie poisoning, and re.ection injection [30]. For example, we could mark as tainted the \nre\u00adturn values of methods that receive input from users, such as those in the HttpServletRequest class \n[3], and then annotate appropriate positions with untainted. Another potential application of type quali.ers \nis to dis\u00adtinguish among different kinds of Strings. For example, we could use a url quali.er to annotate \nstrings that are URL\u00adencoded, an html quali.er for strings that represent valid HTML, or an sql quali.er \nfor strings that are supposed to be SQL queries. JQual would not by itself verify that the strings have \nvalid contents, but it can ensure that they are passed to and from methods that expect strings of those \ntypes. Simi\u00adlarly, byte arrays could be quali.ed with utf8, utf16, or sim\u00adilar to denote the encoding \nof their contents, and then JQual could ensure they are manipulated by the correct methods. Lastly, JSR \n305 proposes to develop standard annotations for Java programs to allow tools to check a variety of cor\u00adrectness \nproperties [35]. Suggested standard annotations in\u00adclude ones to specify nullness, tainting, concurrency \nprop\u00aderties, and internationalization. JQual may be able to check and infer several of these properties. \nP ::= L* L ::= class C extends D {F1; ... ; M1; ...} T ::= C | CQ F ::= Tf M ::= T0 m(T1 x1,...,Tn xn) \nT {e} e ::= x | null | e1; e2 | e.f | e1.f := e2 | e.m(e1,...,en) | (T ) e | new T C ::= Object |(class \nnames) Q ::= . |(quali.er constants) x ::= this |(variable names) f ::= (.eld names) m ::= (method names) \nFigure 3. Java-like source language 3. Type Quali.er Inference Next we present JQual s type inference \nsystem formally. We present three type systems: Core JQual, which is a .eld\u00adbased, context-insensitive \ninference system, FS JQual,a .eld-sensitive extension, and CS/FS JQual, which further adds context-sensitivity. \nWe describe both systems for the source language in Figure 3, which is a variation of Featherweight Java \n[22] that has been extended with quali.ers. Programs P consists of a sequence of class de.nitions L. \nEach class extends exactly one other class, and there is a built-in base class Object.A class de.nition \ncontains a sequence of .eld declarations F and method declarations M. Types T that appear in the source \ncode may either be ordinary Java types C or quali.ed types CQ. A quali.er Q is either a quali.er variable \n., which is an unknown that must be solved for, or a quali.er constant such as readonly or opaque. We \nassume the set of quali.er constants is .xed in advance, and without loss of generality we allow only \none quali.er constant per type [15]. Quali.er variables do not appear in the program text. Field declarations \ncontain a type T , and method declara\u00adtions may also contain quali.ed types for their arguments and returns. \nIn a method declaration, the type T that ap\u00adpears just after the parameter list is the type of this within \nthe method, which is our mechanism for supplying a quali\u00ad.er on this. When a method is invoked, it evaluates \nto its body, which is an expression e. Expressions include variables x (either this or a parameter name), \nthe special value null, sequenc\u00ading e1; e2, .eld access e.f, .eld assignment e1.f := e2, and method invocation \ne.m(e1,...,en). We also allow type casts (T ) e on expressions. We assume that the class in such a cast \nis checked at run time, but the quali.er is not. Finally, the expression new T creates a new instance \nof class de\u00adscribed by T , with its .elds initialized to null. Note that un\u00adlike Featherweight Java, \nwe do not include constructors or calls to super in our language. t ::= null | CQ o ::= {f1 : f1; . \n. . ; m1 : \u00b51; . . .}f ::= ref Q(t) \u00b5 ::= (t1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 tn) t . t0 (a) Inference types fresh(C) = C. \n. fresh fresh(CQ) = CQ create(C) = {create(F1); . . . ; create(M1); . . .}where P f class C extends C' \n{F1; . . . ; M1; . . .}create(T f) = f : ref .(fresh(T )) . fresh create(T0 m(T1 x1, . . . , Tn xn) T \n{e}) = (fresh(T1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 fresh(Tn)) fresh(T ) . fresh(T0) (b) Translation from source to inference \ntypes (SUB-NULL) null = t (SUB-QTYPE) Q = Q' CQ = DQ' (SUB-METHOD) t'i = ti i . 1..n t' = t t0 = t'0 \n(t1 \u00d7 . . . \u00d7 tn) t . t0 = (t' 1 \u00d7 . . . \u00d7 t' n) t' . t' 0 (c) Subtyping rules (CTCLASS) CT(C) = create(C) \nCT f mtype(m, C) = mtype(m, D) .m . C CT f C extends D {. . . ; M1; . . . ; Mn} (MTYPE-IN) P f C extends \nD {. . . ; M1; . . . ; Mn}Mi = . . . m(. . .) . . . CT f mtype(m, C) = CT(C)(m) (MTYPE-NIN) P f C extends \nD {. . . ; M1; . . . ; Mn}.i.m = Mi CT f mtype(m, C) = mtype(m, D) (FTYPE-IN) t = CQ P f C extends D \n{F1; . . . ; Fn; . . .} Fi = T t CT f ftype(f, t) = CT(C)(f) (FTYPE-NIN) t = CQ P f C extends D {F1; \n. . .} .i.Fi = T t CT f ftype(f, t) = ftype(f, DQ) (d) Class table construction and type lookup (CLASS) \nCT f Mi i . 1..n CT f C extends D {. . . ; M1; . . . ; Mn} (METHOD) class(T ) = C CT f mtype(m, C) = \n(t1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 tn) t . t0 CT, [this . t, xi . ti] f e : t' i . 1..n t' = t0 CT f T0 m(T1 x1, . . . , Tn \nxn) T {e} (VAR) x . dom(G) CT, G f x : G(x) (NULL) CT, G f null : null (SEQ) CT, G f e1 : t1 CT, G f \ne2 : t2 CT, G f e1; e2 : t2 (NEW) CT, G f new T : fresh(T ) (CAST-QTYPE) CT, G f e : t t' = fresh(CQ) \nCT, G f (CQ) e : t' (CAST-TYPE) CT, G f e : t t' = fresh(C) t = t' CT, G f (C) e : t' (FREAD) CT, G f \ne : t CT f ftype(f, t) = ref Q' (t' ) CT, G f e.f : t' (FWRITE) CT, G f e1 : t CT f ftype(f, t) = ref \nQ' (t' ) CT, G f e2 : t'' t'' = t' CT, G f e1.f = e2 : t'' (INVOKE) CT, G f e : te CT f mtype(m, class(te)) \n= (t1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 tn) t . t0 CT, G f ei : t'i t'i = ti i . 1..n te = t CT, G f e.m(e1, . . . , en) : t0 \n(e) Class, method, and expression typing rules Figure 4. Quali.er inference Core JQual 3.1 Quali.er \nInference ther null, which is compatible with any other type, or are quali.ed types CQ. We write class(t) \nfor the class compo- Figure 4 presents Core JQual, our basic type inference sys\u00adnent of type t , which \nis unde.ned for null. During infer\u00adtem. We assume throughout that the input program is correct ence, \nwe create a global class table CT that assigns types to with respect to the standard Java types, and \nthus the job of class members. For a class C, the type CT(C) is an objectCore JQual is only to reason \nabout quali.ers. Part (a) of the type o that maps .eld and method names to .eld types f and.gure describes \nthe types used in inference. Types t are ei\u00ad method types \u00b5, respectively. Core JQual is .eld-based be\u00adcause \n.eld types are stored in the global CT, no matter what instance they come from. Field types have the \nform ref Q(t ). Here t is the contents type and includes the value-level quali.er, and Q is the reference-level \nquali.er on the .eld itself. For example, a .nal mutable .eld has type ref .nal(Cmutable). Method types \nhave the form (t1 \u00d7\u00b7 \u00b7\u00b7\u00d7 tn) t . t0. Here t0 is the return type, the other ti are the argument types, \nand t type of this within the method. As a shorthand, we write o(fi) to mean the fi corresponding to \nfi in t, and similarly for o(mj). To perform inference, JQual needs to translate source types T , which \nmay or may not contain quali.ers, into in\u00adference types. Figure 4(b) de.nes this translation. The .rst \ntwo lines de.ne the function fresh(T ), which quali.es type T with a fresh quali.er variable if needed. \nThe next line de\u00ad.nes create(C), which our type rules use to build the class table CT. The notation P \nf L means program P contains the class de.nition L (the program P is an implicit global here). The function \ncreate makes an object type from a class by adding fresh quali.ers to .eld and method types, where needed. \nNote that we always create a fresh reference-level quali.er here for simplicity, and elide the detail \nof applying quali.er constants according to their level. Subtyping The next step is to extend the subtype \norder among quali.ers to an ordering on types, as shown in Fig\u00adure 4(c). (SUB-NULL) makes null a subtype \nof any other type, and (SUB-QTYPE) propagates subtyping from quali\u00ad.ed types to quali.ers. Note that \nwe ignore the base types, because we assume that the program is correct with respect to the standard \ntypes. The third rule, (SUB-METHOD), propagates subtyping contravariantly to the domain and covariantly \nto the range. Subtyping on methods arises from overriding inherited methods, and thus if we assume the \ninput program passes the Java type checker, then the types ti and t'must in fact i have equal base types, \nthough they may differ in their quali\u00ad.ers. (SUB-METHOD) treats the type of this contravariantly, since \nthe receiver object is a method input. This constraint only makes sense because (SUB-QTYPE) does not \ncheck the base class types, which are covariant in method overriding. Class Table Construction Figure \n4(d) presents the .rst stage of type inference, constructing the class table CT by applying (CTCLASS) \nonce to each class de.nition in the program. This rule uses create to build an object type for each class. \nThis rule also constrains any methods in C to be subtypes of methods they override, using the auxiliary \nfunction mtype(m, C), which looks up method m in class C. The subtyping constraint is ignored if mtype(m, \nD) does not exist. The function mtype is de.ned by (MTYPE-IN), which applies if m is a member of C, and \n(MTYPE-NIN), which applies otherwise and looks up the method in the parent class. The base class Object \nhas no methods or .elds. In essence, by adding subtyping constraints between overriding and overridden \nmethods, we are pre-computing a class hierarchy analysis [12], in which we assume that a call to a method \nm of class C might invoke any method that overrides m in a subclass. Though this approach is less pre\u00adcise \nthan other methods, it .ts well with a source-level type system extension, since a programmer would most \nlikely expect that sub-and superclass quali.ers must be related. We analogously de.ne a function ftype(f, \nt), which looks up .eld f in C = class(t). We pass ftype a t in\u00adstead of a C in anticipation of FS JQual \n(Section 3.2). As before, if f is a member of C then (FTYPE-IN) returns its type in CT(C), and otherwise \n(FTYPE-NIN) returns its type from the parent of C. Type Inference Rules Figure 4(e) shows the next stage \nof type inference, which traverses the method bodies in the program and generates subtyping constraints. \nThe base judgment CT f L, de.ned by (CLASS), infers types for the methods. Note that .elds have no initializers \nin this language, and hence there is nothing to check for them. (METHOD) retrieves the type for m from \nCT and infers the type of e, assuming types for this and method parameters as given by CT. Notice that \nwe need not re-translate the T types here, because class table construction has already done so. The \nlast hypothesis of this rule constrains the type of e to be a subtype of the method return type. The \nremaining rules prove judgments of the form CT, G f e : t , meaning expression e has type t with class \ntable CT and type environment G. (VAR), (NULL), and (SEQ) are standard, and (NEW) creates a freshly quali.ed \ntype from T . There are two type cast rules. (CAST-QTYPE) applies when the cast-to type contains a quali.er. \nThis rule creates a freshly quali.ed type t' for the type of the cast. Notice that there is no relation \nbetween t and t' here the cast breaks the .ow of quali.ers. On the other hand, (CAST-TYPE) applies when \nthe cast-to type is a bare type C. In this case, we make a constraint t = t ' between the cast-from and \nthe cast-to type. Recall that (SUB-QTYPE) ignores base types, and so this constraint in effect only relates \nthe quali.ers on t and t '. We provide these two distinct type casts to give the programmer .exibility \nin specifying whether quali.ers propagate through casts. (FREAD) infers the type t of the expression \ne, looks up .eld f in CT, and returns the type of its contents. (FWRITE) is similar, and it also constrains \nthe type of e2 to be a subtype of the .eld contents type. Lastly, (INVOKE) looks up a method type using \nmtype, and then constrains the actual argument types to be subtypes of the formal arguments. We also \nrequire the type of the receiver object to be a subtype of this s type in m. Constraint Resolution We \nview the type rules in Fig\u00adure 4(c) (e) as generating the subtyping constraints they have in their hypotheses. \nThese constraints have the forms t = t ', \u00b5 = \u00b5', and Q = Q'. By applying the rules in = tracked . = \nnot tracked fresh(C) = (C. , create (C)) . fresh fresh(CQ) = (CQ, create (C)) createt(C) = {createt(F1); \n. . . ; createt(M1); . . .}where P f class C extends D {F1; . . . ; M1; . . .}createt(T ft ' ) = f : \nref .(fresh(T )) t = t ' , . fresh createt(T ft ' ) = \u00d8 t = t ' createt(T0 m(T1 x1, . . . , Tn xn) T \n{e}) = t = . (fresh(T1) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 fresh(Tn)) fresh(T ) . fresh(T0) createt(T0 m(T1 x1, . . . , Tn xn) \nT {e}) = \u00d8 t = (a) Translation from source to inference types (SUB-QTYPE) Q = Q ' o = o ' (CQ, o) = \n(DQ ' , o ' ) (SUB-FIELD) Q = Q ' t = t ' t ' ref Q(t) = ref Q ' (t ' ) (SUB-OTYPE) fi = f ' i i . 1..n \n{f1 : f1; . . . ; fn : fn} = {f1 : f ' 1; . . . ; fn : f ' n(b) Subtyping rules = t } (CTCLASS) CT(C) \n= create.(C) CT f mtype(m, C) = mtype(m, D) .m . C CT f C extends D {. . . ; M1; . . . ; Mn} (FTYPE-TRACK) \nt = (CQ, o) o = {. . . ; f : f; . . .}CT f ftype(f, t) = f (FTYPE-IN) t = (CQ, o) P f C extends D {F1; \n. . . ; Fn; . . .}f . dom(o) Fi = T f. CT f ftype(f, t) = CT(C)(f) (FTYPE-NIN) t = (CQ, o) P f C extends \nD {F1; . . . ; Fn; . . .}f . dom(o) .i.Fi = T f. CT f ftype(f, t) = ftype(f, (DQ, o)) (c) Class table \nconstruction and .eld lookup Figure 5. Quali.er inference FS JQual (modi.cations only) Figure 4(c), \nwe can eliminate the .rst two kinds of con\u00adstraints, so that we are left with a set of quali.er con\u00adstraints \nQ = Q '. Assuming that the partial order on quali.er constants is a lattice, we can solve these constraints \nusing graph reachability to look for inconsistent paths through the graph [15]. For example, a path from \nreadonly to mutable would be inconsistent, since it corresponds to a constraint readonly = mutable. If \nthe constraints have a solution, then we have found a valid typing, and if not, then we report a type \nquali.er error. Section 3.3, below, gives several exam\u00adples of constraint graphs. 3.2 Field-Sensitivity \nAs mentioned in the introduction, one important tradeoff when performing a static analysis is between \n.eld-based and .eld-sensitive analysis. To understand the difference, consider the following code snippet: \nclass C extends Object { int f; }2 C c1 = new C; 3 C c2 = new C; 4 opaque int x = c1.f; Line 1 de.nes \na class C with a .eld f. Then lines 2 and 3 create two instances of C, and line 4 stores c1.f in an opaque \ninteger. Therefore c1.f must itself be opaque, since trans\u00adparent integers may not be passed to opaque \npositions. In Core JQual, all instances of C share the same .eld types, no matter how often C is instantiated. \nThus c2.f would also be considered opaque in this example. On the other hand, in a .eld-sensitive analysis, \neach syntactic occurrence of a class is given its own set of .eld types. Thus we would infer that c1.f \nis opaque, but c2.f could be transparent, since the type of c2.f is unconstrained. Clearly a .eld-sensitive \nanalysis can be much more pre\u00adcise than a .eld-based analysis, but .eld-sensitivity might not make sense \nfor all applications after all, in standard Java classes, there are many .elds with non-generic types. \nAdditionally, the more polymorphism there is in a type, the harder it may be to understand, especially \nwhen poly\u00admorphism is combined with subtyping. Field-based analy\u00adsis can also be more ef.cient than .eld-sensitive \nanalysis, since there is less information to track about the program. Indeed, our current implementation \nof JQual (Section 4) typ\u00adically runs out of memory when trying to perform full .eld\u00adsensitive analysis \non our larger benchmark programs, and ef.cient .eld-sensitive analysis is an active area of research \n[27, 31, 43, 44, 48]. JQual solves this problem by asking the programmer to mark .elds that should be \ntreated .eld-sensitively. We call such .elds tracked. In our experience, we found that it is usually \neasy to determine what .elds to make tracked, and that only a few tracked .elds are needed. We designed \nCore JQual carefully so that FS JQual, our .eld-sensitive inference system, is a minimal extension to \nit. 1 class D extends Object { 2 C id(C x) { 3 return x; 4 } 5 void main() { 6 C c1 = new C(); C c2 = \nnew C(); 7 C c3 = id(c1); C c4 = id(c2);  8 }9 } Figure 6. Context-sensitivity example and constraint \ngraph Formally, .eld declarations in the source code are now of the form Tft, where t is either for \na tracked .eld, or . for a non-tracked .eld. We extend types t to the form t ::= null | (CQ,o) Here the \nCQ component is as before, and the object type o maintains tracked .elds. Non-tracked .elds are stored \nin the class table. For example, suppose C is declared as class C extends D { Tf ; T ' g.} Then CT maps \nclass C to a type {g : f ' }, and each occur\u00adrence of C in the program text has a type t =(CQ , {f : \nf}). During inference, when we look up f in type t , we return f, while when we look up g in type t, \nwe .nd its type in CT and return f ' and thus in our example, each separate occur\u00adrence of C will have \nits own type for .eld f, but they will all share the type of .eld g. We de.ne class((CQ,o)) = C. Figure \n5 shows the necessary changes to the typing rules. Part (a) of this .gure rede.nes fresh to return a \nt where the object type portion of the t is constructed with a call to create . The create function now \nhas a subscript t indicating whether the object type it returns should include tracked or non-tracked \n.elds. In particular, when create (Tft ' ) is called, it generates a .eld type for f if t ' is tracked, \nand otherwise it does not, denoted by returning \u00d8. Calling create. does the opposite. Methods are shared \nacross all instances, and thus they reside only in CT and are generated with create., and create never \ncreates method types. Notice that if createt is applied to a recursive type with a tracked .eld, we could \npotential enter an in.nite loop, unrolling the type inde.nitely. To prevent this, when we encounter an \noccurrence of class C nested at any depth within class C, we force them to share the same object type \n(not shown in the .gure). Figure 5(b) shows the necessary changes to the subtyp\u00ading rules. (SUB-QTYPE) \nis modi.ed to propagate subtyping to object types. (SUB-FIELD) handles subtyping on .elds. Since ref \nis a nonvariant constructor, we require that t and ' t are equal. Lastly, (SUB-OTYPE) propagates subtyping \nfrom an object type to its components covariantly. Note that we only apply this rule to object types \nrepresenting tracked .elds, and thus the object types do not contain methods. Also notice that this rule \nrequires that the sub-and superclass have the same .elds and methods, i.e., it does not allow width sub\u00adtyping. \nWe need this feature in practice to propagate quali\u00ad.ers on tracked .elds through up-and down-casts. \nFor ex\u00adample, consider the code Foo f = ...; Object x = f; Foo g = (Foo) x; If Foo contains a tracked \n.eld, we must add it to x s type so that its quali.ers reach g. Finally, Figure 5(c) gives the new rules \nfor class table construction and .eld lookup. (CTCLASS) is the same as before, but we use create. to \nmake object types with non\u00adtracked .elds. When applying ftype(f, t ) to look up a .eld type, there are \nthree cases. (FTYPE-TRACK) applies when f is part of the object type stored in t, i.e., when f is tracked. \nOtherwise, (FTYPE-IN) and (FTYPE-NIN) retrieve the .eld from the class table as before. The class, method, \nand expression typing rules from Core JQual are unchanged in FS JQual. The modi.cations to the .eld lookup \nrules do essentially all the necessary work. For example, (FRREAD) still invokes ftype(f, t) to compute \na type for e.f, but it uses the new .eld lookup rules in Fig\u00ad ' ure 5. Similarly, constraints such as \nt = ti generated in i (INVOKE) now operate on types (CQ,o), using the addi\u00adtional subtyping rules. Constraint \nresolution is also the same process as in Core JQual: We generate subtyping constraints, reduce them \nto quali.er constraint Q = Q ', and the solve the constraints using graph reachability.  3.3 Context-Sensitivity \nAlong with .eld-sensitivity, another major tradeoff in a static analysis is whether to use context-sensitivity \n(a.k.a. para\u00admetric polymorphism for type systems [32]). Consider the code example shown on the left \nin Figure 6. Line 1 de.nes a class D, and lines 2 4 de.ne an identity method id on some other class C. \nOn lines 6 7 we create two instances, c1 and c2, and pass them through id, storing the results in c3 \nand c4, respectively. Since Core and FS JQual are context\u00adinsensitive, they would determine that the \nquali.ers on c1 and c2 .ow to (i.e., are subtypes of) the quali.ers on both c3 and c4. This is imprecise, \nbecause at run time, c1 only .ows to c3, and c2 only .ows to c4. We can solve this problem by introducing \ncontext-sensitivity, so that we can distinguish the two calls to id. JQual incorporates context-sensitivity \nusing a technique proposed by Reps et al [38] and Rehof et al [36]. In this (INST-FIELD) Q j . Q ' t \nj . t ' t j -. t ' ref Q(t) j . ref Q ' (t ' ) (INST-QTYPE) Q j . Q ' o j . o ' (CQ, o) j . (DQ ' , o \n' ) (INST-OTYPE) fi j . f ' i i . 1..n {f1 : f1; . . . ; fn : fn} j . {f1 : f ' 1; . . . ; fn : f ' n} \n(a) Instantiation rules (FTYPE-IN) t = (CQ, o) P f C extends D {F1; . . . ; Fn; . . .}f . dom(o) Fi = \nT f. f = CT(C)(f) f * + f f * - f CT f ftype(f, t) = f (b) Field lookup (INVOKE) CT, G f e : te CT f \nmtype(m, class(te)) = (t1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 tn) t . t0 t0 j + t0 ' CT, G f ei : t ' i ti j - t ' i i . 1..n t \nj - te CT, G f e.mj (e1, . . . , en) : t0 ' (c) Invoke expression typing Figure 7. Quali.er inference \n CS/FS JQual (modi.cations only) approach, we reduce context-sensitive inference to the prob\u00adlem of context-free \nlanguage (CFL) reachability on a con\u00adstraint graph. As is well-known, context-sensitive analysis can \nbe more expensive than context-insensitive analysis, but CFL reachability has proved to be very scalable \nin practice [15, 36, 43, 44]. We can think of a regular quali.er constraint Q = Q ' as an edge Q -. Q \n' in a graph, where the nodes in the graph are quali.er constants and variables. As mentioned earlier, \nwe solve a set of quali.er constraints by looking for inconsistent paths in the constraint graph. We \nadd context\u00adsensitivity by introducing edges labeled with indexed paren\u00adtheses. We pick a fresh index \nj for each call site in the program. Then instead of regular edges, when quali.ers are passed into a \nmethod at call site j, we add instantiation edges labeled with (j . Similarly, when quali.ers are returned \nfrom the same call, we use instantiation edges labeled with )j . To check satis.ability, we use context-free \nlanguage reach\u00adability to propagate quali.ers only along paths that have no mismatched parentheses. For \nexample, the right part of Figure 6 shows the key portion of the constraint graph for the sample program. \nHere the .rst call to id is indexed by i, and the second call is indexed by j. Notice that the path from \nc1 to c3 is valid, because (i matches )i, and similarly for the path from c2 to c4. However, the path \nfrom c1 to c4 is invalid, because (i does not match )j, and similarly for the path from c2 to c3. Thus \nwe have gained precision by excluding unrealizable paths from our analysis, which correspond to non-matched \ncall and return sequences [38]. Notice that these paths would have been valid under a monomorphic analysis, \nwhich would produce the same graph but with no edge labels. Figure 7 shows the changes necessary for \nCS/FS JQual, which extends FS JQual with context-sensitivity using the approach just outlined. Formally, \nlabeled edges in the con\u00adstraint graph correspond to instantiation constraints of the form Q :j Q '. \nHere j indicates the call site, and . is the . variance, either - for contravariant positions or + for \nco\u00advariant positions. The constraint Q :j Q ' corresponds to an + - Q ' to an edge Q ' -.(j Q (notice \nthat we .ip the direction of the arrow for this last constraint [36]). Part (a) of the .gure extends \ninstantiation constraints to types. (INST-FIELD) propagates an instantiation constraint from a reference \ntype to its components. Here -. is the op\u00adposite of the variance ., and notice that, just as with subtyp\u00ading, \nreferences are both co-and contravariant in their con\u00adtents types. (INST-QTYPE) and (INST-OTYPE) both \nprop\u00adagate an instantiation constraint covariantly to the compo\u00adnents of the types. Rather than give \na separate rule for null, we assume we always apply subtyping to turn null types into non-null types \nbefore using then in instantiation constraints. The .eld lookup rules for CS/FS JQual are the same as \nFS JQual, except (FTYPE-IN), as shown in Figure 7(b). This rule applies to non-tracked .elds, which are \nshared across all instances, and thus must be considered global by the analysis. To allow propagation \nof quali.ers through these .elds from any call site to any call site, (FTYPE-IN) adds the constraints \nf :* . f for . =+ and . = -. The label * is a special index that matches any call site in the program, \nand thus these constraints, which correspond to self-loops in the constraint graph, allow the correct \n.ow for globals [36]. In our implementation, we also add these constraints for static .elds, since they \nare global as well. We illustrate self-loops in an example shortly. edge Q -.)j Q ', and the constraint \nQ :j corresponds 1 2 class D extends Object {static C f; 3 4 C foo(C x) {C temp = this.f ; 5 this . f \n= x; 6 return temp; 7 8 9 }void main() {C c1 = new C(); C c2 = new C(); 10 C c3 = foo(c1); C c4 = foo(c2); \n11 12 }}  Figure 8. Self-loops in constraint graphs Figure 7(c) shows the one change necessary to the \nexpres\u00adsion type rules. The revised (INVOKE) rule creates instanti\u00adation edges rather than subtyping \nconstraints at the call site. Argument types and the receiver object type are contravari\u00adant, and the \nreturn type is covariant. For example, consider Figure 6 again. At the .rst call to id, this rule generates \ntwo constraints (ignoring the receiver): x :i - c1, corresponding to the edge from c1 to x, and the constraint \nreturn :i c2, + corresponding to the edge from return to c2. The edges for the second call to id are \nsimilar. Notice that (INVOKE) generates instantiation constraints on the method based on the compile-time \ntype of e. By (CTCLASS) from Figure 4, we have already added appro\u00adpriate constraints between this method \ntype and the types of methods related to it by overriding in the class hierarchy. Thus in essence, (INVOKE) \ninstantiates the type of a method that represents all possible run-time objects represented by e. To \nunderstand the need for self-loops in (FTYPE-IN), consider the example in Figure 8. The method foo on \nlines 3 7 stores the value of its argument x in a static .eld f, and then returns the old value of f. \nThen on lines 9 10, we create new instances c1 and c2 and pass them through foo, storing the results \nin c3 and c4, respectively. Notice that when this code runs, the value of c1 will be stored in c4. The \nright part of the .gure shows the constraints gener\u00adated for this example. Since f is a static .eld, \nwe treat it like a non-tracked .eld and add self-loops labeled with (* and )*. Thus there is a matched \npath from c1 to c4 that crucially uses the self-loops on D.f. Notice that without these self-loops, we \nwould miss this path in the graph and be unsound. While context-sensitivity does increase the complexity \nof the inference algorithm (up to cubic time [36]), our experi\u00adments (Section 4.2) show that it is scalable \nin practice and increases precision. 4. Implementation and Experiments We implemented JQual as an Eclipse \nplug-in. JQual per\u00adforms its analysis on source code, using Eclipse s Java De\u00advelopment Toolkit for parsing. \nJQual generates and solves constraints using CQual s back-end, and if any constraints are unsatis.able, \nmeaning that some value in the program has inconsistent inferred quali.ers, then the constraint solver \nissues a warning message that includes an inference path il\u00adlustrating the error [15]. CQual uses heuristics \nto suppress excess warnings, but we found that they did not always work, and so the counts of warning \nmessages in our experiments do not include warnings with duplicate paths. The input to JQual is a set \nof source .les to analyze and a con.guration .le describing the order among the quali.er constants. Type \nquali.er annotations are given in source code as Javadoc comments with custom tags. We allow methods, \n.elds, variables, and type casts to have quali.er annotations, and .elds may also be annotated as tracked. \nWe chose Javadoc instead of Java 1.5-style annotations [6] because the latter cannot appear in every \nposition that we needed for our experiments. (JSR 308 proposes a solution to this problem [13].) Quali.er \nannotations also indicate whether to apply the quali.er to the reference or value level of a variable. \nWhen the user runs JQual, they can choose whether to enable .eld-sensitivity, context-sensitivity, both, \nor neither. In our formalism, the function create always creates fresh quali.ed types for each tracked \n.eld, but this would be prohibitively expensive in practice. Instead, JQual creates .elds lazily, on-demand. \nInitially, create returns a type with an empty set of .elds. Then when ftype(f, t) is called, we add \nf to t if it is a possible tracked .eld of the object. As a heuristic, when we generate a regular subtyping \nconstraint (CQ,o) = (DQ ' ,o '), we unify o and o ', so that they share tracked .eld sets. This results \nin little lost precision because .elds are reference types, and so in any case the .elds value-level \nquali.ers would be equal after such a constraint. We do not unify .eld sets across instantiation constraints. \nJQual handles a number of features of Java not included in our formal system. Constructors are modeled \nsimilarly to ordinary methods, except the return type is the same as the newly constructed object type. \nJQual is a whole-program analysis, and so it requires source code for all necessary classes. JQual begins \nfrom the initial set of source .les, tran\u00adsitively .nds all classes they reference, and analyzes them. \nJQual aims to be sound, but has three potential sources of unsoundness: Implicit super() constructor \ncalls are ignored, we do not track the .ow of quali.ers from throw to catch clauses, and we do not model \nnative method or re.ective API calls specially, and so they can lose .ow of quali.ers. We do not feel \nthat any of these are signi.cant limitations. We performed all of our experiments on an 2.4GHz AMD Athlon \n4600 processor with 4GB of memory. 4.1 Quali.ers for the JNI For our .rst experiment with JQual, we checked \nthe JNI quali.ers described in Section 2.1 on a small benchmark suite. Rather than add quali.er annotations \nmanually, we developed a simple tool do to so automatically. Our tool uses CIL [33] to analyze C code \nand .nd places where parameters and return values of native methods are directly cast from an int to \nsome C type T or vice-versa. If T is a pointer type, then we mark the corresponding int as opaque, and \nif T is an enumeration with maximum value i, we mark it as enumi. Any other parameter or return types \nare not quali.ed. Note that our analysis may omit some quali.er annotations due to its handling of certain \nC constructs, and because it ignores any transitive .ow of Java ints through the C code. After performing \nthis .rst step, we then add the quali\u00ad.ers to the Java code. Rather than modify the actual Java source, \nwe used a separate auxiliary .le to specify quali\u00ad.ers. We also extended JQual so that any integers manipu\u00adlated \nby Java, such as numeric literals or the results of arith\u00admetic operations, are transparent. Additionally, \nseveral of the benchmarks we analyzed form a library that is intended to be used in many different applications. \nWithout knowing exactly what the client code is, we wanted to check whether any transparent values could \nbe used in opaque positions. Thus we modi.ed JQual so that any ints that could come from outside the \nscope of the library package, namely pub\u00adlic method arguments and public .elds, are transparent. Fi\u00adnally, \nin this analysis, we do not model the Java standard li\u00adbrary, and we do not generate any constraints \nwhen referring to unavailable code. These choices introduce some potential unsoundness, but keep the \nexperiment simple. Figure 9 summarizes our benchmark suite and the results of running JQual. The .rst \nset of benchmarks, listed above the line, is a collection of related libraries for accessing the Gimp \nToolkit (GTK). We analyzed each of these in isolation and then together, listed on the top line. The \nother two benchmarks in the chart, listed below the line, are separate programs. The second column of \nthe table lists the number of lines of code of each benchmark. The third column lists the number of quali.ers \nadded to native methods based on our C code analysis, and the fourth column counts the total number of \nparameter and return positions on native methods. Over all the benchmarks, roughly 28% of the possible \npositions were annotated with quali.ers, indicating that passing C pointers and enumerations between \nJava and C is relatively common in the JNI. To apply JQual to these benchmarks, we used the fol\u00adlowing \nprocedure. We began by running JQual context\u00adand .eld-insensitively. We found that this generated a very \nlarge number of warnings, and so we immediately enabled context-sensitivity. The resulting warning counts, \nstill .eld\u00adinsensitive, are shown in the .fth column in Figure 9. We felt that this was still a large \nnumber of warnings, and so we inspected the output to identify .elds that seemed like good candidates \nfor .eld-sensitivity, which we then marked as tracked. We continued re-running the analysis and look\u00ading \nfor tracked .elds until we could not identify any more good candidates. The results of the .nal context-and \n.eld\u00adsensitive experiment are shown in the last three columns of Figure 9. The .rst column lists the \nrunning time in seconds (one run) the next column lists the total number of tracked .elds, and the last \ncolumn lists the number of warnings re\u00adported by JQual. As these results show, most of the opaque and \nenum\u00adquali.ed integers are used safely in the Java code, since there are few warnings overall. We inspected \nthe .nal warnings for combined gtk and the two standalone benchmarks man\u00adually, and found they fell into \nfour categories. We did not .nd any outright errors, but 7 of the warnings occur because integers arguments \nof public methods could .ow to opaque arguments of native methods. This is a bad programming practice \nbecause it allows library clients to pass transparent integers to opaque positions. The remaining warnings \nare all false positives. Seven of the warnings occur when the integer literal 0, which our analysis quali.es \nas enum0, is passed to an opaque position, meaning it is used as the C null pointer. Two of the warnings \nare from our assumption about enu\u00admeration types in C. In this case, rather than representing a range \nof values, the enumerations represented bit .ags, and our analysis marked the results of bit operations \nas transpar\u00adent, even though they formed legitimate values. Another 23 warnings were related to our analysis \nof enumeration types, but involved inference paths that appear to be unrealizable. The last warning was \ndue to an extra cast inserted by CIL that caused our C code analysis to qualify to an integer that is \nnot a pointer or enumeration.  4.2 Immutability Inference For our second experiment with JQual, we used \nJQual to infer readonly quali.ers for a selection of Java programs. To add these quali.ers to JQual, \nwe modi.ed two typing rules as shown in Figure 10. In (FREAD), we generate a new constraint Q = Qf , \nwhere Qf is the quali.er on the type of e.f and Q is the quali.er on e. In this way, if Q is readonly, \nthen Qf will be as well, i.e., if e is readonly, then so is e.f. In (FWRITE), we generate a new constraint \nQ = mutable, since .eld f is written to. Here Q is f s reference-level quali.er. We also generate a constraint \nQ ' = non.nal, where Q ' is the value-level quali.er on .eld f. Here we can clearly see that non.nal \nis a reference level quali.er and mutable is value level quali.er. As mentioned in Section 2.2 we allow \n Benchmark KLoC Qual Pos Fld Ins Wrn Time Fld Sens Trck Wrn combined gtk 40.6 4,929 17,562 187 2:18s \n22 37 libgtk-java-2.6.2 32.4 4,029 13,844 151 2:07s 20 11 libvte-java-0.11.11 0.2 47 158 0 0:00s 0 0 \nlibglade-java-2.10.1 1.0 5 20 0 0:03s 0 0 libgconf-java-2.10.1 0.7 148 504 0 0:00s 0 0 libgnome-java-2.10.1 \n5.1 632 2,652 3 0:06s 0 0 libgtkmozembed-java-1.7.0 0.5 18 80 0 0:00s 0 0 libgtkhtml-java-2.6.0 0.7 50 \n304 1 0:01s 2 1 jnet.lter 1.2 77 432 24 0:04s 6 3 libreadline-java-0.8.0 0.3 2 36 0 0:00s 0 0 Figure \n9. Results of JNI Experiments (FREAD) CT, G f e : tt =(CQ,o) ' CT f ftype(f, t)= ref Q ' (t ' ) t =(DQf \n,o ' ) Q = Qf ' CT, G f e.f : t (FWRITE) CT, G f e1 : tt =(CQ,o) CT f ftype(f, t)= ref Q ' (t ' ) '' \n''' CT, G f e2 : tt = tQ = mutable Q ' = non.nal '' CT, G f e1.f = e2 : t Figure 10. Modi.ed inference \nrules for immutability constructors to write to readonly and .nal .elds, and so when analyzing constructors \nwe use the original versions of (FREAD) and (FWRITE) rather than the modi.ed versions. We applied immutability \ninference to a variety of Java programs. Figure 11 summarizes the results. The programs beginning with \nunderscores are part of the SPEC JVM benchmark suite [2]. The others are open source programs downloaded \nfrom SourceForge [1]. For the SPEC bench\u00admarks, we included the code of the SPEC JVM execution framework \nin our analysis, and thus the line counts (KLoC) are larger than a straight count of the benchmarks code. \nTo model library calls, we created a special stub version of the libraries that included mutable and \nnon.nal annotations. We also annotated .elds of container classes as tracked, since we expect containers \nto be used polymorphically. We ran JQual with three of the four possible combi\u00adnations of context-insensitive \n(CI) versus context-sensitive (CS) and .eld-based (FB) versus .eld-sensitive (FS). We omitted CI/FS analysis, \nsince context-insensitive construc\u00adtors would merge the .elds of different instances, reducing or eliminating \nthe bene.t for .eld-sensitivity. For the various con.gurations, we report the number of readonly (RO) \nposi\u00adtions inferred on object types in method signatures (includ\u00ading arguments, return, and this); then \nthe number of .elds inferred to be .nal (FF); and then the running time (one run) We do not include methods \nand .elds from the library stubs in our counts. In the context-sensitive analyses, we counted a method \nparameter or result as readonly if it could be used polymor\u00adphically as either mutable or readonly. For \nthe .eld-based analysis, we counted each .eld from a class once, since .eld types are shared across all \ninstances of a class. In the .eld\u00adsensitive analysis, we counted each instance of a tracked .eld separately. \nWe omit the FF column from the CS/FB ex\u00adperiment because context-sensitivity does not change where we \nmay infer .nal. The average percentage of readonly method positions ranges from 48% to 62%, suggesting \nthat large number of parameters, return values, and receiver objects in methods are readonly. A smaller, \nbut still signi.cant percentage of .elds are inferred to be .nal. As expected, the precision in\u00adcreases \nwith the addition of context-and .eld-sensitivity. In most cases, increased precision comes at the cost \nof in\u00adcreased running time, though in a few cases the running time actually decreases, most likely because \nthere are fewer valid paths for propagating quali.ers. To better understand the results of this experiment, \nwe se\u00adlected .fty method signature positions, determined whether they were readonly or mutable according \nto the analysis, and then manually inspected the code. We found that the quali\u00ad.ers inferred on 35 positions \nwe looked at were non-trivial and seemed quite useful, describing accurate properties of the code. Another \n3 positions were inferred readonly but were Strings, which are clearly immutable, and 5 more were return \nvalues of methods that are never called hence the return value is trivially readonly. Lastly, 7 of the \npositions in method signatures were mutable, but seemed likely to be readonly if we had made more .elds \ntracked. Overall, our results show that JQual is able to discover many useful cases of immutability across \nour benchmarks. 5. Related Work There are several threads of work related to JQual. In our own prior \nwork, we proposed type quali.ers as a general mechanism for lightweight static checking and described \nCQual [15], which adds type quali.ers to C. Among other applications, CQual has been used to infer const \nquali\u00ad.ers [14], to .nd format-string vulnerabilities [42], and to .nd user-kernel pointer vulnerabilities \n[24] and dead\u00adlocks [4, 16] in the Linux kernel. Several other researchers have also used CQual [9, 18, \n49], and our hope is that JQual will similarly become a platform for experimentation with lightweight \nstatic analysis of Java. Benchmark KLoC CI/FB RO (%) FF (%) Time CS/FB RO (%) Time CS/FS RO (%) FF (%) \nTime jdbm 4.2 283 (33%) 182 (41%) 0:02s 379 (44%) 0:01s 402 (46%) 301 (52%) 0:02s 227 mtrt 5.7 358 (56%) \n160 (22%) 0:02s 398 (62%) 0:02s 446 (70%) 261 (30%) 0:03s 201 compress 6.2 368 (53%) 190 (23%) 0:03s \n418 (60%) 0:02s 466 (67%) 325 (32%) 0:03s 209 db 6.4 364 (53%) 162 (21%) 0:02s 408 (60%) 0:02s 456 (67%) \n276 (31%) 0:03s 200 check 7.0 481 (62%) 206 (26%) 0:03s 527 (68%) 0:02s 576 (74%) 310 (33%) 0:04s 205 \nraytrace 7.7 521 (53%) 190 (21%) 0:03s 602 (61%) 0:02s 650 (66%) 325 (30%) 0:04s 202 jess 12.0 412 (57%) \n164 (22%) 0:06s 460 (64%) 0:03s 508 (71%) 287 (31%) 0:05s jgap 10.2 784 (41%) 460 (44%) 0:07s 1,003 (52%) \n0:04s 1,087 (57%) 656 (53%) 0:06s jgraph 11.9 1,167 (41%) 288 (29%) 0:10s 1,453 (51%) 0:06s 1,453 (51%) \n3,828 (71%) 0:08s jtds 21.5 1,040 (35%) 854 (48%) 0:10s 1,247 (42%) 0:05s 1,323 (44%) 927 (49%) 0:08s \n213 javac 45.7 359 (56%) 160 (22%) 0:02s 399 (63%) 0:02s 448 (70%) 261 (30%) 0:03s jfreechart 121.4 9,377 \n(46%) 2,098 (33%) 0:55s 11,190 (55%) 0:56s 11,444 (57%) 5,573 (55%) 1:12s Average (48%) (29%) (56%) \n (62%) (42%) Figure 11. Immutability inference results  There are several challenges in performing static \nanal\u00adysis of Java code as compared to C. We encountered the same issues that have been previously identi.ed \nby other re\u00adsearchers [40, 26]. In Java, method invocations are almost all via dynamic dispatch, as opposed \nto C, where function pointer calls occur regularly but much less often. Thus we need to model the call \ngraph in some way, and JQual s choice is class-hierarchy analysis, to match Java s type system. An\u00adother \ndifference is that Java does not have pointers to the stack or pointer arithmetic, though it does have \nmany dy\u00adnamic allocation sites. The Java standard libraries are quite large, and analyzing them requires \nsigni.cant resources. In our experiments, we used a stubbed version of the library with annotations. \nLastly, re.ection [30], dynamic class load\u00ading, and native methods make it dif.cult to achieve sound\u00adness \nin a static analysis of Java. These remain open problems in the research community and for JQual. Type \nquali.er inference is closely related to the problem of points-to analysis, which has been an active \narea of re\u00adsearch in recent years. The goal of points-to analysis for Java is to determine how run-time \nobjects .ow through the program. Similarly, in type quali.er inference, our goal is to determine how \nquali.ers .ow through the program, and then additionally to check that the .ow is valid with respect \nto the programmer-supplied quali.er ordering. Thus we may be able to use others techniques for points-to \nanalysis to per\u00adform type quali.er inference. However, it is unclear whether arbitrary points-to analyses \ncan support the extra conditions for readonly, in which reads through readonly references produce new \nreadonly references, and whether they include analysis of the .ow of integers, which we need for opaque \nand enum inference. In general, type quali.ers are intended as a lightweight, source-level speci.cation \nand checking sys\u00adtem, whereas points-to analysis is a core static analysis that is not directly reported \nto the programmer. As discussed in Section 2.2, our readonly and mutable quali.ers are based on Javari \n[8, 47]. Tschantz [46] presents an inference algorithm for Javari quali.ers. Tschantz s algo\u00adrithm includes \nsome specialized notions of .eld-sensitivity, expressed by inferring bounds on instantiated type variables, \nas well as context-sensitivity, expressed with a romaybe quali.er. It is unclear exactly how these relate \nto the gen\u00aderal notions of .eld-and context-sensitivity in JQual. Ad\u00additionally, Tschantz reports only \none result of his inference algorithm and suggests the implementation is incomplete. Pratikakis et al \n[34] present a framework for program\u00adming with proxies in Java. Their system uses a proxy qual\u00adi.er to \nmark proxied objects, and quali.er inference deter\u00admines where these objects are used and hence must \nbe de\u00admanded at run time. Their quali.er system is specialized to handle proxy, while JQual is general-purpose. \nAn interesting future direction is using JQual to infer proxy quali.ers. Chin et al [10] propose semantic \ntype quali.ers, in which programmers specify user-de.ned type quali.ers for C us\u00ading a type re.nement \nrule language. In this framework, the re.nement rules are automatically incorporated into the source \nlanguage type checker and proven sound with respect to the quali.er semantics. Later work adds monomorphic \ntype quali.er and re.nement rule inference [11]. In contrast, JQual uses a .xed set of quali.er rules \nthat can only be mod\u00adi.ed by editing JQual s source code (e.g., the tweaks neces\u00adsary for readonly and \nopaque checking), but JQual applies to Java and includes context-and .eld-sensitivity. Andreae et al \n[5] bring semantic type quali.ers to Java, but do not investigate quali.er inference. Several researchers \n[27, 31, 39, 41] have developed anal\u00adyses for discovering whether Java methods have side ef\u00adfects. This \nis similar to inferring readonly, but these sys\u00adtems are designed mostly for compiler optimization, rather \nthan source-level speci.cation. Liu and Milanova propose immutability inference for .elds in Java [29]. \nThis is differ\u00adent than the reference immutability for arguments and results inferred by JQual. Artzi \net al [7] propose a combined static and dynamic mutability analysis for Java, using a different notion \nof parameter mutability than readonly. Type quali.ers are related to the re.nement types of Free\u00adman \nand Pfenning [19]. While similar in spirit, re.nement types are signi.cantly more complex, based on the \ntheory of intersection types, while quali.ers include only atomic subtyping. Quali.ers cannot express \nas rich a set of proper\u00adties but may provide a simpler programming interface and allow a more ef.cient \nimplementation. The work of Strom and Yemini [45] on typestate veri.cation similarly provides static \nchecking of properties orthogonal to standard types, although the emphasis is on .ow-sensitive properties. \nWe brie.y discuss some approaches to points-to analysis for Java. Milanova et al [31] present an object-sensitive \nalias analysis for Java, in which each set of calls to a method with a different receiver class type \nis analyzed separately. They show that this limited form of context-sensitivity enhances precision while \nremaining ef.cient. JQual, in contrast, uses full context-sensitivity. Sridharan et al [43, 44] express \npoints-to analysis for Java as a context-free language (CFL) reachability problem. In their encoding, \nthey use CFL reachability both for polymor\u00adphic method calls and for .eld-sensitivity. Since this leads \nto a potentially undecidable problem, to remain tractable they use an approximation and re.nement scheme \nwhen solv\u00ading the constraint graph. In contrast, JQual places .elds structurally inside of types, and \ndoes not use CFL edges for .eld access. JQual s approach is much simpler tech\u00adnically, but in our experience \ndoes not scale if we enable full .eld-sensitivity. However, because we only enable .eld\u00adsensitivity for \nindividual .elds, we avoid the scaling problem while still being precise enough for our applications. \nLhotak [27] describes a BDD-based framework for de\u00adveloping various static analyses of Java, including \npoints-to analysis. Whaley and Lam [48] show how to use BDDs to compute a context-sensitive, .eld-sensitive \nalias analysis of Java that scales to large programs. Lam et al [25] general\u00adize this approach to a number \nof different static analyses of Java. Both of these systems provide a generic infrastructure for program \nanalysis, and may be useful for type quali.ers. Reps has shown that using CFL reachability for both context-and \n.eld-sensitivity is undecidable [37]. We avoid this problem in CS/FS JQual by only using CFL reachability \nfor context-sensitivity. We achieve .eld-sensitivity by repre\u00adsented tracked .elds in the structure of \ntypes, and we tie the knot for recursive types whenever we encounter them. This last part, which is an \napproximation, maintains decidability. Finally, our quali.ers for the JNI can be considered a follow \non to prior work in which we performed type safety checking across the JNI [20]. Our prior work checked \nthat C code used Java types safely, whereas in this paper we use JQual to check that Java code uses C \ntypes safely. 6. Conclusion We have presented JQual, a system for adding type quali\u00ad.ers and type quali.er \ninference to Java. We formalized Core JQual, a .eld-based, context-insensitive type quali.er infer\u00adence \nsystem for a variant of Featherweight Java. We then presented FS JQual, a small extension to this system \nthat adds .eld-sensitivity, and CS/FS JQual, which further adds context-sensitive inference using CFL \nreachability. We stud\u00adied two major applications of JQual: checking that pointer and enum values passed \nthrough a JNI API are used correctly in a Java program, and inferring readonly and .nal quali.ers in \nJava source code. JQual found several examples of poten\u00adtial opaque violations in a small benchmark suite, \nand was able to infer that many positions are readonly or .nal. These results suggest that user-de.ned \ntype quali.ers can provide bene.cial, lightweight, application-speci.c static checking for Java. Acknowledgments \nWe would like to thank the anonymous reviewers for their helpful comments on an earlier version of this \npaper. This research was supported in part by NSF CCF-0430118. References [1] SourceForge. http://www.sourceforge.net. \n[2] SPEC JVM98 Benchmarks. http://www.spec.org/ jvm98/. [3] Java Enterprise Edition HttpServletRequest \nAPI, 2006. http://java.sun.com/javaee/5/docs/api/javax/ servlet/http/HttpServletRequest.html. [4] A. \nAiken, J. S. Foster, J. Kodumal, and T. Terauchi. Checking and Inferring Local Non-Aliasing. In PLDI \n03, pages 129 140, June 2003. [5] C. Andreae, J. Noble, S. Markstrum, and T. Millstein. A framework for \nimplementing pluggable type systems. In OOPSLA 06, pages 57 74, 2006. [6] K. Arnold, J. Gosling, and \nD. Holmes. The Java Program\u00adming Language. Addison-Wesley, 4th edition, 2006. [7] S. Artzi, M. D. Ernst, \nD. Glasse, and A. Kiezun. Combined static and dynamic mutability analysis. Technical Report MIT-CSAIL-TR-2006-065, \nMIT CSAIL, Sept. 2006. [8] A. Birka and M. D. Ernst. A practical type system and language for reference \nimmutability. In OOPSLA 04, pages 35 49, Oct. 2004. [9] P. Broadwell, M. Harren, and N. Sastry. Scrash: \nA System for Generating Secure Crash Information. In Usenix Security 03, Aug. 2003. [10] B. Chin, S. \nMarkstrum, and T. Millstein. Semantic type quali.ers. In PLDI 05, pages 85 95, 2005. [11] B. Chin, S. \nMarkstrum, T. Millstein, and J. Palsberg. Inference of User-De.ned Type Quali.ers and Quali.er Rules. \nIn ESOP 06, pages 264 278, Mar. 2006. [12] J. Dean, D. Grove, and C. Chambers. Optimizatin of Object-Oriented \nPrograms Using Static Class Hierarchy Analysis. In ECOOP 95, pages 77 101, Aug. 1995. [13] M. D. Ernst \nand D. Coward. JSR 308: Annotations on Java types. http://jcp.org/en/jsr/detail?id=308, July 2007. [14] \nJ. S. Foster, M. F\u00a8ahndrich, and A. Aiken. A Theory of Type Quali.ers. In PLDI 99, pages 192 203, May \n1999. [15] J. S. Foster, R. Johnson, J. Kodumal, and A. Aiken. Flow-Insensitive Type Quali.ers. ACM TOPLAS, \n28(6):1035 1087, Nov. 2006. [16] J. S. Foster, T. Terauchi, and A. Aiken. Flow-Sensitive Type Quali.ers. \nIn PLDI 02, pages 1 12, June 2002. [17] T. E. Foundation. Eclipse Project. Web pages at http: //www.eclipse.org. \n[18] T. Fraser, J. Nick L. Petroni, and W. A. Arbaugh. Applying .ow-sensitive CQUAL to verify MINIX authorization \ncheck placement. In PLAS 06, 2006. [19] T. Freeman and F. Pfenning. Re.nement types for ML. In PLDI 91, \npages 268 277, 1991. [20] M. Furr and J. S. Foster. Polymorphic Type Inference for the JNI. In ESOP 06, \npages 309 324, Mar. 2006. [21] V. Haldar, D. Chandra, and M. Franz. Dynamic Taint Propagation for Java. \nIn ACSAC 05, pages 303 311, 2005. [22] A. Igarashi, B. C. Pierce, and P. Wadler. Featherweight Java: \na minimal core calculus for Java and GJ. ACM TOPLAS, 23(3):396 450, 2001. [23] Java-Gnome Developers. \nJava bindings for the gnome and gtk libraries. http://java-gnome.sourceforge.net. [24] R. Johnson and \nD. Wagner. Finding User/Kernel Bugs With Type Inference. In Usenix Security 04, Aug. 2004. [25] M. S. \nLam, J. Whaley, V. B. Livshits, M. C. Martin, D. Avots, M. Carbin, and C. Unkel. Context-sensitive program \nanalysis as database queries. In PODS 05, pages 1 12, 2005. [26] O. Lhot\u00b4ak and L. Hendren. Scaling Java \npoints-to analysis using Spark. In CC 03, pages 153 169, 2003. [27] O. Lhotak and L. Hendren. Jedd: a \nBDD-based Relational Extension of Java. In PLDI 04, pages 158 169, 2004. [28] S. Liang. The Java Native \nInterface: Programmer s Guide and Speci.cation. Addison-Wesley, 1999. [29] Y. Liu and A. Milanova. Ownership \nand Immutability Inference for UML-based Object Access Control. In ICSE 07, pages 323 332, 2007. [30] \nB. Livshits, J. Whaley, and M. S. Lam. Re.ection Analysis for Java. In APLAS 05, pages 139 160, 2005. \n[31] A. Milanova, A. Rountev, and B. G. Ryder. Parameterized Object Sensitivity for Points-to Analysis \nfor Java. ACM TOSEM, 14(1):1 41, 2005. [32] R. Milner. A Theory of Type Polymorphism in Programming. \nJCSS, 17:348 375, 1978. [33] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. CIL: Intermediate Language \nand Tools for Analysis and Transformation of C Programs. In CC 02, pages 213 228, Apr. 2002. [34] P. \nPratikakis, J. Spacco, and M. Hicks. Transparent Proxies for Java Futures. In OOPSLA 04, pages 206 223, \n2004. [35] W. Pugh. JSR 305: Annotations for Software Defect Detection, 2006. http://jcp.org/en/jsr/detail?id= \n305. [36] J. Rehof and M. F\u00a8ahndrich. Type-Based Flow Analysis: From Polymorphic Subtyping to CFL-Reachability. \nIn POPL 01, pages 54 66, Jan. 2001. [37] T. Reps. Undecidability of context-sensitive data-independence \nanalysis. ACM TOPLAS, 22(1):162 186, 2000. [38] T. Reps, S. Horwitz, and M. Sagiv. Precise Interprocedural \nData.ow Analysis via Graph Reachability. In POPL 95, pages 49 61, Jan. 1995. [39] A. Rountev. Precise \nIdenti.cation of Side-effect-free Methods in Java. In ICSM 04, pages 82 91, Sept. 2004. [40] B. G. Ryder. \nDimensions of Precision in Reference Analysis of Object-oriented Programming Languages. In CC 03, pages \n126 137, 2003. [41] A. Salcianu and M. Rinard. Purity and Side Effect Analysis for Java Programs. In \nVMCAI 05, Jan. 2005. [42] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. Detecting Format String \nVulnerabilities with Type Quali.ers. In Usenix Security 01, Aug. 2001. [43] M. Sridharan and R. Bodik. \nRe.nement-based Context\u00adsensitive Points-to Analysis for Java. In PLDI 06, pages 387 400, 2006. [44] \nM. Sridharan, D. Gopan, L. Shan, and R. Bodik. Demand\u00addriven Points-to Analysis for Java. In OOPSLA 05, \npages 59 76, 2005. [45] R. E. Strom and S. Yemini. Typestate: A programming language concept for enhancing \nsoftware reliability. IEEE Trans. Softw. Eng., 12(1):157 171, 1986. [46] M. S. Tschantz. Javari: Adding \nreference immutability to Java. Master s thesis, MIT Dept. of EECS, Aug. 2006. MIT\u00adCSAIL-TR-2006-059. \n[47] M. S. Tschantz and M. D. Ernst. Javari: Adding reference immutability to Java. In OOPSLA 05, pages \n211 230, Oct. 2005. [48] J. Whaley and M. S. Lam. Cloning-based Context-sensitive Pointer Alias Analysis \nusing Binary Decision Diagrams. In PLDI 04, pages 131 144, 2004. [49] X. Zhang, A. Edwards, and T. Jaeger. \nUsing CQUAL for Static Analysis of Authorization Hook Placement. In Usenix Security 02, Aug. 2002.  \n \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Java's type system provides programmers with strong guarantees of type and memory safety, but there are many important properties not captured by standard Java types. We describe JQual, a tool that adds user-defined <i>type qualifiers</i> to Java, allowing programmers to quickly and easily incorporateextra lightweight, application-specific type checking into their programs. JQual provides type qualifier inference, so that programmers need only add a few key qualifier annotations to their program, and then JQual infers any remaining qualifiers and checks their consistency. We explore two applications of JQual. First, we introduce opaque and enumqualifiers to track C pointers and enumerations that flow through Java code via the JNI. In our benchmarks we found that these C values are treated correctly, but there are some places where a client could potentially violate safety. Second,we introduce a read only qualifier for annotating references that cannot be used to modify the objects they refer to. We found that JQual is able to automatically infer read only in many places on method signatures. These results suggest that type qualifiers and type qualifier inference are a useful addition to Java.</p>", "authors": [{"name": "David Greenfieldboyce", "author_profile_id": "81100590105", "affiliation": "University of Maryland, College Park, MD", "person_id": "P721554", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey S. Foster", "author_profile_id": "81338488852", "affiliation": "University of Maryland, College Park, MD", "person_id": "PP39087107", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297051", "year": "2007", "article_id": "1297051", "conference": "OOPSLA", "title": "Type qualifier inference for java", "url": "http://dl.acm.org/citation.cfm?id=1297051"}