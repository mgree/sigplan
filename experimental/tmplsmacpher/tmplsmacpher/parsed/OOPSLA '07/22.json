{"article_publication_date": "10-21-2007", "fulltext": "\n Tracking Bad Apples: Reporting the Origin of Null and Unde.ned Value Errors * Michael D. Bond Nicholas \nNethercote Stephen W. Kent Dept. of Computer Sciences National ICT Australia Dept. of Computer Sciences \nUniversity of Texas at Austin njn@csse.unimelb.edu.au University of Texas at Austin mikebond@cs.utexas.edu \nstephenkent@mail.utexas.edu Samuel Z. Guyer Kathryn S. McKinley Dept. of Computer Science Dept. of Computer \nSciences Tufts University University of Texas at Austin sguyer@cs.tufts.edu mckinley@cs.utexas.edu Abstract \nPrograms sometimes crash due to unusable values, for ex\u00adample, when Java and C# programs dereference \nnull point\u00aders and when C and C++ programs use unde.ned values to affect program behavior. A stack trace \nproduced on such a crash identi.es the effect of the unusable value, not its cause, and is often not \nmuch help to the programmer. This paper presents ef.cient origin tracking of unusable values; it shows \nhow to record where these values come into existence, correctly propagate them, and report them if they \ncause an error. The key idea is value piggybacking:when the original program stores an unusable value, \nvalue piggy\u00adbacking instead stores origin information in the spare bits of the unusable value. Modest \ncompiler support alters the pro\u00adgram to propagate these modi.ed values through operations such as assignments \nand comparisons. We evaluate two im\u00adplementations: the .rst tracks null pointer origins in a JVM, and \nthe second tracks unde.ned value origins in a memory\u00adchecking tool built with Valgrind. These implementations \nshow that origin tracking via value piggybacking is fast and often useful, and in the Java case, has \nlow enough overhead for use in a production environment. * This work is supported by an Intel fellowship, \nNSF CCF-0429859, NSF CCR-0311829, NSF EIA-0303609, DARPA F33615-03-C-4106, In\u00adtel, IBM, and Microsoft. \nAny opinions, .ndings and conclusions expressed herein are the authors and do not necessarily re.ect \nthose of the sponsors. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4eal, Qu\u00b4ebec, Canada. Copyright c . 2007 ACM 978-1-59593-786-5/07/0010. \n. . $5.00 Categories and Subject Descriptors D.2.5 [Software En\u00adgineering]: Testing and Debugging Debugging \naids General Terms Reliability, Performance, Experimentation Keywords Debugging, Low-Overhead Run-Time \nSupport, Null Pointer Exceptions, Unde.ned Values, Managed Lan\u00adguages, Java, Valgrind 1. Introduction \nFinding the causes of bugs is hard, both during testing and after deployment. One reason is that a bug \ns effect is often far from its cause. Liblit et al. examined bug symptoms for various programs and found \nthat inspecting the methods in a stack trace did not identify the method containing the error for 50% \nof the bugs [21]. This paper offers help for a class of bugs due to unusable values that either cause \na failure directly or result in erro\u00adneous behavior. In managed languages such as Java and C#, the null \nvalue is unusable and causes a null pointer exception when dereferenced. In languages like C and C++, \nunde.ned values those that are uninitialized, or derived from unde\u00ad.ned values are unusable, and their \nuse can cause various problems such as silent data corruption, altered control .ow, or a segmentation \nfault. Failures due to unusable values are dif.cult to debug be\u00adcause (1) the origin of the unusable \nvalue may be far from the point of failure, having been propagated through assign\u00adments, operations, \nand parameter passing; and (2) unusable values themselves yield no useful debugging information. At best, \nthe programmer sees a stack trace from the crash point, but this identi.es the effect of the unused value, \nnot its source. This problem is particularly bad for deployed soft\u00adware since the bug may be dif.cult \nto reproduce. Null pointer exceptions are a well-known problem for Java programmers. Eric Allen writes \nthe following in Di\u00adagnosing Java for the IBM developerWorks Java Zone [2]: Of all the exceptions a Java \nprogrammer might encounter, the null-pointer exception is among the most dreaded, and for good reason: \nit is one of the least informative exceptions that a program can signal. Unlike, for example, a class\u00adcast \nexception, a null-pointer exception says nothing about what was expected instead of the null pointer. \nFurthermore, it says nothing about where in the code the null pointer was actually assigned. In many \nnull-pointer exceptions, the true bug occurs where the variable is actually assigned to null. To .nd \nthe bug, we have to trace back through the .ow of control to .nd out where the variable was assigned \nand determine whether doing so was incorrect. This process can be particularly frustrating when the assignment \noccurs in a package other than the one in which the error was signaled. Our goal is to provide this information \nautomatically and at a very low cost. Unused value errors are similarly dif.cult to debug for programs \nwritten in unmanaged languages such as C and C++. For example, Memcheck [31] is a memory checking tool \nbuilt with the dynamic binary instrumentation frame\u00adwork Valgrind [26]. Memcheck can detect dangerous \nuses of unde.ned values, but prior to this paper gave no origin information about those values. Requests \nfor such origin in\u00adformation from Memcheck users are common enough that the FAQ explains the reason for \nthis shortcoming [26]. The key question is: why does this variable contain an un\u00adusable value? We answer \nthis question and solve this prob\u00adlem by introducing origin tracking. Origin tracking records program \nlocations where unusable values are assigned, so they can be reported at the time of failure. We leverage \nthe property that unusable values are dif.cult to debug because they contain no useful information and \nstore the origin infor\u00admation in place of the unusable values themselves,which is aform of value piggybacking. \nValue piggybacking requires no additional space, making origin tracking ef.cient. With some modi.cations \nto program execution, origin values .ow freely through the program: they are copied, stored in the heap, \nor passed as parameters. They thus act like normal un\u00adusable values until the programs uses them inappropriately, \nwhereupon we report the origin, which is often exactly what the programmer needs to diagnose the defect. \nWe implement two separate origin tracking implementa\u00adtions: one tracks null pointer origins in Java, \nand the other tracks origins of unde.ned values in binaries of C, C++, For\u00adtran, and other languages. \nFor the null pointer implementa\u00adtion, we modify Jikes RVM [3, 16], a high-performance vir\u00adtual machine. \nThe unde.ned value implementation is built on top of the memory checking tool Memcheck [31]. Both origin \ntracking implementations are publicly available (Sec\u00adtions 2 and 5). Our results show that origin tracking \nis effective at re\u00adporting the origins of Java null pointer exceptions and adds minimal overhead to overall \nexecution time (4% on average), making it suitable for deployed programs. We collected a test suite of \n12 null pointer exceptions from publicly available Java programs with documented, reproducible bugs. \nBased on examining the stack trace, origin, source code, and bug report, we determine that origin tracking \ncorrectly reports the origin for all of the 12 bugs in this test suite, provides in\u00adformation not available \nfrom the stack trace for 8 bugs, and is useful for debugging in 7 of those 8 cases. Origin tracking in \nMemcheck is accurate for 32-bit un\u00adde.ned values but fails to identify origins for values too small to \nhold a program location. It .nds 72% of unde.ned value errors involving 32-bit data in 20 C and C++ programs. \nMemcheck is a heavy-weight instrumentation tool, and it al\u00adready slows programs down by a factor of 28 \non average. Our additions to Memcheck add on average no measurable overhead. The main contributions of \nthis work are: Value piggybacking to record and propagate debugging information in place of unusable \nvalues.  Two new applications of value piggybacking for origin tracking: (a) identifying the origins \nof null pointer excep\u00adtions in deployed Java programs cheaply and (b) identify\u00ading the origins of unde.ned \nvalues in C, C++, and Fortran programs at testing time.  These applications are notable because previous \nvalue pig\u00adgybacking applications conveyed only one or two bits of in\u00adformation per value (e.g., [20]), \nwhereas we show it can con\u00advey more useful information. Since our approach requires modest changes to \nthe Java virtual machine and incurs very low overhead, commercial JVMs could rapidly deploy it to help \nprogrammers .nd and .x bugs.  2. Origin Tracking in Java This section describes our implementation for \ntracking the origins of null references in Java programs. In each subsec\u00adtion, we .rst describe the general \nstrategy used to piggyback information on null references, and then describe the details speci.c to our \nJikes RVM implementation. 2.1 Supporting Nonzero Null References Java virtual machines typically use \nthe value zero to repre\u00adsent a null reference. This choice allows operations on null references, such \nas comparisons and detection of null pointer exceptions, to be simple and ef.cient. However, the Java \nVM speci.cation does not require the use of a particular concrete value for encoding null [22]. We modify \nthe VM to instead represent null using a range of reserved addresses. Objects may not be allocated to \nthis range, allowing null and object references to be differentiated easily. Our implementation reserves \naddresses in the lowest 32nd of the address space: 0x00000000 0x07ffffff.That is, a reference is null \nif and only if its highest .ve bits are Table 1. How origin tracking handles uses of null in Java code. \nColumn 2 shows example code involving null. Column 3 shows typical semantics for an unmodi.ed VM. Column \n4 shows semantics in a VM implementing origin tracking. Java semantics Standard VM Origin tracking (a) \nAssignment of null constant obj = null; obj = 0; obj = this location; (b) Object allocation obj = new \nObject(); ... allocate object ... foreach ref slot i obj[i] = 0; ... call constructor ... ... allocate \nobject ... foreach ref slot i obj[i] = this location; ... call constructor ... (c) Null reference comparison \nb = (obj == null); b = (obj == 0); b = ((obj &#38; 0xf8000000) == 0) (d) General reference comparison \nb = (obj1 == obj2); b = (obj1 == obj2); if (((obj1 &#38; 0xf8000000) == 0)) b = ((obj2 &#38; 0xf8000000) \n== 0); else b = (obj1 == obj2); zero. The remaining 27 bits encode a program location as described in \nthe next section. As an alternative to a contiguous range of null values, null could be represented as \nany value with its lowest bit set. Object references and null could be differentiated easily since object \nreferences are word-aligned. VMs such as Jikes RVM that implement null pointer exceptions using hardware \ntraps could instead use alignment traps. We did not imple\u00adment this approach since unmodi.ed Jikes RVM \ncompiled for IA32 performs many unaligned accesses already (align\u00adment checking is disabled by default \non IA32).  2.2 Encoding Program Locations The strategy described above provides 27 bits for encoding \nan origin in a null reference. We use one of these bits to dis\u00adtinguish between two cases: nulls that \noriginate in a method body (the common case) and nulls that result from unini\u00adtialized static .elds. \nIn the latter case, the remaining 26 bits identify the particular .eld. In the former case, we encode \nthe program location as a <method, line number> pair us\u00ading one more bit to choose from among the following \ntwo layouts for the remaining 25 bits: 1. The default layout uses 13 bits for method ID and 12 bits for \nbytecode index, which is easily translated to a line number. 2. The alternate layout uses 8 bits for \nmethod ID and 17 bits for bytecode index, and is used only when the bytecode index does not .t in 12 \nbits. The few methods that fall into this category are assigned separate 8-bit identi.ers.  We .nd these \nlayouts handle all the programs in our test suite for origin tracking. Alternatively, one could assign \na unique 27-bit value to each program location that assigns null via a lookup table. This approach would \nuse space proportional to the size of the program to store the mapping. Our approach adds no space since \nper-method IDs already exist in the VM. 2.3 Rede.ning Program Operations. Our implementation rede.nes \nJava operations to accommo\u00addate representing null using a range of values. Null Assignment At null assignments, \nour modi.ed VM assigns the 27-bit value corresponding to the current pro\u00adgram location (method and line \nnumber) instead of zero. The dynamic compiler computes this value at compile time. Ta\u00adble 1, row (a) \nshows the null assignment in Java and its corre\u00adsponding semantics for an unmodi.ed VM and for the origin \na VM implementing origin tracking. Object Allocation When a program allocates a new object, whether scalar \nor array, its reference slots are initialized to null by default. VMs implement this ef.ciently by allocating \nobjects into mass-zeroed memory. Since origin tracking uses nonzero values to represent null, our modi.ed \nVM adds code at object allocations that initializes each reference slot to the program location, as shown \nin Table 1, row (b). These values identify the allocation site as the origin of the null. Since reference \nslot locations are known at allocation time, we can modify the compiler to optimize the code inserted \nat allocation sites. For hot sites (determined from pro.les, which are collected by Jikes RVM and other \nVMs), the compiler inlines the code shown in the last column of Table 1, row (b). If the number of slots \nis a small, known constant (true for all small scalars, as well as small arrays where the size is known \nat compile time), the compiler .attens the loop. Static .elds are also initialized to null, but during \nclass initialization. We modify the VM s class initialization to .ll each static reference .eld with \na value representing the static .eld (the VM s internal ID for the .eld). Of the 12 bugs we evaluate \nin Section 3, one manifests as a null assigned at class initialization time. Null Comparison To implement \nchecking whether a ref\u00aderence is null, VMs compare the reference to zero. Origin tracking requires a \nmore complex comparison since null may have any value from a range. Since our implementation uses the \nrange 0x00000000 0x07ffffff for null, it implements the null test using a bitwise AND with 0xf8000000,as \nshown in Table 1, row (c). General Reference Comparison A more complex case is when a program compares \ntwo references. With origin track\u00ading, two references may have different underlying values even though \nboth represent null. To handle this case, the ori\u00adgin tracking implementation uses the following test: \ntwo ref\u00aderences are the same if and only if (1) they are both nonzero null values or (2) their values \nare the same. Table 1, row (d) shows the modi.ed VM implementation. We optimize this test for the common \ncase: non-null ref\u00aderences. The instrumentation .rst tests if the .rst reference is null; if so, it jumps \nto an out-of-line basic block that checks the second reference. Otherwise, the common case performs a \nsimple check for reference equality, which is suf.cient since both references are now known to be non-null. \n 2.4 Implementation in Jikes RVM We implement origin tracking in Jikes RVM, a high-perfor\u00admance Java-in-Java \nvirtual machine [5, 16]. Our imple\u00admentation is publicly available on the Jikes RVM Research Archive \n[17]. Jikes RVM uses two dynamic compilers. When a method .rst executes, Jikes RVM compiles it with a \nnon-optimizing, baseline compiler. As a method becomes hotter, Jikes RVM recompiles it with an optimizing \ncompiler at successively higher levels of optimization. We modify both compilers to rede.ne Java operations \nto support piggybacking of origins on null values. Our implementation stores program locations instead \nof zero (Table 1, rows (a) and (b)) only in application code, not in VM code or in the Java standard \nlibraries. This choice re\u00ad.ects developers overriding interest in source locations in their application \ncode. Since the VM is not implemented en\u00adtirely in pure Java it needs C-style memory access for low\u00adlevel \nruntime features and garbage collection generating nonzero values for null in the VM and libraries would \ncon\u00adfuse parts of the VM that assume null is zero. Since null ref\u00aderences generated by the application \nsometimes make their way into the VM and libraries, our implementation modi.es all reference comparisons \nto handle nonzero null references (Table 1, rows (c) and (d)) in the application, libraries, and VM. \nSome VMs including Jikes RVM catch null pointer ex\u00adceptions using a hardware trap handler: since low \nmemory is protected, dereferencing a null pointer generates the sig\u00adnal SIGSEGV. The VM s custom hardware \ntrap handler de\u00adtects this signal and returns control to the VM, which throws a null pointer exception. \nThe origin tracking implementa\u00adtion protects the address range 0x00000000 0x07ffffff so null dereferences \nwill result in a trap. For origin tracking, we modify the trap handler to identify and record the cul\u00adprit \nbase address, which is the value of the null reference. When control is returned to the VM, it decodes \nthe value into a program location and reports it together with the null pointer exception. VMs that use \nexplicit null checks to de\u00adtect null pointer exceptions could simply use modi.ed null checks as described \nin Section 2.3. The Java Native Interface (JNI) communicates with un\u00admanaged languages such as C and \nC++, allowing unman\u00adaged code to access Java objects. The unmanaged code as\u00adsumes that null is zero. \nWe therefore modify the VM to iden\u00adtify null parameters passed to JNI methods, and to replace them with \nzero. This approach loses origin information for these parameters but ensures correct execution.  3. \nFinding and Fixing Bugs in Java Programs This section describes a case study using origin tracking to \nidentify the causes of 12 failures in eight programs. These results are summarized in Table 2, which \ncontains the lines of code measured with the Unix wc command; whether the origin was identi.ed; whether \nthe origin was identi.able trivially; and how useful we found the origin report (these criteria are explained \nin detail later in this section). We describe three of the most interesting cases (Cases 1, 2, and 3) \nin detail below and the other nine in the appendix. In summary, our experience showed: The usefulness \nof origin information depends heavily on the complexity of the underlying defect. In some cases, it is \ncritical for diagnosing a bug. Given the extremely low cost of origin tracking (see Section 4), there \nis little rea\u00adson not to provide this extra information, which speeds debugging even when a defect is \nrelatively trivial.  Bug reports often do not contain suf.cient information for developers to diagnose \nor reproduce a bug. Origin tracking provides extra information for users to put in bug reports in addition \nto a stack trace.  It is not always clear whether the defect lies in the code producing the null value, \nor in the code dereferencing it (e.g., the dereferencing code should add a null check). A stack trace \nalone only provides information about the dereferencing code. Origin tracking allows programmers to consider \nboth options when formulating a bug .x.  Null pointer exceptions often involve a null value .ow\u00ading \nbetween different software components, such as ap\u00adplication code and library code. Therefore, even when \nthe origin and dereference occur close together it can be dif\u00ad.cult to evaluate the failure without a \nfull understanding of both components. For example, a programmer might trigger a null pointer exception \nin a library method by passing it an object with a .eld that is unexpectedly null. Origin tracking indicates \nwhich null store in the applica\u00adtion code is responsible, without requiring extra knowl\u00adedge or source \ncode for the library.  Case Program Lines Exception description Origin? Trivial? Useful? 1 Mckoi SQL \nDB 94,681 Access closed connection Yes Nontrivial De.nitely useful 2 FreeMarker 64,442 JUnit test crashes \nunexpectedly Yes Nontrivial De.nitely useful 3 JFreeChart 223,869 Plot without x-axis Yes Nontrivial \nDe.nitely useful 4 JRefactory 231,338 Invalid class name Yes Nontrivial De.nitely useful 5 Eclipse 2,425,709 \nMalformed XML document Yes Nontrivial Most likely useful 6 Checkstyle 47,871 Empty default case Yes Nontrivial \nMost likely useful 7 JODE 44,937 Exception decompiling class Yes Nontrivial Most likely useful 8 Jython \n144,739 Use built-in class as variable Yes Nontrivial Potentially useful 9 JFreeChart 223,869 Stacked \nXY plot with lines Yes Somewhat nontrivial Marginally useful 10 Jython 144,739 Problem accessing doc \nattribute Yes Somewhat nontrivial Marginally useful 11 JRefactory 231,338 Package and import on same \nline Yes Trivial Not useful 12 Eclipse 2,425,709 Close Eclipse while deleting project Yes Trivial Not \nuseful Table 2. The diagnostic utility of origins returned by origin tracking in Java. Cases 1, 2, and \n3 are described in detail in Section 3; the rest are described in the appendix. Bug repositories are \non SourceForge [32] except for Eclipse [10] and Mckoi SQL Database [24]. 3.1 Evaluation Criteria For \neach error, we evaluate how well origin tracking per\u00adforms using three criteria: Origin identi.cation. \nDoes origin tracking correctly return the method and line number that assigned the null respon\u00adsible \nfor the exception? Triviality. Is the stack trace alone, along with the source code, suf.cient to identify \nthe origin? In 8 of 12 null pointer exceptions, the origin is not easy to .nd via in\u00adspection of the \nsource location identi.ed by the stack trace. Usefulness. Does knowing the origin help with understand\u00ading \nand .xing the defect? Although we are not the devel\u00adopers of these programs, we examined the source code \nand also looked at bug .xes when available. We believe that the origin report is not useful or marginally \nuseful for one-third of the cases; potentially or most likely use\u00adful for another third; and most likely \nor de.nitely useful for the remaining third of the cases. 3.2 Origin Tracking Case Studies We now describe \nthree bugs that highlight origin tracking s role in discovering the program defect. Case 1: Mckoi SQL \nDatabase: Access Closed Connection The .rst case highlights an important bene.t of origin track\u00ading: \nit identi.es a null store far away from the point of failure (possibly in another thread). The location \nof the store iden\u00adti.es The bug report comes from a user s message on the mail\u00ading list for Mckoi SQL \nDatabase version 0.93, a database management system for Java (Message 02079). The user reports that the \ndatabase throws a null pointer exception when the user s code attempts to execute a query. The bug report \ncontains only the statement dbStatement.\u00adexecuteUpdate(dbQuery); and a stack trace, so we use information \nfrom the developer s responses to construct a test case. Our code arti.cially induces the failure but \ncap\u00adtures the essence of the problem. The stack trace is shown in Figure 1(a). This information presents \ntwo problems for the application developer. First, the failure is in the library code, so it cannot be \neasily debugged. Second, it indicates simply that the query failed, with no error message or exception \nindicating why. Our origin information, shown in Figure 1(b), reveals the reason for the failure: the \nnull store occurred in Abstract\u00adJDBCDatabaseInterface.internalDispose() at line 298. This method is part \nof closing a connection; line 298 assigns null to the connection object reference. The cause of the failure \nis that the query attempts to use a connection that has already been closed. The origin information may \nbe useful to both the appli\u00adcation user and the database library developers. Users can probably guess \nfrom the name of the method Abstract\u00ad java.lang.NullPointerException: at com.mckoi.database.jdbcserver.JDBCDatabaseInterface. \nexecQuery():213 at com.mckoi.database.jdbc.MConnection. executeQuery():348 at com.mckoi.database.jdbc.MStatement. \nexecuteQuery():110 at com.mckoi.database.jdbc.MStatement. executeQuery():127 at Test.main():48 (a) Origin: \ncom.mckoi.database.jdbcserver. AbstractJDBCDatabaseInterface.internalDispose():298 (b) Figure 1. Case \n1: VM output for Mckoi SQL Database bug. (a) The stack trace shows the query failed inside the library. \n (b) Origin tracking suggests that the failure is due to a closed connection.  java.lang.NullPointerException: \nat freemarker.template.WrappingTemplateModel.wrap():131 at freemarker.template.SimpleHash.get():197 at \nfreemarker.core.Environment.getVariable():959 at freemarker.core.Identifier._getAsTemplateModel():70 \nat freemarker.core.Expression.getAsTemplateModel():89 ... at junit.textui.TestRunner.main():138 (a) Origin: \nfreemarker.template.DefaultObjectWrapper.instance (b) Figure 2. Case 2: VM output for FreeMarker bug. \n(a) The stack trace shows the fault location. (b) The null s origin is an uninitialized static .eld. \njava.lang.NullPointerException: at org.jfree.chart.plot.FastScatterPlot.draw():447 at Bug2.test():16 \nat Bug2.main():9 (a) Origin: Bug2.test():13 (b) Figure 3. Case 3: VM output for JFreeChart bug. (a) The \nstack trace shows a failure inside the library. (b) Origin tracking identi.es the error is caused by \na null from user code. JDBCDatabaseInterface.internalDispose() that the problem is a closed connection, \nand can plan for this pos\u00adsibility in their application logic. The developers can also modify the execQuery() \nmethod to check for a closed con\u00adnection and to throw a useful SQLException that reports the reason, \nas noted in an existing response on the mailing list. Case 2: FreeMarker: JUnit Test Crashes Unexpectedly \nThe second case illustrates how origin tracking helps diag\u00adnose errors when the null reference passes \nfrom variable to variable by assignment. The case is also interesting because at .rst glance the initial \nassignment appears to be non-null, but it is in fact null because of a static initialization ordering \nissue. FreeMarker 2.3.4 is a Java library that generates output such as HTML and source code using user-de.ned \ntem\u00adplates. We reproduced an exception in the library using test code posted by a user (Bug 1354173). \nFigure 2 shows the exception stack trace. The exception occurs at line 131 of wrap(), which tries to \ndereference defaultObjectWrapper, which is null. Pre\u00adviously, defaultObjectWrapper was assigned the value \nof the static, .nal .eld DefaultObjectWrapper.instance. At .rst glance, it appears that DefaultObjectWrapper\u00ad.instance \nis properly initialized: static final DefaultObjectWrapper instance = new DefaultObjectWrapper(); However, \ndue to a circular initialization dependency be\u00adtween WrappingTemplateModel and DefaultObject-Wrapper, \ninstance is in fact initialized to null. Origin tracking helps diagnose this error by reporting the unini\u00adtialized \nstatic .eld instance as the origin of the offending null. The origin should be quite useful for diagnosing \nthe bug since (1) the null passes through a variable, and (2) it is not intuitive that the original assignment \nassigns null. A responder to the bug report also came to the conclusion that the exception is a result \nof static class initialization ordering, but to our knowledge it has not been .xed in any version of \nFreeMarker. Case 3: JFreeChart: Plot Without X-Axis This case in\u00advolves a small test program provided \nby a bug reporter that causes a null pointer exception inside JFreeChart 1.0.2, a graphing library (Bug \n1593150). This case, like the .rst case in this section, represents an important class of failures for \nwhich origin tracking is useful: the failure is induced by the application, but since it occurs inside \nthe library the pro\u00adgrammer has no easy way to interpret the stack trace or to debug the library code. \nThe following is code provided by the user, annotated with line numbers: 12: float[][] data = {{1.0f,2.0f},{3.0f,4.0f}}; \n13: FastScatterPlot plot = new FastScatterPlot(data, null, null); 14: Button aButton = new Button(); \n15: Graphics2D graphics = (Graphics2D)(aButton.getGraphics()); 16: plot.draw(graphics, new Rectangle2D.Float(), \nnew Point2D.Float(), null, null); Figure 3(a) shows the exception stack trace. The method FastScatterPlot.draw(), \ncalled from line 16 of the user code, throws a null pointer exception. This stack trace is not very helpful \nto the library user, who may not have access to or be familiar with the JFreeChart source code. On the \nother hand, origin tracking provides information that is directly useful to the user: the origin is line \n13 of the user s test() (Figure 3). The user can quickly understand that the exception occurs because \nthe code passes null as the x-axis parameter to the FastScatterPlot constructor. While the origin allows \na frustrated user to modify his or her code immediately, it also suggests a better long-term .x: for \nJFreeChart to return a helpful error message. The devel\u00adopers diagnosed this bug separate from us, and \ntheir solution, implemented in version 1.0.3, causes the constructor to fail with an error message if \nthe x-axis parameter is null. Remaining Cases The appendix contains details of the remaining nine bugs. \n  4. Java Run-Time Performance This section evaluates the performance impact of piggyback\u00ading origins \non null values in Java programs. 4.1 Methodology Execution For our Java experiments we run Jikes RVM \nin two different just-in-time compilation modes: adaptive mode and replay mode. The adaptive mode results \nshow the overall effect of origin tracking in a deployed setting, while the replay mode results allow \nus to measure the individual performance factors. In adaptive compilation mode, which is the default, \nJikes RVM dynamically identi.es frequently executed methods and recompiles them at higher optimization \nlevels. Many JVMs use this strategy, and thus the adaptive mode results represent the expected bottom-line \ncost of using origin track\u00ading in deployed software. The way adaptive mode is implemented, however, makes \nit dif.cult to break out the components of performance over\u00adhead: how much is due to the extra cost of \ncompiling the ori\u00adgin tracking code, and how much is due to executing the ori\u00adgin tracking code. The \nadaptive compiler uses timer-based sampling to make compilation decisions, and therefore the additional \ncost of value piggybacking alters these decisions, making it dif.cult to compare runs with and without \norigin tracking. To address this problem, we use replay compilation methodology, which is deterministic. \nReplay compilation forces Jikes RVM to compile the same methods in the same order at the same point in \nexecution on different executions and thus avoids variability due to the compiler. Replay compilation \nuses advice .les produced by a previ\u00adous well-performing adaptive run (best of .ve). The advice .les \nspecify (1) the optimization level for compiling each method, (2) the dynamic call graph pro.le, and \n(3) the edge pro.le. Fixing these inputs, we execute two consecutive it\u00aderations of the application. \nDuring the .rst iteration, Jikes RVM optimizes code using the advice .les. The second it\u00aderation executes \nonly the application with a realistic mix of optimized code. We execute each benchmark in a high-performance \ncon\u00ad.guration: we use a heap size .xed at three times the min\u00adimum necessary for that benchmark to run \nusing a gener\u00adational mark-sweep garbage collector. For replay compila\u00adtion, we report the minimum run-time \nof .ve trials since it represents the run least perturbed by external effects. For adaptive runs, we \nperform 25 trials because of high variabil\u00adity and report the median to discount outliers. Benchmarks \nWe evaluate the performance of origin track\u00ading using the DaCapo benchmarks (version 2006-10), SPEC JVM98, \nand a .xed-workload version of SPEC JBB2000 called pseudojbb [8, 33, 34]. We omit xalan from replay experiments \nbecause we could not get it to run correctly with replay compilation, with or without origin tracking. \nWe perturb the methodology of several replay experi\u00adments that otherwise execute incorrectly; the determinism \nof replay means exposed VM bugs often occur consistently. We execute pmd with 3.1 times the minimum heap \ninstead of 3.0 because 3.0 exposes a VM bug. For the same rea\u00adson, we execute chart with a generational \ncopying collector and pmd with a full-heap mark-sweep collector (these bench\u00admarks would not execute \ncorrectly in any heap size with a generational mark-sweep collector). Platform We perform our experiments \non a 3.6 GHz Pen\u00adtium 4 with a 64-byte L1 and L2 cache line size, a 16KB 8\u00adway set associative L1 data \ncache, a 12K\u00b5ops L1 instruction trace cache, a 2MB uni.ed 8-way set associative L2 on-chip cache, and \n2GB main memory, running Linux 2.6.12. 4.2 Space Overhead Except for one ID per application method, \norigin tracking adds no space overhead because it uses value piggybacking to store program locations \nin place of null references. 4.3 Execution Time Overhead Figure 4 shows the application execution overhead \nof ori\u00adgin tracking. We report the second run of replay methodol\u00adogy, during which only the application \nexecutes. We present several con.gurations that represent various origin tracking functionality levels \n(presented in order of monotonically in\u00adcreasing functionality): Base is application execution time. \nAll bars are normal\u00adized to Base.  Simple checks includes all origin tracking functionality except for \ntwo key but relatively costly components: (1) instrumentation to support general reference compar\u00adisons \nand (2) initialization of nulls to program locations at object allocation time. Simple checks adds 1% \nover\u00adhead on average.  Ref compare adds support for general reference compar\u00adisons to Simple checks. \nRef compare adds 1% over Simple checks, for a total of about 2% on average.  Origin tracking adds initialization \nof nulls at object allo\u00adcation time to Ref compare, and this con.guration con\u00adtains all functionality \nneeded to track and report origins for null pointer exceptions. Origin tracking adds 1% over Ref compare, \nfor a total of 3% on average.   4.4 Compilation Overhead Origin tracking increases compilation time \nbecause it adds instrumentation to the application that rede.nes reference comparison and sets null references \nat object allocation. Fig\u00adure 5 shows the overhead origin tracking adds to compilation for the same con.gurations \nas in Figure 4. We determine compilation time by measuring time spent in the compiler during the .rst \nrun of replay compilation, which compiles  1.2 1.0 0.8 0.6 0.4 0.2 0.0  Figure 4. Application execution \ntime overhead of origin tracking. Base Simple checks Ref compare Origin tracking  Normalized execution \ntimeNormalized compilation time 1.2 1.0 0.8 0.6 0.4 0.2 0.0 Figure 5. Compilation time overhead of origin \ntracking. Base Simple checks Ref compare Origin tracking Figure 6. Adaptive methodology performance \nof origin tracking. The tall bars are overall execution time, while the sub\u00adbars are the fraction of \ntime spent in compilation. and executes the application. Origin tracking adds 10% com\u00adpilation overhead \non average and 19% at most (pseudojbb). Compilation time, however, is a very small fraction of over\u00adall \nexecution time (see below). 4.5 Overall Run-Time Overhead Finally, we use adaptive methodology to measure \nthe overall performance effect of origin tracking. Figure 6 shows com\u00adbined application and compilation \noverhead for the same ori\u00adgin tracking con.gurations as in Figures 4 and 5. The bars are overall execution \ntime, and the sub-bars are the fraction of time spent compiling. On average, origin tracking adds 4% \nto overall execution time. Compilation time is a small fraction of overall time: it increases from 0.043 \nin Base to 0.051 in Origin tracking. Compilation time varies consider\u00adably for single benchmarks, presumably \nbecause of the in\u00adterplay between compilation and application execution.   5. Unde.ned Variables in \nC &#38; C++ Programs In this section, we present another application of value piggybacking: tracking \nthe origins of unde.ned values in C, C++, and Fortran programs. We .rst describe Mem\u00adcheck [31], a tool \nbuilt with Valgrind [26] that validates memory usage in programs. We then describe how we mod\u00adify Memcheck \nto piggyback origins on unde.ned values. Our results show that origin tracking adds only negligible overhead \nto Memcheck, although Memcheck alone slows down execution on average by a factor of 28. Memcheck reports \n147 unde.ned value warnings on our test suite of 20 C, and C++, and Fortran programs. Of these warnings, \n47 are for 32-bit values (in which it is possible to .t a program location), and our enhanced MemCheck \nreports the origin for 34 (72%) of these warnings. Memcheck cannot report origins for the remaining warnings \nsince they involve values smaller than 32 bits, so they cannot .t a program location. Our version of \nMemcheck is publicly available as a branch in the Valgrind source repository: svn://svn.valgrind.org/valgrind/branches/ORIGIN_TRACKING \n5.1 Memcheck Memcheck [31] is implemented in Valgrind [26], a frame\u00adwork for heavyweight dynamic binary \ninstrumentation. Memcheck works on programs written in any language, but it is most useful for those \nwritten in C and C++ in which memory errors are common. Memcheck detects memory\u00adrelated defects such \nas bad or repeated frees of heap blocks (blocks allocated with malloc, new, or new[]), memory leaks, \nheap buffer over.ows, and wild reads and writes. It detects these defects by recording two kinds of metadata: \n(a) heap block information such as size, location, and a stack trace for its allocation point, and (b) \na single Abit ( A for addressability ) per memory byte, which indicates if the byte is legally accessible. \nMemcheck detects dangerous uses of unde.ned values by shadowing every register and memory byte with 8 \nV bits ( V for validity ) that indicate if the value bits are de.ned (i.e., initialized, or derived from \nother de.ned values). It up\u00addates and propagates these bits through memory and regis\u00adters in parallel \nwith normal computation. To minimize false positives Memcheck only warns users about uses of unde\u00ad.ned \nvalues that can change the program s behavior. These uses fall into four cases. 1. The program uses an \nunde.ned value in a conditional branch or conditional move, potentially changing the pro\u00adgram s control \n.ow. 2. The program uses an unde.ned value as a branch target address, potentially changing the program \ns control .ow. 3. The program provides an unde.ned value as an input to a system call, potentially changing \nthe program s side effects. 4. The program uses an unde.ned value as the address in a load or store, \npotentially causing an incorrect value to be used, which could subsequently change the program s control \n.ow or side effects.  In contrast, Memcheck does not warn about benign uses, such as copying or operating \non unde.ned values, because these operations are not inherently erroneous and are very common. For example, \nprograms copy not-yet-initialized .elds in C structs and copy empty bytes in structs due to padding between \n.elds. This delayed reporting avoids many false-positive warnings. For example, the simplest hello world \nprogram causes hundreds of false positive errors with eager reporting. For unde.ned inputs to system \ncalls, Memcheck already gives useful origin information since the value is usually in a memory block; \nfor example, the unde.ned value may be in a .lename string argument. However, for unde.ned conditions, \nload/store addresses, and branch target address, the unde.ned value is in a register, and Memcheck has \nno useful origin information for it. Users of Memcheck com\u00adplain about this case enough that it warranted \nan entry in Valgrind s frequently asked questions (FAQ) .le (starting in version 3.2.2) [26]. 5.2 Memcheck \nImplementation Details This section describes how we modify Memcheck to piggy\u00adback origins on unde.ned \nvalues. Since the values are unde\u00ad.ned, we can assign them whatever value we choose. First we present \nhow our implementation encodes program loca\u00adtions, then how it rede.nes program operations to accom\u00admodate \npiggybacked unde.ned values, and .nally how it re\u00adports origins when an unde.ned value is used in a potentially \nharmful way. Representing Origins Memcheck stores context-sensitive origins for heap-allocated variables \nand context-insensitive origins for stack-allocated variables. Memcheck already computes and stores a \nstack trace for each heap block at allocation. The stack trace includes the allocation site and its dynamic \ncalling context. Memcheck stores stack traces in a calling context tree [4] and uses the 32-bit address \nof this data structure as the origin key, i.e., a value from which it can identify an origin. Our modi.ed \nMemcheck paints each newly allocated heap block with re\u00adpeated copies of the origin key. The exception \nis heap blocks allocated with calloc, which must be initialized with ze\u00adroes. Memcheck takes a similar \nbut lighter-weight approach to unde.ned values allocated on the stack. Because stack al\u00adlocations are \nso frequent, recording a stack trace for every one would be expensive. Instead, Memcheck records a static \n(context-insensitive) code location for each stack allocation, which it it determines at instrumentation \ntime for ef.ciency. When the stack allocation occurs, our modi.ed implemen\u00adtation paints the memory block \nwith the appropriate origin key. Modifying Program Operations No changes are required for copying or \nfor operations that involve normal program values. Nor are any changes required to Memcheck s shadow \nvalues operations. Thanks to value piggybacking, the origin values get propagated for free. Unlike the \nJava implementa\u00adtion, origins can be lost if certain operations modify unde\u00ad.ned values. For example, \nif an unde.ned value holding an origin key is added to a nonzero de.ned value, the resulting value will \nbe unde.ned, but its origin information has been lost. Reporting Origins To report the origins of unde.ned \nvalue warnings, we modify Memcheck at unde.ned value warning checks to read the origin key from the unde.ned \nvalue and look up the corresponding program location. If the origin key exists, Memcheck reports the \nlocation as the likely ori\u00adgin for the unde.ned value. Conditional branches and moves complicate identifying \nthe origin key since their input is a single-bit condition. We need to search backwards to .nd one or \nmore 32-bit values from which the unde.ned con\u00addition bit was derived. At instrumentation time, our imple\u00admentation \nperforms a backwards data.ow trace to .nd all 32-bit values that are ancestors of the condition bit. \nFor ex\u00adample, if the program compares two 32-bit values and then uses the result as a condition, then \neach of the values is re\u00adported as a possible origin if it is unde.ned at run time (de\u00adtermined by examining \nthe V bits when the warning is is\u00adsued). The backwards searching is limited because Valgrind instruments \ncode in small chunks (superblocks) that are usu\u00adally 3 50 instructions in length. This limitation can \ndegrade the accuracy of the origin report. Figure 7 shows an example unde.ned value warning that includes \nan origin. The defect involves allocating a heap Conditional jump or move depends on uninitialised value(s) \nat 0x8048439: g (a.c:20) by 0x8048464: f (a.c:25) by 0x80484A5: main (a.c:34) Uninitialised value has \npossible origin 1 at 0x40045D5: malloc (vg_replace_malloc.c:207) by 0x804848F: main (a.c:32) Figure 7. \nA Memcheck unde.ned value warning involving an origin. block in main(), passing an uninitialized 32-bit \nvalue to a function f(), which then passes it to g(), which then compares the value to another in an \nif-then-else. The .rst half of the warning is what is printed by Memcheck without origin tracking. The \nsecond half of the warning is added by origin tracking: it identi.es the origin the original heap allocation \npoint. 5.3 Discussion We discuss here some limitations of origin tracking due to Memcheck and the C \nand C++ programming model, poten\u00adtial solutions, and related topics. Missed Origins Due to Small Values \nThe biggest limita\u00adtion of origin tracking in Memcheck is that it cannot track program locations well \nin fewer than 32 bits, and therefore it does not report origins for unde.ned value defects involv\u00ading \n8-or 16-bit data. Sixteen bits is just not enough to store a code location for even moderately large \nprograms. This problem does not affect the Java implementation because Java null pointers are always \nword-sized. To address this problem, we tried performing partial matching : reporting every origin for \nwhich the 8 or 16 bits in the unde.ned value matched an 8-or 16-bit fragment of an origin key. But this \napproach resulted in many incorrect matches, particularly in the 8-bit case. Unfortunately, the 8\u00adbit \nand 16-bit cases occur often (Section 5.4). Another possible approach is to store less precise infor\u00admation, \nsuch as a .le or method identi.er in these small values. But this would result in less information for \nthe 32\u00adbit case as well we cannot tell ahead of time which parts of a memory block will be used as 32-bit \nvalues and which as 8-or 16-bit values. Alternatively, it would be possible to execute the program again \nwith information from the .rst run to narrow down the number of matches, although this would be less \nconvenient for programmers. A complete so\u00adlution would store the origins separately, as is done for the \nV bits, rather than use piggybacking, but this solution requires extra space and time, losing the advantages \nof piggybacking. Missed Origins Due to Other Reasons Origins can fail to be identi.ed in the 32-bit case \nfor two reasons. First, if an unde.ned value is modi.ed, it will no longer match its ori\u00adgin key. We \ncould prevent modi.cations of origin values, but the extra checks required for almost every operation \nwould be expensive. We tried unsuccessfully to perform fuzzier matching : requiring that only three of \nthe four bytes in the unde.ned value matched the origin key. Second, if an un\u00admodi.ed, unde.ned 32-bit \nvalue is loaded via an unaligned load, the unde.ned value will not match a key because the bytes will \nbe out of order. Again, fuzzier matching could help: if there are no matches, Memcheck could try rotat\u00ading \nthe bytes of the value before matching. We .nd that un\u00adaligned accesses are not common enough to warrant \nthis ad\u00addition. Incorrect Origins There is a small chance that a 32-bit un\u00adde.ned value that has been \nmodi.ed may match a different origin key, giving the wrong origin. For this reason we al\u00adways describe \nan origin as a possible origin in the warning messages. Changing Program Behavior Assigning origin keys \nto unde.ned memory, instead of the often fortuitously found zero, may change a program s behavior. However, \nthis is ac\u00adceptable as it does not change the program s semantics the changes are within an envelope \nof behavior that is already unde.ned. Also, in this setting, we assume the programmer is trying to identify \ndefects, and is .xing defects in the order Memcheck identi.es them. Execution becomes increasingly unreliable \nas more errors occur. 64-Bit Machines The technique extends simply to 64-bit machines. It is worthwhile \nto keep the origin keys 32-bits, because integers on 64-bit machines are 32-bits. We can ei\u00adther use \npartial matching of 32-bit unde.ned values against 64-bit origin keys, or just use 32-bit origin keys \n(e.g., asso\u00adciate a random 32-bit key with each stack trace instead of using the address of the stack \ntrace data structure). 5.4 Accuracy of Origin Tracking in Memcheck To determine the accuracy of Memcheck \ns origin tracking, we found 20 C, C++, and Fortran programs for which the unaltered version of Memcheck \nissues at least one unde.ned value warning. Three of these (facerec, parser, twolf) are from the SPEC \nCPU2000 suite. The other 17 were found just by trying programs present on a Linux machine more or less \nat random. Unde.ned value errors are common enough that we found the 17 programs in about two hours. \nTable 3 summarizes the results. For these programs, the unaltered Memcheck issues 147 unde.ned value \nwarnings that lack origin information. Memcheck does not reissue warnings that look similar to previous \nones in order to avoid uninteresting duplication of warnings. Nonetheless, it is pos\u00adsible that a single \nunde.ned value defect can result in more than one warning. Of the 147 unde.ned value warnings is\u00adsued \nby Memcheck, 100 involve 8-bit or 16-bit unde.ned values, for which our technique cannot identify origins. \nTwo programs, ps2pdf and xpdf, account for 57 of these small value warnings. We suspect that many of \nthese are 8-bit warnings related to defects involving strings. Program (static instrs) Total 32-bit values \nOrigin None <32-bit None dvips (42K) 1 0 0 1 facerec (38K) 1 1 0 0 .refox (1770K) 6 0 0 6 glibc (12K) \n8 8 0 0 ispell (82K) 1 1 0 0 kanagram (401K) 8 0 1 7 kbounce (453K) 14 0 5 9 kpdf (612K) 1 1 0 0 oof.ce \n(2967K) 1 0 0 1 parser (41K) 2 0 0 2 pdf2ps (166K) 13 5 0 8 ps2ascii (231K) 4 4 0 0 ps2pdf (150K) 24 \n1 0 23 pstree (19K) 3 0 0 3 python (81K) 13 10 3 0 twolf (52K) 2 2 0 0 vim (76K) 2 0 0 2 x.g (135K) 4 \n0 2 2 xfontsel (90K) 2 0 0 2 xpdf (230K) 37 1 2 34 Total 147 34 13 100 Table 3. Unde.ned value warnings \nand Memcheck s success at identifying their origins. Of the 47 unde.ned value warnings involving 32-bit \nval\u00adues for which Memcheck could possibly report origins, it reports 34 (72%). The 13 cases where it \nfailed to identify an origin must involve unaligned memory or modi.ed un\u00adde.ned values, as discussed \nin Section 5.3. We tried some partial (24-bit) and fuzzy (rotated) value matching in an at\u00adtempt to identify \nmore origins, but only a single extra origin was identi.ed, for python. We have not evaluated the usefulness \nof the Memcheck origin reports since we focused in this paper on the Java implementation, but we suspect \nunde.ned value origins will help programmers since they tell programmers something they would otherwise \nneed to .gure out manually. 5.5 Overhead of Origin Tracking in Memcheck To measure the overhead of origin \ntracking in Memcheck, we run SPEC CPU2000 benchmarks (except for galgel, which gfortran failed to compile). \nWe use the training in\u00adputs, which are smaller than the reference inputs, but the experimental runs took \nmore than 24 hours with training inputs alone, and we believe the results would not give no\u00adticeably \ndifferent results in this case. Prior, unrelated experi\u00adments with Memcheck also found that using the \nlarger inputs made made minimal differences to timing results. The test machine was a 2.6GHz Pentium \n4 (Northwood) with 2GB RAM and a 512KB L2 cache. We implemented origin track\u00ading in a pre-3.3.0 development \nversion of Memcheck. Figure 8 shows the results of measuring Memcheck with and without origin tracking. \nMemcheck alone slows pro\u00ad Base Origin tracking 100 90 80 70 60 50 40 30 20 10 0 Slowdown Figure 8. Memcheck \ns slowdown without and with ori\u00adgin tracking. grams down by a factor of 28x (comparable to prior re\u00adsults \n[31]). The main cost of origin tracking is the painting of heap and stack blocks with the origin keys. \nHowever, the overall performance impact of origin tracking is negligible. At worst, Memcheck with origin \ntracking worsens the slow\u00addown factor for eon from 75.7x to 85.9x, and at best it im\u00adproves the slow-down \nfactor for gcc from 63.0x to 57.3x. This level of variation is likely due to factors such as differ\u00adent \ncache behavior caused by the extra writes to uninitialized memory blocks.  6. Related Work Previous \nwork related to origin tracking and unusable val\u00adues can be divided into three categories: (a) dynamic \nap\u00adproaches that help diagnose bugs when they occur, (b) static approaches that detect bugs before the \nprogram is run, and (c) language design approaches which reduce or eliminate the chance of such bugs \noccurring altogether. Dynamic Approaches Origin tracking can be considered a special case of dynamic \nprogram slicing [1,25].Dynamic slices include most or all statements that affect a value via control \nor data-dependence. Dynamic slicing provides infor\u00admation for any value, not just unusable values, and \ndynamic slicing provides all statements affecting a value, not just the value s origin. However, dynamic \nslicing is very expensive, e.g., 10-100X slowdowns are typical, while origin tracking uses value piggybacking \nto make it ef.cient enough for de\u00adployed software. TraceBack records a .xed amount of control .ow (similar \nto dynamic slicing but without data.ow) during execution and reports it in the event of a crash [6]. \nTraceback provides control .ow information leading up to the fault, while origin tracking provides the \ndata-.ow origin of the faulting value. Purify and Memcheck detects a similar class of errors. Purify \neagerly reports some unde.ned value as soon as they are loaded from memory. These operations are closer \nto the unde.ned values origins, but eager reporting can cause false positives. Although, Purify prunes \nthese reports by using static analysis to identify unde.ned values that de.nitely do not cause errors. \nMemcheck instead delays reporting of unde.ned values to the point where they change program behavior, \nwhich yields fewer false positives and together with origin tracking is more accurate. TaintCheck is \na security tool that tracks which values are tainted (i.e., from untrusted sources), and detects if they \nare used in dangerous ways [27]. TaintCheck shadows each byte, recording for each tainted value: the \nsystem call from which it originated, a stack trace, and the original tainted value. Thus TaintCheck \nuses a form of explicit origin track\u00ading that requires both extra space and time (extra operations are \nrequired to propagate the taint values). Value piggyback\u00ading would not be appropriate for TaintCheck \nbecause tainted values cannot have other values piggybacked onto them as they do not have spare bits. \nSaber is a memory-checking tool that stores a special one bit canary value in unde.ned values [20], which \nindi\u00adcates unde.nedness. Our Memcheck implementation instead notes de.ned/unde.ned separately in its \nV bits and stores more complex information (origins) in the unde.ned values. Zhang et al. improve dynamic \nslicing by identifying omis\u00adsion errors, statements that lead to an error because they did not execute \n[36]. Some unde.ned value errors are the re\u00adsult of omission errors, but our origin tracking approach \nre\u00adports only statements that executed, rather than statements that should have executed but did not. \nRecent novel work on anomaly-based bug detection uses multiple program runs to identify program behavior \nfeatures correlated with errors [13, 21, 23, 37]. Origin tracking is complementary to these approaches \nsince they detect the causes of many types of bugs besides unusable value errors, while origin tracking \nmay be able to .nd bug causes not de\u00adtected by invariant violations. Anomaly-based bug detection adds \noverhead too high for deployed use [13] or requires multiple runs to detect bug causes [21, 23, 37], \nwhereas our Java implementation of origin tracking works ef.ciently in a single deployed run. An alternative \nto detecting bugs is to tolerate them auto\u00admatically at run time [7, 29, 30]. For example, Rx rolls back \nto a previous state and tries to re-execute in a different en\u00advironment [29]. DieHard uses random memory \nallocation, padding, and redundancy to probabilistically decrease the chances of errors [7]. These approaches \nare most suitable for pointer and memory corruption errors, rather than semantic errors such as unde.ned \nvalues. Static Analysis Previous bug detection work includes a number of static analysis algorithms for \ndetecting bugs. Pattern-based systems such as PMD are effective at identify\u00ading potential null dereferences \nbut lack the data.ow analysis often needed to identify the reason for the bug [28]. Find-Bugs uses data.ow \nanalysis to identify null dereferences and includes a notion of con.dence to reduce the false positive \nrate [14, 15]. ESC/Java uses a theorem prover to check that pointer dereferences are non-null [11]. Both \nFindBugs and ESC/Java are primarily intraprocedural, and rely on user annotations to eliminate false \npositives due to method pa\u00adrameters and return values. JLint and Metal include an in\u00adterprocedural component \nto track the states of input param\u00adeters [12, 18]. The advantage of static analysis is that it detects \nbugs without having to execute the buggy code. Unfortunately, static tools suffer from two signi.cant \nlimitations. First, they often produce many false positives because they rely on coarse approximations \nof dynamic program behavior, since context and .ow-sensitive analysis is too expensive for large programs. \nSecond, few if any build a model of the heap pre\u00adcise enough to track null values through loads and stores. \nIn contrast, our origin tracking approach reports information only for errors that occur, and tracks \nthe origin through ar\u00adbitrarily long and complex code sequences, including loads and stores to the heap, \nwithout losing precision. Several static bug detectors, including PMD, FindBugs, and Metal, are made \nintentionally unsound to reduce the false positive rate. This choice, however, allows code with bugs \nto pass silently through the system and fail at run-time. Origin tracking complements these systems: \nit can diagnose the more complex bugs that they miss. Language Design The unusable value bugs discussed \nin this paper are a consequence of two particular language features: (a) pointer values are overloaded \nto represent a pointer to something (non-null) or a pointer to nothing (null), and (b) the declaration \nof a variable is separate from its initialization and the assignment can be easily forgotten. An alternative \nto detecting these bugs is to prevent them from happening by choosing a language that does not have these \nfeatures. Java, Chalin and James [9] propose extending Java with never null pointer types, which are \nthe default, and requir\u00ading possibly null pointers to be annotated specially. This feature makes it harder \nto forget to initialize pointers, but as long as null pointers are possible, the problem can still occur. \nFunctional languages avoid both problems. First, vari\u00adables are only introduced when they are bound to \nvalues, so it is impossible for a variable to be uninitialized. Second, they use explicit types to represent \nnothing, allowing the type checker to make sure that programs handle these cases. However, it is still \npossible for variables to have unexpected values, causing a program to fail at run-time. 7. Conclusions \nDevelopers need all the help they can get when debugging. We present a lightweight approach for tracking \nthe origins of null pointers in Java programs and unde.ned values in Memcheck. The key to origin tracking \ns ef.ciency is that program locations are stored in place of null and unde.ned values, avoiding space \noverhead and signi.cant time over\u00adhead since the locations propagate via normal program data .ow. The \nMemcheck implementation of origin tracking adds no overhead, on average, to provide origin information \nat testing time, and .nds origins for 72% of the 32-bit unde\u00ad.ned value errors. The Java implementation \nadds just 4% to overall execution time. Origins are useful for 7 of 12 real bugs, and the toughest bugs \nare those helped most by ori\u00adgin knowledge. Given its minimal footprint and productivity bene.ts, origin \ntracking is ideal for commercial VMs where it can enhance debugging in existing and future deployed software. \n  Acknowledgments We would like to thank Julian Seward for many helpful dis\u00adcussions about the Memcheck \nimplementation; Jason Davis and Ben Wiedermann for testing out our implementation of origin tracking; \nBen Wiedermann for help understanding the Jython source; and Simha Sethumadhavan, Julian Seward, and \nthe anonymous reviewers for valuable feedback about the paper text. Appendix This appendix describes \nthe exceptions from Table 2 not covered inSection3. Case 4: JRefactory: Invalid Class Name This case \nshows how origin tracking helps diagnose an improperly initialized reference that is used later and elsewhere \nin the program. We triggered a previously unknown failure in JRefactory 2.9.18 by accident while trying \nto reproduce Case 11 s fail\u00adure. Perhaps due to pre-submission fatigue, one of us wrote the following \nclass declaration (it should be just Bug, not Bug.java): public class Bug.java { Figure 9(a) shows the \nstack trace produced when JRefactory processes a class containing the incorrect class declaration. Inspection \nof the code at the point of the exception shows that JRefactory correctly detects the invalid class name \nand attempts to print a useful error message. However, the er\u00adror message code fails because it dereferences \nthe return value of ExceptionPrinter.getInstance(),which re\u00adturns ExceptionPrinter.singleton, which is \nnull. java.lang.NullPointerException: at net.sourceforge.jrefactory.factory.ParserFactory. getAbstractSyntaxTree():46 \nat org.acm.seguin.pretty.PrettyPrintFile.apply():102 at org.acm.seguin.tools.builder.PrettyPrinter. visit():77 \nat org.acm.seguin.io.DirectoryTreeTraversal. traverse():91 at org.acm.seguin.io.DirectoryTreeTraversal.run():43 \n... at PrettyPrinter.main():54 (a) Origin: org.acm.seguin.awt.ExceptionPrinter.<clinit>():70 (b) Figure \n9. Case 4: VM output for a JRefactory bug. (a) The stack trace alone shows that a parse error was encountered. \n(b) Origin tracking shows that the error reporting data struc\u00adture was not properly initialized. java.lang.NullPointerException: \nat gnu.xml.dom.DomDocument.checkNewChild():315 at gnu.xml.dom.DomDocument.appendChild():341 at org.eclipse.pde.internal.builders.XMLErrorReporter. \nendDocument():159 at gnu.xml.stream.SAXParser.parse():669 at javax.xml.parsers.SAXParser.parse():273 \n... at org.eclipse.core.internal.jobs.Worker.run():76 (a) Origin: org.eclipse.pde.internal.builders. \nManifestConsistencyChecker.checkFile():76 (b) Figure 10. Case 5: VM output for an Eclipse bug. (a) The \nstack trace alone indicates a parsing error. (b) Origin track\u00ading identi.es the source of the exception. \nFigure 9(b) shows the origin: the class initializer sets ExceptionPrinter.singleton to null, and it is \nnot mod\u00adi.ed after that. On inspection, we found that the other methods in ExceptionPrinter automatically \ninitialize the singleton .eld whenever it is null, and we believe this behavior is needed in the getInstance() \nmethod as well. We submitted this bug and the suggested .x to JRefactory s bug tracker (Bug 1674321), \nbut as of the camera-ready copy there has been no response. Case 5: Eclipse #1: Malformed XML Document \nThe Eclipse integrated development environment (IDE) version 3.2 [10] can fail when a user provides an \nimproper XML document specifying a plugin project s extensions. If the XML document is malformed and \ncontains no root element, Eclipse throws a null pointer exception when attempting to parse the document. \nWhile the stack trace indicates that the failure occurred during parsing, the origin information ex\u00adpresses \nthat the XML documents lacks a root element. Figure 10(a) shows the stack trace produced by this null \npointer exception. Without origin tracking, determining the cause using the stack trace alone would be \nquite dif.cult, since the null value is an input parameter to the method. Fur\u00adther investigation with \nthe debugger would involve following the value back through a series of method calls. The origin tracking \ninformation, shown in Figure 10(b), reveals exactly what is wrong with the XML .le. The null value originates \nin the code that checks the consistency of the .le. The speci.c origin location indicates that the XML \nfRootElement s value is initialized to null and never set to any other value. This value is then passed \nto endDocument, and on to appendChild and .nally to checkNewChild. We reported this bug to Eclipse developers \n(Bug 176500). Developers determined the bug was in the underlying XML parser, which is separate from \nEclipse, and they were unable to reproduce the bug in the latest version of Eclipse (3.3). Given that \nthe origin shows that fRootElement was never initialized, we believe this report would most likely help \n.x a bug in the XML parser. Case 6: Checkstyle: Empty Default Case Checkstyle checks Java source code \nfor compliance to a coding stan\u00addard. Checkstyle s bug tracker contains a bug report describ\u00ading how \nto reproduce a null pointer exception in Version 4.2 (Bug 1472228). The exception occurs when Checkstyle \npro\u00adcesses code where the default case has no statements. We reproduced this bug by providing a class \nto Checkstyle with the following switch statement: switch(x) { case 0: test = true; break; default: } \nWithout origin tracking, Figure 11(a) shows the resulting exception stack trace. We show code with line \nnumbers from FallThroughCheck.checkSlist(): 195: DetailAST lastStmt = aAST.getLastChild(); 196: 197: \nif (lastStmt.getType() == TokenTypes.RCURLY) { 198: lastStmt = lastStmt.getPreviousSibling(); 199: } \n200: 201: return (lastStmt != null) &#38;&#38; 202: isTerminated(lastStmt, aUseBreak, aUseContinue); \nThe exception occurs because lastStmt is null at line 197. However, it is not clear what that null value \nsigni.es, or whether it is safe to simply skip processing lastStmt in the case that it is null. The extra \ninformation provided by origin tracking, shown in Figure 11(b), helps to answer this question. Origin \ntrack\u00ading shows that the null value originates in the Antlr parser component, meaning that the value \nis set to null during pars\u00ad java.lang.NullPointerException: at com.puppycrawl.tools.checkstyle.checks.coding. \nFallThroughCheck.checkSlist():197 at com.puppycrawl.tools.checkstyle.checks.coding. FallThroughCheck.isTerminated():168 \nat com.puppycrawl.tools.checkstyle.checks.coding. FallThroughCheck.visitToken():136 at com.puppycrawl.tools.checkstyle.TreeWalker. \nnotifyVisit():500 at com.puppycrawl.tools.checkstyle.TreeWalker. processIter():625 ... at com.puppycrawl.tools.checkstyle.Main.main():127 \n(a) Origin: antlr.ASTFactory.make():323 (b) Figure 11. Case 6: VM output for Checkstyle bug. (a) Stack \ntrace indicates an error checking a fall-through case. (b) The origin shows the null value originated \nwhen constructing the program AST. java.lang.NullPointerException: at jode.decompiler.ClassAnalyzer.<init>():96 \nat jode.decompiler.ClassAnalyzer.initialize():220 at jode.decompiler.ClassAnalyzer.dumpJavaFile():620 \nat jode.decompiler.ClassAnalyzer.dumpJavaFile():613 at jode.decompiler.Main.decompileClass():184 at jode.decompiler.Main.decompile():376 \nat jode.decompiler.Main.main():203 (a) Origin: jode.bytecode.ClassInfo.forName():157 (b) Figure 12. Case \n7: VM output for JODE bug. (a) The stack trace alone indicates that an inner class has a null pointer \nto its outer class. (b) Origin tracking tells us that the outer class may never have been initialized. \njava.lang.NullPointerException: at org.python.core.ListFunctions.__call__():48 at org.python.core.PyObject.invoke():2105 \nat org.python.pycode._pyx8.f$0():<console> at org.python.pycode._pyx8.call_function():<console> at org.python.core.PyTableCode.call():155 \n... at org.python.util.jython.main():178 (a) Origin: org.python.core.PyClass.__findattr__():178 (b) Figure \n13. Case 8: VM output for a Jython bug. (a) Ex\u00adception output provided by the VM. (b) Extra information \nprovided by origin tracking. ing rather than in some (possibly erroneous) part of the Checkstyle code \nitself. Thus the origin should help devel\u00adopers determine that the null value is not erroneous and sim\u00adply \nindicates a case with no statements. A response to the bug report notes that adding a null check .xes \nthe bug, and developers implemented the .x in Checkstyle 4.3. Case 7: JODE: Exception Decompiling Class \nJava Op\u00adtimize and Decompile Environment (JODE) is a package that includes a decompiler and optimizer \nfor Java. We re\u00adproduced a bug in version 1.1.1 that occurs when trying to decompile a particular class \n.le (Bug 821212). While the stack trace identi.es the immediate cause of the failure, the origin information \nshows that an important logical depen\u00addence (between inner and outer classes) is not being main\u00adtained \nproperly. Figure 12(a) shows the stack trace produced by this fail\u00adure. The exception occurs during initialization \nof an inner class because a pointer to information about the outer class is null. With the stack trace \nand the source code, we were un\u00adable to understand why this pointer was null. Furthermore, we could not \n.nd source for the class to be decompiled (pro\u00advided in the bug report), which is not surprising since \nthe user reporting the bug wanted to decompile it! The reported origin, shown in Figure 12(b), indicates \nthat the pointer to the outer class is null at the allocation site for the inner class information object. \nThe .eld is initialized to null and never set anywhere else, leading us to believe that the outer class \nmay not have been loaded and initialized yet. The origin information is likely to be useful to developers, \nsince it reveals a problem with the logic involved in JODE s class loading. We added the information \nto the of.cial bug report. However, the bug remains un.xed. Case 8: Jython: Use Built-In Class as Variable \nJython is an implementation of the Python language integrated with Java. We reproduce an exception from \nan entry on the jython-dev mailing list archive, dated September 17, 2001 [19], that applies to Jython \n2.0. The exception occurs when the user uses a built-in method as a class variable, which should be a \nvalid operation. Figure 13 shows the exception stack trace for this bug, and the extra information origin \ntracking provides. We ex\u00adamined the source code and found that the source of the null reference is far \nremoved from the null pointer excep\u00adtion. Thus, the information provided by origin tracking is nontrivial. \nWe were unable to understand this bug well enough to .x it or to determine if the information provided \nby origin tracking is useful. A Jython expert examined the source and determined that the implementation \nwas not advanced enough to handle using a built-in class as a variable [35]. The bug is .xed in Jython \n2.2 (we could not reproduce the bug in 2.2), although we could not .nd any record of the .x, and we were \nunable to determine the .x by inspection because of the large differences between the two versions. java.lang.NullPointerException: \nat org.jfree.chart.renderer.xy.StackedXYAreaRenderer. drawItem():457 at Bug.test():52 at Bug.main():20 \n(a) Origin: org.jfree.chart.renderer.xy.StackedXYAreaRenderer$ StackedXYAreaRendererState.<init>():138 \n(b) Figure 14. Case 9: VM output for a JFreeChart bug. (a) The exception stack trace. (b) The null reference \ns origin. java.lang.NullPointerException: at org.python.core.PyObject.getDoc():360 at java.lang.reflect.Method.invoke():147 \nat org.python.core.PyGetSetDescr.__get__():55 at org.python.core.PyObject.object___findattr__():2770 \nat org.python.core.PyObject.__findattr__():1044 ... at org.python.util.jython.main():214 (a) Origin: \norg.python.core.PyObject.fastGetDict():2723 (b) Figure 15. Case 10: VM output for a Jython bug. (a) Excep\u00adtion \noutput provided by vanilla VM. (b) Extra information provided by origin tracking. java.lang.NullPointerException: \nat org.acm.seguin.pretty.PrettyPrintVisitor. removeLastToken():1184 at org.acm.seguin.pretty.PrettyPrintVisitor.visit():979 \nat org.acm.seguin.pretty.PrettyPrintFile.apply():129 at org.acm.seguin.pretty.PrettyPrintFile.apply():105 \nat org.acm.seguin.tools.builder.PrettyPrinter. visit():77 ... at PrettyPrinter.main():54 (a) Origin: \norg.acm.seguin.pretty.PrettyPrintVisitor. removeLastToken():1177 (b) Figure 16. Case 11: VM output for \na JRefactory bug. (a) Exception output provided by vanilla VM. (b) Extra infor\u00admation provided by origin \ntracking. Case 9: JFreeChart: Stacked XY Plot with Lines JFree-Chart is an advanced library for displaying \ncharts in Java applications. A null pointer exception occurs when an ap\u00adplication attempts to generate \na stacked XY plot that has lines enabled in Version 1.0.0 (Bug 1593156). Figure 14(a) shows the exception \nstack trace that occurs. The stack trace shows that the exception occurs when JFreeChart derefer\u00adences \nStackedXYAreaRenderer.lines, which is null. Origin tracking reports the constructor for StackedXY\u00adAreaRendered,where \nStackedXYAreaRenderer.lines is initialized to null (Figure 14(b)). This information tells de\u00advelopers \nthat lines is null because it is initialized to null at allocation time, rather than being assigned null \nlater. How\u00adever, since lines is private and is not assigned anywhere besides the constructor, it is fairly \neasy to reach this conclu\u00adsion by inspection of the class alone. Developers .xed the bug in the next \nversion of JFreeChart by initializing lines to a default Line2D object. Attribute Case 10: Jython: Program \nAccessing doc We found the second Jython bug on Jython s bug tracker (Bug 1462188). The null pointer \nexception occurs when try\u00ading to access the doc attribute of a dictionary object. Figure 15 shows the \nexception output and the extra infor\u00admation origin tracking provides. Examining Jython s source, we .nd \nthat PyObject.fastGetDict() is called from the line that causes the exception (PyObject.java:360). Thus, \norigin tracking s information is not very insight\u00adful because the null reference s source program location \nis not far removed from its dereference. However, since PyObject.fastGetDict() is a virtual method that \nis over\u00adridden in six different subclasses, origin tracking does nar\u00adrow down the source of the null \nreference from seven possi\u00adbilities to one. This information will save a developer time in understanding \nthe bug, especially if the bug is not repro\u00adducible. According to the bug report, developers .xed the \nbug simply by checking if the value returned by fastGetDict() is null. If so, getDoc() then returns rather \nthan dereferenc\u00ading the null pointer. Case 11: JRefactory: Package and Import on Same Line JRefactory \nis a refactoring tool for Java. JRefactory 2.9.18 throws a null pointer exception when provided a Java \nsource .le with the package and import declarations on the same line (Bug 973332): package edu.utexas; \nimport java.io.*; Figure 16 shows that the null s origin (line 1177) is just seven lines above the exception \ns occurrence (line 1184), and static inspection of the code reveals that the null pointer exception can \nonly occur when line 1177 is the origin, so the information provided by origin tracking is trivial in \nthis case. We were unable to understand this bug well enough to .x it, and no .x has yet been reported. \n Case 12: Eclipse: Close Eclipse While Deleting Project If the user initiates a delete of a project with \nan open .le and then immediately tries to close the Eclipse application before the delete is complete, \nEclipse 3.1.2 throws a null pointer exception (Bug 142749). The exception occurs be\u00adcause Eclipse attempts \nto save the open .le upon application   java.lang.NullPointerException: at org.eclipse.ui.internal.EditorManager$7.run():1323 \nat org.eclipse.core.internal.runtime.InternalPlatform. run():1044 at org.eclipse.core.runtime.Platform.run():783 \nat org.eclipse.ui.internal.EditorManager. saveEditorState():1282 at org.eclipse.ui.internal.EditorManager. \nsaveState():1203 ... at org.eclipse.core.launcher.Main.main():948 (a) Origin: org.eclipse.core.internal.resources.Resource. \ngetLocation():876 (b) Figure 17. Case 12: VM output for an Eclipse bug. (a) Ex\u00adception output provided \nby vanilla VM. (b) Extra informa\u00adtion provided by origin tracking. close, but the save uses a project \nroot object that the delete operation has already nulled. Using the stack trace and origin information \nshown in Figure 17, we examined the Eclipse source code and found that the origin of the null is not \nfar removed from the null pointer exception: EditorManager$7.run() calls a method FileEditorInput.getPath(), \nwhich calls Re\u00adsource.getLocation(), which returns a null constant be\u00adcause the project no longer exists. \nThus, origin tracking pro\u00advides trivial information that is not helpful for .xing this bug.  References \n[1] H. Agrawal and J. R. Horgan. Dynamic Program Slicing. In ACM Conference on Programming Language Design \nand Implementation, pages 246 256, 1990. [2] E. Allen. Diagnosing Java Code: The Dangling Composite bug \npattern. http://www-128.ibm.com/developerworks/\u00adjava/library/j-diag2/, 2001. [3] B. Alpern, C. R. Attanasio, \nJ. J. Barton, M. G. Burke, P. Cheng, J.-D. Choi, A. Cocchi, S. J. Fink, D. Grove, M. Hind, S. F. Hummel, \nD. Lieber,V.Litvinov,M.Mergen, T. Ngo, J. R. Russell, V. Sarkar, M. J. Serrano, J. Shepherd, S. Smith, \nV. C. Sreedhar, H. Srinivasan, and J. Whaley. The Jalape no Virtual Machine. IBM Systems Journal, 39(1):211 \n238, 2000. [4] G. Ammons, T. Ball, and J. R. Larus. Exploiting Hardware Performance Counters with Flow \nand Context Sensitive Pro.ling. In ACM Conference on Programming Language Design and Implementation, \npages 85 96, Las Vegas, NV, 1997. [5] M. Arnold, S. J. Fink, D. Grove, M. Hind, and P. F. Sweeney. Adaptive \nOptimization in the Jalape no JVM. In ACM Conference on Object-Oriented Programming, Systems, Languages, \nand Applications, pages 47 65, 2000. [6] A. Ayers, R. Schooler, C. Metcalf, A. Agarwal, J. Rhee, and \nE. Witchel. TraceBack: First Fault Diagnosis by Reconstruc\u00adtion of Distributed Control Flow. In ACM Conference \non Programming Language Design and Implementation, pages 201 212, 2005. [7] E. D. Berger and B. G. Zorn. \nDieHard: Probabilistic Memory Safety for Unsafe Languages. In ACM Conference on Programming Language \nDesign and Implementation, pages 158 168, 2006. [8] S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, \nK. S. McKinley, R.Bentzur, A.Diwan, D.Feinberg,D.Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, \nH. Lee, J. E. B. Moss, A. Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, D. von Dincklage, and B. Wiedermann. \nThe DaCapo Benchmarks: Java Benchmarking Development and Analysis. In ACM Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications, pages 169 190, 2006. [9] P. Chalin and P. James. Non-null \nreferences by default in java: Alleviating the nullity annotation burden. Technical Report 2006-003, \nConcordia University, 2006. [10] Eclipse.org Home. http://www.eclipse.org/. [11] C. Flanagan, K. R. M. \nLeino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. Extended Static Checking for Java. In ACM \nConference on Programming Language Design and Implementation, pages 234 245, 2002. [12] S. Hallem, B. \nChelf, Y. Xie, and D. Engler. A System and Language for Building System-Speci.c, Static Analyses. In \nACM Conference on Programming Language Design and Implementation, pages 69 82, 2002. [13] S. Hangal and \nM. S. Lam. Tracking Down Software Bugs Using Automatic Anomaly Detection. In ACM International Conference \non Software Engineering, pages 291 301, 2002. [14] D. Hovemeyer and W. Pugh. Finding Bugs is Easy. In \nCompanion to ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications, pages \n132 136, 2004. [15] D. Hovemeyer, J. Spacco, and W. Pugh. Evaluating and Tuning a Static Analysis to \nFind Null Pointer Bugs. In ACM Workshop on Program Analysis for Software Tools and Engineering, pages \n13 19. [16] Jikes RVM. http://www.jikesrvm.org. [17] Jikes RVM Research Archive. http://www.jikesrvm.org/\u00adResearch+Archive. \n[18] Jlint. http://jlint.sourceforge.net. [19] Jython-dev Mailing List. http://sourceforge.net/mailarchive/\u00adforum.php?forum \nid=5587. [20] S. Kaufer, R. Lopez, and S. Pratap. Saber-C: An Interpreter-Based Programming Environment \nfor the C Language. In Summer USENIX Conference, pages 161 71, 1988. [21] B. Liblit, M. Naik, A. X. Zheng, \nA. Aiken, and M. I. Jordan. Scalable Statistical Bug Isolation. In ACM Conference on Programming Language \nDesign and Implementation, pages 15 26, 2005. [22] T. Lindholm and F. Yellin. The Java Virtual Machine \nSpeci.cation (2nd Edition). Prentice Hall PTR, 1999. [23] S. Lu, J. Tucek, F. Qin, and Y. Zhou. AVIO: \nDetecting Atomicity Violations via Access-Interleaving Invariants. In ACM International Conference on \nArchitectural Support for Programming Languages and Operating Systems, pages 37 48, 2006. [24] Mckoi \nSQL Database. http://www.mckoi.com/database/. [25] N. Nethercote and A. Mycroft. Redux: A Dynamic Data.ow \nTracer. Electronic Notes in Theoretical Computer Science, 89(2), 2003. [26] N. Nethercote and J. Seward. \nValgrind: A Framework for Heavyweight Dynamic Binary Instrumentation. In ACM Conference on Programming \nLanguage Design and Implementation, pages 89 100, 2007. [27] J. Newsome and D. Song. Dynamic Taint Analysis \nfor Automatic Detection, Analysis, and Signature Generation of Exploits on Commodity Software. In Network \nand Distributed System Security Symposium. [28] PMD. http://pmd.sourceforge.net. [29] F. Qin, J. Tucek, \nJ. Sundaresan, and Y. Zhou. Rx: Treating Bugs as Allergies A Safe Method to Survive Software Fail\u00adures. \nIn ACM Symposium on Operating System Principles, pages 235 248, 2005. [30] M. Rinard,C. Cadar,D.Dumitran, \nD.Roy,T.Leu, and J. Bee\u00adbee. Enhancing Server Availability and Security through Failure-Oblivious Computing. \nIn USENIX Symposium on Operating Systems Design and Implementation, pages 303 316, 2004. [31] J. Seward \nand N. Nethercote. Using Valgrind to Detect Unde.ned Value Errors with Bit-Precision. In USENIX Annual \nTechnical Conference, pages 17 30, 2005. [32] SourceForge.net. http://www.sourceforge.net/. [33] Standard \nPerformance Evaluation Corporation. SPECjvm98 Documentation, release 1.03 edition, 1999. [34] Standard \nPerformance Evaluation Corporation. SPECjbb2000 Documentation, release 1.01 edition, 2001. [35] B. Wiedermann. \nPersonal communication, November 2006. [36] X. Zhang, S. Tallam, N. Gupta, and R. Gupta. Towards Locating \nExecution Omission Errors. In ACM Conference on Programming Language Design and Implementation, pages \n415 424, 2007. [37] P. Zhou, W. Liu, L. Fei, S. Lu, F. Qin, Y. Zhou, S. Midkiff, and J. Torrellas. AccMon: \nAutomatically Detecting Memory\u00adrelated Bugs via Program Counter-based Invariants. In IEEE/ACM International \nSymposium on Microarchitecture, pages 269 280, 2004.  \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Programs sometimes crash due to unusable values, for example, when Java and C# programs dereference null pointers and when C and C++ programs use undefined values to affect program behavior. A stack trace produced on such a crash identifies the effect of the unusable value, not its cause, and is often not much help to the programmer.</p> <p>This paper presents efficient <i>origin tracking</i> of unusable values; it shows how to record where these values come into existence, correctly propagate them, and report them if they cause an error. The key idea is <i>value piggybacking</i>: when the original program stores an unusable value, value piggybacking instead stores origin information in the spare bits of the unusable value. Modest compiler support alters the program to propagate these modified values through operations such as assignments and comparisons. We evaluate two implementations: the first tracks null pointer origins in a JVM, and the second tracks undefined value origins in a memory-checking tool built with Valgrind. These implementations show that origin tracking via value piggybacking is fast and often useful, and in the Java case, has low enough overhead for use in a production environment.</p>", "authors": [{"name": "Michael D. Bond", "author_profile_id": "81100148693", "affiliation": "University of Texas at Austin, Austin, TX", "person_id": "PP39089298", "email_address": "", "orcid_id": ""}, {"name": "Nicholas Nethercote", "author_profile_id": "81331500269", "affiliation": "National ICT Australia, Melbourne, Australia", "person_id": "PP39107479", "email_address": "", "orcid_id": ""}, {"name": "Stephen W. Kent", "author_profile_id": "81339508923", "affiliation": "University of Texas at Austin, Austin, TX", "person_id": "P905214", "email_address": "", "orcid_id": ""}, {"name": "Samuel Z. Guyer", "author_profile_id": "81332502517", "affiliation": "Tufts University, Boston, MA", "person_id": "PP39072767", "email_address": "", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "University of Texas at Austin, Austin, TX", "person_id": "P157900", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297057", "year": "2007", "article_id": "1297057", "conference": "OOPSLA", "title": "Tracking bad apples: reporting the origin of null and undefined value errors", "url": "http://dl.acm.org/citation.cfm?id=1297057"}