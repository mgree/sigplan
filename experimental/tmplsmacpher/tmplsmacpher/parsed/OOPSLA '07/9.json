{"article_publication_date": "10-21-2007", "fulltext": "\n User-Changeable Visibility: Resolving Unanticipated Name Clashes in Traits St\u00b4 ephane Ducasse Language \nand Software Evolution LISTIC Universit\u00b4 e de Savoie &#38; INRIA Futurs stephane.ducasse.free.fr Roel \nWuyts IMEC (Leuven, Belgium) and Universit\u00b4e Libre de Bruxelles homepages.ulb.ac.be/~rowuyts Oscar Nierstrasz \nSoftware Composition Group, University of Bern www.iam.unibe.ch/~oscar Alexandre Bergel Hasso-Plattner-Institut, \nGermany &#38; LERO, Trinity College Dublin, Ireland www.bergel.eu Abstract A trait is a unit of behaviour \nthat can be composed with other traits and used by classes. Traits offer an alternative to mul\u00adtiple \ninheritance. Con.ict resolution of traits, while .exible, does not completely handle accidental method \nname con\u00ad.icts: if a trait with method m is composed with another trait de.ning a different method m \nthen resolving the con.ict may prove delicate or infeasible in cases where both versions of m are still \nneeded. In this paper we present freezeable traits, which provide an expressive composition mechanism \nto sup\u00adport unanticipated method composition con.icts. Our solu\u00adtion introduces private trait methods \nand lets the class com\u00adposer change method visibility at composition time (from public to private and \nvice versa). Moreover two class com\u00adposers may use different composition policies for the same trait, \nsomething which is not possible in mainstream lan\u00adguages. This approach respects the two main design \nprinci\u00adples of traits: the class composer is empowered and traits can be .attened away. We present an \nimplementation of freez\u00adable traits in Smalltalk. As a side-effect of this implementa\u00adtion we introduced \nprivate (early-bound and invisible) meth\u00adods to Smalltalk by distinguishing object-sends from self- Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October \n21 25, 2007, Montr\u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; 2007 ACM 978-1-59593-786-5/07/0010. . \n. $5.00 sends. Our implementation uses compile-time bytecode ma\u00adnipulation and, as such, introduces no \nrun-time penalties. Categories and Subject Descriptors D.3.3 [Programming Languages]: Languages Constructs \nand Features Classes and objects; Inheritance General Terms Languages Keywords Dynamic typing, traits, \nencapsulation, informa\u00adtion hiding, composition. 1. Introduction Traits are pure units of reuse consisting \nonly of methods [SDNB03, DNS+06]. Traits can be composed to form ei\u00adther other traits or classes. They \nare recognised for their potential in supporting better composition and reuse, hence their integration \nin the latest versions of languages such as Perl 6, Squeak [IKM+97], Scala [sca], Slate [Sla] and Fortress \n[for]. Although traits were originally designed for dynamically-typed languages, there has also been \nconsider\u00adable interest in applying traits to statically-typed languages [FR03, SD05, NDS06]. One of the \nkey design principles behind traits is that they empower the composer of traits. The composer has the \nfull control of the composition and the con.ict resolu\u00adtion [DNS+06]. The design principle behind traits \nwas to favor simplicity over completeness [Bra92] or expressive\u00adness [Mey97]. In our opinion it is important \nthat language features stay simple to avoid overwhelming existing devel\u00adopers, and to ease their introduction \nin existing languages when possible. This simplicity-by-design works well in most cases, but has two \ndrawbacks. First of all there is no notion of visibility in traits, which may increase the number of \ncon\u00ad.icting methods that have to be handled at composition time. This does not pose any conceptual problems, \nbut can become tedious in practice. But worse, a number of unanticipated method clash problems are sometimes \npoorly handled. This is shown in the contrived but compact example of Figure 1. Figure 1. Name clash \nwith traits: in Composer either T1 s x, T2 s x or a new method x is called by both foo and bar. Figure \n11 shows a class, Composer, that uses two traits T1 and T2, each of which introduce a method x. T1 and \nT2 are therefore said to be in con.ict since both de.ne a method x. One strong requirement is not to \nmodify T1 or T2 as they might be used by other classes or as part of other trait compositions. With the \noriginal trait con.ict resolution, the con.ict may be resolved by either removing one method x, from \nthe composition or by de.ning a method x in the Composer class, essentially overriding both x s. These \ntwo simple approaches to handle the con.ict turned out to be very practical (as shown by the refactorings \nof several large hierarchies [BSD03]2). However, there are some cases where the con.ict reso\u00adlution of \ntraits is not satisfactory: there is no way to let the methods foo and bar access the method x contained \nin their respective traits. Either T1 s x, T2 s x or a new method x has to be present in the class Composer. \nThat said, if the x meth\u00adods are speci.c helper methods in their respective trait (i.e., the behavior \nof foo depends on the behavior of T1 s x and the behavior of bar depends on the behavior of T2 s x), \nthen the composition and con.ict resolution will break foo, bar or both. This prevents traits from being \nused in an unanticipated manner in certain scenarios, and lowers their reusability. The composition problem \nwe just described with traits is actually more general and exists in other systems as well, together \nwith a number of solutions. Eiffel s key composi\u00adtion mechanism offers the ability to rename methods \nto re\u00adsolve method con.icts [Mey97]. Encapsulation policies of\u00adfer a way to constrain encapsulation interfaces \nfor different 1 Double arrowhead represents trait composition. . indicates a return value. (cf., Smalltalk \nsyntax) 2 Con.icts did not arise for the simple fact that the code being refactored came from a single \ninheritance hierarchy. users [SBD04]. This approach could be used to solve unan\u00adticipated method name \nclashes in traits (which actually was the original goal, even if not presented as such in the paper). \nWhile encapsulation policies can be used to deal with unan\u00adticipated method name con.icts they introduce \nan extra con\u00adcept in the language: the encapsulation policy. Integrating encapsulation policies in a \nhost language is dif.cult. This is why we looked for another solution and arrived at freezable traits, \npresented in this paper. Freezable traits is a composition mechanism that deals with unanticipated method-name \ncon.icts. It is based on the ability to have private methods (early bound and non-visible) within a trait, \nthat can change their visibility at composition time. Also, two composers of the same trait can have \ndiffer\u00adent composition concerns. This supports the key principle of traits: the composer has full control \nover the composition. The composer may decide to make a method private or pub\u00adlic to solve a con.ict \nin a speci.c composition. Our solution supports the .attening property of traits [DNS+06, NDS06] i.e., \nthat traits can be .attened away and do not change the run-time semantics of method lookup. A point of \nvocabulary. A composer is a class or a compos\u00adite trait composed from other traits. A client is a class \nthat sends messages to an instance of a class that may have been composed from traits (see Figure 2). \n Figure 2. A Composer (a class or a trait) composes behavior from existing traits and superclasses. A \nClient uses the result of the composition. In Section 2 we present the original traits design and identify \nits limitations for resolving method con.icts. In Section 3 we describe freezable traits, a minimal extension \nof the original traits model in which traits de.ne access rights for methods, and composers may rede.ne \nthose rights. In Section 4 we describe the operator semantics. In Sec\u00ad tion 5 we present the implementation \nof freezable traits in a dynamically-typed language. Our implementation is based on bytecode transformation, \nis purely static, and does not introduce any run-time costs. In Section 6 we discuss the tradeoffs of \nthe various mechanisms for resolving con.icts. In Section 8 we provide an overview of related work. In \nSec\u00ad tion 9 we conclude by summarising the presented work and outlining future work. 2. Traits and their \nlimitations This section presents traits in a nutshell [DNS+06]. A reader already familiar with traits \nmay skip this section and jump directly to Section 2.2, which describes the limitations of con.ict resolution. \nThese limitations are resolved through the introduction of freezable traits in Section 3. 2.1 Traits \nas units of behaviour Reusable groups of methods. Traits are sets of methods that serve as the behavioural \nbuilding block of classes and primitive units of code reuse [DNS+06]. In addition to of\u00adfering behaviour, \ntraits also require methods, i.e., methods that are needed so that trait behaviour is ful.lled. Traits \ndo not de.ne state, instead they require accessor methods. Figure 3. The class SyncStream is composed \nof the two traits TSyncReadWrite and TStream. Figure 3 shows a class SyncStream that uses two traits, \nTSyncReadWrite and TStream. The trait TSyn\u00adcReadWrite provides the methods syncRead, syncWrite and hash. \nIt requires the methods read and write, and the two accessor methods lock and lock:. We use an extension \nto UML to represent traits (the right col\u00adumn lists required methods while the left one lists the provided \nmethods). Explicit composition. A class contains a super-class ref\u00aderence, uses a set of traits, de.nes \nstate (variables) and be\u00adhaviour (methods) that glue the traits together; a class im\u00adplements the required \ntrait methods and resolves any method con.icts. Trait composition respects the following three rules: \nMethods de.ned in the composer take precedence over trait methods. This allows the methods de.ned in \na com\u00adposer to override methods with the same name provided by the used traits; we call these methods \nglue methods. Flattening property. In any class composer the traits can be in principle in-lined to \ngive an equivalent class de.ni\u00adtion that does not use traits.  Composition order is irrelevant. All \nthe traits have the same precedence, and hence con.icting trait methods must be explicitly disambiguated. \n Con.ict resolution. While composing traits, method con\u00ad.icts may arise. A con.ict arises if we combine \ntwo or more traits that provide identically named methods that do not originate from the same trait. \nThere are two strategies to resolve a con.ict: by implementing a (glue) method at the level of the class \nthat overrides the con.icting methods, or by excluding a method from all but one trait. Traits allow \nmethod aliasing; this makes it possible to introduce an addi\u00adtional name for a method provided by a trait. \nThe new name is used to obtain access to a method that would otherwise be unreachable because it has \nbeen overridden [DNS+06]. In Figure 3, the class SyncStream is composed from TSyncReadWrite and TStream. \nThe trait composition associated to SyncStream is: TSyncReadWrite alias hashFromSync . hash + TStream \nalias hashFromStream . hash The class SyncStream is composed of (i) the trait TSyncReadWrite for which \nthe method hash is aliased to hashFromSync and (ii) the trait TStream for which the method hash is aliased \nto hashFromStream. Method composition operators. The semantics of trait composition is based on four \noperators: sum (+), override (.), exclusion (-) and aliasing (alias .) [DNS+06]. The sum trait TSyncReadWrite \n+ TStream contains all of the non-con.icting methods of TSyncReadWrite and TStream. If there is a method \ncon.ict, that is, if TSyn\u00adcReadWrite and TStream both de.ne a method with the same name, then in TSyncReadWrite \n+ TStream that name is bound to a known method con.ict. The + operator is as\u00adsociative and commutative. \nThe override operator (.) constructs a new composition trait by extending an existing trait composition \nwith some explicit local de.nitions. For instance, SyncStream over\u00adrides the method hash obtained from \nits trait composition. A trait can exclude methods from an existing trait using the exclusion operator \n-. Thus, for instance, TStream - {read, write} has a single method hash. Exclusion is used to avoid con.icts, \nor if one needs to reuse a trait that is too big for one s application. The method aliasing operator \nalias . creates a new trait by providing an additional name for an existing method. For example, if TStream \nis a trait that de.nes read, write and hash, then TStream alias hashFromStream . hash is a trait that \nde.nes read, write, hash and hashFromStream. The additional method hashFromStream has the same body as \nthe method hash. Aliases are used to make con.icting methods available under another name, perhaps to \nmeet the requirements of some other trait, or to avoid overriding. Note that since the body of the aliased \nmethod is not changed in any way, an alias to a recursive method is not recursive. Figure 4. Trait con.ict \nresolution strategies: either via method rede.nition or via method exclusion. In the following section \nwe use the compact example shown in Figure 4. Trait Design Principles. Three principles guided the de\u00adsign \nof traits: .rst, traits should represent a minimal pertur\u00adbation to a classic class-based language. Second, \ncon.icts are detected automatically and there is no implicit con.ict resolution. When con.icts are detected \nthe composer is re\u00adsponsible for resolving them explicitly using the available composition operators. \nThird, traits can be .attened away (they do not impose a runtime semantics and can therefore be compiled \naway). Figure 5. Name clash with traits  2.2 Trait con.ict resolution limits While trait composition \nlets the class composer resolve con\u00ad.icts by rede.ning methods in the composer or excluding them from \nthe composed traits, there are con.icts that are not well handled by traits. Figure 5 illustrates the \nproblem. The class SyncStream is composed of two traits TSyncRead-Write and TStream. Since both traits \nde.ne the method write, a con.ict arises when composing TSyncReadWrite with TStream: the two write methods \nare different, neither being compatible or composable. They are both used in different non-composable \ncontexts. The default trait con.ict resolu\u00adtion is of no help since excluding the method write does not \nwork each respective trait needs to invoke its speci.c write method. Rede.ning the method write in the \nclass does not work either because the behaviours of the two methods are not composable. Even wrapping \none of the traits in an\u00adother trait or class does not solve the problem, as traits can be .attened away \nat composition time without any means to rename a method. The only solution for the developer may be \nto rewrite one of the traits which is clearly against the trait goal to support reusable composable abstractions. \n3. Freezable traits: adjusting method visibility at composition-time As was discussed in detail in previous \nsection, composing traits may result in con.icts, and for some compositions the desired solution cannot \nbe expressed without rewriting some of the con.icting methods. 3.1 Adjusting visibility This paper solves \nthe composition problems of the origi\u00adnal traits by introducing slight changes to the original traits \nmodel. First we consider now that the host language sup\u00adports two access modi.ers (private and public). \nThen two new composition operators let a composer change method accessibility at composition time. With \nfreezable traits, a trait developer gives each method a default access modi.er of either private (-) \nor public (+), similar to the access modi.ers in Java or C++ for example: a private method is only accessible \nfrom within the de.n\u00ading trait. It is therefore bound early to the de.ning trait and not visible to the \nclient or the composer. Other meth\u00adods within the trait referring to the private method will always refer \nto it, even when they are composed with an\u00adother class or trait.  a public method is dynamically bound \nand visible to the client and the composer, behaving as in the original traits model. The method may \nbe overridden in the composer, and sends from methods in the trait to a public method will then result \nin the execution of the overridden method in the composer.  Unlike most existing languages, the default \naccess mod\u00adi.ers can be changed by the composer at composition time with the help of two new operators: \nfreeze (making a public method private) and defrost (making a private method pub\u00adlic). Figure 6. Freeze \nand defrost semantics illustrated. Access-modi.ers are a well-known mainstream lan\u00adguage feature. They \nare typically seen as simple and well\u00adunderstood mechanisms, but their exact semantics differ between \nlanguages. For example Section 8 shows the se\u00ad mantics of private in Ruby, where private methods can \nbe overridden in subclasses, while for example, in Java pri\u00advate methods are not inherited and may not \nbe overrid\u00adden [GJSB05] (p. 144, section 6.6.8). With freezable traits the semantics of public and private \ncombine notions of visi\u00adbilty and early/late binding, as explained in detail in the fol\u00adlowing sections. \nTheir implementation is simple as shown in Section 5. Note that the client only has access to the public \nmethods resulting from the composition process. Freezable traits fol\u00adlow the original traits philosophy \nof having few composition operators and putting the composer in charge of the con.ict resolution. Figure \n6 shows four often-occurring scenarios when ap\u00ad plying traits in the freezable traits model. In (a), \nthe two public methods x con.ict. To avoid this situation, the composer decides to freeze T1 x. Therefore \nthe x invocation in T1 foo is early bound to T1 x. As a con\u00adsequence, the method foo always invokes T1 \nx, regardless of whether the Composer class is subclassed or not (i.e., the dynamic type of self differs \nfrom Composer). In addition T1 s x is not visible in the composer, therefore invoking x returns the value \nT2 according to the de.ni-Figure 7. Con.ict resolution with the freeze operator. tion of T2. Since T2 \ns x is dynamically bound, bar invokes it. In (b) the two public methods x con.ict, and the com\u00adposer \ndecides to freeze them both. Therefore the invoca\u00adtion of x in T1 foo is bound to T1 x and the one in \nT2 bar to T2 x. With none of the methods x being visible for the client, it cannot send a message x to \nan instance of Composer.  In (c) the two methods x are private. The composer de\u00adcides to defrost the \ntwo methods x. This generates a com\u00adposition con.ict that is then handled by de.ning a new method x in \nthe class Composer. Invoking x in T1 foo and in T2 bar results in the execution of this new method x, \nsince x is dynamically bound.  In (d) the method T1 x is private while the method T2 x is public. The \ncomposer decides to freeze T2 x and defrost T1 x. Therefore, we end up with the opposite situation from \n(a).  Using freezable traits, the situation we described in Fig\u00adure 5 can be easily solved, since the \ncomposer can exclude, rede.ne or freeze the con.icting method. Figure 7 illustrates the solution where \none of the con.icting methods is frozen. The fact that the composer decides the .nal visibility of methods \nat composition time implies that a same trait can have different visibilities for its methods in different \ncompo\u00adsitions. For example, Figure 8 illustrates how the trait TSyn\u00adcReadWrite can be used by two classes, \nSyncStream and Se\u00adquenceableStream. The former class uses TSyncReadWrite freeze write, whereas the latter \nsimply uses it. From the point of view of SyncStream, the method write is frozen. TSyn\u00adcReadWrite only \nde.nes one method, syncWrite. From the point of view of SequenceableStream, TSyncReadWrite de\u00ad.nes two \nmethods, write and syncWrite, each being publicly accessible from this class. Figure 8. Different visibility \npolicies can be applied to the same trait.  3.2 Freezing in the presence of subtraits This section extends \nthe notion of freezing to traits that are themselves composed from other traits (subtraits) and thus \ncreate trait composition hierarchies. A natural question that arises then is what happens when we start \nfreezing and defrosting when composing such hierarchies. Since the response to this question is not as \nsimple as one might think, this section focusses just on freezing. The next section tackles defrosting. \n Figure 9. Freezing a trait composed from subtraits. The previous section explains the basic mechanism \nof freezing, i.e., making a public method private and therefore making all local calls to this method \nstatic. When a trait is itself composed from other traits (its subtraits), and these traits again have \nsubtraits, we have to think about exactly what methods need to be frozen. We present the possible alternatives \nfor the freezing semantics and then discuss our choice. Figure 9(a) pictures a trait composition where \nwe want to freeze a method x. The result of freezing x could be: 1. All public methods x are frozen, \nall the way up the trait composition chain. In the given example this would mean that the methods x provided \nfrom T4 as well as T1 are made private, and that therefore blop would call x in T4 and foo would call \nx in T1. There would be no changes for T3. 2. The public method in the .attened trait that needs to be \nfrozen is made private, and the callers of this newly private method become static calls. Note that \nin the .attened version of a trait, there is at most one method with the given name to be frozen. In \nthe example given, the .attened trait T0, shown in Fig\u00adure 9(b), only has one public method x, namely \nthe one provided by T1, which overrides the method x from T4. This method is made private, and the dynamic \ncalls to it in methods blop and foo become static. 3. We could simply disallow freezing a method which \nis provided by a subtrait and not provided by the composed trait itself. In the example this would mean \nthat there is a composition error since x is not provided by T0 but is provided by T1, a subtrait of \nT0. 4. We could decide to add explicit references to indicate the exact method to be frozen. So instead \nof saying Com\u00adposer uses {T0 freeze x} + {T2} we should write Com\u00adposer uses {T0 freeze T1.x} + {T2} \nto freeze the public method x in T1.  We decided in favour of the second option, and say that freezing \na method x in a trait T means making at most the public method x of the .attened trait T private. This \noption respects the principle of least astonishment. The result of freezing a trait hierarchy and using \nit in a composition is that you decide to use it as-is, with all calls going to the methods as though \nthe trait were not composed. Option 1 completely changes the composition since suddenly calls that would \nresult in the invocation of one method suddenly are bound to another one after the freezing. In our example \nthis would mean that both the x provided by T1 as the one provided by T4 would be frozen, and therefore \nblop would call its private method x and return T4 when invoked, instead of T1 before the freezing. Note \nthat using the .attened trait T implies that only non\u00adcon.icting methods may not be frozen. For example, \nif in Figure 6(a) there would be no freeze clause T1 freeze x, then another trait using Composer could \nnot freeze x. The second option also respects encapsulation: saying that method x is frozen in trait \nT freezes method x in T regardless of where it comes from. Option 3 is unattractive, since the composer \nshould not care whether a used trait is composite or not. Option 4 introduces unwanted fragility, since \naspects of the composition hierarchy are hardcoded into the freezing expressions. With the chosen semantics, \nFigure 10 shows that calls to x would result in the same method execution in T0 before and after the \ncomposition. The left part shows the composition of Figure 10. Freezing a trait composed from subtraits \nresults in the .attened trait being used when freezing.  trait T0 by itself. Let s suppose for a moment \nthat we could instantiate a trait and send messages to it, which allows us to investigate the method \nlookup results. We observe that calls in foo and bar are late bound, and would result in the execution \nof method x of T1. Method bar is statically bound to the private method x in T3. When trait T0 isusedin \na composition, as shown in the right part of Figure 10, and x is frozen in T0, the results of sending \nmessages foo, bar and zork are exactly the same as for trait T0 by itself. This is why we dubbed the \noperation freeze in the .rst place: the existing behaviour before composing is frozen and used as such \nin the composition. 3.3 Defrosting in the presence of subtraits The defrost operator makes a a previously \nfrozen method public. This section is dedicated to how this operator be\u00adhaves with a potentially deep \nhierarchy of composing traits. Defrost targets private methods, i.e., methods that are not part of the \npublic interface of a trait. One key semantic point arises when several private methods x issued from \na trait composition belong to the same composite trait. Defrosting x in such a situation deserves special \nattention, as discussed in this section. Figure 11 illustrates a situation where several private x methods \nare present. Each of T3, T4 and T5 has a private x present also in T0 as illustrated in the .attened \nrepresentation of T0. Note that these methods are present but not reachable from composers. As in the \nprevious section, we consider several possible semantics for defrost: 1. All private methods x are defrosted, \nall the way up the trait composition chain. In the hierarchy presented in Figure 11, T0 defrost x results \nin three public x methods, obtained respectively from T3, T4 and T5. These three methods con.ict is solved \nin Composer. 2. All private methods x all the way up the trait composition chain that are not overridden \nare defrosted. Informally this means that the lowest occurrences in the composi\u00adtion chain of x are made \npublic. If Figure 11 would not contain T3, then T0 defrost x would make T4.x public but not T5.x. In \nthe situation depicted by Figure 11, T0 de\u00adfrost x will defrost the two private methods T3.x and T4.x \nand reveal two public methods x obtained from T3 and T4, thereby producing a method con.ict. T5.x remains \nprivate. 3. Only private methods from immediate subtraits can be defrosted by the composer. Since T0 \ndoes not freeze any x, it is an error to attempt to defrost x in T0. 4. We could decide to add explicit \nreferences to indicate which methods to defrost. In that case, in order to defrost T3 s x method we would \nhave to write T0 defrost T3.x.  We decided in favour of the second option because it makes defrost \ndual to its counterpart, freeze. This means that freezing and then defrosting the same method x in a \ntrait T is equivalent to T. In that case, we have the following relation: T freeze x defrost x = T. It \nis then possible to deduce T defrost x freeze x = T. Option 1 does not offer this duality. Whereas T0 \ndefrost x freeze x = T0 since all x in T0 are private, (T0 + T2) defrost x freeze x would not be equal \nto (T0 + T2) since T2 s x would be private. This would also break encapsulation. Option 3 would not allow \nus to formulate the expression T freeze x defrost x since T freeze x is a new trait that does not directly \nde.ne x (even privately). Option 4 uses harcoded pre.xes that break encapsulation and would thereby make \ntrait composition fragile with re\u00adgard to changes in subtrait composition. It is worth noting that defrosting \na method may lead to a con.ict as it happens in T0 defrost x. However this situation is easily solved \nas illustrated in Figure 11. Defrosting x in T0 turns T3 and T4 x public, which results in a con.ict. \nThis con.ict is solved in Composer by de.ning a new x. Note that this new version of x is the one invoked \nby zork. One characteristic of our design decision is that not every private method is defrosted, only \nthose that are reachable (e.g. that are not overridden). On the .gure, the method x issued from T5 may \nnot be defrosted. 4. Operator semantics To specify the semantics of the new operators we de.ne FREEZABLETRAITS, \nan extension of SMALLTALKLITE. SMALLTALKLITE is a dynamic language calculus featur\u00ading single inheritance, \nmessage-passing, .eld access and updates, and self / super sends. SMALLTALKLITE has al\u00adready been presented \nin a previous paper [BDNW07] and is heavily inspired by CLASSICJAVA de.ned by Flatt et al. [FKF98]. We \nrepeated the full description of SMALL-TALKLITE in the appendix to aid the reader, but we do not consider \nit to be a contribution of this paper. We did not use FEATHERWEIGHTJAVA, as in our previous work [NDS06], \nsince FEATHERWEIGHTJAVA is purely functional and does not support super. Moreover, we would like to have \na com\u00admon calculus to express both stateful traits [BDNW07] and freezable traits. The syntax of FREEZABLETRAITS \nis presented in Fig\u00adure 13. Note that we do not provide syntax for declaring methods public or private, \nsince (i) this is not needed to de\u00ad.ne the semantics of the operators, and (ii) this can be sim\u00adulated \npost hoc by de.ning a new trait in which methods to be made private are frozen. The example described \nin Figure 5 that presents the stream synchronization problem is written with FREEZ-ABLETRAITS as follows: \ntrait TSyncReadWrite {write () { implementation 1 ... } syncWrite () { self.lock.acquire() let value \n= self.write() in { self.lock.release() value }}} trait TStream { write () { implementation2 ... } asFile \n(.leName) { let .le = new File () in { .le.setName (.leName) .le.content (self.write()) .le.close() } \n}}} 4.1 Flattening property A key feature of traits is that they can be .attened [DNS+06]. This means \nthat adding traits to a language does not require a change to the method lookup semantics. As a direct \nconse\u00adquence, traits can be compiled away. We demonstrate the .attening property for traits with the \nfreeze and defrost operators by de.ning a .attening function from FREEZABLETRAITS to SMALLTALKLITE. We \ndistinguish a named trait t from a trait expression t which may alias, exclude, freeze or defrost methods. \nA trait t declares a number of methods, but no .elds. A trait or a class may use any number of traits, \npossibly modifying them in a trait expression. A trait expression t may (i) de.ne an alias m' for an \nexisting method m, (ii) exclude a method m, (iii) freeze a method (i.e., hide a method and statically \nbind it), (iv) make a (previously frozen) method publicly visible. Figure 14 presents the .attening function. \nThe .attening is expressed by translating an expression de.ning a class that references traits to a plain \nclass and method de.nitions. The translation expands trait expressions to method declarations and is \nvalid if the resulting classes contain no con.icts. The translation is speci.ed in terms of .ve trait \noperators (Fig\u00adure 15). Trait composition (+) may generate con.icts if two methods with the same name \noccur in the composed traits. Class methods take precedence ( ) over any used trait meth\u00adods. Aliasing \nmay generate a con.ict if a method has already been de.ned under the name of the alias. If the method \nbe\u00ading aliased does not exist, there is no effect. Exclusion sim\u00adply removes the named trait. Freezing \na method removes this method from the interface of a trait, and statically binds sends to it so that \nmay it occur in other methods. Defrosting a method makes it publicly visible and causes sends to it to \nbe dynamically bound. To be able to fully describe the semantics of the operators we chose to represent \nhow the method visibility changes in the context of our implementation, i.e., a dynamically\u00adtyped object-oriented \nlanguage. Therefore, we represent the special treatment we perform on self-sends (see Section 5). The \nmechanism to decide whether a message send would P = defn* et = a trait name ' defn = class c extends \nc { f*meth* t* } meth = m(x *) { e }| trait t { meth* t* } c = a class name | Object ' t = t | t alias \nm . m | t minus mf = a .eld name | t freeze m | t defrost mm = a method name e = new c | x | self | nil \nx = a variable name | f | f=e | e.m(e *) | super.m(e *) | let x=e in e Figure 13. FREEZABLETRAITS syntax. \n[ def1 \u00b7\u00b7\u00b7 defn] = [ def1]] \u00b7\u00b7\u00b7 [ defn] [ trait t { meth* t * }] = \u00d8 '' [ class c extends c { f*meth* \nt * }] = class c extends c { f*meth* [ t *] }[ t1 \u00b7\u00b7\u00b7 tk] = [ t1] + \u00b7\u00b7\u00b7 +[ tk] { meth* if trait t { \nmeth* }. P [ t] = meth* [ t +] if trait t { meth* t + }. P '' [ t alias m . m] = [ t]][m . m] [ t minus \nm] = [ t] - m ' [ t freeze m] = [ t]][m ' /m]self alias m . m minus m ' where m = .[t freeze m](m) \n'' [ t defrost m] = [ t]][m/m ' i]self alias m . mi minus mi ' where M = .[t'](m) and m . M i Figure \n14. Flattening FREEZABLETRAITS to SMALLTALKLITE. ** M1 + M2 = \u00b7\u00b7\u00b7 mi(x ){T} \u00b7 \u00b7 \u00b7 mj(x ){ej }\u00b7\u00b7\u00b7 , ij \n.mi(\u00b7\u00b7\u00b7 ){\u00b7 \u00b7 \u00b7 } occurring in both M1 and M2 * .mj (x ){ej} occurring uniquely in one of M1 or M2, \nj ** M1 M2 = \u00b7\u00b7\u00b7 mi(x ){ei}\u00b7\u00b7\u00b7 mj(x ){ej}\u00b7\u00b7\u00b7 , ij * .mi(x ){ei} occurring in M1, i * .mj (x ){ej} \noccurring only in M2 { j M +[m '(x*){e}] if m(x*){e}. M ' M[m . m]= M otherwise { \u00b7\u00b7\u00b7 Mj-1 Mj+1 \u00b7\u00b7\u00b7 \nif Mj = m(\u00b7\u00b7\u00b7 ){\u00b7 \u00b7 \u00b7 } M - m = M otherwise * M[m ' /m]self = \u00b7\u00b7\u00b7 mi(xi ){ei[m ' /m]self}\u00b7\u00b7\u00b7 , * .mi(x \n){ei} occurring in M i Figure 15. Trait operations ' cause (or not) a frozen method to be invoked, \nwould have Conversely, defrost m renames all the m self-sends to ' to be adapted for a statically-typed \nlanguage. The operator m, where m is the hidden name for m. It creates a new ' semantics should be the \nsame in terms of the results in the alias m for m ', and excludes m from the trait. This needs composer \nand the client visibility. to be done throughout the composition hierarchy, for all m s The expression \nfreeze m renames all the self-sends to m that are not overridden. Defrosting a method m may reveal ' \n to m ', where m is a new name obtained from the .[] hiding several hidden methods m anchored in the \ncomposition. function. The scope of this hiding is per trait. Moreover, .[] is Flattening occurs at composition \ntime (i.e., during the bijective. Detailed information on .[] is given in Section 4.3. compilation). \nBefore being executed, a program needs to be .attened (i.e., traits compiled away). To solve the method \ncon.ict, the class SyncStream can be written as follows: new c [m ' /m]self = new c x [m ' /m]self = \nx self.m(e * i ) [m ' /m]self = self.m '(e * i [m ' /m]self) self.n(e * i ) [m ' /m]self = self.n(e * \ni [m ' /m]self), if n .= m nil [m ' /m]self = nil f=e [m ' /m]self = f=e[m ' /m]self e.m(e * i ) [m ' \n/m]self = e[m ' /m]self.m(e * i [m ' /m]self) super.m(e * i ) [m ' /m]self = super.m(e * i [m ' /m]self) \nsuper.n(e * i ) [m ' /m]self = super.n(e * i [m ' /m]self), if n .= m let x = e in e ' [m ' /m]self = \nlet x = e[m ' /m]self in e '[m ' /m]self T [m ' /m]self = T Figure 16. Self-send substitution  class \nSyncStream extends Object {TSyncReadWrite freeze write + TStream freeze write ... } A .attened version \nof the SyncStream class is: class SyncStream extends Object {writeTSyncReadWrite () { implementation \n1 }syncWrite () { self.lock.acquire() let value = self.writeTSyncReadWrite() in {self.lock.release() \nvalue } } writeTStream () { implementation 2 } asFile (.leName) { let .le = new File () in { .le.setName \n(.leName) .le.content (self.writeTStream()) .le.close() } }}} The two methods write have been renamed \nto writeTSyn\u00adcReadWrite and writeTStream, respectively (cf Section 4.3).  4.2 Self sends When a method \nhas to be (un)frozen, sends that may occur within the same trait have to be renamed. This is achieved \nwith the [m ' /m]self m operator, presented in Figure 16. It ' replaces the self.m(\u00b7\u00b7\u00b7 ) pattern in self.m \n'(\u00b7\u00b7\u00b7 ) where m is a newly generated method name. Since the scope of a freeze is the trait to which it \nis applied, super-sends are not renamed. When the expression TSyncReadWrite freeze write is .at\u00adtened, \nthe call to write() contained in the syncWrite method is translated into self.writeTSyncReadWrite(). \nSimilarly, for the TStream trait, the call of write() in asFile (.leName) is renamed in self.writeTStream(). \n 4.3 The hiding function Hiding a method could be achieved by either de.ning a .x\u00adpoint [BL91, Section \n4.7] or by simply generating a new name for this method and renaming its invocations. Since the defrost \noperation consists of making this method publicly visible, it requires the original method name, so the \nhiding function, .[], must be bijective. .[] is an arbitrary bijective function, parameterized by trait \nexpressions, that maps method names to be frozen to fresh names. It may make use of any information in \nthe trait expression to achieve the mapping. Figure 17 describes the hiding function for freezable traits. \nIt recurses over the trait composition. Freezing a ' method m associates a new name m to it, and defrosting \nit simply remove this association. We write a hiding function '' as a set of bindings, {m . m ,n . n \n,...}. We assume the following operations over such functions: ' {m . m ' } + {n . n ' } = {m . m ,n \n. n ' }{m . m ' } + {m . m '' } = {m . m ' ,m . m '' } ' {m . m ,n . n ' }\\m = {n . n ' }{m . m ' }\\n \n= {m . m ' } ' '' {m . m ,m . m ,n . n ' }\\m = {n . n ' } ' '' {p . p ,m . m ' }{m . m ,n . n ' } = '' \n{p . p ,m . m ,n . n ' } ' Application looks up a binding, {m . m ' }(m)= m . The result of a lookup \nmay be a set of names if a name is bound more than once, {m . m ' ,m . m '' }(m)= {m ' ,m '' }. Such \nsituation may arise when a name is de\u00adfrosted. Freezing a method results in renaming it with a fresh \nname. Creation of this name occurs in the .[t freeze m] ' clause. We assume that a new name m is obtained \nfrom m parametrised with t. This implies that the fresh name is recoverable in precisely the same context \nwhere it has been originally generated. If we use t freeze m twice in different .[trait t { meth* }] \n= \u00d8 .[trait t { meth*t1\u00b7\u00b7\u00b7tk }] = .[t1] + \u00b7\u00b7\u00b7 + .[tk] .[t] = .[trait t { meth*t* }] where trait t { meth* \nt* }. P .[t alias m '.m] = .[t] .[t minus m '.m] = .[t] .[t freeze m] = {m . m ' } .[t] ' where m is \na fresh new name .[t defrost m] = .[t]\\m Figure 17. The .[] hiding function. .[T SyncReadW rite] = \u00d8 \n.[TStream] = \u00d8 .[T SyncReadW rite freeze write] = {write . writeT SyncReadW rite}.[T Stream freeze write] \n= {write . writeT Stream}.[T SyncReadW rite freeze write + T Stream freeze write] = {write . writeT SyncReadW \nrite, write . writeT Stream}.[T SyncReadW rite freeze write defrost write] = \u00d8 .[T Stream freeze write \ndefrost write] = \u00d8 Figure 18. Hiding function for the stream example. contexts, then m is mapped to two \ndifferent names. When we defrost m, the correct mapped name is recovered. By construction, we have: .[t \nfreeze m defrost m] = .[t freeze m]\\m =({m . m ' } .[t])\\m = .[t] Generating a new method name could \nconsist in append\u00ading the name of a trait to a method name. Figure 18 gives some de.nitions based on \nthe stream example. Something important to keep in mind is the fact that the expression .[\u00b7\u00b7\u00b7 ] is a \nfunction. For instance, we have .[TStream freeze write](write)= writeTStream The . function returns the \nlist of bindings related to non overridden hidden methods. A hidden method that has been overridden is \nnot captured by ., and cannot be defrosted therefore. According to the example given in Figure 12, we \nhave: .[T 0] = {x . xT 3,x . xT 4} According to the semantics of ., the binding x . xT 5 is not part \nof .[T 0]: .[T 5] = {x . xT 5} but .[T 4] = {x . xT 4}. 5. Implementing freezable traits in a dynamically-typed \nlanguage We implemented freezable traits in Smalltalk, a dynamically\u00adtyped language, since the original \ntraits are fully imple\u00admented in Squeak Smalltalk [IKM+97]. As is the case with most dynamic languages, \nSmalltalk does not provide access modi.ers, so our implementation has to add them. Therefore a problem \nthat had to be solved in our implementation was how to introduce statically-bound messages without relying \non static types [Wol92, SBD04]. Our solution is based on syntactically distinguishing self\u00adsends from \nobject-sends [TH05,SBD04] (see below). Before presenting our approach we want to stress the dif.culties \nthat arise when static types are not available to decide which methods to invoke. The challenge of introducing \nmethod hiding. Following the analysis developed in [SBD04], there exist three possi\u00adbilities to distinguish \nwhich method to execute in absence of static type annotations. We can use: the dynamic type (i.e., the \nclass) of the receiver,  the identity of the receiver, or  the different kinds of message sends  We \nchose the third one, and therefore distinguish, self, super and object-sends. Object-sends are always \nlate-bound and self-sends may be either early or late-bound [TH05]. Hiding methods in dynamically-typed \nlanguages. Our ap\u00adproach distinguishes between self-sends and object-sends. A self-send is a message \nsend to the pseudo-variable self (this in Java). An object-send is a message that is not sent to self \nor super. With this syntactical distinction we have three different message sends: Self-sends may have \na visibility. They may be early bound and not visible to a client or late bound and visible.  Object-sends \n(i.e., invocations that syntactically do not use the keyword self or this) are always late-bound and \npublic.  Super-sends are static anyway and we do not change their status. The lookup starts in the superclass \nof the class containing the super expression.  Since our solution is based only on a syntactic distinc\u00adtion, \nfreezable traits could also be applied to other dynamic languages (e.g., Python and Ruby). Note that \nRuby [TH05] also distinguishes calls to private methods syntactically (see Section 8). Syntactically \ndistin\u00ad guishing private calls establishes the following properties (see [SBD04] for a deeper analysis): \n simple for developers to understand. It is more stable over code changes and modi.cation.  more stable \nwhen confronted with its re.ective be\u00adhaviour.  easier to implement, since it is based on syntactical \ndif\u00adference. Hence it can be implemented ef.ciently at trait composition time. As such it does not break \nthe .attening property since it does not introduce any run-time penal\u00adties.  Implementation. To implement \nfreezable traits we used ByteSurgeon, a bytecode manipulation framework [DDT06]. Using it at composition \ntime, we do not have to recompile methods but just transform method bytecode to change se\u00adlected self-sends \nto re.ect their visibility status. We then install the resulting method in the class method dictionary \nof the composer as shown by Figure 19 and 20. In Figure 19, the class C considers the x methods to be \nprivate helpers of their respective traits T1 and T2, therefore it declares them to be frozen. The implementation \nthen: 1. changes all the self-sends to x in the traits to be sent to uniquely identi.ed methods (e.g.,T2x \nin T2 and T1x in T1), 2. copy and install in C the transformed methods containing self-sends that have \nchanged, and 3. add entries to the method dictionary of C using the new names and pointing to the trait \nmethods.  In C the method foo is transformed: its self-send to x now refers to the x method of T1, \nnamed T1x which is also installed in the class C and shares the implementation of x. The same happens \nwith bar. With such a mechanism, several composer classes may use the same traits using different visibility \nconstraints with\u00adout problem. In Figure 20 the class C makes the frozen method x of T1 public while \nat the same time making the method x of T2 private. Here the method x is frozen, and is not present in \nthe method dictionary of T1 under this name, but is available as a hidden method T1x to the method foo \nwhich is calling x via a self-send. Imagine that in T1 we also have the method zork: arg de.ned as follows: \nzork: arg arg x In this method, arg x is a normal send (since it is not a self-send). In the context \nof Figure 20, the expression C new zork: C new will return T1 , since there is one method x visible and \nthe message arg x is late-bound. On the other hand, if x is frozen or has become frozen as in Figure \n19 then the same expression will raise an error since there is no visible x method in C. 6. Renaming \nvs. hiding There are three con.ict resolution mechanisms in the freez\u00adable traits model: methods in \nthe composer override methods provided from traits,  methods can be excluded, and  methods can be frozen. \n Each of these mechanisms solves the con.ict by hiding one or more methods. It is as though the methods \nwere not there in the .rst place, and they are therefore not propagated in the composition. The composing \nentity has no knowledge of frozen or excluded methods and, even more importantly, neither do its clients \nor other composing entities. Con.ict resolution mechanisms based on hiding can be contrasted to those \nbased on renaming, even though at .rst glance they look similar. When one or more con.icting methods \nare renamed, con.icts are resolved as well. The key difference between renaming and hiding lies in the \nfact that renamed methods are part of the composing entity, and clients of other composing entities have \naccess to them, whereas hidden methods are no longer visible. In a system that makes heavy use of trait \ncomposition, the presence of con.icting names can impede the effective reuse of traits. Renamed methods \nwill be carried along in the composition, whether they are wanted or not. Exclusion may not be an option \nif these methods are still needed. With hiding this cannot happen. Methods are never along for the ride \nunless the composer explicitly wants them to be. 7. Method con.icts revisited The stateless traits model \nstates that a con.ict arises if two or more traits are combined that provide identically named methods \nthat do not originate from the same trait [SDNB03, DNS+06]. For freezable traits we note that this formulation \nis not correct. To illustrate the problem, Figure 21 shows a trait compo\u00ad sition. Composer is composed \nfrom two subtraits, T0 and T1 that both are composing trait T. Note that x is being frozen in T0 and \nT1, and unfrozen by Composer. With the de.nition of con.icting methods given above we are in trouble. \nThere are no con.icts between the two methods x, since they are both frozen. There is also no problem \nfor Composer from the two provided methods foo (one through T0 and one through T1) since they originate \nfrom the same trait T and are therefore not in con.ict. But with freezable traits this poses problems, \nsince the same method foo has a static binding to x (due to the freezing of x when composing T0) but \nshould at the same time have a dynamic binding to x (due to the unfreezing of x when composing Composer). \nClearly this should not be allowed. In the discussion section of the seminal traits paper [SDNB03] (page \n15) a differently formulated de.nition if con.ict is given: there should be no con.ict if the same method \nis obtained more than once via different paths. This formulation is correct for the freezable traits \nmodel. In the example given it would mean that method foo obtained through T0 is different from the one \nobtained through T1, because the .rst has a static binding to x while the second one is dynamically bound. \nThis con.ict can be solved by the Composer in different ways, for example by excluding foo from either \nT0 or T1, and thereby choosing between the static or dynamically bound x. 8. Related work Quali.er in \nJava. The Java programming language [GJSB00] provides mechanisms for access control, to prevent the users \nof a package or class from depending on unnecessary details of the implementation of that package or \nclass. Each mem\u00adber (class, interface, .eld, or method) may have one of those four quali.ed access: \nif the member or construction is declared public, then access is permitted.  if declared protected, \nthen access is permitted only if the access to the member or constructor occurs from  (i) within the \npackage containing the class in which the protected member or constructor is declared, or from (ii) within \nthe body of a subclass. if declared private, then access is permitted only within the body of the class \nthat encloses the declaration of the member. otherwise, it uses a default access, which is permitted \nonly when the access occurs from within the package in which the type is declared. At .rst sight, the \npublic and private quali.ers seem simi\u00adlar to defrost and freeze in freezable traits. However freeze \nand defrost decouple the de.nition of methods from the speci.cation of their visibility. The Java private \nmethod quali.er early binds a method call: the corresponding private method of the message is directly \nobtained from the class in which the message is sent and is statically determined. The public method \nquali.er makes a method accessible to every object. The Java type checker is restrictive, and does not \nallow for a method to augment its visibility. For instance, a private or protected method m() in a class \nA cannot be made public when overridden in a subclass B. The main reason for not al\u00adlowing a private \nmember to become public is security. In this regard, freezable traits adopt a permissive approach, where \nfrozen methods can be made public by being defrosted. C++. As seen and illustrated in Figure 8, each \ncomposer may have a particular view on the traits it uses. For a given method, its visibility is not \nstated within the trait in which it is de.ned, but on the composer side. When a composer (i.e., a class \nor a trait) de.nes a trait composition, it also speci.es the visibility for each method carried by the \ntrait composition. Letting the composer de.ne its own visibility for the com\u00adposition methods is one \nof the major differences between freezable traits and most mainstream composition and visi\u00adbility mechanisms. \nMore speci.cally, it is typically not pos\u00adsible that subclasses can inherit a private method, by chang\u00ading \nthe access modi.er to public. Consider the following ex\u00adample program in C++ (the same, minus a number \nof syn\u00adtactical differences, holds for Java): class C1 {private: virtual void foo() {}; }; class C2: \nC1 {protected: virtual void foo() {// C1::foo(); // does not compile when uncommented }; }; While it \nlooks as though the access modi.er has been widened, and the private method foo becomes protected in \nthe subclass, this is actually not the case: method foo in class C2 is a new method, since method foo \nfrom class C1 is not visible. This can be seen when uncommenting one line in the body of C2::foo: the \nprogram does not compile because C1::foo is not visible. Note that the inverse (reducing access) may \n(e.g., C++) or may not (e.g., Java) be possible, depending on the language. Freezable traits allow the \ncomposer (but not the client) to widen or restrict the default access modi.ers of existing methods. C#. \nC# addresses the problem of unintended name capture in subclasses by early-binding a given method name \nto a static scope. C# allows the programmer to assign the key\u00adword new (rather than override) to a method \nto declare that it is used for a different concept than in the superclass and that all calls in the superclass \nshould therefore be statically bound to the local method. The only way to protect internal methods from \nsuch unintended name clashes is to explicitly assign the keyword new to the implementation of each of \nthese methods. Ruby. Ruby is one of the few dynamic languages that of\u00adfers access quali.ers: methods \ncan be quali.ed as public, protected and private. Ruby syntactically distinguishes pri\u00advate from public \nmethods, however a private method may be made public in subclasses. Private methods can only be invoked \nby sending a mes\u00adsage to an implicit receiver (i.e., no use of self). However a call to a private method \nis not statically bound to the method de.ned in the class but can be overriden in subclasses. The following \ncode illustrates the point: class C de.nes a private method x. The method foo does not invoke this method \nsince it does not use an implicit receiver but sends the message x to self. This is why C.new.foo raises \nan error. The method foo2 invokes x with an implicit receiver (i.e., no self). C.new.foo2 executes the \nprivate method x and returns 1. So far this is analogous to the early-binding semantics of freezable \ntraits. Now this is different if a subclass de.nes a public method x returning 2. D.new.foo2 is interesting \nsince it returns 2 and not 1 even though the method x is private and the method foo2 calls x with an \nimplicit receiver. This shows that Ruby s private methods are dynamically resolved contrary to freezable \ntraits which are statically bound. class C def zork(arg) ; return arg.x ; end def foo ; self.x end deffoo2; \nx; end private defx;return1; end end class D < C public defx; return2; end end Results: C.new.foo ==> \nfailed C.new.foo2 ==> 1 D.new.foo ==> 2 D.new.foo2 ==> 2 D.new.zork(D.new) ==> 2 D.new.zork(C.new) ==> \nfailed Eiffel. Eiffel [Mey92] is a pure object-oriented language that supports multiple inheritance. \nFeatures, i.e., methods or instance variables, may be multiply inherited along different paths. Eiffel \nprovides the programmer mechanisms that of\u00adfer a .ne degree of control over whether such features are \nshared or replicated. In particular, features may be renamed by the inheriting class. It is also possible \nto select a particu\u00adlar feature in the case of naming con.icts. Selecting a feature means that from the \ncontext of the composing subclass, the selected feature takes precedence over the possibly con.ict\u00ading \nones. Eiffel supports a feature adaptation clause, export, which allows for an inherited feature to change \nits export status. A set of features may be exported to a list of classes as illustrated in the following \npiece of code: class D inherit A export {X, Y} feature1, feature2 end ... The two features, feature1 \nand feature2, may be invoked by instances of classes X and Y. Since we de.ned the semantics of method \nhiding by re\u00adnaming self message sends, one might wonder how freez\u00adable traits relate to the rename operator \nof Eiffel. First, a class hierarchy cannot be .attened in Eiffel as the multiple inheritance and the \nstatic type check prevent methods from being linearly ordered. Second, the renaming does not actu\u00adally \nhide a method, but renames it and all its references. Jigsaw. In his PhD thesis, Bracha [Bra92] de.ned \nJigsaw as a minimal programming language in which packages and classes are uni.ed under the notion of \na module. A module in Jigsaw is a self-referential scope that binds names to values (i.e., constants \nand functions). It acts as a class (i.e., an object generator) and as a coarse-grained structural software \nunit. Modules can be nested, therefore a module can de.ne a set of classes. A number of operators is \nprovided to compose modules. These operators are instantiation, merge, override, rename, restrict, and \nfreeze. The freeze operator of Jigsaw has the same intent as that of freezable traits, which is to add \nsome privacy to a module or a trait. Despite their similar semantics, two major differ\u00adences exist. First, \nin Jigsaw the semantics of freeze is de\u00adscribed by means of the Y .x-point operator. This prevents a \ncomposition of modules to be .attened. Second, a frozen method cannot be defrosted. In Jigsaw, the interface \nof a module cannot be widened, whereas with freezable traits, trait interfaces may be narrowed and widened \nby means of freeze and defrost. Mixin composition. Van Limberghen and Mens formally describe a mixin \nmodel where encapsulation is orthogonal to mixin composition [MvL96]. Their model uni.es meth\u00adods and \nvariables. They propose an operator to encapsulate methods and state locally to the mixin that de.nes \nit. When encapsulated, self-sends are early bound. All of this is fairly similar to our model. What is \nlacking is an inverse operator such as defrost. They do not mention an implementation that would explain \nhow state is represented. Visibility of modules and packages. In his comparison of module systems, Calliss \n[Cal91] argues that the name clash\u00ading problem ( two same named entities exist in the same re\u00adgion ) \ncan be solved either by employing aliasing (which the author refers to renaming in his work), or quali.ed \nrefer\u00adences. With freezable traits, we show that changing visibility is a third option. One major difference \nbetween visibility mechanisms in Java, C#, Ada and freezable traits, is the fact that a visibility policy \nof a given modular unit is .xed and may not vary in any unanticipated way. With freezable traits, a composer \ndecides which visibility policy to adopt when using a trait. Object-Oriented Encapsulation. Schaerli \net al. proposed encapsulation policies as a way to constrain the interface of an object [SBD04]. With \nObject-Oriented Encapsulation (OOE), two cases are distinguished: (1) an inheritance per\u00adspective where \na class can change the way the superclass methods are bound from the subclass perspective and (2) an \nobject perspective where the interface of an object itself may be changed by associating encapsulation \npolicies with object references. From the inheritance perspective, an encapsulation pol\u00adicy associated \nwith a subclass may be de.ned to change how methods in the superclass are bound. If a subclass inherits \nfrom its superclass using an encapsulation policy that for\u00adbids overriding, the subclass may nevertheless \nre-implement the method with the same name as that in the superclass. In that case, a new method is de.ned \nthat has the same name as a method in its superclass. OOE is based on the syntactic distinction of three \ndifferent messages: super-sends, self\u00adsend and object-send. Only self-sends can be early bound. This \nmeans that for both object-sends and super-sends, the method lookup is the same as in Smalltalk-80 and \nentirely independent of encapsulation policies. Freezable traits ex\u00adploit the same syntactic difference \nbetween messages and share the same design principle in the sense that the com\u00adposer controls composition. \nContrary to Object-Oriented Encapsulation, we did not introduce new byte-codes and did not change the \nvirtual machine but use compiled method copying and bytecode rewriting. Introducing a new byte\u00adcode was \nnot necessary since the goal of OOE was to control object-references and attach to them interfaces (encapsula\u00adtion \npolicies), therefore it is necessary to distinguish between object-sends and self-sends. The goal of \nOOE is broader than that of freezable traits: encapsulation policies could be used to control the visibility \nof con.icting trait methods but encapsulation policies are more general in terms of provid\u00ading visibility \ncontrol in the context of inheritance and for object references. Neither of these issues is a concern \nfor freezable traits. Scala. Scala [sca, Ode07] is a statically typed program\u00adming language integrating \nobject-oriented and functional concepts. It supports classes, traits and mixins. In Scala, a trait is \na class that is meant to be added to some other class as a mixin. Classes inherit from other classes \nand can be composed using mixin composition. This is similar to our approach, with only minor differences \n(traits in Scala can contain variables and are therefore more similar to stateful traits [BDNW07] than \nto the stateless traits of this paper). The major difference regarding con.ict resolution be\u00adtween Scala \nand traits is in the mechanism used. In Scala member resolution is handled by class linearization, and \ncomposition con.icts never occur (the automatic lineariza\u00adtion takes care of them). In freezable traits \nmethod con.icts are automatically triggered at composition time and need to be resolved manually by the \ncomposer. A detailed discussion between linearization approaches from different languages and our approach \ncan be found in [DNS+06]. Scala has a number of modi.ers that can be used with methods. Methods can be \ndeclared private or protected, ei\u00adther on an object basis (object-private or object-protected), or on \nthe more common class basis. There is also the option of declaring methods quali.ed private or quali.ed \nprotected, which means that they are accessible only from code within the denoted class or package. On \nthe other hand Scala does not permit subclasses to change the modi.ers of inherited methods, as is possible \nwith freezable traits. Fortress. The Fortress Programming Language is a general\u00adpurpose, statically typed, \ncomponent-based programming language for producing high-performance software [for]. Functions and methods \n(collectively called known as func\u00adtionals) may be overloaded. Within a trait, multiple declara\u00adtions \nfor the same functional name may coexist in the same scope. In addition several of these may be applied \nto any particular functional call. Calls to overloaded functionals are resolved by determining the most-speci.c \napplicable decla\u00adration. Fortress allows functional declarations to be over\u00adloaded while ensuring the \nuniqueness of call declarations for each send. Fortress does not offer visibility quali.ers for methods \nwhich are public. Trait-based metaprogramming. Reppy and Turon have proposed a new trait system [RT06, \nRT07] called trait-based metaprogramming. Based on the Fisher-Reppy trait calcu\u00adlus [FR03], it adds deep \noperations such as method hiding and renaming to extend the range of con.icts that are solv\u00adable by traits. \nHide and rename are the deep variants of exclude and alias. The hide operation permanently binds a provided \nmethod to a trait, while hiding the method s name. A new method with the same name can be introduced \nas a new pro\u00advided or required method of the trait, but existing references to the method from other \nprovided methods are statically bound to its implementation at the time of hiding. The re\u00adname operation \nchanges the name of a method and all its reference in calling methods. The effect of hide is identical \nto that of freeze: both remove a method from a trait s interface and statically binds a method with its \ninvocations on a caller side. However, contrary to our proposal, no counterpart of hide is offered. The \nuse of a type system constitutes the main difference between trait-based metaprogramming and freezable \ntraits. The main issue that has to be adresssed when hide is intro\u00adduced is to keep the type system sound: \nthe requirements of a trait should remain identical before and after method hiding. To accomplish this, \nReppy and Turon transitively record re\u00adquirements in the inlining assumptions of any other provided method. \nThe challenge tackled by freeze is to be reversible, with the defrost operation. The semantics of trait-based \nmetaprogramming is based on dictionaries (a kind of method dispatch tables) to promote type soundness \n[RS02]. However, with this design decision the .attening property is sacri.ced. 9. Conclusion and future \nwork In this paper we have presented two new composition op\u00aderators to de.ne a visibility mechanism for \ncomposable be\u00adhavioural units. Those operators are applied to support unan\u00adticipated method con.icts \nthat cannot be resolved with more traditional composition operators such as aliasing and over\u00adriding. \nAfter having identi.ed limitations when composing traits, we formulated freezable traits which are traits \naugmented with two operators, freeze and defrost. A public method may be made private with freeze. The \ndual operation, de\u00adfrost widens the visibility of a method by making a private method public. We demonstrated \nthat freezable traits can be .attened away, preventing any kind of diamond situations which multiple \ninheritance has to deal with. Our proposal includes an implementation suitable for dynamic program\u00adming \nlanguages such as Ruby, Python and Smalltalk. In this work, traits do not de.ne variables. A trait is \na group of methods that de.ne a behaviour. In our previous work [BDNW07] we augmented a trait with a \nstate declara\u00adtion. As future work, we plan to combine variable de.nition with the visibility model described \nin this paper. We also plan to use freezable traits in a real-world appli\u00adcation, and compare the results \nwith the stateless and stateful trait models. A possible candidate would be the Collection hierarchy, \nsince it was previously refactored using stateless traits [BSD03]. Composition of modular units that \nmay con.ict in an unanticipated way has been the focus of years of research ranging from classes, modules, \nand packages just to name a few. Currently, the aspect-oriented community is facing the dif.cult problem \nof composing cross-cutting concerns. This paper suggests the use of a visibility mechanism to deal with \nthose situations. Acknowledgment. We would like to thank the anonymous reviewers for their helpful comments \nthat allowed us to sub\u00adstantially improve the quality of this paper. We also would like to thank Shane \nBrennan, Damien Cassou and Damien Pollet for their reviews. S. Ducasse gratefully acknowledges the .nancial \nsupport of the french ANR (National Research Agency) for the project COOK: R\u00b4 earchitecturisation des \napplications industrielles objets (JC05 42872). Oscar Nier\u00adstrasz gratefully acknowledges the .nancial \nsupport of the Swiss National Science Foundation for the project Analyz\u00ading, capturing and taming software \nchange (SNF Project No. 200020-113342, Oct. 2006 -Sept. 2008). References [BDNW07] Alexandre Bergel, \nSt\u00b4ephane Ducasse, Oscar Nier\u00ad strasz, and Roel Wuyts. Stateful traits and their formalization. Journal \nof Computer Languages, Systems and Structures, 2007. To appear. [BL91] Gilad Bracha and Gary Lindstrom. \nModularity meets inheritance. Uucs-91-017, University of Utah, Dept. Comp. Sci., October 1991. [Bra92] \nGilad Bracha. The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. PhD thesis, \nDept. of Computer Science, University of Utah, March 1992. [BSD03] Andrew P. Black, Nathanael Sch\u00a8arli, \nand St\u00b4ephane Ducasse. Applying traits to the Smalltalk collec\u00ad tion hierarchy. In Proceedings of 17th \nInternational Conference on Object-Oriented Programming Sys\u00ad tems, Languages and Applications (OOPSLA \n03), volume 38, pages 47 64, October 2003. [Cal91] Frank W. Calliss. A comparison of module con\u00ad structs \nin programming languages. SIGPLAN Not., 26(1):38 46, 1991. [DDT06] Marcus Denker, St\u00b4ephane Ducasse, \nand \u00b4Eric Tanter. Runtime bytecode transformation for Smalltalk. Journal of Computer Languages, Systems \nand Structures, 32(2-3):125 139, July 2006. [DNS+06] St\u00b4ephane Ducasse, Oscar Nierstrasz, Nathanael Sch\u00a8arli, \nRoel Wuyts, and Andrew Black. Traits: A mechanism for .ne-grained reuse. ACM Trans\u00ad actions on Programming \nLanguages and Systems (TOPLAS), 28(2):331 388, March 2006. [FH92] Matthias Felleisen and Robert Hieb. \nThe revised report on the syntactic theories of sequential control and state. Theor. Comput. Sci., 103(2):235 \n271, 1992. [FKF98] Matthew Flatt, Shriram Krishnamurthi, and Matthias Felleisen. Classes and mixins. \nIn Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages \n171 183. ACM Press, 1998. [for] The Fortress language speci.cation. http://research.\u00adsun.com/projects/plrg/fortress0866.pdf. \n[FR03] Kathleen Fisher and John Reppy. Statically typed traits. Technical Report TR-2003-13, University \nof Chicago, Department of Computer Science, December 2003. [GJSB00] James Gosling, Bill Joy, Guy Steele, \nand Gilad Bracha. The Java Language Speci.cation, Second Edition. Addison Wesley, 2000. [GJSB05] James \nGosling, Bill Joy, Guy Steele, and Gilad Bracha. The Java Language Speci.cation (Third Edition). Addison \nWesley, 2005. [IKM+97] Dan Ingalls, Ted Kaehler, John Maloney, Scott Wallace, and Alan Kay. Back to the \nfuture: The story of Squeak, A practical Smalltalk written in itself. In Proceedings OOPSLA 97, ACM SIGPLAN \nNotices, pages 318 326. ACM Press, November 1997. [Mey92] Bertrand Meyer. Eiffel: The Language. Prentice-Hall, \n1992. [Mey97] Bertrand Meyer. Object-Oriented Software Con\u00adstruction. Prentice-Hall, second edition, \n1997. [MvL96] Tom Mens and Marc van Limberghen. Encapsulation and composition as orthogonal operators \non mixins: A solution to multiple inheritance problems. Object Oriented Systems, 3(1):1 30, 1996. [NDS06] \nOscar Nierstrasz, St\u00b4ephane Ducasse, and Nathanael Sch\u00a8arli. Flattening Traits. Journal of Object Technology, \n5(4):129 148, May 2006. [Ode07] Martin Odersky. Scala language seci.cation v. 2.4. Technical report, \nEcole Polytechnique F\u00b4ed\u00b4erale de \u00b4Lausanne, 1015 Lausanne, Switzerland, March 2007. [RS02] Jon G. Riecke \nand Christopher A. Stone. Privacy via subsumption. Inf. Comput., 172(1):2 28, 2002. [RT06] John Reppy \nand Aaron Turon. A foundation for trait-based metaprogramming. In International Workshop on Foundations \nand Developments of Object-Oriented Languages, 2006. [RT07] John Reppy and Aaron Turon. Metaprogramming \nwith traits. In Proceedings of European Conference on Object-Oriented Programming (ECOOP 2007), 2007. \n[SBD04] Nathanael Sch\u00a8arli, Andrew P. Black, and St\u00b4ephane Ducasse. Object-oriented encapsulation for \ndynami\u00adcally typed languages. In Proceedings of 18th Inter\u00adnational Conference on Object-Oriented Program\u00adming \nSystems, Languages and Applications (OOP\u00adSLA 04), pages 130 149, October 2004. [sca] The scala programming \nlanguage. http://lamp.ep..\u00adch/scala/. [SD05] Charles Smith and Sophia Drossopoulou. Chai: Typed traits \nin Java. In Proceedings ECOOP 2005, 2005. [SDNB03] Nathanael Sch\u00a8arli, St\u00b4ephane Ducasse, Oscar Nier\u00adstrasz, \nand Andrew Black. Traits: Composable units of behavior. In Proceedings of European Conference on Object-Oriented \nProgramming (ECOOP 03), vol\u00adume 2743 of LNCS, pages 248 274. Springer Verlag, July 2003. [Sla] Slate. \nhttp://slate.tunes.org. [TH05] David Thomas and Andy Hunt. Programming Ruby. Addison Wesley, 2nd edition, \n2005. [Wol92] Mario Wolczko. Encapsulation, delegation and inheritance in object-oriented languages. \nIEEE Software Engineering Journal, 7(2):95 102, March 1992. A. SMALLTALKLITE We present SMALLTALKLITE, \na Smalltalk-like dynamic language featuring single inheritance, message-passing, .eld access and update, \nand self and super sends. SMALL-TALKLITE is similar to CLASSICJAVA, but removes inter\u00adfaces and static \ntypes. Fields are private in SMALLTALKLI-TE, so only local or inherited .elds may be accessed. We base \nour approach on the object model used by Flatt et al. [FKF98] to give a semantics for mixins for Java-like \nlan\u00adguages. We adapt the CLASSICJAVA model they introduce to develop SMALLTALKLITE, a simple calculus \nthat captures the key features of Smalltalk-like dynamic languages. A.1 SMALLTALKLITE reduction semantics \nThe syntax of SMALLTALKLITE is shown in Figure 23. SMALLTALKLITE is similar to CLASSICJAVA, while eliding \nthe features related to static typing. We similarly ignore features that are not relevant to a discussion \nof traits, such as re.ection or class-side methods. In order to simplify the reduction semantics of SMALL-TALKLITE, \nwe adopt an approach similar to that used by Flatt et al. [FKF98], namely we annotate .eld accesses and \nsuper sends with additional static information that is needed at run-time . This extended redex syntax \nis shown in Fig\u00adure 22. The .gure also speci.es the evaluation contexts for the extended redex syntax \nin Felleisen and Hieb s notation [FH92]. Predicates and relations used by the semantic reductions are \nlisted in Figure 25. (The predicates CLASSESONCE(P ) etc are assumed to be preconditions for valid programs, \nand are not otherwise explicitly mentioned in the reduction rules.) P f(e, S) '.(e ' , S ') means that \nwe reduce an expres\u00ad sion (redex) e in the context of a (static) program P and a (dynamic) store of objects \nS to a new expression e ' and (pos\u00ad e = v | new c | x | self | e.f | e.f=e | e.m(e*) | super(o, c).m(e*) \n| let x=e in e E = [] | o.f=E | E.m(e*) | o.m(v * Ee*) | super(o, c).m(v * Ee*) | let x=E in e v, o = \nnil | oid Figure 22. Redex syntax P = defn* e defn e meth c f = = ||= = = class c extends c { f*meth* \n}new c | x | self | nil f | f=e | e.m(e *) super.m(e *) | let x=e in e m(x *) { e }a class name | Object \na .eld name m = a method name x = a variable name Figure 23. SMALLTALKLITE syntax  sibly) updated store \nS '. A redex e is essentially an expression e in which .eld names are decorated with their object con\u00adtexts, \ni.e., f is translated to o.f, and super sends are deco\u00adrated with their object and class contexts. Redexes \nand their subexpressions reduce to a value, which is either an object identi.er or nil. Subexpressions \nmay be evaluated within an expression context E. The store consists of a set of mappings from object \niden\u00adti.ers oid . dom(S) to tuples (c, {f . v}) representing the class c of an object and the set of \nits .eld values. The initial value of the store is S = {}. Translation from the main expression to an \ninitial redex is speci.ed out by the o[ e] function (see Figure 24). This c binds .elds to their enclosing \nobject context and binds self to the oid of the receiver. The initial object context for a program is \nnil.(i.e., there are no global .elds accessible to the main expression). So if e is the main expression \nassociated to a program P , then nil[ e] Object is the initial redex. The reductions are summarised in \nFigure 26. new c [new] reduces to a fresh oid, bound in the store to an object whose class is c and whose \n.elds are all nil. A (local) .eld access [get] reduces to the value of the .eld. Note that it is syntactically \nimpossible to access a .eld of another object. The redex notation o.f is only generated in -P Direct \nsubclass '' c -P c.. class c extends c\u00b7\u00b7\u00b7{\u00b7\u00b7\u00b7} . P =P Indirect subclass ' c =P c= transitive, re.exive \nclosure of -P .P Field de.ned in class f .P c .. class \u00b7 \u00b7 \u00b7 {\u00b7 \u00b7 \u00b7 f \u00b7\u00b7\u00b7} . P .P Method de.ned in class \n(m, x * ,e).P c .. class \u00b7 \u00b7 \u00b7 {\u00b7 \u00b7 \u00b7 m(x *){e}\u00b7\u00b7\u00b7} . P .* P Field de.ned in c '' f .* c .. .c,c =P \nc',f .P c P .* Method lookup starting from c P (c, m, x * ,e).* c' .. c' = min{c'' |(m, x * ,e).P c'',c \n=P c''} P CLASSESONCE(P ) Each class name is declared only once '' ' .c,c, class c \u00b7\u00b7\u00b7 class c\u00b7\u00b7\u00b7 is \nin P . c= cFIELDONCEPERCLASS(P ) Field names are unique within a class declaration .f, f', class c \u00b7 \n\u00b7 \u00b7 {\u00b7 \u00b7 \u00b7 f \u00b7\u00b7\u00b7 \u00b7\u00b7\u00b7} is in P . f f' = f' FIELDSUNIQUELYDEFINED(P ) Fields cannot be overridden '' \nf .P c, c =P c=. f .P cMETHODONCEPERCLASS(P ) Method names are unique within a class declaration '' .m,m, \nclass c \u00b7 \u00b7 \u00b7 {\u00b7 \u00b7 \u00b7 m(\u00b7\u00b7\u00b7 ){\u00b7 \u00b7 \u00b7 } \u00b7 \u00b7 \u00b7 m'(\u00b7\u00b7\u00b7 ){\u00b7 \u00b7 \u00b7 } \u00b7 \u00b7 \u00b7 } is in P . m= mCOMPLETECLASSES(P ) \nClasses that are extended are de.ned range(-P ) . dom(-P ) .{Object}WELLFOUNDEDCLASSES(P ) Class hierarchy \nis an order =P is antisymmetric CLASSMETHODSOK(P ) Method overriding preserves arity 'x''' .m,m, (m, \nx1 \u00b7\u00b7\u00b7 xj ,e).P c, (m, x'1 \u00b7\u00b7\u00b7 ,e').P c,c =P c=. j = k k Figure 25. Relations and predicates for SMALLTALKLITE \nP f(E[new c], S) '.(E[oid], S[oid .(c, {f . nil |.f, f .* c})]) [new] P where oid .. dom(S) P f(E[o.f], \nS) '.(E[v], S) [get] where S(o)= (c, F) and F(f)= v P f(E[o.f=v], S) '.(E[v], S[o .(c, F[f . v])]) [set] \nwhere S(o)= (c, F) P f(E[o.m(v *)], S) '.(E[o[ e[v */x *]]]], S) [send] c ' ' where S[o]= (c, F) and \n(c, m, x * ,e).* c P P f(E[super(o, c).m(v *)], S) '.(E[o[ e[v */x *]]]'' ], S) [super] c ' '* ''''' \nwhere c -P c and (c ,m, x ,e).* c and c =P c P P f(E[let x=v in e], S) '.(E[e[v/x]], S) [let] Figure \n26. Reductions for SMALLTALKLITE the context of the object o. Field update [set] simply updates the corresponding \nbinding of the .eld in the store. When we send a message [send], we must look up the cor\u00adresponding method \nbody e, starting from the class c of the receiver o. The method body is then evaluated in the context \nof the receiver o, binding self to the receiver s oid. Formal parameters to the method are substituted \nby the actual ar\u00adguments (see Figure 27). We also pass in the actual class in which the method is found, \nso that super sends have the right context to start their method lookup. super sends [super] are similar \nto regular message sends, except that the method lookup must start in the superclass of class of the \nmethod in which the super send was declared. When we reduce the super send, we must take care to '' pass \non the class c of the method in which the super method was found, since that method may make further \nsuper sends. let in expressions [let] simply represent local variable bindings. Errors occur if an expression \ngets stuck and does not reduce to an oid or to nil. This may occur if a non-existent o[ new c '] c = \nnew c ' o[ x] c = x o[ self] c = o o[ nil] c = nil o[ f] c = o.f o[ f=e] c o[ e.m(e * i )]]c o[ super.m(e \n* i )]]c o[ let x=e in e '] c = = = = o.f=o[ e] c o[ e] c .m(o[ ei] * c ) super(o, c).m(o[ ei] * c ) \nlet x=o[ e] c in o[ e '] c Figure 24. Translating expressions to redexes  new c [v/x]= new c x [v/x]= \nv x ' [v/x]= x ' self [v/x]= self nil [v/x]= nil f [v/x]= f f=e [v/x]= f=e[v/x] ** e.m(e )[v/x]= e[v/x].m(e \n[v/x]) ii ** super.m(e )[v/x]= super.m(e [v/x]) ii '' let x=e in e [v/x]= let x=e[v/x] in e ' let x ' \n=e in e [v/x]= let x ' =e[v/x] in e '[v/x] Figure 27. Variable substitution variable, .eld or method \nis referenced (for example, when sending any message to nil). For the purpose of this paper we are not \nconcerned with errors, so we do not introduce any special rules to generate an error value in these cases. \n   \n\t\t\t", "proc_id": "1297027", "abstract": "<p>A trait is a unit of behaviour that can be composed with other traits and used by classes. Traits offer an alternative to multiple inheritance. Conflict resolution of traits, while flexible, does not completely handle accidental method name conflicts: if a trait with method <i>m</i> is composed with another trait defining a different method <i>m</i> then resolving the conflict may prove delicate or infeasible in cases where both versions of m are still needed. In this paper we present <i>freezeable traits</i>, which provide an expressive composition mechanism to support unanticipated method composition conflicts. Our solution introduces private trait methods <i>and</i> lets the class composer change method visibility at composition time (from public to private and vice versa). Moreover two class composers may use different composition policies for the same trait, something which is not possible in mainstream languages. This approach respects the two main design principles of traits: the class composer is empowered and traits can be flattened away. We present an implementation of freezable traits in Smalltalk. As a side-effect of this implementation we introduced private (early-bound and invisible) methods to Smalltalk by distinguishing object-sends from self-sends. Our implementation uses compile-time bytecode manipulation and, as such, introduces no run-time penalties.</p>", "authors": [{"name": "St&#233;phane Ducasse", "author_profile_id": "81100625020", "affiliation": "LISTIC Universit&#233; de Savoie & INRIA Futurs, Lille, France", "person_id": "P396541", "email_address": "", "orcid_id": ""}, {"name": "Roel Wuyts", "author_profile_id": "81100639276", "affiliation": "IMEC and Universit&#233; Libre de Bruxelles, Brussels, Belgium", "person_id": "PP39067163", "email_address": "", "orcid_id": ""}, {"name": "Alexandre Bergel", "author_profile_id": "81342489310", "affiliation": "Hasso-Plattner-Institut & LERO: Trinity College Dublin, Potsdam, Germany", "person_id": "PP39088989", "email_address": "", "orcid_id": ""}, {"name": "Oscar Nierstrasz", "author_profile_id": "81100134506", "affiliation": "University of Bern, Bern, Switzerland", "person_id": "PP39029114", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297040", "year": "2007", "article_id": "1297040", "conference": "OOPSLA", "title": "User-changeable visibility: resolving unanticipated name clashes in traits", "url": "http://dl.acm.org/citation.cfm?id=1297040"}