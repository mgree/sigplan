{"article_publication_date": "10-21-2007", "fulltext": "\n Variant Path Types for Scalable Extensibility Atsushi Igarashi Kyoto University, Japan igarashi@kuis.kyoto-u.ac.jp \n Abstract Much recent work in the design of object-oriented program\u00adming languages has been focusing \non identifying suitable features to support so-called scalable extensibility,where the usual extension \nmechanism by inheritance works in differ\u00adent scales of software components that is, classes, groups of \nclasses, groups of groups and so on. Its typing issues has usually been addressed by means of dependent \ntype systems, where nested types are seen as properties of objects. In this work, we seek instead for \na different solution, which can be more easily applied to Java-like languages, in which nested types \nare considered properties of classes. We introduce the mechanism of variant path types,which provide \na .exible means to express intra-group relationship (among classes) that has to be preserved through \nextension. In particular, improving and extending existing works on groups and exact types, we feature \nthe new notions of exact and inexact quali.cations, providing rich abstractions to ex\u00adpress various kinds \nof set of objects, with a .exible subtyp\u00ading scheme. We formalize a safe type system for variant path \ntypes on top of Featherweight Java. Our development results in a complete solution for scalable extensibility, \nsimilarly to previous attempts based on dependent type systems. Categories and Subject Descriptors D.3.1 \n[Programming Languages]: Formal De.nitions and Theory; D.3.2 [Pro\u00adgramming Languages]: Language Classi.cations \nObject\u00adoriented languages; D.3.3 [Programming Languages]: Lan\u00adguage Constructs and Features Classes and \nobjects; Poly\u00admorphism; F.3.3 [Logics and Meaning of Programs]: Stud\u00adies of Program Constructs Object-oriented \nconstructs; Type structure General Terms Design, Languages, Theory Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4eal, \nQu\u00b4ebec, Canada. Copyright c . 2007 ACM 978-1-59593-786-5/07/0010...$5.00 Mirko Viroli Alma Mater Studiorum \n Universit`a di Bologna, Italy mirko.viroli@unibo.it Keywords Scalable extensibility, subtyping, variance, \nvari\u00adant path types 1. Introduction Background Much recent work in the design of object\u00adoriented programming \nlanguages has been focusing on iden\u00adtifying suitable features to support extensibility not just for individual \nclasses, but also for groups of classes, groups of groups and so on. This research direction is meant \nto make object-oriented languages meet the requirements of scal\u00adable component-based applications: since \na reusable piece of code (namely, a component) can be implemented as a group of cooperating classes, \nit would be useful to apply the tra\u00additional mechanism of inheritance to groups of classes. Re\u00adsearches \non family polymorphism [12], higher-order struc\u00adtures [13], nested inheritance [25], and grouping mecha\u00adnisms \n[3, 20, 30], all share this common goal, which we shall refer to as scalable extensibility, the term \ncoined in the work by Nystrom et al. [25]. In particular, for an object-oriented language supporting \nscalable extensibility, a number of fea\u00adtures must be provided, namely: (i) a mechanism for nest\u00ading \nclasses at an arbitrary level, (ii) an inheritance construct seamlessly working for both single classes \nand groups of classes, (iii) a .exible subtyping relation for nested class\u00adtypes, and (iv) a group-polymorphism \nmechanism. It is very well known that scalable extensibility suffers from the covariance problem: in \nthe standard framework of inheritance is subtyping of object-oriented languages, the mutual inter-relationships \nof classes in the same group can\u00adnot be safely preserved by group extension. Languages sup\u00adporting scalable \nextensibility usually solve this problem by a rather expressive dependent type (or class) system, as \nin JX [25], Scala [28], or gbeta [13] (notable exceptions include Bruce s work [3] and Concord [20]). \nAlthough there are sev\u00aderal studies on simple core calculi for languages with depen\u00addent types such as \nfor Scala and gbeta [27, 10, 14] such languages are typically more complex than the standard Java setting \nand more dif.cult to manage. In particular, the fact that nested types are accessed through a restricted \nset of ex\u00adpressions raises subtle interactions with somewhat orthogo\u00adnal aspects such as immutability \nof .elds and variables see Section 5 for a more detailed discussion. It is there\u00adfore interesting to \nstudy whether scalable extensibility can be achieved in a language without dependent types, for pos\u00adsibly \neasier application to mainstream Java-like languages, by starting from existing work on self-references \n(MyType), grouping mechanisms, and exact types [5, 3, 20, 29]. Our Contributions In [29], we started \napproaching this issue by seeking a minimal set of features for supporting features related to family \npolymorphism [12] in the context of scalable extensibility at only one level of nesting. This set includes \nan inheritance mechanism for group of classes decoupled from subtyping, a notion of relative path types \nto express mutual dependency preserved by inheritance, and family polymorphic methods through type variables \nover groups thereby, dependent types are avoided. In this paper, we advance this approach by supporting \nar\u00adbitrary levels of group hierarchies and by a new typing con\u00adstruct which we name variant path types1, \nwhich achieve .exibility and expressiveness in both subtyping and acces\u00adsibility of the hierarchy. Based \non our previous work [29], this construct .rst extends the concept of relative path types to work in \na deeply nested structure. Then, generalizing the notion of MyType and MyGroup in [2, 3], such types \ncan express self reference and mutual reference among classes in a group, which have to be preserved \nby group extension. In addition, such types feature two kinds of quali.cations the notation to access \na nested class D (as a type) inside the class of a type T which can be used in combination at any level \nof nesting: exact (T@D)and inexact quali.ca\u00adtions (T.D). While exact quali.cation supports safe poly\u00admorphism \nat the group level (or binary methods in a broad sense) by restricting subtyping, inexact quali.cation \nrecov\u00aders subtyping by preventing unsafe invocations of (binary) methods. Thereby, they provide rich \nabstractions to express various kinds of set of objects with .exible subtyping. The name variant comes \nfrom the facts that: (i) the two kinds of quali.cations can be seen as operators that, given a path type \nT, take a (nested) class name C and yield types T@C and T.C respectively; and (ii) such operators have \nvariance prop\u00aderties concerning subtyping/subclassing similarly to variant parametric types [18] (a.k.a. \nwildcards [32] in Java 5.0 [15]). More speci.cally, exact quali.cations act as invariant: T@D is a subtype \nof T@E only when D = E; and inexact quali.cations act as covariant: T.D is a subtype of T.E when D extends \nE (inside the class of type T). Our technical contributions can be summarized as fol\u00adlows: the introduction \nof the notion of variant path types for safe scalable extensibility; and  formalization of a core language \nFJ extending Feather\u00adweight Java [17] (FJ) with a sound type system of variant path types.  1 This name \nwas derived from the metaphor of a nesting hierarchy of classes as adirectory structurein a .lesystem. \nFull potential of the expressiveness of variant path types and applicability to mainstream languages \nlike Java are yet to be fully explored. Nevertheless, variant path types are interesting for they support \nsafe extensions of groups in a fairly simple setting, and can then be considered as a basis for a lightweight \nform of scalable extensibility. This paper is an extended version of [19]. Rest of This Paper Section \n2 describes the basic frame\u00adwork of classes with arbitrary level of nesting and exten\u00adsion; Section 3 \nintroduces the informal syntax and semantics of variant path types, mainly by means of examples. Then, \nSection 4 develops the formal core calculus FJ. Finally, Sec\u00adtion 5 discusses related works, and Section \n6 provides con\u00adcluding remarks. 2. Class Nesting and Extension In this section, we brie.y review how \nthe notion of groups and their extension provide scalable extensibility, by consid\u00adering a simpli.ed \nsetting without static types. 2.1 Grouping Classes by Nesting As in previous approaches [12, 13, 28, \n25], we see a class as both a mechanism to generate objects and one to group classes. Considering the \ngraph example [12], which is described by a class de.nition like: class Graph{ class Node{ field edges; \n} class Edge{ field src, dst; method connect(node1, node2) { src=node1; dst=node2; } } .. method createGraph(..){..} \n} Here, we de.ne a group of classes: classes Node and Edge are called member classes of the group class \nGraph. (In order to concentrate on the semantics of groups and their inheritance, in this section we \nwill use keywords field and method, instead of types, for .eld/method declarations.) To denote a nested \nclass, we rely on the familiar notation of C1.C2. \u00b7\u00b7\u00b7.Cn, which can be used e.g. to create instances \nout of members Edge and Node as in the following code: var e = new Graph.Edge(..); var n = new Graph.Node(..); \n (Again, we use the keyword var for variable declarations.) A new instance of member Edge (Node, resp.) \ninside class Graph is assigned to variable e (n,resp.). A key idea of scalable extensibility is to extend \nthe usual class extension mechanism to allow a class to inherit not only .elds and methods but also member \nclasses, which can be further extended. For example, below is the de.nition of the new group class CWGraph \n(a class for graphs of colored nodes and weighted edges): class CWGraph extends Graph { class Node { \nfield color; } class Edge { field weight; method connect(node1, node2) { weight = \u00b7\u00b7\u00b7; super.connect(node1, \nnode2); } } } CWGraph inherits method createGraph() and member classes Node and Edge; furthermore, those \nmember classes are extended simultaneously with new .elds and meth\u00adods such as color, weight, and an \noverriding method connect(). Hence, an instance of CWGraph.Edge has three .elds: var e = new CWGraph.Edge(..); \n\u00b7\u00b7\u00b7 e.weight \u00b7\u00b7\u00b7 e.src \u00b7\u00b7\u00b7 e.dst \u00b7\u00b7\u00b7 This extension mechanism is meant to work at any depth in the structure \nof nesting. If Graph.Edge itself de\u00ad.nes member classes A and B,then CWGraph.Edge.A and CWGraph.Edge.B \nautomatically inherit from the original versions of A and B inside Graph.Edge. In standard single-inheritance \nlanguages such as Java and Smalltalk, the complete de.nition of a subclass is obtained by composing all \nof its superclasses by taking overriding into account. Here, the complete de.nition of a class is obtained \nby recursively composing enclosing classes from the top level down to the leaf of the nesting hierarchy \n[11]. For example, the complete de.nition of CWGraph is obtained by composing Object, Graph and CWGraph \nin this order; it composes Node and Edge in Graph with those in CWGraph, resulting in the expected group \nof classes. 2.2 Extension inside Group As discussed elsewhere [13, 25], it is reasonable to expect members \nof a class to extend another class. In particular, it would be useful to allow a member class to extend \nfrom another in the same group to express the so-called expression example [25, 31], as in Figure 1. \nThe group class AST (which stands for abstract syntax trees) has classes Literal and Plus for abstract \nsyntax tree nodes that extend another member Expr of the same class. Each member class is equipped with \nmethod toString() to return a string representation of an abstract syntax tree. In an extension ASTeval \nof AST, each member class is extended with eval() for evaluation. As in the previous example, ASTeval.Plus \ninherits .elds op1 and op2 from AST.Plus. This schema seems to naturally lead to a mul\u00adtiple inheritance \nscenario: ASTeval.Plus actually inherits from ASTeval.Expr and AST.Plus, and both of these in\u00adherit from \nAST.Expr thus leading to a typical diamond structure. Notice that, while inheriting from ASTeval.Expr \nclass AST{ field root; class Expr extends Object{ method toString(){ return \"\"; } } class Literal extends \nExpr { field val; method toString(){ return val; } } class Plus extends Expr { field op1, op2; method \ntoString(){ return this.op1.toString()+ \"+\"+this.op2.toString(); } method replaceOp1(e) { this.op1 = \ne; } } } class ASTeval extends AST { class Expr extends Object{ method eval(){ return 0; } } class Literal \nextends Expr{ method eval(){ return val; } } class Plus extends Expr{ method eval(){ return this.op1.eval() \n+ this.op2.eval(); } } } Figure 1. Simple Expressions is explicit through the extends clause, inheriting \nfrom AST.Plus is implicit, as it is due to the enclosing group extension. As argued also in Nystrom et \nal. [25], however, we can avoid problems that typically happen in ordinary multiple\u00adinheritance languages \nby hierarchical, recursive composition described above. To obtain a complete de.nition of Plus in ASTeval, \nfor example, the top-level ASTeval is .rst composed with AST, resulting in member classes each of which \nis composed with the member class of the same name in AST. Then, the complete de.nition of Plus is .nally \nobtained by composing Expr and Plus in the composed ASTeval. In this way, bodies of superclasses can \nbe given a linear order. Note that in general, deeper nesting structures might lead a class to inherit \nfrom more than two classes, but the above discussion naturally extends to such cases, as formalized in \nSection 4.  3. Variant Path Types Built on top of this language fragment with class nesting and hierarchical \ncomposition, we introduce variant path types that allow a number of interesting relationships among classes \nin a group to be expressed. 3.1 Absolute vs. Relative Path Types The ability to automatically inherit \nmember classes (in gen\u00aderal a whole structure of nesting) is not suf.cient per se to provide a true scalable \nextensibility mechanism in a stati\u00adcally typed setting. If some relationship exists among mem\u00adbers inside \na group e.g., in Graph we have that instances of member Edge should hold a reference to an instance of \nmember Node then we want it to be preserved through ex\u00adtension. That is, the same relation must automatically \nhold in class CWGraph as well. More concretely, we may require instances of Graph.Edge to hold references \nto instances of Graph.Node, and instances of CWGraph.Edge to hold references to instances of CWGraph.Node,as \nalsoargued in Ernst [12]. In other words, cross-group references such as an instance of CWGraph.Node \nbeing a source node of Graph.Edge must be disallowed. However, a naive type sys\u00adtem as in Java fails \nto express such an invariant: if we declare src and dst to have type Graph.Node, then those .elds would \nbe inherited with the same type, resulting in cross\u00adgroup reference. To express such relationship, we \nintroduce a new kind of types called relative path types [29], which refer to other classes in a relative \nway from the class where that type appears (as in relative path expressions in the UNIX .le system). \nExamples of relative path types are This, This.A, This.A.B, ^This, ^^This, ^This.A. Type This means the \ncurrent class it is found in other languages [25, 4] with a different name such as MyType [2]. Analogously, \ntype This.A means member A inside the current class , and This.A.B member B inside member A inside cur\u00adrent \nclass . Type ^This means the group of the current class (or the enclosing class of the current class \n), type ^^This the group of the group of the current class , and so on. Finally, ^This.A is member A \ninside the group of the current class , which is a type used by a class to denote another member of its \ngroup. A general form ^ \u00b7\u00b7\u00b7^This.C1.C2. \u00b7\u00b7\u00b7.Cn of relative path types is hence understood as .rst going \nup k times in the nesting structure (k is the number of ^ ), and then going down through path C1.C2.... \n.Cn.2 In the previous graph example, the intra-group relation\u00adship between Edge and Node is expressed \nby using type ^This.Node, which means Graph.Node in the class of Graph.Edge and CWGraph.Node in the class \nof CWGraph.Edge, and ^This.Edge. Figure 2 shows a complete graph example written in our language. Here, \nnodes hold a reference to an array of edges of type ^This.Edge and edges hold two ref\u00aderences to source \nand destination nodes of type ^This.Node to express they are from the same kind of graph. In the class \nCWGraph, types of those .elds are inherited as written in the superclass and they now refer to Edge and \nNode in CWGraph. This example also clari.es the need to disallow cross-group 2 An operator similar to \n^ is often introduced as a special form of quali.\u00adcation .out [14, 9] and, in Tribe [9], .out can appear \nanywhere in a path type. We allow ^ to apply only to This or type variables (introduced later) since \nin our setting where nested classes are properties of classes, rather than objects as in Tribe symbol \n^ in the middle of a type expression will simply cancel a preceding quali.cation. class Graph { class \nNode { ^This.Edge[] es=new ^This.Edge[10]; int i=0; void add(^This.Edge e) { es[i++] = e; } } class Edge \n{ ^This.Node src, dst; void connect(^This.Node s, ^This.Node d) { src=s; dst=d; s.add(this); d.add(this); \n}} .. This.Node startNode; boolean containsNode(This.Node n){..} boolean containsEdge(This.Edge n){..} \n } class CWGraph extends Graph { class Node { Color color; } class Edge { int weight; void connect(^This.Node \ns, ^This.Node d) { weight = colorToWeight(s.color, d.color); super.connect(s, d); }} } Figure 2. Graph \nand CWGraph Classes references: method connect() invoked through CWGraph must take two instances of CWGraph.Node, \notherwise ac\u00adcessing .eld color on them would fail. As seen in previous section, relative path types \nare cou\u00adpled with types of the kind C1. \u00b7\u00b7\u00b7.Cn which we call ab\u00adsolute path types, since they denote \na certain class indepen\u00addently of the location where such a type is used. A natural way to exploit the \nclass structure seen above through absolute types is as follows: Graph g = new Graph( \u00b7\u00b7\u00b7); \u00b7\u00b7\u00b7 Graph.Node \nn = g.startNode; CWGraph.Edge e; CWGraph.Node n1,n2; \u00b7\u00b7\u00b7 e.connect(n1, n2); Notice that the type of \nstartNode is declared to be This.Node and accessed through the absolute path type Graph yields type Graph.Node \nby substituting the receiver type Graph for This. Similarly, the argument types of e.connect() becomes \nCWGraph.Node by replacing ^This in the declared type ^This.Node with CWGraph,which is a pre.x of the \nreceiver type CWGraph.Edge. 3.2 Exactness for Type Safety It is very well known that scalable extensibility \nsuffers from the covariance problem: in the standard framework of in\u00adheritance is subtyping of mainstream \nobject-oriented lan\u00adguages, it is not safe to use type This (and some other rela\u00adtive path types) in \ncertain places such as a method argument type. In our graph example, although class CWGraph inherits \nGraph and class CWGraph.Node implicitly inherits from Graph.Node, assuming naively CWGraph to be a subtype \nof Graph or similarly CWGraph.Node to be a subtype of Graph.Node will break type safety as the following \ncode reveals: Graph.Node n1 = new Graph.Node(..); Graph.Node n2 = new Graph.Node(..); Graph.Edge e = \nnew CWGraph.Edge(..); e.connect(n1,n2); // Unsafe call Graph g = new CWGraph(..); Graph.Edge e2 = g.startNode.es[0]; \ne2.connect(n1,n2); // Also unsafe Since the code fragment above is trying to connect two Graph.Nodes \nwith a CWGraph.Edge, the call to connect() causes the attempt to access .eld color on a node of type \nGraph.Node, which does not have it! Actually, a similar sit\u00aduation occurs only by allowing subtyping \nbetween CWGraph and Graph as the last three lines show. To solve this problem, some language mechanism \nis re\u00adquired to ensure that the classes of e, n1,and n2 are mem\u00adbers of the same group. The solution \nadopted in JX relies on what they call dependent classes and immutable variables see Section 5 for a \ndetailed discussion. We instead rely on a simpler solution of exact types [5, 3, 4], brie.y reviewed \nbelow. An exact type denotes instances of a single class, exclud\u00ading any of its subclasses: thus exact \ntypes also plays a role of run-time types of objects. We might use the tentative no\u00adtation @(A) to mean \nan exact type corresponding to the class designated by the absolute path type A: for example, ex\u00adact \ntype @(Graph.Node) consists only of instances of class Graph.Node. On the other hand, a type Graph.Node,which \nis said to be inexact, includes instances of class Graph.Node and its subclasses, explicit or implicit.3 \nA method taking a relative path type such as connect() cannot be invoked on inexact Graph.Edge, as we \ndo not know whether an actual instance belongs to the group Graph or CWGraph. Thus, in\u00advocation of a \nmethod taking a relative path type is allowed only when the receiver type is exact; the argument type \nob\u00adtained by replacing This (or ^ \u00b7\u00b7\u00b7^This) will also be con\u00adsidered exact. In this sense, This (possibly \nwith ^)is always exact. By using exact types, the type system can reject the example above: invocation \nof connect() on inexact type Graph.Edge is prohibited. If the type of e were declared to be @(Graph.Edge) \nso that connect() can be invoked, the assignment @(Graph.Edge) e = new CWGraph.Edge(..); 3 Note that \nthe same notation Graph.Node is used sometimes to denote a single class named Node nested in Graph and \nsometimes to denote an inexact type. before the invocation would be prohibited because @(Graph.Edge) \nis not a supertype of @(CWGraph.Edge). (Expressions new will be given exact types since the class is \nknown.)  3.3 Exact and Inexact Quali.cations and Subtyping In the above section, @ was treated as an \noperator for abso\u00adlute path types. However, in our setting, we have found that it is more natural to \nconsider that @ is rather a new kind of quali.cation in addition to . , in order to control the degree \nof exactness in a more .ne-grained manner! So, for class AST.Expr, say, variant path types now feature \nfour kinds of types: a fully exact type @AST@Expr (which was written @(AST.Expr) above), partially inexact \ntypes .AST@Expr and @AST.Expr, and .nally .AST.Expr (which was writ\u00adten AST.Expr) with the usual meaning. \nWe call . inex\u00adact quali.cation and @ exact quali.cation. Here, @ at the head can be considered an exact \nquali.cation over the top level, or a package. An inexact quali.cation over the top level can be omitted \nfor syntactic analogy with Java, writing e.g. AST.Expr instead of .AST.Expr. (In the formal calcu\u00adlus \nintroduced in the next section, on the other hand, even the top level will be made explicit as the symbol \n/ and, for example, AST.Expr will be formally written /.AST.Expr.) The intuition behind a type like @A.B \nis the common supertype of all the members that extends B inside class A (@A@B included). So, type @AST.Expr \nis a common su\u00adpertype of @AST@Expr, @AST@Literal,and @AST@Plus. Similarly, A@B is read as the common \nsupertype of mem\u00adber B in the group A or its subclasses (@A@B included). So, AST@Expr is a common supertype \nof @AST@Expr and @ASTeval@Expr but not @AST@Literal. Figure 3 shows the subtyping hierarchy for abstract \nsyntax nodes. The name variant path types comes from the two kinds of quali.\u00adcations, which introduce \ndifferent variance with respect to the simple class name after quali.cation: symbol @ acts as invariant \nT@D is a subtype of T@E only when D = E and . acts as covariant T.D is a subtype of T.E when D extends \nE (inside the class of T). Now, dots in relative path types are also considered inex\u00adact quali.cation: \nfor instance This.B would be the com\u00admon supertype of all the members that extends B inside the current \nclass , and ^This.B the common supertype of all the members that extends B inside the enclosing class \n. Thus, type ^This.Expr used inside some member of AST would denote the set of all nodes of the current \nversion of abstract syntax tree. Now, AST with type annotations can be written as follows: class AST \n{ class Expr {..} class Literal extends Expr {..} class Plus extends Expr { ^This.Expr op1, op2; String \ntoString(){ return this.op1.toString() + \"+\" + this.op2.toString(); } AST.Expr A     @AST.Expr AST@Expr \n@ASTeval.Expr  @AST@Expr @ASTeval@Expr 7 . .          Figure 3. The rich subtyping hierarchy \nfor the expression example. Dotted arrows represent subtyping while solid arrows represent inheritance, \nwhich is not subtyping. void replaceOp1(^This.Expr e) { this.op1 = e; return; } } } Type ^This.Expr \nis used to denote the two operands of a Plus expression. An instance of @AST@Plus can con\u00adtain any @AST.Expr, \nthat is, instances of type @AST@Plus, or @AST@Literal, as operands, whereas an instance of @ASTeval@Plus \ncan contain any @ASTeval.Expr.There\u00adfore, types This, ^This, ^^This, and so on, are exact types.  3.4 \nInexact Quali.cation and Access Restriction Since an inexact type is a common supertype of many ex\u00adact \ntypes, it is clear from the substitutability principle that it should provide a more restricted access \nto its methods and .elds than any of those exact types, and in particular, its ex\u00adact version. For example, \nit is easy to see that @Graph@Edge provides connect(), which takes only @Graph@Nodes(not @CWGraph@Node), \nwhereas Graph.Edge does not. Actually, even a partially inexact type can allow access to methods taking \nrelative path types. For example, connect() can be safely invoked on @Graph.Edge since the argument type \n^This.Node of connect() only requires arguments to belong to the same graph it does not require Nodestobe \nexact (due to inexact quali.cation). The rule of thumb is that a method taking a relative path type can \nbe invoked when the type replacing ^ \u00b7\u00b7\u00b7^This is exact: in this case, ^This in ^This.Node is replaced \nwith exact @Graph,apre.x of @Graph.Edge.4 4 One might want to use ^This@Edge and ^This@Node rather than \n^This.Edge and ^This.Node in the graph example in Figure 2. The choice would not matter in this particular \ncode because nested classes Node and Edge do not have a binary method (such as equal() taking an argu\u00adment \nof type This). If Node had equal(), then invoking it on s or d inside connect() have to be prohibited \nbecause the type of s or d is (partially) inexact. To invoke equal(), their types would have to be ^This@Node, \nwhich is fully exact. See the discussion below, too. To clarify the differences between ^This.C and This, \nwe describe an example of equal() for checking (syntac\u00adtic) equality of abstract syntax trees. It also \ndemonstrates usefullness of partially inexact types. A natural design choice would be to add this method \nto class AST.Expr with signature boolean equal(This e), and implement it, for example, in class Plus \nas follows: class AST { \u00b7\u00b7\u00b7 class Plus extends Expr{ ^This.Expr op1, op2; \u00b7\u00b7\u00b7 boolean equal(This e){ \nreturn this.op1.equal(e.op1) &#38;&#38; this.op2.equal(e.op2); } } } Unfortunately, this implementation \ndoes not typecheck: since equal() takes a relative path type This,which re\u00adquires the receiver type to \nbe fully exact, it cannot be in\u00advoked on this.op1 of type ^This.Expr. In fact, it should not typecheck \nit can happen that the (run-time) type of re\u00adceiver this.op1 and argument e.op1 are not the same. It \nis also weird that equal() takes This, since it will only amount to allowing comparison of two ASTs whose \nroot nodes are of the same kind. Thus, a correct version would take ^This.Expr instead of This to enable \ncomparison be\u00adtween trees with arbitrary kinds of roots. However, simply changing This to ^This.Expr \nwould not work e.op1 is disallowed this time. To make it work, we have to simulate multi-dispatching \nbased on both receiver and argument types (a similar style of programming for Scala is shown by Zenger \nand Oder\u00adsky [34]). A solution to this problem with variant path types is shown in Figure 4. Each class \nis equipped with auxiliary methods eqLit() and eqPlus(), specialized to different kinds of AST nodes. \nIn class Expr these methods provide a default behavior to return false. Actual code of com\u00ad class AST \n{ class Expr{ \u00b7\u00b7\u00b7 // default implementations boolean equal(^This.Expr e){ return false;} boolean eqLit(^This.Lit \ne){ return false; } boolean eqPlus(^This.Plus e){ return false; } } class Lit extends Expr { int i; \n\u00b7\u00b7\u00b7 boolean equal(^This.Expr b) { return b.eqLit(this); }; boolean eqLit(^This.Lit e) { return e.i == \nthis.i; } } class Plus extends Expr { ^This.Expr op1, op2; \u00b7\u00b7\u00b7 boolean equal(^This.Expr b) { return \nb.eqPlus(this); }; boolean eqPlus(^This.Plus e) { return this.op1.equal(e.op1) &#38;&#38; this.op2.equal(e.op2); \n} } } Figure 4. Implementation of the method equal(). parison is coded in specialized versions, Lit.eqLit() \nand Plus.eqPlus(), where the argument has the same type as the class in which they are de.ned. If the \nargument and the class are different kinds, the answer should be false, inher\u00adited from Expr. Finally, \nand more interestingly, in equal() in Lit and Plus, the exact kind of the root of one of the nodes (namely \nthis) is revealed, so comparison is delegated to specialized versions by swapping the argument and the \nreceiver. Note that this of type This is passed to a method taking ^This.Lit or ^This.Plus; in general, \nit is safe to allow subtyping between This and ^This.C in nested class D that extends C. This implementation \ncorrectly typechecks and works as expected. Moreover, it is easy to add another kind of expressions (other \nthan Lit and Plus) by extending AST. 3.5 Parametric Methods for Group-Polymorphic Methods One of the \ncentral ideas in family polymorphism [12] is that it should be possible to develop functionalities that \ncan work uniformly over different families. Recasting it to our framework, it means that we should be \nable to write methods accepting as formal arguments instances of members of the same group, where different \ninvocations may be concerned about different groups. As an example, we consider the method connectAll() \nthat takes as input an array of edges and two nodes of any group (of graphs) and connects each edge to \nthe two nodes. We achieve it by adding parametric methods in the style of Java 5.0 to our language, but \nwith new features of exact type variables with quali.cation. More concretely, method connectAll() is \nwritten as follows: <exact G extends Graph> static void connectAll(G@Edge[] es, G@Node n1, G@Node n2) \n{ for (int i: es) { es[i].connect(n1,n2); } } Method connectAll() is de.ned as parametric in an exact \ntype variable G which represents the group used for each invocation with upper-bound Graph; and the arguments \nare of type G@Edge[], G@Node and G@Node, respectively. It can be invoked as follows: @Graph@Edge[] ges \n= \u00b7\u00b7\u00b7; @Graph@Node gn1 = \u00b7\u00b7\u00b7, gn2 = \u00b7\u00b7\u00b7; @CWGraph@Edge[] ces = \u00b7\u00b7\u00b7; @CWGraph@Node cn1 = \u00b7\u00b7\u00b7, cn2 = \u00b7\u00b7\u00b7; \n <@Graph>connectAll(ges, gn1, gn2); // OK <@CWGraph>connectAll(ces, cn1, cn2); // OK <@Graph>connectAll(ces, \ngn1, gn2); // compile-time error <Graph>connectAll(ces, gn1, gn2); // compile-time error In the .rst \ninvocation of the example code, instantiation of G with @Graph is speci.ed, hence edges and nodes of \nfamily Graph can be passed, and similarly in the second invocation for CWGraph. The third invocation \nis not well typed, as ces has type @CWGraph@Edge[], which does not belong to the group @Graph. (In other \nwords, it is not a subtype of @Graph@Edge[].) Finally, the last one is not well typed, either, since \nan inexact type Graph is passedtoan exact type variable. Notice that the introduction of exact type variables \nis crucial: connect() is allowed to be invoked in the method body exactly for the reason that G is an \nexact type and, if the fourth invocation were allowed, it would lead to unsoundness. Finally, as developed \nin our previous work [29], a type inference mechanism can also be designed by extending that in Java \n5.0, so that the instantiation of type variables can be automatically inferred it is left for future \nwork.  4. Formalizing Variant Path Types In this section, we formalize the ideas described in the previous \nsection as a small core calculus called FJ based on Featherweight Java [17]. What we model here includes \nnested classes with hierarchical composition, variant path types, and parametric methods only with exact \ntype vari\u00adables, as well as the usual features of FJ, that is, .elds, ob\u00adject instantiation, and recursion \nby this.In FJ, a nested class can extend either Object, which is an empty class, or another class in \nthe same group, though some other lan\u00adguages [20, 25] allow a more liberal style of inheritance. We drop \ntypecasts since one of our points is to show scalable ex\u00adtensibility is possible without resorting to \ntypecasts, which are used to get around restrictions imposed by a naive type system. We assume every \ntype variable to be exact for sim\u00adplicity and hence drop the exact keyword; non-exact type variables \nwould be easy to add. 4.1 Syntax The abstract syntax of types, class declarations, method dec\u00adlarations, \nand expressions is given in below. Here, nis a nat\u00adural number (0 or positive integers); the metavariables \nC and D range over (simple) class names; X and Y range over (ex\u00adact) type variables; S, T, U,and V range \nover types; f and g range over .eld names; m ranges over method names; and x ranges over variables. A \n::= / |A@C run-time types E ::= / |Xn |E@C exact types T ::= / |Xn |T@C |T.C types L ::= class C . C{ \nT f; L M} classes M ::= <X.T>T m(T x){return e;} methods e ::= x |e.f |e.<E>m(e) |new A(e) expressions \nFollowing the custom of FJ, we put an over-line for a possibly empty sequence. Furthermore, we ab\u00adbreviate \npairs of sequences in a similar way, writ\u00ading T f; for T1 f1;... ;Tn fn; , where n is the length of T \nand f,and this.f=f; as shorthand for this.f1=f1;... ;this.fn=fn; and so on. Sequences of .eld declarations, \nparameter names, method de.nitions, nested class de.nitions are assumed to contain no duplicate names. \nSo, we sometimes view a sequence as a mapping: for example, L(C) denotes a class Li of name C and similarly \nfor M. We write the empty sequence as , denote the length of a sequence using |\u00b7|and concatenation of \nsequences using a comma. Unlike the previous section, we make the top level explicit as / in the formal \nsyntax but we often abbreviate /@C to @C and /.C to C. Run-time types, which represent classes from which \nob\u00adjects are instantiated, are also called absolute path types, whereas types starting with Xn, which \ncorresponds to ^ \u00b7\u00b7\u00b7^X (with ^ n times) in the previous section, are called relative path types. X0 is \nabbreviated to X by omitting the super\u00adscript. Here, we extend the pre.xing operation from This to all \ntype variables. Also note that for notational convenience we use absolute path types such as @C@D, instead \nof the common notation C.D used in the last section, for new ex\u00adpressions and names of classes. A quali.cation \nof the form @C is called exact whereas .C is called inexact. In particular, a type without any inexact \nquali.cation is called an exact type, ranged over by E as shown above. As in FJ, Object is a special \nclass name, whose de.nition does not appear in the class table. Moreover, in FJ, qual\u00adi.cations @Object \nand .Object are allowed everywhere even though @A@Object is not de.ned in the class table. Al\u00adlowing \nsuch quali.cations makes the de.nitions of lookup functions simple: @A@Object is simply assumed to have \nno members. We include / (read top-level ) without any qual\u00adi.cation also mostly for technical convenience \nand, as seen in rules for well-formed types and typing, / by itself cannot appear in any program texts. \nA class declaration consists of its name, the simple name of its superclass, .eld declarations, methods, \nand nested classes. The symbol . is read extends. A method decla\u00adration can be parameterized by exact \ntype variables X.Since the language is functional, the body of a method is a single return statement. \nAn expression is either a variable, .eld access, method invocation, or object creation. We assume that \nthe set of (type) variables includes the special variable this (This, resp.), which cannot be used as \nthe name of a (type, resp.) parameter of a method. A class table CT is a .nite mapping from run-time \ntypes A to (top-level or nested) class declarations and is as\u00adsumed to satisfy the following sanity conditions \nto identify a class table with a set of top-level classes: (1) CT(A@C)= class C \u00b7\u00b7\u00b7 for every A@C . dom(CT);(2) \nif CT(A@C) has a nested class declaration L of name D,then CT(A@C@D)= L;and (3) A@Object . dom(CT) for \nany A . dom(CT).A program is a pair (CT,e) of a class table and an expression. To lighten the notation \nin what follows, we always assume a .xed class table CT. 4.2 Hierarchical Composition and Lookup Functions \nAs discussed in Section 2, a complete de.nition of a nested class is obtained by propagating composition \nof enclos\u00ading classes in a top-down manner. We de.ne a function classes(A) to list up nested classes \ninside A after hierarchical composition of A. It requires the following auxiliary operator L1.L2 to compose \na superclass L1 with a subclass L2: class C . D{T f; L1 M1} .class C . D{Ug; L2 M2} = class C . D{T f; \nU g; (L1.L2)(M1.M2)} Here, L1.L2 denotes the set union of classes from L1 and L2 where classes of the \nsame name are recursively composed by .. Similarly, M1.M2 denotes the set union of methods from M1 and \nM2 where methods in M2 have priorities over the method of thesamenamein M1,since M2 are overriding def\u00adinitions. \nTheir straightforward de.nitions are omitted here for brevity. In the de.nition of L1.L2,the extends \nclauses have to match in order to preserve inheritance structure of nested classes. Actually, we de.ne \na more general function classes(A,i) instead of classes(A), which is considered classes(A,n) where n \nis the length of A (that is, the number of sim\u00adple class names in A). The auxiliary argument i,which \nis a natural number, controls how deep hierarchical compo\u00adsition is performed to list up nested classes: \nfor example, classes(@C@D,0) lists up only the nested classes that appears in CT(@C@D) without taking \ninheritance into account at all; classes(@C@D,1) will compose the top-level class C with its superclasses \nand returns nested classes appearing exactly in D. In most cases, we use the specialized version classes(A); \nthe signi.cance of the auxiliary argument will be clari.ed in typing of classes. The de.nition of classes(A,i) \nappears at the top of Fig\u00adure 5. The .rst rule says that A@Object has no nested classes and the second \nthat / is the top-level. The third rule, which deals with full composition, means that nested classes \nin A@C are obtained by composing nested classes in C in classes(A,i) with those in its superclass A@D. \nNote that L are also the result of composition till the depth of the enclosing class A. The fourth rule, \non the other hand, means that, when i is less than the length of A@C, nested classes in A@D are ignored. \nFor example, consider the following FJ classes: class AST extends Object { class Expr extends Object \n{ T m() { return e_1; } } class Lit extends Expr { } class Plus extends Expr { T m() { return e_3; } \n} } class ASTE extends AST { class Expr extends Object { } class Lit extends Expr { T m() { return e_5; \n} } class Plus extends Expr { T m() { return e_6; } } } Then, classes(/@ASTE,1) returns nested classes \nExpr, Lit, Plus obtained by composing ones inside ASTE and its su\u00adperclass AST, i.e., class Expr extends \nObject { T m() { return e_1; } } class Lit extends Expr { T m() { return e_5; } } class Plus extends \nExpr { T m() { return e_6; } } Here, method m in class @AST@Plus has disappeared as it is overridden \nby one in class @ASTE@Plus, which implicitly extends @AST@Plus. At this point, we can check that there \nare no cycles in the inheritance relation at all levels. First, cycles at the top level can be easily \ndetected; if there is no cycle, then classes(@C) is de.ned for any @C . dom(CT). Second, the absence \nof cy\u00adcles in classes(@C) can be checked for each C, ensuring well\u00adde.nedness of classes(@C@D) for any \nD . dom(classes(@C)). We can repeat this procedure until the maximum level of nesting is reached. One \nmay wonder if cycles can be detected earlier when a class table is given or later as part of typechecking. \nFirst of all, cycles can be detected only when hierarchical com\u00adposition is taken into account: for example, \nclass C2 in the classes below class C1 { class D1 extends D2 {} } class C2 extends C1 { class D2 extends \nD1 {} } contains a cycle of nested classes D1 and D2 but it cannot be detected unless C1 and C2 are composed. \nOf course, C1 is already an ill-formed class since D2, speci.ed as the su\u00adperclass of D1, is missing. \nHowever, cycles should be de\u00adtected before typechecking the process in which we .nd C1 is ill formed \nbecause typechecking uses lookup func\u00adtions, which works only when there are no cycles. Thus, cy\u00adcles \nshould be detected now. In what follows, we assume there are no cycles in the given class table. Thanks \nto classes(A,i), it is now easy to de.ne functions to look up .elds and methods from a given class name. \nThe de.nitions of .eld/method lookup functions are also in Fig\u00adure 5. Function .elds(A,i), which is similar \nto classes(A,i), enumerates all .eld names of A (and its superclasses) with their types. Similarly, mtype(m,A,i) \nreturns the signature of method m in A. Now, it is fairly easy to read off how class bodies are lin\u00adearized, \ni.e., in what order members are looked up: for exam\u00adple, methods of an instance of @ASTE@Lit will be \nsearched in @ASTE@Lit, @AST@Lit, @ASTE@Expr,and @AST@Expr in this order.  4.3 Type System The main judgments \nof the type system consist of one for type equivalence . f S = T, one for matching . f E1 <# E2, one \nfor subtyping . f S<: T, one for type well\u00adformedness . f T ok, and one for typing .; G f e : T. Here, \n., called bound environment, is a .nite mapping writ\u00ad rations of type variables with their respective \nupper bounds. Similarly, G, called type environment, is a .nite mapping of method parameters with their \nrespective types. As seen later, . usually contains This<:T,inwhich T represents the class where the \njudgment is made. Following the custom of FJ [17], we abbreviate a se\u00adquence of judgments in the obvious \nway: . f S1 <: T1, ..., . f Sn <: Tn to . f S<: T (similarly for type equivalence and matching); . f \nT1 ok, ..., . f Tn ok to . f T ok; and .; G f e1:T1,..., .; G f en:Tn to .; G f e:T. 4.3.1 Auxiliary \nDe.nitions We .rst de.ne a few auxiliary operations used in typing rules. Tn denotes a type obtained \nby dropping the last n    classes(A,i) (L are all top-level classes) classes(A@Object,i)= classes(/,i)=L \ni=|A@C| classC D{ \u00b7\u00b7\u00b7L \u00b7\u00b7\u00b7} .classes(A,i) classes(A@D,i)=L/ classes(A@C,i)=L/.L i<|A@C| classC D{ \u00b7\u00b7\u00b7L \n\u00b7\u00b7\u00b7} .classes(A,i) classes(A@C,i)=L .elds(A,i) .elds(A@Object,i)= classC D{Tf; \u00b7\u00b7\u00b7} .classes(A,i) .elds(A@D,i)=Ug \n.elds(A@C,i)=Ug,Tf mtype(m,A,i) i<|A@C| classC D{ \u00b7\u00b7\u00b7M} .classes(A,i) <X U>S0 m(S x){ \u00b7\u00b7\u00b7 } .M mtype(m,A@C,i)=<X \nU>S.S0 n=|A@C| classC D{ \u00b7\u00b7\u00b7M} .classes(A,i) m .M mtype(m,A@D,i)=<X U>S.S0 mtype(m,A@C,i)=<X U>S.S0 \nFigure 5. FJ: Lookup Functions quali.cations from T; it is de.ned by: Objectn = Object T0 = T m Xn+m \n (Xn)= n Tn-1 (T@C)= (n>0) n Tn-1 (T.C)= (T.C =Object,n>0) n Note that (\u00b7)is an operation on types \nwhereas Xn is just a syntactic entity. By using the pre.xing operation, (simultaneous) type substitution \n[T/X]of types for type variables is de.ned as follows: [T/X]/ = / [T/X]Xni = Tni [T/X]Yn = Yn (if Y .X) \n[T/X](S@C)=([T/X]S)@C [T/X](S.C)=([T/X]S).C Note that Xn is replaced with the corresponding pre.x of \nT. [T/X]e is de.ned straightforwardly. An exact type substitution [T/@X], which requires an exact type \nwhen Xn is replaced, is similarly de.ned below: [T/@X]/ = / nn [T/@X]Xi = Ti (if Tn is exact) [T/@X]Yn \n= Yn (if Y .X) [T/@X](S@C)= ([T/@X]S)@C [T/@X](S.C)= ([T/@X]S).C Notice that the argument T may contain \ninexact quali.ca\u00adtions: for example, [@C.D1/@X]X^1@D2 = @C@D2 (whereas [C.D1/@X]X^1@D2 is unde.ned). \nexact(T)(inexact(T), resp.) denotes a type in which all inexact (exact, resp.) quali.cations in T are \nreplaced by exact (inexact, resp.) ones. They are de.ned by: exact(/)= inexact(/)= / exact(Xn)= inexact(Xn)= \nXn exact(T@C)= exact(T.C)= exact(T)@C inexact(T@C)= inexact(T.C)= inexact(T).C  4.3.2 Type Equivalence \nThe judgment .f S = T can be read type S is equivalent to T under .. The rules are shown in Figure 6. \nThe .rst three rules say that it is indeed an equivalence relation, and the last two that it is a congruence. \nThe key rule is the fourth rule, which says that if the upperbound of a type variable is exact, then \nthe two types are in fact equivalent. The .fth rule means that if Xn is equivalent to an exact type E@C, \nthen its enclosing class Xn+1 is to E and hence Xn and Xn+1@C are equivalent: for example, X<: @Graph@Node \nf X = X1@Node can be derived. 4.3.3 Matching The subtyping relation will be de.ned by using the inher\u00aditance \nrelation, which is formalized as matching here. The judgment .f E1 <# E2 can be read exact type E1 matches \nE2 or simply E1 extends E2. The rules are shown in Fig\u00adure 6. The matching relation is a partial order \nincluding type equivalence and @Object as the top element, as seen in the .rst three rules. The fourth \nrule means that, if X is assumed to be a subtype of T, then it must extend exact(T)whatever it is instantiated \nwith. The .fth rule is similar to the .fth rule for type equivalence: for example, the matching judgment \nThis <: Graph.Node f This <# This1@Node can be derived by this rule. The last rule deals with extends \nclauses. 4.3.4 Subtyping The judgment form for subtyping . f S<:T can be read S is subtype of T under \n.. Subtyping rules are shown in Figure 6. As usual, subtyping is re.exive and transitive with Object \nas the top type and a type variable (with some pre.xing) is a subtype of (the corresponding pre.x of) \nits declared upper bound. The sixth rule intuitively means that exactness can be forgotten. The third \nlast rule might look counterintuitive since exact quali.cation works covariantly. Note that, however, \nif T is not exact, the resulting type T@C is not exact, either. For example, @ASTeval@Plus is a subtype \nof AST@Plus, which includes Plus from both AST and ASTeval. The last rule roughly means that inexact \ntypes are related if one inherits the other it is parallel to the last rule of matching. 4.3.5 Type \nWell-formedness The judgment form for well formed types is .f T ok, read as T is well formed under .. \nThe type well-formedness rules are also in Figure 6. A type is well formed when the class that the type \npoints to in A exists. Even when the class of a given name is not in the domain of the class table, it \nmay implicitly exist, due to nested inheritance, hence the function classes is used in the last two rules. \nNote that A@Object or A.Object is always well formed if A is well formed.  4.3.6 Typing Typing for expressions. \nThe typing judgment form G f e : T is read expression e is given type T under G. The typing rules are \nshown in Figure 7; readers who are familiar with languages with matching [2], in particular LOOJ [4], \nwill notice some similarities. The key rules are T-FIELD for .eld access and T-INVK for method invocation. \nThe rule T-FIELD means that the type of .eld access e0.fi is obtained by looking up .eld declara\u00adtions \nfrom the class that matches the receiver type. Note that, if fi s type is declared to be relative, then \nThisi will be re\u00adplaced with the corresponding pre.x of the receiver type: for example, if .elds(@CWGraph@Node)= \nThis1@Edge edg and G=x :@CWGraph@Node, y :This1@Node,then This<:CWGraph.Node;Gf x.edg :@CWGraph@Edge \nThis<:CWGraph.Node;Gf y.edg :This1@Edge. In this way, accessing a .eld of relative path type gives a \nrelative path type only when the receiver is also given a relative path type. In T-INVK, the .rst line \nmeans that the type of the re\u00adceiver T0 matches (i.e., inherits) a class A that has method m with the \nsignature <X U>T.S0. The second and third lines roughly mean that the actual type arguments must be sub\u00adtypes \nof the corresponding upperbounds U and the types of the actual value arguments must be subtypes of the \ncorre\u00adsponding formal; the substitution is applied since Ui may in\u00adclude Xi, ..., Xi-1 and T may include \nX. As discussed in the last section, binary methods can be invoked only when the receiver type is exact \nand, in general, pre.xed This must be exact5. For example, assume mtype(@Graph@Edge, connect) =(This1@Node, \nThis1@Node). void . Then \u00b7;x :@Graph@Edge, y :@Graph@Node f x.connect(y,y) :void should be derived but \nnot \u00b7;x :Graph.Edge, y :@Graph@Node f x.connect(y,y) :void . In order to express this condition, we use \nexact type substi\u00adtution [T/@X]de.ned before. In this example, [Graph.Edge/@This]This1@Node is not well \nde.ned, making the second judgment above not derivable. Note that, even if the receiver type T0 contains \ninexact quali.cation, [T0/@This]may succeed as in [@Graph.Edge/@This1@Node]This1@Node =@Graph@Node. So, \n\u00b7;x :@Graph.Edge, y :@Graph@Node f x.connect(y,y) :void is derivable. 5 This requirement is essentially \nthe same as exactness preservation [26].  .fS =T .fT =T .fS =T .fT =S .fS =T .fT =U .fS =U X<:T .. \nTn is exact .fXn =Tn X<:T .. Tn =S@C .fXn =Xn+1@C .fS =T .fS@C =T@C .fS =T .fS.C =T.C .fE1 <# E2 .fE1 \n=E2 .fE1 <# E2 .fE2 <# E3 .fE <# @Object .fE1 <# E2 .fE1 <# E3 X<:T .. X<:U .. exact(Un)=E@C .fXn <# \nexact(Tn).fXn <# Xn+1@C .fE1 <# E2 .fE<#A class C D{ \u00b7\u00b7\u00b7} .classes(A) .fE1@C <# E2@C .fE@C <# E@D .fS<:T \n.fS =T .fS<: T .fT<:U .fT<: Object.fS<:T .fS<:U X<:T .. X<:T .. Tn =S.C .fXn <: Tn .fXn <: Xn+1.C .fS<:T \n.fS<: T.fT@C <: T.C .fS@C <: T@C .fS.C <: T.C .fexact(T)<#A classC D{ \u00b7\u00b7\u00b7} .classes(A) .fT.C <: T.D .fT \nok X<:T ...fTn ok .f@Object ok .fObject ok .fXn ok classC D{ \u00b7\u00b7\u00b7} .classes(/) classC D{ \u00b7\u00b7\u00b7} .classes(/) \n.f@C ok .fC ok .fT ok .fexact(T)<# A (classC D{ \u00b7\u00b7\u00b7} .classes(A)or C =Object) .fT@C ok .fT ok .fexact(T)<# \nA (classC D{ \u00b7\u00b7\u00b7} .classes(A)or C =Object) .fT.C ok Figure 6. FJ: Rules for type equivalence, matching, \nsubtyping, and type well-formedness Typing for methods. The judgment for well-formed meth\u00ad signatures \nof overriding methods must be identical (modulo ods is of the form f M ok in A, read method M is ok in \nrenaming of type parameters) with the overridden, but, un- A. The rule T-METHOD checks whether the method \nbody like FJ, this condition will be checked by T-CLASS. is well typed, provided that this is of type \nThis and that formal type and value parameters are given declared upper Typing for classes. The judgment \nfor classes is of the form bounds and declared types, respectively. This is bounded by f L ok in A, read \nclass L is ok in A. The rule T-CLASS inexact(A),where A is the class name in which the method is means \nthat a class is well formed if (1) its superclass, .eld declared, since the method, which may be inherited \nto sub\u00ad types, nested classes, and methods are all well formed; and classes of A, has to work for any \nsubclass of A. Like FJ, the (2) methods are correctly overriding. The second line means .; G fe : T \nfM ok in A .; G fx :G(x) (T-VAR) .; G fe0 : T0 . fexact(T0) <# A .elds(A)= T f .; G fe0.fi :[T0/This]Ti \n(T-FIELD) .; G fe0 : T0 . fexact(T0) <# A mtype(m,A)= <X U>T.S0 . fE ok . fE<: [E/X][T0/@This]U .; G \nfe : S . fS<: [E/X][T0/@This]T .; G fe0.<E>m(e) :[E/X,T0/This]S0 (T-INVK) . fA0 ok .elds(A0)= T f .; \nG fe : S .; G fnew A0(e) : A0 . fS <: ([A0/This]T) (T-NEW) .i.1..|U|.(This<:inexact(A),X1<:U1,...,Xi-1<:Ui-1 \nfUi ok) .= This<:inexact(A),X<:U . fT0,T ok .; this : This,x : T fe : S0 . fS0 <: T0 f<X U>T0 m(T x){ \nreturn e; } ok in A (T-METHOD) fL ok in A This<:C1. \u00b7\u00b7\u00b7.Cn-1 fT ok fL ok in @C1@ \u00b7\u00b7\u00b7@Cn fM ok in @C1@ \n\u00b7\u00b7\u00b7@Cn fclass D D/{} ok in @C1@ \u00b7\u00b7\u00b7@Cn for any D such that class D D/{ \u00b7\u00b7\u00b7} .classes(@C1@ \u00b7\u00b7\u00b7@Cn) and \nD .dom(L), . . . . . . for any m, i.{1,...,|A@C|}, if mtype(m,@C1@ \u00b7\u00b7\u00b7@Cn,i-1) = <Y U>S.S0 and class \nCi Ci/{..} .classes(@C1@ \u00b7\u00b7\u00b7@Ci-1,i-1) and mtype(m,@C1@ \u00b7\u00b7\u00b7@C/i@ \u00b7\u00b7\u00b7@Cn,i)= <Y U/>S/.S0/, then U/,S0/,S/ \n= U,S0,S . . . . . . fclass Cn Cn/ { T f; L M} ok in @C1@ \u00b7\u00b7\u00b7@Cn-1 (T-CLASS) Figure 7. FJ: Typing Rules \nthat a nested class D implicitly inherited inside Cn is equiv\u00adalent to an explicit class with the empty \nbody and it must be well-formed, too. This condition ensures the signatures of methods inherited from \nall superclasses of @C1 \u00b7\u00b7\u00b7@Cn@D are identical. The last big condition ensures correct method overriding, \nwhich is more involved to check than it may .rst appear, because one class may inherit de.nitions from \nmultiple su\u00adperclasses. For concreteness, consider a class @C1@C2@C3 to see what this condition means. \nWhen i=1,it says if mtype(m,@C1@C2@C3,0) = <Y U>S.S0 and class C1 C1/{..} . classes(/,0) and mtype(m,@C1/@C2@C3,1) \n= <Y U/>S/.S0/,then U/,S0/,S/ = U,S0,S. It means that the signature of a method de.ned exactly in @C1@C2@C3 \nis the same as the one inherited from @C1/@C2@C3 (or @C1//@C2@C3, and so on). So, it amounts to checking \nconsistency of the signatures of the methods in the class @C1@C2@C3 against those de.ned (if any) in \nthe lowest class in the chain of classes @C/1@C2@C3 <# @C//1@C2@C3 <# \u00b7\u00b7\u00b7 (where @C1 <# @C1/ <# @C1//). \nWhen i =2, the condition implies the consistency of the signatures of the methods in the classes that \nappear in the previous step @C1@C2@C3 <# @C/1@C2@C3 <# @C//1@C2@C3 <# \u00b7\u00b7\u00b7 against those in the plane \nof classes THEOREM 1 (Subject Reduction). If \u00d8; \u00d8fe : T and e -. e/,then \u00d8; \u00d8fe/ : T/,for some T/ such \nthat \u00d8fT/ <: T. . . . . . . <# <# @C1@C//2@C3 <# @C/1@C//2@C3 <# \u00b7\u00b7\u00b7 THEOREM 2 (Progress). If \u00d8; \u00d8fe \n: A and e is not a value, / then e -.e/,for some e. <# <# @C1@C/2@C3 <# @C/1@C/2@C3 <# \u00b7\u00b7\u00b7 THEOREM 3 \n(Type Soundness). If \u00d8; \u00d8f e : T and e -. e/ with e/ being a normal form, then e/ is a value v such that \n\u00d8; \u00d8fv : A,for some A such that \u00d8fA<: T. (where @C2 <# @C2/ <# @C2//). Note that, in this step, meth\u00adods \ninherited from different directions, that is, @C/1@C2@C3 and @C1@C/2@C3 are checked against each other, \neven if @C1@C2@C3 does not have a method m. Finally, when i =3, the merged plane, obtained by combining \nthe chain and the plane above, is checked against the three dimension space, which covers @C1@C2@C3 s \nall superclasses, which have not been covered in the previous steps. Finally, a program (CT,e) is well \nformed if all (top-level) classes in CT are well formed and \u00d8; \u00d8fe : T for some T.  4.4 Operational \nSemantics The operational semantics is given by the reduction relation of the form e -. e/, read expression \ne reduces to e/ in one step. We require another lookup function mbody(m,A), of which we omitted the obvious \nde.nition, for the method body with formal (type) parameters, written <X>(x)e,of given method and class \nnames. The reduction rules are given below. We write [d/x,e/y]e0 for the expression obtained from e0 \nby replacing x1 with d1, ..., xn with dn,and y with e. There are two reduction rules, one for .eld access \nand one for method invocation, which are straightforward, thanks to lookup functions. The reduc\u00adtion \nrules may be applied at any point in an expression, so we also need the obvious congruence rules(if e \n-. e/ then e.f -.e/.f, and the like), omitted here. .elds(A)= Tf (R-FIELD) new A(e).fi -.ei mbody(m,A)= \n<X>(x)e0 (R-INVK) new A(e).<E>m(d) -. [d/x, new A(e)/this][E/X,A/This]e0 We write -.* for the re.exive \nand transitive closure of -.. 4.5 Type Soundness The type system is sound with respect to the operational \nse\u00admantics, as expected. Type soundness is proved in the stan\u00addard manner via subject reduction and progress \n[33, 17]. For brevity, we only sketch the proofs in Appendix; full proofs appear in an extended version \nof the paper, available at http://www.sato.kuis.kyoto-u.ac.jp/~igarashi/ papers/. The set of values, \nmentioned in Theorem 2, are de.ned by: v ::= new A(v),where v can be empty.  5. Related Work and Discussion \nNested Inheritance. The present work has emerged as an enhancement of language constructs for lightweight \nfamily polymorphism [29], with arbitrary levels of nesting, explicit inheritance between nested classes \nin the same group, and generalized relative path types with inexact quali.cation. The resulting language \ndesign is very close to Nystrom et al. s JX language [25], though without exploiting dependent types(/classes). \nJX supports an extension mechanism called nested inher\u00aditance that allows an inheritance hierarchy to \nbe nested in another class and such a hierarchy to be inherited and ex\u00adtended by extending the enclosing \nclass, just as our proposal. Indeed, it is very similar how class de.nitions are composed. Moreover, \nJX allows a class to extend another class outside the group. Key ideas in their type system are dependent \nclasses and pre.x types. Dependent classes are type expressions of the form p.class, which means p s \nrun-time class (here, p is a sequence of .nal .eld accesses on a .nal variable). Us\u00ading dependent classes, \na method equal() would take an argument of type this.class, which guarantees that the run-time classes \nof the receiver and the argument agree. The notion called pre.x types is usually used with depen\u00addent \nclasses to express an enclosing class of a dependent class. For example, Graph[n.class] means n.class \ns in\u00adnermost enclosing class, which is a subclass of Graph.By combining the fact that inheritance is \nconsidered subtyping, they are useful when two arguments have to share the same enclosing class as in \nconnect all() as in Section 3. For example, here is its variant make loop() written in JX. void make_loop(final \nGraph.Node n, Graph[n.class].Edge e) { n.src = n.dst = e; } JX s static type system guarantees that \nthe actual argu\u00adment s run-time types share the same enclosing class, which must be a subclass of Graph. \nSince inheritance is subtyp\u00ading, CWGaph.Node is a subtype of Graph.Node and so make loop() can be invoked \nwith CWGraph.Node and CWGraph.Edge. Since types now refer to expressions, the interaction with side-effects \nmust be taken into account; JX poses the restriction that .class can be preceded only by a sequence of \nzero or more accesses of .nal .elds to .nal variables (including this) to avoid the meaning of the same \ndependent class expression to change at different program points. That s why n is (and must be) quali.ed \nwith final. On the other hand, our language design is completely or\u00adthogonal to assignments, which are \ntherefore not considered in FJ calculus we expect they can be easily and safely added with the usual \ntyping rule. Instead of dependent classes, we use type variables and This to achieve the separation of \ntypes and expressions for ease of typechecking. In particular, we observe that value arguments of JX \nalso play the role of type arguments. It will be more apparent by comparing with the de.nition of make \nloop() in our language: <exact X extends Graph.Node> void make_loop(X n, ^X@Edge e) { \u00b7\u00b7\u00b7} Notice that \nX plays the role of n.class in the JX code. Following how connect all() is written is Section 3, it can \nalso be written <exact X extends Graph> void make_loop(X@Node n, X@Edge e) { \u00b7\u00b7\u00b7} We believe that separating \ntype variables gives more intu\u00aditive method signatures, especially when parametric types are involved; \nfor example, if connect all(),which takes arrays, is to be written in JX, the method de.nition seems \nto be something like: void connect_all(final Graph g, g.class.Edge[] es, g.class.Node[] ns) { \u00b7\u00b7\u00b7} or \nvoid connect_all(final Graph.Edge e, e.class[] es, Graph[e.class].Node[] ns) { \u00b7\u00b7\u00b7} which requires a \nvalue parameter g or e,which is not re\u00adquired by the method body. One consequence of this design of JX \nseems that, as op\u00adposed to the common understanding, subtyping does not quite imply substitutability, \nwhich we think is not very intu\u00aditive: if an expression in a program is replaced with another, which \nis of a subtype of the original, the program can be\u00adcome ill-typed. For example, suppose class C, which \nhas the subclass D, has method equal() that takes an argument of type this.class. Then, c.equal(c) would \nbe well typed under the assumption that c has type C.Since D is a subtype of C in JX, one might expect \nthat d of type D would be substi\u00adtutable for c and so d.equal(c) would be also well typed but, in fact, \nit is not. In our type system, subtyping implies substitutability thanks to the distinction between exact \nand inexact quali.cations: c.equal(c) is allowed only when c is given an exact type @C and it can be \nreplaced only by an\u00adother expression of the same exact type. More recently, Nystrom, Qi, and Myers [26] \nhave ex\u00adtended JX to support the mechanism called nested intersec\u00adtion, which is similar to symmetric \nmixin composition in Scala [28, 27]. It would be interesting future work to add nested intersection to \nFJ. Matching. A series of work [2, 7, 6, 4] by Bruce and his colleagues has been addressing statically \nsafe type systems for languages with the notion of MyType (corresponding to This in this paper). As we \nhave also discussed, even if one class extends another, the object type from the former is not always \na subtype of that from the latter due to binary methods methods whose argument types include MyType. \nInstead of subtyping, they introduce the matching relation on object types, which re.ects the class hierarchy \nand plays an important role in typechecking binary methods. In the language called LOOM [6], the notion \nof hash types of the form #T is introduced; #T behaves as a common super\u00adtype6 of all types that match \nT but binary methods cannot be invoked on it. Our inexact quali.cation can be consid\u00adered a generalization \nof hash types in the context of nested classes. It may be worth noting that in some other languages of \ntheirs [5, 3, 4], hash types are default (requiring no spe\u00adcial symbols such as #) and objects types \non which binary methods can be invoked are called exact types and written @T. Also, they have introduced \nmatch-bounded polymorphic methods [7] to describe generic methods that work on differ\u00adent types that \nmatch the same interface. Polymorphic meth\u00adods in this paper can be viewed as match-bounded polymor\u00adphic \nmethods in disguise, since if an exact type E is a sub\u00adtype of T,then E matches exact(T). Our choice \nis mainly for the sake of familiarity and uniformity with usual subtype\u00adbounded polymorphic methods. \nLater, the notion of MyType is extended from self-recursive object types to mutually recursive object \ntypes, resulting in the notion of MyGroup [5, 8, 3]. Here, mutually recursive classes are put in a group, \nwhich is extensible just as classes, and MyGroup, which changes its meaning along group ex\u00adtension, is \nused to express mutual references among classes. In this paper, groups and classes are uni.ed into a \nsingle mechanism of classes, which can be arbitrarily nested. Ac\u00adcordingly, MyType and MyGroup are uni.ed \ninto a relative path type Thisn . Concord [20] is another language that also has the notion of groups \nand MyGroup. A main difference from the present work is that Concord does not support nesting of groups \nbut allows a class in a group to extend an absolute type, a class outside the enclosing group. It would \nbe interesting future work to extend our language to allow a class to extend non\u00adsiblings. Virtual Classes. \nHistorically, virtual classes [21] (more precisely, virtual patterns) in Beta [22] have been very in.u\u00adential \nto much work on the design of languages that support scalable extensibility by using nesting structure \nof classes. The basic idea of virtual classes is to allow classes to be attributes of objects just as \nmethods, by putting nested class 6 Subtyping is not explicitly mentioned in their paper but there are \ntyping rules to convert from one (exact) type to its hash version and from a hash type to another hash \ntype which is matched by the former. de.nitions in another class and those nested classes to be inherited \nand further extended in a subclass. Although the original proposal was not statically type-safe, virtual \nclasses are useful to describe not only generic data structures but also mutually recursive classes such \nas nodes and edges of graphs and their extensions. Ernst, who coined the term family polymorphism, im\u00adproved \nBeta s static analysis in the development of the lan\u00adguage gbeta to ensure the safety of the use of virtual \nclasses as extensible mutually recursive classes [12] and also higher\u00adorder hierarchies [13], which refer \nto a mechanism that al\u00adlows extensible class hierarchies just as in the example of AST in this paper. \nNested classes in gbeta are designed to be members (or attributes) of an object of their enclosing class \nas in Beta. So, in order to instantiate a nested class, an enclosing class has to be instantiated .rst \nand then a constructor of the nested class is invoked on the enclosing instance (that is, the in\u00adstance \nof the enclosing class) as in inner classes of Java [16]. Unlike Java, however, objects from the same \nnested class with different enclosing instances are distinguished by the static analysis, making it possible \nto create many copies of the same group and prevent objects from different copies from being mixed. For \nexample, one can implement hash tables by a class that has a virtual class implementing ele\u00adments; then, \nelements from different instances of hash tables will not be mixed. Scala [27, 28] and CaesarJ [23] adopt \na similar mechanism of virtual classes. From the type system point of view, such a mechanism can be considered \nlike de\u00adpendent types [1]. In fact, a type is a path of (immutable) .eld accesses followed by a class \nname in the virtual class calculus [14], which models gbeta-style virtual classes de\u00adscribed above. On \nthe one hand, these languages are more powerful than ours in the following points. First, as mentioned \nabove, groups are .ner grained and their number is unbounded since they are expressed by objects. Second, \nthey can better deal with the situation where the identity of a group is abstracted out. For example, \nconsider hash tables that are put into a data structure such as a list. Then, information on which hash \ntables are held by the list is lost in general. Nevertheless, it is still possible to extract an element \nfrom a hash table and put it back to the same hash table without exactly knowing a type of an element. \nIn some sense, the type systems of these languages are equipped with some kind of existential types. \nOn the other hand, in our language, once exact type information is lost, there is no way of recovering \nit. For example, it is not possible to invoke replaceOp1() on inexact AST.Plus. We expect this limitation \ncan be lifted by introducing a mechanism similar to the unpacking operation in the context of existential \ntypes [24] or by a mechanism similar to wildcard capture [32]. On the other hand, our typing mechanism \nseems to have the advantage that it is easy to express, say, all sorts of expressions by inexact quali.cations. \nSince there is only a single kind of quali.cation for those path dependent types, it does not seem very \neasy to express such a type. More recently, Clarke et al. have proposed another virtual class calculus \ncalled Tribe [9], in which nested classes are members of an object of their enclosing class, too. Tribe \ngeneralizes types for existing languages of virtual classes by allowing both .nal .eld access .f and \nclass access .C, which can appear in any order. For example, an expression this.f (where f is a .nal \n.eld) is also a singleton type, which denotes the value of this.f; this.C means some object of the class \nC nested in this; C.f refers to the object in .eld f of some object of C (or one of its subclasses); \nand C.D refers to some object of the class D nested in some object of C (or one of its subclasses). Tribe \ntypes provide .ne control over subtyping in a way similar to, but different from ours. While their quali.ca\u00adtion \n.C roughly corresponds to our inexact quali.cation, the quali.cation .f can be considered very exact \nquali.cation in the sense that it always denotes a single object, rather than objects of a single class \nas our exact quali.cation denotes. We believe that these languages, in which nested classes are treated \nas members of objects, should bene.t from our exact quali.cation, which provides an intermediate degree \nof exactness between very exact quali.cation by .nal .eld accesses and ordinary inexact quali.cations. \nFor example, exact types are useful to express standard binary methods such as equality, which as far \nas we understand does not seem very straightforward to express with Tribe types only. 6. Concluding \nRemarks We have proposed variant path types to support safe scal\u00adable extensibility. Relative path types, \na natural extension of MyType by Bruce et al. in the context of nested classes, en\u00adable to describe inter-relationship \namong classes in the same group, preserved by extension of the enclosing class. Also, exact and inexact \nquali.cations give .exible abstractions for various kinds of set of instances with a rich subtyping hier\u00adarchy. \nThe type system has been formalized as an extension of Featherweight Java, and proved to be sound. Main \nfuture work of this research concerns evaluating the applicability to a full-blown language such as Java. \nFor ex\u00adample, it is interesting to investigate type inference for para\u00admetric methods, which we have \nalready done to some degree in previous work [29]. Moreover, it would be useful to study alternative \nsyntactic sugar for variant path types, to support common programming patterns as in [25]. Implementation \nissues are also left for future work but we believe that the techniques described in Nystrom et al. [25] \ncan be applied to our proposal, as the semantics of inheritance of our language is similar (in fact, \nsimpler). Acknowledgments We thank Vincent Siles for .nding bugs in proofs and help\u00ading us prove a .xed \nlemma and anonymous reviewers for useful comments. The .rst author would like to thank mem\u00adbers of the \nKumiki project for fruitful discussions on this subject. This work was supported in part by Grant-in-Aid \nfor Scienti.c Research No. 18200001 and Graint-in-Aid for Young Scientists (B) No. 18700026 from MEXT \nof Japan (Igarashi), and from the Italian PRIN 2006 Project EOS DUE Extensible Object Systems: Dynamic \nand Unpre\u00addictable Environments (Viroli).  A. Proof Sketches We sketch the proofs of Theorems 1 and \n2. (Theorem 3 is their easy consequence.) The structure of the proof of sub\u00adject reduction is similar \nto those for Featherweight Java and Featherweight GJ [17]. So, we .rst prove various substi\u00adtution lemmas, \nwhich are all proved by induction on the derivations, including the following four: LEMMA 1 (Type Substitution \nPreserves Subtyping). If X<:U, . f S<: T and \u00d8f U ok and \u00d8f A<: U,then [A/X]. f[A/X]S<: [A/X]T. LEMMA \n2 (Type Substitution Preserves Type Well-formedness). If X<:U, . f T ok and \u00d8f A, U ok and \u00d8f A<: U,then \n[A/X]. f[A/X]T ok. LEMMA 3 (Type Substitution Preserves Typing). If X<:U, .; G f e : T and \u00d8f U ok and \n\u00d8f A<: U, then there exists T/ such that [A/X].; [A/X]G f[A/X]e : T/ and [A/X]. fT/ <: [A/X]T. LEMMA \n4 (Substitution Preserves Typing). If .; G, x:T f e : T0 and .; G fd : S and . fS<: T, then there exists \nT0/ such that .; G f[d/x]e : T0/ and .; G fT0/ <: T0. In the proofs of the last two lemmas about typing, \nwe also use lemmas stating that type substitution is covariant, i.e., if . fS1 <: S2,then . f[S1/X]T<: \n[S2/X]T, and that exact type substitution is contravariant, i.e., If . fS1 <: S2 and [S2/@X]T is well \nde.ned, then . f[S2/@X]T<: [S1/@X]T. Then, we prove properties of lookup functions: a .eld or method \nof some class is also present in any of its subclasses and, if a method type lookup succeeds, then a \nmethod body lookup also succeeds and the body is well typed. LEMMA 5. If \u00d8f A<# A/ and Tf . .elds(A/),then \nTf ..elds(A). LEMMA 6. If \u00d8f A<# A/ and mtype(A/)= <X U>S.S0, then mtype(A)= <X U>S.S0. LEMMA 7. If mtype(m, \nA)= <X U>T.T0, then there exist x, e0, B and T0 such that mbody(m, A)= <X>(x)e0 and . f A<# B and This<:inexact(B), \nX<:U; this : This, x:T f e0 : S0 and This<:inexact(B), X<:U fS0 <: T0.           A.1 Proof \nof Theorem 1 By induction on the derivation of e -.e/ with case analysis on the last rule used. We show \nonly main cases. Case R-FIELD: e = new A(e).fi .elds(A)= Tf e/ = ei By T-FIELD,and T-NEW,we have \u00d8fA \nok \u00d8; \u00d8fe : S \u00d8fS<: [A/This]T \u00d8fA<#A/ Ufi ..elds(A/) T =[A/This]U By Lemma 5, Ufi ..elds(A) and U = Ti. \nThus, \u00d8; \u00d8fei : Si and \u00d8fSi <: T, .nishing the case. Case R-INVK: e = er.<E>m(d) er = new A(e) mbody(m, \nA)= <X>(x)e0 e/ =[d/x, er/this][E/X, A/This]e0 By T-INVK and T-NEW,wehave \u00d8fA ok \u00d8; \u00d8fnew A(e) : A \u00d8fA<#A/ \nmtype(m, A/)= <X U>T.S0 \u00d8fE ok \u00d8fE<: [E/X][A/@This]U \u00d8; \u00d8fe : S \u00d8fS<: [E/X][A/@This]T T =[E/X, A/This]S0 \n. By Lemma 6, mtype(A)= <X U>T.S0. Then, by Lemma 7, there exist B and U0 such that \u00d8fA<#B This<:inexact(B), \nX<:U; x:S, this:This fe0 : U0 This<:inexact(B), X<:U fU0 <: S0 . We can prove that \u00d8fA<#B implies \u00d8fA<: \ninexact(B). Then, by Lemma 3, there exists U0/ such that / \u00d8; x :[E/X][A/This]S, this : A f[E/X][A/This]e0 \n: U0\u00d8fU0/ <: [E/X][A/This]U0 . We also have \u00d8f[E/X][A/This]U0 <: [E/X][A/This]S0 by Lemma 1. Finally, \nby Lemma 4, there exists U0// such that // // <: U0/ \u00d8; \u00d8fe/ : U0\u00d8fU0. Finally, by S-TRANS, \u00d8fU0// <: \nT, .nishing the case. Case RC-INVK-RECV: e = e0.<E>m(e> / e0 -.e0e/ = e0/.<E>m(e) By T-INVK,we have \u00d8; \n\u00d8fe0 : T0 \u00d8fexact(T0) <# A0 mtype(m, A0)= <X U>T.S0 \u00d8fE ok \u00d8fE<: [E/X][T0/@This]U \u00d8; \u00d8fe : S \u00d8fS<: [E/X][T0/@This]T \nT =[E/X][T0/This]S0                               By the induction hypothesis, \nthere exists T0/ such that / \u00d8; \u00d8fe0/ : T0\u00d8fT0/ <: T0 . We have \u00d8f exact(T0/) <# A0.Since [T0/@This]U \nand [T0/@This]T are well de.ned, by contravariance of exact type substitution and Lemma 1, \u00d8f[E/X][T0/@This]U<: \n[E/X][T0//@This]U \u00d8f[E/X][T0/@This]T<: [E/X][T0//@This]T . By T-INVK, \u00d8; \u00d8fe0/.<E>m(e) :[E/X][T0//This]S0 \n. Finally, by covariance of type substitution, we have \u00d8f[E/X][T0//This]S0 <: [E/X][T0/This]S0 .nishing \nthe case. . A.2 Proof of Theorem 2 By induction on e. We show only main cases. Case: e = e0.fi / If \ne0 is not a value, by the induction hypothesis, e0 -.e0 / for some e0; then, use RC-FIELD. On the other \nhand, if e0 is a value, then, by T-FIELD,it must be of the form new A0(v) and Tfi ..elds(A0/) for some \nA0/ such that \u00d8fA0 <# A0/. By Lemma 5 and T-NEW, .elds(A0)= Tf .Tfi. Then, e0.fi -.vi. Case: e = e0.<E>m(e) \n/ If ei is not a value, by the induction hypothesis, ei -.ei / for some ei; then, use RC-INVK-RECV (if \ni =0)or RC-INVK-ARG (otherwise). On the other hand, if e0 is a value, then by T-INVK, it must be of the \nform new A0(v) and mtype(m, A0/)= <X U>S.S0 for some A0/ such that \u00d8; \u00d8f A0 <# A0/.By Lemma 6, mtype(m, \nA0)= <X U>S.S0 and, by Lemma 7, mbody(m, A0)= <X>(x)e/ where |x|= |e|. Thus, we have / e -.[e/x, new \nA0(v)/this][E/X, A0/This]e .nishing the case. .   References [1] David Aspinall and Martin Hofmann. \nDependent types. In Benjamin C. Pierce, editor, Advanced Topics in Types and Programming Languages, chapter \n2, pages 45 86. The MIT Press, 2005. [2] Kim B. Bruce. A paradigmatic object-oriented programming language: \nDesign, static typing and semantics. Journal of Functional Programming, 4(2):127 206, April 1994. Preliminary \nversion in POPL 1993, under the title Safe type checking in a statically typed object-oriented programming \nlanguage .                    [3] Kim B. Bruce. Some challenging typing issues in \nobject\u00adoriented languages. In Proceedings of Workshop on Object-Oriented Development (WOOD 03), volume \n82 of Electronic Notes in Theoretical Computer Science, 2003. [4] Kim B. Bruce and J. Nathan Foster. \nLOOJ: Weaving LOOM into Java. In Proceedings of European Conference on Object-Oriented Programming (ECOOP2004), \nvolume 3086 of Lecture Notes on Computer Science, Oslo, Norway, June 2004. Springer Verlag. [5] Kim B. \nBruce, Martin Odersky, and Philip Wadler. A statically safe alternative to virtual types. In Proceedings \nof 12th European Conference on Object-Oriented Programming (ECOOP 98), volume 1445 of Lecture Notes on \nComputer Science, pages 523 549, Brussels, Belgium, July 1998. Springer Verlag. [6] Kim B. Bruce, Leaf \nPetersen, and Adrian Fiech. Subtyping is not a good match for object-oriented languages. In Pro\u00adceedings \nof 11th European Conference on Object-Oriented Programming (ECOOP 97), volume 1241 of Lecture Notes on \nComputer Science, pages 104 127, Jyv\u00a8askyl\u00a8a, Finland, June 1997. Springer Verlag. [7] Kim B. Bruce, \nAngela Schuett, and Robert van Gent. Poly-TOIL: A type-safe polymorphic object-oriented language. In \nW. Olthoff, editor, Proceedings of 9th European Conference on Object-Oriented Programming (ECOOP 95), \nvolume 952 of Lecture Notes on Computer Science, pages 27 51, Aarhus, Denmark, August 1995. Springer \nVerlag. [8] Kim B. Bruce and Joseph C. Vanderwaart. Semantics-driven language design: Statically type-safe \nvirtual types in object\u00adoriented languages. In Proceedings of 15th Conference on the Mathematical Foundations \nof Programming Semantics (MFPS XV), volume 20 of Electronic Notes in Theoretical Computer Science, New \nOrleans, LA, April 1999. Elsevier. Available through http://www.elsevier.nl/locate/ entcs/volume20.html. \n[9] Dave Clarke, Sophia Drossopoulou, James Noble, and Tobias Wrigstad. Tribe: A simple virtual class \ncalculus. In Proceedings of International Conference on Aspect-Oriented Software Design (AOSD 07), pages \n121 134, Vancouver, BC, March 2007. [10] Vincent Cremet, Franc\u00b8ois Garillot, Sergue\u00a8i Lenglet, and Martin \nOdersky. A core calculus for Scala type checking. In Proceedings of International Symposium on Mathematical \nFoundations of Computer Science, Springer LNCS, pages 1 23, September 2006. [11] Erik Ernst. Propagating \nclass and method combination. In Proceedings of European Conference on Object-Oriented Programming (ECOOP \n99), volume 1628 of Lecture Notes on Computer Science, pages 67 91, Lisboa, Portugal, June 1999. Springer \nVerlag. [12] Erik Ernst. Family polymorphism. In Proceedings of European Conference on Object-Oriented \nProgramming (ECOOP2001), volume 2072 of Lecture Notes on Computer Science, pages 303 326, Budapest, Hungary, \nJune 2001. Springer Verlag. [13] Erik Ernst. Higher-order hierarchies. In Proceedings of European Conference \non Object-Oriented Programming (ECOOP2003), volume 2743 of Lecture Notes on Computer Science, pages 303 \n328, Darmstadt, Germany, July 2003. Springer Verlag. [14] Erik Ernst, Klaus Ostermann, and William R. \nCook. A virtual class calculus. In Proceedings of ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages (POPL2006), pages 270 282, Charleston, SC, January 2006. [15] James Gosling, Bill Joy, Guy \nSteele, and Gilad Bracha. The Java Language Speci.cation. Addison-Wesley, third edition, June 2005. [16] \nAtsushi Igarashi and Benjamin C. Pierce. On inner classes. Information and Computation, 177(1):56 89, \nAugust 2002. A special issue with papers from the 7th International Workshop on Foundations of Object-Oriented \nLanguages (FOOL7). An earlier version appeared in Proceedings of the 14th European Conference on Object-Oriented \nProgramming (ECOOP2000), Springer LNCS 1850, pages 129 153, June, 2000. [17] Atsushi Igarashi, Benjamin \nC. Pierce, and Philip Wadler. Featherweight Java: A minimal core calculus for Java and GJ. ACM Transactions \non Programming Languages and Systems, 23(3):396 450, May 2001. A preliminary summary appeared in Proceedings \nof the ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 99), \nACM SIGPLAN Notices, volume 34, number 10, pages 132 146, October 1999. [18] Atsushi Igarashi and Mirko \nViroli. Variant parametric types: A .exible subtyping scheme for generics. ACM Transactions on Programming \nLanguages and Systems, 28(5):795 847, 2006. [19] Atsushi Igarashi and Mirko Viroli. Variant path types \nfor scalable extensibility. In Informal Proceedings of the International Workshop on Foundations and \nDevelopment of Object-Oriented Languages (FOOL/WOOD 2007), Nice, France, January 2007. Available at http://foolwood07. \ncs.uchicago.edu/accepted.html. [20] Paul Jolly, Sophia Drossopoulou, Christopher Anderson, and Klaus \nOstermann. Simple dependent types: Concord. In Proceedings of 6th ECOOP Workshop on Formal Techniques \nfor Java-like Programs (FTfJP2004), June 2004. [21] Ole Lehrmann Madsen and Birger M\u00f8ller-Pedersen. Vir\u00adtual \nclasses: A powerful mechanism in object-oriented pro\u00adgramming. In Proceedings of ACM Conference on Object-Oriented \nProgramming, Systems, Languages, and Applica\u00adtions (OOPSLA 89), pages 397 406, October 1989. [22] Ole \nLehrmann Madsen, Birger M\u00f8ller-Pedersen, and Kristen Nygaard. Object-Oriented Programming in the BETA \nProgramming Language. Addison Wesley, 1993. [23] Mira Mezini and Klaus Ostermann. Conquering aspects \nwith Caesar. In Proceedings of International Conference on Aspect-Oriented Software Design (AOSD 03), \npages 90 99. ACM, 2003. [24] John C. Mitchell and Gordon D. Plotkin. Abstract types have existential \ntypes. ACM Transactions on Programming Languages and Systems, 10(3):470 502, 1988. Preliminary version \nappeared in Proc. of the 12th ACM POPL, 1985. [25] Nathaniel Nystrom, Stephen Chong, and Andrew C. Myers. \nScalable extensibility via nested inheritance. In Proceedings of ACM Conference on Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA 04),pages 99 115, Vancouver, BC, October 2004. [26] Nathaniel \nNystrom, Xin Qi, and Andrew C. Myers. J&#38;: Nested intersection for scalable software composition. \nIn Proceedings of ACM Conference on Object-Oriented Pro\u00adgramming, Systems, Languages, and Applications \n(OOP\u00adSLA 06), pages 21 36, Portland, OR, October 2006. [27] Martin Odersky, Vincent Cremet, Christine \nR\u00a8ockl, and Matthias Zenger. A nominal theory of objects with dependent types. In Luca Cardelli, editor, \nProceedings of European Conference on Object-Oriented Programming (ECOOP 03), volume 2743 of Lecture \nNotes on Computer Science, pages 201 224, Darmstadt, Germany, July 2003. Springer Verlag. [28] Martin \nOdersky and Matthias Zenger. Scalable component abstraction. In Proceedings of ACM Conference on Object-Oriented \nProgramming, Systems, Languages, and Applica\u00adtions (OOPSLA 05), pages 41 57, San Diego, CA, October 2005. \n[29] Chieri Saito, Atsushi Igarashi, and Mirko Viroli. Lightweight family polymorphism. Journal of Functional \nProgramming, 2007. To appear. A preliminary summary appeared in Proceedings of the 3rd Asian Symposium \non Programming Languages and Systems (APLAS2005), Springer LNCS vol. 3780, pages 161 177, November, 2005. \n[30] Yannis Smaragdakis and Don S. Batory. Implementing layered designs with mixin layers. In Proceedings \nof 12th European Conference on Object-Oriented Programming (ECOOP 98), volume 1445 of Lecture Notes on \nComputer Science, pages 550 570, Brussels, Belgium, July 1998. Springer Verlag. [31] Mads Torgersen. \nThe expression problem revisited: Four new solutions using generics. In Proceedings of European Con\u00adference \non Object-Oriented Programming (ECOOP2004), volume 3086 of Lecture Notes on Computer Science, pages 123 \n146, Oslo, Norway, June 2004. [32] Mads Torgersen, Erik Ernst, Christian Plesner Hansen, Peter von der \nAh\u00b4e, Gilad Bracha, and Neal Gafter. Adding wildcards to the Java programming language. Journal of Object \nTechnology, 3(11), December 2004. Special issue: OOPS track at SAC 2004, pp. 97 116. [33] Andrew K. Wright \nand Matthias Felleisen. A syntactic approach to type soundness. Information and Computation, 115(1):38 \n94, November 1994. [34] Matthias Zenger and Martin Odersky. Independently exten\u00adsible solutions to the \nexpression problem. Technical Report IC/2004/33, Ecole Polytechnique F\u00b4\u00b4 ed\u00b4erale de Lausanne, Lau\u00adsanne, \nSwitzerland, March 2004. \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Much recent work in the design of object-oriented programming languages has been focusing on identifying suitable features to support so-called <i>scalable extensibility</i>, where the usual extension mechanism by inheritance works in different scales of software components-that is, classes, groups of classes, groups of groups and so on. Its typing issues has usually been addressed by means of dependent type systems, where nested types are seen as properties of objects. In this work, we seek instead for a different solution, which can bemore easily applied to Java-like languages, in which nested types are considered properties of classe.</p> <p>We introduce the mechanism of <i>variant path types</i>, which provide a flexible means to express intra-group relationship (among classes) that has to be preserved through extension. In particular, improving and extending existing works on groups and exact types, we feature the new notions of <i>exact</i> and <i>inexact qualifications</i>, providing rich abstractions to express various kinds of set of objects, with a flexible subtyping scheme. We formalize a safe type system for variant path types on top of Feather weight Java. Our development results in a complete solution for scalable extensibility, similarly to previous attempts based on dependent type systems.</p>", "authors": [{"name": "Atsushi Igarashi", "author_profile_id": "81100444415", "affiliation": "Kyoto University, Kyoto, Japan", "person_id": "PP39101049", "email_address": "", "orcid_id": ""}, {"name": "Mirko Viroli", "author_profile_id": "81100133996", "affiliation": "Universita di Bologna, Cesena, Italy", "person_id": "P201740", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297037", "year": "2007", "article_id": "1297037", "conference": "OOPSLA", "title": "Variant path types for scalable extensibility", "url": "http://dl.acm.org/citation.cfm?id=1297037"}