{"article_publication_date": "10-21-2007", "fulltext": "\n WebRB: Evaluating a Visual Domain-Speci.c Language For Building Relational Web-Applications Avraham \nLeff James T. Ray.eld IBM T.J. Watson Research Center {avraham,jtray}@us.ibm.com Abstract Many web-applications \ncan be characterized as relational . In this paper we introduce and evaluate WebRB,a vi\u00adsual domain-speci.c \nlanguage for building such applica\u00adtions. WebRB addresses the limitations of the conventional imperative-embedding \napproach typically used to build relational web-applications. We describe the WebRB lan\u00adguage, present \nextended examples of its use, and discuss the WebRB visual editor, libraries, and runtime. We then evaluate \nWebRB by comparing it to alternative approaches, and demonstrate its effectiveness in building relational \nweb\u00adapplications. Categories and Subject Descriptors D[1]: 7 Visual Pro\u00adgramming; D [3]: 2 Data-.ow languages \nGeneral Terms Languages Keywords webrb, web relational blocks, relational web\u00adapplications, web-application \ndevelopment, visual program\u00adming languages, data-.ow languagesR  1. Introduction Different techniques \nhave been proposed for developing web applications. For example, some design tools exist (e.g., Dreamweaver \n[1] and IBM Rational Application Devel\u00adoper [2]), that provide a largely visual design paradigm. However, \nfor web applications which create dynamic pages and update relational databases, the imperative-embedding \napproach seems to be by far the most popular. In this ap\u00adproach, developers create web pages in an imperative \nlan\u00adguage such as Java or PHP. When the web page is accessed, the web server executes the imperative \nlanguage code and sends the output to the web-browser client. The imperative Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4eal, \nQu\u00b4ebec, Canada. Copyright c &#38;#169; 2007 ACM 978-1-59593-786-5/07/0010. . . $5.00 code may be written \nby hand, or automatically generated and hand-tailored (e.g., Ruby on Rails [3]). The popularity of such \ntext-based approaches is puzzling, since an all visual technique for designing web-pages would seem to \nbe more natural. This paper advocates the use of We\u00adbRB (Web Relational Blocks), which is unique in being \npre\u00adcisely such an all-visual approach, in contrast to imperative\u00adembedding or largely visual approaches. \nConsider the Product Catalog web-page shown in Fig\u00adure 1A. The web-page allows an eCommerce site to adminis\u00adter \nits product catalog through a browser interface. Although simple, it illustrates the following typical \npieces of dynamic web-page function: A dynamic HTML table is displayed to the user in which each row \nshows information about a product in an eCom\u00admerce catalog. The table is populated by reading data from \na relational database table.  Buttons in each row of the HTML table allows users to modify the relational \ndatabase table (e.g., to edit or delete a product in the catalog). Another button allows users to add \nproducts to the catalog.  The web-page is linked navigationally to other web\u00adpages in the application \nso that clicking the add but\u00adton navigates to the Add Product page, and clicking the edit button navigates \nto the Edit Product page. More\u00adover, data required by the next page (such as a product s ITEMNO) .ow \nfrom the current page into the next page.  The Product Catalog web-page illustrates properties of a \nbroad class of dynamic web-applications which we charac\u00adterize as relational . By this we mean that they: \n1. Read relational databases and present the data in a GUI; 2. Update relational databases based on \na user s interaction with the GUI; 3. Perform transformations of the relational data which re\u00adquire \nonly simple or moderately complex business logic.  Contrast the imperative-embedding approach for writing \ndynamic web-pages with the WebRB approach. Figure 2 is a fairly typical PHP speci.cation of the Product \nCatalog  A  Figure 1. Product Catalog Web-Page and WebRB Page-Design web-page; Figure 1B is a WebRB \npage-design of the same of the table cells. After the loop, the page reverts back to web-page. (Here, \nwe are motivating the use of WebRB;a de-HTML mode to generate the closing elements. This exam\u00adtailed \nset of examples and evaluation is provided later in the ple illustrates a number of drawbacks with the \nimperative\u00adpaper.) Since PHP pages start in unprocessed mode (typ-embedding approach. First, six language \ntransitions are re\u00adically HTML), the code in Figure 2 immediately switches quired in this example, forcing \na developer to switch be\u00adto PHP mode. Using PHP imperative code, a connection tween model and business \nlogic mode and GUI mode. to the database is established, and a SQL[4] query is exe-Second, the visual \n(HTML) portion of the page must be ex\u00adcuted. Next, the page switches back to HTML mode in order pressed \nin a non-visual fashion, requiring the developer to to generate the HTML table, then back to PHP to fetch \nthe keep a mental image of how the page will look when ren\u00addatabase data, then back to HTML to generate \nthe contents dered in a browser. Third, it mixes both imperative (PHP) and declarative (HTML) styles \nin close proximity. Finally, the database query must be expressed in SQL, even though a vi\u00adsual query \nbuilder might be more appropriate. WebRB is a visual domain-speci.c language designed to address the \nlimitations of the imperative-embedding ap\u00adproach for relational web-applications. As shown in Fig\u00adure \n1B, WebRB includes the following speci.c features that make it easy to write such applications: Its \nrelational API and data.ow approach strongly support the bi-directional movement of relational data between \ndatabase tables and the GUI.  By using relational algebra to transform relational data, developers are \nable to express business logic in a way that .ts their data s semantics.  As a visual programming language, \nit allows develop\u00aders to visually construct the application s GUI. Moreover, even the non-GUI portions \nof the application are written using the same syntax and semantics as the GUI portion. Developers therefore \ndo not have to repeatedly cross be\u00adtween visual and non-visual languages when developing the application. \n These features also point to the types of web-applications that WebRB is not suited for: those with \ncomplex business logic (more dif.cult to express in relational algebra) or those that access non-relational \ndata (need a different API). In this paper, we substantiate the claim that, compared to the imperative-embedding \napproach, WebRB can signif\u00adicantly improve developer productivity and reduce mainte\u00adnance costs for relational \nweb-applications. Also, we show that WebRB provides suf.cient functionality to implement any relational \nweb-application with moderately complex business logic. Section 2 de.nes the WebRB model of computation \nand visual language, and compares its approach to related work. We discuss the WebRB implementation in \nSection 3. In Sec\u00adtion 4 we present a detailed set of examples to show how WebRB is used to construct \nnon-trivial web-pages. The core of the paper is Section 5 in which we evaluate WebRB across a number \nof important language dimensions, and compare it to alternative approaches for developing web-applications. \nWe summarize the contributions of WebRB in Section 6.  2. The Language 2.1 Model of Computation The \nWebRB model of computation closely supports the lan\u00adguage s application domain: relational web-applications. \nFrom the end-user s perspective, such applications consist of a set of pages, each of which has a GUI \nthrough which the user can interact with the application. A WebRB devel\u00adoper implements the application \nwith a set of visual page\u00addesigns (such as Figure 1) that in addition to specifying the GUI seen by \nthe end-user specify the business logic and database access that respond to user interactions. The WebRB \nmodel of computation is therefore page-based , and differs from typical GUI event-handlers [5] in that \nre\u00adsponse logic is speci.ed by the page-design itself rather than through code that is attached to individual \nGUI widgets. Speci.cally, the event-loop for processing page Pj consists of the following steps: 0. Render \nPj s GUI on the end-user s device (e.g., as a page displayed in a web-browser). 1. Wait for the user \nto interact with the GUI. 2. Process a user-interaction by executing Pj s declarative speci.cation which \ndescribes (through the semantics of its blocks and the block data-.ow):  (a) What (and how) data should \nbe transformed, and which persistent database tables should be accessed and updated. (b) How to select \nthe application s next page (e.g., Pk). Note that the next page may be the same as the current page (i.e. \nk = j).  3. Repeat from step 0, using Pk. We next explain how the behavior of an individual page\u00addesign \nis speci.ed by WebRB s visual syntax and by We-bRB s relational API. 2.2 Language Elements A WebRB page-design \nis a named set of blocks that have been assembled by a developer, such as the one shown in Figure 1. \nPage-designs are constructed using the following visual elements: A block is a component that provides \na well-de.ned relational function. Blocks may optionally receive input and/or produce output; such inputs \nor outputs may consist only of relational data.  A block indicates that it receives relational input \n(or out\u00adput) with an input (or output) pin. Pins are thus a named I/O port, and blocks can have zero \nor more input (or out\u00adput) pins.  Data .ow between blocks is represented as a wire that  connects a \nblock s input pin to a block s output pin. Examining Figure 1, we see a wire transmitting an n\u00adtuple \nrelation (each containing four attributes) connecting the READ DB block s output pin to the HTML-TABLE \nblock s input pin. A WebRB implementation is responsible for providing de\u00advelopers with a set of useful \nblocks. The only requirement is that all blocks use a relational API. The number of in\u00adput and output \npins are arbitrary and may vary from block to block. A block s API can further constrain its input s \nre\u00adlation header in terms of what attribute names or types are legal, or it can constrain the cardinality \nof a valid relation.  Figure 2. Product Catalog, PHP version For example, by looking at Figure 1, we \nsee that BUTTON blocks have no input pins, since they are used only for user input. In contrast, an HTML-TABLE \nblock has one input pin which accepts a relation of any type, and whose data is used to populate the \ntable. A BUTTON block has a single output pin which transmits a single boolean relation (see [6], TA-BLE \nDEE) whose value indicates whether or not the button was clicked. In contrast, an HTML-TABLE block has \nmulti\u00adple output pins: one that transmits a generic relation con\u00adsisting of the tuple selected by the \nuser s interaction, and a set of pins that transmit the individual attributes of the tuple selected by \nthe user. Once a developer assembles blocks as a page-design, that design becomes a .rst-class citizen \nof the language. From WebRB s perspective, page-designs are blocks. The only dif\u00adference is that built-in \nblock types are pre-assembled by a WebRB implementation, whereas pages are assembled by a developer. \nBecause they must be assembled, pages are the only construct that can be edited or validated using a \nWe\u00adbRB visual editor. In the context of the visual editor, we re\u00adfer to a page design. Once assembled, \na page is represented using the blocks, pins, and wires metaphor, and behaves just like a pre-assembled \nblock. In that context, we refer to a page block. The semantics of a page-design are self\u00adcontained since \ndevelopers do not add any non-visual code. Pages can therefore be directly executed by the WebRB run\u00adtime, \nfor example, as web-pages rendered in a browser and linked to data and control logic on the server. In \nthe context of page execution, we refer to a page-design as an applica\u00adtion page. A page-design A can \nuse a page block B in two ways: As a page that is directly embedded into A s page-design and application \npage. In this case, B is represented with an EMBEDDED PAGE block. EMBEDDED PAGE blocks allow developers \nto construct libraries of reusable page\u00addesigns such that a page can be nested in other pages as a custom \nblock. Alternatively, a developer may re-factor a complicated (visually busy ) page-design into a page \ncontaining EMBEDDED PAGE blocks. As a possible next page when A executes. In this case, B is represented \nwith a PAGE TRANSITION block, to which a developer wires relational logic that speci.es when the application \nwill transition from A to B s application page (see Section 2.1). The Search page-design of Figure 9 \nillustrates these two ways that page blocks are used. The buy button in the HTML table is wired to an \nembedded buy page block (Figure 12) that encapsulates the processing of purchasing a single line-item. \nUsing PAGE TRANSITION blocks, the Search page-design speci.es that a successful buy operation navigates \nto the Shopping Cart page (Figure 11). The Search page-design also speci.es that a search operation refreshes \nthe Search page, but populates the TEXT-ENTRY .eld with the user-supplied search string. In order for \npages (supplied by a developer) to behave exactly like pre-assembled blocks, there must be a mecha\u00adnism \nto specify a page s input and output API. This is done with PAGE INPUT and PAGE OUTPUT blocks. A PAGE \nIN-PUT block passes data (unchanged) from an input pin on a embedded or PAGE TRANSITION block into the \npage-design in which the PAGE INPUT block appears. Likewise, a PAGE OUTPUT block passes data (unchanged) \nfrom the page de\u00adsign in which it appears to the output pin of an EMBED-DED PAGE block. Thus, PAGE INPUT \nblocks are analogous to a function s formal input parameters, and PAGE OUTPUT blocks are analogous to \na function s formal output parame\u00adters. These blocks are represented as named input (output) pins on \nthe page s corresponding EMBEDDED PAGE block or PAGE TRANSITION blocks. PAGE INPUT and PAGE OUTPUT blocks \nare illustrated by the Buy page-design shown in Figure 12. There are two PAGE INPUT blocks: ItemNoQty \nsupplies a two-attribute, single-tuple, relation consisting of the selected product s name and the quantity \npurchased; buy supplies a boolean relation indicating whether to initiate the buy processing. There are \nthree PAGE OUTPUT blocks: errorMsg provides an error message string (as a single-tuple single-attribute \nrelation); success is a boolean relation which is TRUE if the buy processing was successful; and error \nis a boolean relation which is TRUE if an error occurred.  2.3 Re.ned Model of Computation The semantics \nof database and widget blocks require that we re.ne Step2ofthe WebRB model of computation described in \nSection 2.1. We do this characterizing pre-assembled blocks along two axes: (1) whether they are stateless \nor state\u00adful; and (2) whether they appear in the GUI that is seen by the end-user. Stateless, non-GUI, \nblocks are the simplest to understand. They are purely functional, in the sense that block output depends \ncompletely on the current inputs to the block. For example, the output of a JOIN block is always the \nnatural join of the inputs. Such blocks have attractive properties: they are easily composed, and reasoning \nabout their behavior is straightforward ([7], Chapter 3). Also, all their dependencies can be clearly \nseen in the visual representation. Stateless GUI blocks are also fairly simple: they create a visible \nGUI artifact based on their current inputs. For example, a TEXT block generates a text label in the GUI, \nand the contents of that label are based on the block s input at the time that the GUI s widget is generated. \nStateful blocks are less straightforward. However, they are vitally necessary, because useful applications \nrequire the ability to enter, preserve, and modify persistent information. Even pure functional languages \nsuch as Haskell are forced to accommodate this requirement [8]. The WebRB model of computation incorporates \nstateful blocks by treating a page\u00addesign as a sequential synchronous circuit. As a result, step 2 above \nexecutes as a series of sub-steps that describe how block s inputs and its current state Si interact \nto create the block s outputs and next state Si+1. Stateful GUI blocks (e.g., TEXT-ENTRY) are displayed \nin the GUI using the current value of their input(s). The user s interaction may alter the value of the \nblock, e.g., by typing into the text-entry .eld. When the user interaction is processed, the output value(s) \nof the block are the last value(s) seen by the user: i.e., either the value that was initially displayed, \nor the value that was entered by the user. Thus, stateful GUI blocks can retain state during the user\u00adinteraction \nperiod, but may also be modi.ed by the user to contain new state. Stateful non-GUI blocks are used to \naccess the database, and encapsulate the state of a database table. READ DB blocks have an output pin \nwhose value is the current con\u00adtents of the speci.ed database table, and do not have any input pins. \nMutator blocks (INSERT DB, UPDATE DB,and DELETE DB) make changes to the database. These blocks have two \ninput pins: an enable pin, which enables or disables the block, and another pin which accepts the tuple(s) \nto be inserted, updated, or deleted. Mutator blocks have no output pins. During event processing, the \ndatabase state transitions from the initial state Si to the .nal state Si+1. WebRB allows multiple instances \nof READ DB and muta\u00adtor blocks to reference the same database table. This is visual syntactic sugar ; \notherwise WebRB would have to de.ne a CRUD block (one per table per page), combining the func\u00adtion of \nREAD DB, INSERT DB, UPDATE DB,and DELETE DB. However, the WebRB runtime only allows one mutator block \n(per user) to be enabled at any given time. Otherwise the developer would need to specify ordering rules \nfor updates. Step 2 in Section 2.1 incorporates these various types of pre-assembled blocks in a re.ned \nevent-processing algo\u00adrithm that executes as follows: 1. All enabled mutator blocks evaluate their inputs \n(in\u00adcluding enable ). This recursively causes all the blocks which feed those inputs to evaluate their \ninputs, and so on. The recursion terminates at stateful blocks which have a known output value (stateful \nGUI blocks and READ DB blocks). Stateful GUI block outputs corre\u00adspond to the values that the user saw \nin the GUI, and READ DB block outputs correspond to the initial state of the database, Si. 2. All mutator \nblocks simultaneously change the database state (according to the inputs saved in the previous step) \nto the new state Si+1, by inserting, updating, or deleting table records as appropriate. 3. The next \napplication page is selected. This is done by evaluating the inputs to the enable input pin of all PAGE \nTRANSITION blocks in the current page. Although enable is a reserved pin name, the semantics of this \ninput pin evaluation are the same as other pin evaluations. A page is selected as the application s next \npage only if the enable pin s input is TRUE.In the Shopping Cart page-design (Figure 11), for example, \nthe Search page is selected if the user initiates a search by clicking the go button. Although a page-design \nmay contain any number of PAGE TRANSITION blocks, at runtime, only zero or one of them may be enabled \nsimultaneously. If zero PAGE TRANSITION blocks are enabled, no page transition occurs (the next page \nis the same as the current page, i.e. k = j). It is a runtime error for two or more PAGE TRANSITION blocks \nto be simultaneously enabled. 4. The GUI for the next application page is generated. All GUI blocks \non the page (stateful and stateless) evaluate their input pin(s). This ultimately evaluates the blocks \nwhich feed the GUI element inputs. As before, the re\u00adcursion terminates at stateful blocks which have \na known output value (stateful GUI blocks and READ DB blocks). Stateful GUI block outputs still correspond \nto the values that the user saw in the current GUI page, but READ DB block outputs now correspond to \nthe new database state Si+1. 5. The next GUI page is returned to the user for display.  2.4 Concurrency \nSince relational applications are almost always multi-user, WebRB must support concurrent execution of \nits applica\u00adtions. The shared application-state in WebRB consists of the database tables which are accessed \nby the READ DB and mutator blocks. WebRB relies on the database manager to provide ACID [9] properties \nfor the database tables. At the beginning of the re.ned event-processing algorithm (Sec\u00adtion 2.3), a \ndatabase transaction is started. Before the next GUI page is returned to the user for display (step 5), \nthe database transaction is committed. If any runtime errors are detected by the WebRB runtime (e.g., \nfor the same user, multiple mutator blocks are simultaneously enabled, or two or more PAGE TRANSITION \nblocks are simultaneously en\u00adabled), the database transaction is rolled-back. If they wish, developers \ncan explicitly roll-back transactions by disabling all mutator blocks when an error is detected. We do \nthis in Figure 12, in which a failed string-to-integer disables the IN-SERT DB block for the CART table. \nThe WebRB approach of coupling transaction scope to the event loop is a compromise between requiring \nan applica\u00adtion to handle transaction-scoping explicitly, and providing middleware [10] which supports \nlong-running transactions (those which span multiple user events). Future WebRB work will explore relaxing \nthe transaction-scope = event con\u00adstraint. 2.5 Security With respect to access control to application \npage-designs or data, WebRB does not currently distinguish between the de\u00adveloper role (the person coding \na page-design) and the end\u00aduser (the person executing the assembled application). We\u00adbRB implements access \ncontrol by providing authenticated users of the system with a virtual database partition that stores \npage-designs and application data. However, a sim\u00adple model is used in which one user (whether a developer \nof end-user) cannot access another user s database partition. Obviously this design is unsuitable for \na production en\u00advironment. In such an environment, WebRB will have to dis\u00adtinguish the developer role \nfrom the end-user role and pro\u00advide each role with different access rights. Developers would need new \nblocks to support access control. WebRB will also have to enable collaboration (both read and write access) \nbe\u00adtween developers by providing function similar to CVS or SVN. We have not done any design work in \nthis area with regard to WebRB. With regard to an application s runtime security, WebRB is generally \nnot susceptible to some of the attacks which are effective on contemporary systems. For example, SQL \ninjection attacks are not effective because there is no way to specify a design which routes user input \nto the SQL parser. SQL cannot be directly entered into WebRB designs, and internal use of SQL always \nuses parameterized prepared statements. Similarly, WebRB is generally not vulnerable to cross-site scripting \nattacks, because there is no way to have a design which causes user-supplied or database-supplied data \nto be interpreted as HTML. TEXT-ENTRY, TEXT-LABEL,and HTML-TABLE widgets automatically escape all input \ndata to prevent it from being interpreted by the browser. 2.6 Related Work The task of easing the development \nof multi-page applica\u00adtions that integrate relational data, GUIs, and business logic has been approached \nfrom many directions. WebRB provides an integrated, visual, end-to-end approach for building rela\u00adtional \napplications, which eliminates the need for developers to cross between visual and non-visual languages. \nAlthough many mixed (visual and non-visual) development environ\u00adments exist, the bulk of this paper focuses \non a comparison between WebRB and non-visual imperative-embedded ap\u00adproaches. We do so because imperative-embedding \nalso pro\u00advides a consistent language paradigm (all non-visual), and has enduring popularity among the \ndeveloper community. In this section, however, we discuss the relationship of various components of the \nWebRB approach such as visual pro\u00adgramming, visual editors, and integration of relational data to other \nwork in this area. 2.6.1 Visual Programming Languages The idea that visual programming languages (VPLs) \nshould be used to improve developer productivity (relative to text\u00adbased languages) is well-known. Some \nVPLs, such as VIPR [11] and Prograph [12], have attempted to provide visual imper\u00adative programming languages. \nFrom a language perspec\u00adtive, WebRB differs from such VPLs because it is declarative (rather than imperative), \nand is relation-based (rather than object-oriented). More fundamentally, unlike WebRB which is a domain-speci.c \nlanguage, these languages are general purpose and therefore do not provide built-in support for databases \naccess or for constructing GUIs. Rather, such lan\u00adguages are intended to replace languages such as C. \nOther languages and systems do support visual GUI construc\u00adtion. Forms/3 [13] allows construction of \nscreens based on function expressions. However, it does not support database access, and does not directly \nsupport relation types. Also, Forms/3 functions are expressed textually, not visually. Co\u00adcoa [14] supports \nsimple GUI construction, but again does not support database access. 2.6.2 Visual Editors Many visual \neditors exist which allow the design of static web pages, in WYSIWYG fashion. This is an attractive ap\u00adproach, \nbecause it provides a very close mapping between the design-time view and the run-time view. However, \nit is dif.cult to extend such editors to support dynamic pages, because of the lack of appealing visual \nlanguages which can handle the business logic ( controller ) portions of the ap\u00adplication. Dreamweaver \n[1] is an example of a visual editor for static web pages that also provides some extensions for dy\u00adnamic \nweb pages. For example, it allows developers to attach non-visual imperative code (e.g., JavaScript) \nto web pages, to generate HTML tables from queries on database tables, and to generate HTML forms that \nupdate database tables. However, it allows only forms-based business logic to be speci.ed visually, and \nforces developers to escape into non\u00advisual languages when they need to express logic beyond this scope. \nJavaServer Faces [15] (JSF) is an alternative technology for specifying web pages, and a variety of visual \neditors (e.g., [16]) allow developers to construct web pages using a mix of WYSIWYG and non-visual techniques. \nJSF provides (server-side) user-interface components, such as text-input boxes, tables, and buttons, \nwhich are rendered to the browser using pluggable rendering code. The web page is described by a set \nof JSF tags and XML con.guration. Although the (initial) page layout can be done visually, and inter-page \nnavigation can also be speci.ed visually, existing JSF visual editors do not provide a visual mechanism \nfor handling the dynamic portions of the page. The visual editors instead provide a linkage with (non-visual) \nJava code ( managed beans ), which reads and updates the JSF components. 2.6.3 Visual Access To Relational \nData Other languages, like WebRB, directly support visual access to relational databases, including Query-by-Example \n[17] which allows non-programmers to specify database queries and updates by .lling out templates describing \nthe desired operations. Visual query systems [18] provide read access and presentation services for relational \ndatabase systems using a visual programming paradigm. Database modeling software such as DDS-Pro [19] \nsupport visual design of tables and queries. Unlike WebRB, however, none of these tools provides full \nsupport for the visual construction of relational applications. Like Cocoa [14], most do not support \nupdates to the database other than very simple property\u00adeditor GUIs. 2.6.4 Object-Relational Mapping \nObject-Relational Mapping (ORM) technologies address the task of integrating relational data into applications \nby treat\u00ading such data as objects that can be used in a general-purpose object-oriented language. Typically \ntooling (either visual or XML-based) is used to create a mapping between a row in a database table and \nan instance of an object. Examples of such technology include Hibernate [20] and EJB container\u00admanaged \npersistence [21]. In ORM approaches, objects are the .rst-class construct used to build applications. \nWebRB, in contrast, is motivated by the observation that for relational applications in which relational \ndata is heav\u00adily accessed and manipulated the most natural approach treats relations (tables) as the \n.rst-class construct used to build applications. The relational model is based on set the\u00adory, in which \neach relation represents a set, and each tuple (row) value indicates the presence of that value in the \nset. Attribute (column) values are drawn from a speci.c type, such as integer, string, date, etc. Row \nvalues indicate a rela\u00adtionship between multiple attribute values, and thus do not themselves naturally \nform a type system (see [6], chapter 2). In WebRB, objects are attribute values rather than the tuple \nvalues of an ORM system. WebRB borrows many concepts from object-oriented pro\u00adgramming, including encapsulation \nand separation of in\u00adterface from implementation. Blocks have a de.ned inter\u00adface (pins), and are only \naccessible via that interface. The implementation is unspeci.ed and not available from out\u00adside the block. \nIn addition, attribute values in WebRB are handled very much like object instances, and a natural ex\u00adtension \nof WebRB would be to support developer-de.ned types (classes) for attributes. Developer-de.ned types \ncould then be mapped onto relational columns, and FUNCTION blocks (Section 4.3) would enable operations \nto be invoked on developer-de.ned types. 2.6.5 Summary To summarize, many tools, languages, and systems \nuse vi\u00adsual techniques to improve developer productivity for con\u00adstructing portions of an application. \nWebRB,however, uses visual techniques for all parts of an application. Its ability to do so stems, in \nlarge part, because WebRB is a domain\u00adspeci.c language for relational web-applications, and does not \nsupport programming of other types of applications. Thus, by limiting its scope, WebRB can use a data-.ow \nap\u00adproach which naturally expresses the movement of relational data between databases and the GUI with \na small set of visual metaphors. By using relational algebra, transforma\u00adtions of relational data are \ndone in the same semantic space and with the same visual metaphors as the data itself. Finally, the \nWebRB model of computation and runtime nat\u00adurally supports the deployment of multiple page-designs as \nweb-applications containing multiple web-pages that run in a standard web-browser.   3. Implementation \nWebRB [22] also includes: a visual editor whose palette of pre-assembled blocks provides the functionality \nused to typically develop the simpler sort of web-applications. The visual editor allows developers to \ndirectly code WebRB page designs using only the language s visual syntax without additional con\u00adstructs. \n a runtime which deploys WebRB page designs as an ap\u00adplication s web-pages that execute in a standard \nbrowser. It also manages an application s inter-page navigation and associated data-.ows. Finally, the \nruntime validates page designs and reports errors via the visual editor.  3.1 Visual Editor The WebRB \neditor is written in JavaScript (about 10,000 lines of code), runs in a standard Mozilla Firefox browser, \nand is used to visually construct WebRB programs. Because WebRB is a visual language, there is a good \n.t between the editor and the programs that it constructs. Figure 3 shows that the WebRB editor is comprised \nof sev\u00aderal frames. A page-design (corresponding to a single web\u00adpage) is assembled in the page editor \nframe. As a named page-design, it will be listed in the set of EMBEDDED PAGE blocks and PAGE TRANSITION \nblocks that are available to the developer. The palette frame contains the set of pre\u00adassembled blocks \nfrom which a developer drags and drops blocks when assembling a page design in the page editor frame. \nThe palette can be thought of as a block factory that produces generic block instances. The set of pre-assembled \nblocks will be discussed as we walk-through the process of using WebRB to construct web-pages in Section \n4. If a given block instance is selected, a property editor for that instance is displayed in the bottom \nframe of the visual editor. This al\u00adlows developers to view and customize the block s behavior (e.g., \nrename input or output attributes). The blocks, pins, and wires visual metaphor is directly supported \nbecause the pin names of all block instances (including page-blocks) are displayed in the page-design. \nWires are drawn by left\u00adclicking near an given pin, dragging the mouse to the other pin while holding \nthe left mouse-button down, and then re\u00adleasing the mouse button. Wires can be deleted by selecting them \nand hitting the delete key. Blocks (and all of their at\u00adtached wires) are deleted by selecting them and \nhitting the delete key. The WebRB editor provides special support for construct\u00ading a web-application \ns GUI. Developers can move all of a page-design s blocks to speci.c x, y coordinates on the page editor \nframe. When a page-design is rendered as a web-page, its widget blocks (e.g., TEXT-ENTRY or HTML-TABLE) \nare rendered as corresponding GUI widgets at pre\u00adcisely those coordinates on the web-page. This approach \nis much easier than using imperative code to draw and position the widgets. The WebRB editor reduces \nthe length of the code, test, and debug development cycle because applications can be directly executed \nfrom the editor itself. Incremental con\u00adstruction is encouraged because only a small set of blocks is \nrequired to bootstrap a working application. Blocks may be added, removed, or rewired at any time. Any \npage may be immediately validated and executed.  3.2 Runtime The WebRB runtime is written in PHP (approximately \n15,000 lines of code), and is hosted on an Apache web\u00adserver, using IBM DB2 as the database storing the \npage designs and application data. The WebRB runtime is respon\u00adsible for deploying WebRB page-designs \nas web-applications that execute in a standard browser. We now explain how our runtime can do this without \nrequiring developers to add im\u00adperative code on either the client or the server. The server does not \nhave to directly manipulate the We\u00adbRB visual language because page-designs are stored in their serialized \nXML representation. The XML representation serves as a canonical form of a given block: it s instantiated \nas an PHP object on the server, and as a JavaScript object in the browser. The WebRB runtime renders \na WebRB page by creating server-side versions of each WebRB block . Model blocks are implemented as a \nwrapping of connec\u00adtions to database tables; algebra blocks are implemented to provide the required algebra \nfunction; and widget blocks are implemented so that their getHTML() method produces the corresponding \nHTML that can be rendered in a web-browser. Block inter-connection is implemented by driving the spec\u00ad \n Figure 3. The WebRB Editor i.ed data-.ow from output pins to their input pins, and so on, using a recursive \nprocess. The initial page of an application is displayed when the client s browser issues an HTTP GET \nrequest: the server s WebRB runtime calls getHTML() to create the initial page, and returns the web-page \nto the browser. During initial-page evaluation, widgets with output pins will return empty rela\u00adtions \n(since the user has not yet had an opportunity to en\u00adter any data). Once launched, the server forgets \nabout the page until the user interacts with the web-page, causing an HTTP POST of the page and its data \nto the server. The WebRB runtime uses the POST data to instantiate the correspond\u00ading server-side version \nof that web-page, provides the user\u00adsupplied data (e.g., text-.eld input) to the widget blocks, and evaluates \nthe resulting relational circuit . The runtime must then determine which web-page should be instantiated \nnext.  4. Examples The Product Catalog example (Figure 1) and the discussion of the WebRB language \n(Section 2) show that WebRB theo\u00adretically addresses many of the scaling dif.culties that have traditionally \nbeen associated with visual languages [23]. We\u00adbRB can be used to develop large-scale applications, since \ndevelopers can scale an application in two ways: hierar\u00adchical scaling and horizontal scaling. Hierarchical \nscal\u00ading involves using EMBEDDED PAGE blocks to encapsulate function, both to reduce page complexity \nand enable re-use of function. Horizontal scaling involves partitioning an ap\u00adplication into multiple \npages, and using PAGE TRANSITION blocks to specify inter-page navigation and data .ow. In this section \nwe ll use a set of examples to show that WebRB implementation (Section 3) is powerful enough to easily \ndevelop relational web-applications with signi.cant function. The examples will incrementally introduce \nWebRB capabilities to enable us to highlight speci.c pieces of func\u00adtion. The page-designs are screen-shots \nof the WebRB visual editor [22], and the web-pages are screen-shots of the corre\u00adsponding web-application \nexecuting in a web-browser. 4.1 CRUD Function The examples in this sub-section allow an eCommerce site \nto administer a product-catalog: we use them to show how We\u00adbRB makes it easy to construct web-pages \nthat perform the well-known Create, Retrieve, Update, and Delete (CRUD) Figure 4. eCommerce Site Page-Transition \nDiagram operations. The page-transition diagram of the site is shown in Figure 4. There are two groups \nof pages: product cata\u00adlog administration, and shopping pages. We already intro\u00adduced the Product Catalog \npage (Figure 1) in Section 1. It displays the current contents of the product catalog. Add and Edit buttons \nprovide links to the Add Product (Fig\u00adure 6) and Edit Product (Figure 7) pages, respectively. The Search \npage (Figure 9) is used to search the product catalog. If a product is purchased with the Buy button, \nthe Shop\u00adping Cart page (Figure 11) is displayed. The core of the Product Catalog page is a read opera\u00adtion \nin which a READ DB block .ows the product catalog the entire relation stored in the PRODUCTS database \ntable intoan HTML-TABLE block.Thedeveloperusestheproperty editor (Figure 5) to specify that, in addition \nto displaying all columns of the database table, each row of the HTML table should include edit and delete \nbuttons. These and the Add product button drive write operations from the GUI to the database table. \nThe Figure also shows how the WebRB developer spec\u00adi.es event-handling among a set of possible user-speci.ed \nactions. The display of a new page after a user input occurs is controlled by PAGE TRANSITION blocks \n(Section 2) such as the Add Product and Edit Product blocks. A PAGE TRANSITION block has an enable pin \nwhich, if TRUE, causes a transition to the speci.ed page. They also have any number of input pins, one \nfor each PAGE INPUT block on the target page, that specify inter-page data-.ow. Although the Add Product \npage-design does not have any PAGE IN-PUT blocks, the Edit Product page-design includes a PAGE INPUT \nblock that .ows the ITEMNO data into the page. Thus, clicking the Edit button brings up the Edit Product \nweb\u00adpage, allowing the selected product to be updated. The page navigation is speci.ed by wiring the \nboolean-relation output of the button to the boolean-relation enable input pin of the EditProduct PAGE \nTRANSITION block.(Anunselected button emits the FALSE relation; a selected button emits the TRUE relation.) \nData-.ow to the Edit Product web-page is speci.ed by wiring the HTML-TABLE s selectedRow out\u00adput pin \nfrom the HTML-TABLE to the ItemNo input pin of the Edit Product PAGE TRANSITION block. The developer \nuses the property editor (Figure 5) to specify that the one\u00adtuple relation that .ows from the selectedRow \npin contains only the ITEMNO attribute. The Add Product and Edit Product page-designs (Fig\u00adures 6 7) \nare conceptually similar to the Product Catalog page-design, except that they use UPDATE DB and INSERT \nDB blocks to represent the appropriate CRUD operation. The delete product operation is implemented by \ndirectly incor\u00adporating a DELETE DB block into the Product Catalog page\u00addesign. Since no PAGE TRANSITION \nblock is enabled when a product is deleted, the Product Catalog page is redisplayed (no page-transition \noccurs).  4.2 Business Logic: Relational Algebra &#38; Expressions The CRUD examples of Section 4.1 \nshow that WebRB has the right set of database and GUI blocks for web-pages that require no business logic. \nNow we show how WebRB al\u00adlows developers to incorporate moderate amounts of busi\u00adness logic into their \nweb-pages. Using a visual programming language to specify business logic in a general-purpose way can \nbe dif.cult [24]. WebRB is able to solve this problem because of the more constrained semantics of its \nrelational application domain. The operators in the relational algebra ([6], Chapter 2) take at least \none re\u00adlation as input and produce a relation as output. Using op\u00aderators such as JOIN, PROJECT,and UNION, \nallows WebRB business logic to bene.t from the close .t between the re\u00adlational algebra and the relational \nmodel used in the WebRB database and GUI blocks.  Figure 5. HTML-TABLE Property-Editor Figure 6. Add \nProduct Page-Design and Web-Page Consider Figure 8, a page-design for a Search web-page and retrieve \ninformation about that product. Unlike the Prod\u00adinterface to the PRODUCTS database table. The web-page \nuct Catalog page, which retrieves the entire database table, (Figure 9) allows users to search for a \nproduct by name here the developer wants to retrieve only a speci.ed subset Figure 7. Edit Product Page-Design \nand Web-Page of rows. There are two inputs to the page: searchText (the text to search for), and msg \n(a message to be displayed). When the page is .rst launched, these two inputs are empty relations. The \ndeveloper .rst uses a JOIN block to compute a Carte\u00adsian product between searchText and the PRODUCTS \ntable. Since they have no common attributes, the searchText is essentially appended to each row of PRODUCTS \nas a new column. Then, the resulting relation is .ltered by a WHERE block, so that only tuples where \nthe product NAME matches the searchText are kept. Next, the result is JOINed with a constant string (QTY \n= 1 ) to set a default purchase quan\u00adtity to be displayed. Finally, the results are displayed in an HTML-TABLE. \nThe WHERE block uses a tuple expression to specify that only tuples that match the searchText string \nshould be selected from the PRODUCTS table. A tuple expression is an expression whose input is a single \ntuple and whose re\u00adsult is a single value. Tuple expressions can include con\u00adstants, but differ from \nstandard expressions in that their vari\u00adables refer to attributes in the input tuple. Thus, the ex\u00adpression \nB+3 is interpreted as the value of the attribute B plus the constant 3 . More formally, constants and \ninput at\u00adtributes are the terminal nodes of a WebRB expression tree. The non-terminal nodes in a WebRB \nexpression-tree may  Figure 8. Search Page-Design Figure 9. Search Web-Page be unary functions (e.g., \nunary minus, type conversion) or Figure 8 shows how WebRB uses EMBEDDED PAGE binary functions (e.g., \nMATCH(), arithmetic sum, or CON-blocks to achieve hierarchical page-design scaling. Buy CATENATE()). \nWebRB provides a library of node implemen-product is a chunk of controller function, for example, tations \nto support commonly used functions and operators. that was factored out from the original design into \na separate buy EMBEDDED PAGE block. We discuss this EMBED\u00ad DED PAGE in the context of how WebRB does \nexception handling in Section 4.4. Figure 8 also includes a search UI EMBEDDED PAGE block (Figure 10) \nwhich encapsulates the web-page s view . An application s UI can thus be de\u00adsigned by one developer independently \nof the business logic or database access that is done by other developers. Work\u00ading independently requires \nonly that the developers agree on the EMBEDDED PAGE API: i.e., the PAGE INPUT and PAGE OUTPUT blocks. \n 4.3 Business Logic: Natural Join &#38; Functions The Shopping Cart page-design in Figure 11 introduces \nother constructs to specify web-page business logic. The de\u00adveloper wants to display the contents of \na user s shopping cart which is persistently stored in a database table. Fol\u00adlowing standard normalization \ntechniques, only a product s ITEMNO and the quantity ordered are stored in the CART ta\u00adble. In order \nto include product name and price information (stored in the PRODUCTS table) in the HTML-TABLE, the de\u00adveloper \nuses a JOIN block to perform the natural join of the two relations. Since the HTML-TABLE also includes \na column showing the sub-totals for each line-item in the cart (the extPrice attribute), the developer \nuses a FUNCTION block to calculate this value and add it to the HTML-TABLE s input relation. FUNCTION \nblocks are WebRB s solution to the problem of how to implement functions using relational algebra. Con\u00adsider \nthe operation of converting the string representation of an integer (e.g., 42 ) to the corresponding \ninteger (42). What is desired is a block with an input attribute of type string ( 42 ), and an output \nattribute of type integer (42), representing the converted value. In WebRB, this is accom\u00adplished by \na FUNCTION block. FUNCTION blocks de.ne their output attributes in terms of tuple-expressions (Section \n4.2) applied to their input at\u00adtributes. In our example, the expression D = TOINT(STR) speci.es that \nthe function s output attribute, D,is the re\u00adsult of applying the function TOINT (convert to integer) \nto the value of the attribute STR . More generally, a FUNCTION block allows developers to create new \nattributes, specifying that their value in terms of a tuple-expression that is applied to each tuple \nin the input relation. A FUNCTION block s out\u00adput is thus a relation containing only attributes which \nare derived from the input relation via tuple expressions. Developers can also use FUNCTION blocks to \nadapt re\u00adlations to match another block s desired inputs. Examples include: removing unneeded attributes \n(projection), creating derived attributes, and type-conversion. As shown in Fig\u00adure 11, input attributes \nmay be propagated directly to the output by specifying the trivial expression NAME = NAME. This is done \nwith the ITEMNO, NAME,and PRICE attributes. The FUNCTION block also converts the quantity to a string \nfor display (QTYSTRING = VARCHAR(QTY)), and calculates the line-item total (EXTPRICE = VARCHAR(QTY * \nDOU-BLE(PRICE))) as a string. (Although not shown here, the ex\u00adpression C = B renames attribute B as \nC; input attributes are removed from the output relation simply by not explicitly specifying them as \noutput attributes.)  4.4 Business Logic: Exception Handling Under any application design paradigm, errors \ncan be di\u00advided into two classes: those that can be detected before runtime, and those which are detected \nonly at runtime. The vast majority of WebRB errors can be detected while design\u00ading the application, \nbefore running it. WebRB uses database meta-data to validate that the names and types of relation at\u00adtributes \nassociated with persistent model blocks are correct. All block interconnections carry information about \ntheir re\u00adlation headers the set of attribute names and types which .ow on the connection. This enables \nthe WebRB design tools to validate, before runtime, that output connections are com\u00adpatible with the \ninputs that they are connected to. For exam\u00adple, if the relation header of the insert input to the INSERT \nDB block does not match the relation header of the block s model, the error is reported to the developer \nand the page\u00addesign will not be executed. Similarly, attempts by a block to access attributes that do \nnot actually appear in the input relation header, can be detected at design time. Of course, user-provided \ninput cannot be validated be\u00adfore the application actually executes. Some attribute type\u00admismatches occur \nonly for speci.c data-values and cannot be detected at design-time. For example, in the example of Section \n4.3, D = TOINT(STR), the string 4t2 is not a le\u00adgal string version of any integer, and therefore cannot \nbe converted to an integer. WebRB therefore needs an excep\u00adtion model through which developers can specify \nhow they want the runtime to deal with such errors. Because WebRB is a declarative data-.ow language, \nit cannot use the excep\u00adtion model of imperative languages such as C++ and Java. Like other declarative \nlanguages, WebRB does not have a .ow of control that can be altered by an exception. Our solution is \nbased on a Replacement Model approach [25] in which an expression that is supplied with invalid inputs \nre\u00adturns a developer-supplied value as its output. This implies that an expression always has an output \nthat it can supply to other blocks. WebRB inserts the developer-supplied er\u00adror value into the output \nattribute whenever an error oc\u00adcurs. As a convenience to the developer, the output rela\u00adtion of a FUNCTION \nblock optionally associates an error attribute with each developer-speci.ed output attribute. Er\u00adror \nattributes are string-typed, and contain the WebRB mes\u00adsage generated when the error occurred, e.g. Invalid \ninteger value . As a further convenience, FUNCTION blocks have a boolean-relation error pin whose value \nis TRUE whenever the output relation contains one or more tuples with an error value. For example, consider \nagain Figure 9. After a search, the user is given the option to purchase a speci.ed quantity of one of \nthe products in the search results. The business logic for this operation is contained in an EMBEDDED \nPAGE block (Buy, Figure 12). The Buy block has two inputs: ItemNoQty (the item number and quantity from \nthe HTML-TABLE on the Search page, and the buy enable, which is a boolean relation indicating that the \nBuy button was pressed.  Since the Quantity comes from a text-entry .eld, the value received by the \nBuy block is a string. This is converted to an integer by the FUNCTION block on the center left. If the \nQuantity that the user entered represents a valid integer, the error pin from the FUNCTION block will \nbe false. The NOT block in the Buy block design is used to invert the sense of the error pin ( no error \n), and fed to a JOIN block along with the Buy button signal. A JOIN between two boolean relations is \nthe same as a logical AND of the two values. Thus, the item and quantity are inserted into the CART table \nif and only if there is no conversion error and the Buy button was pressed. This value is also fed to \nthe success output pin from the Buy block. If an error occurs during the conversion when the Buy button \nis pressed, a TRUE value is fed to the error output pin from the Buy page. Another FUNCTION block (top \ncen\u00adter in Figure 12) builds an error message string, using the function TEXT = CONCAT( INVALID QUANTITY: \n, QTYS-TRING). The message is fed to the errorMsg output from the Buy page.  4.5 Session Data Web applications \noften maintain state between HTTP re\u00adquests, usually called session data. WebRB does not have a built-in \nmechanism for handling session data. However, ses\u00adsion data may be kept in a database table with the \nrest of the application data. In order to support this approach, WebRB will add a mechanism for accessing \nthe session identi.er. This could be done by adding a block whose output is the current session identi.er. \nWhile session data is not shared by concurrent users, and is therefore not usually considered a concurrency \nissue, in fact session data may be accessed by concurrent browser requests from the same user. By using \ndatabase tables to implement session data, concurrent browser requests can be safely supported.  5. \nEvaluation In this section we substantiate our claim that WebRB can sig\u00adni.cantly improve developer productivity \nfor the subset of web-applications for which it s designed: multi-page inter\u00adactive applications that \nprimarily read and update relational databases and include moderate amounts of business logic. We begin \nby noting how the WebRB data-.ow language, and its consistent use of a relational API, allows developers \nto easily express typical web-application tasks. For example, consider a typical requirement to display \nthe contents of a database table. The imperative-embedding approach (see Figure 2) requires that developers \n.rst issue the appropriate query; and then iterate through the result-set, displaying one tuple and \nthen one attribute at a time. Figure 1B shows how a WebRB developer simply wires the database table \n(via a READ DB block) to the HTML-TABLE: the relation .ows on the wire with the HTML-TABLE extracting \nthe attributes it s interested in on the .y . The task of acquiring and iterating through the result-set \nis left to the WebRB runtime. As shownbythe use of JOIN and WHERE blocks in the lower-left of Figure \n9, the simplicity of using relational data .ow is maintained even when a developer must transform databetweenthedatabasesourceandthe \nHTML-TABLE sink.  In Section 5.1, we compare WebRB to well-known al\u00adternatives for writing web-applications. \nWe do this using the Cognitive Dimensions [26] (CD) approach, following the outline used in [24]. Cognitive \nDimensions allows us to quickly evaluate the usability of information-based ar\u00adtifacts without doing \na detailed analysis. In some cases we have identi.ed de.ciencies with WebRB. Unless otherwise noted, \nwe plan to address these as time permits. In Sec\u00adtion 5.2 we address speci.c issues of missing WebRB \nfunc\u00adtion. 5.1 Feature Analysis For each feature, we contrast the WebRB approach with a standard imperative-embedding \napproach, used by PHP, Java, and other languages to generate dynamic web pages. We also mention other \nsystems, where a speci.c contribution is noteworthy. Abstraction Gradient: The WebRB language uses (Sec\u00adtion \n2) a relatively small number of abstractions, including relations, attributes, blocks, pins, and wires.The \nWebRB im\u00adplementation (Section 3) adds a moderate number of built-in blocks, including algebra blocks \n(JOIN, NOT, FUNCTION, and WHERE); constant blocks, database blocks (READ DB, INSERT DB, DELETE DB,and \nUPDATE DB); widget blocks (TEXT-ENTRY, TEXT-LABEL, HTML-TABLE,and BUTTON); and PAGE TRANSITION. WebRB \nallows developers to de\u00ad.ne their own new abstractions (user-de.ned blocks). CD characterizes such behavior \nas abstraction tolerant.  We note, however, that although many developers have already worked with relational \ndatabases, they have proba\u00adbly not worked with formal relational algebra even though it is the basis \nfor relational database systems. Thus, the use of relational algebra in WebRB represents a signi.cant \nab\u00adstraction gradient for many developers. Imperative embedding approaches include the abstrac\u00adtions \nof the basic language (e.g., variables, statements, ex\u00adpressions, control structures, arrays, exceptions, \nclasses, methods), as well as abstractions introduced by the libraries used to build the application. \nFor example, each language has a library which is used for database access (e.g., PDO for PHP, JDBC for \nJava). Other abstractions may be used for HTML page construction, such as Smarty [27] for PHP, and JSP \nfor Java. Closeness of Mapping: WebRB provides excellent closeness\u00adof-mapping for the GUI portion of \napplications. In the de\u00adsign view, widgets are shown in the same location and with the same appearance \nthey will have in the runtime view. Also, the WebRB wires provide a close visual mapping to the data.ow \nof the system. The closeness-of-mapping for the database tables and al\u00adgebra blocks is less clear. Although \nthey provide a close mapping to relational algebra, relational algebra may not map well to the problem \ndomain. For example, a search operation requires the use of a JOIN block, and optionally a WHERE block. \nAlthough this makes sense from the stand\u00adpoint of relational algebra, it does not map closely to the \ndesired search operation. For imperative embedded approaches, closeness of map\u00adping for web application \nGUIs is typically poor. The imper\u00adative code is generating HTML, which does not have a close mapping \nto the GUI that will be seen in the web browser. Vi\u00adsual design tools, such as Dreamweaver, help with \nthis prob\u00adlem, but typically have trouble with generation of dynamic pages, and round-tripping between \nvisual and imperative de\u00adsigns. Developers are often forced to do a .rst-cut using the visual design \ntool, and then manually modify the result as they add business logic with imperative code. Imperative \naccess to databases also has poor closeness of mapping. Virtually all database access is initiated via \nSQL, which does not map closely to the database design. Read operations return a result set, which is \naccessed a single cell at a time using function/method calls. Tools such as DDS-Pro let the developer \nwork in a more closely mapped domain. Consistency: WebRB attempts to be very consistent. All blocks, \npins, and wires use a relation data-type, and any in\u00adput may be connected to any output. Imperative languages \nhave varying degrees of consistency, but typically a devel\u00adoper cannot infer anything about unknown parts \nof the lan\u00adguage from the known parts. Diffuseness/Terseness: WebRB has many of the diffuseness problems \ndescribed in [24]. In particular, the visual repre\u00adsentation of relational algebra and model components \nre\u00adquires more design-screen real estate than comparable text\u00adbased languages (e.g. SQL). However, WebRB \ns EMBEDDED PAGE blocks mitigate this problem somewhat, since devel\u00adopers can use them to factor complexity \nof a page-design. Imperative languages such as PHP and Java are generally considered to be less diffuse \nthan visual languages such as WebRB. Error-Proneness: We have identi.ed some common error scenarios with \nWebRB designs. For example, some of the widgets (e.g. TEXT-ENTRY and TEXT-LABEL) use a default attribute \nname, and developers forget to change it to what they want to use. However, such errors are quickly detected \nby the WebRB validation algorithms. Imperative languages are well known for providing op\u00adportunities \nfor slips (where the developer ends up doing something they didn t mean to do). Well-known examples include \nmistyped variable names and mismatched parenthe\u00adses or braces [24]. Hard Mental Operations: WebRB has \na lower demand on cognitive resources than non-visual systems. For example, visible wires are used to \nroute data to and from the widgets. In contrast, many non-visual systems require the developer to remember \nthe association between widgets and (separate) code. On the other hand, many developers may .nd the use \nof relational algebra to be a hard mental operation. The popu\u00adlarity of visual query systems [18] indicates \nthat the visual domain is popular for at least some relational operations. However, the use of relational \nalgebra for all controller operations may be problematic. Using imperative code to generate GUIs is certainly \na hard mental operation. The developer must continually map between the HTML domain and the visual domain. \nVisual design tools are a considerable improvement. Hidden Dependencies: WebRB contains hidden dependen\u00adcies, \nwhich arise from the hierarchical composition style of the design environment. At a local level (intra-page), \nit is easy to see dependencies between blocks, because depen\u00addent blocks must be connected by wires. \nHowever, between pages, it is more dif.cult to see dependencies. For exam\u00adple, there is no automated \nway to .nd out which blocks ref\u00aderence a particular block. Also, WebRB allows multiple in\u00adstances of \ndatabase blocks to reference the same database table. Thus, it is not obvious that the input to an UPDATE \nDB block on Page A affects the next output of a READ DB block on Page B. These limitations can be addressed \nby enhance\u00adments to the development system. Imperative languages such as PHP and Java certainly suf\u00adfer \nfrom hidden dependencies. In the language itself, there is no way to determine the inbound linkages (e.g., \nthere is no way to determine who calls a function). This is typically addressed by design tools such \nas Eclipse [28], which can search for dependencies and display them for the developer. Premature Commitment: \nLike most visual programming languages, WebRB suffers from premature commitment with regard to layout \n[24]. We address this by making it very easy to move blocks (low viscosity). Premature Commitment also \narises at table creation time, because all the attributes and their types must be speci.ed, and cannot \nbe changed without deleting and recreating the table. Non-visual imperative languages also suffer from \nprema\u00adture commitment. Typical workarounds are decoupling (in\u00adterim versions, or Plan to throw one away \n[29]), and leav\u00ading place-holders in the code and going back later to .ll them in later [24]. Progressive \nEvaluation: WebRB has excellent support for Progressive Evaluation. The current page displayed in the \neditor may be validated at any time. Any page without fatal validation errors may be immediately executed \nat any time. With imperative languages, progressive evaluation is de\u00adpendent on the development tools \nin use. High-end IDEs such as Eclipse support incremental compilation and quick launching of applications. \nSecondary notation: WebRB provides some support for secondary notation. Developers may place and group \nthe blocks on their designs to make the function more appar\u00adent. WebRB also supports annotations, which \nconsist of text strings that are visible on the design page, but are not visible on the runtime page. \nImperative text languages provide some opportunities for secondary notation. The most obvious example \nis comments (escape from formalism) and indentation (redundant recod\u00ading) [26]. Opportunities for more \nexpressiveness are limited by the one-dimensional nature of text coding. Viscosity: WebRB has low viscosity \nfor many types of changes. For example, blocks may easy by moved by drag\u00adging with the mouse, and any \nattached wires will rubber band to follow the block. Additional features would be helpful for reducing \nviscosity. For example, the ability to select a set of blocks and convert them to an embedded block (refactoring), \nand the ability to move multiple selected blocks in unison. For imperative text languages, the raw viscosity \nis fairly high. For example, changing the name of a variable requires .nding all the uses of that variable \nand changing them. Refactoring a piece of code into a separate func\u00adtion/method requires cutting, pasting, \nand a lot of cleanup work. For GUIs described by text (e.g. HTML), the viscosity is even higher, because \nediting takes place in the non-visual domain. Design tools (IDEs) are vital for reducing viscosity in \ntextual languages. Visibility: WebRB provides good visibility at the page level, since all the blocks \nand data .ows (wires) are easily seen. Many of the blocks provide a visual indication of their property \nsettings. For example, database blocks display their table name and attribute names, FUNCTION blocks \ndisplay a subset of their mapping function(s), and WHERE blocks display their condition expression. However, \nsome blocks potentially have so many properties that displaying all of them would require too much screen \nreal-estate (e.g. there is no limit on how many mapping functions a FUNCTION block may have). Construction \nof GUIs with imperative code often leads to visibility problems. For example, GUI event-handling is often \nimplemented by attaching small pieces of code to GUI widgets (e.g. the onclick attribute in HTML). Crucial \npieces of an application s function are thus diffused, making it hard to modify the application. Visual \ndesign tools do not help much with this problem, because they do not have a good approach for managing \nthis complexity.  5.2 Areas For Improvement WebRB is both an approach for building web-applications \n using a visual, data-.ow, relational DSL and an implemen\u00adtation [22] of this approach. Although our \nimplementation is certainly missing certain features, the examples of Sec\u00adtion 4 show that it already \ncan be used to write non-trivial web-applications. We therefore distinguish between missing features \nthat can easily be added to the implementation and features that require redesigning WebRB itself. Modifying \nthe visual presentation: Developers can stati\u00adcally position GUI widgets at the desired x, y locations. \nThe property editor in WebRB s visual editor gives develop\u00aders control of some aspects of a web-page \ns GUI, such as a page s foreground and background colors. However, a de\u00adveloper cannot specify the color \nof non-text GUI widgets such as table elements, nor control style (fonts, or location) dynamically. We \nbelieve that, in a web-application environ\u00adment, visual presentation issues should be addressed with \nHTML/CSS technologies. Thus, by allowing developers to supply their own style-sheets, visual presentation \nissues that are orthogonal to WebRB can be solved using a familiar tech\u00adnology. More GUI blocks: WebRB \ncurrentlyincludes HTML-TABLE, BUTTON, TEXT-ENTRY and TEXT-LABEL GUI blocks, but does not include image \nor link blocks. We plan to sup\u00adport these blocks as well using the same approach in which we wrap a relational \nAPI around a HTML widget s interface. Integration with AJAX-based frameworks: WebRB applica\u00adtion deployment \nis done through a server loading individ\u00adual page-designs; managing inter-page navigation and data\u00ad.ow; \ninterrogating a page-design for its HTML; and sending the HTML to be rendered in a standard web-browser \n(Sec\u00adtion 3.2). In this approach, the web-browser does not use AJAX techniques [30] such as caching application \nstate or executing business logic. We note that AJAX techniques are primarily concerned with function \nplacement. For example, many techniques move function into the browser to improve response time. WebRB \nis primarily concerned with applica\u00adtion function, not placement, and thus is largely orthogonal to AJAX. \nThus WebRB could incorporate AJAX concepts without requiring fundamental changes. For example, block \nexecution could be done in the browser. Interfacing with imperative code: A more fundamental weakness \nof WebRB is that it s self-contained and has no interface to arbitrary imperative code (e.g., business \nlogic written in PHP and Java). Although WebRB s use of rela\u00adtional algebra and tuple-expressions does \nsupport applica\u00adtions with small or moderate amounts of business logic, completely restricting access \nto other code is problematic. To address this restriction, we .rst observe that the dif.\u00adculty does not \nlie in how the visual WebRB environment can interface to non-visual function. WebRB blocks such as the \npersistent database blocks very effectively wrap non\u00advisual function. Instead, the issue is how can a \nfunctional or declarative programming language such as WebRB interface with an imperative programming \nlanguage. Our (unimple\u00admented) solution to this problem is to allow imperative code in a WebRB page-design \nso long as it is encapsulated in a functional and relational API. As shown by the persistent database \nblocks, this can be done even for operations that change system state as long as well-de.ned relational \nin\u00adputs and outputs can be abstracted from the imperative code. Although this approach does not allow \narbitrary pieces of imperative code, it signi.cantly relaxes the all-or-nothing WebRB constraint.  6. \nSummary In this paper we identi.ed a ubiquitous set of applications that we termed relational web-applications \n. These are dy\u00adnamic web-applications that: 1. Read relational databases and present the data in a GUI; \n 2. Update relational databases based on a user s interaction with the GUI; 3. Perform transformations \nof the relational data which re\u00adquire only simple or moderately complex business logic.  We identi.ed \na number of problems with imperative-embedding the most popular approach for constructing relational \nweb\u00adapplications, and introduced WebRB as a visual domain\u00adspeci.c language that solves these problems. \nBecause We\u00adbRB is designed for, and limited to, construction of relational web-applications, it is able \nto successfully use visual pro\u00adgramming techniques to improve productivity without suf\u00adfering from the \nscaling issues that are often associated with visual programming languages. WebRB blocks have the right \nlevel of abstraction for common database read and write op\u00aderations, and its use of relational algebra \nprovides a good .t between moderately complex business logic and the ap\u00adplication s data. Using a detailed \nset of web-page examples, we substantiated these claims by evaluating WebRB across a large number of \nlanguage dimensions. Also, we showed that WebRB provides suf.cient functionality to implement any relational \nweb-application with moderately complex busi\u00adness logic. We have not yet done any analysis of the runtime \nper\u00adformance of WebRB. However, we feel that 1) productivity improvements will offset the additional \nruntime costs; 2) it should be possible for WebRB designs to be compiled to ef.cient runtime constructs; \nand 3) much of the work can be pushed down to the database. In the current implementa\u00adtion [22], there \nare no noticeable response-time delays, even though the runtime implementation has not been optimized \nat all. References [1] David McFarland. Dreamweaver MX 2004: The Missing Manual. O Reilly Media, 2003. \nISBN: 0596006314. [2] IBM Rational Application Developer for Websphere Soft\u00adware Version 6.0. http://www-8.ibm.com/software/ \nincludes/pdf/rat_app_dev_LoRes.pdf, 2006. Publica\u00adtion number GC34-2464-00. [3] Ruby on rails. http://www.rubyonrails.org/, \n2007. [4] C. J. Date and Hugh Darwen. A Guide to SQL Standard. Addison-Wesley, 4rth edition, 1996. ISBN: \n0201964260. [5] Wikipedia. Event loop. http://en.wikipedia.org/w/ index.php?title=Event_loop&#38;oldid=89348024, \n2006. [6] C.J. Date and H. Darwen. Databases, Types and the Relational Model (3rd Edition). Addison-Wesley, \nBoston, MA, 2006. [7] Peter Van Roy and Seif Haridi. Concepts, Techniques, and Models of Computer Programming. \nMIT Press, Cambridge, Mass, 2004. [8] Antony J. T. Davie. Introduction to Functional Programming Systems \nUsing Haskell. Cambridge University Press, 1992. [9] J. Gray and A. Reuter. Transaction Processing: Concepts \nand Techniques. Morgan Kaufmann, San Francisco, CA, USA, 1993. [10] Brian T. Bennett, Bill Hahm, Avraham \nLeff, Thomas A. Mikalsen, Kevin Rasmus, James T. Ray.eld, and Isabelle Rouvellou. A Distributed Object \nOriented Framework to Offer Transactional Support for Long Running Business Processes. In ACM Middleware, \npages 331 348, 2000. [11] Wayne Citrin, Michael Doherty, and Benjamin Zorn. Formal semantics of control \nin a completely visual programming language. Proc. Symposium on Visual Languages, pages 208 215, 1994. \n[12] P.T. Cox, F.R. Giles, and T. Pietrzykowski. Prograph: a step towards liberating programming from \ntextual conditioning. IEEE Workshop on Visual Languages, pages 150 156, 1989. [13] M.M. Burnett and \nA.L. Ambler. A declarative approach to event-handling in visual programming languages. Proc. IEEE Workshop \non Visual Languages, pages 34 40, 1992. [14] James Duncan Davidson. Learning Cocoa with Objective-C, \nSecond Edition. O Reilly, Sebastopol, CA, USA, 2002. [15] JavaServer Faces Technology. http://java.sun.com/ \njavaee/javaserverfaces/, 2007. [16] MyEclipseIDE. http://www.myeclipseide.com/, 2007. [17] M. M. Zloof. \nQuery-by-example: a data base language. IBM Systems Journal, 16(4), 1977. [18] Tiziana Catarci, Maria \nF. Costabile, Stefano Levialdi, and Carlo Batini. Visual query systems for databases: A survey. Journal \nof Visual Languages &#38; Computing, 8(2), April 1997. [19] Database design studio. http://www.dds-pro.com/ \nproducts/main.html, 2006. [20] Relational Persistence for Java and .NET. http://www. hibernate.org/, \n2007. [21] Enterprise Javabeans Technology. http://java.sun.com/ products/ejb/, 2007. [22] IBM alphaWorks \nServices: Web Relational Blocks. http: //services.alphaworks.ibm.com/webrb/, 2006. [23] M.M Burnett, \nM.J. Baker, C. Bohus, P. Carlson, S. Yang, and P. Van Zee. Scaling up visual programming languages. Computer, \n28:45 54, March 1995. [24] T. R. G. Green and M. Petre. Usability analysis of visual programming environments: \na cognitive dimensions framework. J. Visual Languages and Computing, 7(2):131 174, 1996. [25] S. Yemini \nand D. Berry. A modular veri.able exception handling mechanism. ACM Transactions on Programming Languages \nand Systems (TOPLAS), 1985. [26] Thomas Green and Alan Blackwell. Cognitive dimensions of information \nartefacts: a tutorial. http://www.cl.cam.ac. uk/~afb21/CognitiveDimensions/CDtutorial.pdf, October 1998. \n[27] Smarty : Template engine. http://smarty.php.net/, 2007. [28] Eclipse Project. http://www.eclipse.org/eclipse, \n2006. [29] Frederick P. Brooks. The Mythical Man-Month: Essays on Software Engineering, 20th Anniversary \nEdition. Addison-Wesley Professional, 1995. [30] Justin Gehtland, Dion Almaer, and Ben Galbraith. Pragmatic \nAjax: A Web 2.0 Primer. Pragmatic Bookshelf, 2006.  \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Many web-applications can be characterized as \"relational\". In this paper we introduce and evaluate <i>WebRB</i>, a visualdomain-specific language for building such applications. <i>WebRB</i> addresses the limitations of the conventional \"imperative-embedding\" approach typically used to build relational web-applications. We describe the <i>WebRB</i> language, present extended examples of its use, and discuss the <i>WebRB</i> visual editor, libraries, and runtime. We then evaluate <i>WebRB</i> by comparing it to alternative approaches, and demonstrate its effectiveness in building relational web-applications.</p>", "authors": [{"name": "Avraham Leff", "author_profile_id": "81100102554", "affiliation": "IBM T. J. Watson Research Center, Yorktown Heights, NY", "person_id": "P23196", "email_address": "", "orcid_id": ""}, {"name": "James T. Rayfield", "author_profile_id": "81100261155", "affiliation": "IBM T. J. Watson Research Center, Yorktown Heights, NY", "person_id": "P133317", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297048", "year": "2007", "article_id": "1297048", "conference": "OOPSLA", "title": "Webrb: evaluating a visual domain-specific language for building relational web-applications", "url": "http://dl.acm.org/citation.cfm?id=1297048"}