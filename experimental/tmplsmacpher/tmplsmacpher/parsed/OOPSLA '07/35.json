{"article_publication_date": "10-21-2007", "fulltext": "\n No Ifs, Ands, or Buts Uncovering the Simplicity of Conditionals Jonathan Edwards MIT Computer Science \nandArti.cial Intelligence Lab edwards@csail.mit.edu Abstract Schematic tables are a new representation \nfor conditionals. Roughly a cross between decision tables and data .ow graphs, they represent computation \nand decision-making orthogonally. Theyunify the full range of conditional con\u00adstructs, from if statements \nthrough pattern matching to poly\u00admorphic predicate dispatch. Program logic is maintained in a declarative \ncanonical form that enforces completeness and disjointness among choices. Schematic tables can be used \neither as a code speci.cation/generation tool, or as a self-contained diagrammatic programming language. \nThey give program logic the clarity of truth tables, and support high-level direct manipulation of that \nlogic, avoiding much of the mental computation demanded by conventional con\u00additionals. Categories and \nSubject Descriptors D.2.2[Software En\u00adgineering]: DesignTools andTechniques Decision tables; D.2.6[Software \nEngineering]: Programming Environments; D.3.3[Programming Languages]: Language Constructs and Features \ncontrol structures, polymorphism; D.1.7[Pro-grammingTechniques]:Visual Programming General Terms Languages \n Keywords decision tables, control structures, polymor\u00adphism, visual programming, refactoring 1. Introduction \nItisdueto ourchoosingto acceptorreject thatwedo not see the true nature of things. Seng-ts an, third \nZen patriarch Conditionals are the backbone of a program. Theyprovide the essential ability to execute \ndifferent code in different Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page.To \ncopyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 07, October 21 25, 2007, Montr \u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; 2007ACM \n978-1-59593-786-5/07/0010...$5.00 situations, and they establish much of a program s struc\u00adture. The \nhardware-given conditional branch instruction has evolved into a variety of programming language constructs: \nnested if-then-else blocks; switch statements; pattern match\u00ading in functional languages; and polymorphism1 \nin object\u00adoriented languages. One reasonforthisvarietyof conditionalsisthatthemost basic and general \none, the if-statement, is not completely sat\u00adisfactory. The structure of nested if-then-else blocks forms \na treeof decisions which wemust mentally compilefrom our informal understanding. Conversely, when we \nread nested if-then-else blocks we must decompile the tree back into a higher-level understanding.Walking \ndown the tree, espe\u00adcially downelse-branches, quickly becomes disorienting and forces us to reason with \ndeMorgan s law. Making decisions in the wrong order can lead to duplication of subsequent de\u00adcisionsacross \nbranches.Weoftenhavetorefactorthetreeto reduce duplication or to .nd a single resting spot for some new \nlogic. It is hard to tell whether a decision tree covers all possible combinations of cases, and it is \nhard to tell how different trees logically overlap. Graphical representations of decision trees, such \nas .owcharts andNassi-Shneiderman diagrams [30], have the same problems. Studies of the dif.\u00adcultiescausedby \ncontrol structures are surveyedinPaneand Myers [32], p.30 31. Newer forms of conditionals (switch statements, \npattern matching, and polymorphism) respond to these problems in similar ways. They partition code into \ndistinct cases and declaratively specify the conditions in which to invokethem. Declarative conditions \ntie the cases to data de.nitions, and allow compile-time analysis to detect errors and offer as\u00adsistance \nin an Interactive Development Environment (IDE). The compilertakes careofgeneratinganexecutable decision \ntree. However none of these constructs are .exible enough to completely supplant if-statements, which \nare still needed for the ad hoc glue logic which does not sort out along any simple dimension. This paper \nintroduces schematic tables, a new representation that attempts to be .exible enough to replace if-statements, \nand declarative enough to replace pat\u00ad 1Throughout this paper, polymorphism will be taken to mean subtype \npolymorphism. tern matching and polymorphism, while making all of them easier to understand, and easier \nto manipulate. Truth tables have long been used to express logic more clearly than symbolic propositions. \nA number of tabular speci.cation languages have been found bene.cial [16, 18, 24]. Decision tables [34, \n39] have been used both for speci.\u00adcations [13] and asaprogramming language feature [36, 38]. Figure \n1 shows an example of a decision table from Kirk [22]. Decision tables express complex logic clearly, \nbut suf\u00adfer from a number of limitations that have impeded their adoption. Composing decision tables \nleads to a combina\u00adtorial explosion, and worse, the tacit duplication of logic and decisions. The response \nof splitting and nesting tables re-establishes the tree structure of if-statements, with all its disadvantages. \nTables require that exactly one column be true in all cases, a constraint that can be hard to main\u00adtain.Astudy \n[15] comparing decision tables to if-statements found the former to be preferredbut less accurate. Another \nstudy [41] found decision tables inferior to English struc\u00adtured by if-statements for comprehension tasks. \nIt is inter\u00adesting thata study [14] comparing textual and graphical pro\u00adgramming notations used an apparatus \nsimilar to decision tables as the reference point. Overshadowing these issues is the fundamental limitation \nof decision tables: they are not complete programs. We must add code to evaluate condi\u00adtions and execute \nactions, and we must structure that code to interfacewiththetable.The programistorn betweentwo worlds. \nSchematic tables attempt to generalize decision ta\u00adbles into a self-suf.cient programming language. Thekeyideasof \nschematictables are: 1. Computation and logic are represented orthogonally, in theverticaland horizontal \ndimensionsofa table, separat\u00ading their different semantics. 2. The two dimensions of tables provide \nan extra degree of freedom over textual syntax for structuring code, and reduce the need to split up \nrelated code. 3. Maintenance of a single logical invariant (partitioning), drives high level semantic \ntransformations that reduce programming effort. 4. Schematic tables are canonical, in a certain sense \nrepre\u00adsenting equivalent programs equivalently. Diagrammatic notation is made feasible by eliminating \nmanual layout. The need for refactoring is reduced. 5. All forms of conditionals are uni.ed, from ad \nhoc if\u00adstatements to pattern matching and polymorphic predi\u00adcate dispatch.  6.A declarative language \nof predicates ties together the notions of types, assertions and conditionals. Schematic tables have \nbeen developed within the Subtext project [10], whose goal is to make programming easier by altering \nthe representation of programs. However theymay be applicable apart from Subtext, asa speci.cation language \nor code generator that goes deeper into implementation de\u00adtails than decision tablesand tabular speci.cation \nlanguages. Theymay also be useful as a visualization of conventional code within an IDE that maps table \nchanges into code refac\u00adtorings and transformations. Such applications are left for future work. This \npaper will instead present schematic ta\u00adblesintheir fullestform,aspartoftheSubtext language,but will \nonly discuss Subtextin sofar asis necessary. Schematic tables have not yet been implemented, and some \ndetails of their design are unsettled. The diagrams in this paper are paper prototypes from the user \ninterface de\u00adsign of Subtext 2. Theyhave been placed at the end of the paper so that theycan be torn \noffand followed separately (or viewedina separate window).Avideo demoof the imple\u00admentation will be made \navailable at http://subtextual. org/subtext2.html. Color is an important visual aid in the user interface \n a full color version of this paper can be found at http://subtextual.org/OOPSLA07.pdf. Schematic tables \nwill be presented in stages, starting at the level of decision tables, then adding in turn the capabilities \nof functional programming and polymorphism. The presen\u00adtation will focus on the improvements to the programming \nexperience. 2. Simple Schematic Tables The process of constructing instructiontables should be very fascinating. \nThere need be no real danger of it ever becoming a drudge, for any processes that are quite mechanical \nmay be turned over to the machine itself. Turing [40] We startby introducinga simpli.ed formof schematic \ntable comparable in power to decision tables,but with advanced IDE support that keeps tables in a canonical \nform free of logical errors. The programmer is freed from doing Boolean algebra. Figure2shows someJava \ncodeandthe correspond\u00ading schematic table. The important features of this table are: 1. Each row of the \ntable corresponds to a variable in the program, which is de.ned in the .rst column in blue. Each column \nof the table states what to do in a certain situation. 2. The second column corresponds to the Java \nconditional if (a &#38; b) x = 1;. The cells for a and b contain gray boxes labeled y which are called \npredicates. Predicates represent a test applied to their row s value. The y pred\u00adicate tests whether \na Boolean variable is true, n tests for false,anda blankcell doesn tcare.The second columnis true when \nall its predicates are true, in other words when both a and b are true. 3. The cell for x in the second \ncolumn contains the number 1, which is called a value. When a column is true, the  valuesinthecolumnare \nassignedtotheirrow svariables, which in this case sets x=1. 4. The third column corresponds to the Java \nconditional if (!a | !b) x =2;.To express this disjunction a verti\u00adcal dotted line divides the predicates \nwithin the column into subcolumns. The entire column is considered to be true whenever it contains a \nsubcolumn in which all the predicates are true.The left subcolumn contains only the predicate n on the \nvariable b, which tests that it isfalse. The right subcolumn contains the predicate n on thevari\u00adable \na, testing that it is false. Thus the column is true when either a or b isfalse, in which case x is assigned \n2. Note that values belong to the entire column, not sub\u00adcolumns. 5. The division of columns into subcolumns \nis known in logic as disjunctive normal form. Every predicate has a complementary form that is its negation \n(e.g. y and n). The possibly negated predicates within each subcolumn are conjoined (logical AND) and \nthen all of the sub\u00adcolumns are disjoined together (logicalOR). The signif\u00adicance of disjunctive normal \nform is that it can represent all possible logicalpropositions.Asimilar tabular repre\u00adsentationof queriesis \npresentedinPane and Myers [31]. The bene.t of the table is that it clearly reveals the condi\u00adtions under \nwhich x=2,whereastheJavacodeleavesitupto ustowork outthe logicofthe else block using deMorgan s law: \n\u00ac(a.b)=(\u00aca.\u00acb). Thatmay notbeanundueburden in this trivialexample,but as we will seeeven slightly more \ncomplex conditionals can quickly lead to bewilderment. Unfortunately truth tables do not absolve us of \ndoing mental Boolean algebra. They merely shift theburden onto the construction and maintenance of the \ntable, which can re\u00adquire just as much effort, and be as error-prone. As men\u00adtioned previously, it is \nquite easy to build tables that have gaps or inconsistencies in their logic. The same problem arises \nin the Java code of Figure 3, which is a transliteration of the table. The conditions for each case are \nmade explicit, butwiththe maintenanceburdenofensuringthatexactlyone of the if statements executes in \nall cases. It seems that we arefacedwitha dilemma:havingtodo mental Booleanal\u00adgebra either when we read \nour code or when we change it. Schematic tables circumvent this dilemma by doing the cal\u00adculations automatically \nwhile editing within an IDE. After all, it is absurd to be doing Boolean algebra in our head when there \nis a computer sitting right in front of us. 2.1 Logical editing It has long been realizedthat decision \ntables can be automat\u00adically validated [21, 33], and some contemporary products [25, 37] do so interactively, \nimmediately revealing errors. Schematic tables instead provide high-level editing opera\u00adtionsthatkeepthetablefreeofgapsandoverlapsatall \ntimes. Errors are essentially automatically .xed, although the pro\u00adgrammer may need to makesubsequent \nadjustments to home in on a desired result. As an example, we will show how the tablein Figure2couldhavebeen \ncreated. 1.We will start with the tablein Figure 4(a), which uncon\u00additionally assigns x=2. We need to \nadd logic to assign x=1 when a and b are true.A new column is introduced via a menu operation, resulting \nin 4(b). 2. Next we put y predicates into the cells for a and b in the column witharight-click menu that \nsuggests possible predicates2, resulting in 4(c). 3. Thevaluetobe assignedto x is editedinto the proper \ncell in 4(c). Assigning x creates an overlap con.ict with the existing assignment, which is automatically \nresolved by creating a new column restricted to the complement of the con.icting one, as shownin 4(d). \n The IDE calculates deMorgan s law for us in order to keep the table free of overlaps and gaps. The \nprecise in\u00advariantisthatall columns assigningthe samevariable must be logically disjoint (no overlaps), \nand together must com\u00adpletely cover all possible cases (nogaps). These two prop\u00aderties combined are called \npartitioning.3 By automatically maintaining partitioning, the programmer is freed of the drudgery of \nBoolean algebra, whether they are reading or writing code.  2.2 Transactional editing Changing program \nlogic often involves a series of coordi\u00adnated edits in different places. While making these edits we \nmay temporarily disrupt the program, requiring compensat\u00ading edits elsewhere. Schematic tables supporta \ntransactional editingmodethatallowsustoperformaseriesof edits while visualizing their cumulative impact, \ndeferring commitment until we are satis.ed. For example, Figure 5 shows some Java code and its corresponding \ntable. Suppose that we discover a bug: the cases when b and c are true should set x=3. We want to preserve \nthe existing behavior in all other cases. Further, we want to make this change without copying the assignment \nx=3, since that might cause undesirable code duplication. Skeptical readers are invited to solve this \nmundane problem before reading ahead. 1. Sincewewanttoaddnewcasesthatassign x=3,we usea mouse-menu operation \nto insert a new subcolumn in the right-hand column, resulting in Figure 6(a). This edit is being performedin \nthe transactional mode that displays the cumulative impact of a series of changes and allows the programmer \nto either complete or cancel them. The red box around the new subcolumn indicates that it is a set of \nstates being added into the column. Since the 2The suggestions are based on the variable s type, to be \ndiscussed in \u00a73. 3Observe that Dijsktra s guarded commands [8] useoverlappingtoexpress nondeterminacy, \nwhereas schematic tables are disjoint and deterministic. subcolumn contains no predicates, it is always \ntrue, and thus con.icts with all other columns and subcolumns. All of them are X-d out, indicating that \nthey are states currently marked to be subtracted by the transaction. 2.We continueby limiting the tentative \nnew subcolumnto the states of interest by inserting y predicates on b and c as requested. The result \nis 6(b), which has divided up the other two columns to show precisely which states now need tobe subtracted \ntokeep the table partitioned. This information may be important: it tells us, case by case, what the \nimpact of our changes will be on the old logic. 3. Clicking on the green arrow completes the transaction, \ndeleting the X d out cases and leaving us with the .nal solution in 6(c). The solutioninJavaisshowninFigure7,withthechangesin \nbold. The author s informal sampling has found no one (in\u00adcluding himself) who could immediately get \nthis right. The schematic table makes the change straightforward, turning over the mechanical calculation \nto the machine itself. 2.3 Canonicity Schematic tables havean important property: theyare canon\u00adical. \nThere is only one way to express each different mean\u00ading4. The only control the programmer has over the \ntable s layout is the order in which the variables are de.ned in the left hand column (and similar orderings, \nsuch as the order of enumeration constants). These orderings are extended to columnsina modi.edlexicographical \nmanner,the detailsof which willbe omitted. The importantfactis thatthe pred\u00adicates within columns are \nreduced to Blake canonical form [1, 4], which guarantees that the subcolumns represent all of the simplest \npossible examples of the cases being se\u00adlected. These examples are called prime implicants [35] in logic, \nand help to makeschematic tables example centric[9]. Canonicity will be preserved as we enrich schematic \ntables throughout the rest of the paper. 3. Functional Schematic Tables In spite of progress in restricting \nand simplifying the structures of software, they remain inherently unvisu\u00adalizable, and thus do not permit \nthe mind to use some of its most powerful conceptual tools. This lack not only impedes the process of \ndesign within one mind, it severely hinders communication among minds. Fred Brooks [3] This section \naddresses the fundamental limitation of de\u00adcision tables: that they can not represent arbitrary computa\u00adtions, \nonly logic. Here schematic tables are turned into full\u00ad.edged functions that are callable, and in turn \ncall other ta\u00adbles, and even recurse upon themselves. The basic idea is 4 Different meaning is non-equivalence \nin the decidable logic of predi\u00adcates discussed in \u00a77. to represent expressions as trees of function \ncalls, laid out vertically across rows of the table, with one function call per row. Useful new views \nof code are enabled. The stan\u00addard notionsof types and assertions are also introduced,but with the twist \nthat theyshare the same declarative language of predicates with conditionals, leading to some convenient \ninteractions among what are normally only loosely coupled language features. We will restrict ourselves \nto the simple case of functions thathaveexpressions inside conditionals,but not the other way around. \nThe general case will be handled in the next section. Figure8showsthe Fibonaccifunction implemented in \nJava and Figure9is the equivalent schematic table. The important features demonstrated by this table \ncan be sum\u00admarized as follows: 1. Function arguments are representedas input variables of the table, \nsuf.xed by a colon, and function results are represented as output variables, suf.xed with an equals \nsign. All functions use the standard input variable in. Binary operators use a second input with. All \nfunctions use the standard output variable out. The value assigned by the table to out is the return \nvalue of the function. 2. Predicates are generalized to test for type membership (.)and arithmetic inequalities(<,i, \n =,etc.). Predicates lacking a relation symbol are equality tests. The implicit left-hand argument of \na predicate is the variable de.ned in its row. 3. Predicates are applied to variables in the .rst column \nto represent classical types, with compile-time5 type check\u00ading. 4. Predicates can be used as assertions, \nwhich are run-time tests thatthrow anexceptionif they arefalse(but onlyif they are in a true column). \nAssertions do not affect the truth conditions of their containing column. Assertions are displayed as \nan octagonal box and turn red if violated (like a stop sign). 5. Expressions containing nested function \ncalls are repre\u00adsented as inverted trees of boxes. Each box is a function call, and is on its own row \nof the table. The last column of the table assigns out from the function tree equivalent to theexpression \nfibonacci(in -1) + fibonacci(in -2) whenever the input is = 2.  6.Vertical lines are used to connect \nfunction calls within an expression. Inputs enter the function box from the top, and outputs leave it \nfrom the bottom. The positions of these lines are shownin thekeyin Figure 10. 5There is no difference \nbetween compile-time and run-time in Sub\u00adtext, since all code is always running. To preserve familiar \nterminology, compile-time will be taken to mean a static analysis that ignores the ac\u00adtualvaluesofvariablesand \nhence appliestoall possibleexecutions, whereas run-time properties are speci.c to a single execution \ninstance. 7.Themaininputandoutputlinesofa functionarealigned, and so composing functions through their \n.rst argument, as in f(g(h(... ))) leads to a vertically aligned stack of boxes. Secondary inputs indent \ntheir function stacks and place them under the stacks of left-ward arguments. 8. Function arguments that \nare variables or constants are named inside the box at the same position as a line would enter. Function \ntrees are actually graphs; the de\u00advices used to represent cross-cutting edges are discussed elsewhere \n[10],but will notbeusedin this paper. 9. Editingof function trees canbe performed witha number of mouse \nandkeyboard operations [10], the most impor\u00adtant of which is the splice operation.Afunction box can be \ndragged offof a palette, or out of existing code, and thendroppedontooneoftheverticallinesofthe tree.The \nfunction will be spliced into the tree at that point, cutting the line and connecting the two ends into \nthe function along its primary input/output axis. Connections between functions can also be altered by \ndragging lines around, changing the shape of the tree. 10. The function tree layout algorithm is canonical, \ndriven by input argument order and the connections between function inputs and outputs. The programmer \ncontrols only those connections. There is no manual placement and adjustment as with many visual programming \nlan\u00adguages [5, 29]. Neither is there fussing with carriage re\u00adturns and tabs to beautify textuallayout. \n Function treesoffer someadvantagesover traditionalpar\u00adenthetically nested expressions. They can be \nread linearly, following the visual cues of the lines, either up or down. Nested expressions can quickly \nbecomes disorienting: after all, we are not stack machines. The vertical layout across rows enables some \nnew ways to visualize execution and browse code, described below. 3.1 Live code Schematictableshelpnotonlyto \nvisualizethelogicofcode, but also its actual execution. Since every variable and func\u00ad tion call has \nits own row of the table, execution values can be annotated into the rows, as shown in Figure 11 for \nan input value of 2. The values of every variable and the pri\u00ad mary output of every function call are \nshown pre.xed with an equals sign.True predicates are colored green,false pred\u00ad icates gray.False columns \nare shaded entirely gray, showing that their contents are inactive, and in contrast highlighting the \ntrue columns. In Subtext all code is always a running instance, so dis\u00ad playing theseexecutionvalues \nmerely reveals what has been kept hidden until now. But the same presentation could be used to illuminate \ncode within a conventional debugger, by selecting a stack frame of the function. Unlike traditional break-and-step \ndebugging, the entire execution of the func\u00ad tion is made visible at once. Function trees offer a conve\u00adnient \nplace to annotate complete traces of execution values withinthecode itself.Apreviouspaper[9] discussedanim\u00adplementation \ntechnique for Java and the implications for the development process. 3.2 Laminar browsing Sincefunctioncallsarearrayedinthevertical \ndimension,the horizontal dimension can be used to zoom in on them non\u00addisruptively, with a technique \ncalled laminar browsing. Fig\u00adure 12 shows how anyfunction call can be expanded right\u00adward to see its \ninternals. This example shows drilling into the recursivestructureof .bonaccitoexploreaparticularex\u00adecution,butit \ncould equally wellbe usedtobrowse between different functions and de.nitions during editing. Structured \nvalues can also be expanded in the same way. Multiple expansions are stacked up in columns of the browser \nwindow called layers.Vertical scrolling is geared between the layers, with rightward layers scrolling \nfaster than leftward onesin ordertokeep related information syn\u00adchronized on screen. Expanding from the \nright-most layer opens a new one to the right, and scrolls the entire display leftward. Backtrackingisdonebyscrollingtheentiredisplay \nrightward to see the contextually leftward layers. This ap\u00adproachmapsoutatreeoftraversals,unlikethe strictly \nlinear back/forward history of browsers. It also shows the context of where you came from and where you \nare going, unlike browsingby opening independent windows.  3.3 Types, assertions, and conditionals Predicates \nfoster a convenient interplay between types, as\u00adsertions, and conditionals, which are only loosely related \nin conventional languages. Because assertions and conditionals use the same language of predicates as \ntypes, they have meaning at compile-time. Predicates satisfy types within their column, as if they were \nimplicit local downcasts. One can impose speci.cations on a function by publishing ar\u00adbitrary predicates \nas types, obligating the callers to satisfy them with assertions or conditional guards (the aforemen\u00adtioned \ndowncasts generalized to arbitrary properties). As\u00adsertions of arbitrary predicates .ow out of a function \nat compile-time, like return types, to latch conditionals or sat\u00adisfy types, even though theyare run-time \nchecks. Assertions may occurin other columnsthanthe .rst, conditionalizedby the predicates of that column \nto form logical clauses6. Over\u00adall, the ubiquitous use of predicates enables programs to be more declarative. \n6If such clausal assertions could be incorporated into reasoning within the function s callers then we \nstart to get the features of a formal speci.cation language. Future research will explore this direction. \n4. From Java to the Outer Limits We will control the horizontal. We will control the vertical. The ControlVoice7 \n In this section a larger example introduces the full ca\u00adpabilities of schematic tables.Tables will be \ngeneralized to support multiple independent conditional tests, and these tests can select the inputs \nto functions. The central idea is that computation is represented in the vertical dimension of the table, \nwhile decision-making is in the horizontal dimen\u00adsion. Orthogonalizing these two concerns allows their \ndiffer\u00adent semantics to be manifested directly in the geometry and behavior of the table. Maintaining \nlogical partitioningof the table drives high-level transformations that save labor. The extra degree \nof freedom offered over textual syntax reduces the need to split code across control structures. Figure \n13 shows the Java implementation of a function that calculates the damage of an attack in a video game, \nknown as hitpoints. Attacks are categorizedby the Attack enum into MELEE and MAGICAL, which draw upon \ndifferent attributes of the attacking character: its strength or magic. Arandom number modulates the \neffectiveness of the attack, unless the attacker possesses the magical Amulet of Puis\u00adsance, which bestows \n80% effectiveness. The damage to the target depends on the type of the attack. A magical attack is damaging \nin inverse proportion to the target s magical power, while a melee attack is damaging only to the extent \nthatitoverpowersthetarget s armor.To simplify matters,all numeric values are assumed to be normalized \nto the interval [0 1]. Unfortunately, as so often happens, the requirements do not cleanlyfactor out \nintoa simple switch on the typeof the attack, leading to a design dilemma. There is shared logic between \nthe cases. Copying the shared logic across different cases would be undesirable duplication. Yet abstracting \nit into a separate function is of questionable bene.t because it is so intertwined with the rest of the \ncode. Using two switch statements to centralize the shared logic, the choice taken here, is redundant \nand splits apart related code. The point is not to debate this dilemma which Java thrusts upon us,but \nrather to show how schematic tables can avoid the need to make such dif.cult trade-offs. Figure 14 shows \nthe same function as a schematic table, illuminated by a live example execution. The important fea\u00adtures \nof this table are: 1. More than one column can be true at a time, allowing in\u00addependent conditions to \nbe tested without a combinato\u00adrialexplosionof cases. The graying-outoffalse columns in the live example \nhighlights by contrast the three true columns, plus the .rst column (whichis onlyfalse when there is \na type error). 7http://en.wikipedia.org/wiki/Outer_Limits 2. Function inputs caninvolve choices,indicatedby \nsplit\u00adting the vertical connector line across multiple columns, connectedbya horizontal line.Forexample \nthe .rst in\u00adputtothe * function in the .rst column is a choice be\u00adtween .8 and a call to random, based \non the value of the attacker.amulet .eld. 3. The partitioning invariant is generalized to require that \nthere be exactly one true column among all the choices for a variable or function input. The question \nmark in the bottomrowaddsa sub-partitioning constraint,whichis explained in \u00a74.5. 4. Function inputs \nand outputs can be named like local variables, as in power and e.ectiveness. However these names are \noptional and for documentation purposes only they are not required like in textual languages as a form \nof exposed plumbing. In the Java code, we wouldn thave thought twice about collapsing power and effectiveness \ninto a nested expression if the switch statement hadn tforced us to split out the code. 5. Predicates \ncan test the result of internal computations, shown by the <0 and =0 predicates evaluating the result \nof the subtraction to their left. Note that the =0 predicate allows the value it is testing to .ow through \nto the output withouthavinghadtoassignit.rsttoa localvariable.  Columns unite code that is used under \nthe same condi\u00adtions, whereas textual conditionals often force it to be split apart. The dilemma of Figure \n13 is resolved: the code that was split across the two switch statements is now uni.ed vertically within \ncolumns, while the shared logic in the left\u00adward columns is jointly accessed horizontally. Another com\u00admon \nannoyance is having to save a Boolean in a .ag vari\u00adablewhichisthen repeatedlytestedbyconditionals scattered \nthroughout the code.Aschematic tablewould unite the bod\u00adies of those conditionals in a single column \nmaking a single test.We will seein \u00a75how columns can also unite code split across polymorphic methods. \nThe more .exible connectivity within a schematic table is because it has two dimensions, whereastexthasonlyone(or \nperhaps 1.5, counting indenta\u00adtion). 4.1 Controlling the horizontal The table is still canonical. The \nprogrammer can not place function callsin cells.Vertical placementis determinedby the tree layout algorithm \ndescribed earlier. Horizontal place\u00adment is determined by a relevancy analysis. The downstream consumers \nof the call s outputs are tra\u00adversed to determine the union of all cases in which they are used;thecallisthenplacedinacolumn \npredicatingthe com\u00adputed relevancyconditions. The leftmost * call is used in all cases, so it is placed \nin the .rst column. The other * call is placed in the last column because it is only used for magical \nattacks. The relevancyanalysis frees the program\u00admer from having to conditionalize function calls based \non when theywill be needed, as in a lazy language. But unlike lazy languages, the inferred predicates \nmake it clear exactly what those conditions are, which may be important to know. Theyact likeexplicit \nconditionals, including satisfying input types of the called function. As mentioned earlier, the horizontal \nordering of columns is also canonical. An important property of this ordering is thatitisa topological \nsortof the implication ordering.For example, the column which conjoins the predicates melee and <0 implies \nthecolumn with just melee:columns that are trueinasetof casesareimpliedbythosethatareonlytruein a subset \nof those case. Therefore the melee-only column is placed to the left of the more restrictive ones. The \ntruthiest column is always the left-most one containing the types de.ning all possible cases. Self-contradictory \ncolumns will appear on the right-hand side (and be shaded extra-darkly). This ordering property means \nthat the geometry of the table tells us something about its logic. 4.2 The central idea The central \nidea of schematic tables is that function trees show computation vertically, while truth tables show \nlogic horizontally. Computation and decision-making are thus rep\u00adresented orthogonally. The geometry \nand behavior of the table manifests the different semantics of these two di\u00admensions: computation that \nof data .ow graphs; decision\u00admaking that of Boolean algebra. Separating these two as\u00adpects of a program \nmakes it easier to understand, and easier to change.Havingtwo independent dimensionsoffersanex\u00adtra degree \nof freedom over linear text, reducing the need to split apart related code. 4.3 Restriction Schematic \ntables can be restricted into a partial view that assumes certain predicates are true. Figure 15 shows \nthe re\u00adstriction on magical attacks (and with live execution values turned off). The restriction predicate \nis displayed in yellow. All columns that are contradicted by the restriction assump\u00adtions are hidden. \nAll predicates that are implied by the re\u00adstriction assumptions are also hidden. Note that a restriction \nis a fully editable view of the schematic table. 4.4 Pattern matching The way that schematic tables \ndivide the code into cases which are guarded by predicates is somewhat like pattern matching [6] in functional \nlanguages. The declarative nature of patterns allows completeness to be enforced at compile\u00adtime. However \npattern matching has some limitations: 1.Pattern matching enforces completeness,butnot disjoint\u00adness \n overlapping patterns are allowed, with the .rst .t 8 being executed. First .t is like doing implicit \nelse with a return or break statement. It encodes logic tacitly 8Hope [6], which .rst introduced pattern \nmatching, useda best .t seman\u00adtics that arguably overcomes this objection. This feature was discarded \nin in order, making it terserbut harder to understand, and harder to preserve under change. 2.Pattern \ncases are laid out vertically in the source .le, while schematic tables do so horizontally, orthogonal \nto thecode.Liningupallthe predicatesonthesamevariable inarowmakes the differences between patterns more \nvis\u00adible, as in truth tables. Note howthe attacker.amulet .eld is destructured into a box occupying its \nown rows of the table, lining up all the predicates on it. Destructuring variable assignments couldbe \nlikewise represented. 3. The hitPointsexamplewould requiretwoseparatepattern matches, just as it requires \ntwo switch statements in Java: shared code between the cases causes the data .ow to wind out and back \nin to each case. This .ow is easily represented in the two dimensions of a schematic table.  4.5 Code \ntransformation Maintenance of the partitioning invariant on tables drives high-level transformations \nthat save programmer labor and thought.Wesawthisin \u00a72for simple decision tables; we will demonstrate \nit now for general code editing. For example suppose that we introduce new weapons technology into thegame: \nranged weapons that can attack froma distance. We want the hit point calculation for ranged weapons to \nbe the same as for melee attacks, except that a new ability, acuity, will modulate itseffectiveness.We \nadjust the codein a sequence of simple steps: 1. Appending ranged to the Attack enumeration automati\u00adcally \nchanges the table as in Figure 169.A new column has been added tokeep the table complete,but using an \nexclamationmarkasthevalueofthe assignment.Theex\u00adclamation mark is a special error value that indicates \na missing value requiring resolution by the programmer. It is highlighted in red, andalso has the effect \nof violating the Rational type on out, which likewise .ares up red. We can resolve this problem by replacing \nthe exclama\u00adtion mark with the appropriate code for the new case.A pattern matching languagewouldhave \nreportedthe miss\u00ading case as a compiler error. The schematic table goes furtherby also generating the \nboilerplate for .xing it. 2.To share the logic of melee attacks with ranged ones in Java, we would add \nRANGED onto the case selectors for MELEE in both of the switch statements. We do the same thingin the \nschematic tablebydragging the ques\u00adtion mark onto theexclamation mark.The question mark serves hereasa \ngrouphandleonthepairofvalues imme\u00ad subsequent functional languages, although it has been revived in a \nrecent proposal [26]. 9Note that the two subtraction functions have been placed on the same row. This \nis an abbreviation to save vertical space by reusing a row for multiple functions when it is known that \nthey are in contradictory columns. This abbreviation is a user-con.gurable parameter.  diately to its \nright, which together cover the melee case.10 The drag action merges the conditions ofthe target col\u00adumn \n(ranged) with the actions of the source columns (melee), resulting in Figure 17. The target.armor logic \nthat before was in the melee columns is now predicated on being melee or ranged (using a comma to abbreviate \nthe disjunction). But the choice of attacker.strength for melee attacks was moved into a new column to \nthe right, because it applies in more restricted conditions, in accor\u00addance with the canonical ordering \nof the table. 3. The previous change triggered a new incompleteness error. The choice between attacker.strength \nand at\u00adtacker.magic does not cover ranged attacks, so an ex\u00adclamation mark is again automatically introduced \nto .ll thegap.Atype erroris triggered on the * function onthe left, which turns red. 4.We .x this errorby \nreplacing theexclamation mark with the desired reference to attacker.acuity, producing the .nal result \nin Figure 18. Introducing the new enumeration constant ranged led us by the hand in writing the code \nto deal with it, step by step, driven by maintenance of the partitioning invariant of schematic tables. \n5. Duck Polymorphism Object oriented languages offer subtype polymorphism as a powerful form of conditional. \nPolymorphic dispatch decides which method to choose based on class in other words conditionalizing on \nclass. The power of polymorphism is that it makes class-based conditionality declarative. One can infer \nthings about method dispatch at compile time, which IDE s use to great advantage. Polymorphism imposes \nstruc\u00adture on the code that helps identify the role of methods just by their containing class. Schematic \ntables, as already de\u00adscribed, support all the essential features of polymorphism, albeit in an unconventional \nmanner. The argument is that schematic tables walk like polymorphism, and quack like polymorphism, and \nhence provide duck polymorphism . There are two essential features of polymorphism11: 1. Dividing code \ninto methods that are specialized by their containing class and the types of their arguments. 2. Overriding \nof methods via dynamic dispatch.  10 The question mark establishes a sub-partitioning constraint among \ncolumns. A question mark is like an abstract value , in the sense of an abstract method, layingdowna \nmarker that obligesthevaluetobe assigned in all columns which logically restrict that column, and which \ntogether must cover all cases of that column. This constraint is analogous to the way that an abstract \nmethod must be overridden in all non-abstract subclasses. 11 This section will actually showhowschematic \ntables emulate the features of generic functions [28], while using the more familiar terminology of methods \nas if there were no difference. The difference is primarily one of syntactic packaging: there are well \nknown ways to turn functions into methods, as for example in Python. The basic idea is, .rstly, that \nrestrictions on schematic ta\u00adblesoffer specializedviews similarto methods,but without physically dividing \nup the code. Secondly, that table parti\u00adtioning induces overriding logic between columns that im\u00adply \neach other, without having to invoke hidden run-time machinery. Duck polymorphism offers some advantages. \nMethods can share code, reducing their fragmentation. Method dispatch is revealed as explicit logic in \nthe table. Inherited behavior and possible dynamic overridings are clearly visualized. The declarative \npower of polymorphism is made .exible enough to replace ad hoc if-statements. 5.1 Restriction replaces \nmethod division Figure 19 replaces the switch statements in hitPoints with polymorphism in the standard \nmanner. The Attack enum is converted to a class with subclasses Melee and Magical. Seven methods are \nproduced. The arrows show the cross\u00adclass transfers of control for a call to Melee.hitPoints. Remember \nthatclasses are typically de.nedin separate .les, so even in modern IDE s the programmer will not see \nthem together as in Figure 19. Comprehending how all the little fragmentary methods tie together when \none doesn tactually see them together is a central dif.culty of polymorphism. Schematic tables don t \nneed to be divided into little spe\u00adcialized methods. Instead, we can use restriction to view specialized \naspects of the table that correspond to methods. Figure 20 shows the trivial conversion of the table, \nreplac\u00ading equality by instance membership. Figure 21 shows lam\u00adinar browsing from a table that calls \nthe hit points function within a column contingent on Magical attacks. The call is expanded to the right, \nautomatically restricted on the predi\u00adcates of the calling context. The restriction shows us just the \nparts of the table relevant to Magical attacks, likethe method whichwouldbe dispatchedin this situation. \nRestrictionsactlikemethodsinthesensethattheyshowa class-specialized fragment of the code. They are specialized \ndeclaratively like methods with predicates, allowing static analysis, partitioning constraints, and IDE \nassists. Restric\u00adtions are independently editable, just as if they were phys\u00adically distinct methods. \nBut restrictions have an advantage over methods: they can share code without extracting it into another \nmethod, reducing method fragmentation. The table contains two methods : the columns predi\u00adcated on .Melee \nand .Magical respectively. There is no need to extract the shared logic about amulets and ran\u00addomness \ninto the Java effectiveness method. That code shows up in both method restrictions, .agged as being shared \nbecause it is located in columns to the left of the yel\u00adlow restriction column. Edits to such shared \ncode are visible in all sharingrestrictions, just as editing anextracted method would be. We don t need \nto extract the power method ei\u00adther, which was done solely to allow it to be called from effectiveness. \nNow the code that had to be split across hitPoints and power sits in the same column. Polymor\u00adphic restriction \nprovides more coherent class-specialization of code than methods do, because it is orthogonal to data \n.ows.  5.2 Implication partitioning replaces dynamic dispatch Dynamic dispatch is the other essential \naspect of polymor\u00adphism. It allows us to incrementally add code specialized for certain subclasses and \nhave it be invoked when needed. Predicate dispatch [12, 27] provided the key insight that method dispatchisdrivenby \nlogical implication.Asubclass method overrides a superclass method because an object be\u00ading in the subclass \nimplies it is also in the superclass. Predi\u00adcate dispatch adds a decidable logic of predicates that allow \ndispatching on conditions other than class membership, with the rule that implicants override. Predicate \ndispatch also in\u00adtegrates overloading, by including predicates on arguments in the implication. This \nlogical interpretation of polymor\u00adphism .ts right into schematic tables. As an example, we will add the \nranged attack from \u00a74.5 polymorphically. Since it differed from melee attacks only in the acuity parameter, \nit would be simplest to add Ranged as a subclass of Melee. But ranged attacks are not concep\u00adtually instances \nof melee attacks, so the proper thing to do is to introduce a new abstract class Physical which has sub\u00adclasses \nMelee and Ranged. Figure 22 shows the resulting Javacode.Wehave decidedthatthedefaultforphysicalat\u00adtacks \nshould be to rely on the attacker s strength, and only override thisinthe caseof ranged attacks. The \nsame change is easily made to the schematic table.Too easily instead we will make Physical non-abstract \nto expose more gen\u00aderal dispatch logic. The steps are as follows: 1. Figure 23 shows the effects of altering \nthe class hierar\u00adchy.Completeness inducesa column showing thereisa gap in the logic for non-Melee Physical \nattacks, indicated as before with the exclamation mark error value. This er\u00adrorwouldbe reportedinJavaasthefailuretooverridethe \nabstract method Attack.hitPoints in Physical. The table error identi.es preciselywhat cases are missing, \nnot just their superclass. It also provides the boilerplate for a .x, in the same way as was seen earlier \nwith enumera\u00adtions. 2. As was done in Java, the existing Melee logic needs to be promoted up to the \nPhysical class. This is done by dragging the .Melee predicate and dropping it in the error column. The \ncases of the columns are merged (overwriting the con.icting exclamation mark), produc\u00ading Figure 24, \nwhich differs from the starting point only in that the .Melee predicate has turned into .Physical. The \nequivalent change in Java would typically be done by renaming the Melee class to Physical. 3. Next the \noverriding behavior for Ranged attacks must be added, as in the Java method Ranged.power. Overriding \nis introduced by editing within a restriction. Figure 25 shows the restriction on Ranged. There is no \ncode spe\u00ad  ci.c to ranged attacks yet, so the restriction column is empty. Note that the inherited behavior \nis shown in the columns to the left, predicated by source class (in this case Physical). The value of \nattacker.strength is over\u00adridden within the restrictionbydirectly editingthe proper cell in the asserted \ncolumn, as shown by the text .eld in Figure 25. This edit will cause attacker.strength to dis\u00adappearfromthe \nrestrictedview,asithasbeenoverridden. 4.To see the big picture, Figure 26 lifts the restriction up to \nthe superclass Physical. There is a column on the right hand side predicated on Ranged containing the \noverriding value just entered. The value it overrides, at\u00adtacker.strength, is in the column to its left, \npredicated on being Physical but not Ranged. These predicates reveal preciselythe dispatchlogicofthe \npower method in Java: the Physical.power method willbeoverriddenonlyby Ranged.power. Thislogicisshowninapleasinglysym\u00admetric \nform using the negative predicate ./. The method dispatch algorithm has essentially been compiled into \nthe predicates, induced by the partitioning invariant on columns that specialize (imply) others. The \nschematic table interpretation of polymorphism has some limitations compared to languages designed expressly \nfor the purpose.Forexample, thereis currently no mecha\u00adnism equivalent to Java s super. But schematic \ntables also offer some bene.ts. The specialization of code into meth\u00adods is achieved more .exibly by \nrestricted views, permit\u00adting code sharing without method fragmentation. The logic of methoddispatchisrevealedexplicitly,and \ninducedbythe partitioning constrainton tables.Overridingis introducedby editing within a restriction. \nRestrictions offer a view from one point in the class hierarchyof both inherited and over\u00adriding code.Thepowerof \npredicate dispatchisprovided,but given an extra degree of freedom so that it can apply to ad hoc internal \nlogic, not just at method calls. 6. Untangling time and logic Up until now we have ignored a crucial \nissue: execution or\u00adder. The conventional approach is to delicately intertwine actions into the control-.ow \nof conditionals. Schematic ta\u00adbles allows us to untangle time and logic, representing them orthogonally. \nThe Subtext approach to time and state has been dis\u00adcussedin detail elsewhere [11].Abriefsketchwillbe \nmade of how time can be represented in schematic tables in a way compatible with either a conventional \nsemantics or that of Subtext. The basic idea is to represent execution order as an explicit data .ow. \nAll operations with side-effects are repre\u00adsented as functions called actions that transform states. \nBy convention theytake an input state on their primary input ar\u00adgument and produce an output state on \ntheir primary output. These states can be seen as symbolizing points in time12. Actions are ordered \nby being stacked up along their pri\u00admary axis. All state-inspecting operations, likepointer deref\u00aderences, \nare considered to inspect theinput state of their con\u00adtaining function, or equivalently, thattheyall \nhappen before anyinternal actions are executed. Figure 27 shows an example of a simple Java method that \nexecutes some other methods which are presumed to have side-effects and interdependencies. The equivalent \nschematic table is shown to the right13. The columns can be imagined as highway lanes , with time driving \ndown\u00adward, and predicates causing lane switches. Note that this is not some special mode, but the same \nrepresentation of functions that we have been using all along. By representing time and logic orthogonally, \nthey can be seen as separate aspects, and changed independently. Altering the conditions gating an action \nwhile preserving its relative execution order can be achieved by dragging it horizontally in the table. \nConversely, altering the execution orderof an action while preserving itsgating conditions can be achieved \nby dragging it vertically in the table. For example, suppose that we want to execute I in all cases but \nwithout changing its execution order relative to the other actions. Modifying the Java code requires \nsome care. Figure 28(a) shows the necessary changes in bold, with deletions struck through. The equivalent \nchange to the schematic tableis performedin28(b)by draggingthe action I horizontallyovertothe .rst column, \nwhichisthe condition in which we want to execute it, while keeping its vertical position unchanged, to \npreserve execution order. The red line is a popup drop guide. Figure 28(c) shows that the required cuts \nand splices have been automatically performed to achieve the desired result. 7. Decidability The power \nof schematic tables is that theymake conditionals declarative, providing the knowledge at compile-time \nand edit-time that informs all of the advanced features described in this paper. But the use of predicates \nlike =0 may seem concerning type systems carefully avoid such properties because they are in general \nundecidable. Luckily schematic tables are in a simpler situation than type systems, which must reason \nabout the effects of arbitrary computations. Schematic tables need only reason about the partitioning \npropertiesof predicateson setsof.xedvalues. Such reason\u00ading is essentially propositional, and decidable. \nFormally, partitioning requires only formulas of the form .x1,...,xn.F where F is a quanti.er-free formula \nof .rst\u00ad 12Thisis similartothe approachtakenby monads[20,42],though without the higher-order cleverness \nused to accomplish it within an expression language. On the other hand, Subtext treats states as virtual \nversions of the entire global state. 13 Flowgraphs [19] use similar diagrams (though witha conventional \ntreat\u00admentof conditionals)ina categorical semanticsofimperative computation. order logic with equality \nand constants as the only function symbols. The type-membership predicate . is axiomatized by encoding \nthe subtype hierarchy into partitionings. The partitioning properties of integer comparison can be axiom\u00adatized \nusing formulas of the same form, such as .x . Int. .y . Int. (x>y) .\u00ac(x = y) and a .nite number of instances \nof schemata like .x . Int. (x = 'n') . (x = 'n') . (x = 'n +1') suf.cient to cover the integer literals \nin use. These formu\u00adlas belong to a decidable fragment of .rst order logic, the Bernays-Sch\u00a8on.nkel-Ramseyclass \n[2],whose satis.ability can be checked in NP. There are known decision proce\u00addures [17, 23] for similar \nproblems. Subtext will employ a SAT-solver [7] as a .exible testbed for the logic of predi\u00adcates. 8. \nConclusion: Representation Matters In symbols one observes an advantage in discovery which is greatest \nwhen they express the exact nature ofathingbrie.yand,asitwere,pictureit;then indeed the labor of thought \nis wonderfully diminished. Leibniz The conclusionofferedby schematic tablesisthat represen\u00adtation matters. \nTheir .exibility comes from the extra degree of freedom offered by a two-dimensional notation. Their \npower comes from directly manifesting Boolean algebra in their geometry and behavior. It is a truism \nin all technical .eldsthatthekeyto solvinga problemis choosingtheright notation. The hallmark of a good \nnotation is that it mirrors its domain: that equivalent situations get represented equiv\u00adalently, and \nthat different representations refer to different situations: in other words, canonicity. The need to \nmanually refactor having to laboriously make literally meaningless changes before being able to ex\u00adpress \na solution is a textbook symptom of poor notation. Another warning sign is the need for dif.cult mental \ncal\u00adculation to understand and manipulate the notation. Enor\u00admous effort and creativity has been invested \ninto IDE s like Eclipse, yet in the end there is something gravely unhealthy about a notation that requires \nsuch a complex life-support system. Schematic tables raise obvious concerns.Will theyscale to large programs? \nWill the variety of editing operations be too complex? Will canonicity cause disturbing volatil\u00adity as \nwe edit? These are all serious matters of user inter\u00adface (UI) research. There is some reason for optimism, \nhow\u00adever.Textual languages are anchoredtoa grammar, limiting IDE s to being enhanced text editors. Schematic \ntables, as a computer-mediated representation, make no commitment to a .xed encoding. They are not viable \noutsideof an IDE,but theyleave the door wide openfor cleverUI innovation. The signi.cance of schematic \ntables may not rest upon whether or not they are the one true way to represent con\u00additionals. It may \nrather be as witness that there exist inter\u00adesting new ways to represent programs outside of the well\u00adexplored \nspace of grammars. The history of programming languages is not over. Acknowledgments Daniel Jackson, \nDerek Rayside, Rob Seater, EminaTorlak, and Viktor Kuncak provided helpful discussions, and the Software \nDesign Group at MIT provided a creative environ\u00adment. Constructive criticismwasofferedbyJacques Carette, \nMatt Hellige, Macneil Shonle, and the anonymous referees. Ethan Edwards helped formulate the examples. \nReferences [1] A. Blake. Canonical expressions in Boolean algebra. PhD thesis, UniversityofChicago, \n1938. [2] E.B\u00a8 adel. orger,Y. Gurevich, and E. Gr\u00a8The classical decision problem. Springer, 2001. [3]F. \nBrooks. No Silver Bullet: Essence andAccidentsof Software Engineering. Computer, 20(4):10 19, 1987. [4]F. \nBrown. Boolean Reasoning. Kluwer Academic Publishers Boston, 1990. [5] M. Burnett and A. Goldberg. Visual \nobject-oriented programming. Manning, 1995. [6] R. Burstall, D. MacQueen, and D. Sannella. HOPE: An experimental \napplicative language. Proceedings of the 1980 ACM conference on LISP and functional programming, pages \n136 143, 1980. [7] M. Davis, G. Logemann, and D. Loveland. Amachine program for theorem-proving. Commun. \nACM, 5(7): 394 397, 1962. [8] E.W. Dijkstra. Guarded commands, nondeterminacy and formal derivation of \nprograms. Commun.ACM, 18 (8):453 457, 1975. [9] J. Edwards. Example centric programming. SIGPLAN Not. \n(OOPSLA 04 Onward! Proceedings), 39(12):84 91, 2004. ISSN 0362-1340. [10] J. Edwards. Subtext: Uncovering \nthe simplicity of pro\u00adgramming. In OOPSLA 05: Proceedings of the 20th annualACM SIGPLAN conference on \nObject oriented programming, systems, languages, and applications, pages 505 518.ACM Press,2005. [11]J.Edwards. \nFirst ClassCopy&#38;Paste.Technical report, Massachusetts Institute of Technology Computer Sci\u00adence and \nArti.cial IntelligenceLaboratory, May 2006. URL http://hdl.handle.net/1721.1/32980. [12] M. Ernst, C. \nKaplan, and C. Chambers. Predicate Dispatching:AUni.ed Theory of Dispatch. ECOOP, 98:12th, 1998. [13] \nD. L. Fisher. Data, documentation, and decision tables. Commun.ACM, 9(1):26 31, 1966. [14]T. Green and \nM. Petre. WhenVisual Programs are Harder to Read than Textual Programs. Human-Computer Interaction, 1992. \n[15] R. Halverson Jr. An Empirical Investigation Comparing IF-THEN Rules and DecisionTables for Rrogramming \nRule-based Expert Systems. System Sciences, 1993, Proceeding of the Twenty-Sixth Hawaii International \nConference on, 3, 1993. [16] C. Heitmeyer, M. Archer, R. Bharadwaj, and R. Jef\u00adfords. Tools for constructing \nrequirements speci.ca\u00adtions: The SCR toolset at the age of ten. International Journal of Computer Systems \nScience and Engineering, 20(1):19 35, 2005. [17] M. Ibramsha and V. Rajaraman. Detection of logical errors \nin decision table programs. Commun.ACM, 21 (12):1016 1025, 1978. [18]R. Janicki,D.L.Parnas,andJ. Zucker.Tabular \nrepre\u00adsentations in relational rocuments. In Relational meth\u00adods in computer science, pages 184 196. \nSpringer-Verlag, 1997. [19] A. Jeffrey. Premonoidal categories and a graphi\u00adcal view of programs. Technical \nReport 98-004, CTI, DePaul University, August 1998. URL http://facweb.cs.depaul.edu/research/ techreports/abstract98004.htm. \n[20] S. Jones. Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign\u00adlanguage \ncalls in Haskell. Engineering theories of software construction, Marktoberdorf Summer School, pages 47 \n96, 2000. [21]P. J. H. King. Ambiguity in limited entry decision tables. Commun.ACM, 11(10):680 684, \n1968. [22]H. Kirk. Useof DecisionTablesin Computer Program\u00adming. Communicationsof theACM, 8(1):41 43, \n1965. [23]V.KuncakandM. Rinard. Decision proceduresfor set\u00advalued .elds. 1st InternationalWorkshop on \nAbstract Interpretation of Object-Oriented Languages (AIOOL 2005), 2005. [24] N. G. Leveson. Intent speci.cations: \nAn approach to building human-centered speci.cations. Software Engineering, 26(1):15 35, 2000. [25] LogicGem \n3.0 QuickStart. URL http: //www.catalyst.com/products/logicgem/ quickstart.pdf. [26] A.L\u00a8oh and R. Hinze. \nOpen datatypes and open func\u00adtions. Proceedings of the 8th ACM SIGPLAN sym\u00adposium on Principles and practice \nof declarative pro\u00adgramming, pages 133 144, 2006. [27]T. Millstein. Practical predicate dispatch. Proceed\u00adingsof \nthe 19th annualACM SIGPLAN Conference on Object-oriented programming,systems, languages, and applications, \npages 345 364, 2004. [28] D. A. Moon. Object-oriented programming with .a\u00advors. In OOPLSA 86: Conference \nproceedings on Object-oriented programming systems, languages and applications, pages 1 8, New York, \nNY, USA, 1986. ACM Press. [29] B. Myers. Taxonomies of Visual Programming and Program Visualization. \nJournal of Visual Languages and Computing, 1(1):97 123, 1990. [30] I. Nassi and B. Shneiderman. Flowchart \ntechniques for structured programming. SIGPLAN Not., 8(8):12 26, 1973. [31] J. Pane and B. Myers. Tabular \nand Textual Methods for Selecting Objects froma Group. Proceedings of VL 2000: IEEE International Symposium \non Visual Lan\u00adguages, pages 157 164, 2000. [32] J. Pane and B. Myers. Usability Issues in the De\u00adsign \nof Novice Programming Systems. Technical Re\u00adport CMU-CS-96-132, School of Computer Science, Carnegie \nMellon University, August 1996. [33] S. Pollack. Analysis of the Decision Rules in Decision Tables. Technical \nReport RM-3669-PR, Rand Corp, 1963. [34]U. Pooch.Translationof DecisionTables. ACM Com\u00adputing Surveys \n(CSUR), 6(2):125 151, 1974. [35]W. Quine. The Problem of SimplifyingTruth Func\u00adtions. The American Mathematical \nMonthly, 59(8): 521 531, 1952. [36] B. Silberg. Detab/65 in third-generation cobol. SIG-PLAN Not., 6(8):4 \n8, 1971. [37] StateStep Tutorial. URL http://statestep.com/ tutorial/RuleInitial.html. [38] R. F. Sterbenz. \nTabsol decision table preprocessor. SIGPLAN Not., 6(8):33 40, 1971. [39] D. Thomas. Agile Programming: \nDesign to Accommo\u00addate Change. IEEE Software, 22(3):14 16, 2005. [40] A. M.Turing. (1946) Proposed Electronic \nCalculator, reportfor NationalPhysicalLaboratory,Teddington.In A. M.Turing sACE Report of 1946 and OtherPapers. \nMIT Press, 1986. [41] I. Vessey and R. Weber. Structured Tools and Con\u00additional Logic: an Empirical Investigation. \nCommuni\u00adcationsof theACM, 29(1):48 57, 1986. [42]P.Wadler. Comprehending monads. Proceedings of the 1990ACM \nconference on LISP and functionalpro\u00adgramming, pages 61 78, 1990.       \n\t\t\t", "proc_id": "1297027", "abstract": "<p><i>Schematic tables</i> are a new representation for conditionals. Roughly a cross between decision tables and data flowgraphs, they represent computation and decision-making orthogonally. They unify the full range of conditional constructs, from if statements through pattern matching to polymorphic predicate dispatch. Program logic is maintained in a declarative canonical form that enforces completeness and disjointness among choices. Schematic tables can beused either as a code specification/generation tool, or as a self-contained diagrammatic programming language. They give program logic the clarity of truth tables, and support high-level direct manipulation of that logic, avoiding much of the mental computation demanded by conventional conditionals.</p>", "authors": [{"name": "Jonathan Edwards", "author_profile_id": "81100596781", "affiliation": "Massachusetts Institute of Technology, Cambridge, MA", "person_id": "PP39093206", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297075", "year": "2007", "article_id": "1297075", "conference": "OOPSLA", "title": "No ifs, ands, or buts: uncovering the simplicity of conditionals", "url": "http://dl.acm.org/citation.cfm?id=1297075"}