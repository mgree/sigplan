{"article_publication_date": "10-21-2007", "fulltext": "\n Modular Typestate Checking of Aliased Objects Kevin Bierhoff Jonathan Aldrich Institute for Software \nResearch, School of Computer Science Carnegie Mellon University, 5000 Forbes Avenue, Pittsburgh, PA 15213, \nUSA {kevin.bierhof,jonathan.aldrich} @ cS.cmu.edu Abstract Objects often de.ne usage protocols that \nclients must follow in order for these objects to work properly. Aliasing makes it notoriously dif.cult \nto check whether clients and imple\u00admentations are compliant with such protocols. Accordingly, existing \napproaches either operate globally or severely re\u00adstrict aliasing. We have developed a sound modular \nprotocol checking approach, based on typestates, that allows a great deal of .exibility in aliasing while \nguaranteeing the absence of pro\u00adtocol violations at runtime. The main technical contribution is a novel \nabstraction, access permissions, that combines typestate and object aliasing information. In our methodol\u00adogy, \ndevelopers express their protocol design intent through annotations based on access permissions. Our \nchecking ap\u00adproach then tracks permissions through method implemen\u00adtations. For each object reference \nthe checker keeps track of the degree of possible aliasing and is appropriately con\u00adservative in reasoning \nabout that reference. This helps de\u00advelopers account for object manipulations that may occur through \naliases. The checking approach handles inheritance in a novel way, giving subclasses more .exibility \nin method overriding. Case studies on Java iterators and streams pro\u00advide evidence that access permissions \ncan model realistic protocols, and protocol checking based on access permis\u00adsions can be used to reason \nprecisely about the protocols that arise in practice. Categories and Subject Descriptors D.2.4 [Software \nEngi\u00adneering]: Software/Program Veri.cation; F.3.1 [Logics and Meanings of Programs]: Specifying and \nVerifying and Rea\u00adsoning about Programs General Terms Languages, Veri.cation. Keywords Typestates, aliasing, \npermissions, linear logic, behavioral subtyping. Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00e9al, Qu\u00e9bec, Canada. Copyright \nc &#38;#169; 2007 ACM 978-1-59593-786-5/07/0010. . . $5.00 1. Introduction In object-oriented software, \nobjects often de.ne usage pro\u00adtocols that clients must follow in order for these objects to work properly. \nProtocols essentially de.ne legal sequences of method calls. In conventional object-oriented languages, \ndevelopers have three ways of .nding out about protocols: reading informal documentation, receiving runtime \nexcep\u00adtions that indicate protocol violations, or observing incorrect program behavior as a result of \nprotocol violations that broke internal invariants. It is the goal of this work to help developers follow \npro\u00adtocols while they write code as well as to allow them to cor\u00adrectly and concisely document protocols \nfor their code. We build on our previous work on leveraging typestates [34] for lightweight object protocol \nspeci.cation [4]. Our protocols are state machines that are reminiscent of Statecharts [20]. Aliasing, \ni.e. the existence of multiple references to the same object, is a signi.cant complication in checking \nwhether clients observe a protocol: a client does not neces\u00adsarily know whether its reference to an object \nis the only reference that is active at a particular execution point. This also makes it dif.cult to \ncheck whether a class implements its speci.ed protocol because reentrant callbacks through aliases can \nagain lead to unexpected state changes. Existing protocol checking approaches fall into two cate\u00adgories. \nThey either operate globally, i.e. check an entire code base at once, or severely restrict aliasing. \nGlobal analyses typically account for aliasing but they are not suitable for interactive use during development. \nMoreover, they do not check whether a declared protocol is implemented correctly, a crucial requirement \nin object-oriented software where any class might have a protocol of its own. Modular protocol checkers, \nlike Fugue [12], the .rst sound modular typestate checker for an object-oriented lan\u00adguage, better support \ndevelopers while they write code: like a typechecker, they check each method separately for pro\u00adtocol \nviolations while assuming the rest of the system to behave as speci.ed. The trade-off, unfortunately, \nhas been that modular checkers require code to follow pre-de.ned patterns of aliasing. Once a program \nleaves the realm of supported aliasing, any further state changes are forbidden. Generally speaking, \nstate changes are only allowed where the checker is aware of all references to the changing object. This \napproach has serious drawbacks. First, many exam\u00adples of realistic code might be excluded. Moreover, \nfrom a developer s point of view, the boundaries of what a checker supports are hard to predict and they \nmight not .t with the best implementation strategy for a particular problem. Fi\u00adnally, aliasing restrictions \narguably leave developers alone just when they have the most trouble in reasoning about their code, namely, \nin the presence of subtle aliasing. This paper proposes a sound modular typestate check\u00ading approach \nfor Java-like object-oriented languages that allows a great deal of .exibility in aliasing. For each \nref\u00aderence, it tracks the degree of possible aliasing, and is appropriately conservative in reasoning \nabout that refer\u00adence. This helps developers account for object manipu\u00adlations that may occur through \naliases. High precision in tracking effects of possible aliases together with system\u00adatic support for \ndynamic state tests, i.e. runtime tests on the state of objects, make this approach feasible. Our ap\u00adproach \nhelped expose a way of breaking an internal invari\u00adant that causes a commonly used Java standard library \nclass, java.io.BufferedlnputStream, to access an array out\u00adside its bounds. Contributions of this paper \ninclude the fol\u00adlowing. Our main technical contribution is a novel abstraction, called access permissions, \nthat combines typestate with aliasing information about objects. Developers use access permissions to \nexpress the design intent of their proto\u00adcols in annotations on methods and classes. Our modular checking \napproach veri.es that implementations follow this design intent. Access permissions systematically capture \ndifferent pat\u00adterns of aliasing (.gure 1). A permission tracks (a) how a reference is allowed to read \nand/or modify the referenced object, (b) how the object might be accessed through other references, and \n(c) what is currently known about the object s typestate.  In particular, our full and pure permissions \n[3] capture the situation where one reference has exclusive write access to an object (a full permission) \nwhile other references are only allowed to read from the same object (using pure permissions). Read-only \naccess through pure per\u00admissions is intuitively harmless but has to our knowledge not been exploited \nin existing modular protocol checkers.  In order to increase precision of access permissions, we include \ntwo additional novel features, which make weak permissions more useful than in existing work. We call \npermissions weak if the referenced object can poten\u00adtially be modi.ed through other permissions.  Temporary \nstate information can be associated with weak permissions. Our checking approach makes sure that temporary \nstate information is forgotten when it becomes outdated. Permissions can be con.ned to a particular part \nof the referenced object s state. This allows separate per\u00admissions to independent parts of the same \nobject. It Access through Current permission has . . . other permissions Read/write access Read-only \naccess None unique [6] Read-only full [3] immutable [6] Read/write Share [12] pure [3] Figure 1. Access \npermission taxonomy also implies a state guarantee even for weak permis\u00ad sions, i.e. a guarantee that \nthe referenced object will not leave a certain state. We handle inheritance in a novel way, giving subclasses \nmore .exibility in method overriding. This is necessary for handling realistic examples of inheritance \nsuch as Java s BufferedlnputStream (details in section 3.2).  We validated our approach with two case \nstudies, itera\u00adtors (section 2) and streams (section 3) from Sun s Java standard library implementation. \nThese case studies pro\u00advide evidence that access permissions can model realistic protocols, and protocol \nchecking based on access permis\u00adsions can be used to reason precisely about the protocols that arise \nin practice.   A more complete evaluation of our approach is beyond the scope of this paper, which \nfocuses on fully presenting our checking technique. The evaluation does establish that our compared to \nfull-.edged program veri.cation systems [26, 2] relatively simple approach can verify code idioms and \n.nd errors that no other decidable modular system can. The case studies re.ect actual Java standard library \nprotocols and, as far as we can tell, cannot be handled by any existing modular protocol veri.cation \nsystem. The following two sections introduce access permissions and veri.cation approach with examples \nfrom our case stud\u00adies before sections 4 and 5 give a formal account of our ap\u00adproach. Section 6 compares \nour approach to related work. 2. Read-Only Iterators This section illustrates basic protocol speci.cation \nand ver\u00adi.cation using our approach based on a previous case study on Java iterators [3]. Iterators follow \na straightforward pro\u00adtocol but de.ne complicated aliasing restrictions that are eas\u00adily violated by \ndevelopers. They are therefore a good vehicle to introduce our approach to handling aliasing in protocol \nveri.cation. Iterators as presented here cannot be handled by existing modular typestate checkers due \nto their aliasing restrictions. 2.1 Speci.cation Goals The speci.cation presented in this section models \nthe lterator interface de.ned in the Java standard library. For the sake of brevity we focus on read-only \niterators, i.e. iterators that cannot modify the collection on which they iterate. We will refer to read-only \niterators simply as iterators and qualify full Java iterators as modifying iterators . In earlier work \nwe showed how to capture full Java iterators [3]. Goals of the presented speci.cation include the following. \n Figure 2. Read-only iterator state machine protocol Capture the usage protocol of Java iterators. \n Allow creating an arbitrary number of iterators over col\u00adlections.  Invalidate iterators before modi.cation \nof the iterated collection.   2.2 State Machine Protocol An iterator returns all elements of an underlying \ncollection one by one. Collections in the Java standard library are lists or sets of objects. Their interface \nincludes methods to add objects, remove objects, and test whether an object is part of the collection. \nThe interface also de.nes a method iterator that creates a new iterator over the collection. Repeatedly \ncalling next on an iterator returns each object contained in the iterated collection exactly once. The \nmethod hasNext determines whether another object is available or the iteration reached its end. It is \nillegal to call next once hasNext returns false. Figure 2 illustrates this protocol as a simple state \nmachine. Notice that hasNext is legal in both states but does not change state. We call hasNext a dynamic \nstate test: its return value indicates what state the iterator is currently in. The next section will \nshow how this protocol can be speci.ed.  2.3 Iterator Interface Speci.cation States Through Re.nement. \nWe call the set of possible states of an object its state space and de.ne it as part of the object s \ninterface. As suggested above, we can model the iterator state space with two states, available and end. \nIn our approach, states are introduced by re.nement of an existing state. State re.nement corresponds \nto OR-states in Statecharts [20] and puts states into a tree hierarchy. State re.nement allows interfaces \nto, at the same time, in\u00adherit their supertypes state spaces, de.ne additional (more .ne-grained) states, \nand be properly substitutable as sub\u00adtypes of extended interfaces [4]. Re.nement guarantees that all \nnew states de.ned in a subtype correspond to a state in\u00adherited from the supertype. States form a hierarchy \nrooted in a state alive de.ned in the root type Object. Iterators there\u00adfore de.ne their state space \nas follows. states available, end refine alive; Typestates do not correspond to .elds in a class. They \ndescribe an object s state of execution abstractly and infor\u00admation about .elds can be tied to typestates \nusing state in\u00advariants (see section 3.1). Access Permissions Capture Design Intent. Iterators have \nonly two methods, but these have very different behavior. While next can change the iterator s state, \nhasNext only tests the iterator s state. And even when a call to next does not change the iterator s \nstate, it still advances the iterator to the next object in the sequence. hasNext, on the other hand, \nis pure: it does not modify the iterator at all. We use a novel abstraction, access permissions ( permis\u00adsions \nfor short), to capture this design intent as part of the it\u00aderator s protocol. Permissions are associated \nwith object ref\u00aderences and govern how objects can be accessed through a given reference [7]. For next \nand hasNext we only need two kinds of permissions; more kinds of permissions will be introduced later. \n full permissions grant read/write access to the refer\u00adenced object and guarantee that no other reference \nhas read/write access to the same object.  pure permissions grant read-only access the the refer\u00adenced \nobject but assume that other permissions could modify the object.  A distinguished full permission \ncan co-exist with an ar\u00adbitrary number of pure permissions to the same object. This property will be \nenforced when verifying protocol compli\u00adance. In a speci.cation we write perm(x) for a permission to \nan object referenced by x, where perm is one of the permis\u00adsion kinds. Access permissions carry state \ninformation about the referenced object. For example, full(this) in available represents a full permission \nfor an object (this) that is in the available state. Linear Logic Speci.cations. Methods can be speci.ed \nwith a state transition that describes how method parame\u00adters change state during method execution. We \npreviously argued that existing typestate veri.cation approaches are limited in their ability to express \nrealistic state transitions [4] and proposed to capture method behavior more precisely with logical expressions. \nAccess permissions represent resources that have to be consumed upon usage otherwise permissions could \nbe freely duplicated, possibly violating other permissions as\u00adsumptions. Therefore, we base our speci.cations \non linear logic [18]. Pre-and post-conditions are separated with a linear implication (-) and use conjunction \n(.) and disjunc\u00adtion (.).1 In certain cases, internal choice (&#38;, also called additive conjunction) \nhas been useful [3]. These connectives represent the decidable multiplicative-additive fragment of linear \nlogic (MALL). Iterators illustrate that state transitions are often non\u00addeterministic. For next, we can \nuse an imprecise post\u00adcondition and specify next so that it requires a full permis\u00adsion in state available \nand returns the full permission in the 1 Tensor (.) corresponds to conjunction, alternative (.) to disjunction, \nand lollie (-) to implication in conventional logic. The key difference is that linear logic treats known \nfacts as resources that are consumed when proving another fact. This .ts well with our intuition of permissions \nas resources that give access to objects. alive state. In a Statechart, this corresponds to transitioning \nto a state that contains substates (.gure 2). full(this) in available -full(this) in alive Dynamic state \ntests (like hasNext) require relating the (Boolean) method result to the state of the tested object (usu\u00adally \nthe receiver). A disjunction of conjunctions expresses the two possible outcomes of hasNext (.gure 4) \nwhere each conjunction relates a possible method result to the corre\u00adsponding receiver state. (We adopt \nthe convention that \u00adbinds weaker than . and ..) pure(this) -(result = true . pure(this) in available) \n. (result = false . pure(this) in end) These speci.cations enforce the characteristic hasNext / next \ncall pairing: hasNext determines the iterator s current state. If it returns true then it is legal to \ncall next. The it\u00aderator is in an unknown state after next returns, and another hasNext call determines \nthe iterator s new state.  2.4 Creating and Disposing Iterators Multiple (independent) iterators are \npermitted for a single collection at the same time. However, the collection must not be modi.ed while \niteration is in progress. Standard imple\u00admentations try to detect such situations of concurrent modi\u00ad.cation \non a best-effort basis. But, ultimately, Java program\u00admers have to make sure on their own that collections \nare not modi.ed while iterated. (Note that concurrent modi.ca\u00adtions often occur in single-threaded programs \n[32].) This section shows how the aliasing constraints between iterators and its collection can be handled. \nAs we will see, this problem is largely orthogonal to specifying the rela\u00adtively simple protocol for \nfor individual iterators that was discussed in the previous section. Immutable Access Prevents Concurrent \nModi.cation. Ac\u00adcess permissions can guarantee the absence of concurrent modi.cation. The key observation \nis that when an iterator is created it stores a reference to the iterated collection in one of its .elds. \nThis reference should be associated with a per\u00admission that guarantees the collection s immutability \nwhile iteration is in progress. We include two previously proposed permissions [6] into our system in \norder to properly specify collections. immutable permissions grant read-only access to the referenced \nobject and guarantee that no reference has read/write access to the same object.  unique permissions \ngrant read/write access and guaran\u00adtee that no other reference has any access to the object.  Thus immutable \npermissions cannot co-exist with full permissions to the same object. We can specify the collec\u00adtion \ns iterator method using these permissions as follows. Notice how it consumes or captures the incoming \nreceiver permission and returns an initial unique permission to a fresh Collection c = new ... Iterator \nit = c.iterator(); II legal while(it.hasNext() &#38;&#38; ...) { II legal Object o = it.next(); II legal \nIterator it2 = c.iterator(); II legal while(it2.hasNext()) { II legal Object o2 = it2.next(); II legal \n... } } if(it.hasNext() &#38;&#38; c.size() == 3) { II legal c.rerove(it.next()); II legal if(it.hasNext()) \n... } II ILLEGAL Iterator it3 = c.iterator(); II legal Figure 3. A simple lterator client iterator object. \npublic class Collection { Iterator iterator() : immutable(this) -unique(result) } It turns out that \nthis speci.cation precisely captures Sun s Java standard library implementation of iterators: Iterators \nare realized as inner classes that implicitly reference the collection they iterate. Permission Splitting. \nHow can we track permissions? Consider a client such as the one in .gure 3. It gets a unique permission \nwhen .rst creating a collection. Then it creates an iterator which captures an immutable permis\u00adsion \nto the collection. However, the client later needs more immutable permissions to create additional iterators. \nThus while a unique permission is intuitively stronger than an immutable permission we cannot just coerce \nthe client s unique permission to an immutable permission and pass it to iterator: it would get captured \nby the newly created it\u00aderator, leaving the client with no permission to the collection at all. In order \nto avoid this problem we use permission splitting in our veri.cation approach. Before method calls we \nsplit the original permission into two, one of which is retained by the caller. Permissions are split \nso that their assumptions are not violated. In particular, we never duplicate a full or unique permission \nand make sure that no full permission co-exists with an immutable permission to the same object. Some \nof the legal splits are the following. unique(x) = full(x) . pure(x) full(x) = immutable(x) . immutable(x) \nimmutable(x) = immutable(x) . immutable(x) immutable(x) = immutable(x) . pure(x) They allow the example \nclient in .gure 3 to retain an immutable permission when creating iterators, permitting multiple iterators \nand reading the collection directly at the same time. Permission Joining Recovers Modifying Access. When \nsplitting a full permission to a collection into immutable interface Iterator<c : Collection, k : Fract>{ \nstates available, end refine alive boolean hasNext() : pure(this) -(result = true . pure(this) in available)) \n. (result = false . pure(this) in end) Object next() : full(this) in available -full(this) void finalize() \n: unique(this) -immutable(c,k) } interface Collection { void add(Object o) : full(this) -full(this) int \nsize() : pure(this) -result = 0 . pure(this) II rerove(), contains() etc. sirilar Iterator<this, k > \niterator() : immutable(this,k) -unique(result) } Figure 4. Read-only lterator and partial Collection \ninterface speci.cation permissions we lose the ability to modify the collection. Intuitively, we would \nlike to reverse permission splits to regain the ability to modify the collection. Such permission joining \ncan be allowed if we introduce the notion of fractions [6]. Essentially, fractions keep track of how \noften a permission was split. This later allows join\u00ading permissions (with known fractions) by putting \ntogether their fractions. A unique permission by de.nition holds a full fraction that is represented \nby one (1). We will capture fractions as part of our permissions and write (perm)(x, k) for a given permission \nwith fraction k. We usually do not care about the exact fraction and therefore implicitly quan\u00adtify over \nall fractions. If a fraction does not change we often will omit it. Fractions allow us to de.ne splitting \nand joining rules as follows. unique(x, 1) .=full(x, 1/2) . pure(x, 1/2) full(x, k) .=immutable(x, k/2) \n. immutable(x, k/2) immutable(x, k) .=immutable(x, k/2) . immutable(x, k/2) immutable(x, k) .=immutable(x, \nk/2) . pure(x, k/2) For example, we can split full(it, 1/2) into full(it, 1/4) . pure(it, 1/4) and recombine \nthem. Such reasoning lets our iterator client recover a unique iterator permission after each call into \nthe iterator. Recovering Collection Permissions. Iterators are created by trading a collection permission \nfor a unique iterator per\u00admission. We essentially allow the opposite trade as well in order to modify \na previously iterated collection again: We can safely consume a unique iterator permission and recover \nthe permissions to its .elds because no reference will be able to access the iterator anymore. A simple \nlive variable analy\u00adsis can identify when variables with unique permissions are no longer used. (As a \nside effect, a permission-based ap\u00adproach therefore allows identifying dead objects.) Collection c = \nnew ... unique(c) Iterator it<c, 1I2> = c.iterator(); immutable(c, 1/2) . unique(it) while(it.hasNext() \n&#38;&#38; ...) { immutable(c, 1/2) . unique(it) in available Object o = it.next(); immutable(c, 1/2) \n. unique(it) Iterator it2<c, 1I4> = c.iterator(); immutable(c, 1/4) . unique(it) . unique(it2) while(it2.hasNext()) \n{ immutable(c, 1/4) . unique(it) . unique(it2) in available Object o2 = it2.next(); immutable(c, 1/4) \n. unique(it) . unique(it2) ... } II it2 dies } immutable(c, 1/2) . unique(it) if(it.hasNext() &#38;&#38; \nc.size() == 3) { immutable(c, 1/2) . unique(it) in available c.rerove(it.next()); II it dies after next() \nunique(c) and no permission for it if(it.hasNext()) ... } II ILLEGAL II it definitely dead unique(c) \nIterator it3<c, 1I2> = c.iterator(); immutable(c, 1/2) . unique(it3) Figure 5. Verifying a simple lterator \nclient For lack of a more suitable location, we annotate the finalize method to indicate what happens \nwhen an iter\u00adator is no longer usable. And in order to re-establish exactly the permission that was originally \npassed to the iterator we parameterize lterator objects with the collection permis\u00adsion s fraction. The \nfinalize speci.cation can then release the captured collection permission from dead iterators. The complete \nspeci.cation for iterators and a partial collection speci.cation are summarized in .gure 4. 2.5 Client \nVeri.cation Figure 5 illustrates how our client from .gure 3 can be veri.ed by tracking permissions and \nsplitting/joining them as necessary. After each line of code we show the current set of permissions on \nthe right-hand side of the .gure. We recover collection permissions from dead iterators as soon as possible. \nThis lets us verify the entire example client. We correctly identify the seeded protocol violation. \n2.6 Summary We presented a speci.cation of read-only iterators that pre\u00advents concurrent collection modi.cation. \nTo this end it asso\u00adciates collections and iterators with access permissions, de\u00ad.nes a simple state \nmachine to capture the iterator usage pro\u00adtocol, and tracks permission information using a decidable \nfragment of linear logic. Our logic-based speci.cations can relate objects to precisely specify method \nbehavior in terms of typestates and support reasoning about dynamic tests.  3. Java Stream Implementations \nI/O protocols are common examples for typestate-based pro\u00adtocol enforcement approaches [11, 12, 4]. This \nsection sum\u00adFigure 6. PipedlnputStream s state space (inside open) marizes a case study in applying \nour approach to Java char\u00adacter streams and in particular stream pipes and buffered in\u00adput streams. The \nsection focuses on implementation veri.ca\u00adtion of stream classes, which to our knowledge has not been \nattempted with typestates before. Implementation veri\u00ad.cation generalizes techniques shown in the previous \nsection for client veri.cation. 3.1 Stream Pipes Pipes are commonly used in operating system shells \nto for\u00adward output from one process to another process. Pipes carry alphanumeric characters for a source \nto a sink. The Java I/O library includes a pair of classes, PipedOutputStream and PipedlnputStream, that \noffers this functionality inside Java applications. This section provides a speci.cation for Java pipes \nand shows how the classes implementing pipes in the Java standard library can be checked using our approach. \nInformal Pipe Contract. In a nutshell, Java pipes work as follows: A character-producing writer writes \ncharacters into a PipedOutputStream (the source ) that forwards them to a connected PipedlnputStream \n(the sink ) from which a reader can read them. The source forwards char\u00adacters to the sink using the \ninternal method receive. The writer calls close on the source when it is done, causing the source to \ncall receivedLast on the sink (.gure 7). The sink caches received characters in a circular buffer. Calling \nread on the sink removes a character from the buffer (.gure 8). Eventually the sink will indicate, using \nan end of .le token (EOF, -1 in Java), that no more characters can be read. At this point the reader \ncan safely close the sink. Closing the sink before EOF was read is unsafe because the writer may still \nbe active. The pipe classes in Sun s standard library implementation have built-in runtime checks that \nthrow exceptions in the following error cases: (1) closing the sink before the source, (2) writing to \na closed source or pushing characters to the sink after the source was closed, and (3) reading from a \nclosed sink. The speci.cation we present here makes these error cases impossible. State Space with Dimensions. \nThe source protocol can be modeled with three states raw, open, and cloSed. raw indicates that the source \nis not connected to a sink yet. For technical reasons that are discussed below, we re.ne open into ready \nand Sending. The writer will always .nd the source in state ready. For the sink protocol we again distinguish \nopen and cloSed. A re.nement of open helps capturing read s pro\u00adtocol: The sink is within as long as \nread returns characters; the eof state is reached when read returns the EOF token. While within, we keep \ntrack of the sink s buffer being empty or nonEmpty. We further re.ne nonEmpty into partial and flled, \nthe latter corresponding to a full buffer. At the same time, however, we would like to track whether \nthe source was closed, i.e., whether receivedLast was called. We previously proposed state dimensions \nto ad\u00address such separate concerns (here, the buffer .lling and the source state) [4] with states that \nare independent from each other. State dimensions correspond to AND-states in State\u00adcharts [20]. We can \nsimply re.ne nonEmpty twice, along different dimensions. We call the states for the second dimension \nSourceOpen and SourceCloSed with the obvious semantics. Note that we only need the additional Source \ndimension while the buffer is nonEmpty; the source is by de.nition open (closed) in the empty (eof ) \nstate.2 To better visualize the sink s state space, .gure 6 summarizes it as a Statechart. Shared Modifying \nAccess. Protocols for source and sink are formalized in .gures 7 and 8 with speci.cations that work similar \nto the iterator example in the last section. How\u00adever, the sink is conceptually modi.ed through two distinct \nreferences, one held by the source and one held by the reader. In order to capture this, we introduce \nour last permission. Share permissions grant read/write access to the refer\u00adenced object but assume that \nother permissions have read/write access as well. Conventional programming languages effectively always \nuse Share permissions for mutable state. Interestingly, Share permissions are split and joined exactly \nlike immutable per\u00admissions. Since Share and immutable permissions cannot co\u00adexist, our rules force a \ncommitment to either one when ini\u00adtially splitting a full permission. full(x, k) = share(x, k/2) . share(x, \nk/2) share(x, k) = share(x, k/2) . share(x, k/2) share(x, k) = share(x, k/2) . pure(x, k/2) State Guarantees. \nWe notice that most modifying methods cannot change a stream s state arbitrarily. For example, read and \nreceive will never leave the open state and they cannot tolerate other permission to leave open. We make \nthis idea part of our access permissions. We include another parameter into permissions that speci.es \na state guarantee, i.e. a state that cannot be left even by mod\u00adifying permissions. Thus a state guarantee \n(also called the permission s root) corresponds to an area in a Statechart that cannot be left. As an \nexample, we can write the permis\u00ad 2 This is only one way of specifying the sink. It has the advantage \nthat read\u00aders need not concern themselves with the internal communication between source and sink. public \nclass PipedOutputStrear { states raw, open, closed refine alive; states ready, sending refine open; raw \n:= sink = null ready := half(sink, open) sending := sink = null closed := sink = null private PipedInputStrear \nsink; public PipedOutputStrear() : 1 -unique(this) in raw {} void connect(PipedInputStrear snk) : full(this) \nin raw . half(snk, open) \u00ad full(this) in ready { sink = snk; store permission in .eld } full(this) in \nopen public void write(int b) : full(this, open) in ready . b = 0 -full(this, open) in ready { half(sink, \nopen) from invariant sink.receive(b); returns half(sink, open) } full(this, open) in ready public void \nclose() : full(this) in ready -full(this) in closed { half(sink, open) from invariant sink.receivedLast(); \nconsumes half(sink, open) } full(this) in closed } Figure 7. Java PipedOutputStream (simpli.ed) sion \nneeded for read as Share(this, open). Without an ex\u00adplicit state guarantee, only alive is guaranteed \n(this is what we did for iterators). State guarantees turn out to be crucial in making Share and pure \npermissions useful because they guarantee a state even in the face of possible changes to the referenced \nobject through other permissions. Moreover, if we combine them with state dimensions we get independent \npermissions for orthogonal object aspects that, e.g., let us elegantly model modifying iterators [3]. \nExplicit Fractions for Temporary Heap Sharing. When specifying the sink methods used by the source (receive \nand receivedLast) we have to ensure that the source can no longer call the sink after receivedLast so \nthe sink can be safely closed. Moreover, in order to close the sink, we need to restore a permission \nrooted in alive. Thus the two Share permissions for the sink have to be joined in such a way that there \nare de.nitely no other permissions relying on open (such permissions, e.g., could have been split off \nof one of the Share permissions). We extend the notion of fractions to accomplish this task. We use fractions \nto track, for each state separately, how many permissions rely on it. What we get is a fraction function \nthat maps guaranteed states (i.e. the permission s class PipedInputStrear { strear = open, closed refines \nalive; position = within, eof refines open; buffer = erpty, nonErpty refines within; filling = partial, \nfilled refines nonErpty; source = sourceOpen, sourceClosed refines nonErpty; empty := in = 0 . closedByWriter \n= false partial := in = 0 . in = out flled := in = out sourceOpen := closedByWriter = false sourceClosed \n:= closedByWriter . half(this, open) eof := in = 0 . closedByWriter . half(this, open) private boolean \nclosedByWriter = false; private volatile boolean closedByReader = false; private byte buffer[] = new \nbyte[1024]; private int in = -1, out = 0; public PipedInputStrear(PipedOutputStrear src) : full(src) \nin raw -half(this, open) . full(src) in open { unique(this) in open = half(this, open) . half(this, open) \nsrc.connect(this); consumes one half(this, open) } half(this, open) . full(src) in open synchronized \nvoid receive(int b) : half(this, open) . b = 0 -half(this, open) in nonEmpty { II standard irplerentation \nchecks if pipe intact while(in == out) half(this, open) in flled ... II wait a second half(this, open) \nin empty . partial if(in< 0){in= 0;out= 0;} buffer[in++] (byte)(b &#38; 0xFF); if(in >= buffer.length) \nin = 0; } half(this, open) in partial synchronized void receivedLast() : half(this, open) -1 { closedByWriter \n= true; } this is now sourceClosed public synchronized int read() : share(this, open) -(result = 0 . \nshare(this, open)) . (result = -1 . share(this, open) in eof) { ... } II analogous to receive() public \nsynchronized void close() : half(this, open) in eof -unique(this) in closed { half(this, open) from eaf \ninvariant = unique(this, open) closedByReader = true; in= -1; } } Figure 8. Java PipedlnputStream (simpli.ed) \n root and its super-states) to fractions. For example, if we split an initial unique permission for a \nPipedlnputStream into two Share permissions guaranteeing open then these permissions rely on open and \nalive with a 1/2 fraction each. (Iterator permissions root in alive and their fraction functions map \nalive to the given fraction.) In order to close the sink, we have to make sure that there are exactly \ntwo Share permissions relying on open. Fraction functions make this requirement precise. For readability, \nwe use the abbreviation half in .gure 8 that stands for the following permission. half(x, open) = Share(x, \nopen, {alive . 1/2, open . 1/2}) By adding fractions and moving the state guarantee up in the state hierarchy, \nthe initial permission for the sink, unique(this, alive, {alive . 1}), can be regained from two half(this, \nopen) permissions. half is the only permission with an explicit fraction function. All other speci.cations \nimplicitly quantify over all fraction functions and leave them unchanged. State Invariants Map Typestates \nto Fields. We now have a suf.cient speci.cation for both sides of the pipe. In order to verify their \nimplementations we need to know what types\u00adtates correspond to in implementations. Our implementation \nveri.cation extends Fugue s approach of using state invari\u00adants to map states to predicates that describe \nthe .elds of an object in a given state [12]. We leverage our hierarchi\u00adcal state spaces and allow state \ninvariants for states with re\u00ad.nements to capture invariants common to all substates of a state. Figure \n7 shows that the source s state invariants describe its three states in the obvious way based on the \n.eld snk pointing to the sink. Notice that the invariant does not only talk about the sink s state (as \nin Fugue) but uses permissions to control access through .elds just as through local vari\u00adables. The \nsink s state invariants are much more involved (.g\u00adure 8) and de.ne, e.g., what the difference between \nan empty buffer (in < 0) and a flled circular buffer (in = out) is. Interestingly, these invariants are \nall meticulously docu\u00admented in the original Java standard library implementation for PipedlnputStream \n[4]. The half permission to itself that the sink temporarily holds for the time between calls to receivedLast \nand close lets us verify that close is al\u00adlowed to close the sink. Veri.cation with Invariants. Implementation \nchecking as\u00adsumes state invariants implied by incoming permissions and tracks changes to .elds. Objects \nhave to be in a state when\u00adever they yield control to another object, including during method calls. \nFor example, the source transitions to Sending before calling the sink. However, the writer never .nds \nthe source in the Sending state but always ready Sending never occurs in a method speci.cation. We call \nstates that are not observed by a client intermediate states. They help us deal with re-entrant calls \n(details in section 5.2). A practical syn\u00adtax could make such intermediate states implicit. Figures 7 \nand 8 show how implementation checking pro\u00adceeds for most of the source s and sink s methods. We show \nin detail how .eld assignments change the sink s state. The sink s state information is frequently a \ndisjunction of possi\u00adble states. Dynamic tests essentially rule out states based on incompatible invariants. \nAll of these tests are present in the Figure 9. Frames of a BufferedlnputStream instance in state filled. \nThe blue virtual frame is in a different state than its super-frame.  original Java implementation; \nwe removed additional non\u00adnull and state tests that are obviated by our approach. This not only shows \nhow our approach forces necessary state tests but also suggests that our speci.cations could be used \nto gen\u00aderate such tests automatically. 3.2 Buffered Input Streams A BufferedlnputStream (or buffer , \nfor short) wraps an\u00adother underlying stream and provides buffering of charac\u00adters for more ef.cient retrieval. \nWe will use this example to illustrate our approach to handling inheritance. Compared to the original \nimplementation, we made .elds private in or\u00adder to illustrate calls to overridden methods using super. \nWe omit intermediate states in this speci.cation. Class Hierarchy. BufferedlnputStream is a subclass \nof FilterlnputStream, which in turn is a subclass of lnputStream. lnputStream is the abstract base class \nof all input streams and de.nes their protocol with informal docu\u00admentation that we formalize in .gure \n10. It implements con\u00advenience methods such as read(int[J) in terms of other abstract methods. FilterlnputStream \nholds an underly\u00ading stream in a .eld s and simply forwards all calls to that stream (.gure 10). BufferedlnputStream \noverrides these methods to implement buffering. Frames. The buffer occasionally calls overridden meth\u00adods \nto read from the underlying stream. How can we reason about these internal calls? Our approach is based \non Fugue s frames for reasoning about inheritance [12]. Objects are bro\u00adken into frames, one for each \nclass in the object s class hi\u00aderarchy. A frame holds the .elds de.ned in the correspond\u00ading class. We \ncall the frame corresponding to the object s runtime type the virtual frame, referred to with normal \nref\u00aderences (including this). Relative to a method, we call the current frame corresponding to the class \nthat the method is de.ned in with thisfr , and the frame corresponding to public abstract class InputStrear \n{ public class BufferedInputStrear states open, closed refine alive; extends FilterInputStrear { states \nwithin, eof refine open; states depleted, filled refine within; public abstract int read() : closed := \nunique(super) in closed . buf = null share(thisf\", open) -(result = 0 . share(thisf\", open)) open := \nunique(buf) . (result = -1 . share(thisf\", open) in eof) flled := pos < count . unique(super) in open \npublic abstract void close() : depleted := pos = count . unique(super) in within full(thisf\", alive) \nin open -full(thisf\", alive) in closed eof := pos = count . unique(super) in in eof public int read(byte[] \nbuf) : private byte buf[] = new byte[8192]; share(this, open) . buf = null -private int count = 0, pos \n= 0; (result = -1 . share(this, open) in eof) . (result = 0 . share(this, open)) public BufferedInputStrear(InputStrear \ns) { ... for(...) unique(s) in open -unique(thisf\" ) in open ... int c = this.read() ... } { count = \npos =0 . unique(buf) } super(s); unique(super) in open } unique(thisf\", alive) in open public class FilterInputStrear \nextends InputStrear { within := unique(s) in within public synchronized int read() { eof := unique(s) \nin eof if(pos >= count) closed := unique(s) in closed { share(thisf\", open) in depleted . eof fill(); \nshare(thisf\", open) in flled . eof private volatile InputStrear s; if(pos >= count) return -1; returns \nshare(thisf\", open) in eof protected FilerInputStrear(InputStrear s) } any path: share(thisf\", open) \nin flled unique(s, alive) in open -unique(thisf\", alive) in open return buf[pos++] &#38; 0xFF; { this.s \n= s; } } share(thisf\", open) in flled . eof ... II read() and close() forward to s } private void fill() \nshare(thisf\", open) in depleted . eof \u00adshare(thisf\", open) in flled . eof Figure 10. Java FilterlnputStream \nforwards all calls to { invariant: unique(super) in within . eof underlying lnputStream (simpli.ed) count \n= pos = 0; note: assumes buffer was fully read int b = super.read(); unique(super) in within . eof while(b \n>= 0) { unique(super) in within the immediate superclass is called super frame. Figure 9 buf[count++] \n= (byte) (b &#38; 0xFF); shows a sample BufferedlnputStream instance with its share(thisf\", open) in \nflled three frames. if(count >= buf.length) break; b = super.read(); unique(super) in within . eof Frame \nPermissions. In our approach, a permission actu-} if loop never taken, share(thisf\", open) in eof ally \ngrants access to a particular frame. The permissions we } share(this, open) in flled . eof have seen \nso far give a client access to the referenced ob\u00ad public synchronized void close() { ject s virtual frame. \nPermissions for other frames are only buf = null; invariant: unique(super) in open accessible from inside \na subclass through super. super.close(); unique(super) in closed Figure 9 illustrates that a BufferedlnputStream \ns state } full(thisf\", alive) in closed can differ from the state its .lter frame is in: the .lter s \nstate might be eof (when the underlying stream reaches eof ) while the buffer s is still within (because \nthe buffer array Figure 11. BufferedlnputStream caches characters from still holds unread characters). \nThe state invariants in .gure FilterlnputStream base class 11 formalize this. They let us verify that \nsuper calls in the buffer implementation respect the .lter s protocol. Because the states of frames \ncan differ it is important to enforce that a permission is only ever used to access .elds in the frame \nit grants permission to. In speci.cations we This distinction implies that fill (.gure 11) cannot call \nspeci.cally mark permissions that will actually access .elds read(int[J) (because it does not have a \nsuitable virtual (and not just call other methods) of the receiver with thisfr . frame permission) but \nonly super.read(). This is impera-We require all methods that use these permissions to be tive for the \ncorrectness of fill because a dynamically dis\u00adoverridden. On the other hand, convenience methods such \npatched call would lead back into the still empty buffer, as read(int[J) can operate with permissions \nto the virtual causing an in.nite loop. (One can trigger exactly this effect frame and need not be overridden \n(.gure 10). in the Java 6 implementation of BufferedlnputStream.) 3.3 Summary This section showed how \nour approach can be used to ver\u00adify realistic Java pipe and buffered input stream imple\u00admentations. The \nnotion of access permissions is central to our approach. Overall, we introduced .ve different kinds of \npermissions (.gure 1). While three kinds are adapted from existing work [7, 12] we recently proposed \nfull and pure permissions [3]. State guarantees and temporary state information increase the usefulness \nof weak (Share and pure) permissions. Permission splitting and joining is .exi\u00adble enough to model temporary \naliasing on the stack (during method calls) and in the heap (e.g., in pipes and iterators). Permission-based \nstate invariants enable reasoning about protocol implementations. We handle inheritance based on frames \n[12] and permit dynamic dispatch within objects for convenience methods.  4. Formal Language This section \nformalizes an object-oriented language with protocol speci.cations. We brie.y introduce expression and \nclass declaration syntax before de.ning state spaces, access permissions, and permission-based speci.cations. \nFinally, we discuss handling of inheritance and enforcement of be\u00adhavioral subtyping. 4.1 Syntax Figure \n12 shows the syntax of a simple class-based object\u00adoriented language. The language is inspired by Feather\u00adweight \nJava (FJ, [24]); we will extend it to include type\u00adstate protocols in the following subsections. We identify \nclasses (C), methods (m), and .elds (f) with their names. As usual, x ranges over variables including \nthe distin\u00adguished variable this for the receiver object. We use an over\u00adbar notation to abbreviate a \nlist of elements. For example, x : T = x1:T1, ..., xn:Tn. Types (T ) in our system in\u00adclude Booleans \n(bool) and classes. Programs are de.ned with a list of class declarations and a main expression. A class \ndeclaration CL gives the class a unique name C and de.nes its .elds, methods, typestates, and state invariants. \nA constructor is implicitly de.ned with the class s own and inherited .elds. Fields (F ) are declared \nwith their name and type. Each .eld is mapped into a part of the state space n that can depend on the \n.eld (details in section 5.2). A method (M) declares its result type, formal parameters, speci.cation \nand a body expression. State re\u00ad.nements R will be explained in the next section; method speci.cations \nMS and state invariants N are deferred to sec\u00adtion 4.4. We syntactically distinguish pure terms t and \npossibly ef\u00adfectful expressions e. Arguments to method calls and object construction are restricted to \nterms. This simpli.es reason\u00ading about effects [30, 9] by making execution order explicit. Notice that \nwe syntactically restricts .eld access and as\u00adsignments to .elds of the receiver class. Explicit getter \nand setter methods can be de.ned to give other objects access to .elds. Assignments evaluate to the previous \n.eld value. programs class decl. .eld decl. PR CL F ::= ::= ::= (CL, e) class C extends CI { F R I N \nM }f : T in n meth. decl. state decl. M R ::= ::= T m(T x) : MS = e d = s refines s0 terms expressions \nvalues references types nodes t e v r T n ::= |::= ||::= ::= ::= ::= x | o | true | false t1 and t2 | \nt1 or t2 | not t t | f | assign f := t new C(t) | t0.m(t) | super.m(t) if(t, e1, e2) | let x = e1 in \ne2 o | true | false x | f | o C | bool s | d classes methods C m .elds states f s variables dimensions \nx d objects o Figure 12. Core language syntax. Speci.cations (I, N, MS) in .gure 14.  4.2 State Spaces \nState spaces are formally de.ned as a list of state re.nements (see .gure 12). A state re.nement (R) \nre.nes an existing state in a new dimension with a set of mutually exclusive sub-states. We use s and \nd to range over state and dimension names, respectively. A node n in a state space can be a state or \ndimension. State re.nements are inherited by subclasses. We assume a root state alive that is de.ned \nin the root class Object. We de.ne a variety of helper judgments for state spaces in .gure 13. refnementS(C) \ndetermines the list of state re.nements available in class C. C f A wf de.nes well formed state assumptions. \nAssumptions A combine states and are de.ned in .gure 14. Conjunctive assumptions have I to cover orthogonal \nparts of the state space. C f n = nde.nes the substate relation for a class. C f A # AI de.nes orthogonality \nof state assumptions. A and AI are orthogonal if they refer to different (orthogonal) state dimensions. \nC f A -n de.nes that a state assumption A only refers to states underneath a root node n. C f A \u00ab n .nds \nthe tightest such n. 4.3 Access Permissions Access permissions p give references permission to access \nan object. Permissions to objects are written acceSS(r, n, g, k, A) (.gure 14). (We wrote perm(r, n, \ng) in A before.) The ad\u00additional parameter k allows us to uniformly represent all permissions as explained \nbelow. Permissions are granted to references r. References can be variables, locations, and .elds. \n Permissions apply to a particular subtree in the space space of r that is identi.ed by its root node \nn. It rep\u00ad  class C extends CI { F R ... } refnementS(CI)= RI n in refnementS(C) refnementS(Object)= \n\u00b7 refnementS(C)= RI ,R C f n wf C f A1 wf C f A2 wf C f A1 wf A1 # A2 C f A2 wf d = s refines s . refnementS(C) \nC f n wf C f A1 . A2 wf C f A1 . A2 wf C f si = dC f d = sC f n = n II II = nI* dI = dI C f n = nC f \nnd = s refines s . refnementS(C)= sI refines s * . refnementS(C) d C f n = nI C f d # dI III I C f n1 \n= nC f n# nC f n2 = nC f AI # AC f A1,2 # AC f A1,2 # AC f nI = n 112 2 I C f n1 # n2 C f A # AI C f \nA1 . A2 # AC f A1 . A2 # AC f n-n I C f A1,2 -nC f A1 . A2 wf C f A1,2 -nC f A1 . A2 wf C f A -n .nI \n: C f A -nI implies n = nC f A1 . A2 -nC f A1 . A2 -nC f A \u00ab n Figure 13. State space judgments (assumptions \nA de.ned in .gure 14) resents a state guarantee (section 3). Other parts of the state space are unaffected \nby the permission. The fraction function g tracks for each node on the path from n to alive a symbolic \nfraction [6]. The fraction func\u00adtion keeps track of how often permissions were split at different nodes \nin the state space so they can be coalesced later (see section 5.5).  The subtree fraction k encodes \nthe level of access granted by the permission. k> 0 grants modifying access. k< 1 implies that other \npotentially modifying permissions exist. Fraction variables z are conservatively treated as a value between \n0 and 1, i.e., 0 <z< 1.  An state assumption A expresses state knowledge within the permission s subtree. \nOnly full permissions can per\u00admanently make state assumptions until they modify the object s state themselves. \nFor weak permissions, the state assumption is temporary, i.e. lost after any effectful ex\u00adpression (because \nthe object s state may change without the knowledge of r).  We can encode unique, full, Share, and pure \npermissions as follows. In our formal treatment we omit immutable per\u00admissions, but it is straightforward \nto encode them with an additional bit that distinguishes immutable and Share per\u00admissions. unique(r, \nn, g) in A = acceSS(r, n, {g, n . 1}, 1,A) full(r, n, g) in A = acceSS(r, n, g, 1,A) Share(r, n, g, k) \nin A = acceSS(r, n, g, k, A) (0 <k< 1) pure(n, n, g) in A = acceSS(r, n, g, 0,A)  4.4 Permission-Based \nSpeci.cations We combine atomic permissions (p) and facts about Boolean values (q) using linear logic \nconnectives (.gure 14). We also include existential (.z : H.P ) and universal quanti.cation of fractions \n(.z : H.P ) to alleviate programmers from writing concrete fraction functions in most cases. We type \nall expressions as an existential type (E). permissions p ::= acceSS(r, n, g, k, A) facts assumptions \nfraction fct. fractions predicates method specs q A g k P MS ::= ::= ::= |::= ::= ||||::= t = true | \nt = false n | A1 . A2 | A1 . A2 z | n . v g/2 | g1, g2 1 | 0 | z | k/2 p | q P1 . P2 | 1 P1 &#38; P2 \n| T P1 . P2 | 0 .z : H.P | .z : H.P P -E expr. types E ::= .x : T.P state inv. N ::= n = P initial state \nprecise state I S ::= ::= initially (.f : T .P, S)s1 . . . . . sn fract. terms fract. types fract. vars. \nh H z ::= ::= g | k Fract | n . Fract Figure 14. Permission-based speci.cations  Method speci.cations. \nMethods are speci.ed with a linear implication (-) of predicates (MS). The left-hand side of the implication \n(method pre-condition) may refer to method receiver and formal parameters. The right-hand side (post\u00adcondition) \nexistentially quanti.es the method result (a simi\u00adlar technique is used in Vault [11]). We refer to the \nreceiver with this and usually call the return value result. State invariants. We decided to use linear \nlogic predicates for state invariants as well (N). In general, several of the de.ned state invariants \nwill have to be satis.ed at the same time. This is due to our hierarchical state spaces. Each class declares \nan initialization predicate and a start state (I) that are used for object construction (instead of an \nexplicit con\u00adstructor). 4.5 Handling Inheritance Permissions give access to a particular frame, usually \nthe vir\u00adtual frame (see section 3.2) of an object. Permissions to the virtual frame are called object \npermissions. Because of sub\u00adtyping, the precise frame referenced by an object permission is statically \nunknown. references r ::= ... | super | thisfr In order to handle inheritance, we distinguish references \nto the receiver s current frame (thisfr ) and its super-frame (super). Permissions for these special \nreferences are called frame permissions.A thisfr permission grants access to .elds and can be used in \nmethod speci.cations. Permissions for super are needed for super-calls and are only available in state \ninvariants. All methods requiring a thisfr permission must be overridden because such methods rely on \nbeing de.ned in a particular frame to access its .elds. 4.6 Behavioral Subtyping Subclasses should be \nallowed to de.ne their own speci.\u00adcations, e.g. to add precision or support additional behav\u00adior [4]. \nHowever, subclasses need to be behavioral sub\u00adtypes [29] of the extended class. Our system enforces be\u00adhavioral \nsubtyping in two steps. Firstly, state space inheri\u00adtance conveniently guarantees that states of subclasses \nal\u00adways correspond to states de.ned in superclasses [4]. Sec\u00adondly, we make sure that every overriding \nmethod s speci.\u00adcation implies the overridden method s speci.cation [4] us\u00ading the override judgment \n(.gure 16) that is used in checking method declarations. This check leads to method speci.ca\u00adtions that \nare contra-variant in the domain and co-variant in the range as required by behavioral subtyping.  \n5. Modular Typestate Veri.cation This section describes a static modular typestate checking technique \nfor access permissions similar to conventional typechecking. It guarantees at compile-time that protocol \nspeci.cations will never be violated at runtime. We empha\u00adsize that our approach does not require tracking \ntypestates at run time. A companion technical report contains additional judg\u00adments and a soundness proof \nfor a fragment of the system presented in this paper [5]. The fragment does not include inheritance and \nonly supports permissions for objects as a whole. State dimensions are omitted and speci.cations are \ndeterministic. The fragment does include full, Share, and pure permissions with fractions and temporary \nstate infor\u00admation. 5.1 Permission Tracking We permission-check an expression e with the judgment G; \n. fi e : .x : T.P \\E. This is read as, in valid C context G and linear context ., an expression e executed \nwithin receiver class C has type T, yields permissions P , and affects .elds E . Permissions . are consumed \nin the process. We omit the receiver C where it is not required for checking a particular syntactic form. \nThe set E keeps track of .elds that were assigned to, which is important for the correct handling of \npermissions to .elds. It is omitted when empty. The marker i in the judgment can be 0 or 1 where i =1 \nindicates that states of objects in the context may change during evaluation of the expression. This \nwill help us reason about temporary state assumptions. A combination of markers with i . j is 1 if at \nleast one of the markers is 1. valid contexts G ::= \u00b7| G,x : T | G,z : H | G,q linear contexts . ::= \n\u00b7| .,P effects E ::= \u00b7|E,f Valid and linear contexts distinguish valid (permanent) information (G) from \nresources (.). Resources are tracked linearly, forbidding their duplication, while facts can be used \narbitrarily often. (In logical terms, contraction is de.ned for facts only). The valid context types \nobject variables, fraction variables, and location types and keeps track of facts about terms q. Fraction \nvariables are tracked in order to handle fraction quanti.cation correctly. The linear context holds currently \navailable resource predicates. The judgment G f t : T types terms. It includes the usual rule for subsumption \nbased on nominal subtyping induced by the extendS relation (.gure 16). Term typing is com\u00adpletely standard \nand can be found in the companion report. The companion report also includes rules for formally typing \nfractions and fraction functions [5]. Our expression checking rules are syntax-directed up to reasoning \nabout permissions. Permission reasoning is de\u00adferred to a separate judgment G; . f P that uses the rules \nof linear logic to prove the availability of permissions P in a given context. This judgment will be \ndiscussed in section 5.5. Permission checking rules for most expressions appear in .gure 15 and are described \nin turn. Packing, method calls, and .eld assignment are discussed in following subsections. Helper judgments \nare summarized in .gure 16. The notation [eI/x]e substitutes eI for occurrences of x in e. P-TERM embeds \nterms. It formalizes the standard logical judgment for existential introduction and has no effect on \nexisting objects.  P-FIELD checks .eld accesses analogously.  P-NEW checks object construction. The \nparameters passed to the constructor have to satisfy initialization predicate P and become the object \ns initial .eld values. The new existentially quanti.ed object is associated with a unique permission \nto the root state that makes state assumptions according to the declared start state A. Object construc\u00adtion \nhas no effect on existing objects. The judgment init (.gure 16) looks up initialization pred\u00adicate and \nstart state for a class. The start state is a con\u00adjunction of states (.gure 14). The initialization predicate \nis the invariant needed for the start state.  P-IF introduces non-determinism into the system, re\u00ad.ected \nby the disjunction in its type. We make sure that the predicate is of Boolean type and then assume its \ntruth  G f t : T G; . f [t/x]P localFieldS(C)= f : T G; . f [fi/x]P P-TERM P-FIELD G; . f0 t : .x : \nT.P G; . f0 fi : .x : Ti.P C G f t : T init(C)= (.f : T .P, A) G; . f [t/f]P P-NEW G; . f0 new C(t): \n.x : C.acceSS(x, alive, {alive . 1}, 1,A) (G,t = true); . fi e1 : .x : T.P1 \\E1 G f t : bool (G,t = false); \n. fj e2 : .x : T.P2 \\E2 P-IF G; . fi.j if(t, e1,e2): .x : T.P1 . P2 \\E1 .E2 G; . fi e1 : .x : T.P \\E1 \n(G,x : T ); (.I,P ) fj e2 : E2 \\E2 i =1 implies no temporary assumptions in .I Fields in E1 do not occur \nin .I P-LET G; (., .I) fi.j let x = e1 in e2 : E2 \\E1 .E2 (x : T, this : C); P fiC e : .result : Tr.Pr \n.T\\E E = .result : Tr.Pr override(m, C, .x : T .P -E) P-METH Tr m(Tx): P -E = e ok in C ... M ok in \nCM overrides all methods with thisfr permissions in CI CL ok \u00b7; \u00b7f_ i e : E \\E P-CLASS P-PROG class \nC extends CI { FRI NM } ok (CL, e) : E Figure 15. Permission checking for expressions (part 1) and declarations \nclass C extends CI {...}. CL class C {... M ...}. CL Tr m(Tx): P -.result : Tr.P I = e . M C extendS \nCI mtype(m, C)= .x : T .P -.result : Tr.P I C extendS CI mtype(m, CI)= .x : T .MSI implies (x : T, this \n: C); \u00b7f MS -MSI class C... {F ...}. CL override(m, C, .x : T .MS) localFieldS(C)= F class C extends \nCI {f : T in nS initially (.fI : T I ,f : T .P I . P, A) ... }init(CI)=(.fI : T I.P I,AI) \u00b7;(P, full(super, \nalive, {alive . 1},AI)) f invC (A) .T init(Object)=(1, alive) init(C)= (.fI : T I ,f : T .P I . P, A) \n class C {... n = P ...}. CL P =nl=nll<n predC (nII) invC (A)= P . nI II predC (n)= P predC (n,n)= P \ninvC (n, A)= P . predC (n,n) . predC (n) invC (Ai)= Pi . ni predC (ni,n)= Pi I n1 . n2 \u00ab n (i =1, 2) \ninvC (n)= 1 . n invC (A1 . A2)= P1 . P1 I . P2 . P2 I . n invC (Ai)= Pi . ni predC (ni,n)= P I n1 . n2 \n\u00ab n (i . 1, 2) i invC (A1 . A2)=(P1 . P I) . (P2 . predC (n2,n)) . n 1 only pure permissions in P exists \nshare or full permission in P efectSAllowed(P )=0 efectSAllowed(P )=1 Figure 16. Protocol veri.cation \nhelper judgments (falsehood) in checking the then (else) branch. This ap-.elds affected by the .rst expression. \nThis makes sure proach lets branches make use of the tested condition. that outdated .eld permissions \ndo not survive assign\u00adments or packing. Moreover, temporary state information P-LET checks a let binding. \nThe linear context used is dropped if the .rst subexpression has side effects. in checking the second \nsubexpression must not mention A program consists of a list of classes and a main ex\u00adpression (P-PROG, \n.gure 15). As usual, the class table CL is globally available. The main expression is checked with initially \nempty contexts. The judgment CL ok (P-CLASS) checks a class declaration. It checks .elds, states, and \nin\u00advariants for syntactic correctness (omitted here) and veri.es consistency between method speci.cations \nand implementa\u00adtions using the judgment M ok in C. P-METH assumes the speci.ed pre-condition of a method \n(i.e. the left-hand side of the linear implication) and veri.es that the method s body expression produces \nthe declared post-condition (i.e. the right-hand side of the implication). Conjunction with T drops excess \npermissions, e.g., to dead objects. The over\u00adride judgment concisely enforces behavioral subtyping (see \nsection 4.6). A method itself is not a linear resource since all resources it uses (including the receiver) \nare passed in upon invocation.  5.2 Packing and Unpacking We use a re.ned notion of unpacking [12] to \ngain access to .elds: we unpack and pack a speci.c permission. The access we gain re.ects the permission \nwe unpacked. Full and shared permissions give modifying access, while a pure permission gives read-only \naccess to underlying .elds. To avoid inconsistencies, objects are always fully packed when methods are \ncalled. To simplify the situation, only one permission can be unpacked at the same time. Intuitively, \nwe focus [13] on that permission. This lets us unpack Share like full permissions, gaining full rather \nthan shared access to underlying .elds (if available). The syntax for packing and unpacking is as follows. \nexpressions e ::= ... | unpack(n, k, A) in e | pack to A in e Packing and unpacking always affects the \nreceiver of the currently executed method. The unpack parameters express the programmer s expectations \nabout the permission being unpacked. For simplicity, an explicit subtree fraction k is part of unpack \nexpressions. It could be inferred from a programmer-provided permission kind, e.g. Share. Typechecking. \nIn order for pack to work properly we have to remember the permission we unpacked. Therefore we introduce \nunpacked as an additional linear predicate. permissions p ::= ... | unpacked(n, g, k, A) The checking \nrules for packing and unpacking are given in .gure 18. Notice that packing and unpacking always af\u00adfects \npermissions to thisfr . (We ignore substitution of this with an object location at runtime here.) P-UNPACK \n.rst derives the permission to be unpacked. The judgment inv determines a predicate for the receiver \ns .elds based on the permission being unpacked. It is used when checking the body expression. An unpacked \npredicate is added into the linear context. We can prevent multiple permissions from being unpacked at \nthe same time using a straightforward data.ow analysis (omitted here). invC (n, g, k, A) = invC (n, A) \n. purify(aboveC (n)) invC (n, g, 0, A) = purify (invC (n, A) . aboveC (n)) where aboveC (n) = nl:n<nl= \n predC (nI) Figure 17. Invariant construction (purify in .gure 19) P-PACK does the opposite of P-UNPACK. \nIt derives the predicate necessary for packing the unpacked permission and then assumes that permission \nin checking the body ex\u00adpression. The new state assumption A can differ from be\u00adfore only if a modifying \npermission was unpacked. Finally, the rule ensures that permissions to .elds do not survive packing. \nInvariant transformation. The judgment invC (n, g, k, A) determines what permissions to .elds are implied \nby a per\u00admission acceSS(thisfr , n, g, k, A) for a frame of class C. It is de.ned in .gure 17 and uses \na purify function (.gure 19) to convert arbitrary into pure permissions. Unpacking a full or shared permission \nwith root node n yields puri.ed permissions for nodes above n and in\u00adcludes invariants following from \nstate assumptions as is. Conversely, unpacking a pure permission yields completely puri.ed permissions. \n 5.3 Calling Methods Checking a method call involves proving that the method s pre-condition is satis.ed. \nThe call can then be typed with the method s post-condition. Unfortunately, calling a method can result \ninto reentrant callbacks. In order to ensure that objects are consistent when called we require them \nto be fully packed before method calls. This re.ects that aliased objects always have to be prepared \nfor reentrant callbacks. This rule is not a limitation because we can always pack to some intermediate \nstate although it may be inconvenient in practice. Notice that such intermediate packing obviates the \nneed for adoption while allowing focus [13]: the interme\u00addiate state represents the situation where an \nadopted object was taken out of the adopting object. Inferring intermediate states as well as identifying \nwhere reentrant calls are impos\u00adsible (intermediate packing avoidance) are important areas for future \nresearch. Virtual calls. Virtual calls are dynamically dispatched (rule P-CALL). In virtual calls, frame \nand object permis\u00adsions are identical because object permissions simply refer to the object s virtual \nframe. This is achieved by substituting the given receiver for both this and thisfr . Super calls. Super \ncalls are statically dispatched (rule P-SUPER). Recall that super is used to identify permissions to \nthe super-frame. We substitute super only for thisfr . We omit a substitution of this for the receiver \n(this again) for clarity. G; . fC acceSS(thisfr , n, g, k, A) receiver packed k =0 implies i = 0 G;(.I \n, invC (n, g, k, A), unpacked(n, g, k, A)) fCi e : E \\E P-UNPACK G; (., .I) fi unpack(n, k, A) in e \n: E \\E C G; . fC invC (n, g, k, A) . unpacked(n, g, k, AI) k =0 implies A = AI G; (.I , acceSS(thisfr \n, n, g, k, A)) fi localFieldS(C)= f : T in n C e : E \\E Fields do not occur in .I P-PACK G; (., .I) \nfi pack n to A in e : E \\ f C G f t0 : C0 G f t : T G; . f [t0/this][t0/thisfr ][t/x]P mtype(m, C0)= \n.x : T .P -Ei = efectSAllowed(P ) receiver packed P-CALL G; . fi t0.m(t):[t0/this][t0/thisfr ][t/x]E \nG f t : T G; . f [super/thisfr ][t/x]PC extendS CI mtype(m, CI)= .x : T .P -Ei = efectSAllowed(P ) receiver \npacked P-SUPER G; . fi C super.m(t):[super/thisfr ][t/x]E G; . f t : .x : Ti.P G; .I fC [fi/xI]P I . \np localFieldS(C)= f : T in nni = np = unpacked(n, g, k, A),k =0 P-ASSIGN G; (., .I) f1 assign fi := \nt : .xI : Ti.P I . [fi/x]P . p \\ fi C Figure 18. Permission checking for expressions (part 2) p = acceSS(r, \nn, g, k, A) purify(P1)= P I purify(P2)= P I op . {., &#38;, .} 12 purify(p)= pure(r, n, g, A) purify(P1 \nop P2)= P1 I op P I 2 unit .{1, T, 0} purify(P )= P I purify(P )= P I purify(unit)= unit purify(.z : \nH.P )= .z : H.P I purify(.z : H.P )= .z : H.P I Figure 19. Permission puri.cation 5.4 Field Assignments \nAssignments to .elds change the state of the receiver s cur\u00adrent frame. We point out that assignments \nto a .eld do not change states of objects referenced by the .eld. Therefore reasoning about assignments \nmostly has to be concerned with preserving invariants of the receiver. The unpacked predicates introduced \nin section 5.2 help us with this task. Our intuition is that assignment to a .eld requires unpack\u00ading \nthe surrounding object to the point where all states that refer to the assigned .eld in their invariants \nare revealed. No\u00adtice that the object does not have to be unpacked completely in this scheme. For simplicity, \neach .eld is annotated with the subtree that can depend on it (.gure 12). Thus we inter\u00adpret subtrees \nas data groups [27]. The rule P-ASSIGN (.gure 18) assigns a given object t to I a .eld fi and returns \nthe old .eld value as an existential x. This preserves information about that value. The rule veri.es \nthat the new object is of the correct type and that a suitable full or Share permission is currently \nunpacked. By recording an effect on fi we ensure that information about the old .eld value cannot .ow \naround the assignment (which would be unsound).  5.5 Permission Reasoning with Splitting and Joining \nOur permission checking rules rely on proving a predicate P given the current valid and linear resources, \nwritten G; . f P . We use standard rules for the decidable multiplicative\u00adadditive fragment of linear \nlogic (MALL) with quanti.ers that only range over fractions [28]. Following Boyland [7] we introduce \na notion of substitution into the logic that al\u00adlows substituting a set of linear resources with an equivalent \none. G; . f P I P I = P SUBST G; . f P The judgment P = P I de.nes legal substitutions. We use substitutions \nfor splitting and joining permissions (.g\u00adure 20). The symbol -= indicates that transformations are allowed \nin both directions. SYM and ASYM generalize the rules from section 2. Most other rules are used to split \nper\u00admissions for larger subtrees into smaller ones and vice versa. A detailed explanation of these rules \ncan be found in the companion report [5]. Our splitting and joining rules maintain a consistent set of \npermissions for each object so that no permission can ever violate an assumption another permission makes. \nFractions A = AI = AII or (A = AI and AII = n) or (A = AII and AI = n) SYM acceSS(r, n, g, k, A) -=acceSS(r, \nn, g/2, k/2,AI) . acceSS(r, n, g/2, k/2,AII) A = AI = AII or (A = AI and AII = n) or (A = AII and AI \n= n) acceSS(r, n, g, k, A) -=acceSS(r, n, g/2, k, AI) . pure(r, n, g/2,AII) ASYM n1 # n2 A1 -n1 = nA2 \n-n2 = n pi = full(r, ni, {g, nodeS(ni,n) . 1}/2,Ai) F-SPLIT-. full(r, n, g, A1 . A2) =p1 . p2 n1 # n2 \nA1 -n1 = nA2 -n2 = n pi = full(r, ni, {g, n . 1, nodeS(ni,n) . 1}/2,Ai) F-JOIN-. p1 . p2 =full(r, n, \n{g, n . 1},A1 . A2) A1 # A2 full(r, n, g, A1 . A2) -=full(r, n, g, A1) . full(r, n, g, A2) F-. A -nI \n= n IIF-DOWN full(r, n, g, A) =full(r,n, {g, nodeS(n,n) . 1},A) A -nI = n IIF-UP full(r,n, {g, n . 1, \nnodeS(n,n) . 1},A) =full(r, n, {g, n . 1},A) nI = n P-UP I pure(r, n, {g, nodeS(n,n) . k},A) =pure(r, \nnI, g, A) FORGET acceSS(r, n, g, k, A) =acceSS(r, n, g, k, n) Figure 20. Splitting and joining of access \npermissions of all permissions to an object sum up to (at most) 1 for every node in the object s state \nspace.  5.6 Example To illustrate how veri.cation proceeds, .gure 21 shows the fill method from BufferedlnputStream \n(.gure 11) written in our core language. As can be seen we need an intermediate state readS and a marker \n.eld reading that indicate an ongoing call to the underlying stream. We also need an additional state \nre.nement to specify an internal method replacing the while loop in the original implemen\u00adtation. (We \nassume that thisfr permissions can be used for calls to private methods.) Maybe surprisingly, we have \nto reassign .eld values af\u00adter super.read() returns. The reason is that when calling super we lose temporary \nstate information for this. Assign\u00adment re-establishes this information and lets us pack prop\u00aderly before \ncalling doFill recursively or terminating in the cases of a full buffer or a depleted underlying stream. \nIt turns out that these re-assignments are not just an in\u00adconvenience caused by our method but point \nto a real prob\u00adlem in the Java standard library implementation. We could implement a malicious underlying \nstream that calls back into the surrounding BufferedlnputStream object. This call changes a .eld, which \ncauses the buffer s invariant on count to permanently break, later on resulting in an undocumented array \nbounds exception when trying to read behind the end of the buffer array. Because fill operates on a \nShare permission our veri\u00ad.cation approach forces taking into account possible .eld changes through reentrant \ncalls with other Share permis\u00adsions. (This is precisely what our malicious stream does.) We could avoid \n.eld re-assignments by having read require a full permission, thereby documenting that reentrant (mod\u00adifying) \ncalls are not permitted for this method.  6. Related Work In previous work we proposed more expressive \ntypestate speci.cations [4] that can be veri.ed with the approach pre\u00adsented in this paper. We also recently \nproposed full and pure permissions and applied our approach to specifying full Java iterators [3]. Veri.cation \nof protocol compliance has been studied from many different angles including type systems, abstract interpretation, \nmodel checking, and veri.cation of general program behavior. Aliasing is a challenge for all of these \napproaches. The system that is closest to our work is Fugue [12], the .rst modular typestate veri.cation \nsystem for object\u00adoriented software. Methods are speci.ed with a determinis\u00adtic state transition of the \nreceiver and pre-conditions on argu\u00adments. Fugue s type system tracks objects as not aliased or maybe \naliased . Leveraging research on alias types [33] (see below), objects typically remain not aliased as \nlong as they are only referenced on the stack. Only not aliased objects can change state; once an object \nbecomes maybe porary state assumptions, full, immutable, and pure permis\u00adclass BufferedInputStrear extends \nFilterInputStrear { sions, or permissions for object parts in Fugue. states ready, reads refine open; \n... states partial, corplete refine filled; reads := reading; ready := reading = false; ... private boolean \nreading; ... public int read() : .k : Fract.... = unpack(open,k) in let r = reading in if(r == false, \n... fill() ... ) private bool fill() : .k : Fract. share(thisf\" , open) in depleted . eof \u00adshare(thisf\" \n, open) in available . eof = unpack(open, k, depleted . eof) in assign count = 0 in assign pos = 0 in \nassign reading = true in pack to reads in let b = super.read() in unpack(open, k, open) in let r = reading \nin assign reading = false in assign count = 0 in assign pos = 0 in if(r, if(b = -1, pack to eof in false, \npack to depleted in doFill(b)), pack to eof in false) private bool doFill(int b) : .k : Fract. share(thisf\" \n, open) in depleted . partial \u00adshare(thisf\" , open) in partial . complete = unpack(open, k, depleted \n. partial) in let c = count in let buffer = buf in assign buffer[c] = b in assign count = c + 1 in let \nl = buffer.length in if(c + 1 >= l, pack to complete in true, assign reading = true in pack to reads \nin let b = super.read() in unpack(open,k) in let r = reading in assign reading = false in assign count \n= c + 1 in assign pos = 0 in pack to partial in if(r == false .. b == -1, true, doFill(b)) Figure 21. \nFragment of BufferedlnputStream from .g\u00adure 11 in core language aliased its state is permanently .xed \nalthough .elds can be assigned to if the object s abstract typestate is preserved. Our work is greatly \ninspired by Fugue s abilities. Our approach supports more expressive method speci.cations based on linear \nlogic [18]. Our veri.cation approach is based on access permissions that permit state changes even in \nthe presence of aliases. We extend several ideas from Fugue to work with access permissions including \nstate invariants, packing, and frames. Fugue s speci.cations are expressible with our system [4]. Fugue \ns not aliased objects can be simulated with unique permissions for alive and maybe aliased objects correspond \nto Share permissions with state guarantees. There is no equivalent for state dimensions, tem- Veri.cation \nof protocol compliance has also been de\u00adscribed as resource usage analysis [23]. Protocol speci.ca\u00adtions \nhave been based on very different concepts including typestates [34, 11, 25], type quali.ers [16], size \nproperties [9], direct constraints on ordering [23, 35], and type re.ne\u00adments [30, 10]. None of the above \nsystems can verify im\u00adplementations of object-oriented protocols like our approach and only two [35, \n10] target object-oriented languages. Ef\u00adfective type re.nements [30] employ linear logic reasoning but \ncannot reason about protocol implementations and do not support aliasing abstractions. Hob [25] veri.es \ndata struc\u00adture implementations for a procedural language with static module instantiation based on typestate-like \nconstraints us\u00ading shape analyses. In Hob, data can have states, but modules themselves cannot. In contrast, \nwe can verify the implemen\u00adtation of stateful objects that are dynamically allocated and support aliasing \nwith permissions instead of shape analysis. Finally, concurrent work on Java(X) proposes activity an\u00adnotations \nthat are comparable to full, Share, and pure per\u00admissions for whole objects that can be split but not \njoined. Similar to effective type re.nements, state changes can be tracked for a pre-de.ned set of types, \nbut reasoning about the implementation of these types is not supported. To our knowledge, none of the \nabove systems supports temporary state information. Because programming with linear types [36] is very \nin\u00adconvenient, a variety of relaxing mechanisms were pro\u00adposed. Uniqueness, sharing, and immutability \n(sometimes called read-only) [7] have recently been put to use in re\u00adsource usage analysis [23, 9]. Alias \ntypes [33] allow multiple variables to refer to the same object but require a linear token for object \naccesses that can be borrowed [7] during function calls. Focusing can be used for temporary state changes \nof shared objects [13, 16, 2]. Adoption prevents sharing from leaking through entire object graphs (as \nin Fugue [12]) and allows temporary sharing until a linear adopter is deallocated [13]. All these techniques \nneed to be aware of all references to an object in order to change its state. Access permissions allow \nstate changes even if objects are aliased from unknown places. Moreover, access permis\u00adsions give .ne-grained \naccess to individual data groups [27]. States and fractions [6] let us capture alias types, borrow\u00ading, \nadoption, and focus with a single mechanism. Sharing of individual data groups has been proposed before \n[7], but it has not been exploited for reasoning about object behav\u00adior. In Boyland s work [6], a fractional \npermission means immutability (instead of sharing) in order to ensure non\u00adinterference of permissions. \nWe use permissions to keep state assumptions consistent but track, split, and join per\u00admissions in the \nsame way as Boyland. Global approaches are very .exible in handling alias\u00ading. Approaches based on abstract \ninterpretation (e.g. [1, 19, 14]) typically verify client conformance while the pro\u00adtocol implementation \nis assumed correct. Sound approaches rely on a global aliasing analysis [1, 14]. Likewise, most model \ncheckers operate globally (e.g. [21]) or use assume\u00adguarantee reasoning between coarse-grained static \ncompo\u00adnents [17, 22]. The Magic tool checks individual C func\u00adtions but has to inline user-provided state \nmachine abstrac\u00adtions for library code in order to accommodate aliasing [8]. The above analyses typically \nrun on the complete code base once a system is fully implemented and are very expensive. Our approach \nsupports developers by checking the code at hand like a typechecker. Thus the bene.ts of our approach \ndiffer signi.cantly from global analyses. Recently, there has been progress in inferring typestate protocols \nin the presence of aliasing [31], which we believe could be fruitfully combined with our work to reduce \ninitial annotation burden. Finally, general approaches to specifying program behav\u00adior [26, 15, 2] can \nbe used to reason about protocols. The JML [26] is very rich and complex in its speci.cation fea\u00adtures; \nit is more capable than our system to express object behavior (not just protocols), but also potentially \nmore dif\u00ad.cult to use due to its complexity. Verifying JML speci.ca\u00adtions is undecidable in the general \ncase. Tools like ESC/Java [15] can partially check JML speci.cations but are unsound because they do \nnot have a sound methodology for handling aliasing. Spec# is comparable in its complexity to the JML \nand imposes similar overhead. The Boogie methodology al\u00adlows sound veri.cation of Spec# speci.cations \nbut requires programs to follow an ownership discipline [2]. Our system is much simpler than these approaches, \nfo\u00adcusing as it does on protocols, and it is designed to be de\u00adcidable. Our treatment of aliasing makes \nour system sound, where ESC/Java is not. While the treatment of aliasing in our system does involve complexity, \nit gives the program\u00admer more .exibility than Boogie s while remaining modular and sound. Because it \nis designed for protocol veri.cation in particular, our system will generally impose smaller speci.\u00adcation \noverhead than the JML or Spec#.  7. Conclusions This paper proposes a sound modular protocol checking \nap\u00adproach, based on typestates, that allows a great deal of .ex\u00adibility in aliasing. A novel abstraction, \naccess permissions, combines typestate and object aliasing information. Devel\u00adopers express their protocol \ndesign intent using access per\u00admissions. Our checking approach then tracks permissions through method \nimplementations. For each object reference the checker keeps track of the degree of possible aliasing \nand is appropriately conservative in reasoning about that refer\u00adence. A way of breaking an invariant \nin a frequently used Java standard library class was exposed in this way. The checking approach handles \ninheritance in a novel way, giv\u00ading subclasses more .exibility in method overriding. Case studies on \nJava iterators and streams provide evidence that access permissions can model realistic protocols, and \npro\u00adtocol checking based on access permissions can be used to reason precisely about protocols arising \nin practice. In future work we hope to further re.ne and evaluate our approach. We plan to develop a \ndeterministic algorithm for reasoning about permissions. We hope to leverage our experiences in using \nour approach to increase its practicality. Based on the case studies presented in this paper we made \nthe following observations:  In this paper we chose to make the linear logic formal\u00adism underlying our \napproach explicit in example proto\u00adcol speci.cations. However, our case studies suggest that practical \nprotocols follow certain patterns. For example, method speci.cations often consist of simple conjunc\u00adtions \nthat can be expressed by annotating each method argument separately. With syntactic sugar for such pat\u00adterns \nwe believe that programmers will only rarely have to use linear logic operators explicitly.  Speci.cation \neffort lies primarily with protocol imple\u00admentation developers, which better amortizes over time. Conversely, \niterator, stream, and other libraries clients have (we believe) minimal work to do unless they store \nobjects in .elds. (Fugue s experience suggests that loop invariants for typestate checking can often \nbe inferred [12].)  Only a fraction of our system s capabilities are needed for any given example (although \nthey all are necessary in different situations). Developers do have to understand the general idea of \naccess permissions.  We believe that these observations indicate that the ap\u00adproach can be practical, \nespecially with the help of syntax that captures common cases concisely. A systematic eval\u00aduation of \nthis claim is an important part of planned future work.  Acknowledgments We thank John Boyland, Frank \nPfenning, the Plaid group, Sebastian Bo\u00dfung, and Jason Reed for fruitful discussions on this topic. We \nalso thank the anonymous reviewers for their helpful feedback. This work was supported in part by NASA \ncooperative agreement NNA05CS30A, NSF grant CCF-0546550, and the Army Research Of.ce grant num\u00adber DAAD19-02-1-0389 \nentitled Perpetually Available and Secure Information Systems . References [1] T. Ball and S. K. Rajamani. \nAutomatically validating temporal safety properties of interfaces. In Proc. of the Eighth SPIN Workshop, \npages 101 122, May 2001. [2] M. Barnett, R. DeLine, M. F\u00e4hndrich, K. R. M. Leino, and W. Schulte. Veri.cation \nof object-oriented programs with invariants. Journal of Object Technology, 3(6):27 56, June 2004. [3] \nK. Bierhoff. Iterator speci.cation with typestates. In 5th Int. Workshop on Speci.cation and Veri.cation \nof Component-Based Systems, pages 79 82. ACM Press, Nov. 2006. [4] K. Bierhoff and J. Aldrich. Lightweight \nobject speci.cation with typestates. In Joint European Software Engineering Conference and ACM Symposium \non the Foundations of Software Engineering, pages 217 226. ACM Press, Sept. 2005. [5] K. Bierhoff and \nJ. Aldrich. Modular typestate veri\u00ad.cation of aliased objects. Technical Report CMU\u00adISRI-07-105, Carnegie \nMellon University, Mar. 2007. http://reports-archive.adm.cs.cmu.edu/anon/isri2007/CMU\u00adISRI-07-105.pdf. \n[6] J. Boyland. Checking interference with fractional permis\u00adsions. In Int. Symposium on Static Analysis, \npages 55 72. Springer, 2003. [7] J. T. Boyland and W. Retert. Connecting effects and uniqueness with \nadoption. In ACM Symposium on Principles of Programming Languages, pages 283 295, Jan. 2005. [8] S. Chaki, \nE. Clarke, A. Groce, S. Jha, and H. Veith. Modular veri.cation of software components in C. In Int. Conference \non Software Engineering, pages 385 395, May 2003. [9] W.-N. Chin, S.-C. Khoo, S. Qin, C. Popeea, and \nH. H. Nguyen. Verifying safety policies with size properties and alias controls. In Int. Conference on \nSoftware Engineering, pages 186 195, May 2005. [10] M. Degen, P. Thiemann, and S. Wehr. Tracking linear \nand af.ne resources with Java(X). In European Conference on Object-Oriented Programming. Springer, Aug. \n2007. [11] R. DeLine and M. F\u00e4hndrich. Enforcing high-level protocols in low-level software. In ACM Conference \non Programming Language Design and Implementation, pages 59 69, 2001. [12] R. DeLine and M. F\u00e4hndrich. \nTypestates for objects. In European Conference on Object-Oriented Programming, pages 465 490. Springer, \n2004. [13] M. F\u00e4hndrich and R. DeLine. Adoption and focus: Practical linear types for imperative programming. \nIn ACM Conference on Programming Language Design and Implementation, pages 13 24, June 2002. [14] S. \nFink, E. Yahav, N. Dor, G. Ramalingam, and E. Geay. Effective typestate veri.cation in the presence of \naliasing. In ACM Int. Symposium on Software Testing and Analysis, pages 133 144, July 2006. [15] C. Flanagan, \nK. R. M. Leino, M. Lillibridge, G. Nelson, J. Saxe, and R. Stata. Extended static checking for Java. \nIn ACM Conference on Programming Language Design and Implementation, pages 234 245, May 2002. [16] J. \nFoster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. In ACM Conference on Programming Language \nDesign and Implementation, pages 1 12, 2002. [17] D. Giannakopoulou, C. S. P.as.areanu, and J. M. Cobleigh. \nAssume-guarantee veri.cation of source code with design\u00adlevel assumptions. In Int. Conference on Software \nEngineer\u00ading, pages 211 220, May 2004. [18] J.-Y. Girard. Linear logic. Theoretical Computer Science, \n50:1 102, 1987. [19] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A system and language for building system-speci.c, \nstatic analyses. In ACM Conference on Programming Language Design and Implementation, pages 69 82, 2002. \n[20] D. Harel. Statecharts: A visual formalism for complex systems. Sci. Comput. Programming, 8:231 274, \n1987. [21] T. A. Henzinger, R. Jhala, R. Majumdar, and G. Sutre. Lazy abstraction. In ACM Symposium \non Principles of Programming Languages, pages 58 70, 2002. [22] G. Hughes and T. Bultan. Interface grammars \nfor modular software model checking. In ACM Int. Symposium on Software Testing and Analysis, pages 39 \n49. ACM Press, July 2007. [23] A. Igarashi and N. Kobayashi. Resource usage analysis. In ACM Symposium \non Principles of Programming Languages, pages 331 342, Jan. 2002. [24] A. Igarashi, B. Pierce, and P. \nWadler. Featherweight Java: A minimal core calculus for Java and GJ. In ACM Conference on Object-Oriented \nProgramming, Systems, Languages &#38; Applications, pages 132 146, 1999. [25] V. Kuncak, P. Lam, K. Zee, \nand M. Rinard. Modular pluggable analyses for data structure consistency. IEEE Transactions on Software \nEngineering, 32(12), Dec. 2006. [26] G. T. Leavens, A. L. Baker, and C. Ruby. JML: A notation for detailed \ndesign. In H. Kilov, B. Rumpe, and I. Simmonds, editors, Behavioral Speci.cations of Businesses and Systems, \npages 175 188. Kluwer Academic Publishers, Boston, 1999. [27] K. R. M. Leino. Data groups: Specifying \nthe modi.cation of extended state. In ACM Conference on Object-Oriented Programming, Systems, Languages \n&#38; Applications, pages 144 153, Oct. 1998. [28] P. Lincoln and A. Scedrov. First-order linear logic \nwithout modalities is NEXPTIME-hard. Theoretical Computer Science, 135:139 154, 1994. [29] B. H. Liskov \nand J. M. Wing. A behavioral notion of subtyping. ACM Transactions on Programming Languages and Systems, \n16(6):1811 1841, Nov. 1994. [30] Y. Mandelbaum, D. Walker, and R. Harper. An effective theory of type \nre.nements. In ACM Int. Conference on Functional Programming, pages 213 225, 2003. [31] M. G. Nanda, \nC. Grothoff, and S. Chandra. Deriving object typestates in the presence of inter-object references. In \nACM Conference on Object-Oriented Programming, Systems, Languages &#38; Applications, pages 77 96, 2005. \n[32] G. Ramalingam, A. Warshavsky, J. Field, D. Goyal, and M. Sagiv. Deriving specialized program analyses \nfor certify\u00ading component-client conformance. In ACM Conference on Programming Language Design and Implementation, \npages 83 94, 2002. [33] F. Smith, D. Walker, and G. Morrisett. Alias types. In European Symposium on \nProgramming, pages 366 381. Springer, 2000. [34] R. E. Strom and S. Yemini. Typestate: A programming \nlanguage concept for enhancing software reliability. IEEE Transactions on Software Engineering, 12:157 \n171, 1986. [35] G. Tan, X. Ou, and D. Walker. Enforcing resource usage pro\u00adtocols via scoped methods. \nIn Int. Workshop on Foundations of Object-Oriented Languages, 2003. [36] P. Wadler. Linear types can \nchange the world! In Working Conference on Programming Concepts and Methods, pages 347 359. North Holland, \n1990. \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Objects often define usage protocols that clients must follow inorder for these objects to work properly. Aliasing makes itnotoriously difficult to check whether clients and implementations are compliant with such protocols. Accordingly, existing approaches either operate globally or severely restrict aliasing.</p> <p>We have developed a sound modular protocol checking approach, based on typestates, that allows a great deal of flexibility in aliasing while guaranteeing the absence of protocol violations at runtime. The main technical contribution is a novel abstraction, <i>access permissions</i>, that combines typestate and object aliasing information. In our methodology, developers express their protocol design intent through annotations based on access permissions. Our checking approach then tracks permissions through method implementations. For each object reference the checker keeps track of the degree of possible aliasing and is appropriately conservativein reasoning about that reference. This helps developers account for object manipulations that may occur through aliases. The checking approach handles inheritance in a novel way, giving subclasses more flexibility in method overriding. Case studies on Java iterators and streams provide evidence that access permissions can model realistic protocols, and protocol checking based on access permissions can be used to reason precisely about the protocols that arise in practice.</p>", "authors": [{"name": "Kevin Bierhoff", "author_profile_id": "81100267548", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "P741897", "email_address": "", "orcid_id": ""}, {"name": "Jonathan Aldrich", "author_profile_id": "81100454133", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39043496", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297050", "year": "2007", "article_id": "1297050", "conference": "OOPSLA", "title": "Modular typestate checking of aliased objects", "url": "http://dl.acm.org/citation.cfm?id=1297050"}