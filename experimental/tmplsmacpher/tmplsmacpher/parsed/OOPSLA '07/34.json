{"article_publication_date": "10-21-2007", "fulltext": "\n Living it up with a Live Programming Language Sean McDirmid \u00b4 Ecole PolytechniqueF\u00b4ed\u00b4eralede Lausanne \n(EPFL) 1015 Lausanne, Switzerland sean.mcdirmid@ep..ch Abstract Adynamic language promotes ease of use \nthrough .exible typing, a focus on high-level programming, and by stream\u00adlining the edit-compile-debug \ncycle. Live languages go be\u00adyond dynamic languages with more ease of use features.A live language supports \nlive programming that provides pro\u00adgrammers with responsive and continuous feedback about how their edits \naffect program execution. A live language is also based on high-level constructs such as declarative \nrules so that programmers can write less code.A live lan\u00adguage could also provide programmers with responsive \nse\u00admantic feedback to enable time-saving services such as code completion. This paper describes the design \nof a textual live language that is based on reactive data-.ow values known as signals and dynamic inheritance. \nOur language, Super-Glue, supports live programming with responsive semantic feedback, which we demonstrate \nwith a working prototype. Categories and Subject Descriptors D.2.6[Programming Environments]: Interactive \nEnvironments live program\u00adming; D.3.2[Programming Languages]: Data-.ow, Very High-level, and Object-oriented \nLanguages; D.3.3 [Lan\u00adguage Constructs andFeatures]: Inheritance dynamic. General Terms HumanFactors \nand Languages 1. Introduction Dynamic programming languages support rapid develop\u00adment by reducing verbosity \nin both source code and the de\u00advelopment process. Although labeled as dynamic because they often rely \non dynamic typing, dynamic languages are best characterized by their emphasis of .exibility, concise\u00adness, \nand ease of development over performance and gen\u00aderality. Dynamic typing promotes .exibility by enforcing \nfewer restrictions on type compatibility and conciseness by Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr \u00b4ebec, \nCanada. eal, Qu\u00b4Copyright c . 2007ACM 978-1-59593-786-5/07/0010...$5.00 eliminating verbose type annotations. \nDynamic languages also emphasize high-level programming models, often based on higher-order functions \nor objects, that reduce the amount ofcode neededtoexpressa program.Together,.exibletyp\u00ading and high-level \nprogramming models support component programming so that programmers can create feature-rich programs \nwith little code by reusing existing components. Finally,dynamic language environments streamline the \nedit\u00adcompile-debug cycle by either eliminating or hiding compi\u00adlation and by allowing code to be changed \nwhile a program is running.Forexample, manyLisp [25], Smalltalk [12], and Erlang [1] environments support \nhot swapping where a pro\u00adgram s code can be updated without restarting. Can we design languages that \nare easier to use than ex\u00adisting dynamic languages? For inspiration, look at visual languages such asFabrik \n[15], LabVIEW [21], and spread\u00adsheet languages such as Excel andForms/3 [3], which are designed to be \nused by casual programmers, novices, and even end users. Visual languages are based on simple, of\u00adten \ndeclarative, programming models that heavily empha\u00adsize component reuse. For example, Apple s Quartz \nCom\u00adposer [17] supports the assembly of animation components through reactive data-.ow connections that \nencapsulate change-propagation details. The simple programming mod\u00adels of visual languages also enable \nlive programming, which provides programmers with immediate and continuous feed\u00adback about how their \nedits affect program execution. For example, editing a connection graph in Quartz Composer immediately \nchanges the composed animation. Compared to live programming, the hot swapping supported by dynamic languages \nis mushy: the effect of edited code on program behavior is not apparent until the code is re-executed. \nFor example, editing the Smalltalk statement w fill: red to w fill: blue will not immediately re-color \nblue all wid\u00adgets that have been bound to w. In spite of their bene.ts, visual languages do not replace \ntextual dynamic languages.For one thing, text can be writ\u00adten more quickly [23]. More signi.cantly, visual \nlanguages must deal with a scaling-up problem [4]: the ability tobuild large programs is hindered by \nconcrete visual notation that does not easily support abstraction. Modern visual languages solve the \nscaling up problem in a variety of ways; e.g., Forms/3 [3] allow for name-based cell referencing and \ndata abstraction through generic forms. Still, text s natural sup\u00adport for naming makes it more suitable \nfor manyabstraction\u00adheavy programming tasks. Also, the simple programming models that enable liveprogramming \nin visual languages can alsobe appliedtotextual languages.A live language is then a textual or visual \nlanguage that supports live programming through a simple programming model. Supportfortextual naminginalive \nlanguageis problem\u00adatic: how are programmers provided with responsive seman\u00adtic feedback about what names \narevalid? Semantic feedback speedsupthe programming processby detecting typos early on and enabling services \nsuch as code completion, which al\u00adlows programmers to browse available resources. Program\u00admers are often \ndeprived of responsive semantic feedback in dynamically-typed languages because names are dif.cult to \nresolve before run-time. Static typing that typically enables semantic feedback is too verbose and in.exible \nto be used in a live language. Implicit typing would work better in a live language where inference provides \nresponsive semantic feedback without type annotations. This paper explores the design of a textual live \nlanguage that reuses ideas from dynamic and visual languages along with a few new ideas. The language, \nSuperGlue, is based on a simple reactive data-.ow programming model that is suitedtobuilding interactive \nprograms outofexisting com\u00adponents. Components in SuperGlue are connected together through signals into \na data-.ow graph. Being reactive, the values that .ow across signal connections can change over time, \nwhich eases the expression of interactive programs. For scaling purposes, signals extend classes through \ndy\u00adnamic inheritance, where what classes a signal extends can change at run time. Signals and dynamic \ninheritance seam\u00adlessly support live programming by masquerading edits as programmatic changes in the \nprogram s mutable execution state. Unlike Self [29] and like Cecil [6], dynamic inheri\u00adtance in SuperGlue \nis based on declarative predicates [7], which is very compatible with a reactive data-.ow model. Because \nclass extensions are declarative, type inference can provide programmers with responsive semantic feedback. \nDependent typing improves type inference so that type an\u00adnotations are unnecessary. Previous work [20] \nintroduces SuperGlue s support for object-oriented signals, and shows how this support eases the constructionof \ninteractive programs. This paperexpands on thisworkby augmenting SuperGlue with dynamic inher\u00aditance, \nwhich signi.cantly simpli.es the language, andlive programming. Figure1showshowlive programming occurs \nin a working Eclipse-based prototype. In this paper, we use a PacMan-like game as a running example. \nA program is edited freely as text in the upper half of the programming environment while the execution \nis shown in the lower half. As soonasakeypress leadstovalid code,theeffectofthe edit is incorporated \ninto the executing program. So that live programming remains responsive, SuperGlue supports error recovery \nwhere syntax, semantic, and execution errors are notedinthe background whileexecution continues.Thelive \nprogramming experience that is shown as a frame-expanded movie1inFigure1is narratedas follows: (a) The \nprogrammer types port pacMan . Figure to de\u00ad.nea pacMan signal thatextends thegame s Figure class so \npacMan is drawn on the game s canvas. Because a shape for pacMan has not been speci.ed, it is drawn by \ndefault as a rectangle. (b) The programmer types the extension pacMan . Pie, which causes pacMan to \nextend the Pie class and be drawn as a circle. The shape of pacMan is updated on screen as soon as the \nprogrammer types the e in Pie. (c) The programmer types the connection pacMan.fill = yellow, causing \nthis circle to be immediately colored yellow. Through type inference, code completion can complete typing \nfor .fill in pacMan. (d) The programmer types pacMan.extent = 330. As the programmer types each character \nin 330, pacMan s ap\u00adpears respectively as a 357, 327, and .nally a 30 de\u00adgree slice. The programmer than \n.nishes this line with + (time % 30), which causespacMan s mouth to close continuously in a 30 degree \nmotion.  The rest of this paper is organized as follows. Section2 lists live language design problems \nand how these problems are solvedin SuperGlue. Section3describeshowSuperGlue supportslive programming. \nSection4describes preliminary experienceon SuperGlue s useindevelopinga simplegame. Section5presents \nrelatedwork and Section6concludes. 2. Language Design SuperGlue is based on the data-.ow programming \nmodel that was originally introduced by Karp and Miller [16] to deal with concurrency through a graph \nprogram represen\u00adtation. Even without considering concurrency, the data-.ow model is appealing to live \nlanguages because all computa\u00adtional dependencies are encoded explicitly. The data-.ow modelbyitselfdoesnot \nscale: non-trivial programsinvolvea large or unbounded number of data-.owconnections that are tedious \nor impossible toexpress individually.For this rea\u00adson, SuperGlue augments its data-.ow model with object\u00adoriented \nconstructs. As a brief overview, SuperGlue consists of the following constructs: Signals, which are data-.ow \nvalues that facilitate inter\u00adcomponent communication. Signals are objects that ex\u00adtend classes, are connected \nto other signals, and contain signals de.ned in their extended classes. Signals are de\u00ad.ned as class \nmembers using the port keyword. 1Movies are frame expanded in this document. A preferred electronic document \nwith inlined movies is available on the author s website.  (a) (b) (c) (d) Figure 1: An example of \nthe SuperGlue programming environment being used in a live programming session; the editor is in the \ntop half of each sub-.gure while the running program is shown in the lower half. Classes,which are \ntypes that encapsulate behavior. Classes are not values and they can only be extended by signals. Classes \nare de.ned at the top-level of a program or as members in other classes using the class keyword.  Connections, \nwhich relate signals to other signals so that their values are equivalent. Connections are rules that \nare similar to simple uni-directional constraints. Connections are expressed with the = operator.  Extensions, \nwhich cause signals to extend classes. Exten\u00adsions are rules that can target signals outsideoftheir de.\u00adnitions. \nExtensions are expressed with the .2 operator.  Conditions, which guard when connection and extension \nrules can be applied. Conditions query existing connec\u00adtion and extension relationships through the same \n= and  . operators that are used to create these relationships in rules. Conditions areexpressedin if \nclauses that surround guarded connection and extension rules. As an opening example, consider the following \nSuper-Glue code that de.nes the Ghost class, three ghost signals, and connects the .ll color of all ghost \nsignals: 1 class Ghost { port fill . Color; }2 port (blinky, clyde, bashful) . Ghost; 3 Ghost.fill = \nblue; The .rst line of this code de.nes a Ghost class with a mem\u00adber fill signal thatextends the Color \nclass. The second line 2The user types :, which is then rendered in the editor as .. de.nes three signals, \nblinky,clyde,andbashful,whichex\u00adtend the Ghost class. The third line is a rule that connects the fill \nsignal of all ghosts, including blinky, clyde, and bashful, to the color blue. When used in expressions, \nclass identi.ers are variable that quantify over all signals that ex\u00adtend the identi.ed class; e.g., \nGhost in Ghost.fill is a vari\u00adable that quanti.es over all signals that extend the Ghost class. Unlike \nimperative assignments, connection rules have declarative meaning that is unrelated to statement execution \norder; e.g., on line three, blue is continuously connected to rather than discretely assigned to the \nghost s .ll color. The nature of the values that .ow across data-.ow con\u00adnections determines what programs \ncan be concisely ex\u00adpressed in a data-.ow language. In SuperGlue as well as many existing textual and \nvisual data-.ow languages, such as Lucid [32] and Quartz Composer [17], data .ow is reac\u00adtive in that \ntime-varyingvalues .ow across connections. Re\u00adactive data-.ow languages hide change-propagation details \nfrom programmers by dealing with the details generically at connection end points. By hiding change-propagation \nde\u00adtails, continuously changing state is treated in the same sim\u00adpleway that immutable state is. Consider \nthe following code that causes pacMan s mouth to close continuously: 1 class Pie { port extent . Number; \n} 2 port pacMan . Pie; 3 pacMan.extent = 330 + (time % 30); The last line of this code connects pacMan \ns extent signal to an expression that continuously increases from 330 until 360 degrees, causing pacMan \ns mouth to shut continuously in a 30 degree motion. Such behavior occurs because the time signal is a \nperiodically incrementing number; e.g., it is con\u00adnected to 1042 and, after ten milliseconds, it is re-connected \nto 1043. At connection end-points, signals in SuperGlue are provided and consumed by components that \nexpress event handling details throughageneral-purpose language such as Java or Scala [22]. In our example, \nScala code updates the time signal when time advances and redraws pacMan when its extent signal changes. \nWe describe how this code in\u00adterfaces with SuperGlue in Section 2.3. Because SuperGlue code is completely \noblivious to what happens over signal connections, interactive programs, where continuous change is common,areexpressedmoreeasily.AswewillseeinSec\u00adtion \n3, such obliviousness also enables live programming. In our previous version of SuperGlue [20], class \nexten\u00adsions could only be expressed in signal and class de.ni\u00adtions. This restriction complicated SuperGlue \ns class system and prevented it from being very dynamic; i.e., signal types couldnotchangeat run-time.Asasimpli.cationandtosup\u00adport \nlive programming, class extensions are now rules in the sameway that connections are.Forexample, the \nstatement pacMan . Figure is an extension rule that can be writ\u00adten down wherever pacMan is visible not \njust where pacMan is de.ned. As rules, both connections and extensions can be guarded by conditions. \nConsider the following code that causes signalstoextendthe PositionByKeyboard class when theyalreadyextend \nboth the Position and Keyboard classes: 1 class Position; class Keyboard; 2 class PositionByKeyboard; \n3 if (Position . Keyboard) 4 Position . PositionByKeyboard; The condition on line three of this code \nensures that the Position identi.er is only bound to signals that extend both the Position and Keyboard \nclasses. Line fourisanextension that then causes these signals to extend the PositionByKey\u00adboard class. \nAs we will see in Section 2.2, such extensions are useful in adapting incompatible signals. Extension \nrules in SuperGlue target signals and not classes.As syntacticsugar,anextension canbe speci.edina class \nde.nition,buttheextensionisappliedtoallsignalsthat extendthe de.ned classandnotthe class itself.Nocyclicin\u00adheritance \noccurs in SuperGlue when the signals of two dif\u00adferent classes extend the other class instead, the classes \nare semanticallyequivalentin thata signal thatextends one also extends the other. Such mutual extension \nconstructions en\u00adable the re.nement of signals that have already been created. For example, the de.nition \nclass RichNumber . Number and theextension rule Number . RichNumber does not cre\u00adate a cycle; instead \nit causes all Number signals, including numeric literals, to be RichNumber signals and vice versa. Because \nconditions query signals whose values change over time, their truth values can also change over time. \nBe\u00adcause time-varying conditions can guardextension rules, Su\u00adperGlue supports dynamic inheritance where \nwhat classes a signal extends can vary over time. Dynamic inheritance en\u00adables the state-based classi.cation \nof signals without deeply nested if statements, and, as described in Section 3, sup\u00adports live programming \nwithout the need for special-case se\u00admantics. Unlike Self [29], where dynamic inheritance occurs through \nimperative slot assignment, dynamic inheritance in SuperGlue is predicated as in Cecil [6, 7]. Considerthe \nfol\u00adlowing code that causes pacMan to extend the Damaged class when it overlaps with a ghost: 1 class \nFigure { port (overlaps,hit) . Hit } 2 class Ghost . Figure; class Damaged . Figure; 3 port pacMan . \nFigure; 4 if (pacMan.overlaps . Ghost.Hit) 5 pacMan . Damaged; 6 Damaged.fill = red; For the duration \nthat pacMan overlaps with some .gure, pacMan s overlaps signal is bound to the hit signal of this .gure. \nThe condition on line four is then only true for dura\u00adtions where the .gure that pacMan overlaps with \nis a ghost. During these durations, pacMan extends the Damaged class, inheriting all the behavior of \nthis class and being subject to rules that target signalsof this class.Forexample, the con\u00adnection of \nred to a damaged .gure s fill color would apply to pacMan while it overlaps with a ghost. As soon as \npacMan no longer overlaps with a ghost, it unextends the Damaged class and the special damaged behavior \nno longer applies. 2.1 Implicit Typing Dynamic languages avoid static typing because of its ver\u00adbose \ntype annotations, limited .exibility, and inability to deal with change. However, static typing also \nprovides pro\u00adgrammers of responsive semantic feedback that is especially importantinalive programming \nenvironment:it allows pro\u00adgrammers to converge on correct edits more quickly through code completion, \nwhere programmers can browse the names of available entities, and validation, which immediately in\u00adforms \nprogrammers of typos. Static types can also convey programmer intent and resolve ambiguity. In SuperGlue, \nmultiple connections can connect the same signal.Toresolve ambiguity, connections that target more speci.c \nstatic types are considered before connections that target less speci.c static types if the guarding \nconditions of both connections are true. Such by-type prioritization is analogous method overriding in \nmost object-oriented languages. To provide semantic feedback without type annotations, types are computed \nin SuperGlue through type inference, whichisaformof implicit typing. Implicit typing is viable in SuperGlue \nbecause extensions are declarative rules that can be accurately inferred by an analysis that is both \n.ow and context-insensitive. The inferred type of a symbol is a set of classes that restricts the symbol \nfrom only being bound at run-time to signals that extend all of these classes. Sub\u00adtyping is then de.ned \nas a subset relationship: ta is a sub\u00adtype of tb if all classes in tb are classes in ta.Type inference \nbuildsupa symbol s inferred typeby analyzing surrounding extension conditions and known extension rules \nthat target classes already contained in the inferred type. 1 class Duplicator 2 3 { size . Number; class \nT 4 5 class get port ghosts . T { port index . Duplicator; . Number; } } 6 ghosts.T . (Ghost,Figure); \n7 ghosts.size = 10; 8 if (ghosts.get.index = 3) 9 ghosts.get.fill = red; Figure2: SuperGlue code that \ncreates ten ghosts, wherethe ghost at index three is colored red. Asanexampleofhowtype inference occurs, \nconsiderthe following code that overrides a position s x signal when the position extends the PositionCell \nclass: 1 class Position { port (x,y) . Number; } 2 class PositionCell 3 { port (xc, yc) . NumberCell; \n} 4 Position.x = 0; 5 if (Position . PositionCell) 6 Position.x = Position.xc.result; Overriding in \nSuperGlue is de.ned as follows: if the type of a is ta, the type of c is tc, and tc is a strict sub-type \nof ta, then the connection a = b overrides the connection c = d. On line four, the inferred type of Position \nincludes only the Position class because the type of a class identi\u00ad.er always contains itself. On line \nsix, Position s inferred type also contains the PositionCell class because of the surrounding extension-querying \ncondition on line .ve. As a result, the connection on line six, which targets the type (Position,PositionCell),overrides \nthe connection on line four,which targets the type (Position). Because Position s inferred type on line \nsix contains the PositionCell class, the member signal xc can be accessed through Position and is listed \nby code completion. SuperGlue supports a form of dependent typing where class types are pre.xed by their \ncontaining signals. When type inference computes a symbol s type, pre.xes are ap\u00adproximated as signal \nand class symbols. Consider the code in Figure 2 that creates ten ghosts. On line nine, the in\u00adferred \ntype of ghosts.get contains the following classes: ghosts.get by de.nition, Duplicator.get because the \nghosts pre.x extends Duplicator on line .ve, ghosts.T because of the extension on line four and by a \nbinding of Duplicator to ghosts on line .ve, Duplicator.T by line .ve again, and .nally, Ghost and Figure \nbytheextension on line six. On line nine, the fill signal can be accessed and connected because ghosts.get \nsignals extend Figure. 2.2 Dynamic Typing and Adaptation In SuperGlue, because both connections and \nextensions can be guardedbystate-dependent conditions, when theyare ap\u00adplied at run-time is not statically \nknown. As a result, Super-Glue depends on dynamic typing to verify two connection properties: .rst, that \nprimitive-extending signals are con\u00adnected to concrete values of the appropriate primitive class; and \nsecond, that all signals are connected unambiguously. The .rst property ensures that component implementations \ncorrectly communicate through primitive-extending signals; e.g., a providing component pushes through \na number that is consumed asa numberby one or more other components. The second property detects multiple \nactive connections to the same signal that do not having overriding relationships. In both cases, dynamic \ntyping ensures that components com\u00admunicate correct and unambiguous values at run-time. Independently-developed \nor differently-purposed compo\u00adnents will often not agree on the types of their non-primitive signals.For \nthis reason, SuperGlue permits connections be\u00adtween type-incompatible signals where additional rules \ncan de.ne compatibility. Consider the following code where pacMan s positionis connectedtoakeyboard: \n1 class Canvas 2 { class Figure { port position . Position; } 3 port keyboard . Keyboard; } 4 port game \n. Canvas, pacMan . game.Figure; 5 pacMan.position = game.keyboard; The signal types involved in the \nconnection on line .ve are incompatible: the type of pacMan.position contains only the Position class \nwhile the type of game.keyboard con\u00adtains only the Keyboard class. The programmer intends the position \nof pacMan tobe controlledby thekeyboard. Such intent can be realized with code that de.nes what it means \nfor a signal to extend the otherwise unrelated Position and Keyboard classes. At run-time, the above \nconnection causes pacMan s position signal to extend both the Position and Keyboard classes. These classes \ncan then be combined to de\u00adscribe the target of an extension rule: 1 if (Position . Keyboard) 2 Position \n. PositionByKeyboard; By this extension, a signal that extends both the Keyboard and Position classes \nalso extends the PositionByKeyboard class, which we refer to as an adapter mixin. Normal mix\u00adins enable \na form of linearized multiple inheritance where a mixin is explicitly applied to an object. An adapter \nmixin is implicitly applied to a signal that extends a combination of classes; e.g., a signal that extends \nPosition and Keyboard will implicitly extend PositionByKeyboard. With implicit application, adapter mixins \ncan adapt connections to auto\u00admatically resolve type incompatibility. The PositionByKey\u00adboard class resolves \nthe incompatibility between position andkeyboard as follows: 1 class PositionByKeyboard. (PositionCell,Keyboard) \n2 { goup = keyup ; godown = keydown ; 3 go left = key left; go right = key right; } The go * and key \n* signals are respectively de.ned in the PositionCell and Keyboard classes whose de.nitions are not shown. \nThe connections in PositionByKeyboard cause imperative position state that is maintained by Position-Cell \ntobe incremented accordingtokeyboard inputanda time signal that is not shown. This code is applied whenever \npositions are connectedtokeyboards.Forexample,if mul\u00adtiple .gure positions are connected to the keyboard, \nthese .gures will movein unisonbykeyboard input.  2.3 Implementation and Code Behind Our prototype implementation \nof SuperGlue conceptually builds and maintains a dependency graph that tracks how signal values are inter-dependent. \nSo that dependencies are updated reactively, our prototype is based on the UI pattern of damage and repair:when \na signal changes, its dependen\u00adcies are damaged and scheduledinawork-listfor repair through re-evaluation. \nDamage is then propagated through the dependency graph. Maintaining an exact dependency graph is unrealistic \nbecause signals can depend on each other in cyclic ways that are dif.cult to track. Instead, our pro\u00adtotype \nis conservative: a dependency is recorded when the evaluation of signal A depends on signal B,but is \nnever ex\u00adplicitly unrecorded when A no longer depends on B. De\u00adpendent signals are instead .ushed after \nbeing damaged if dependent signals still depend on the changing signal, then this dependency is re-recorded \nduring repair. Flushing en\u00adsures that signals are noti.ed only once of changes in signals that they no \nlonger depend on. SuperGlue code cannot directly express computations such as arithmetic or drawing on \na canvas. Instead, these computations are expressed as code behind3 connections and extensions that are \nwritten in Java (or Scala [22]). A code behind connection expresses the connection s result in Java code \naccording to the following Java Signal interface: interface Signal<T> { T eval(Observer o); }interface \nObserver { void notify(); } A signal provider implements the Signal interface s eval methodtoprovidea \nsignal s currentvalueand ensurethatan Observer is noti.ed when that value changes. Consider the following \nJava code that implements a clock s time signal: time = new Signal<Number> { Number eval(Observer o) \n{ p = period.eval(o).toLong(); timer.schedule(new TimerTask() { void run() { o.notify(); }}, p); return \nSystem.currentTimeMillis / p; }}; The time signal s eval method schedules a timer task to notify the \ncaller that the time has changed, which occurs in period milliseconds.Asignal consumer calls the Signal \ninterface s eval method to access a signal s value, and can provide an observer so that it is noti.ed \nof changes in the value.Forexample, the time signal calls the eval method on the clock s period signal \nto obtain the clock s period. The time signal s implementation passes its called observer directly into \nthe period signal. As a result, when a clock s period signal change, its time clients are noti.ed directly. \n3 Code behind is often used to describe imperative code that implements complicated behavior in an otherwise \ndeclaratively-speci.ed user interface. The SuperGlue runtime produces and consumes signals according \nto the Signal Java interfaces based on the the rules of a SuperGlue program. For example, the connec\u00adtion \nperiod = 100 causes the SuperGlue runtime to create a Java Signal object that returns 100 when its eval \nmethod is called. As we discuss in Section 3, edits to code will no\u00adtify observers of the signals derived \nfrom the edited code; e.g., when the 100 token is changed through editing, the Su\u00adperGlue runtime will \nnotify all observers that the period s eval method was called with. It is through the implementa\u00adtion \nand routing of signals via declarative rules that Super-Glue adds its value to the program; i.e., SuperGlue \nacts as a middle man between components that do the real work. Code behind extensions are evaluated by \nthe SuperGlue runtimewhenasignalextendsorunextendsaclass.TheJava interface for a class extension is as \nfollows: interface Extension { void enter(Signal s); void exit(Signal s); } The enter and exit methods \nof a class extension are called whena signal starts or stopsextendinga class, which occurs when the signal \nis created, destroyed, or when the guard of an extension changes. The enter and exit methods of a class \nextension are responsible for managing the signal s state with respect to the class. Consider the following \nJava code that implements the NumberCell class extension: NumberCell = new Extension() { static Map<Signal,State> \nsignals = ...; void enter(Signal s) { State state = new State(s); signals.put(s, state); state.notify(); \n} void exit (Signal s) { signals.remove(s); }} Number cell state is stored in a map and is keyed by the \nsignal s own identity. The state is implemented as follows: class State extends Observer { Double value; \nSignal signal; Set<Observer> clients; void notify() { if (signal.set enable.eval(this)) { value = signal.set \nto.eval(this); foreach (o : clients) o.notify(); clients.clear(); }}} A number cell State object is an \nobserver that queries the set enable and set to signals when called. If the set enable signal is true, \nthen the value of the number cell is set to the value of the set to signal while the number cell s observers \nare noti.ed and .ushed. The number cell State object is used as its own observer in queries to the set \nenable and set to signals, so it will be called when\u00adever the values of these signals change. The number \ncell get signal is implemented to access number cell state as follows: get = new Signal<Number>() { Number \neval(Observer o) { state = NumberCell.signals.get(container()); state.clients.add(o); return state.value; \n}} When evaluated, the get signal looks up number cell state according to its containing NumberCell signal. \nIt then adds the called observer as a client of the NumberCell state object and returns the NumberCell \ns current value. Beyond manag\u00ading state, code behind extensions can implement behavior that reacts to \na signal extending a class. For example, the code behindextension fora canvas s Figure class causesex\u00adtending \nsignals to be drawn on the canvas. Signal initializationinvolves calling classextension enter methods \nto allocate the signal s state and the initialization of the signal s sub-signals.To breakcycles, signals \nthat are de\u00ad.ned recursively are not initialized, although they can still be used. Currently, signal \ninitialization is a signi.cant drag on performance: even the most trivial signal requires ex\u00adtensive \ninitialization, which is the reason object creation in Section4isveryexpensive. Additionally, with our \ncurrent scheme, extensions can cause an unbounded number of ob\u00adjects to consume individual resources. \nConsider the code Number . canvas.Figure, which expresses that every num\u00adber signal in the program s \nuniverse should be drawn as a .gure in canvas. Since the number of Number signals in a program is probably \nquite large, writing such a statement could cause the program to lock up.We plan to .x initial\u00adization \nby changing extension noti.cation semantics so that some classes can act more like concrete sets: code \nbehind could iterateover allof theclass sextending signals, as well as be noti.ed of when signals enter \nor leave the set.To en\u00adable iteration, extension of such a class would be restricted to signals that \nhave a .xed location in the connection graph with respectto the class.As anexample,if Figure in a can\u00advas \nobject is such a restricted class, then it could only be extended by signals that can be addressed from \nthe canvas object; e.g., the code Number . canvas.Figure would fail because there is no concrete pathof \nconnections from arbi\u00adtrary Number signals to the canvas signal. Correspondingly, state management must \nbecome more implicit withgarbage collection-like semantics. Implementing these features in our prototype \nis left to future work. 3. Live Programming Live programmingin SuperGlueis enabledby its simple re\u00adactive \ndata-.ow model anda programming environment that takes advantage of this model. By adhering to the declar\u00adative \ndata-.ow model, the code of a SuperGlue program has a direct relationship with its execution state. As \na re\u00adsult, the programming environment can responsively update programexecution state accordingto programmer \nedits.The object-oriented features that improve SuperGlue s scalabil\u00adity are declarative and do not interfere \nwith this property; e.g., dynamic inheritance occurs via declarative predicates rather than imperative \nslot assignment. SuperGlue is tightly integrated into a programming environment that includes a source \ncode editor with modern conveniences such as auto\u00adindenting, semantic highlighting, code completion, \nhover help, andhyperlink navigation. These services enhance live programming by allowing programmers \nto write, read, and navigate code more quickly; e.g., the programmer can use code completion to conveniently \nbrowse what signals and classes are available through a signal. As mentioned before, manyof these services, \nsuch as code completion, would be dif.cult to implement reliably and responsively without im\u00adplicit typing. \nThe SuperGlue code is processed by the SuperGlue run\u00adtime in four phases: scanning, parsing, type inference, \nand execution. All four phases are incrementally performed after every edit. As described in Section \n2.3, the execution phase is additionally performed when program state changes; e.g., when the time signal \nadvances. All four phases are based on a layered version of the damage and repair pattern that was describedin \nSection 2.3:akeyboard edit damages the token stream,a changeinthetoken stream damagesthe parse tree, \na change in the parse tree damages inferred type informa\u00adtion, and .nally, a change in inferred type \ninformation can damage the program s execution. The live programming experience is sensitive to the er\u00adror \nrecovery and edit latency characteristics of each code\u00adprocessing phase. Syntactic, semantic, and run-time \nerrors are inevitable while the programmer is typing. In the pres\u00adence of these errors, a programmer \nshould still receive use\u00adful feedback about the other parts of the program.Forcing programmers to immediately \n.x errors slows them down by forcing them off their preferred development plan. Edit la\u00adtency is the \namount of time that it takes for an edit to per\u00adcolate through all four phases. Long edit latencyreduces \nthe responsive of the feedback provided to programmers, which leadstoa mushy live programmingexperience. \nUsers will notice latencyat 100 milliseconds and become distractedby latencythat is greater than 500 \nmilliseconds. Editing in the SuperGlue programming environment is syntax-aware and not syntax-directed \n[28]; i.e., syntax errors are tolerated. Scanning and parsingin our prototypeisfairly fast and supports \nvery robust error recovery: in the presence of syntax errors, the program still executes, other parts \nof the program can be processed reliably, and editor services will stillwork correctly.We achieve this \nthrough precedence parsing[11],whichasa bottom-upparsingmethod,iseasily made incrementalandvery error \ntolerant.Infact, precedence parsers are not sensitive to syntax errors at all. The .ip-side is that precedence \nparsing is not very expressive and cannot detect syntax errors as conventionalBNF-based parsers can. \nTo deal these problems, we augment precedence parsing with enhanced scanning,abrace matcher,anda type \nchecker that also checks for syntax errors. A detailed discussion of these techniques is beyond the scope \nof this paper and will be reported on in the future. 3.1 Type Inference Incremental type inference is \nachieved by storing computed type information and typing context at each node in the parse tree. The \nparse node s type information is damaged when the node s parse structure, typing context, or child\u00adtree \ntypes have changed. Error recovery involves reporting detected errors in the programming environment \nand then reverting to a previously computed or default types for use in typing parent parse nodes. Also, \nsymbol tables support change operations.Whenthesymboltableisusedbyaparse node to lookup some name, a \ndependency with the parse node is recorded in the table. When a symbol is changed, all parse nodes that \ndepend on the symbol s new and old names are damaged. As with scanning and parsing, type errors, such \nas the failure to .nd a symbol bound to a name, are reported without stopping the executing program. \nAt worst, a type error acts to disable the current rule being edited. All connection and extension rules \nthat are encoded in a SuperGlue program are organized by our prototype accord\u00ading to the inferred types \nthat theytarget. Inference involves traversing rules that are compatible with a symbol s grow\u00ading inferred \ntype. When a rule is changed in source code, allsymbols whose inferred types areaffectedby the old and \nnew version of the rule are damaged so that repair will re\u00adcompute their inferred types using the new \nrule. Because a rule can be used in computing types for a large number of symbols, changinga rule can \nincur noticeable latency.For example, changing a rule that targets the Number class will not only damage \nall user-de.ned symbols whose type con\u00adtains Number, but will also damage all numeric literals. In a \n280 line SuperGlue program, which we describe in Sec\u00adtion 4, changing a rule that targets the Number \nclass incurs a typing delay of around three and a half seconds4. How\u00adever, because most classes are only \nextended a few times in a program, rule changes often incur no noticeable latency. Various techniques \nare used in our prototype to speed up incremental type inference. Because of dependent typing, the number \nof possible types in a program is exponential with respect to the number of declared classes although \nin practice only a few types are signi.cant. When editing changes an extension rule that targets an inferred \ntype, all symbols whose inferred types are subtypes of this type must be damaged. All signi.cant inferred \ntypes are hashed in our prototype so that the signi.cant sub-types of a type can be quickly computed \nand its symbols damaged; otherwise the editing of extension rules would be intractable. Asanexampleoflivetype \ninference, considerthe frame\u00adexpanded moviein Figure3thatis narrated as follows: (a) The programmer types \nport clyde . Ghost,whereGhost is underlined with red jaggies because it cannot be re\u00adsolved to a symbol. \n (b) As soon as the programmer de.nes the Ghost class, the reference to Ghost in clyde s de.nition becomes \nvalid. The programmer then tries to access clyde s position  4All times are measuredin this paper ona2GHz \nMacbook Pro with2GB of RAM, running Java 1.5.0 07 and Eclipse 3.3M5. signal, which is underlined with \nred jaggies because position is not a member of clyde. (c) As soon as the programmer causes the Ghost \nclass to ex\u00adtend the MyFigure class, the access to clyde s position signal becomes valid. (d) Because \nthe position signal in all Ghost signalsextends the Position class, the x and y position signals show \nup in code completion on clyde s position signal.   3.2 Execution Hot swapping in a dynamic language \nreplaces code so that its re-execution occurs according to the new version of the code as opposed to \nthe old version. Changing class mem\u00adbers or inheritance relationships can also cause updates to objects \nin the heap, as is supported in most Smalltalk [12] environments. By being based on a simple data-.ow \nmodel, liveprogrammingin SuperGlue goes much morefarther than this: code edits immediately change the \nprogram s data-.ow graph and the observable execution state of the program. Because of SuperGlue s support \nfor reactivity and dynamic inheritance, live programming can be supported with very few special-case \nsemantics. Edits that change connection and extension rules semantically masquerade as program\u00admatic \nchange. As we described in Section 2, connection and extension rules are guarded by arbitrary conditions \nwhose truth values can change over time. The editing of a rule can then resemble changing the state of \nan implicit guarding condition. For example, if the programmer types the code pacMan . Pie, the added \nextension rule can be realized as a pre-existing extension if (P) pacMan . Pie, where condition P changes \nfromfalseto true.In our prototype, rule changes cause dependent run-time signal values to be dam\u00adaged, \nwhere signal re-evaluation occurs according to an up\u00adto-date set of rules. Through this masquerade, only \nedits that add or removesignal and class de.nitions need to be special\u00adcased in our prototype. Becausevariables \ncanbe boundtoan unbounded number of signal values, rule changes can result in higher latency than what \ncan occur during type inference. As mentioned in Section 2.3, edits that add new signals to a program \nincur latency in the initialization of these signals and all of their member signals. Because edit latencies \nare linear in the number of created signals, so it is easy to imagine how an edit that increases the \nsize of something can takean arbitrary amount of time to process. We given an example of this problem \nSection 4.2. Initialization latencyis currently one of the weakest parts of our prototype and we hope \nto improve on it in the future through tuning and multi-threading. Note that signal initialize time is \nneeded in whether a change occurs programmatically or through editing. However, this latencyacts to distract \nthe programmer during editing As with the other phases, all errors that occur during the execution phase \nare duly reported and then shunted off to the background as program execution continues. Errors that \n (a) (b) (c) (d) Figure 3: An example of how type inference is used to provide semantic feedback in \nthe SuperGlue programming environment. can occur during the execution phase include ambiguously connected \nsignals, unconnected primitive signals, and cus\u00adtom errors that are detected in code behind, such as \ndivide by zero. Unlike errors in the previous phases, which can be reported against the program s source \ncode, errors in the execution phase are reported against signal values and are recorded in a separate \nview. Beyond reporting errors, our prototype does not currently providefacilities for debugging whyerrorshave \noccurred, whichis leftto futurework. After an error is reported, a default value is used if necessary \nto allow program execution to continue. For code behind to play well in SuperGlue s live pro\u00adgramming \nenvironment, it must report errors on signal val\u00adues rather than throwexceptions, whichwould cause the \npro\u00adgram to stopexecuting. Code behind should alsofall back ondefault behavior that indicates errorsinthe \nprogram sex\u00adecution,if possible.Forexample,the.guredraw routinewe have coded to draw 2D shapes will report \nan error and draw a .gure as a rectangle if the .gure is not a concrete shape. Such error recovery allows \nthe programmer to ignore errors as convenient and focus on other parts of the program. The frame-expanded \nmovie in Figure 4, which demon\u00adstrates live programming execution, is narrated as follows: (a) pacMan \ns position is bound to the keyboard of the can\u00advas it is displayed in. So that pacMan s orientation cor\u00adresponds \nto the direction it is moving in, its rotation signal is bound to its position. pacMan then moves as \nexpectedina videogame. (b) Ghosts for the game are created by de.ning a ghosts signal that extends the \nDuplicator class. Initially two  ghosts are created, which are drawn as ghost shapes on the canvas by \nextending the Figure and Ghost classes. Because both ghosts occupy the same default position, only one \nghost is visible. (c) The Ghost class is de.ned as an open extension to the ghosts.get class. In this \nclass, the position and fill signals of each ghost extend the Random class, causing each ghost to have \na random color and motion. (d) Finally, the number of ghosts is changed from two to eight, causing six \nmore ghosts to appear after around three seconds of edit latency.  4. Preliminary Experience Although \nour SuperGlue prototype is still immature, it can already be used to write complete programs. Previous \nwork [20] demonstrates how a previous prototype was used tobuild rich user interfaces with complicated \nwidgets such as tables and trees. This section describes our experience with implementinga simplegamein \nSuperGlue usinga li\u00adbrary that wrapsJava2D components. Thegameisa simpli\u00ad.edversionofPacMan with the \nfollowing features: Thegame consistsofa player controlled pacMan protago\u00adnist and multiple computer \ncontrolled ghost antagonists on a canvas.  Normally, if pacMan is touched by a ghost, it is trans\u00adported \nto the northwest corner of the canvas.  In the middle of the canvas is a powerPellet. If pacMan eats/touches \nthe powerPellet, the powerPellet disap\u00adpears for some amount of time. During this time, if   (a) (b) \n (c) (d) Figure 4: An example of how execution occurs during live editing in the SuperGlue programming \nenvironment. pacMan touches a ghost, the ghost is transported to the northwest corner of the canvas. \nAspectsof thisgamehave been usedin theexamplesof this paper.We divide our discussion into three parts: \ncode com\u00adplexity and design (Section 4.1), live programming experi\u00adence (Section 4.2), and performance \n(Section 4.3). 4.1 Code Complexity and Design The code for ourgame canbedivided into three categories: \n58 lines of game-speci.c SuperGlue code that is listed in Figure 5, 225 lines of library SuperGlue code, \nand 5,750 lines of library-speci.c Scala code. Nogame-speci.c Scala code was required, and we do not \nexpect SuperGlue pro\u00adgramsto require customJavaor Scala code.Tobe complete in our discussion, our prototype \nis implemented in 23,000 lines of Scala code. Our prototype also depends on an IDE framework, under in-house \ndevelopment at the EPFL, that handles most scanning, parsing, and Eclipse-based IDE ser\u00advices, which \nconsists of 28,000 lines of Scala code. A large portion of the code in our animation library wraps Java2D \n(2,600 lines of Scala code). This animation li\u00adbrary supports the rectangle and ellipse-likearc (Pie) \nshapes, Af.ne transforms (scaling, rotation, translation), and shape\u00adarea operations (union, intersection, \nsubtraction). On top of this functionality, we can derive more complicated shapes; e.g., the GhostShape \nin Figure5isa unionofan ellipseand translated article, with two small ellipses cut out to form its eyes. \nOur Java2D wrapper also supports .ll and line col\u00adors, keyboard input, and rudimentary collision detection. \nMany Java2D features have not yet been wrapped and a more complete wrapping will require more code. The \nother Scala parts of the library are devoted to arithmetic, timers, interpolation, random number generation, \nand number cells that can be updated. Number cells are especially important because they are currently \nthe only form of state that our li\u00adbrary supports. Other library classes arebuiltontopof these classes \nusing SuperGlue code.Forexample,a PositionCell class composes two number cell classes and extends the \n Figure5: The SuperGlue code foraPacMan-likegame; this code has been copied directly from the runningversionof \nthegame. Position class to provide a mutable position, while the PositionByKeyboard class builds on PositionCell \nto up\u00addate the position according tokeyboard input. Our library leverages rule-based abstractions to \ncreate de\u00adfault connections when possible, which reduces the number of explicit connections that must \nbe expressed per program. For example, manylibrary classes depend on timers: num\u00adber cells use time signals \nto control how often they are in\u00adcremented (velocity), random number generators use time signals to control \nhow often theygenerate new random num\u00adbers, and interpolation transforms a time signal into a wave. These \nclasses extend the Timed class whose time signalis connectedbydefaultto the time signalofacontaining \nClock signal. By having the Game class extend the Clock class, any time dependent behavior that is de.ned \ninside the Game class isby default connected from thegame s clock. Wehave found mutualextensions (Section2)and \nadapter mixins (Section 2.2) to be very useful and repeatedly appli\u00adcable in the design of our animation \nlibrary. The Position-ByKeyboard adapter mixin has already been mentioned in Section 2.2. Additionally, \nthe PositionByRandom class adapts the Position and Random classes to move .gures in random patterns, \nthe ColorByRandom class adapts the Color and Random classes to generate random colors, while the RotationByPositionCell \nclass adapts the Rotation and PositionCell classes to compute the rotation of a shape accordingtothe \ndirectionitismovingin. Mutualextensions allow us to create rich versions of classes that are only ap\u00adpliedin \nrestricted contexts.Forexample, numbers only sup\u00adport basic arithmetic operations by default. However, \nwhen used in the context of a time signal, it is often useful that numbers (including literals) also \nsupport interpolation and random number generation operators. By de.ning a Number extended RichNumber \nclass inside the Clock class, program\u00admers can write 0 <> 360 to express a value that oscillates between \n0 and 360 according to the containing Clock signal, or 0 # 256 to express a random value between 0 and \n256 that also changes according to the containing time signal. Type inference computes types that ensures \nthese operators are only accessible on numbers (including literals) that are used in the body of a class \nthat extends the Clock class. Given the design of our animation library, the game\u00adspeci.ccodeinFigure5isvery \nconciseand limitedto con\u00ad.guration tasks, e.g., how many ghosts, establishing core game relationships, \ne.g., thatpacMan is controlledbythekey\u00adboard, and coregame logic; e.g., reseting pacMan oraghost s position \nwhen theycollide. All adaptation code between non game-speci.c classes has been counted as part of the \nlibrary. Admittedly, programs might require adaptations between li\u00adbrary classes thatdo not alreadyexist,but \nthese adaptations can be published or at least added to the developers own li\u00adbrary for reuse in future \nprograms.  4.2 Live Programming The live programming experience is dif.cult to describe on paper and \nis best seen in action in the electronic version of this paper. However, edit latency can measurably \naffect the live programming experience. Many edits used in the construction of our game do not incur \nnoticeable edit la\u00adtency. However, as discussed in Section 3, there are situa\u00adtions where noticeable \nand sometimes very long pauses can occur; e.g., by causing manysignals to extend a new class or creating \nmany different signals at once. One informal benchmark that we use in ourgame is based on ghost cre\u00adation \nlatency: how long does it take to duplicate N ghosts? The good news: the edit latencyof ghost creation \nis linear creating 2N ghosts takes only twice as long as creating N ghosts. The bad news: it take around \n500 milliseconds to du\u00adplicate one ghost. The ugly news: creating ten ghosts will waste .ve seconds of \nthe programmer s life. As described in Section 2.3, the problem is in the way our prototype deals with \nsignal initialization, which we plan to .x in the future through a language change. Signi.cant edit latency \ncan also occur when type inference and circuit caches are cold.For example, whena ghostis .rst created \nduringagame, around two seconds are needed tobuild the ghost s circuits.Fortu\u00adnately, all future ghosts \nobtain these circuits from a cache. Another part of the live programming experience to con\u00adsider is error \ndetection and debugging. Our current proto\u00adtype only supports the reporting of errors, and does not pro\u00advide \nanysupport for debugging beyond providing responsive feedback from the executing program. The value of \nrespon\u00adsive feedback as a debugging aid cannot be understated: be\u00ading able to see at one moment on one \nscreen how an edit af\u00adfectsthe program sexecutionallowsthe programmertovery quickly determine if the \nedit was good or not. Errors often do not accumulate as they would if the programmer waited until after \nmanyedits to test the program. Additionally, be\u00adcause theylack control .ow, programs have simpler execu\u00adtion \nmodels that do not involve call stacks, instruction step\u00adping, and so on. However, because of SuperGlue \ns support for object-oriented dispatch of rules, code is substantially more abstract than execution; \ni.e., execution errors need not be directly related to one piece of code. For example, if a signal is \nconnected ambiguously,the involved rules could be scattered throughout the program. The immediate feedback \nof live programming eliminates much of the need to separately debug programs. This elimi\u00adnation shouldin \ntheory speed up the programming process, but we cannot measure this in our current prototype. Given suf.cient \nerror recovery and edit latencycharacteristics, live programming feedback should always be available \nto pro\u00adgrammers. However, many users often disable feedback in their IDEs orword processors because theyare \ndistractedby transient syntax, type, spelling, or grammar errors. In many cases, users are overwhelmed \nby useless feedback that re\u00adsults from poor error recovery.Part of the distraction is re\u00adlated to users \nwho prefer little or no feedback; e.g., they use Emacs or notepad instead of Eclipse. Beyond habit and \ner\u00adror recovery, good feedback must be tuned so that is con\u00adtinuouslyavailable discreetlyinthe background \nwithoutdis\u00adtracting the user when its not needed. Ensuring and validat\u00ading that feedback is engineered \nin this way is left to future work. 4.3 Performance More than most dynamic languages, SuperGlue eschews \nperformance in favor of being higher-level, more .exible, and supporting live programming. Although edit \nlatency is important to live programming, overall program perfor\u00admance is less so. However, there is \nthe danger that Super-Glue could be too slow for manykinds of applications. One area where our prototype \ns performance could be improved is in application start-up. Because of our prototype sreliance on incremental \nwork list processing, much work is done and thrownaway because manynodes are processed before their dependencies \nare ready. For this reason, on start up, our game requires around 32 seconds to start-up: two seconds \nfor parsing, ten seconds for type inference, and 20 seconds to perform initial execution processing. \nOur focus on edit latency, which work lists address, has led us to poor batch performance, and future \nwork should focus on .xing this. Another way of measuring performance in ourgame is through frame rate. \nFor our game, we measure frame rate as related to ghost count: around 100 frames per second is possible \nfor pacMan and a couple of ghosts, ten frames per second with ten ghosts, and .ve frames per second with \ntwenty ghosts. Although such performance might be accept\u00adable forasimplegame,our implementation needs \nbetter per\u00adformance so that SuperGlue can be used more widely. SuperGlue s reactive data-.ow model does \nnot support direct compilation. Instead, a SuperGlue program executes as a connection graph that resembles \na scene graph in a 3D program. As with scene graphs, the connection graph of a SuperGlue can conceivably \nundergo high-level dynamic optimizations that speed up how programs execute, espe\u00adcially if domain speci.c \nknowledge can be considered. As SuperGlue is only acting as a middle man between Java\u00adimplemented components, \na compiler could also bind these components directly together by inlining the component Java code with \nJava code generated from SuperGlue code. Inlining would allow SuperGlue performance to approach Java \nperformance levels. However,to preserve live program\u00adming support, such inlining mustbe retractable. \nFuturework will explore how performance can be improved through dy\u00adnamic graph optimizations and compilation. \n5. Related Work SuperGlueis stronglyin.uencedby Self [29].Every artifact of a Self program is an object \nwhose every aspect, includ\u00ading what they extend, can be updated at run-time. Self sup\u00adports no abstractions \nother than objects: class or method con\u00adstructions areexpressibleas objects. SuperGlueis more con\u00adventional: \nbehavior is expressed through distinct class con\u00adstructs. Self supports code hot swapping and responsive \nlive programming in Morphic [18] through polling and a graphi\u00adcal meta menu that can directly edit speci.c \nobjects [30]. However, live programming does not apply to Self source code, and direct changes to objects \nare not copied back into the code of the program. In SuperGlue, all program behavior is derived from \ncode that can undergo live programming. Because dynamic inheritance in Self occurs through im\u00adperative \nslot assignment, the type of an object can change in any way at anytime without the bene.t of static \ntyping. Dynamic object inheritance is supported with static typing in Cecil[6,7] through declarative \npredicates, which are also used in SuperGlue. However in SuperGlue, reactive signals make predicated \nclass extensions more responsive: because predicates refer to signals, when a signal extends or unex\u00adtends \na class is known immediately. In Cecil, program be\u00adhavior cannot responsively react to changes in class \nexten\u00adsions because predicates can only be checked on demand. SuperGlue differs from existing dynamic \nlanguages such as Lisp, Smalltalk, or Erlang in its support for live program\u00adming and declarative programming \nmodel. Of these lan\u00adguages, Erlang [1] s robust support for fault tolerance and hot swapping comes closest \nto live programming. Like Su\u00adperGlue, Erlang processes communicate explicitly via mes\u00adsagesandnot implicitly \nthrough shared pointers.Asa result, a process can be restarted without de-stabilizing the entire program. \nSuperGlue supports more responsiveliveprogram\u00adming through signals, which unlike messages encapsulate \nstate change. Also, SuperGlue supports the hot swapping of expressions rather than larger-grained processes. \nOne of the main contributions of this paper is showing how visual language liveness can be realized in \na textual language. Ever since SketchPad [27], visual languages have emphasized simple interactive programming \nmodels that ac\u00adcommodate end users or novices. SuperGlue is designed for programmers who typically use \ndynamic languages, and end-user programming is not a goal. Many modern visual languages solve the scaling \nup problem in ways that do not degrade live programming; e.g., assemblies in Fabrik [15] are reused as \nobjects, and data types in Forms/3 [3] can be elegantly speci.ed as generic spreadsheet forms. Su\u00adperGlue \nsolves the scaling-up problem using conventional class constructs that are more suited to the naming \ncapa\u00adbilities of textual languages. AgentSheets [24] is a visual spreadsheet language that is based on \ngraphical rewrite rules and implicit component assembly through spatial adjacency. AgentSheets demonstrates \nhow live languages can be based on rewrite rules, and how manyuseful visual concepts (spa\u00adtial adjacency)do \nnot transfer easily to text. Many existing textual languages are based on reactive data-.ow programming \nmodels. Signal [2], Lucid [32], and LUSTRE [5] are textual reactive data-.ow languages that emphasize \nthe formal veri.cation of concurrency in real\u00adtime systems. As a result, they are not designed to support \nthe rapid development capabilities of a dynamic or live lan\u00adguage. SuperGlue is very similar to functional-reactive \nlan\u00adguages such as Fran [10],Yampa [14], and FrTime [8]. Such languages augment the functional paradigm \nwith reactive signals; e.g., the result of a function call f(x) forms a sig\u00adnal that changes whenever \nthe x signal changes. In contrast, SuperGlueis basedon rules, which are less.exiblebuthave the advantage \nthat they do not need to be applied explic\u00aditly. It remains an open question whether functional-reactive \nlanguages can support responsive live programming with re\u00adcursive applicative programming models. Subtext[9] \nbridges thegap between code andexecution by allowing programmers to edit code that directly repre\u00adsents \nprogram executions that lacks textual names. Because edits operate directly onexecution, Subtext supports \nrespon\u00adsive live programming. On the other hand, Subtext supports scaling through an unproven copy-.ow \nrather than data\u00ad.ow. Code and execution remain separate in SuperGlue and theirgapis only bridged throughlive \nprogramming. Flogo II [13] is another textual live language that focuses on end-user robot programming. \nFlogo II supports both re\u00adactive data-.ow and procedural code, where the latter does not support responsive \nlive programming. Given its focus on end users, Flogo II scaling constructs (Erlang-like pro\u00adcesses) \nare more concrete and do not scale as well as Super\u00adGlue s classes. An intriguing idea in Flogo II s \nis live text: the state of an executing program is presented as graphical annotationsinthe program stextual \nsource code.Forexam\u00adple, statements are grayed out when they are guarded by a condition that is currently \nfalse. SuperGlue does not cur\u00adrently support similar capabilities. SuperGlue s static type system relies \non type inference and dependent typing to provide programmers with se\u00admantic feedback while avoiding \nverbose type annotations. Scala [22] is a statically typed object-oriented language that utilizes dependent \ntyping and type inference to reduce ver\u00adbosity, and therefore is a viable alternative to dynamic lan\u00adguages. \nSuperGlue s type system is in.uenced by Scala s; however, dynamic typing is still used to validate connec\u00adtions. \nAn alternative way of obtaining semantic feedback in a dynamic language is through the use of heuristics \nand pro\u00adgram analysis; e.g., Olin Shivers describes various analyses for inferring types in Scheme [26]. \nHowever,global program analysis is a hard problem and so is often not very accurate or ef.cient. Type \ninference in SuperGlue relies on a very simple program analysis that remains accurate while being both \n.ow and context insensitive. 6. Conclusions and Future Work Programmer-centric dynamic languages have \nbeen around for awhile: Lisp and Smalltalk are respectively more than 40 and 25 years old. New dynamic \nlanguages, such as Ruby [19] and Python [31], still strongly resemble Lisp and Smalltalk in their feature \nsets. Now is the time to explore languages that support higher-level live programming with responsive \nsemantic feedback. This paper demonstrates the viability of both the design and implementation of such \na live language that also supportstextual abstraction.Wehave shownthatalivelanguagecouldbebasedonasimple \ndeclar\u00adative reactive data-.ow model that is augmented with pred\u00adicated object-oriented inheritance and \ndispatch.We believe that a live text languages could be based on other simple computational models such \nas constraints, .rst-order logic, and rewrite rules, where live visual languages already exist. Future \nwork will focus on improving SuperGlue s design and implementation in the following areas: -As described \nat the end of Section 2.3, SuperGlue s sup\u00adport for class extension and signal initialization will be \nchanged to enhance performance. -Our prototype does not currently provide enough debug\u00adging support.We \nplan to allows programmers to inspect, reason about errors in, and edit speci.c signals. -We must improve \non latency and performance if the widespread use of SuperGlue is to be viable. Building a live programming \nenvironment is an undocumented black art that requires a complete re-think of how code is scanned, parsed, \ntyped, and executed. The prototype de\u00adscribed in this paper has already undergone some tuning and there \nare still manyimprovements that we can make. -We should explore the incorporation of other visual and \ninteractive features into the SuperGlue s programming environment. Features to be explored include support \nfor direct manipulation, where speci.c signal values can be changed directly, and live text, where source \ncode is annotated with execution details. Finally, we plan to support SuperGlue with rich libraries that \nwill make it a good platform for building interactive programs in an interactive way. Acknowledgments \nWe thank Adriaan Moors, Gilles Dubochet, Lex Spoon, and the anonymous reviewers for comments on drafts \nof this paper. This work was partially supported by a grant from the European Framework6PalCom project. \nReferences [1]J.L. ArmstrongandR.Virding.Anexperimental telephony switching language. In Proc. of Interantation \nSwitching Symposium, May 1991. [2]A.Benveniste,P.L. Geurnic,andC. Jacquemot. Synchronous programming \nwith events and relations: the Signal language and its semantics. In Science of Computer Programming, \n1991. [3] M. Burnett, J. Atwood, R.Walpole, H. Gottfried, J. Reich\u00adwein, and S.Yang. Forms/3:A.rst-order \nvisual language to explore the boundaries of the spreadsheet paradigm. In Journal of Functional Programming, \npages 155 206, Mar. 2001. [4] M. M. Burnett, M. J. Baker, C. Bohus,P. Carlson, S.Yang, andP.van Zee. \nScalingup visual programming languages.In IEEE Computer, pages 45 54, Mar. 1995. [5] P. Caspi, D. Pilaud, \nN. Halbwachs, and J. A. Plaice. LUS-TRE: a declarative language for programming synchronous systems. \nIn Proc. of POPL, 1987. [6] C. Chambers. Object-oriented multi-methods in Cecil. In Proc. of ECOOP, pages \n33 56, June 1992. [7] C. Chambers. Predicate classes. In Proc. of ECOOP, pages 268 296, July 1993. [8] \nG. H. Cooper and S. Krishnamurthi. Embedding dynamic data.ow in a call-by-value language. In Proc. of \nof ESOP, 2006. [9] J. Edwards. Subtext: Uncovering the simplicity of program. In Proc. of OOPSLA Onward, \n2005. [10] C. Elliott andP. Hudak. Functional reactive animation. In Proc. of ICFP, volume 32 (8) of \nSIGPLAN Notices, pages 263 273.ACM, 1997. [11] R.W. Floyd. Syntactic analysis and operator precedence. \nIn Journalof theACM, volume 10 (3), pages 316 333, 1963. [12] A. Goldbergand D. Robson. SmallTalk-80: \nThe Language and its Implementation. AddisonWesley, Boston, MA, USA, 1983. [13] C. M. Hancock. Real-time \nProgramming and the Big Ideas of Computational Literacy. PhD thesis, Massachusetts Institute ofTechnology, \nSept. 2003. [14] P. Hudak, A. Courtney, H. Nilsson, and J. Peterson. Arrows, robots, and functional reactive \nprogramming. In Advanced Functional Programming, volume 2638 of Lecture Notes in Computer Science, pages \n159 187. Springer, 2002. [15] D.Ingalls,S.Wallace,Y.-Y. Chow,F. Ludolph, andK.Doyle. Fabrik, a visual \nprogramming environment. In Proc. of OOPSLA, pages 176 190, Nov. 1988. [16] R. M. Karp and R. E. Miller. \nProperties of a model for parallel computations: Determinacy, termination queueing. SIAMJournal for Applied \nMathemetics, 14(6):1390 1410, Nov. 1966. [17] P. O. Latour. Quartz Composer. Apple Computer, 2005. http://developer.apple.com/graphicsimaging/quartz/\u00adquartzcomposer.html. \n[18] J. H. Maloneyand R. B. Smith. Directness and liveness in the Morphic user interface construction \nenvironment. In ACM Symposium on User Interface SoftwareandTechnology,pages 21 28.ACM, 1995. [19] Y. \nMatsumoto. Ruby: Programmers BestFriend. http://www\u00ad.ruby-lang.org/en/. [20] S. McDirmid and W. C. Hsieh. \nSuperGlue: Component programming with object-oriented signals. In Proc. of ECOOP, June 2006. [21] National \nInstruments Corporation. LabVIEW User Manual, 1990. [22] M. Odersky and et. al. The Scala language speci.cation. \nTechnical report, EPFL, Lausanne, Switzerland, 2007. http://scala.ep..ch. [23] M. Petre. Whylooking isn \ntalways seeing: Readership skills and graphical programming. Comm. of theACM, pages 33 44, June 1995. \n[24] A. Repenning. AgentSheets: an interactive simulation environment with end-user programmable agents. \nIn Proc. of Interaction, 2000. [25] E. Sandewall. Programming in an interactive environment: the lisp \nexperience. Computing Surveys, 10(1), Mar. 1978. [26] O. Shivers. The semantics of Scheme control-.ow \nanalysis. In Proc. of PEMP, pages 190 198, June 1991. [27] I. B. Sutherland. SKETCHPAD, a man-machine \ngraphical communication system. In Proc.ofthe SpringJoint Computer Conference, pages 329 346, 1963. [28] \nT. Teitelbaum and T. W. Reps. The Cornell program synthesizer: A syntax-directed programming environment. \nCommunicationsof theACM, 24(9):563 573, 1981. [29] D. Ungar and R. B. Smith. Self: the power of simplicity. \nIn Proc. of OOPSLA, pages 227 242, Oct. 1987. [30] D. Ungar and R. B. Smith. Programming as an experience: \nthe inspiration for Self. In Proc. of ECOOP, pages 227 242, Aug. 1995. [31] G. van Rossum and F. L. Drake. \nThe Python Language Reference Manual, Sept. 2003. [32] W. W. Wadge and E. A. Ashcroft. Lucid, the Data.ow \nProgramming Language. Academic Press, 1985.   \n\t\t\t", "proc_id": "1297027", "abstract": "<p>A dynamic language promotes ease of use through flexible typing, a focus on high-level programming, and by streamlining the edit-compile-debug cycle. Live languages go beyond dynamic languages with more ease of use features. A <b>live language</b> supports <b>live programming</b> that provides programmers with responsive and continuous feedback about how their edits affect program execution. A live language is also based on high-level constructs such as declarative rules so that programmers can write less code. A live language could also provide programmers with responsive semantic feedback to enable time-saving services such as code completion. This paper describes the design of a textual live language that is based on reactive data-flow values known as <b>signals</b> and <b>dynamic inheritance</b>. Our language, SuperGlue, supports live programming with responsive semantic feedback, which we demonstrate with a working prototype.</p>", "authors": [{"name": "Sean McDirmid", "author_profile_id": "81100205762", "affiliation": "Ecole Polytechnique Federale de Lausanne, Lausanne, Switzerland", "person_id": "PP39102353", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297073", "year": "2007", "article_id": "1297073", "conference": "OOPSLA", "title": "Living it up with a live programming language", "url": "http://dl.acm.org/citation.cfm?id=1297073"}