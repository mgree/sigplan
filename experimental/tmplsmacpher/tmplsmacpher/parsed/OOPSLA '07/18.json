{"article_publication_date": "10-21-2007", "fulltext": "\n Establishing Object Invariants with Delayed Types Manuel F\u00a8ahndrich Songtao Xia Microsoft Research \n{maf,sxia}@microsoft.com Abstract Mainstream object-oriented languages such as C# and Java provide an \ninitialization model for objects that does not guar\u00adantee programmer controlled initialization of .elds. \nInstead, all .elds are initialized to default values (0 for scalars and null for non-scalars) on allocation. \nThis is in stark contrast to functional languages, where all parts of an allocation are ini\u00adtialized \nto programmer-provided values. These choices have a direct impact on two main issues: 1) the prevalence \nof null in object oriented languages (and its general absence in functional languages), and 2) the ability \nto initialize cir\u00adcular data structures. This paper explores connections be\u00adtween these differing approaches \nand proposes a fresh look at initialization. Delayed types are introduced to express and formalize prevalent \ninitialization patterns in object-oriented languages. Categories and Subject Descriptors F.3.1 [Specifying \nand Verifying and Reasoning about Programs]: Invariants; F.3.3 [Studies of Program Constructs]: Object-oriented \nconstructs, Type structure; D.2.4 [Software/Program Veri.cation]: Class invariants; D.1.5 [Object-oriented \nProgramming]; D.3.3 [Language Constructs and Features]: Classes and objects General Terms Languages, \nReliability, Veri.cation Keywords non-null types, object invariants, initialization 1. Introduction \nIn functional languages, data structures are built bottom-up, and all parts of an allocation are initialized \nunder program\u00admer control. This bottom-up approach provides strong guar\u00adantees in terms of initialization: \nthere are no initialization Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPLSA 07 October 21 25, Montr\u00b4eal, Qu\u00b4ebec, Canada. Copyright c . 2007 ACM \n978-1-59593-786-5/07/0010. . . $5.00 holes present that have to be .lled later by programmers. A direct \nconsequence is the absence of a null value in these languages, as it is not needed. In object-oriented \nlanguages, initialization happens top\u00addown instead. Allocation of an object default-initializes all .elds \nto 0-equivalent values (0 for scalars, null for non\u00adscalars). An object constructor is then invoked that \nselec\u00adtively initializes some of the .elds again, possibly allocating sub-objects and calling constructors \non them. A direct con\u00adsequence of this approach is the need to have 0-equivalent values for all types. \nFor reference types, this means that a null value is part of every type. Initialization via constructors \ndoes not usually guarantee that certain .elds are initialized to something other than their default value. \nCircular structures Besides the initialization guarantees and the need for null, the top-down vs. bottom-up \ninitializa\u00adtion also impacts the ability to initialize circular data struc\u00adtures. In object-oriented \nlanguages, it is common to build highly connected and circular structures. The top-down ap\u00adproach makes \nthis easy, as a self-reference is available dur\u00ading the initialization of an object. This self-reference \ncan be passed to methods and stored into .elds of other objects. In functional style bottom-up initialization, \ncircular data structures are not directly expressible. However, some lan\u00adguages, such as OCaml and lazy \nlanguages, such as Haskell, do provide recursive bindings. In OCaml [8], these recur\u00adsive value bindings \nare very restricted, as the compiler must guarantee proper initialization: type T=Aof T* T| Bof T* T \nlet rec x=A(x,y ) and y=B(y,x ) OCaml restricts the right-hand side of recursive value def\u00adinitions to \nbe constructors or tuples, and all occurrences of the de.ned names must appear only as constructor or \ntuple arguments. These restrictions allow the following implemen\u00adtation for such recursive bindings: \n.rst allocate memory for the values being constructed. In the example, this means al\u00adlocating memory \nto hold the two triples (a tag and two val\u00adues) and bind these memory locations to xand y.Onceall bindings \nare established, the constructed values can be ini\u00adtialized normally. If we write out these steps in \npseudo-code, they look as follows: 1 public class List { 2 Node sentinel ; 3 public List () { this .sentinel \n= new Node(this); } 4 5 public void Insert (object data) { 6 this . sentinel . InsertAfter (data); 7 \n} 8 } 9 10 internal class Node { 11 List parent; Node prev; Node next; 12 object data; 13 // for sentinel \nconstruction 14 internal Node(List parent) { 15 this .parent = parent; 16 this .prev = this; 17 this \n.next = this; 18 } 19 // for data node construction 20 private Node(Node prev, Node next, object data) \n{ 21 this .parent = prev.parent; 22 this .prev = prev; 23 this .next = next; 24 this .data = data; 25 \n} 26 internal void InsertAfter (object data) { 27 Node newNode = new Node(this, this.next, data); 28 \nthis .next.prev = newNode; 29 this .next = newNode; 30 } 31 internal object Remove() { 32 this .next.prev \n= this.prev; 33 this .prev.next = this.next; 34 this .next = this; 35 this .prev = this; 36 return this \n.data; 37 } 38 } Listing 1. Linked list example let x = alloc [3]; and y = alloc [3] in initACons(x, \nx, y ); // x.tag = A; x.0 := x; x.1 := y initBCons(y, y, x ); // y.tag = B; y.0 := y; y.1 := x We assume \nthe automatically generated functions initACons and initBCons that take the uninitialized block and set \nthe tag and the two arguments. Let s now see how a similar initial\u00adization is expressed in object-oriented \nstyle. The example in Listing 1 shows the core of a doubly-linked list implemen\u00adtation in C# using a \nsentinel node and back-pointers from each node to the list. The initialization of List and Node is non-symmetric. \nWe perform the initialization top-down, by .rst allocating a List object, passing the self-reference \nto the constructor of Node and .nally assigning the sentinel to the 1 class List { 2 Node! sentinel \n; 3 List () { this .sentinel = new Node(this); } 4 5 void Insert (object data) { 6 this . sentinel . \nInsertAfter (data); 7 } 8 } 9 10 class Node { 11 List ! parent; Node! prev ; Node! next; 12 object data; \n13 // for sentinel construction 14 Node(List ! parent) { 15 this .parent = parent; 16 this .prev = this; \n17 this .next = this; 18 } 19 // for data node construction 20 Node(Node! prev, Node! next, object data) \n{ 21 this .parent = prev.parent; 22 this .prev = prev; 23 this .next = next; 24 this .data = data; 25 \n} 26 ... 27 } Listing 2. Example with non-null types List . sentinel .eld. Note that the List constructor \nbuilds an empty list, as the sentinel node is always part of a list. 1.1 The Problem We are interested \nin providing object-oriented languages with stronger invariants to express design decisions and catch \nerrors early. In previous work [4], we proposed non\u00adnull types for object-oriented languages to deal \nwith the prevalence of null-dereference errors. In that work, we pro\u00adposed that for each reference type \nT,there are two ver\u00adsions: T? and T ! , where the former includes the null value, whereas the latter \nexcludes it. In the rest of this paper, we do not explicitly use the form T? and instead just write T \nfor the possibly null type. If we allow object .elds to be declared with with non-null types, we recover \nthe bene.t of functional languages where data .elds are guaranteed to be initialized and non-null. Modifying \nour previous example, we would like to mark the .elds of List and Node as non-null. Such .eld invariants \nare crucial in checking that the store to this .next.prev on line 28 cannot cause a null-dereference. \nListing 2 shows the same code with non-null type speci\u00ad.cations for all the .elds and the necessary parameters \n(we omit access modi.ers such as private and public from now on to reduce unnecessary details). Fields \nwith non-null types represent simple object invari\u00adants, guaranteeing that the corresponding .eld is \nnever ob\u00adservably null. Due to the top-down approach of initialization in object-oriented languages however, \nthis invariant does not necessarily hold during initialization. In particular, in the ex\u00adample, when \nthe self-reference to the List object is passed to the Node constructor on line 3, the invariant of the \nList ob\u00adject is not yet established: this .sentinel is still null. In [4], we addressed the initialization \nproblem by 1. Forcing constructors to initialize all non-null .elds 2. Introducing raw types to express \nthe fact that self\u00adreferences during initialization are not yet fully initial\u00adized. In constructors of \nclass C, the self-reference this is thus typed as Craw. Reading a .eld from a reference of type Craw \nalways produces a possibly null value, even if the .eld is declared non-null.  With raw types, we would \nhave to annotate the List parame\u00adter on line 14 as raw, yielding the following Node construc\u00adtor. 10 \nclass Node { 11 List ! parent; Node! prev ; Node! next; 12 object data; 13 // for sentinel construction \n14 Node(List ! raw parent) { 15 this .parent = parent; // error : List ! raw = List! 16 this .prev = \nthis; // error : Node!raw = Node! 17 this .next = this; // error : Node!raw = Node! 18 }19 ... Unfortunately, \nthis approach does not help when uninitial\u00adized object references are to be stored into .elds of other \nobjects as is the case here, unless we mark the .eld types as raw. We d like to avoid using raw types \nfor .elds, as they would weaken the object invariant considerably. Thus, with\u00adout changing the .eld types, \nwe cannot type our example be\u00adcause in the contexts of the constructors, the self-reference this now \nhas type List ! raw (resp. Node!raw). As a result, the assignments on lines 15 17 are ill-typed, because \nthe .eld types are not raw types. Although the raw-type system is too weak to type it, we can intuitively \nargue the correctness of the example: the example is correct, because the code is not relying on the \n.eld invariants until both objects are fully initialized. At that point in time, the references need \nno longer be viewed with raw types.  1.2 Delayed Objects In this paper, we formalize the intuition for \nwhy the exam\u00adple in the previous section is correct. The principal idea is to separate allocation from \ninitialization and to force the al\u00adlocation of an object o to specify a future time t,atwhich o becomes \nvalid (meaning that its .eld invariants hold). We refer to this time t as o.ValidTime in our discussion, \nbut it is not needed at runtime. Thus, an allocation of o establishes a proof obligation that by time \no.ValidTime, all invariants of o (in particular non-nullness of .elds) are established. The passing of \ntime is modeled as an equivalence class Now of time labels that are no longer in the future. When time \nt arrives, it is added to the equivalence class Now. Thus, a time t.Now is a future time, which we will \nwrite as t> Now. We say that an object o is delayed, if o.ValidTime > Now. Reading a .eld from a delayed \nobject may yield null,even if the .eld is declared with a non-null type. The rest of the paper makes \nthese ideas precise in the form of a static type system based on the following novel ideas: Delayed types \nA delayed type C.t describes a delayed object o with o.ValidTime = t. Delayed types are similar to raw \ntypes in that .eld invariants may not yet hold. However, delayed types differ from raw types in that \nwe can reason about when the referenced object becomes valid. Raw types intuitively are delayed types \nwith an unknown delay time: Craw = .t.C.t . Delayed .elds Given an object o with delayed type C.t , we \nnot only know that o.ValidTime = t, we can also reason about the delay of objects q reachable from o \nvia one or more .eld reads (o . q). In order for o to be valid at time o.ValidTime, all such objects \nq must be valid by that time as well, i.e., q.ValidTime =t. This fact is convenient, as it enables storing \na reference of delayed type into a .eld whose type is not delayed,as long as the target object s delay \nis no shorter than the stored object. As a consequence, we do not need to declare .elds with delayed \ntypes, as their delay is constrained by the delay of the container. A .eld assignment o.f = q is thus \nallowed whenever q.ValidTime =o.ValidTime. Our type system enforces this property and thereby guarantees \nthat invariants are not ob\u00adserved prematurely. Delay scopes We separate allocation from initialization \nand introduce a delay scope around those two parts. Given a future time t, allocation is expressed as \nCOt x= alloc C[t]; The newly allocated object has x.ValidTime = t and is assumed to be 0-initialized \n(null for non-scalar .elds). The time t speci.es when the invariants of the allocated object must hold. \nNote that there is no construtor call directly associated with an allocation. A delay scope introduces \na binding of a future time t that arrives at the end of the block: delay t { B } At the end of the delay \nscope, types C.t become equiva\u00adlent to C.Now, which we just write as type C.In other words, at the end \nof the scope, objects with delay t can now be con\u00adsidered fully initialized. method declaration O(m)= \nsr C.m[Xt, G](y0 : C! .0 ,y1 : s1, .., yn : sn) Er .eld declaration O(f)= C.f : t method de.nition O(C.m)= \nsr C.m[Xt, G](y0 : C! .0 ,y1 : s1, .., yn : sn) Er{e }inheritance O fC =D Variables Expressions Environment \n Figure 1. Class and Method Declarations y .V Classes e ::= y |e.f |y.f := e |e; e Methods |let y = e \nin e Fields |y0.m[.X](y1, .., yn) E.ects |ifnull y then e else e Types |delay t in e Delay types |let \ny = alloc C[t] in e Time vars |unpack t, y = e in e Time G ::= |G,y: s |G,t Substitution |G,t=. |G,t>Now \nB, C, D m .M f .F E .V \u00d7F t ::= C |C! |void s ::= t . |.(t =.).s t .T . ::= Now |t .n . .T .. Figure \n2. Language De.nitions For this to be sound, we must prove that at the end of a delay scope that binds \nt, all objects with delay t satisfy their invariants. For non-null .eld invariants, this is simple to \nprove: it suf.ces, for example, to separately ensure that block B contains calls to constructors on all \nallocations of time t, and to prove that each constructor initializes all non\u00adnull .elds. A strength \nof our technique is that it works equally for the initialization of circular object graphs as for DAGs. \n 1.3 Outline The remainder of the paper is organized as follows: Sec\u00adtion 2 introduces a small object \noriented calculus and type language to formalize our approach. Section 3 describes the type rules for \nthe language and Section 4 argues the correct\u00adness of our approach. Sections 5 and 6 describe our imple\u00admentation \nand experience in Spec#. Section 7 discusses pos\u00adsible extensions and future work, Section 8 contains \nrelated work, and Section 9 concludes.  2. Language We use a small core of an imperative object-oriented \nlan\u00adguage to formalize our ideas. The language consists of class declarations with .elds and methods. \nWe assume that the declaration information is provided by the overloaded class environment O as shown \nin Fig. 1. To avoid unnecessary complications, all methods are virtual instance methods and a method \nname m stands for a unique non-overridingmethod declaration. Thus, unrelated methods (not having a com\u00admon \nbase method) must have distinct names. O(m) there\u00adfore maps a method name to the unique declaring class \nand signature where m is introduced. A particular method de.\u00adnition in a class C is found via O(C.m). \nWe assume simi\u00adlarly, that each .eld has a unique name and that .elds cannot be shadowed or overwritten. \nThus, O(f) maps a .eld name f to the declaring class and type of the .eld. Note that the declared .eld \ntypes need never be delayed and our language thus uses t for .eld types, rather than possibly delayed \ntypes s. We assume that the inheritance induced subtyping relation is provided by O fC =D and that it \nis re.exive, transitive, and anti-symmetric. Each method is universally quanti.ed (generic) over a set \nof time variables [Xt, G] that are constrained by an envi\u00adronment G. Additionally, method signatures \nconsist of a re\u00adturn type sr, the method name and de.ning class C.m,and names and types of formal parameters \nyi : si. The receiver (self or this) has an explicit name and is always the .rst pa\u00adrameter y0. The signature \nfurther consists of the effect Er describing the set of .elds initialized by the method. We use such \neffects to ensure the initialization of .elds. This ap\u00adproach obviates the need to treat constructors \nspecially. Figure 2 describes the expression and type language. The expression language consists of standard \nparts such as local bindings, .eld reads and writes, and sequential composition. Method calls are standard \nexcept that they contain an ex\u00adplicit instantiation [.X] of the quanti.ed time variables. To re\u00adduce \nthe number of cases in the calculus, all calls are virtual. Adding non-virtual calls does not pose any \nadditional prob\u00adlems. The ifnull conditional allows testing reference values against null, which is the \ndefault value of all .elds (we don t need an explicit null constant). The delay t in e expression introduces \na fresh time t in the scope of expression e. Allocation expression let y = alloc C[t] in e allocates \na fresh object of class C that must be initialized by some future time t. In order to simplify the technical \npresentation, we explicitly name the allocated ob\u00adject with the binding y and enforce a stricter rule \nthat re\u00adquires the initialization of the object by the end of expres\u00ad OfC =D C =D [ ST-REFL ] [ ST-INHERIT \n] [ ST-NONNULL1 ] C!=D! s =s C =D Gft t=Now GfGfGfGf Figure 3. Subtyping rules Gft .1 =.2 ==GGGfff=GGGfff=GGG=Gf==...,,t23t \n[]]][[T-TT-NLT-RMRANS MOATER MEFL GGGf=f=f=.....t13ttt G=G,t>Now,.. [TM-LATER ] Gft t>Now === === C =D \nt1 =t2 t1 =t2 [ST-NONNULL2 ] [ST-DELAY ] [ST-NOW ] .. t Now C!=D t =t t 1 =t 1 2 2 Figure 4. Timing \nrules sion scope e. Due to syntactic nesting, this scope ends prior to the arrival of time t. Finally, \nbecause we make use of existential types, we use an explicit unpack expression to bind the unpacked value \nand enforce scoping of the existentially bound time variable. We bind the existentially bound time variable \nto program time variable t. Initialization effects E consist of a set of variable-.eld pairs. Ordinary \ntypes t are either possibly null class refer\u00adences C, non-null references C!,or void (we do not add any \nother primitive types for simplicity). Delayed types sconsist of an ordinary type t and a delay time \n.. Time expressions . are either the equivalence class Now of times that have arrived, or a time variable \nt. Finally, we also need existen\u00adtial quanti.cation over constrained time variables in order to handle \n.eld reads. The form .(t =.).s binds the variable t. Typing environments Gcontain both typing assumptions \nfor expression variables y, as well as binding assumptions for time variables t. The latter come in three \nforms: 1) an unconstrained t(useful if a method is generic in t), 2) t=., binding twith upper-bound ., \nand 3) t> Now, binding tas a future time. Subtyping Subtyping (Fig. 3) in our system is restricted to \nsubtyping induced by inheritance and subtyping between possibly null and non-null references. Timing \nrelations do not induce subtyping due to the fact that .elds of objects are mutable. The only rule that \ninvolves timing constraints is ST-NOW which axiomatizes the equivalence class Now.All times t=Now are \nconsidered equivalent to Now. Timing The timing rules in Fig. 4 allow one to derive tim\u00ading constraints \nfrom timing assumptions in the environment G. 2.1 Example Revisited Returning to our example from Section \n1, we can now type the initialization of the doubly linked list in our calculus using delayed references \nas follows: 1 List . sentinel : Node! 2 3 void List . ctor [t, t>Now](this:List!Ot) {this.sentinel} \n4 { 5 let tmp:Node!Ot = alloc Node[t] in // allocate 6 tmp.ctor1[t ]( this ); // call constructor 7 this \n. sentinel = tmp; 8 }9 10 void Node.ctor1[t, t>Now](this:Node!Ot,parent:List!Ot) 11 {this .parent, this \n.prev, this .next} 12 { 13 this .parent = parent; 14 this .prev = this; 15 this .next = this; 16 } Even \nthough we will only present the type rules in the next section, we discuss here how the type system reasons \nabout the above code. The List . ctor method is generic over a time t with constraint t>Now. The type \nof this is declared as List ! Ot, ie., it is also delayed with time t. The constraint t>Now is needed \nto allow the allocation of the sentinel Node on line 5, as allocations always require a future time. \nThe allocation of the sentinel node yields a delayed reference of type Node!Ot which is bound to tmp \n1. The choice of time t for the allocation of Node is crucial here. It speci.es that both the List and \nits sentinel Node become valid at the same time. This allows them to safely refer to each other prior \nto being fully initialized. The delayed types of the List 1 We show the type here, although the calculus \ndoes not need type annota\u00adtions in bindings. and the sentinel Node guarantee that no code can rely on \nthe invariants of these objects prior to t. For example, were we to read the parent .eld prior to time \nt, we must read it through a delayed reference of type Node!Ot. The type system will ' produce a type \nList Otfor some delay t', stating that the parent reference itself could be null, and that the invariants \nof the parent may not hold either. To guarantee that all the non-null declared .elds of the sentinel \nnode thus allocated are eventually initialized, the type system generates a proof obligation that all \nthese .elds are written to in the block following the allocation. This obli\u00adgation is immediately discharged \nby the call to the ctor1 method, since this method is declared with initialization ef\u00adfect {parent,prev,next}, \nthus guaranteeing that these .elds are written. The call itself is checked as follows: the method Node.ctor1 \nis also generic over a time t, which we instan\u00adtiate here with the bound time t of List . ctor. The con\u00adstraint \nt>Now is also satis.ed. Then, the receiver tmp and the parameter this have exactly the types required \nby the Node.ctor1 signature (Node!Ot and List ! Ot). Next, tmp is assigned to the sentinel .eld of this.Note \nthat the sentinel node in tmp still has a delayed type Node!Ot at this point, but the sentinel .eld of \nList is simply Node!, i.e., not delayed. Yet, the assignment is allowed because the containing List object \n(this) is itself delayed with time t, which is obviously no sooner than the delay of the sentinel. The \nvalue written to the .eld must be non-null according to the .eld type, which is guaranteed by the type \nof tmp. Finally, at the end of method List . ctor, the return type and the initialization effects are \nchecked. The method is declared to initialize sentinel , which is the case. Now, consider some client \ncode building a fresh empty list. In order to allocate, the code requires a future time t.A delay blockisusedtobind \na fresh time t. let list : List ! ONow = delay t in let tmp : List ! Ot = alloc List[t] // allocate in \ntmp.ctor[t](); // call constructor tmp // result of delay Within the delay scope, we can now allocate \na List object and call its constructor to satisfy the proof obligation to initialize all non-null .elds. \nThe newly allocated list is the result of the delay block. Since at that point, the delay time t arrives, \nthe type of the list can be changed to List ! ONow by renaming the bound time t to Now in the result \nof the delay block. The next section presents all the type rules and describes them in more detail. O(m)= \nsr D.m[Xt, G](y0 : D! .0 ,y1 : s1, .., yn : sn) Er O fC =D bv(G) = Xt G0 =G,y0 : C! .0 ,yi : si fwf G0 \nG0 fe e : sr,E Er .{(y, f) |(y, f) .E ..i.y = yi} .0 O fsr C.m[Xt, G](y0 : C! ,y1 : s1, .., yn : sn) \nEr {e } Figure 7. Method typing  3. Typing 3.1 Method Typing The method typing rule in Fig. 7 checks \nthe well-formedness of a method. We do not explicate how the class environment is checked, but we assume \nthat each method is checked via this rule. The rule states that in class environment O, method C.m is \nwell-typed, provided that method m s declared sig\u00adnature in class D is equivalent to the signature of \nC.m ( mod\u00adulo the receiver s class), that C inherits from D (or is D), that the timing constraint environment \nG binds all quanti.ed timing variables Xt. More .exible overriding policies are of course possible (such \nas covariant return types, contravari\u00adant argument types), but such extension are orthogonal to the problem \nstudied here. The method body must be well typed in environment G0, formed by augmenting the timing constraints \nG with bindings for the formal parameter types yi : si. Environment G0 must be well-formed according \nto the rules of Fig. 5, which guarantees that each timing variable is bound exactly once and no unbound \ntiming variables are used. Finally, the last line of the antecedent guarantees that the declared initialization \neffect Er is a subset of the initializa\u00adtion effect of the body e and that it only refers to the method \nparameters.  3.2 Expression Typing Figure 8 shows the type rules for all expressions in our language. \nThe judgments have the form G fe e : s; E, meaning that under assumptions G, expression e has type s \nand effect E. Note that the type system does not take advantage of the effect E to reason about .elds \nthat might already have been initialized. The effect E is solely used to prove that all .elds are eventually \ninitialized after allocation and prior to the delay time. We ll explain each rule in turn. Rule T-LOOKUPretrievestypingassumptionsforbindings \nfrom the environment. It has no initialization effect. Rule T-LET is also standard except that the resulting \neffect E is .ltered to not include any initializations on the bound variable y in the body e2.Rule T-SUB \nis a standard subtyping rule. Rule T-DELAY handles the introduction of a delay scope, binding future \ntime t in expression e.Time t must not occur in the environment G. Body e is then typed with the addi\u00ad \n G fwf t G fwf . G fwf . G,t=.fwf s [WF-TYPE ][WF-DELAYT ][WF-EXISTT ] . G fwf t G fwf t G fwf .(t=.).s \nG=G' ,t,.. G=G' ,t=.,.. G=G' ,t>Now [WF-NOW ][WF-ASSUME1 ][WF-NOLATER1 ][WF-DELAY1 ]G fwf Now G fwf t \nG fwf t G fwf t G fwf G' t.bv(G,G')G fwf G' G,G' fwf s [WF-EMPTY ][WF-ASSUME2 ][WF-ASSUME3 ]G fwf G fwf \nG' ,t G fwf G' ,y: s G fwf G' G,G' fwf .t.bv(G,G')G fwf G' t.bv(G,G') [WF-NOLATER2 ][WF-DELAY2 ]G fwf \nG' ,t=. G fwf G' ,t>Now Figure 5. Well-formedness bv( )= 0 bv(G,t)= bv(G),t bv(G,t=.)= bv(G),t bv(G,t>Now)= \nbv(G),t bv(G,y: s)= bv(G),y Figure 6. Bound variables tional assumption that t>Now. Finally, the resulting \ntype is the type of the body s, but with treplaced with Now,as the time tlogically arrives at the end \nof the delay scope. Rule T-ALLOC allocates a new object of class C with delay t and binds it to y in \nthe body e.Time t must strictly be in the future, as the newly allocated object does not satisfy the \ninvariants of non-null .elds. Type-checking block eyields initialization effect E, which must cover all \nthe non\u00adnull .elds of C and its base classes (nn.elds(C)). Thus, at the end of the allocation block e, \nthe newly allocated object satis.es its .eld invariants. This is suf.cient to prove that at the end of \nthe delay scope for t, all .elds of all objects with o.ValidTime = tare initialized. The conditional \nrule T-IFNULL is a standard conditional rule, except that the condition variable y is rebound in the \nelse branch to a non-null type C!, and the resulting initial\u00adization effect is the intersection of the \ninitialization effects of both branches. The type of the condition may be delayed for any time t, as \nthe conditional only examines the pointer value, not the object s .elds. Writing to a .eld is handled \nby rule T-WRITE.Given that y has type C! t1 ,and .eld f is declared in C or one of its base classes, \nthe assignment is well-typed, provided that additionally, the assigned type is compatible with the .eld \ntype and the delay t2 of the stored value is no later than the delay of the container t1. This is the \ncrucial rule maintaining the necessary invariant that all objects reachable from a reference with delay \nt have delays no later than t. The rule also establishes an initialization effect for .eld f of binding \ny. Handling .eld reads T-READ is probably the most com\u00adplicated aspect of the type system. Given the \ninvariant just mentioned, we do not actually know the delay t2 of a refer\u00adence stored in a .eld f. Furthermore, \nthe .eld type t might have to be weakened to include null, unless we can prove that the container is \nnot delayed. We thus do a case-split. The result type s of the read is t Now, if we can prove that the \ncontainer is not delayed. In this case, the .eld type is the declared .eld type and the read value is \nnot delayed. Other\u00adwise, we produce an existentially quanti.ed type, where we abstract over delay t2. \nWe only know that delay t2 is no later than the delay t1 of the containing object. We further weaken \nthe .eld type t to t?, which has the effect of removing any non-nullness. Rule T-UNPACK is a standard \nexistential elimination rule. It types the body e2 of the scope under the assumption that the existentially \nbound time t with constraint t =., while guaranteeing that tis fresh and does not escape the scope e2. \nFinally, rule T-CALL handles method calls. It types the re\u00adceiver and all arguments and forms the substitution \n. that maps formal time parameters Xtto actual times .X. The judg\u00adment G f. G' ensures that the assumptions \nG imply the as\u00adsumptions G' under the substitution .. The rules for implica\u00adtion are shown in Fig. 9. \nIf all actual argument types match the formal argument types under substitution ., the call is well-typed \nand results in effects Er, where we substitute the ' actual bindings yi for the formals yi.  4. Correctness \nThis section argues the correctness of our approach. Con\u00adsider the delay scopes active at runtime. These \nscopes parti\u00ad G fe e : s; E G fe y : C t; \u00d8G fe e1 : s; E1 G,y: C! t fe e2 : s; E2 G=G' ,y: s, .. [T-LOOKUP] \nE = E1 nE2 [T-IFNULL ] G fe y : s; \u00d8 G fe ifnull y then e1 else e2 : s; E G fe e : s1; Et .bv(G) G f= \ns1 =s2 G,t>Now fe e : s; E [T-SUB] [T-DELAY ] G fe e : s2; E G fe delay t in e : s[Now/t]; E G ft t> \nNow G fe e1 : s1; E1 G,y: C! t fe e : s; E1 G fe e2 : s2; E2 .f .nn.elds(C).(y, f) .E1 E = E1 .E2 [T-SEQ \n] E = E1 \\{(y, )} [T-ALLOC ] G fe e1; e2 : s2; E G fe let y = alloc C[t] in e : s; E G fe y : C! t1 \n; \u00d8 G fe e : t t2 ; E1 O(f)= C.f : t G fe e : C! t1 ; E O(f)= C.f : t G ft t2 =t1 E = E1 .{(y, f)}G fe \ny.f := e : void; E [T-WRITE ] s = . t Now if G ft t1 =Now .(t2=t1).t? t2 otherwise G fe e.f : s; E [T-READ \n] where (C!)? = C and C?= C. G fe e1 : .(t =.).s1; E1 t .bv(G) t .fv(s2) G fe e1 : s1; E1 G,t=., y: \ns1 fe e2 : s2; E2 G,y : s1 fe e2 : s2; E2 E = E1 .(E2 \\{(y, )}) [T-UNPACK ] E = E1 .(E2 \\{(y, )}) [T-LET \n] G fe unpack t, y = e1 in e2 : s2; E G fe let y = e1 in e2 : s2; E G fe yi : si; \u00d8i =0..n '' ' O(m)= \nsr D.m[Xt, G'](y0 : .0' ,y1 : s1' , .., y : s ' ) E nn s ' = D! 0 . =[Xt] . G'. ' ./XG f 0 G f= si =.(s \n') i =0..n i[T-CALL]G fe y0.m[.X](y1, .., yn): .(sr); E[yi/y '] i Figure 8. Typing Rules G f. [IMP-EMPTY \n] G fwf .(t) G f. G' G f. G' ,t [IMP-BIND ] G ft .(t) =.(.) G f. G' G f. G' ,t=. [IMP-NOLATER ] G ft \n.(t) > Now G f. G' G f. G' ,t>Now [IMP-DELAY ] Figure 9. Constraint Implication tion the heap objects \ninto disjoint time regions, one per delay region Now and the delay time tn becomes equivalent with scope, \nplus the non-delayed region Now, as depicted in Fig-Now. ure 10. Each object o belongs to the region \ndesignated by Objects can refer to other objects within the same time re\u00ado.ValidTime. When an object \nis allocated with, say, delay tn, gion, or can refer to objects in regions with an earlier delay it enters \nthe region associated with that delay time. When the time (upward in the .gure). Delay times are ordered \naccord\u00addelay scope tn ends, the region is joined to the non-delayed ing to the delay scopes entered at \nruntime. The delay scopes form a stack, where the last scope entered will be exited prior Now Invariants \nhold tn Delayed t1 t0 Figure 10. Time regions and their relation to all scopes below it. In the picture, \ndelay scope t0 is the out\u00adermost delay scope, and tn is the currently innermost scope. As execution progresses, \neither new nested scopes are added between tn and Now,or tn is exited, merging tn s region to the Now \nregion of non-delayed objects. The following invariant captures the reference pattern described in Figure \n10. INVARIANT 4.1. Objects only point to other objects with same or smaller delays .o.o p =.p.ValidTime \n=o.ValidTime where op means that object p is reachable from o through 0 or more .eld references. The \nnext invariant captures the fact that delayed objects need not satisfy their .eld invariants yet. INVARIANT \n4.2. Non-delayed objects satisfy their .eld in\u00advariants. .o.(o.ValidTime .Now)=..(f .nn.elds(o)).o.f \n= null We now argue how these invariants are maintained. First, consider invariant 4.1. Only three operations \nin the language in.uence this formula: allocation, delay, and .eld assign\u00adment. Allocating a new object \nadds a new element to the quanti.cation. The property holds trivially for the new ob\u00adject, as it does \nnot reference, nor is it referenced by any other object. Exiting a delay scope joins the time of the \nregion on the top of the stack (tn)to Now. This can be viewed as changing ValidTime of each object in \ntn to Now. Consider each reference from an object in tn. The target of such a ref\u00aderence can only be \nin Now or in tn itself. After the change, these refer from objects in Now to objects in Now,which is \nadmissible. Consider a reference targeting an object in tn. After the change, this reference targets \nan object in region Now. Such references are allowed from all regions, thus all such references are still \nvalid after the change. Finally, updating a .eld requires proving that the delay of the stored value \nis less-than or equal to the delay time of the container. Type rule T-WRITE enforces this. Of course, \nwe must also show that the delayed types conservatively approximate the actual ValidTime of the typed \nobject. At allocation, this is obviously the case. Inspecting the type rules shows that the delay in \nthe type of a value can only be changed by storing the value into a .eld and reading it back. Storing \na value with delay t1 into a .eld of an object with delay t2 amounts to existential abstraction (forgetting \nthe exact time) of t1. This is visible in .eld reads, where the delay time of the read object is simply \nsome time t =t2. Now consider invariant 4.2. This formula is affected by the same three operations: allocation, \ndelay, and .eld update. Allocation adds a new element to the domain of the quanti.\u00adcation. Because allocation \nrequires a delay time t> Now, strictly later than Now, we guarantee that the implication is trivially \nsatis.ed. When ending a delay scope, all objects in tn now need to satisfy the right-hand side of the \nimplication. Fortunately, the allocation rule checks that all .elds are writ\u00adten within the scope of \nthe allocation (and thus within the scope binding the delay time). This, together with the check in type \nrule T-WRITE guaranteeing that if the .eld type is non-null, the written value is also non-null, guarantees \nthat all non-null declared .elds are indeed non-null by the end of the delay scope. The .eld update type \nrule does not permit writing null into a .eld that is declared non-null. Thus, once a non-null typed \n.eld is non-null, it can never revert back to null. To guarantee that t> Now implies t .Now,wemust be \ncareful that the constraint t> Now cannot survive the delay scope binding t.Rule T-DELAY enforces that \nt is not free in the environment or the result and our existential types cannot capture t> Now constraints. \nFinally, it remains to verify that non-null types correctly approximate the non-nullness of the typed \nvalues. Non-null types are introduced only by the allocation rule (we assume allocation always succeeds). \nInspecting subtyping and the type rules shows that no other means of obtaining a non\u00adnull type exist \nexcept reading a .eld with a non-null type declaration. Rule T-READ yields only a non-null type given \nthat the container is not-delayed. Otherwise, the result is of possibly null type, mirroring invariant \n4.2. 4.1 Multithreading discussion It is noteworthy that the delayed approach extends naturally to a \nmulti-threaded setting. One simply has to ensure that delayed objects are never shared. This is natural \nand simple to enforce: 1) delayed objects can never be stored in global locations accessible by multiple \nthreads. 2) delayed objects cannot be stored in .elds of already shared objects (already enforced by \n.eld update rule), as the shared object cannot be delayed, and 3) starting a new thread requires all \nparameters to the thread to be non-delayed objects.  5. Spec# Implementation We have implemented the \nidea of delayed types in Spec#, an experimental extension of C# with non-null types, pre\u00adconditions, \npost-conditions, and invariants [1]. The next sub\u00adsections .rst describe the existing mechanism in Spec# \nto deal with non-null types on .elds, then sketch how we add the idea of delayed types. We show how Spec#-level \ncon\u00adstructs map to the formalization of the previous sections and how the proof obligations are discharged \nat the high-level. We also discuss how to handle features of the language not described in the calculus. \n5.1 Prior approach to non-null typed .elds Prior to the introduction of delayed types, Spec# used the \nfollowing approach to guarantee proper initialization and avoiding exposure of non-initialized objects \nduring con\u00adstruction: constructors of objects with non-null typed .elds must initialize all such .elds \nprior to the base constructor call, and the only allowed operation on the object under construction prior \nto the base constructor call is to write its .elds. This simple approach guarantees that in each con\u00adstructor, \nafter the base constructor call, all non-null typed .elds of the object are non-null, thereby avoiding \nthe need for raw types. The drawbacks of this approach are as follows: 1) new syntax is needed in the \nconstructor to enable initialization of .elds as a function of constructor arguments prior to the base \nconstructor call. In C++ e.g., special syntax exists to initial\u00adize .elds. In Spec#, we opted to make \nthe base constructor call explicit in the body of constructors as base (...) . The lan\u00adguage requires \nthat there is a base constructor call on each path through the constructor. 2) as a result, every constructor \nof a class with non-null typed .elds must have an explicit base constructor calls in its body. This can \nbe a nuisance when porting existing code from C# and changing some .eld types to non-null, as it most \noften requires putting a base constructor call at the end of the method. Sometimes, initial\u00adization of \n.elds in constructors is interspersed with calls on the object under construction, and in order to place \nthe base constructor call, further reordering of the code is needed. 3) circular initialization patterns \nas in our example in the intro\u00adduction, cannot be dealt with at all. With the introduction of delayed \ntypes, most constructors ported from C# can remain unchanged, even after changing some .eld types to \nnon-null types, as the initialization of these .elds may now occur after the base constructor call. Furthermore, \nif there are methods called on the object under construction, it is often possible to mark those methods \nas taking a delayed receiver, without the need to rearrange the constructor code. 5.2 Delayed Types \nIn Spec#, we use an attribute [Delayed] instead of the low\u00adlevel types of the formalization. The attribute \ncan only ap\u00adpear in method signatures on parameters, method results, and the method itself. In the last \ncase, it applies to the method s receiver (this). We interpret these attributes as fol\u00adlows: We implicitly \nquantify each method over a single time variable t. All types in the method signature attributed with \n[Delayed] are delayed by t. All non-attributed types are not delayed (Now). We found that being able \nto mention a sin\u00adgle delay time seems suf.cient in most examples. Using our attribute syntax, we avoid \never naming a time explicitly. 5.3 Constructors Constructors are special in that the implicit this parameter \nis by default delayed with the implicit time parameter t. Furthermore, we assume that constructors have \nan implicit effect clause that speci.es the initialization of all non-null .elds (including those of \nbase classes). This, together with base calls and the type rules in Sect. 3 guarantees that all non-null \n.elds are initialized by the time the constructor returns. Finally, in constructors, the implicitly quanti.ed \ntime variable thas bound t> Now, whereas in ordinary meth\u00adods it is unconstrained. For backward compatibility \nwith Spec# s prior initializa\u00adtion scheme, we support the annotation [NotDelayed] on con\u00adstructors. This \nannotation speci.es that the receiver is not to be treated as delayed, but that all non-null .elds have \nto be initialized prior to the base constructor call as dis\u00adcussed above. Thus, programmers have a choice \nwhether to treat constructors as delayed or not delayed, resulting in one of two initialization schemes. \nNon-delayed constructors are most useful when the object under construction is used for signi.cant computation \nafter initialization prior to returning from the constructor. 5.4 Allocation Each allocation in the \nhigh-level language new C(...) is modeled in the calculus as delay t in let tmp = alloc C[t] in tmp.ctor[t \n](...); tmp Together with the default initialization effect of constructors, this translation guarantees \nthat the type rule for alloc is always satis.ed. To allocate at an existing delay, the high-level construct \nnew C[Delayed ](...) is used. It translates to let tmp = alloc C[t] in tmp.ctor[t ](...); tmp where tis \nthe implicit time parameter of the current method. As only constructors make the assumption that t>Now,this \nconstruct is only supported in constructors. We can reason how the high-level language and its rules \nguarantee the necessary invariants at the low-level. Each constructor is checked to initialize all its \nnon-null .elds. Together with the forced call to the base construc\u00adtor, this is suf.cient to establish \nthe implicitly speci.ed effect of constructors (which is that all non-null typed .elds of the this object \nare non-null).  The rule for .eld assignment guarantees the reachability invariant (4.1).  Finally, \nthe proof obligation at the end of an alloca\u00adtion block is satis.ed by construction of the translation \nsketched above, as each alloc block contains a construc\u00adtor call on the newly allocated object.  5.5 \nExistential Types We do not want to deal with existentials at the Spec# lan\u00adguage level. Observe that \nexistentials only arise when read\u00ading from a delayed reference. Existentially quanti.ed types simply \nstand for references with unknown delay. We can wrap each access to such references within implicit unpack \nexpressions and weaken the type by forgetting the constraint on the existentially bound variable. This \nweakening results in some loss of expressiveness, but in practice, it has not been a problem. It precludes \nfor example reading a refer\u00adence from a delayed object, and then storing it back into the same object. \n 5.6 Exceptions Exceptions complicate the checking of the initialization ef\u00adfects in allocation blocks. \nWhen an exception escapes an al\u00adlocation block, the .elds of the newly allocated object with delay time \nt, might not yet be properly initialized. Yet, the al\u00adlocated object can escape the block by virtue of \nhaving been assigned to another delayed object allocated earlier. If the exception is handled within \nthe delay scope for t, then the object might escape the delay without proper initialization. We can prevent \nthis scenario by disallowing handling of ex\u00adceptions in constructors. This way, it is guaranteed that \nan exception raised in an allocation scope unwinds all current delay scopes. 5.7 Generics Generics in \nC# or Java provide universal quanti.cation over types. This quanti.cation has to be done independently \nof the quanti.cation over delay time. Quanti.cation over a type cannot include its delay. Expressed in \nour formalism, type quanti.cation would range over t, not over s.Thus,a method might have a formal parameter \nwith type T ,where T is a type parameter, yet the delay of the parameter type is speci.ed independently. \n 5.8 Delegates Delegates in C# are method closures capturing an object and a method to call on that object. \nThe constructor of delegates takes the captured object as a parameter (along with the method pointer). \nWe found that often delegates were constructed by capturing a delayed object. To support this scenario, \nthe delegate constructor signature could be given delayed types for the parameter and the receiver. However, \nbecause we only support one quanti.ed time variable, such a signature makes the constructor unusable \nto capture a non-delayed object. Using a separate delay time t1 for this and another t2 =t1 for the captured \nobject makes such constructors applicable in all contexts. This problem arises mainly because the delegate \ncon\u00adstructors are generated automatically. In programmer written constructors, one can work around this \nlimitation by provid\u00ading two separate constructors. 5.9 Initialization Helper Methods Our current implementation \nrequires that all non-null typed .elds are initialized in constructors themselves. The calculus is more \nexpressive in that it allows initialization to be done in helper methods called from constructors, if \nthe helpers have the appropriate initialization effect speci.cations. We plan to add such speci.cations \nto Spec# in the future.  6. Experience After implementing support for delayed types in Spec#, we adapted \ntwo substantial code bases to the new initialization scheme: Boogie, the veri.er of Spec# and a large \nfraction of the Singularity research operating system. Boogie is about 50000 lines and 418 classes, the \nrelevant Singularity code base is about 150,000 lines with 2003 classes, both including comments and \nwhite-space. Table 1 contains usage counts related to non-null and delayed types that illuminate the \napplicability of the proposed approach. More than half the classes in Boogie and about a third of the \nclasses in Singularity use some non-null .eld invariants. For these classes, over 91% of constructors \nin Boogie and over 95% in Singularity can be typed as delayed, meaning they do not need any special initialization \nsyntax for the .elds, or explicit placement of a base constructor call. Maybe surprisingly, for classes \nwithout non-null typed .elds, there are also some uses of non-delayed constructors. These arise due to \ninheritance and calls to non-delayed base constructors. As we hoped, the number explicit uses of [Delayed] \nan\u00adnotations is small in both code bases, even though the num\u00adber of implicit delayed receivers for delayed \nconstructors is 445 in Boogie and 1617 in Singularity. Our defaults for con\u00adstructors thus work out well. \nWe break down the explicit use of delayed into three categories: 1) We found 24 methods that are called \nfrom constructors, passing the object under construction as a parameter. These are often helper methods \nsuch as assertion methods, or property getters. 2) We found 16 uses of delayed parameters due to actual \ncircular initial\u00adizations. In Boogie there is one such use, in Singularity 15  Table 1. Usage of delayed \ntypes such uses. The simplest use is that of a parent object con\u00adstructing a helper object that contains \na back pointer to the parent, similar to our example. The most complicated form are several doubly linked \nlist implementations. 3) Finally, we found 5 explicit uses of delayed allocations (all other de\u00adlayed \nallocations are inferred). For Boogie, we further studied the impact of delayed constructors on the use \nof explicit base constructor calls base (...) in constructor bodies, which was required in the prior \nscheme to allow initialization of the non-null typed .elds prior to the base constructor call. Of the \n169 uses of such explicit base (...) calls in constructor bodies prior to delayed type use, all but 37 \nwhere eliminated. We classi.ed the remaining 37 uses into 4 categories: 1) we found 10 uses of non-trivial \ncomputations performed in the constructor or in methods called from the constructor after initialization \nis complete. 2) in 19 cases, the explicit base call was used be\u00adcause the base constructor was not delayed \nand the deriv\u00ading class had non-null .eld initializations. 3) in 4 cases, we found that programmers used \nthe more expressive power of explicit base calls in the body to compute data prior to the base call that \nwas used both as an argument to the base call, as well as in the constructor itself. 4) .nally, four \nuses were due to special constant .elds used in the Boogie methodol\u00adogy itself. Overall, the conversion \nwas painless, due to good de\u00adfaults.  7. Extensions 7.1 Arrays We are working on extending the delay \napproach to handle arrays of non-null element types. For arrays, the elements of the array have to be \ntreated like .elds of an object. The main difference between array and object construction is that there \nis no well-delimited construction method for arrays, and the number of elements is not constant. One \nsimple approach is to require an explicit runtime check via a pre-de.ned method that guarantees the initialization \nof all elements to non-null values. The approach described in this paper is then adapted to merely ascertain \nthat this runtime check is present on each path from an array allocation to the end of its delay scope. \n 7.2 Generalization So far we have shown how to reason about invariants in\u00advolving non-null .elds. Our \napproach can be generalized to reason about more complicated invariants. In particular, the type system \ncan directly support heap-monotonic pred\u00adicates [5], i.e., properties, that once established, are never \nviolated in future heaps. 7.3 Other Applications The techniques sketched here can also be applied to \nfunc\u00adtional programming languages, such as OCaml in order to generalize the allowable expressions on \nthe right-hand-side of recursive bindings. The language would have to provide a form of constructor functions \nfor tuples and datatype val\u00adues that assign to the .elds of the value under construction. Besides the \nautomatically generated ones such as initACons, such constructor functions could then also be programmer \nwritten. Reading from delayed values would have to be re\u00adstricted to matching of the datatype tag only \nno access to the arguments of datatypes or tuples would be allowed as there is no suitable null value. \n 7.4 Phased Initialization One recurring problem in dealing with object invariants is that often, objects \nand entire object graphs are initialized in several phases. Only after the last phase are all invariants \nestablished. Consider for example a parser that builds ASTs bottom-up. It is possible that the programmer \nwould like each node to point to its parent node (except for the root obviously). The parent pointers \nhave to be established as a second phase. Our technique so far cannot yet deal with this problem. However, \nwe think it is a step in the right direction. Observe that objects allocated with delay tn can only escape \nthe delay scope for tn by being reachable from the result of the delay scope expression. Thus, we have \na guarantee that these objects are not reachable from anywhere else. One can exploit this observation \nby associating a new obligation with the result of a delay scope and instead of renaming tn to Now, renaming \nit to tn-1. Such a renaming also preserves our reachability invariants. The additional complication is \nthat the new obligation must cover all objects with delay tn, not just the top-level one. Given this \nidea, it is possible to associate new obligations to an object (graph) whenever it escapes from a delay \nscope. We plan to explore this idea further.  8. Related Work The problem of properly initializing data \nstructures has been studied in the context of compiling typed high-level lan\u00adguages to typed assembly \nlanguage. At some point dur\u00ading the translation, memory allocation and initialization be\u00adcomes explicit \nand the initialization steps must be captured by the type system. For this purpose, Morrisett et. al. \ndevel\u00adoped an alias type system where the types of memory loca\u00adtions can change as these locations are \nupdated [10, 13]. Alias types can be used to solve the initialization problem as long as detailed post \nconditions are provided. In particu\u00adlar, for our doubly linked-list example, the alias type solution \nwould include specifying the exact pointer relations estab\u00adlished by the Node constructor. Furthermore, \nthe alias type approach would force the programmer to be explicit about aliasing (resp. non-aliasing). \nThe same comments would ap\u00adply if we were to use Hoare style reasoning with separation logic. Our approach \nusing delayed types differs from the above in that we do not have to reason about aliasing and we only \nrequire very abstract speci.cations about how .elds are initialized. This makes the approach amenable \nfor inclusion in a mainstream language with good defaults as described in the previous section. Our work \ndoes not need to address the problem of proving the well-foundedness of recursive de.nitions [9, 3], \nas our circular structures always involve heap objects. Similarly, we do not try to address the issue \nof how to de.ne mutually referential structures in the presence of abstract creation functions [11]. \nThere are similarities of our work with the region type system of Tofte and Talpin [12]. A delay time \nt acts simi\u00adlarly to a region. A distinguishing aspect, however, is that at the end of a delay scope, \na time region is not deleted, but joined with the Now region. The reachability invariant of ref\u00aderences \nin our delay scopes seems super.cially similar to the outlives relation of regions in the safe-C dialect \nCyclone [6]. Interestingly, their pointer relation is inverse to ours, as ref\u00aderences can point from \nnewly allocated regions to objects in older regions, but not vice-versa. Non-null types are now being \nconsidered for a number of languages besides Spec#, e.g., for JML-based Java [2]. These languages have \nto deal with the problem of observing non-null .eld invariants prior to their establishment. Raw types \nfrom our prior work [4] provide one solution. The present work improves substantially over that by providing \nthe same guarantees, while supporting vastly more expres\u00adsive initialization patterns, including circular \nstructures. We thus advocate the use of delayed types in these language ef\u00adforts over the inclusion of \nraw types. 9. Conclusions We described a new approach to the initialization problem in OO-languages \nequipped with non-null types. The main idea is to include in the type system a notion of future time \nat which objects under construction become valid. References to objects under construction are typed \nwith delayed types t t, capturing that the object s .eld invariants may not hold prior to time t. This \nformalization allows a .exible .eld up\u00addate rule that can store pointers with delayed types into .elds \nof other delayed objects, as long as the containing object s delay is longer than the delay of the .eld \nvalue. Furthermore, there is no need to cater for this situation in the declared type of .elds. The resulting \ntype system is powerful enough to successfully type check cyclic initializations. We have im\u00adplemented \nthese ideas in the Spec# compiler. Our experi\u00adence shows that with delayed types, a language supporting \nnon-null typed .elds can mostly avoid requiring .eld initial\u00adizations prior to the base-constructor call. \nThis is important for porting existing code in C# to Spec#, and similarly for porting Java code into \nJML [7]. In the latter case, the fact that constructor semantics do not need to change is of spe\u00adcial \nimportance, since the JML speci.cations live in source code comments and do not in.uence the code generation, \nwhich is performed by a normal Java compiler.  References [1] Mike Barnett, K. Rustan M. Leino, and \nWolfram Schulte. The Spec# Programming System: an Overview. In Proceedings of the Workshop on Construction \nand Analysis of Safe, Secure and Interoperable Smart devices, volume 3362 of LNCS, 2004. [2] P. Chalin \nand P. James. Non-null References by Default in Java: Alleviating the Nullity Annotation Burden. In Proceedings \nof the 21st European Conference on Object-Oriented Programming, 2007. [3] Derek Dreyer, Robert Harper, \nand Karl Crary. A Type System for Well-Founded Recursion. In Proceedings of the 31st Annual ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, 2004. [4] Manuel F\u00a8ahndrich and K. Rustan M. Leino. \nDeclaring and Checking Non-Null Types in an Object-Oriented Language. In Proceedings of the 2003 ACM \nConference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA 2003, pages 302 \n312. ACM, November 2003. [5] Manuel F\u00a8ahndrich and K. Rustan M. Leino. Heap Monotonic Typestate. In Proceedings \nof the .rst International Workshop on Alias Con.nement and Ownership (IWACO), July 2003. [6] Dan Grossman, \nGreg Morrisett, Trevor Jim, Michael Hicks, Yanling Wang, and James Cheney. Region-based Memory Management \nin Cyclone. In Proceedings of the 2002 ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI), pages 282 293. May 2002. [7] Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation \nfor detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, Behavioral Speci.cations \nof Businesses and Systems, pages 175 188. Kluwer Academic Publishers, 1999. [8] The OCaml Programming \nLanguage. http://caml.inria.fr. [9] Claudio Russo. Recursive Structures for Standard ML. In Proceedings \nof the 2001 International Conference on Functional Programming, pages 50 61, 2001. [10] Frederick Smith, \nDavid Walker, and Greg Morrisett. Alias types. In Proceedings of the 14th European Symposium on Programming, \nvolume 1782 of LNCS, pages 366 381. Springer, March 2000. [11] Don Syme. An Alternative Approach to Initializing \nMutually Referential Objects. Technical Report MSR-TR-2005-31, Microsoft Research, March 2005. [12] Mads \nTofte and Jean-Pierre Talpin. Implementation of the Typed Call-by-Value lambda-Calculus using a Stack \nof Regions. In Proceedings of the 1994 Symposium on Principles of Programming Languages, pages 188 201, \n1994. [13] David Walker and Greg Morrisett. Alias types for recursive data structures. In Proceedings \nof the 4th Workshop on Types in Compilation, September 2000. \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Mainstream object-oriented languages such as C# and Java provide an initialization model for objects that does not guarantee programmer controlled initialization of fields. Instead, all fields are initialized to default values (0 for scalars and <b>null</b> for non-scalars) on allocation. This is in stark contrast to functional languages, where all parts of an allocation are initialized to programmer-provided values. These choices have a direct impact on two main issues: 1) the prevalence of <b>null</b> in object oriented languages (and its general absence in functional languages), and 2) the ability to initialize circular data structures. This paper explores connections between these differing approaches and proposes a fresh look at initialization. Delayed types are introduced to express and formalize prevalent initialization patterns in object-oriented languages.</p>", "authors": [{"name": "Manuel Fahndrich", "author_profile_id": "81100288438", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "P348268", "email_address": "", "orcid_id": ""}, {"name": "Songtao Xia", "author_profile_id": "81539268756", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP39115969", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297052", "year": "2007", "article_id": "1297052", "conference": "OOPSLA", "title": "Establishing object invariants with delayed types", "url": "http://dl.acm.org/citation.cfm?id=1297052"}