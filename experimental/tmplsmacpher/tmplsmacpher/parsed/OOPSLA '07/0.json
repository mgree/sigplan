{"article_publication_date": "10-21-2007", "fulltext": "\n TheJastAdd ExtensibleJava Compiler Torbj\u00a8orn Ekman ProgrammingTools Group University of Oxford, UK \ntorbjorn@comlab.ox.ac.uk Abstract The JastAdd Extensible Java Compiler is a high quality Java compiler \nthatis easytoextendin ordertobuild static analy\u00adsis toolsforJava,andtoextendJavawithnew language con\u00adstructs.Itisbuilt \nmodularly, withaJava 1.4 compiler thatis extendedtoaJava5compiler. Example applications that are built \nas extensions include an alternative backend that gen\u00aderates Jimple, an extension of Java with AspectJ \nconstructs, and the implementation of a pluggable type system for non\u00adnull checking and inference. The \nsystem is implemented using JastAdd, a declarative Java-like language. We describe the compiler architecture, \nthe major design ideas forbuilding andextending the com\u00adpiler, in particular, for dealing with complex \nextensions that affect name and type analysis. Ourextensible compiler com\u00adparesveryfavorably concerning \nquality, speed and size with otherextensibleJava compiler frameworks.It also compares favorably in quality \nand size compared with traditional non\u00adextensibleJava compilers,andit runs withinafactorof three compared \ntojavac. Categories and Subject Descriptors D.3.4[Programming Languages]: Processors General Terms Design, \nLanguages Keywords OOP, Compilers, Extensibility, Declarative Fra\u00admeworks, Modularity, Java 1. Introduction \nThis paper presents the JastAdd Extensible Java Compiler, JastAddJ. It is built using the metacompiler \ntool JastAdd which provides advanced support for constructing modular andextensible compilers [HM03, \nEkm06]. When using Jast-AddJ as is, it works in the same way as a normal Java com\u00adpiler, generating class \n.les from source code. What is new Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr \u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; \n2007ACM 978-1-59593-786-5/07/0010...$5.00 G\u00a8 orel Hedin Department of Computer Science Lund University, \nSweden gorel@cs.lth.se about JastAddJ is the way it can easily be extended with language constructs \nas well as with static analyses. As an example of language extension, JastAddJ itselfisbuilt asa basepart \nsupportingJava1.4,andanextensionthataddsthe new features in Java 5: enums, the enhanced for statement, \nautoboxing, varargs, static imports, and generics with wild\u00adcards.Asanexampleof static analysis, modulesfor \nnon-null type checking and type inference have been implemented as extension modules to JastAddJ[EH07]. \nBothof theseexam\u00adples illustrate highly non-trivial extensions. Thekeyto theextensibilityof JastAddJis \nthe declarative foundation of the underlying system JastAdd, which is based on object-orientation, inter-type \ndeclarations [KHH+01], declarative rewrites [EH04], and attribute grammars, includ\u00ading support for reference \nattributes [Hed00], nonterminal attributes [VSK89] and circular attributes [MH03]. These declarative \nfeaturesallowextensionstobebuilt withoutin\u00adteracting unduly with each other, and thereby making them \neasy to combine. Writing a compiler for a complex language such as Java is notoriously hard and there \nare numerous subtle details that all need to be handled correctly to support the full language. In contrast \nto the other extensible Java compilers that we know of, JastAddJ is highly compliant with the language \nspeci.cation, actually passing a slightly higher number of tests in the Jacks test suite [jac07a] than \npopular compilers like javac and the Eclipse compiler. To be of practical use, an extensible compiler \nneeds to be ableto handlelarge programsand alsotobe reasonablyfast. JastAddJcan handle large programs, \nmore than 100K LOCs, and it runs well within a factor of three as compared to javac. This is reasonablyfast \nconsidering the main applica\u00adtion area:todoexperimentsin language design,toaddplug\u00adgabletype systems \n[Bra04],andtobuild specialized analysis or transformation tools. JastAddJis open source [jas07] and we \nhave used it extensively in our own research projects. Therestofthispaperis structuredasfollows.In section2 \nwe discuss the main architecture of JastAddJ, the modules it consists of, and examples of how these modules \nhave been reused and combined with extension modules in different projects. Section3discussesthemajordesignideaswehave \ndeveloped inbuilding JastAddJ. Sections 4-7 discusskeyas\u00adpects of compilation and how they are handled \nin JastAddJ to support extensibility: name analysis, type analysis, and de.nite assignment. Section8evaluates \nJastAddJ,providing performance measures, etc., and comparing to other com\u00adpilers or similar tools (both \nextensible and non-extensible). Finally, section9discusses relatedwork and section10 con\u00adcludes the paper. \n2. Architecture 2.1 Main components JastAddJconsistsof four main components:a Java 1.4 fron\u00adtend and \nbackend, and a Java5frontendand backend. Each component is represented as a directory of reusable source \n.les (JastAdd .les and parser generator input .les), a main program (in Java), and a build .le. The backends \nare ex\u00adtensions of the frontends: they reuse source .les from the frontend components. Similarly, the \nJava5components are extensions of the Java 1.4 components,de.ning only what is neededtoextend theJava \n1.4implementationtoJava5.New extended languages, analyzers or backends canbebuiltby de.ning components \nthat similarlyextendtheexisting Jast-AddJ components. The main programs in the frontends are error checking \nprettyprinters: they parse Java source .les, read dependent class .les, print compile-time error messages \nand print nor\u00admalized versions of the .les. These tools serve as examples forhowtobuild source-to-source \ntranslating toolsand anal\u00adysis tools such as pluggable type checkers. The main pro\u00adgrams in the backends \nare normal Java compilers that parse Java .les, print compile-time error messages and produce class .les. \nFigure 1 shows the main components in JastAddJ. The numbers represent the total number of lines of source \ncode (LOC) in the component measured using using SLOCCount [Whe07]. Figure 1. Main components of JastAddJ \n 2.2 Example extensions We have made several different extensions toJastAddJ. One example is a pluggable \ntype system for checking and infer\u00adring non-null annotations [EH07]. The main implementation ofthe non-null \ncheckerisbuiltasanextensiontotheJava 1.4 frontend. It can be run as a pure checker (without com\u00adpiling \nto bytecode) or as an extended compiler, combining it with the Java 1.4 backend. The extension can furthermore \nbe combined with theJava5frontend and backend. Onlya few attributes need to be re.ned when combining \nthe non\u00adnull type system extension with the generic type system ex\u00adtension. Figure2depicts the different \ncomponents and how they extend each other. Figure 2. Apluggable non-null checker forJastAddJ We are \ncurrently collaborating with the AspectBench compiler team in implementing an AspectJ frontend as an \nextension to the Java 1.4 frontend. As part of that work we havealso implementeda backend that generates \nJimple code for the Soot bytecode manipulation framework [VRHS+99]. These two components are replacing \nthe polyglot-based frontend of the abc AspectJ compiler [ACH+06] by Jast-AddJ. Advice weaving is performed \non the Jimple represen\u00adtation while inter-type declarations are woven in the Jast\u00adAddJ-based frontend \nfor AspectJ.Amajor bene.t from this change is the automatic scheduling of attribute computa\u00adtions rather \nthan relying on manual scheduling of more than 45 different passes in the polyglot-based frontend. Otherextensions \ninclude an alternative backend forPal-VM, a Smalltalk-based virtual machine intended for low memory pervasive \nsystems, developed in the EU integrated projectPalCom[Pal07];aJavatoCcompilerfor hard real\u00adtime systems \n[Nil06], and a system for automatic hardware compilation for Java [And05]. 2.3 Generation architecture \nAJastAddJ component is speci.ed by four principal parts: an abstract grammar de.ning the structure of \nabstract syn\u00adtax trees (AST), behavior speci.cations de.ning the behav\u00adior of the AST, a context-free \ngrammar, de.ning how text is parsed into ASTs, and a main program that reads the in\u00adput .le, runs the \nparser tobuild the AST, and uses the AST behavior to generate output. The abstract grammar and the behavior \nare speci.ed us\u00ading the JastAdd language. The JastAdd tool takes these spec\u00adi.cations and generates an \nobject-oriented class hierarchyin Java for the AST. For parsing, a traditional parser genera\u00adtor is used \nwhich also generates Java code. A component can reuse other components by simply including their ab\u00adstract \ngrammars, behavior, and context-free grammars into the generation process. Figure 3 illustrates this \ngeneration architecture. The generated Java code is placed in two local packages: AST and parser. Figure \n3. Generation architecture  2.4 Modularization The abstract and context-free grammars can be modularized \nin a rather simple way, drawing on their similarity to object\u00adoriented class hierarchies that can be \nextended with new subclasses.The realkey totheextensibilityof JastAddJ is the way the behavior can be \nspeci.ed in a declarative way, using the constructs in JastAdd. The modularextensionofJava 1.4 intoJava5isavery \nchallenging case. In particular, genericsin Java5crosscuts aspects of compilation like name and type \nanalysis in an intricate way. Due to the declarativeness of JastAdd, these aspects can be described as \nseparate modules. Because of the declarativeness, speci.cation order is ir\u00adrelevant, and the reason for \ngrouping a set of attributes and equations togetherintoa moduleisto promote reuseandun\u00adderstandability. \nJastAddJ is decomposed at twolevels. At the coarse-grained component level, the decomposition is done \nbased on what large components (directories) that are ex\u00adpected to be reused, e.g., a Java 1.4 frontend. \nAt the .ner\u00adgrained module level, a component is decomposed into indi\u00advidual modules (.les), each consisting \nof a set of attributes, equations, etc. This decomposition is based primarily on un\u00adderstandability. \nFigure 4 shows the decomposition of the Java 1.4 and Java 5 frontend components into modules, and illustrates \nhow different criteria can be used for the modularization. The Java 1.4 frontend is decomposed according \nto the dif\u00adferent kinds of analyses performed in the compiler, such as name analysis, type analysis, \nde.nite assignment, etc. This decomposition is largely based on the structure of the Java language speci.cation \n(JLS) [GJSB00].Forexample, name analysis is described in section 6 in the JLS. The Java 5 frontend is \ninstead decomposed according to the new lan\u00adguage constructs: the enhanced-for statement, autoboxing, \netc. The module for enhanced-for describes how all the anal\u00adyses (name analysis, type analysis, etc.) \nare extended in or\u00adder to handle the enhanced-for construct. Because of the declarative speci.cation, \nmanyother decompositions would have been possible as well. Java 1.4 frontend LOC Java 5extension LOC \nAbstract grammar 261 47 Behavior Name analysis Type analysis De.nite assignment Exception handling Constant \nexpressions Anonymous classes Class .les Unreachable statements Prettyprinter Misc 2481 1387 1054 208 \n467 124 475 127 788 659 Behavior Enhanced for Autoboxing Static imports Generics Varargs Enums Annotations \n65 197 110 2394 141 339 369 Bytecode reader 1157 689 Context-free grammar 1053 538 Main program 111 20 \ntotal 10 352 4909 Figure 4. Modulesin theJava 1.4 and5frontends 3. Design principles The JastAdd system \nallows the behavior of compilers to be speci.ed declaratively,using equations and other declarative constructs. \nWhile declarative, these constructs can easily be understood in terms of normal object-oriented programming, \nandthe resultofa JastAdd speci.cationisan object-oriented frameworkthatcanbe eitherusedasis,bynormalJavacode, \norit canbe furtherextended using JastAdd constructs.In this section we will discuss these design ideas \nand how theyhave been applied in JastAddJ. 3.1 The attributed AST Aprogram is represented inside the \ncompiler as an abstract syntax tree (AST). The tree nodes are objects of AST classes that are generated \nfrom the abstract grammar which de.nes both a class hierarchy and a composition hierarchy. For example, \nWhile is de.ned as a subclass of Statement, and as having two children: one Expression for the condition \nand one Statement for the body. Compilation problems are cast into problems of de.ning attributes oftheAST \nnodes.Forexample,thegoalof name analysis is to associate each use of an identi.er with the appropriate \ndeclaration, according to the scope rules of the language. This problem is cast into the problem of de.ning \na decl attribute of identi.er access nodes, such that the valueisa referencetothe appropriate declaration \nnode. This problem can be further decomposed into subproblems that are also de.nedby attributes.Forexample, \nthe scope rules that de.ne the visibility of declarations can be de.ned using additional attributes. \nAttributes that are references to AST nodes are called reference attributes [Hed00], and make many problems \nstraightforward to express declaratively. This is in contrast to traditional Knuth-style attribute grammars \n[Knu68] that usually result in very cumbersome speci.cations for other than very simple problems. While \nthe attributes are de.ned declaratively by equa\u00adtions in JastAdd, they are accessible to ordinary program\u00admers \nas methods on the AST classes.Forexample, the at\u00adtribute decl will be represented as a method Declaration \nAccess.decl() where Access and Declaration are AST classes modelling identi.er accesses and declarations \nre\u00adspectively. 3.2 Graphs superimposed on the AST The AST tree structure gives a basic hierarchical \nrepresen\u00adtation of the program, traversable through methods gen\u00aderated as part of the AST class hierarchy, \nfor example, getCondition() and getBody() for accessing the chil\u00addren of a While node.For manycompilation \nproblems, ad\u00additional graph structures are useful, for example inheritance graphs, method call graphs, \netc. The use of reference at\u00adtributes, like decl,resultsina superimposed graph structure on the AST. \nSuch graphs may well be cyclic. Consider two mutually dependent classes A and B, where A has a variable \nof type B and B has a variable of type A. The resulting graph, consid\u00adering both child edges and the \ndecl reference attributes, is cyclic. In practice, manygraphs are cyclic, so it is very use\u00adful that \nthe declarative underlying system allows them to be expressed. Speci.c graphs can be de.ned by de.ning \nadditional at\u00adtributes. For instance, suppose we want to de.ne a type graph, capturing the subtype relation. \nThe essential infor\u00admation for this graph can be found in the decl attributes of the extends and implements \nclauses in the class decla\u00adrations. An explicit graph can be de.ned by adding an at\u00adtribute supertypes \nto the ClassDeclaration, de.ned as the set of declarations referred to in the extends and implements \nclauses. 3.3 The AST as the only data structure The use of an attributed AST, and using reference attributes \nto superimpose graphs onto the AST, makes it straightfor\u00adward to use the AST as the only data structure.Forexam\u00adple, \ninstead of using the separate symbol tables of traditional compilers, the corresponding information is \ncast as attributes in the AST. This is useful, because it allows the extension mechanisms that apply \nto ASTs and attributes to be applied to the compilation data structures too. JastAdd attributes can have \nparameters, making it possi\u00adbleto de.ne suitableAPIstotheAST.Forexample, instead of using the traditional \nsymbol tables for looking up decla\u00adrations of identi.ers, manyAST nodes are equipped with an attribute \nDeclaration lookup(String identifier) that will return the appropriate declaration that is visible at \nthat particular node. Through tree edges and reference at\u00adtributes, subproblems can be delegated to other \nnodes and their attributes. For example, the lookup attribute for an ordinary identi.er access may be \nde.ned in terms of other lookup attributes in the enclosing class and its superclasses. 3.4 Declarative \nframeworks The generated result of a JastAdd speci.cation is an object\u00adoriented framework: a set of collaborating \nAST classes with amethod API that is generated from the attribute de.nitions. The framework can be used \nas is by client Java code: con\u00adstructing an AST by instantiating the concrete AST classes (typically \nusing a parser), and calling the attributes in the API to query the AST for information. For example, \nwe could query the decl attribute of an identi.er access in order to .nd its declaration. The framework \ncan also be extended with new behavior. Such extensions are made in JastAdd, resulting in a gener\u00adated \nextended Java framework. The extensions can be made both along the syntactic dimension, adding newAST \nclasses, and along the behavior dimension, adding new attributes to the AST classes. The framework is \ndeclarative in that the behavior is de\u00ad.ned through equations. From the usage perspective this means \nthat once an AST has been constructed (for exam\u00adple, via a parser), all its attributes automatically \nhave values such that all equations hold. The client code does not have to worry about in which order \nthe attributes are given values; this is part of the implementation of the attribute methods andis automatically \ngeneratedby JastAdd.Infact, thiseval\u00aduation is done on-demand, as attribute values are used, and many \nvalues are cached for ef.ciency. A consequence of the declarative de.nition of the at\u00adtributes is that \nit is safe for client code to use anyattributes and in any order. There are no hidden assumptions on \nthe orderin whichthe attributesmaybe called:theirvalues are constant for anygiven AST.For this reason \nall attributes are represented as public Java methods in the resulting frame\u00adwork. Nevertheless, when \nwriting a behavior module, there are typically some attributes that are intended to be used by clients, \nothers that are intendedtobe de.ned whenextending the language, and yet others that are simply help attributes \nthat solvesmall subproblems. Informally,we therefore speak of a client interface and an extension interface \nto the differ\u00adent behavior modules. The client interface simply consists of classes with methods. The \nextension interface makes use of a number of declarative extension mechanisms. 3.5 Declarative extension \nmechanisms JastAdd combines ordinary object-oriented programming extension mechanisms with some declarative \nmechanisms especially targeting tree based computations. Theyall share the common purpose to simplify \nthe use of the major design ideas presented sofar. Language structure is speci.ed by an object-oriented \nab\u00adstract grammar from which JastAdd generates a Java class hierarchyincluding constructors and traversal \nAPI. This pro\u00advides the usual object-oriented opportunities for abstraction through deep class hierarchies \nwith late bound methods and reuse through inheritance. Inter-type declarations are used to allow modular \nextension to an existing class hierarchy. Jast-Add takes an extreme approach where no behavior is spec\u00adi.ed \ndirectly in the abstract grammar, but always through external behavior modules that introduce new attributes \nand equations in AST node classes. The main mechanismto specifyextensible behavior mod\u00adules is the use \nof declarative attributes whose values are de\u00ad.ned by equations. The equations are speci.ed in a syntax \ndirectedfashion, solvinga problem for each AST node type in isolation. The order of specifying the equations \nis irrele\u00advant: an attribute evaluation engine automatically combines the equations into a global solution, \nordering the evalua\u00adtion of individual equations. This makes it trivial to combine modules no manual \ncode is needed for ordering the com\u00adputations. Synthesized attributes are very similar to virtual meth\u00adods \nwithout side-effects.An attributeis speci.edina class and equations may be overridden in subclasses. \nInherited attributes propagate information about the current context downwards in a tree while decoupling \nthe use of an attribute from its de.nition. The node reading an attribute value need notbeawareof which \nnode de.nes thatvaluebutonly that there is an ancestral node providing an equation. Circular at\u00adtributes \ncan be used when there are cyclic dependencies be\u00adtween equations which are then evaluated using .xed-point \niteration. When using the AST as the only data structure it is crucial to be able to incrementally add \nnew information to the AST to represent data that is not available at parse time. Nonter\u00adminal attributes \nare attributes that are subtrees de.ned using attributes and grafted into the existing AST. These attributes \nmay make use of other attributes and provide a means to de\u00ad.ne new trees as functions of an existing \ntree. JastAdd also supports conditional rewrites that may use attributes to de\u00ad.ne context-dependent \ntransformations to the AST. This can, for instance, be used to rewrite the AST into a form more suitable \nfor later computations.  3.6 TheJastAdd speci.cation language As a background to the examples in the \nupcoming sec\u00adtions, we brie.y introduce the JastAdd speci.cation lan\u00adguage through a simple example language. \nThe language contains an abstract class A, and four con\u00adcrete classes B, C, D, and E. Classes D and E \nare subclasses to A. Class D has two children called myB and myC, of types B and C respectively. B, C \nand E have no children. abstract A; B; C; D: A ::= myB:B myC:C; E: A; A declares a synthesized attribute \nsa of type int and with a default value 42. D overrides the default with an equation de.ning sa to equal \n4711. The attribute and the equation are introduced into the classes A and D using inter\u00adtype declarations: \nsyn int A.sa() = 42; eq D.sa() = 4711; B declares an inherited attribute ia of type int. E declares an \ninherited attribute r of type C. Because C is an AST class, r is a reference attribute. D declares a \nnonterminal attribute myNta of type E, and provides a default value, new E(): inh int B.ia (); inh C \nE.r(); nta E D.myNta() = new E(); The inherited attributes must be de.ned in an ancestor node. D de.nes \nthe ia of its myB child using the sa attribute of its myNta nonterminal attribute. D also de.nes the \nr of myNta as equal to its myC child reference: eq D.myB().ia() = myNta().sa() + 1; eq D.myNta().r() \n= myC(); Figure 5 shows a class diagram for the language. The inter-type declarations have been moved \ninto the appropriate classes. The aggregate relations show the AST hierarchy. Figure 5. Class diagram \nfor example language Figure6shows an attributed AST for the language. The unattributed AST with the D,B,andC \nnodesis createdby,for example,a parser. The attribution, including theE object and the r, ia, and sa \nattributes, is then computed automatically by the attribute evaluator. 4. Name Analysis The goal of name \nanalysis is to bind each access of an iden\u00adti.er to its corresponding declaration. While the implemen\u00adtation \nis intricate, the resulting client interface in JastAddJ Figure 6. Attributed AST for example language \nis very simple, as shown in Figure 7. It consists of the single attribute decl in Access nodes. Figure \n7. Client interface to the name analysis Java name analysis contains manychallenging and inter\u00adesting \nproblems. While there are manysubtleties in the in\u00addividual language constructs, there are two main subprob\u00adlems. \nFirst, the visibility rules need to handle different com\u00adbinations of scopes, such as nested scopes, \ninheritance, and quali.ed access to remote members. Second, determining the meaningofa nameisfairly complex:it \ndepends on the syntactic context and it may also depend on the resolution of other names in that context. \nInaprevious articlewehaveshownhow name analysis is solved in our Java 1.4 frontend [EH06]. In this section \nwe will show how this solution forms two extension interfaces, one for each of the main subproblems, \nand we will exem\u00adplify how these interfaces can be used when extending the language. 4.1 Visibility rules \nThe set of visible identi.ers at an AST node is de.ned by an attribute lookup(string ) which returns \nthe appropri\u00adate visible declaration node. Access nodes use the lookup attribute to de.ne their decl \nattribute. The lookup attribute is declared as inherited, meaning that its value is de.ned by an ancestor \nnode.1 By declaring an attribute as inherited, we say that the node captures the value de.ned by the \nancestor. Figure 8 shows the extension interface to the visibility rules. In the framework there are \nsome classes that take on the role of de.ning lookup for their children. This is done by an equation \nthat de.nes the lookup attribute for a given child of the node. The equation holds for all lookup at\u00adtributes \nin the complete subtree of the child, but may be rede.ned further down in the subtree, in another node \nthat de.neslookup. Such rede.nition canbe used,forexample, 1In a traditional attribute grammar [Knu68], \nthe value of an inherited attributeis de.nedbythe immediate parent node. JastAdd usesashorthand, similar \nto the Eli including feature [KW94], so that it is suf.cient if there is a de.nition of the attribute \nsomewhere along the ancestor spine of the AST. to model nested scoping.A language construct that affects \nvisibility typically rede.nes lookup for its children. It does so by capturing its own lookup attribute \nand combining it with other speci.c lookups. The speci.c lookups are synthe\u00adsized attributes that model \nsome speci.c visibility. Examples include looking up names in a given block, in a given class, in the \ninheritance chain of a given class, and so on. Figure 8. Extension interface to the visibility rules \nClasses in the framework take on the roles of de.ning lookup, capturing lookup, and providing speci.c \nlookups in order to implement the visibility rules of the different Java 1.4 language constructs. The \nvisiblity de.nition for .elds, parameters, and local variables, includes 14 classes taking on the role \nof de.ne lookup,7 classes that capture lookup, and9classes that provide speci.c lookup. The correspond\u00ading \nnumbers for types are 9 classes that de.ne lookup, 5 classes that capture lookup, and5classes that provide \nspe\u00adci.c lookup. The reason that type visibilty requires fewer rules than variable visibilty is that \nthere are fewer language constructs that may enclose type declarations than variable declarations. Consequently, \nmethod visibilty requires even fewer rules. The same three roles can be used also when ex\u00adtendingtheframework,aswillbeexempli.edin \nSection4.3. 4.2 Determine the meaning of names Names in Java are highly context-sensitive and a Java \nparser typicallybuilds general Access nodes for all names, regard\u00adless of their actual meaning. The JLS \nde.nes the speci.c rules for how to .rst classify context-free names according to their syntactic context \nand then to re.ne them by reclas\u00adsifying contextually ambiguous names. Our Java compiler follows this \nimplementation scheme [EH06]. While the de\u00adtails of this implementation are quite intricate, the extension \ninterface is very simple: a new language construct that has an Access child needs only provide an equation \nde.ning its initial NameKind which can be a type, a package, an expres\u00adsion, or ambiguous (eithera package \nora type, depending on other context). The further re.nement of ambiguous names is then carried out automaticallyby \ntheJava 1.4 frontend. Figure9showstheextension interfaceto determiningthe meaning of names. The framework \ndeclares the inherited at\u00adtribute nameType for Access nodes.A new language con\u00adstruct that has an Access \nchild needs to provide an equation for this attribute.  4.3 Extensions The complete name analysis framework \nconsists of the two parts described in sections 4.1 and 4.2. Using this simple Figure 9. Extension interface \nto determining the meaning of names framework it is very easy to de.ne new language constructs that \nextend Java with constructs that affect the name analy\u00adsis. 4.3.1 The enhancedfor loop Consider extending \nJava 1.4 with the enhanced for loop of Java 5: for(Element e : collection) statement Alocal variable \ndeclaratione is declared and needs to be included in the set of visible declarations of the contained \nstatement. The new loop is modelled by a new AST class EnhancedFor, see Figure 10. It de.nes lookup for \nits con\u00adtained statement by an equation that delegates to a new spe\u00adci.c lookup, matchLocal. The speci.c \nlookup .rst matches the string with the local variable, and if no match, it dele\u00adgates to theEnhancedFor \ns own lookup attribute, which is captured by the superclass Stmt. The abstract syntax for the EnhancedFor \nis EnhancedFor: Stmt ::= Access Decl Exp Stmt Since EnhancedFor is a construct with an Access child (Element \nin the example above), it also provides an equa\u00adtion to de.ne the nameType of that Access as equal to \nNameKind.TYPE.  4.3.2 Adding an inspect statement As anotherexample, considerextendingJavawithan inspect \nstatement in which the members of the inspected object are visible without quali.cation. This newstatement \nchanges the set of visible declarations for its contained statement: inspect(obj) statement The new statement \nis modelled by a new AST class InspectStmt. Similarly to the previous example on the EnhancedFor, the \nInspectStmt de.nes the lookup at\u00adtribute of its contained statement, see Figure 11. The equation reuses \nthe existing speci.c lookup attribute matchMembers of the inspected object s type. A simple combination \nof this attribute with the current visibility con\u00adtext, i.e., the lookup attribute of the InspectStmt \nitself, yields the desired visibility context for the contained state\u00adment. This simple equation will \ncause all Access nodes in\u00adside the inspected statement to be automatically bound to the appropriate declarations. \nThe example illustrates the reuse of speci.c lookup at\u00adtributes in the name analysis framework. The whole \nJava 1.4 name analysis frameworkisinfactbuiltup incrementally us\u00ading this technique: some language constructs \nintroduce new speci.clookup attributes, othersmake useof these attributes to de.ne visibility. For example, \nMethod declarations and Class declarations provide speci.c lookup attributes. These are combined in various \nways in different language con\u00adstructs to support block nesting, inheritance, nested classes, and quali.ed \naccess to type members. The example also illustrates that name analysis and type analysis are mutually \ndependent: the de.nition of the lookup attribute of the InspectStmt uses the type anal\u00adysis framework \nas well (see the next section): it uses the type attribute of its inspected object.Type analysis on the \nother hand requires name binding to .nd the type of a name and to bind type names to declarations. Name \nbinding and type analysis are thus mutually dependent and would re\u00adquire complex manual scheduling if \nnot using declarative attributes. 5. Type analysis The two main tasks of the type analysis framework \nare to compute the type for expressions and to decide whether two types are in the subtype relation. \nThe way these analyses are implementedishighlyaffectedbythedesign principletouse the AST as the only \ndata structure which is thekeyto their extensibility. This requires types to be represented by nodes \nin the AST, and the type of an expression is represented simply by a reference attribute that points \nto the appropriate type node. We will use the term binding as a synonym to a reference attribute, in \nparticular when the attribute binds together distant parts of the AST. This design leads to the simple \nclient interface shown in Figure 12. The attribute type binds each Expr to a TypeDecl which can then \nbe used to compute the subtype relation using the subtype attribute. Extending the language with new \nkinds of types then boils down to the following two problems. First, to obtain AST representations for \nthe new types. Second, to extend the subtype test so that the instances of the new types can be compared \nwith each other and with other existing types. 5.1 Typerepresentation Java has both explicitly and implicitly \ndeclared types. For explicitly declared types, like classes and interfaces, we use their declaration \nnodes as type representations.For implic\u00aditly declared types, for example primitive types and arrays, \nweaddASTnodesaspartofthe attributeevaluation,i.e.,af\u00adter parsing. This is done declaratively through \nthe use of non\u00adterminal attributes.A nonterminal attributeisa child node thatis de.nedby an equation, \nrather than constructedby the parser. In JastAdd, nonterminal attributes are evaluated on demand, i.e., \nthe nonterminal attribute nodes are constructed automatically as soon as they are accessed. Figure 13 \nshows the extension interface for type repre\u00adsentation. In the framework there are abstract classes like \nexpressions and declarations that bind toa type.If theexten\u00adsion introduces subclasses to these, called \nconcrete binds to type in the .gure, theyhaveto supply an equation for binding to the desired type node. \nThe type node can be an instance of an existing TypeDecl subclass in the framework, or of a new type \nin theextension.Typically, the equations de.ning type bindings make use of the name analysis framework, \ni.e. the decl attribute, to .nd the desired type object. Suppose the extension introduces new types. \nIn case the extension also introducesexplicit declarationsof these types, the nodes canbe automaticallybuiltby \nthe parser. Butif the new types are implicitly declared, they need to bebuilt as nonterminal attributes.In \nthis case they arebuilt as children to another AST class,a declarationcontext. The use of inter\u00adtype \ndeclarations allows an extension to add attributes and equations to existing classes in the framework. \n 5.2 Extensible subtype tests The subtype relation is the foundation of object-oriented type checking \nand used when implementing other rela\u00adtions such as assign conversion, method invocation con\u00adversion, \ncasting conversion, etc. We implement the sub\u00adtype relation through a parameterized attribute boolean \nTypeDecl.subtype(TypeDecl t) to determine if two types are in the subtype relation. All kinds of types \nare possible to compare using the sub\u00adtype attribute. Not only class and interface types, but also primitive \ntypes and array types.To compare class and inter\u00adface types, we use a straightforward implementation \nof the subtype test that searches the direct supertypes transitively. Since all types are represented \nby nodes in the AST, we can simply follow the reference attributes that bind type declara\u00adtions to their \ndirect supertypes. The subtype attribute supports comparison between two arbitrary types. To allow the \nmodular de.nition and extension of this relation, we have used the double dis\u00adpatch pattern [Ing86].2 \nWhen comparing two types by t1.subtype(t2), the subtype attribute dispatches on t1, and its de.nition \nuses another attribute that dispatches on t2. The combination of double dispatch with inter-type declara\u00adtions \nallows extensions to be done modularly, as illustrated below. The double dispatch pattern allows us to \nspecify the sub\u00adtype relation with a single equation for each pair of type kinds. In practice, the number \nof equations is much smaller since manytypes are incompatible, and these combinations can rely on default \nequations that simply return false. 2Binary attributes, analogous to binary methods [BCC+95], could have \nbeen used as an alternative mechanism for achieving extensible implemen\u00adtation,but are not supportedby \nJastAdd. Figure 14 shows the extension interface for subtyping. The subtype attribute is a synthesized \nattribute in the ab\u00adstract class TypeDecl. Each different kind of type is rep\u00adresented by a subclass \nto TypeDecl and provides an equa\u00adtion for subtype. The framework includes a number of such types, here \nexempli.ed with T1 and T2.For each such type, say T1, there is also an attribute supertypeOfT1 in TypeDecl, \nwith the default value false. The framework can be extended by adding a new type, say NewType, as a subclass \nof TypeDecl. Its equation for subtype should do the double dispatch, i.e., it should call supertypeOfNewType. \nThe declaration of this attribute is added to the abstract TypeDecl in the framework by means of an inter-type \ndeclaration, also with false as a default value. The NewType then overrides this equation and pro\u00advides \nthe implementation for comparing two NewTypes. If a NewType can be a supertype of another type, say T1, \nin the framework, then an equation for supertypeOfT1 is added to NewType to capture this relation. And \nconversely, if a NewType can be a subtype of a T1, then an equation for supertypeOfNewType should be \nadded to T1, again using an inter-type declaration. As seen in Figure 14, the use of inter-type declarations \nallows the extension to be expressed modularly: even the additions to the existing classes in the framework \ncan be expressed inside the extension module.  5.3 Extensions 5.3.1 Non-null types As an example extension, \nconsider the addition of non-null types to Java, to prevent null pointer exceptions. We have implemented \nsuch an extension, including non-null type in\u00adference for legacycode [EH07], and supporting virtual dis\u00adpatch \nduring object initialization using the concept of raw types [FL03]. The type system is extended to distinguish \nbetween possibly-null types, and guaranteed non-null types. The Java 1.4 framework includes the AST class \nClassDecl which models possibly-null types.For each ClassDecl node in the AST, there should be a non-null \ncounterpart. This is mod\u00adelled by a new class NonNull. Instances of NonNull are added as nonterminal \nattributes of ClassDecl. An attribute possiblyNull is added to NonNull that points back to its parent \nClassDecl. This makes it easy to go back and forth between a possibly-null type and its non-null counterpart, \nas needed in other equations. See Figure 15. Figure 15. Extending the type representation framework \nwith non-null types Equations that extend the subtype relation are shown in Figure 16. The framework \nincludes, in addition to Class-Decl, a class NullType that models the type of the null value. The extension \nincludes two boilerplate equations for the double dispatch. Of the two remaining equations, one handles \nthe comparison between two non-null types. This is computedby comparing the types between their possibly\u00adnull \ncounterparts, using the possiblyNull attribute de.ned earlier. The last equation is added by means of \nan inter-type declaration to ClassDecl, and compares the ClassDecl with a NonNull type, by delegating \nthe comparison to the possibly-null counterpart of the latter. The converse com\u00adparison, checking if \na NonNull type is a supertype of a ClassDecl, willalwaysbefalse,andiscoveredbythede\u00adfault equation. No \nadditional equations are needed for com\u00adparing NonNull with NullType because these are never in the subtype \nrelation and are coveredbythe default equations. To handle raw types, the type analysis framework is \nex\u00adtended in a similar way.  5.3.2 Generic types Java5generic types are implementedbyextending theJava \n1.4 framework in a similar way as for non-null types. Each parameterizationofa generic typeisbuilt usinga \nnontermi\u00adnal attribute. Figure17showsa simpli.edASTfora generic class Cell and a parameterization using \nString as the type argument. The nonterminal attribute is depicted as a dashed tree edge. Amain difference, \nas compared to the non-null example, is that each generic class may have manyparameterizations. The nonterminal \nattribute thereforetakesalistofarguments. Speci.c .eld and method signatures are also built as part of \nthe nonterminal attribute, where the type parameter T has been replaced by the type argument String. \nThis way, much of the other compilation, such as name lookup and quali.ed access to members of parameterized \ntypes, need not be aware of generic types. Wealsoprovide accesstothe erasedversionofatypeand its members \nthrough the erasure() reference attributes. 6. De.nite assignment The JLS prescribes that each local \nvariable and every blank .nal .eld must have a de.nitely assigned value prior to any access to its value. \nA Java compiler must therefore carry out a conservative .ow analysis to make sure that each control .ow \npath to a variable access contains at least one assignmentto thatvariable.Asimilarcomputation, de.nitely \nunassigned, is needed to ensure that a .nal variable is only assigned at most once. The client interface \nin Figure 18 provides information whetheravariableis de.nitely assignedornotinaparticular context. Since \nvariable assignment is an expression in Java, the .ow analysis needs to propagate information not only \nthrough statementsbut also throughexpressions. Figure 17. Simpli.ed AST for representation of generic \ntypes Figure 19 shows the extension interface for de.nite as\u00adsignment which is centered around the isDAbefore \nand isDAafter attributes, both parameterized with the desired Variable. Each language element that contains \nchildren that are part of the execution .ow needs to provide an equa\u00adtion for the inherited attribute \nisDAbefore. This attribute represents the status before the element is executed. Each execution element \nneeds to provide an equation for the sta\u00adtus afterexecutionby de.ning the isDAafter attribute. These \nmechanisms for handling de.nite assignment are used inside the framework, and can also be used in exten\u00adsions \nof the framework. Figure 20 shows how the While statement is handled, assuming for a moment that it is \nde\u00ad.ned in an extension rather than inside the framework. The abstract grammar for While is the following. \nWhile: Stmt ::= cond:Expr body:Stmt; Notice that the While is both an execution element itself (as are \nall statements), and it contains other execution ele\u00adments: cond and body. The informal speci.cation \nof De.\u00adnite Assignment in Chapter 16 of the JLS states that: Avariable is de.nitely assigned before \nthe condition if it is de.nitely assigned before the while statement.  Avariable is de.nitely assigned \nbefore the loop body if it is de.nitely assigned after the condition.  Avariable is de.nitely assigned \nafter a WhileStatement if it is de.nitely assigned after the condition.  Notice the similarity between \nthis syntax-directed way of specifying de.nite assignment and the equations in Figure 20. De.nite unassignment \nprovides additional challenges in that there may be circular dependencies between attributes asshownbythe \nfollowingexample.A variableisonly def\u00adinitely unassigned before a loop condition in a while state\u00adment \nif it is de.nitely unassigned both before the while state\u00adment and after the loop body. Moreover, whether \na vari\u00adable is de.nitely unassigned after the loop body depends on whether the variable is de.nitely \nunassigned before the loop condition. This leads back to the initial de.nition which leadstoacircularity. \nSuch attributes canbeexpressed declar\u00adatively using circular attributes in JastAdd. The evaluation is \ncarried out using a .x-point computation, starting at a start value speci.ed in the declaration of the \ncircular at\u00adtribute. Because the computation is declaratively expressed, itis straightforwardtoextenditfornew \nlanguage constructs, simply by supplying additional equations for the new lan\u00adguage construct, analogously \nto how it was done for the While statement in Figure 20. 7. Discussion The previous sections have demonstrated \nthreekey declar\u00adative frameworks that can be extended modularly when adding new language constructs. \nThere are additional frame\u00adworks with similar small extension interfaces in JastAddJ that deal with unreachable \nstatements,control .ow,constant expressions, error checking, and codegeneration. Each new language construct \nneeds to extend some of these frame\u00adworks in order to support error checking and/or class .le generation.For \ninstance, the inspect statement, used earlier to exemplify name analysis extension, would also need to \nextend several of the other frameworks to fully extend the compiler. New analyses that are added to the \ncompiler can bene.t from using these frameworks and may also de.ne their own extended reusable frameworks. \nSection3 presented the major design principles that en\u00adable modular extensions to JastAddJ. The syntax \ndirected approach to declaratively specify context-sensitive compu\u00adtations using attributes provides \na foundation for extensible computations. Attributes allow speci.cations to be broken down into small \nproblems that are solved for each kind of node type separately, and then combined into a whole au\u00adtomatically \nby the attribute evaluation engine. Synthesized attributes enable abstraction over the node children \nwhile inherited attributes enable abstraction over the current con\u00adtext.Traditional use of symbol tables \nbreak these qualities byintroducing unnecessary dependencies between unrelated computations that make \nuse of the tables. Mutually depen\u00addent analyses must then be scheduled manually as discussed in the previous \nsections, e.g., object-oriented name and type analysis. The extension mechanisms all rely on tree based \ncomputations and the design principle to use the AST as the only data structure serves to maintain that \nproperty through\u00adout the compiler. There are three main language features in JastAdd that enable the \nuse of the AST as the only data structure while maintaining a loose coupling between different parts \nof the AST. First, references to remote nodes allow for abstraction over distant structures. Attributes \nmay be accessed remotely through a reference without exposing unnecessary details about the remote context. \nSecond, inherited attributes with parameters enables abstractionover the current context with\u00adout introducing \nfurther dependencies besides that there must be an ancestor that de.nes the value in the current context. \nThis kind of abstraction occurs naturally in programming languages where one can often refer to enclosing \nelements implicitly, e.g., break out of the current loop, or explicitly, a named variable currently in \nscope. Third, nonterminal at\u00adtributes can be used to build new subtrees as functions of existing structures \nduring attribute evaluation which is im\u00adportant to represent implicitly declared entities that need to \nbe explicit in the AST. 8. Evaluation We have evaluated JastAddJ by comparing it to a number of open \nsource Java compilers, both extensible and non\u00adextensible ones. The evaluation has been done from several \nperspectives: language compliance, performance, and imple\u00admentationsize.We .rst present the compilers \nwe compare with, then the test suites we have run, and .nally the results of the different comparisons. \nAll tests were carried out on a ThinkPad T42p Pentium M 1.7 Ghz with 1 Gbyte memory, running Fedora Core \n6 Linux. Unless otherwise noted the tests wereexecuted using the Java HotSpot Client VM version 1.5.0 \n02-b09 and we report thefastestof.ve runs. 8.1 Compilers overview We include the most common industrial \nstrength Java com\u00adpilersaswellasafew researchcompilersthatexplicitlysup\u00adport extensibility. If a compiler \nexists in both a Java 1.4 and aJava5 version we include both, the reason being that we want to use the \nlatest version for compliance comparisons but the Java 1.4 version when comparing implementation size. \nAll compilers are implemented in Javaunless otherwise stated. We have only included compilers that are \npublicly available including source code.We chose not to include the GNU compiler for Java (gcj) since \ntheyare currently replac\u00ading their frontend with the eclipse frontend, which is already included in the \ncomparison. Javac Javac is the standard compiler in Sun JDK and also serves as a reference implementation \nfor the Java Pro\u00adgramming Language. It is implemented in Java and in the comparison we include javac \n1.4.2 and javac 1.5.0. Eclipse The Eclipse project contains an incremental Java compiler based on technology \nevolved from the Visu\u00adalAge Java compiler. We have tried to remove all IDE speci.c compiler code to allow \nforafair comparison to the stand alone compilers.Version 2.1.3 supporting Java 1.4 only andversion 3.1.2 \nthat also supportsJava5 are included in the comparison. Jikes Jikes is a high-performance Java 1.4 compiler \nwritten in C++ originally developed by IBM at T. J. Watson research Centerbut now maintainedby an open \nsource community. The comparison is based on version 1.22. Polyglot Polyglot is framework forbuilding \nJava frontends using a library that can be extended with new language features and analyses through inheritance \n[NCM03].Ver\u00adsion 2.2.0 of polyglot is included in the comparison.We havealso includedanexperimentalJava5extension,ver\u00adsion \nR20061211, which is a modular extension to Poly\u00adglot 1.3.4 [SM07]. JaCo JaCo is an extensible compiler \nfor Java 1.4 writ\u00adten in a slightly extended Java dialect calledKeris that supports extensible algebraic \ndata types with defaults [jac07b, ZO01a].Kerisis itself implementedasa modu\u00adlar language extension to \nJaCo.  8.2 Test suites The most widely used test suites for Java are probably the SPECjvm98 and SPECjbb2000. \nTheyare not particular suit\u00adable for evaluating our extensible compiler since theyfocus on testing JVMs \nrather than if the compiler can handle all language idiosyncrasies. The Java Compatibility Kit (JCK) \nisanextensive test suite that canbe licensed fromSunto en\u00adsure compatible implementations of Java. This \nis an excel\u00adlent test suite perfectly targeting our domain. However, the open license is read-only which \nprevents us from automated processing of the test suite.Visual inspection reveals that it is anexcellent \ntest suite with manychallenges both for static semantic analysis and code generation includingJava5fea\u00adtures.We \ntherefore have to rely on alternative test suites to validate the correctness of the compilers.We have \nused the Jacks test suite, the DaCapo benchmark, and a number of sample applications, as described below. \n8.2.1 Jacks Jacks is an excellent compiler killing test suite that validates the static semantic analysis \nperformed by Java 1.4 compil\u00aders using a test suite that mimics the chapters from the JLS, Second Edition. \nIt was originally developed at IBM but is now maintainedby the Mauve project. The suite does unfor\u00adtunately \nneither testJava5features nor run-time behaviorof the generated code. 8.2.2 DaCapo benchmark The DaCapo \nbenchmarkisasetof general purpose, realistic, freely available Java applications combined with an evalua\u00adtion \nmethodology for benchmark suites and a performance evaluation methodology [BGH+06]. While the main goal \nof the DaCapo suite is not to test the frontend part of a com\u00adpiler it provides an automated test harness \nand result valida\u00adtorthat canbe usedtoverify thatthe code generatedbythe compiler is correct.We have \nused DaCapo release dacapo\u00ad2006-10-MR2 which includes the following applications in its test suite: \nantlr Aparser generator and translator generator. bloat Abyte-code level optimization and analysis tool. \nchart Agraph plotting toolkit and pdf renderer. eclipse An integrated development environment. fop An \noutput-independent print formatter. hsqldb An SQL relational database engine. jython Apython interpreter. \nluindex Atext indexing tool. lusearch Atext search tool. pmd Asource code analyzer. xalan An XSL processor. \n  8.2.3 Sample applications The previous benchmarks only test Java 1.4 features. There are, to our knowledge, \nno open test suites for Java5which enable the samesystematic testing.We therefore handpicked afewapplicationsthatmakeextensiveuseofJava5features. \nWe also included older Java 1.4 versions of the same appli\u00adcations which allow us to compare how the \nlanguage exten\u00adsions affect compilation. The packages we included from the JDK are particularly challengingin \nthattheymakeextensive use of trickylanguage features such as nested classes, anony\u00admous classes, and \ngeneric types using wildcards. Finally we included two substantial applications to verify that the com\u00adpilers \nscale to moderate sized applications in the range of 100K LOCs. junit 3.8.1 JUnit testing framework, \n3.6K LOC of Java 1.4 source. junit 4.1 JUnit testing framework, 3.1K LOC of Java 5 source. jhotdraw 5.3 \nJHotDrawGUI framework for structured graph\u00adics, 14.6K LOC of Java 1.4 source. jhotdraw 7.0.8 JHotDraw \nGUI framework for structured graphics, 38.7K LOCofJava5 source. JDK 1.4.2 The java.lang and java.util \npackages from JDK 1.4.2, 35.7K LOC of Java 1.4 source. JDK 1.5 Thejava.lang andjava.util packages from \nJDK 1.5, 56.2K LOCofJava5source. ecj 3.2.2 The Eclipse Java compiler, 94.1K LOC of Java 1.4 source. Jigsaw \nThe of.cial W3C Java-based Web server, 100.8K LOC of Java 1.4 source.  8.3 Compiler compliance We compiled \nthe Jacks test suite on all selected Java com\u00adpilers. Warnings were turned off not to produce warnings \nabout common programming mistakes which are not con\u00adsidered errors in the test suite, e.g., a warning \nthat a .nally block can not complete normally. The compilers that sup\u00adport Java 5 were run in Java 1.4 \ncompatibility mode. The results are shown in Figure 21 showing number of passed, skipped, andfailed tests. \nThe tests that were skipped are tests that cause the compilers to get stuck in a never ending loop. The \nskipped tests for javac, eclipse, and JastAddJ1.4are all causedby the samebugin the standard class library \nwherea .oating point number is converted from a string representa\u00adtion into its binary counterpart. Although \nJastAddJ1.4passes more tests than anyof the other compilers, we do not claim superiority to either compilerbut \nmerely conclude that the number offailed test cases indicates that the compiler im\u00adplements the complete \nstatic semantic analysis for Java 1.4. Whilethe Jackstest suitedoesanexcellentjobin testing language \nidiosyncrasies we use another set of benchmarks to validate our thesis that most language features are \nused by even fairly small real world applications. Figure 22 shows the success rate for a set of sample \nprograms, described in Section 8.2.3, ranging from a few thousand to more than 100K LOCsexcluding comments \nand whitespace. Both jaco and polyglotgivenumerousfalse positives and internal com\u00adpiler errors which \nshows that real applications indeed con-tain many of the language details tested by the Jacks test suite. \nCompiler %pass #pass #skip #fail javac1.4 javac1.5 eclipse1.4 eclipse1.5 jikes polyglot2 jaco JastAddJ1.4 \n99.0 % 99.2 % 98.1 % 98.6 % 99.3 % 90.5 % 78.0 % 99.5 % 4446 4455 4409 4429 4461 4065 3505 4468 1 1 1 \n1 0 49 3 1 44 35 81 61 30 377 983 22 Figure 21. Results from running the Jacks test suite.Tests that \nare skipped cause the compiler not to terminate.  Compiler junitv jhotdraw v JDK v ejcv jigsaw v javac1.4 \njavac1.5 eclipse1.4 eclipse1.5 jikes polyglot2 jaco JastAddJ1.4 v v v v v v v v v v v v fail v v v v \nv fail fail v v v v v fail fail v v v v v fail fail v Figure22. Results from compiling the Java1.4 applications \ndescribed in Section 8.2.3. The results from compiling the Java 5 applications de\u00adscribed in Section \n8.2.3 are shown in Figure 23. We have only included theJava5enabled compilers sinceitis rather pointless \ncompilingJava5codewithaJava1.4 compiler.It is interesting to notice how challenging it is to compile \neven quite small Java5applications. One of the major reasons is the extensive use of generics and wildcards \nin the collection framework. Even quite simple usage of these classes may for instance rely on inference \nof type parameters for generic methods. Compiler junit 4.1 jhotdraw 7.0.8 JDK 1.5 v v v javac1.5 eclipse1.5 \nv v v polyglot5 JastAddJ5 fail v fail v fail v Figure 23. Results from compiling the Java5applications \ndescribed in Section 8.2.3.  The DaCapo test suite is used to check that the compilers generate correct \ncode and not only perform static semantic analysis. Figure 24 shows the execution time of the bench\u00admarks \nin the suite for code generated by javac, eclipse, and JastAddJ1.4. The compilers perform virtually no \noptimiza\u00adtions but rely on dynamic optimization in the virtual ma\u00adchine. The exact layout of bytecode \nmay still have signi.\u00adcant effects since the HotSpot compiler is highly optimized for the particular \nlayout performedbyjavac.We notice that there is still some room for improvement in the JastAddJ1.4 backend \nfor bloat and xalan but thatthe performanceisvery similar for the rest of the benchmarks.  Figure24. \nExecution time for the DaCapo benchmark suite.  8.4 Compilation time To evaluate the speed of our generated \ncompiler we have compared compilation times for the applications described in Section 8.2.3. Each application \nwas compiled .ve times and the shortest compilation time for each Java 1.4 applica\u00adtionisshowninFigure25.Jikesisbyfarthefastest \ncompiler which is not that surprising since it is implemented in C++ and does not suffer from VM startup \ntime and initial com\u00adpilation. The results indicate that our generated compiler is less than three times \nslower than thefastestjava based com\u00adpiler. We also notice that JastAddJ is several times faster than \npolyglot, anotherextensible compiler, on medium sized applications. The compile times for the Java 5 \napplications is shown in Figure 26. The generated JastAddJ5 based compiler is less than three times slower \nthanjavac whichis thefastest Java5compiler. JastAddJ5is actually narrowing thegap to javac1.5 compared \nto the corresonding Java1.4 implementa\u00adtions.Webelievethis stems from the demand-driven creation of parameterized \ntypes used in JastAddJ5where parameter\u00adized body declarations are only built when being used by client \ncode. This shows that using the AST as the only data structure is feasable for even quite complex language \nex\u00adtensions. It is also worth noticing that we do not perform any analysis or optimization of the grammars. \nWe believe that there are plenty of opportunities for domain-speci.c optimizations in this area related \nto caching and evaluation strategies. Thatwouldhopefully further narrow thegap be\u00adtween JastAdd generated \ncompilers and hand written com\u00adpilers.  8.5 Implementation size The tested compilers are implemented \nin different language dialects or sometimes even completely different languages. We still .nd it interesting \nto compare implementation sizes to get a rough estimate of the implementation effort, and we have used \nSLOC-count to count the number of lines of code, excluding commentsand whitespace [Whe07].Wehavealso \nincluded the number of tokens since the number of lines can differ quite substantially depending on coding \nstyle. Fig\u00adure27showsthevarious sizesforthe tested compilers.We are somewhat surprised by the large differences \nin source size, often being more than twice as large as the javac com\u00adpiler. The Eclipse compiler is \nan incremental compiler nor\u00admally used within an IDE which may account for the larger code size. JastAddJ1.4and \nJaCo stand out as being signi.\u00adcantly smaller than Javac. Both compilers use extended ver\u00adsions of Java \nespecially targeting compiler implementation which seems to pay off. However, the poor compliance re\u00adsults \nfor JaCo makes it hard to drawanyde.nite conclusions. The JastAdd based implementation shows that the \ndeclara\u00adtive speci.cation technique not only allows for extensibil\u00aditybutalsoyields signi.cantly smaller \ncompilers.Thelower half of the comparison contains the Java5compilers. Jast-AddJ5 and Polyglothave modularextensions \nthat canbe en\u00adabled at will while javac and eclipse are later generations of the compiler. The JastAddJ5Java5 \nextensionis roughly5K LOC of code while the Polyglot extension is 24K LOC, and even compared to the base \ncompiler size, the extension for JastAddJ5is proportionally smaller than the corresponding Polyglot extension. \nMoreover, doing the same comparison for the modularextension and the delta betweenjavac1.4 and javac1.5 \nshows that they are proportionally about the same size. This indicates that not only is JastAdd based \ncompilers smaller than handwritten compilers in Javabut the modular extensions scale in the same way \nas in-place changes to the code base. Compiler #KLOC #KTokens javac1.4 21 ( 100 % ) 106 ( 100 % ) eclipse1.4 \n57 ( 271 % ) 288 ( 271 % ) jikes 70 ( 333 % ) 342 ( 322 % ) polyglot2 39 ( 186 % ) 220 ( 207 % ) jaco \n16 ( 76 % ) 73 ( 68 % ) JastAddJ1.4 15 ( 71 % ) 58 ( 54 % ) javac1.5 30 ( 100 % ) 155 ( 100 % ) eclipse1.5 \n83 ( 297 % ) 411 ( 265 % ) polyglot5 63 ( 210 % ) 340 ( 219 % ) JastAddJ5 21 ( 66 % ) 87 ( 56 % ) Figure \n27. The source code size of the compilers using javac as baseline. The upper half compares Java 1.4 com\u00adpilers \nwhile thelower part comparesJava5compilers.  9. Related work Traditional compilers may provide well-engineered \nAPIs for adding additional analyses, e.g., the JDT model in the Eclipse Java compiler [ecl07],but they \nare often less suited for languageextensions.For instance, the ajc compiler for AspectJ [asp07] is an \nexcellent integration of AspectJ ex\u00adtensions and the Eclipse Java compiler, but the integration is non-modular \nand requires manual synchronization of the two code bases. There are Java source-to-source translators \nthat pro\u00advide support for extensions at the syntactic level but that do not support extensible static-semantic \nanalysis, e.g., JavaBorg/MetaBorg [BV04], the Java Syntactic Extender [BP01] and the JakartaTool Suite \n[SB02]. These tools trans\u00adlate an extended Java dialect to pure Java and rely on a separate compiler \nfor the actual compilation to bytecode. While this approach is attractive for its simple implemen\u00adtation \nit has serious drawbacks when it comes to handling context-sensitive information. The translation can \nnot in\u00adclude context-sensitive properties such as the type of an expression in the translation strategies. \nSince the approach is based on source-to-source, a separate Java compiler is needed to perform error \nchecking and bytecode generation. Error checking is performed on the generated code, and er\u00adrors are \nrarely well aligned with the original source code. There are also approaches that provide support for \nstatic\u00adsemantic analysisbut more limited support for syntacticex\u00adtensions. OpenJava [TCIK00] adds a macro \nsystem to Java that uses a meta-object protocol (MOP), similar to Java s re.ection API, to manipulate \nthe program structure. Macro programs can access data structures representing a logical structure of \na program from which much of the semantic structure of the program is exposed. The MOP can be used to \nadd additional analyses on top of Javabut there is little support for re.ning existing analyses or for \nsyntactic exten\u00adsion. The most .exible solution for language extensibility is to provide support for \nextensions at both the syntactic and static-semantic analysis level. Polyglot is an extensible source-to-source \ncompiler framework implemented in Java that relies on design patterns for extensibility, e.g., abstract \nfactories, extensible visitors based on delegation, and prox\u00adies [NCM03]. The base code is a Java 1.4 \nfrontend which has been extended successfully for numerous language fea\u00adtures. The frontend has for instance \nbeen extended with the AspectJ language in the AspectBench project [ACH+06]. The extension is modular \nand uses the Soot optimization framework as a backend to form a full AspectJ compiler [VRHS+99]. The \ncompiler is pass oriented (with extensible passes) and also supports tree rewriting at the end of each \npass. JaCo is an extensible Java 1.4 compiler including both frontend and backend [ZO01b]. The .rst implementation \nof JaCo was done in a Java dialect supporting algebraic types with defaults [ZO01a].Asetof object-oriented \narchitectural patterns was used to further support extensibility. JaCo has later been implemented inKeris, \nan extension to Java that supports extensible modules with explicit re.nement and specialization mechanisms. \nBoth compilers are based on explicit scheduling of multiple passes. The above compilers all rely on manual \nscheduling of de\u00adpendencies between analyses. In contrast, the JastAdd Ex\u00adtensible Java compiler is implemented \nin the declarative ReRAGs formalism, combining the language mechanisms automatically while supporting \nmodularity and extensibility as described in the previous sections. ableJ is a declarative Java frontend \nimplemented using the Silver attribute gram\u00admar system [WKSB07]. The system supports full Java 1.4 concrete \nsyntax and limited semantic analyses such as type checking. While certainly useful forexperimenting with \nlan\u00adguage features the lack of support for complete Java 1.4 is a major drawback when trying to evaluate \nlanguage features on real programs rather than smallexamples.Onlyafewex\u00adperimentalJava5 extensions areavailable \nand there are no published performance measurements or systematic testing. 10. Conclusions We have presented \nJastAddJ, the JastAdd Extensible Java compiler,and demonstrated thatitisa practical high-quality extensible \ncompiler: large programs can be handled, the speci.cations are smaller than hand-crafted code, and highly \nnon-trivial modularextensionscanbedeveloped,likeadding generics to a language. The compilation is slower \nthan in hand-crafted compilers, within a factor of three of Javac. This is still very reasonable when \nconsidering the main ap\u00adplication area: tobuild special-purpose analyses and tobuild extended languages. \nOur compiler outperforms all other ex\u00adtensible compilers for Java that we know of, considering all measures: \nJava compliance, compilation speed, speci.cation size,andthe supportfor non-trivialextensions.Wehavealso \nshown that our compiler can handle large programs, over 100K LOCs, and that our modular extensions scale \nin the same way as in-place changes to the code base of a non\u00adextensible compiler. As a side-result of \nour experimental evaluation, we have cometothe interesting conclusionthataJavacompilerneeds to be extremely \ncompliant with the language speci.cation in order to be of much practical use: compilers that do not \nhandle almost all of the special cases of the language constructs willfail on allexceptafew small programs. \nThis is bacuse even using the JDK libraries requires advanced features such as inference of type parameters \nfor generic methods. To demonstrate that the technique is indeed applicable to practical problemsofextendingJava, \nwehavebuiltsubstan\u00adtial extensions to our Java 1.4 compiler. This includes an ex\u00adtension to Java 5, an \nAspectJ frontend, an alternative back\u00adend that compiles to Jimple, and a pluggable non-null type checker. \nIn implementing JastAddJ, we have developed a number of general design techniques forbuildingextensible \ncompil\u00aders, and techniques for dealing with central aspects of com\u00adpilation, such as name analysis, type \nanalysis, and de.nite assignment.Wehave illustratedhow these highly non-trivial compilation problems \ncanbeexpressedas declarativeframe\u00adworks with small extension interfaces, that allow straight\u00adforward \nmodular extension. In doing so, we have used a number of declarative extension mechanisms from the at\u00adtribute \ngrammar .eld, such as inherited attributes, reference attributes, nonterminal attributes, and circular \nattributes.We think that this illustrates that these features blend very well with object-oriented programming. \nThe design techniques we havedeveloped are general and can be reused for building extensible compilers \nfor other languages as well. For example, a current effort involves building anextensible compiler foraphysical \nmodelling and simulation language, Modelica[ \u00b0 AEH07]. In principle, the modules that de.ne the core \ndeclarative frameworks could be refactored into separate components and reused for many languages. However, \nthese modules are so small that such implementation reuseis hardlyworth theeffort.We .ndit more important \nto document the ideas as we have done in this paper, so that the ideas themselves can be reused. Acknowledgments \nWe thank David Notkin and the anonymous reviewers of OOPSLA for helpful comments on earlier drafts of \nthis paper. References [ACH+06] Pavel Avgustinov, Aske Simon Christensen, Laurie Hendren, Sascha Kuzins, \nJennifer Lhot\u00b4ak, Ondrej Lhot\u00b4ak, Oege de Moor, Damien Sereni, Ganesh Sittampalam, and Julian Tibble. \nabc: An extensible AspectJ compiler. Transactions on Aspect-Oriented Software Development, 1(1), 2006. \n[And05] Per Andersson. Ef.cient modelling and synthesis of data intensive recon.gurable systems. PhD \nthesis, Lund University, Sweden, June 2005. [asp07] ajc in the AspectJ project, 1.5.0, 2007. http://www.eclipse.org/aspectj/. \n[BCC+95] Kim B. Bruce, Luca Cardelli, Giuseppe Castagna, Jonathan Eifrig, Scott F. Smith, Valery Trifonov, \nGary T. Leavens, and Benjamin C. Pierce. On binary methods. Theory and Practice of Object Systems, 1(3):221 \n242, 1995. [BGH+06] S. M. Blackburn, R. Garner, C. Hoffman, A. M. Khan, K. S. McKinley, R. Bentzur, A. \nDiwan, D. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, \nA. Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, D. von Dincklage, and B. Wiedermann. The DaCapo benchmarks: \nJava benchmarking development and analysis. In Proceedings of OOPSLA 06. ACM Press, October 2006. [BP01] \nJonthan Bachrach and Keith Playford. The Java syntactic extender (JSE). In Proceedings of OOPSLA 01, \npages 31 42. ACM Press, 2001. [Bra04] Gilad Bracha. Pluggable Type Systems. In OOPSLA 04 workshop on \nrevival of dynamic languages, 2004. [BV04] Martin Bravenboer and Eelco Visser. Concrete syntax for objects. \nDomain-speci.c language embedding and assimilation without restrictions. In Proceedings of OOPSLA 04, \npages 365 383. ACM Press, October 2004. [ecl07] Eclipse Java Compiler, Eclipse Java Development Tools \n3.1.2, 2007. http://download.eclipse.org/eclipse/downloads/drops/ R-3.1.2-200601181600/index.php. [EH04] \nTorbj\u00a8orn Ekman and G \u00a8orel Hedin. Rewritable Reference Attributed Grammars. In Proceedings of ECOOP \n2004, volume 3086 of LNCS, pages 144 169. Springer, 2004. [EH06] Torbj\u00a8orn Ekman and G\u00a8orel Hedin. Modular \nname analysis for Java using JastAdd. In Generative and Transformational Techniques in Software Engineering, \nInternational Summer School, GTTSE 2005, volume 4143 of LNCS. Springer, 2006. [EH07] Torbj\u00a8orn Ekman \nand G\u00a8orel Hedin. Pluggable checking and inferencing of non-null types for Java. Proceedings of TOOLS \nEurope 2007, Journal of Object Technology, 6(7), 2007. [Ekm06] Torbj\u00a8orn Ekman. Extensible Compiler Construc\u00adtion. \nPhD thesis, Lund University, Sweden, June 2006. [FL03] M. Fahndrich and K. Rustan M. Leino. Declaring \nand checking non-null types in an object-oriented language. In Proceedings of OOPSLA 03, pages 302 312, \n2003. [GJSB00] James Gosling, Bill Joy, Guy Steele, and Gilad Bracha. The Java Language Speci.cation \nSecond Edition. Addison-Wesley, Boston, Mass., 2000. [Hed00] G\u00a8orel Hedin. Reference Attributed Grammars. \nIn Informatica (Slovenia),24(3), pages 301 317, 2000. [HM03] G\u00a8orel Hedin and Eva Magnusson. JastAdd: \nan aspect-oriented compiler construction system. Science of Computer Programming, 47(1):37 58, 2003. \n[Ing86] D. H. H. Ingalls. Asimple technique for handling multiple polymorphism. In Proceedings of OOP\u00adSLA \n86, pages 347 349, 1986. [jac07a] The Jacks compiler test suite, 2007. http://sources.redhat.com/mauve/. \n[jac07b] JaCo Java Compiler, The Programming Language Keris, 2007. http://lampwww.ep..ch/ zenger/keris/. \n[jas07] JastAdd, 2007. http://jastadd.cs.lth.se/web/. [KHH+01] Gregor Kiczales, Erik Hilsdale, Jim Hugunin, \nMik Kersten, Jeffrey Palm, and William G. Griswold. An overview of AspectJ. In Proceedings of ECOOP 2001, \nvolume 2072 of LNCS, pages 327 355. Springer, 2001. [Knu68] Donald E. Knuth. Semantics of context-free \nlan\u00adguages. Mathematical Systems Theory, 2(2):127 145, June 1968. Correction: Mathematical Systems Theory \n5, 1, pp. 95-96 (March 1971). [KW94] [MH03] [NCM03] [Nil06] [Pal07] [SB02] [SM07] [TCIK00] [VRHS+99] \n[VSK89] [Whe07] [WKSB07] [ZO01a] [ZO01b] [\u00b0 AEH07] Uwe Kastens andWilliam M.Waite. Modularity and reusability \nin attribute grammars. Acta Infor\u00admatica, 31(7):601 627, 1994. E. Magnusson and G. Hedin. Circular Reference \nAttributed Grammars -Their Evaluation and Applications. Electr. Notes Theor. Comput. Sci., 82(3), 2003. \nNathaniel Nystrom, Michael R. Clarkson, and AndrewC. Myers. Polyglot:Anextensible compiler framework \nforjava. In Compiler Construction, 12th International Conference, CC 2003, volume 2622 of LNCS, pages \n138 152. Springer, 2003. Anders Nilsson. Tailoring native compilation of Java for real-time systems. \nPhD thesis, Lund University, Sweden, May 2006. Palpable Computing -anewperspectiveon Ambient Computing, \n2007. http://www.ist-palcom.org. Yannis Smaragdakis and Don Batory. Mixin layers: an object-oriented \nimplementation technique for re.nements and collaboration-based designs. ACM Trans. Softw. Eng. Methodol., \n11(2):215 255, 2002. Milan Stanojevic and Todd Millstein. Java 5 extension for Polyglot compiler framework, \n2007. http://www.cs.ucla.edu/ milanst/projects/polyglot5/. MichiakiTatsubori, Shigeru Chiba,Kozo Itano, \nand Marc-Olivier Killijian. OpenJava:AClass-Based Macro System for Java. In Proceedings of the 1st OOPSLAWorkshop \non Re.ection and Software Engineering, pages 117 133. Springer, 2000. RajaVall\u00b4ee-Rai, Laurie Hendren,Vijay \nSundaresan, Patrick Lam, Etienne Gagnon, and Phong Co. Soot -a Java Optimization Framework. In Proceedings \nof CASCON 1999, pages 125 135, 1999. H. H. Vogt, S. D. Swierstra, and M. F. Kuiper. Higher order attribute \ngrammars. In Proceedings of PLDI 89, pages 131 145.ACM Press, 1989. David A. Wheeler. SLOCCount, 2007. \nhttp://www.dwheeler.com/sloccount/. EricVanWyk, Lijesh Krishnan, August Schwerd\u00adfeger, and Derek Bodin. \nAttribute Grammar-based Language Extensions for Java. In Proceedings of ECOOP 07, LNCS. Springer, 2007. \nMatthias Zenger and Martin Odersky. Extensible algebraic datatypes with defaults. In Proceedings of ICFP \n01, pages 241 252.ACM Press, 2001. Matthias Zenger and Martin Odersky. Implement\u00ading extensible compilers. \nIn Workshop on Multi\u00adparadigm Programming with Object-Oriented Lan\u00adguages, Budapest, Hungary, June 2001. \nJohan \u00b0orel Hedin. Akesson,Torbj\u00a8orn Ekman, andG\u00a8Development of a Modelica compiler using Jast-Add. In \nProceedings of LDTA 07. Electr. Notes Theor. Comput. Sci., 2007.     \n\t\t\t", "proc_id": "1297027", "abstract": "<p>The JastAdd Extensible Java Compiler is a high quality Java compiler that is easy to extend in order to build static analysis tools for Java, and to extend Java with new language constructs. It is built modularly, with a Java 1.4 compiler that is extended to a Java 5 compiler. Example applications that are built as extensions include an alternative backend that generates Jimple, an extension of Java with AspectJ constructs, and the implementation of a pluggable type system for non-null checking and inferenc.</p> <p>The system is implemented using JastAdd, a declarative Java-like language. We describe the compiler architecture, the major design ideas for building and extending the compiler, in particular, for dealing with complex extensions that affect name and type analysis. Our extensible compiler compares very favorably concerning quality, speed and size with other extensible Java compiler frameworks. It also compares favorably in quality and size compared with traditional non-extensible Java compilers, and it runs within a factor of three compared to javac.</p>", "authors": [{"name": "Torbj&#246;rn Ekman", "author_profile_id": "81339498098", "affiliation": "University of Oxford, Oxford, United Kngdm", "person_id": "PP39093267", "email_address": "", "orcid_id": ""}, {"name": "G&#246;rel Hedin", "author_profile_id": "81100270533", "affiliation": "Lund University, Lund, Sweden", "person_id": "P550568", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297029", "year": "2007", "article_id": "1297029", "conference": "OOPSLA", "title": "The jastadd extensible java compiler", "url": "http://dl.acm.org/citation.cfm?id=1297029"}