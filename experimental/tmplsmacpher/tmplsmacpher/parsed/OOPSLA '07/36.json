{"article_publication_date": "10-21-2007", "fulltext": "\n Epi-Aspects: Aspect-Oriented Conscientious Software Sebastian Fleissner Elisa Baniassad Departmentof \nComputerScience and Engineering The Chinese UniversityofHongKong Shatin, N.T., HongKong {seb, elisa}@cse.cuhk.edu.hk \nAbstract Conscientious software is a recently proposed paradigm for developing reliable, self-sustaining \nsoftware systems. Con\u00adscientious software systems consist of an allopoietic part, which encapsulates \napplication functionality, and an au\u00adtopoieticpartthatis responsibleforkeepingthesystemalive by monitoring \nthe application and adapting it to environ\u00admental changes. Practical application of the conscientious \nsoftware paradigm requires solutions to two open problems: The design of suitable autopoietic programming \nlanguages and the proposal of concrete architectures for combining the autopoietic and allopoietic parts. \nIn this paper, we tackle the second challenge, and propose a concrete, aspect-oriented architecture for \nrealizing conscientious software. Here, we introduce epi-aspects,a constructfor upgradingnewandex\u00adisting \napplications into conscientious software. This paper provides the architectural design of epi-aspects, \nan autopoi\u00adetic simulator,anda concrete frameworkfordevelopingepi\u00adaspects in Java. Theframework and the \nsimulator are used to conducta case studyin which wedevelop and testa con\u00adscientious Java application. \nCategories and Subject Descriptors D.2.11 [Software/-Software Engineering]: Software Architectures General \nTerms Reliability Keywords Aspect-Oriented Programming, Conscientious Software 1. Introduction Conscientious \nsoftware is a new paradigm for develop\u00ading reliable, self-sustaining software systems proposed by Gabriel \nand Goldman in [9]. Unlike other approaches for self-sustaining software, such as IBM s autonomic comput\u00ading \n[13, 17], conscientious software consists of two distinct Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr \u00b4ebec, Canada. \neal, Qu\u00b4Copyright c &#38;#169; 2007ACM 978-1-59593-786-5/07/0010...$5.00 parts: An allopoietic1 part, \nwhich encapsulates application functionality, and an autopoietic2 part, which continuously re-creates \nitselfandis entirelydevotedtokeepingthe system running smoothly. The allopoietic part encapsulates traditional \napplication functionality. It is written in a general purpose program\u00adming language, such as C++ or Java, \nand produces some computational results or provides services to users. The au\u00adtopoietic part monitors \nand adapts to environmental changes, and observes and evaluates the health of the allopoietic part. In \ncase the allopoietic partfails, the autopoietic part assists with error recovery. Error recovery and \nmonitoring are well\u00adunderstood concepts, but its techniques are not frequently applied in practice. One \nidea behind the conscientious soft\u00adwareparadigm and the introductionof autopoietic/allopoi\u00adetic parts \nis to encourage developers to devote equal efforts to implementing functionality and error recovery. \nTo maintain the health of the application, the autopoietic part must be able to observe and affect the \noperation of the allopoietic part. In [9], Gabriel and Goldman propose the concept of epimodules, which \nserve as a bridge between the autopoietic and allopoietic parts. Epimodules are attached to allopoietic \ncomponents and monitor their behavior. When necessary, epimodules can affect and alter allopoietic com\u00adponents. \nFor example epimodules can instruct allopoietic components to run tests, restart, upgrade, clone, or \nkill them\u00adselves. The ideas and visions described in Gabriel and Goldman s paper are on a conceptual \nand theoretical level. In order to realize conscientious software, at least two open problems haveto \nbe solved. Firstly,new autopoietic programming lan\u00adguages, which are designed to preventbugs that lead \nto pro\u00adgram crashes, have to be realized to ensure that the imple\u00admentation autopoietic part does notfail. \nSecondly, concrete, 1 Allopoiesis is the process whereby a system produces something other than the system \nitself. One example of this is an assembly line, where the .nal product (such as a car) is distinct from \nthe machines doing the producing. This is in contrast with autopoiesis. (From www.wikipedia.org) 2 Autopoiesis \nliterally means auto (self)-creation (from the Greek: auto -for self-and poiesis -for creation or production). \n(From www.wikipedia.org) Figure 1. Aspect-Oriented Conscientious Software Architecture practical architectures \nfor conscientious software have to be proposed. In this paper, we tackle the second challenge, and propose \na concrete, aspect-oriented architecture for realizing consci\u00adentious software. The goal of this architecture, \nand that of conscientious software, is to allow the separation of the core application functionality \n(the allopoietic part) from the mon\u00aditoring, regulation, and error recovery concerns, as provided by \nthe autopoietic part. Our proposed architecture (.gure 1) consists of three por\u00adtions: the allopoietic \npart (referred to as the application), the autopoietic system, and epi-aspects, which are the glue that \nbinds the other two portions. Epi-aspects are able to advise on join points in both the application and \nautopoietic sys\u00adtem, and so facilitate feedback from the application. They extend the application with \nfunctionality required for eval\u00aduating its health, and for performing adjustments requested bythe autopoietic \nsystem.Suchextensions include function\u00adality for testing, upgrading, cloning, restarting, and killing \nallopoietic components. As a result, epi-aspects can be used to upgrade existing applications into conscientious \nsoftware in a non-invasive manner. This paper provides the conceptual design of epi-aspects, and proposes \na concrete framework for developing epi\u00adaspects in Java. The framework contains an autopoietic sim\u00adulator \nthat operates according to logic rules de.ned in the Prolog programming language. A Java epi-aspect advises \non a Java application and the autopoietic simulator. In ordertoevaluatethe potentialof epi-aspects,we \nperform a case study in which we use epi-aspects to upgrade an ex\u00adisting Java application into conscientious \nsoftware. The up\u00adgraded conscientiousJavaapplicationis usedto conductvar\u00adious tests, such as injection \nof programming errors, software upgradefailures, and data corruption. 1.1 Paper Organization Section2describes \nthe research contextin which this paper is set. Section 3 introduces an application scenario that is \nused throughoutthe paper for illustrative purposes. This ap\u00adplication scenarioisalsousedinthecasestudyin \nsection6to evaluate the potential of epi-aspects. The conceptual design of epi-aspects and the architecture \nof aspect-oriented con\u00adscientious software are described in section 4, and a frame\u00adwork for developing \nepi-aspects in Java is introduced in sec\u00adtion 5. Section7compares the epi-aspects architecture with closely \nrelated work. Section8discusses open problemsof epi-aspects, and the paperis concludedin section9. 2. \nResearch Context There are several areas of research dedicated to investigat\u00ading mechanisms for allowing \nsoftware systems to be self\u00adsustaining. Among them are autopoietic software systems, autonomic computing, \nre.ective and adaptive middleware, monitoring-oriented computing,and recovery-oriented com\u00adputing. Autopoietic \nsoftware systems were .rst proposed in the 1970s [21]. They have been widely considered a compu\u00adtational \nmodel and applied in the .eld of arti.cial intelli\u00adgence [22, 15]. During the 1980s the concept received \nless attention and was rediscovered in the late 1990s [16]. Since autopoiesis is widely considered a \ncomputational concept, most research focuses on algorithms and simulations of sim\u00adple autopoietic systems. \nGabriel and Goldman describe the paradigm of conscien\u00adtious software in [9], expanding on the concepts \nof autopoi\u00adetic software systems.According to their description, con\u00adscientious software consists of \nan allopoietic part, which en\u00adcapsulates application functionality, and an autopoietic part, which is \nresponsible for keeping the system alive. Fleiss\u00adner and Baniassad proposeaconcrete autopoietic-allopoietic \nsoftware architecture, which is based on the biological con\u00adcept of commensalistic symbiosis, in [8]. \nIn a related effort, IBM devised the notion of autonomic computing [13, 17]. It refers to concepts and \ntechnolo\u00adgies that enable software to become more self-managing. To achieve this goal, autonomic computing \nproposes four principles, which are self-con.guration, self-healing, self\u00adoptimization, and self-protection. \nAccording to [13], self\u00adcon.guration refers to software components and systems that automatically follow \na set of high-level con.guration policies. In case of policy changes, the entire system ad\u00adjusts itself \nautomatically. Self-optimization is a process in which components continually seek opportunities to im\u00adprove \ntheir own performance. The self-healing process al\u00adlows the system to automatically detect and repair \nsoftware and hardware problems and the self-protection mechanism defends the system against malicious \nattacks and failures. The self-protection mechanism uses an early warning sys\u00adtem that allows anticipation \nand prevention of systemfail\u00adures. Researchers are exploring aspect-oriented approaches for realizing \nautonomic computing. For example, Engel et al. propose the usage of dynamic operating system aspects \nfor realizing autonomic software in [7], and Greenwood et al. describe how to use dynamic aspects for \nimplementing an autonomic system in [12]. Recent research in the .eld of re.ective and adaptive mid\u00addleware \n[2, 20, 14, 6] shares some goals with autonomic computing and conscientious software. As described in \n[11], opennessand dynamic self-adaptation are fundamental properties of re.ective middleware, and therefore, \nre.ec\u00adtive middleware is suited to support autonomic computing and self-sustaining systems.For instance, \nthe approachby Rasche et al. [19] proposes the usage of dynamic aspect weaving for recon.guration. The \nRainbow framework pro\u00adposed by Garlan et al. in [10] is a concrete adaptive middle\u00adware architecture \nthat uses monitoring and constraint evalu\u00adation for adaptation. Monitoring-oriented programming, as \ndescribed by Chen et al.in[3,4,5],isa practical programmingparadigmthat uses monitoring as the fundamental \nprinciple for implementing reliable software. The formal speci.cation of an application is used as the \nbasis for generating a set of monitors that are integrated into the software. During runtime, these monitors \nobserve the runtime behavior of the application and trigger user-de.ned routines, when a speci.cation \nis validated or violated. Recovery oriented computing(ROC),exploredbyPatterson et al. in [18], suggests \nplanning to incorporate or recover from a certain class of errors, rather than trying to prevent them \nfrom arising The major aim of recovery oriented com\u00adputing is to minimize the mean time to repair in \ncase a sys\u00adtemfailure occurs. In order to enablefast recovery aftera failure,ROC employsthe following \nsix techniques: Recov\u00adery experiments, diagnosis, partitioning, reversible systems, defense in depth, \nand redundancy. 3. Application Scenario Figure 2. Application Scenario Throughout this paper and in \nthe case study, we consider a concrete Java application to illustrate the various features of aspect \noriented conscientious software and epi-aspects. This applicationisaorderandinventorymanagement(OIM) \nsystem for a wholesale companythat specializes in modern andantiquebooks.Asshownin.gure2,thissystem consists \nof a HSQLDB database engine, an application server, and client applications that accessthis server through \nthe XML-RPC protocol. The application server contains two major components called Orders and Inventory, \nwhich implement business rules related to managing orders and the company s inventory. The staff of the \ncompany frequently request new features, and the system is continuously updated by a small team of developers. \nAlso, since certain antique books do not have the same properties as modern books, such as ISBN num\u00adbers, \noccasional changestothe database are necessary.Asa result, changes to the application server, database, \nand user interfaceofthe client applicationsare common,andthesys\u00adtem as a whole is constantly evolving. \nHowever, since the system is essential for the operation of the company, long down-times due to programming \nerrors or maintenance op\u00aderations are unacceptable. The order and inventory management system is developed \nand improved with the focus on features that are explicitly requested by staff of the wholesale company, \nand mecha\u00adnisms for self-maintenance and error recovery either receive alowpriorityorare omitted completely.Asaresult,thesys\u00adtem \nis bound to become more fragile over time, and a com\u00adpletefailureis possible. 4. Proposed Architecture \nThe proposed aspect-oriented conscientious software archi\u00adtecture (illustrated in .gure 1) consists of \nthree portions: An application (the allopoietic system), which imple\u00adments some desired functionality, \nsuch as the inventory management application described in section 3.  An autopoietic system, responsible \nforkeeping the sys\u00adtem alive.  Epi-aspects, which act as a bridge between the other two portions by \nextending the application with functional\u00adity related to self-sustainment, such as test routines and \nmaintenance function.  The following sections provide a detailed description of the aspect-oriented \nconscientious software architecture. Sec\u00adtion 4.1 covers the allopoietic application, section 4.2 illus\u00adtrates \nthe features and behavior of the autopoietic system, and section 4.3 describes the anatomy of epi-aspects. \n4.1 AllopoieticApplication This portion of the conscientious architecture is a traditional application, \nsuch as the OIM system described in section 3. No alteration of this application is necessary since all \ncon\u00adscientious functionality is encapsulated in the other two por\u00adtions of the system. In this paper \nwe assume object-oriented or component-based applications and we use the term appli\u00adcation entity to \nrefer to an instance of an object or compo\u00adnent.  4.2 Autopoietic system The autopoietic system is a \nnetwork of instances that con\u00adstantly observes itself, its environment, and the state of the application, \nwhich is exposed by epi-aspects. In case of any problems, such as errors in the application, the autopoi\u00adetic \nsystem makes queries, and recommendations to cor\u00adrect the problem. The autopoietic system does not employ \narti.cial intelligence: Software developers explicitly imple\u00adment the conditions for triggering autopoietic \nrecommenda\u00adtions and queries. Queries are used by the autopoietic sys\u00adtem to monitor the health of the \napplication. Recommen\u00addations are made either routinely, or based on the result of a query. Both recommendations \nand queries can be de.ned and customized by the developer of the autopoietic system. Our architecture \nprovides a core set of each, as listed in ta\u00adble 1(recommendations) andtable2(queries). Start, Stop, \nCreate, Destroy, Clone These suggestions are directed at application entities. Update Recommends to update \nthe application soft\u00adware. This can be directed at the whole appli\u00adcation or application entities. Revert \nAfter a software update, the autopoietic sys\u00adtem an advise the application to revert to the previous \nversion. This recommendation is used if a problematic software update is ap\u00adplied. Test Recommends to \ntest an application entity. Custom This recommendation allows the autopoietic system to advise the application \nto perform a custom task. Table 1. Autopoietic Recommendations In order to facilitate epi-aspects, \nwhich implement advice for recommendations and queries, the autopoietic system in\u00adcludes an internal \nrun-time weaver for epi-aspects, called the epi-weaver. The epi-weaver depends on the programming language \nused to implement the epi-aspects, because not all programming languages provide compatible approaches \nfor invoking methods or routines. In order to support a speci.c programming language, a customized weaver \nhas to be de\u00adveloped and integrated withthe autopoietic system. 4.3 Epi-Aspects The purpose of epi-aspects \nis to make the application visible to and controllable by the autopoietic system. In particular, epi-aspects \nare responsible for encapsulating self-sustaining concerns and anyfunctionality required for smooth interac\u00adtion \nbetween the autopoietic system and application. Reveal This query indicates that the autopoietic sys\u00adtem \nrequires information about speci.c appli\u00adcation entities or the application as a whole. For example, \nin order to evaluate the health of a component, autopoietic instances have to be able to examine its \ninternal state. Speed This query indicates that an autopoietic sys\u00adtem wishes to obtain information about \nthe current speed (performance) of a certain ap\u00adplication entity. Custom Allows speci.cation of custom \nqueries. The purpose of custom queries is to provide a.ex\u00adible mechanism for extendingthe autopoietic \nsystem. Table 2. Autopoietic Queries Since epi-aspects crosscut the autopoietic system and ap\u00adplication, \nthey support two types of advice: The .rst type advises on recommendations and queries of the autopoietic \nsystem, and performs required tasks, such as testing and other maintenance. The second type advises on \njoin points in the applicationandis responsibleforkeepingthe autopoietic system updated on the application \ns status and performance. Each epi-aspect contains: 1. An epi-queue,which is used to dispatch information \nfrom epi-aspects to the autopoietic system. 2. Application advice, which are responsible for providing \nfeedback on the application s health to the autopoietic system. This feedback is passed to the autopoietic \nsystem through the epi-queue.  3.Amechanism for de.ning advice on autopoietic recom\u00admendations and queries. \nSuch query advice and recom\u00admendation advice perform maintenance or update opera\u00adtions according to suggestionsby \nthe autopoietic system, or to provide information to satisfy an autopoietic query. As epi-aspects implement \nadvice for both application and autopoietic system,theyhavetobewoven twicebydifferent weavers: One weaver \nis responsible for weaving application advice during compilation or at run time. The other weaver is \nthe epi-weaver of the autopoietic system. For example, let s consider an epi-aspect denoted as DatabaseEpiAspect, \nwhich is part of an upgrade to turn the OIM service intro\u00adducedin section3into conscientious software. \nThe applica\u00adtion advice of this epi-aspect are woven into the code of the database engine during compile-time, \nand the recommenda\u00adtion and query advice are woven into the autopoietic system during run-time. Sender, \nReceiver Type Contents Both autopoietic instances and application entity can acts as sender andreceiver. \nIndicates the type of the epi-message. Can be one of the following: Parameter: Epi-message is passed \nto an autopoietic recommendation or query advice as parameter. Answer: Epi-message is an answer to an \nautopoietic query. Feedback: Epi-message contains feed\u00adback regarding the allopoietic applica\u00adtion. \n Error: Epi-message reports an error that occurred in the allopoietic application. Epi-Error: Epi-message \nreports an error that occurred in an epi-aspect. Contains the contents of the message. The format of \nthis message could be anything from strongly typed data over XML to nat\u00adural language. The only requirement \nis that both autopoietic instances and epi-aspects are able to interpret this format. Table 3. Epi-Message \nAttributes 4.3.1 Epi-Messages andEpi-Queue The autopoietic system and epi-aspects communicate by exchanging \nepi-messages, which consist of the attributes shown in table 3. The autopoietic system can pass epi\u00admessages \nas parameters to recommendation and query ad\u00advice implemented by epi-aspects. Each epi-aspect has access \nto an epi-queue, which can be used to dispatch information to the autopoietic system. Be\u00adfore an epi-aspect \nis woven into the autopoietic system, it merely contains a stub for the epi-queue that does not contain \nany functionality. When the epi-weaver processes an epi-aspect,it does not only weave recommendation \nand query advice,but also injectsa concrete implementationof the epi-queue. This approach ensures that \nepi-aspects do not depend on the concrete realization of the autopoietic system. 4.3.2 Application advice \nApplication advice are de.ned on joint points in the allopoi\u00adetic application. Their purpose is to observe \none or more speci.c application entities and to expose their state to the autopoietic environment. Depending \non the join point it ad\u00adviseson,the implementationofanapplication advicegathers and optionally forwardsinformation \nto the autopoietic sys\u00ad Error Creation Advice for errors or exceptions gather as much information on \nthe error as possi\u00adble, including the source of and reason for the error, and then dispatch this infor\u00admation \nto the autopoietic system via the information queue. For example, in the OIM service, error application \nadvice can be de.ned for exceptions thrown by the database engine and XML-RPC service. Advice for creation \njoin points are re\u00adsponsible for informing the autopoietic system which application entities, such as \nobjects, components, and modules, exist. The autopoietic system uses this informa\u00adtion to decide which \nentities should be monitored. Performance Performance advice are invoked before and after certain methods \nor procedures in the application. Their purpose is to mea\u00adsure the execution time of methods and report \nit to the autopoietic system. This al\u00adlows the autopoietic system to keep track of the application s \nperformance and de\u00adtect possible timeouts. Table 4. Application Advice tem. Information is dispatched \nto the autopoietic system via the epi-queue. Existing aspect-oriented programming languages, such as \nAspectJ, provide suf.cient pointcut primitives to describe most of the application join points required \nby epi-aspects. As a result, epi-aspects can be realized as an extension of existing aspect-oriented \nprogramming languages. The following application-level joinpoints are required by the epi-aspect architecture: \n Create:Creation of a new application entity, such as the construction of an object.  Destroy: Destruction \nof an application entity, such as a component or object.  Error:Unexpected errors or exceptions.  Invocation/Execution:Invocation \nandexecutionof meth\u00adods.  Event:Events, in an event handling system.  Set:Setting of a variable or \npropertyvalue.  Table4providesthe detailsofhowaselectionofthe appli\u00adcation advice might be used.  4.3.3 \nQuery and Recommendation Advice Query and recommendation advice implement maintenance and information \nretrieval operations proposed by the au\u00adtopoietic system. Theyarewoven into the autopoietic system by \nthe epi-weaver at runtime. Developers of the OIM system might implement recommen\u00addation advice to implement \na unit test to verify the proper operation of the XML-RPCcomponent, or to apply updates to the OIM system. \nTheymay implement a queryadvice to implement an evaluator that obtains the current speed of the XML-RPC \nrequests per minute. That implementationwould advise on the Speed suggestion, andwould help the autopoi\u00adetic \nsystemtokeep trackofthe sizeoftheworkloadonthe XML-RPC component. Query and recommendation advice consist \nof two portions: Header,which contains the attributesname and receiver\u00adpattern. The name attribute is \nthe name of a prede.ned (see tables1and2) or custom recommendation or query. The receiver-pattern attribute \ncontains a regular expres\u00adsion for matching the target application entity.  Implementation,which contains \nthe allopoietic code for implementing the requested action. It uses epi-messages as input and output \nparameters as a means for communi\u00adcation between the autopoietic system and epi-aspect.  5. Epi-AspectsJava \nFramework This section speci.es a framework for developing aspect\u00adoriented conscientious software in \nJava. This framework, which is called Epi-AJ, provides an autopoietic simulator and constructs for implementing \nepi-aspects in the Java pro\u00adgramming language. The autopoietic simulator includes a weaver for epi-aspects, \nand contains a logic engine imple\u00admented in the Prolog programminglanguage, which imple\u00adments the behavior \nof the autopoietic system described in section 4.2. The Epi-AJ framework is designed as a supplement \nto Aspect-J. Since version 5, AspectJ has supported the usage of Java annotations for de.ning aspects \nand advice. Epi-AJ providesasetofJava annotations,whichallowthe de.nition of autopoietic recommendation \nand query advice. As a re\u00adsult, an epi-aspect can be implemented using a combination of AspectJ annotations \nand Epi-AJ annotations. The usage of annotationsis convenientina sense thatitis not necessary to usetoolslikethe \nAspectBench compiler[1]toextendthe grammaroftheAspectJ pointcutlanguagewithnewpointcut primitivesfor \nepi-aspects. Listing1illustrates the de.nition of an epi-aspect using the combination of Aspect-J and \nEpi-AJ. The Epi-AJ framework is divided into three Java packages: 1. The package conscientious.epiaj(shown \nin .gure 3) con\u00adtains the base classes and interfaces of the framework. 1 2 3 4 5 6 7 8 9 10 11 12 13 \n14 15 16 17 18 19 20 21 22 @Aspect public class XMLRPCEpiAspect extends EpiAspect { @After( this(s) \n&#38;&#38; execution(XMLRPCService.new( ..)) ) public void newInstance(XMLRPCService s) { /* ... * /} \n @AfterThrowing( target(s) &#38;&#38; execution(* XMLRPCService.run( ..)) ) public void reportException(XMLRPCService \ns) { /* ... * /} @RecommendationAdvice(recommendation= start , recipientPattern= . * ) public EpiMessage \nstartXMLRPCServer(EpiMessage message){ /* ... * /} @CloneRA( org .apache .server . * ) public EpiMessage \ncloneXMLRPCServer(EpiMessage message){ /* ... * /} @QueryAdvice(query= speed , recipientPattern= org \n.apache .server . * ) public EpiMessage getCurrentXMLServerSpeed(EpiMessage message){ /* ... * /} @RevealQA( \n. * ) public EpiMessage revealObjects(EpiMessage message){ /* ... * /} /* ... * / } Listing 1. Epi-Aspect \nExample Code(Epi-AJ Framework) 2. The package conscientious.epiaj.annotations contains annotations for \ndeclaring autopoietic recommendation and query advice in epi-aspects. 3. The package conscientious.simulator \ncontains the Java part of the autopoietic simulator, such as the implemen\u00adtations of the epi-weaver and \nepi-queue.  5.1 Base Classes and Interfaces As illustrated in .gure 3, The Epi-AJ framework provides \nthe following set of base classes and interfaces for realiz\u00ading epi-aspects, epi-messages, and epi-queues: \nEpiAspect, EpiQueue, and EpiMessage. As described in section 4.3.1, epi-aspects and the autopoi\u00adetic \nsystem communicatebyexchanging epi-messages. Each epi-aspect has access to an epi-queue thatallows them \nto dis\u00adpatch epi-messages to the autopoietic system. The abstract class EpiAspect is the base class for \nepi\u00adaspect implementations, EpiQueue de.nes the interface of epi-queue implementations, and the class \nEpi-Message is the implementation of the epi-message illustrated in table 3. The EpiAspect class contains \nan instance variable whose type is the EpiQueue interface. When an the implementa\u00adtion of an epi-aspect \nis woven, the autopoietic system (or autopoietic simulator) assigns a concrete epi-queue imple\u00admentation \nto this instance variable. After that, the epi-aspect implementation can start dispatching epi-messages \nto the au\u00adtopoietic system. The Epi-Message class contains four instance variables, which are equivalent \nto the epi-message attributes Sender, Receiver, Type, and Contents described in table 3. 5.2 Advice \nand Annotations The Epi-AJ framework provides the following set of Java annotations for declaring recommendation \nand query advice: @RecommendationAdvice(name, receiverPattern)  @QueryAdvice(name, receiverPattern) \n @RevealQA(receiverPattern)  @SpeedQA(receiverPattern)  @TestRA(receiverPattern)  Figure 3. Epi-AJ \nBase Classes @UpdateRA  @RevertRA(receiverPattern)  @CloneRA(receiverPattern)  @CreateRA/@DestroyRA(receiverPattern) \n @StartRA/@StopRA(receiverPattern)  All annotations have a receiverPattern attribute that can be used \nto specify a regular expression for matching the class/epi-aspect at which the autopoietic recommendation \nor query is directed. The @RecommendationAdvice and @QueryAdvice annotations are generic annotations \nthat can be used to declare advice on any autopoietic recommen\u00addation and query, including custom recommendations \nand queries. The remaining annotations are provided for conve\u00adnience and can be used to specify advice \nonthe pre-de.ned autopoietic recommendations and queries described in tables 1and 2. As shown in listing \n1, the implementation part of the rec\u00adommendation and query advice is a Java method that re\u00adceives an \nEpiMessage object as parameter and returns an\u00adother EpiMessage object to the autopoietic system. The \nEpiMessage parameterissetupbythe autopoieticsystemto specify details regarding the recommendation or \nquery, and the EpiMessage return value contains feedback or other in\u00adformation for the autopoietic system. \n 5.3 Autopoietic Simulator The Epi-AJ framework provides an autopoietic simulator that can be usedfor \ndeveloping and testing epi-aspects. This simulator consists of a runtime, an epi-weaver written in Java, \nand uses the Prolog programminglanguage to imple\u00adment the rules of the autopoietic system. Prolog is \nnot an au\u00adtopoietic programming language that is speci.callydesigned to preventbugs that can leadto program \ncrashes. However, as the design of an autopoietic programming language is not within the scope of this \npaper, Prolog is a suitable substitute for simulation purposes, because it is declarative and it is not \neasy to write a Prolog program that crashes. The autopoietic simulator can be invoked from a Java program \nby creating and con.guring an instance of the Simulator class shown in .gure 4. Internally,the Simulator \nclass uses the SWI Prolog engine to simulate the behavior of the autopoietic system. Interaction between \nthe Simulator instance and the SWI Prolog engine is accomplished through the JPL (Java Interface to Prolog) \nAPI, which is part of the SWI Prolog distribution. Figure 4. Epi-AJ Autopoietic Simulator When a new \ninstance of the Simulator class is created, the calling application provides a list of epi-aspects. During \nits initialization, the Simulator instance performs the follow\u00ading tasks: 1. The SWI Prolog engine is \ninitializedand the Prolog pro\u00adgram(s) mimicking the autopoietic systems are loaded. 2. An instance of \nthe AdviceRepository shownin .gure4 is created. 3. An instance of the Weaver class is created and the \nlist of epi-aspects is passed to it.  4. The Weaver instance weaves the epi-aspects into the AdviceRepository \ninstance. Moreover, it injects an in\u00adstance of the EpiQueueImp class, which implements the simulators \nepi-queue into eachwoven epi-aspect. 5. The Simulator instance issues the autopoietic recom\u00admendation \nStart, which is dispatched to all woven epi\u00adaspects.  Once the autopoietic simulator is running, the \nwoven epi\u00adaspects can dispatch epi-messages to it via the EpiQueueImp instance. Whenever an epi-message \nis received, the Prolog program(s) are invoked and the result can be an autopoietic recommendations or \nquery. Autopoietic recommendations andqueries are dispatchedto relevant adviceofthewoven epi-aspects. \n6. Case Study This section describes a case study that was conducted to evaluate the potential of aspect-oriented \nconscientious soft\u00adware. The .rst part of this study, whichis described in sec\u00adtion 6.1, illustrates \nhow to apply epi-aspects and the Epi-AJ framework to turn the order and inventory management (OIM) system \nintroduced in section 3 into conscientious software. The second part in section 6.2 describes experi\u00adments \nand studies that were conducted to test and evaluate the conscientiousversionofthe OIM system. Figure5 \nshowsa more detailed viewof the OIM system s design, and highlights the main Java classes of the OIM \nsystem: XmlRpcService, OrderManager, OimService , InventoryManager,DbConnectionPool,UserAccounts and \nDbConnection. Figure 5. OIM System Classes The XmlRpcService class uses Apache s XML-RPC distri\u00adbution \nto initialize a HTTP server that accepts XML-RPC requests. This server uses re.ection to map incoming \nXML-RPC requests to an instance of the OimService class. Ad\u00additionally, it converts return values provided \nby methods of the OimService instance into XML-RPC responses. Even though Apache s XML-RPC distribution \nis mature and stable, these classes can generate critical exceptions in case of invalid requests and \nnetwork problems. ThebusinesslogicoftheOIM systemis implementedbythe OrderManager, InventoryManager, \nand UserAccounts classes. The OIM system uses the HSQLDB database engine. The database is accessed via \nthe classes DbConnectionPool and DbConnection. The class DbConnectionPool main\u00adtains a pool of re-usable \nDbConnection instances, which provide access to the database via the JDBC driver supplied with the HSQLDB \ndistribution. The class UserAccounts implements user management and authentication. 6.1 Implementation \nOverview The purpose of the .rst part of this case study is to use epi-aspects and the Epi-AJ framework \nto upgrade the OIM system into conscientious software. The aim of this upgrade is to make the OIM system \nobservable and controllable by an autopoietic system. The following sections describe the implementation \nof four epi-aspects, which add necessary conscientious extensions to the OIM system: software maintenance, \nXML-RPC mon\u00aditoring, Database monitoring, and OIM system monitoring. This upgradeis non-invasive, sinceitis \nunnecessaryto mod\u00adify the existing source of the OIM system, the HSQLDB en\u00adgine, and Apache s XML-RPC \ndistribution. 6.1.1 Software Maintenance Epi-Aspect The software maintenance epi-aspect (.gure 6(a)) \nimple\u00adments functionality for updating and reverting the compo\u00adnents of the OIM system. It provides advice \nfor the autopoi\u00adetic Update and Revert recommendations. When the soft\u00adware maintenance epi-aspect is \ninitialized, it creates a mini\u00admal HTTP service, which developers can use to submit soft\u00adware updates \nvia a web-browser. Whenever the software maintenance epi-aspect receives an update through the HTTP service,it \ndoes not immediately installtheupdate,but storesitforlateruse,and dispatchesan epi-message to notify \nthe autopoietic system that an update isavailable.Ifthe autopoietic system approvesofthe update, it .rst \nissues recommendations to affected components to prepare for an imminent update, and then issue the Update \nrecommendation, which causes the software maintenance epi-aspect to install the update. If the autopoietic \nsystem notices that certain componentsex\u00adperience problems after an update, such as uneven perfor\u00ad Figure \n6. Case Study Epi-Aspect Design mance, it can issue a Revert recommendation that indicates that the problematic \ncomponent should be reverted to a pre\u00advious version. The software maintenance epi-aspect imple\u00adments \nan advice on the Revert recommendation that checks if a previous version of the affected component exists. \nIf a previous version is available, the advice disables the current version, and re-installs thepreviousversion. \n 6.1.2 XML-RPC Epi-Aspect The OIM system is accessed by clients via the XML-RPC protocol. The service \nproviding this access is implemented by the XmlRpcService class, which utilizes Apache s XML-RPC distribution. \nIt is imperative for the OIM system that the XML-RPC service does not fail. The XML-RPC epi-aspect (.gure \n6(d)) is responsiblefor implementing er\u00adror recovery, testing and application monitoring concerns. It \nalso implements an observer feature to evaluate and store the current speed of the XML-RPC service. The \nspeed is de.nedasthetime requiredtoexecuteadummy XML-RPC request. 6.1.3 Database Epi-Aspect The database \nepi-aspect (.gure 6(c)) encapsulates function\u00adality that allows the autopoietic system to observe and \nin\u00adterfere with the operation of the HSQLDBdatabase engine. In addition, the database epi-aspect implements \ndatabase backup and recovery features. The backup feature period\u00adically backs up the database .les and \nallows restoring the database to a previous version. It is useful for preventing problems related to \ndata corruption. Thedatabase epi-aspect records all SQL commands that are issuedto the HSQLDB engine \nfrom within the OIM system. This recorded history can be used for undoing changes to the database and \nits schema. 6.1.4 OIM Epi-Aspect The OIM epi-aspect (.gure 6(b)) is responsible for ex\u00adposing the health \nof the main classes of the OIM system, namely UserAccounts, OIMService, OrderManager, and InventoryManager \nto the autopoietic system. Addition\u00adally, the OIM epi-aspect extends these main classes with functionality \nto comply recommendations issued by the au\u00adtopoietic system.  6.2 Experiments and Studies One experiment \nand one study were conducted to evaluate the potential of the conscientious OIM system. The experi\u00adment \nevaluates ability of the conscientious OIM to recover from buggy updates, and the study illustrates the \nprocess of extending the conscientious OIM system with a .ner\u00adgrained monitoring and recoverymechanism. \n 6.2.1 Software Update Experiment In the software updateexperiment,working andbuggy up\u00addates are applied \nto the original and conscientious OIM sys\u00adtems, and the behavior of the systems during and after the \nupdate is observed, compared, and evaluated. The experiment consists of two phases and each phase con\u00adsists \ntwo parts: Inthe.rstpart,theexperimentisconductedwiththe original OIM system, which does not make use \nof any epi-aspects. In the second part, the experiment is repeated using the conscientiousversionoftheOIM \nsystemandthe autopoietic simulator. Then the results of both parts are compared and evaluated. The experiment \nuses the original OIM system, the consci\u00adentious OIM system, the autopoietic simulator, and an addi\u00adtional \nsimulator that mimics the behavior of a client appli\u00adcation that accesses the OIM system. This clientapplication \nsimulator can be con.gured to generate a speci.c number of requests per minute, allowing adjustment of \nthe workload that the OIM system has to handle. The client application simulator uses a log .le to record \nrequests results and ex\u00adceptions that occur when accessing the OIM system. Phase1: InstallWorkingUpdate \nAworking update of the XmlRpcService class is installed, and the necessary steps and time required for \nupdating the original and conscientious OIM systems are compared. This phase is initialized by performing \nthe following steps: 1. Start the original OIM system. 2. Start the conscientious OIM system and autopoietic \nsim\u00adulator. 3. Start two instances of the client simulator and con.gure them to issue one request per \nsecond to the original and conscientious OIM systems. These instances are denoted as client simulator1,which \nissues requests to the original OIM server, and client simulator2, which issues requests to the conscientious \nOIM server.  After phase one has been initialized, the following steps are executed in sequence: 1. \nManually overwrite the Java class .le of the XmlRpcService class in the originalOIM system with the new \nversion. 2. Shutdown and restart the original OIM system. 3. Use the HTTP update service of the software \nmainte\u00adnance epi-aspect to submit the sourcecode of the updated XmlRpcService classtothe conscientiousversionofthe \nOIM system.  The results of the .rst phase are shown in table 5. While the update is successful for \nboth the original and consci\u00adentious OIM, the original OIM system has to be restarted which makes the \nsystem unavailable for approximately 17 seconds. This short period causes a number of XML-RPC requests \nissued by the client simulator 1 to fail. The con\u00adscientious OIM system, however, experiences no downtime, \nbecause the software update epi-aspect applies and initial\u00adizes the updated version of the XmlRpcService \nclass in the background and then immediate replaces the old instance with the new one. This result indicates \nthat the conscien\u00adtious OIMversionis more suitablefor being updated during production use. Original OIM \nUpdate successful. Approx 17 sec\u00adonds downtime, because the entire OIM system is restarted. Client Simulator \n1 Log .le indicates 19 failed re\u00adquests. Conscientious OIM Update successful. No downtime. Client Simulator \n2 Log .le indicates no failed re\u00adquests. Table 5. Software Update ExperimentPhase1Results Phase 2: Install \nBuggy Update Inthe secondphaseabuggyupdateofthe XmlRpcService classis installed. Thebugin this updateisa \nlatentbug that causes criticalfailure afterthe XmlRpcService instance has been running for approximately \none hour. This phase uses the same steps as the .rst phase,except that the updatedver\u00adsion of the XmlRpcService \nclass contains a latent critical bug that starts causingfailures afterapproximately one hour. After the \nupdates are applied to both OIM systems, their be\u00adhavior is observed for three hours. Table6shows the \nobservation log of the second phase. As the observation log indicates, the XML-RPC service of the original \nOIM systemfails after approximately 61 minutes. The conscientious OIM system restarts the XML-RPC ser\u00advice \nafter it causes an initial exception in the 61st minute of the experiment. The restart prevents further \nexceptions for approximately one hour. When exceptions start occur\u00adring again in the 125th minute of \nthe experiment, the con\u00adscientious OIM system reverts the XML-RPC service to its previous version and \ncontinues running smoothly until the end of the experiment.  6.2.2 Fine-Grained Monitoring Study The \npurpose of this study is to illustrate the software de\u00adsign and development process of aspect-oriented \nconscien\u00adtious software by extending the conscientious OIM system with a .ner-grained error monitoring \nand recovery mecha\u00adnism. This extension involves extending the OIM epi-aspect as well as writing new \nrules for the autopoietic simulator. Here, we describe the design and implementation, and the Experiment \nEvent Time (Min) 61:23 First exception in the XmlRpcService in\u00ad stance the original OIM system. 61:27 \nFirst exception in the XmlRpcService in\u00ad stance the conscientious OIM system. 61:27 The autopoietic simulator \nrecommends to restart the XmlRpcService instance of the conscientious OIM system, which is done by the \nXML-RPC service epi-aspect. 61:29 The XmlRpcService instance of the origi\u00ad nal OIM system terminates. \nOriginal OIM system not accessible. 125:14 Exception in the XmlRpcService instance the conscientious \nOIM system. Autopoi\u00adetic simulator recommends reverting the XmlRpcService to a previous version, which \nis done by the software mainte\u00ad nance epi-aspect. 180:00 Conscientious OIM system is still running properly. \n Table 6. Software Update Experiment Phase2Log approach for testing the extended conscientious OIM sys\u00adtem. \nThe .ner-grained error monitoring and recovery mecha\u00adnism maintains a history of exceptions for the each \nof the classes UserAccounts, OIMService, OrderManager, and InventoryManager. The functionality for the \nexception history is implemented by a component that is added to the OIM epi-aspect. Wheneveranexception \noccursin oneofthe OIMmain classes,this componentmakesanentryintoalog .le associated with the class that \nthrew the exception. Apart from creatingthe entries, the component counts the number ofexceptionsin pre-de.ned \nintervals.The numberofexcep\u00adtions per interval is recorded and submitted the numbers of exceptions for \nthe .ve most recent intervals are submitted to the autopoietic system via the epi-queue. The autopoietic \nsimulator requires additional rules for pro\u00adcessing the epi-messages containing the exception counts \nof the .ve previous intervals: 1. If the number of exceptions for the current interval is greater than \nzero, issue a Test suggestion. The corre\u00adsponding advice in the OIM epi-aspect veri.es the re\u00adsponsiveness \nof the OIM system classes. If the testfails, the default rules of the autopoietic simulator trigger a \nRestart suggestion. 2. If the number of exceptions between the four previous and current interval have \nincreased more than a pre\u00adde.ned threshold, issue a Restart suggestion. To test the proper operation \nof the implementation of the .ne-grained monitoring feature, updated versions of the classes OIMService \nand OrderManager, which randomly throw non-critical and critical exceptions, are added to the conscientious \nOIM system. Non-critical exceptions do not affect the proper operation of instances of these two classes, \nand critical exceptions lead to a crash of the OIM system. The testis run accordingtothe following protocol: \n1. The updated OIM epi-aspect, autopoietic rules, new ver\u00adsions of OIMService are OrderManager are deployed \nin the conscientious OIM system. 2. The component in the OIM epi-aspect is con.gured to use intervals \nof three minutes. 3. The autopoietic simulator is con.gured to use 10 excep\u00adtions as the thresholdvalue \nfor triggering Restart sugges\u00adtion. 4. One instance of the client simulator is started with the same \ncon.guration used in the software update experi\u00adment described in section 6.2.1. 5. Let the experiment \nrun for 120 minutes.  This test can only fail if there is an implementation error in the OIM epi-aspect. \nAfter the test is run successfully, the development of the .ne-grained monitoring feature is completed. \n7. ComparisonWith RelatedWork The goals of self-sustainment and self-adaptation are not limited to conscientious \nsoftware. As described in section 2, autonomic computing, monitoring oriented programming, and re.ective \nand adaptive middleware attempt to tackle the same issue using various approaches. This section compares \nepi-aspects with concrete architectures proposed within these .elds. 7.1 Re.ective and Adaptive Middleware \nThe Rainbow [10] and Adapta [20] frameworks are concrete adaptive and re.ective middleware architectures. \nThe Rainbow framework by Garlan et al. consists of an ar\u00adchitecture layer, a system layer, and a translation \ninfrastruc\u00adture. The system layer contains application functionality and so-called effectors and probes. \nEffectors are components that carry out system modi.cations and probes observe the ap\u00adplication. The \ninformation collected by probes can be pub\u00adlished and queried by the architecture layer. In the archi\u00adtecture \nlayer information from the probes is aggregated and used to maintain an architectural model, which is \nperiodi\u00adcally evaluated by a constraint evaluator. If a constraint vio\u00adlation occurs, an adaptation engine \ncarries out corresponding actions via effectors. The translation infrastructure is respon\u00adsible for transmitting \ninformation between the two layers. The epi-aspects architecture and Rainbow framework both separate \napplication functionality from an observation and adaptation mechanism. In the epi-aspects architecture, \nthe observation and adaptation mechanism is the autopoietic system and in the Rainbow framework, this \nmechanism is the constraintevaluatorin the architecture layer.A signi.\u00adcant difference of both architectures \nis that an epi-aspect en\u00adcapsulates the functionality of probes, effectors, and trans\u00adlation infrastructure, \nwhich are separate components in the Rainbow framework. Adapta by Sallem et al. is a CORBA-based re.ective \nmid\u00addleware for developingadaptive, component-based applica\u00adtions.Like the Rainbow framework, and the \nepi-aspects ar\u00adchitecture, it aims at separating application code from the code responsible for adaptation.Adapta \nhasa runtime envi\u00adronment providing monitoring and trigger functionality. This environment can be con.gured \nby a XML-based recon.g\u00aduration language denoted as AdaptaML. This language al\u00adlows developers to con.gure \nmonitoring components, to de\u00ad.ne local and distributed events, and to specify recon.gura\u00adtion actions \nthat are applied to the application in response to events. Adapta and the Rainbow framework focus primarily \non adaptation, which is just one feature of the epi-aspects ar\u00adchitecture. In comparison, the strength \nof the epi-aspects ar\u00adchitecture is .ner-grained error recovery, as epi-aspects can advise on exceptions \nand directly access the internal state of instances within the application. 7.2 Monitoring-Oriented \nProgramming (MOP) As described in [5], monitoring-oriented programming is a programming paradigm build \nupon runtime veri.cation techniques that aims supporting reliable software via mon\u00aditoring and error \nrecovery. The formal speci.cation of an application is used as the basis for generating a set of moni\u00adtors \nthat are integrated into the software.Chen et al. propose a concrete development Java development tool \ndenoted as Java-MOP in [4], which provides user interfaces for editing and processing speci.cations for \ngenerating monitors. Java-MOP is not directly comparable with the epi-aspects architecture, because it \nis essentially a compiler for monitor speci.cations. The epi-aspects architecture on the other hand isa \nruntimeanddevelopmentenvironmentfor conscientious software based on aspect-oriented programming. Chen \net al. also propose an aspect-oriented approach for MOP in [5], in which the formal speci.cations are \nencapsulated in abstract aspects. LikeJava-MOP this aspect-oriented MOP tool is not dynamic, since the \nformal speci.cations are translated into monitors before runtime. Like the epi-aspects framework, monitoring-oriented \npro\u00adgramming can be used to implement .ne-grained error detection and recovery, and mechanisms for adapting \nthe system. However, depending on the implementation MOP application are not necessarily dynamic and \nadaptive in a sense that a running system can be adjusted. It is possible to consider conscientious software \nand hence the epi-aspects framework as anextensionofthe MOP paradigm. 8. Discussion This section discusses \nopen issues and limitations of au\u00adtopoietic conscientious software architecture, the proposed architecture, \nand the Epi-AJ framework that are not ad\u00addressedin the other partsofthe paper. 8.1 Limitations of Epi-Aspects \nThe proposed architecture encourages a clear separation be\u00adtween application functionality and an autopoietic \nsystem for monitoring, regulation, and error recovery. This archi\u00adtectural separation is a shift in software \nengineering prac\u00adtice, which focuses on application functionality and often ne\u00adglects well-known error \nrecovery and adaptation techniques. Since the autopoietic system is not an arti.cial intelligence, but \nimplementedbydevelopers whohave designed rules for keeping an application running as smoothly as possible, \ncer\u00adtain unpredictable conditions can still cause the application to perform unwantedactions. Criticalfailures \nthat crash the system can be handled by the autopoietic system. However, it is not possible to prevent \nan application from doing some\u00adthing it is not supposed to do. As such, the epi-aspects archi\u00adtectureis \nproneto humanfailure. A practical issue of epi-aspects not addressed in the previ\u00adous sections is the \nproblem of potentialbuggy epi-aspects. Since epi-aspects can contain a signi.cant amount of code, the \nintroductionof latentbugsis possible.Asa result, epi\u00adaspectshavetoprovidea mechanism that reliably performs \nself-updates.One possible approachisthe usageofa meta epi-aspect that monitors the epi-aspects for internal \nprob\u00adlems. Another issue is the update of epi-aspects. In the case study, we only implement a dedicated \nepi-aspect that provides a mechanismfor updatingtheclassesoftheOIM system,but not the epi-aspects. The \nmost straightforward approach for dealing withthe issueisto implementa dedicated epi-aspect that provides \nfunctionality for reliably updating other epi\u00adaspects and itself.  8.2 RealizingAnAutopoietic system \nThe autopoietic simulator of the Epi-AJframework is meant for development and test purposes. In order \nto use epi\u00adaspects in real world applications, the development of a full autopoietic system is necessary. \nApart from the lack of au\u00adtopoietic programming languages as envisioned by Gabriel and Goldman in [9], \nthe following issues have to be ad\u00addressed. The .rst question is how to implement and deploy an au\u00adtopoietic \nsystem.One optionistoimplementisasa program that runs directly on the computer s hardware and providesa \nvirtual machine for running an operating system, similar to VMWare or Colinux. The advantage of this \napproach is that the autopoietic system does not depend on other software, which might be buggy. Furthermore, \ncomponents, drivers, and applications of the operating system can be realized as aspect oriented conscientioussoftwarethatiswovenintothe \nautopoietic system on startup. Another similar option is running the autopoietic system on top of an \nexisting, stable operating system kernel, which provides hardware abstraction, basic services, and includes \ndrivers. Athird option is to implement the autopoietic system as an application running on an operating \nsystem or inside a vir\u00adtual machine. Advantages are that this approach has lower implementation complexity. \nThe major disadvantage is that the autopoietic system depends on an operating system or virtual machine \nand therefore is only as stable as the under\u00adlying software. Another technical issue that has to be resolved \nare the exact mechanisms for invoking recommendation and query advice woven into the autopoietic system, \nand for transporting mes\u00adsages from epi-aspects tothe autopoietic system via an epi\u00adqueue. If autopoietic \nsystem and application run in the same process, which is the approach used by the autopoietic sim\u00adulator, \nthis issue is trivial. However, running the autopoietic system and application in the same process defeats \nthe pur\u00adposeof conscientious software, becausea criticalfailurein the application might terminate the \nprocess and thus the au\u00adtopoietic system. 9. Conclusion This paper proposes a concrete aspect-oriented \narchitecture for realizing conscientious software as envisionedbyGabriel and Goldman in [9]. Apart from \nproposing and describing the conceptual architecture, which introduces epi-aspects as a construct for \ncombining an autopoietic system and appli\u00adcations into working conscientious software, we design and \nimplement Epi-AJ, a framework for implementing and test\u00ading aspect-oriented conscientious applications. \nFurthermore, we conduct an experimental case study to evaluate the po\u00adtential of the proposed architecture \nand Epi-AJ framework. The resultsofthe case study show thatin comparison witha plain Java application, \nan aspect-oriented conscientious ap\u00adplication adapts better to changes and problems that we in\u00adtroduced \nin our controlled test environment. The research presentedin this paperis only the .rst step to\u00adwards \ncreating a solid aspect-oriented architecture for con\u00adscientious software that is suitable to be used \nin real-world applications.Weexpect further researchto focusontwoar\u00adeas: One area is the design of an \nautopoietic programming language that can be used to implement the autopoietic sys\u00adtem of the aspect-oriented \nconscientious software architec\u00adture. The second area is experimental and comparative re\u00adsearch that \ncontinues to validates and compare the proposed architecture to other techniques for creating self-sustaining \nsoftware, such as autonomic computing, re.ective and adap\u00adtive middleware, and monitoring oriented programming. \nAcknowledgments We would like to thank our shepherd Doug Lea who pro\u00advided guidance and helpful feedback \non improving this pa\u00adper. We would also like to thank Ron Goldman, and the anonymous reviewers for their \ncomments and direction. References [1] P. Avgustinov, A. S. Christensen, L. Hendren, S. Kuzins, J. Lhotk, \nO. Lhotk, O. de Moor, D. Sereni, G. Sittampalam, and J. Tibble. abc : An extensible aspectj compiler. \nTransactions onAOSD, (1):293 334, 2006. [2] G.S. Blair,G. Coulson, andP. Grace. Research directionsin \nre.ective middleware: the lancaster experience. In ARM 04: Proceedings of the 3rdworkshop on Adaptive \nand re.ective middleware, pages 262 267, New York, NY, USA, 2004. ACM Press. [3]F.ChenandG.Ros\u00b8u.Towards \nmonitoring-orientedprogram\u00adming:Aparadigm combining speci.cation and implementa\u00adtion. In Workshop on \nRuntimeVeri.cation(RV 03), volume 89(2) of ENTCS, pages 108 127, 2003. [4] F. Chen and G. Ros\u00b8u. Java-mop: \nA monitoring oriented programming environment for java. In Proceedings of the Eleventh International \nConference onTools and Algorithms for the construction and analysis of systems (TACAS 05), volume 3440 \nof LNCS, pages 546 550. Springer-Verlag, 2005. [5] F. Chen and G. Ros\u00b8u. Mop: Reliable software development \nusing abstract aspects. Technical Report UIUCDCS-R-2006\u00ad2776, Department of Computer Science, University \nof Illinois at Urbana-Champaign, 2006. [6]F. Eliassen,E. Gj\u00f8rven,V.S.W. Eide, andJ.A. Michaelsen. Evolving \nself-adaptive services using planning-based re\u00ad.ective middleware. In ARM 06: Proceedings of the5th workshop \non Adaptive and re.ective middleware (ARM 06), page1,NewYork,NY, USA, 2006.ACM Press. [7] M. Engel and \nB. Freisleben. Supporting autonomic com\u00adputing functionality via dynamic operating system kernel aspects. \nIn AOSD 05: Proceedings of the 4th international conference on Aspect-oriented software development, \npages 51 62,NewYork,NY, USA, 2005.ACM Press. [8] S. Fleissner and E. Baniassad. Acommensalistic software \nsystem. In OOPSLA 06: Companion to the 21st annual ACM SIGPLAN conference on Object-oriented programming, \nsystems, languages, and applications.ACM Press, 2006. [9] R.P. Gabriel, R. Goldman, and K. A. McIntyre. \nConsci\u00adentious software. In OOPSLA 06: Proceedings of the 21st annualACM SIGPLAN conference on Object-oriented \npro\u00adgramming, systems, languages, and applications, NewYork, NY, USA, 2006.ACM Press. [10] D. Garlan, \nS.-W. Cheng, A.-C. Huang, B. Schmerl, and P. Steenkiste. Rainbow: Architecture-based self-adaptation \nwith reusable infrastructure. Computer, 37(10):46 54, 2004. [11]P. Grace,G. Coulson,G.S. Blair,andB. \nPorter.Adistributed architecture meta-model for self-managed middleware. In ARM 06: Proceedings ofthe \n5th workshop on Adaptive and re.ective middleware (ARM 06), page 3, NewYork, NY, USA, 2006.ACM Press. \n[12] P. Greenwood and L. Blair. Using dynamic aop to implement an autonomic system. In Proceedings of \nthe 2004 Dynamic Aspects Workshop (DAW04), Lancaster, pages 76 88. RICAS, March 2006. [13] J. O.Kephart \nand D. M. Chess. The vision of autonomic computing. Computer, 36(1):41 50, January 2003. [14] R. Maia, \nR. Cerqueira, and F. Kon. A middleware for experimentation on dynamic adaptation. In ARM 05: Proceedings \nof the 4th workshop on Re.ective and adaptive middlewaresystems,NewYork,NY,USA, 2005.ACM Press. [15] \nB. McMullin. Computational autopoiesis: The original algorithm. WorkingPaper 97-01-001, Santa Fe Institute, \nSanta Fe, NM 87501, USA, 1997. [16] B. McMullin andF. J.Varela. Rediscovering computational autopoiesis. \nIn Fourth European Conference on Arti.cial Life (ECAL 97), pages 38 47, 1997. [17] R. Murch. Autonomic \nComputing. IBM Press, March 2004. [18] D.Patterson, A. Brown,P. Broadwell, G. Candea, M. Chen, J. Cutler,P. \nEnriquez, A.Fox, E. Kiciman, M. Merzbacher, D. Oppenheimer, N. Sastry,W.Tetzlaff, J.Traupman, and N.Treuhaft. \nRecovery oriented computing (roc): Motivation, de.nition, techniques,.Technical report,Berkeley,CA,USA, \n2002. [19] A. Rasche,W. Schult, and A. Polze. Self-adaptive multi\u00adthreaded applications: a case for dynamic \naspect weaving. In ARM 05: Proceedings of the 4th workshop on Re.ective and adaptive middleware systems, \nNewYork, NY, USA, 2005. ACM Press. [20] M. A. S. Sallem and F. J. da Silva e Silva. Adapta: a framework \nfor dynamic recon.guration of distributed applications. In ARM 06: Proceedings of the 5th workshop on \nAdaptive and re.ective middleware (ARM 06), page 10, NewYork,NY, USA, 2006.ACMPress. [21]F.J.Varela,H.R. \nMaturana, andR. Uribe. Autopoiesis: The organization of living systems, its characterization and a model. \nBioSystems, 5:187 196, 1974. [22] M. Zeleny. Self-organization of living systems:A formal model of autopoiesis. \nInternational Journal of General Systems, 4:13 28, 1977.     \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Conscientious software is a recently proposed paradigm for developing reliable, self-sustaining software systems. Conscientious software systems consist of an allopoietic part, which encapsulates application functionality, and an autopoietic part that is responsible for keeping the system alive by monitoring the application and adapting it to environmental changes. Practical application of the conscientious software paradigm requires solutions to two open problems: The design of suitable autopoietic programming languages and the proposal of concrete architectures for combining the autopoietic and allopoietic parts. In this paper, we tackle the second challenge, and propose a concrete, aspect-oriented architecture for realizing conscientious software. Here, we introduce epi-aspects, a construct for upgrading new and existing applications into conscientious software. This paper provides the architectural design of epi-aspects, an autopoietic simulator, and a concrete framework for developing epi-aspects in Java. The framework and the simulator are used to conduct a case study in which we develop and test a conscientious Java application.</p>", "authors": [{"name": "Sebastian Fleissner", "author_profile_id": "81339499723", "affiliation": "Chinese University of Hong Kong, Sha Tin, Hong Kong", "person_id": "PP39094058", "email_address": "", "orcid_id": ""}, {"name": "Elisa L. A. Baniassad", "author_profile_id": "81414615851", "affiliation": "Chinese University of Hong Kong, Sha Tin, Hong Kong", "person_id": "PP39056949", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297076", "year": "2007", "article_id": "1297076", "conference": "OOPSLA", "title": "Epi-aspects: aspect-oriented conscientious software", "url": "http://dl.acm.org/citation.cfm?id=1297076"}