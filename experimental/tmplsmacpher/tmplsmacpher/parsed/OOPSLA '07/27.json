{"article_publication_date": "10-21-2007", "fulltext": "\n TheJava Module System: Core Design and Semantic De.nition Rok Strnisa.PeterSewell MatthewParkinson \nComputer Laboratory, University of Cambridge {Rok.Strnisa,Peter.Sewell,Matthew.Parkinson}@cl.cam.ac.uk \nAbstract Java has no module system. Its packages only subdivide the class namespace, allowing only a \nvery limited form of component-level information hiding and reuse. Two Java Community Processes have \nstarted addressing this problem: one describes the runtime system and has reached an early draft stage, \nwhile the other considers the developer s view and only has a straw-man proposal. Both are natural lan\u00adguage \ndocuments, which inevitably contain ambiguities. In this work we design and formalize a core module sys\u00adtem \nfor Java. Where the JCP documents are complete, we followthem closely; elsewhere we makereasonable choices. \nWe de.ne the syntax, the type system, and the operational semantics of an LJAM language, de.ning these \nrigorously in the Isabelle/HOL automated proof assistant. Using this formalization, we identify various \nissues with the mod\u00adule system. We highlight the underlying design decisions, and discuss several alternatives \nand their bene.ts. Our Is\u00adabelle/HOL de.nitions should provide a basis for further considerationofthe \ndesign alternatives, for reference imple\u00admentations, and for proofs of soundness. Categories and Subject \nDescriptors D.3.1[Programming Languages]:Formal De.nitions and Theory; D.3.3[Pro\u00adgramming Languages]: \nLanguage Constructs andFeatures General Terms Design, Languages, Theory Keywords Java,JAM,LJAM, module, \nsuperpackage 1. Introduction Large applications are typicallybuiltin several parts, which are more tightly \nconnected to each other than to the outside. Therefore, one would like to give these parts more access \nto each other than the outside world has. One might also want these parts reused at manypoints in the \nsystem without worrying about the synchronization of shared data. Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr \u00b4ebec, \nCanada. eal, Qu\u00b4Copyright c &#38;#169; 2007ACM 978-1-59593-786-5/07/0010...$5.00 In the functional world, \nthis problem is solved with modules,but popular OO-languages, such as Java [15] and C# [20], have no \ndirect language support for the above sce\u00adnario. In Java, you have two alternatives: either (1) to put \nall parts of an application in a single package, and make them all non-public, which results in one giant, \nunwieldy package; or(2)toputeachpartinitsown package,butthenyoualso have to make their interfaces public, \nglobally visible [10]. To address this, two Java Community Processes are de\u00adveloping Java Module System \n(JAM1)for the next version of Java [28]. One of them, JSR-277 [31], describes the run\u00adtime. The other,JSR-294 \n[29], is intended to cover the devel\u00adoper s view and the access policies. Currently, it only has a straw-man \nproposal [11], consistingofacoupleofexamples. Moreover, the JSR-277 draft introduces manyconcepts and \nis implementation-oriented,makingitishardtograspthees\u00adsential ideas.Forexample, there are: hierarchical \nstructures of repositories, which can change at runtime; module de.ni\u00adtions that can be instantiated \nand linked to other instances in remote repositories; and lookup functions for module and class de.nitions \nwith unexpected behaviours. Both JSR s and this paper are mostly prose; however, our paper is based on \na fully-formalized, mathematical de.nition. In this paper we present an integrated design for a Java \nModule System, LJAM, covering the core parts of both JSR-277 and JSR-294. For those aspects in the scope \nof the former, we follow the informal description closely; for the remainder, we try to capture what \nwe believe is the in\u00adtended semantics. Our design is expressed rigorously: we de.ne the syntax, type \nsystem and operational semantics for LJAM, producing (from a single source) both human\u00adreadable typeset \nrules and machine-processed mathematics for the Isabelle/HOL proof assistant. More speci.cally, our contributions \nare: a lightweight introduction to the Java Module System;  development of the JSR-294 material on \nthe program\u00admer s view and the access model(\u00a73.2);  discussion of the core of JSR-277(\u00a73.3, \u00a73.5 7); \nand, most signi.cantly,  a rigorous formalization of the above (\u00a74), available while theJAM designis \nongoing.  1JAM comes fromJAva Module system, and notJAva with Mixins [6]. 2. Background The Java Module \nSystem (JAM) [30] is aimed at bringing hierarchical, component-level information hiding to Java, while \nat the same time removing the problem of DLL/JAR hell. In this section, we introduce the problems that \nJAM is trying to solve, and give an overview of the proposed solutions. 2.1 Hierarchical Information \nHiding Suppose we want to run a servlet that provides calendar ser\u00advices on our web serverinexistingJava.We \nwrite the We\u00adbCalendar software unit, which depends on two third-party software units(XSLT and ServletEngine); \nboth of these re\u00adquire an XMLParser: the .rst to create HTML from XML calendar data, and the second for \nits con.guration .les. Fur\u00adthermore, ServletEngine uses a Cache software unit toavoid overhead. Figure \n1 shows the dependency relation between these software units, and the result of putting them into their \nown Java packages. Figure 2 provides the key for this and all other .gures in this paper.  Figure 2. \nThekeyfor all .guresin thispaper At the moment, all classes in our system can see the pub\u00adlic classes \nin engine.cache. Since Cache is (in our applica\u00adtion) logically part of ServletEngine, we would like \nto make engine.cache s public interface (its public classes) visible only to engine, i.e. to classes \nin package engine, and not also to the rest of the system. Away of tackling this problem is to combine \nthe contents of both engine and engine.cache into a single package, and make engine.cache s public interface \npackage-private instead; however, this approach not only loses structure, it also makes the package-private \ninterfaces of the original packages visible to all classes in the new,combined package. A better approach \nis to put both packages in a bigger structure, which acts as a black box, so that webcalendar, which \nis outside this structure, cannot see any of its con\u00adtents.We referto this kindofabigger structure asa \nmod\u00adule de.nition (or superpackage; the terms are used inter\u00adchangeably in the literature), and henceforth \nto the speci.c one holding both engine and engine.cache packages as ServletEngine. To solve the information-hiding \nproblem in a hierarchi\u00adcal way, we need to allow module de.nitions to de.ne their own interfaces, i.e. \nto selectively leak parts of the interfaces of their contents. (If module de.nitions were simply black \nboxes, there would be no point in putting them in a big\u00adger black box, since none of them could see each \nother s contents anyway.) For example, suppose there is a public class engine.Servlet that we would like \nto make visi\u00adble to webcalendar.CalendarServlet (which is outside of engine.Servlet s module de.nition \nServletEngine). To achieve this, ServletEngine has to explicitly export engine.Servlet. Since webcalendar \nis a standard Java package it is un\u00adaware of module de.nitions; therefore, we put it inside its own module \nde.nition WebCalendar, which then im\u00adports ServletEngine, making engine.Servlet visible to webcalendar. \nSee Figure3for the software design, now with module de.nitions. Note that no module de.nitionever contains \nanother2;this allows, for example, that bothXSLT and ServletEngine import the same XMLParser.  Figure \n3. The example with module de.nitions 2The newest proposal of JSR-294 de.nes the concept of a submodule \nde.nition, which is a module de.nition that is encapsulated by another module de.nition.Wedo not formalize \nsubmodules.  2.2 DLL/JAR Hell InJava,aclassisloaded into the runtimebya classloader. Normally, it is \nloaded from a class .le on the local .lesys\u00adtem,butitcanalsobe loadedfrom somewhereelse,orgener\u00adatedbyre.ection, \nand then possibly post-processed/checked before use [18]. A classloader keeps a map from fully\u00adquali.ed \nnames of classes3 to their de.nitions, which means these names have to be distinct for a particular classloader. \nClasses loaded or generated by different classloaders have incompatible types this makes sense, since \nthe de.nitions ofthe classes canbedifferentevenif their names match,and since they do not share static \nstate. By default, classes are loaded by the system classloader. JAR hell appears when two software components \nrequire different versions of a third component. In our example, this can happen if XSLT and ServletEngine \nrequire differentver\u00adsions of XMLParser. This meansthat the system classloader would needtoloadtwoversionsofall \nxml.parser classes, which is not possible due to the above-mentioned restric\u00adtions. When a classloader \nis told to load a class whose name matches an already loaded class, it simply ignores the com\u00admand. This \nresults in undesirable behaviour either for XSLT or ServletEngine, depending on which version of the \nXML-Parser is loaded .rst. There are various solutions to this problem using com\u00adplex systems of classloaders. \nThe most common arguments against their useis that theyare ad-hoc, notbuilt into the lan\u00adguage, and/or \nnon-standardized (we discuss some of them later in \u00a75).JAM allows same-named classes in the system as \nlong as they are in different modulede.nitions: Figure4 shows this solution to the problem.  Figure \n4. JAM s solution to DLL/JAR hell 3. The Design, Informally This section presents the Java Module System \nand LJAM, informally. Subsections that are largely formalizations of the existing early draft of JSR-277 \nare annotated with (JSR-277) ; those that shouldbe coveredby JSR-294,but 3Afully-quali.ed class name \nincludes the nameof theJava package thata class belongs to. are here designed by us, are annotated with \n(JSR-294) . Subsections with no annotations contain our material not directly related to either ofthe \ntwo JSR s. In each section, we identify all major design decisions made, eitherbytheJava s EG-277or EG-2944,orbyus,and \nthen discuss reasons for them and possible alternatives at the end of the same subsection. We begin with \na fragment of Java,LightweightJava, on which we base our design and formalization. 3.1 LightweightJava \nwithStandardPackages Lightweight Java (LJ) is an imperative fragment of Java. It is intended to be as \nsimple as possible while still retaining the feel of Java. LJincludes .elds, methods, single inheri\u00adtance, \nand dynamic method dispatch,but does not include anyof the more advanced language features, e.g. .eld \nhid\u00ading, method overloading, interfaces, inner classes, or gener\u00adics.Amajor differencew.r.t. FeatherweightJava \n(FJ) [16]is thatLJalso models state, whereasFJis purely functional.In this sense,LJis similarto ClassicJava[14],but, \nunlike Clas\u00adsicJava, LJ is a proper subset of Java, i.e. every LJ program is a valid Java program. LJ \nis also formalized rigorously: using the Ott tool [25], we obtain the typeset rules and its formal de.nition \n(in Isabelle/HOL [21]) from a single point of truth its Ott source .les. All documents regarding LJ \nare available online [27]. Mostof LJ s syntaxis shownin Figure5.Meta-variables dcl, f , var, meth range \nover identi.er strings,5 whereas k is an index meta-variable.Overbars indicate lists, e.g. s is a list \nofstatements, and ykk.1..n stands for y1 ...yn (we omit . 1..n when thelengthis not important). The ctx \nin the ob\u00adject creation statement is a runtime annotation representing the context of the statement: \nit is always empty in LJ, but notinitsextensions;it willbeexplainedin more detail later. The restisfairly \nstandard. By adding the concept of standard Java packages to LJ, we already obtain the core part of the \nsyntax for our Lightweight Java Module System (LJAM): the syntactic changes and additions required to \nsupport Java packages are shown in Figure 6. Note that the fully-quali.edname (of a class) now starts \nwith pn, which is a meta-variable rang\u00ading over valid package names (which can include full stops, i.e. \n. ). Now we have an appropriate base language to add the concepts described in \u00a72. 4ExpertGroup(EG)isagroupofindividuals/companies,which \ncontributes to particular Java Community Process (JCP). 5Our meta-variable naming is very speci.c. This \nis because Ott creates a meta-type for each meta-variable, which allows it to typecheck the semantic \nde.nitions: we only allow a meta-variable to appear at certain places in a construct. Therefore, we use \nshort names, which closely correspond to standard notation wherever possible.Forexample, the meta-typeof \nmeta\u00advariable dcl (name of derived class) is a subtype of the meta-type of meta\u00advariable cl (name of \nclass; either dcl or Object). fqn ::= fully quali.ed name | dcl def. cl ::= class name | Object top class \n| fqn fully quali.ed name fd ::= .eld declaration | cl f ; def. vd ::= variable declaration | cl var \ndef. x, y ::= term variable | var normal variable | this keyword s ::= statement |{ skk } block | var \n= x ; variable assignment | var = x . f ; .eld read | x . f = y ; .eld write ' | if (x == y) s else sconditional \nbranch | var = x . meth (y); method call | var = newctx cl(); object creation meth sig ::= method sig. \n| cl meth (vd) def. meth body ::= method body | s1 .. sk return y ; def. meth def ::= method def. | meth \nsig { meth body } def. cld ::= class | class dcl extends cl { fd meth def } def. Figure 5. Syntax of \nLJ fqn ::= fully quali.ed name | pn.dcl def. am ::= access modi.er | default | public public pd ::= package \ndeclaration | package pn ; def. cld ::= class | pd am class dcl extends cl { fd meth def } def. Figure \n6. SyntaxofLJ withPackages(modi.cations)  3.2 Module Files and New public (JSR-294) The source .le describing \na module de.nition is known as a module .le, with syntax as below. mf ::= super package mn { exportfqnj \n; j pnk ; k mnl ; l } A module .le speci.es the module de.nition s name mn, its contents as a list of \npackage names pnk ; k , its exports as a list of fully-quali.ed class names exportfqnj ; j , and its \nimports as a list of module de.nition names mnl ; l . DESIGN DECISION 1 (Module Membership). Module .les \nspecifytheir contentswithalistofpackage names(notclass names). The meaning of import here is similar \nto the standard meaning of import in Java: in both cases the visibility of the contentsofthe imported \nentityis controlledbythe entity itself. The main difference, apart from operating on a differ\u00adent scale, \nis that module de.nitions can also control what is visible outside them, which makes hierarchical information \n package xml.parser; public class Parser {...} package engine; class Config {...} package engine; public \nclass Servlet {...} package engine.cache; public class Cache {...} package webcalendar; public class \n CalendarServlet {...} super package XMLParser { export xml.parser.Parser; xml.parser; } super package \nServletEngine { export engine.Servlet; engine; engine.cache; XMLParser; } super package WebCalendar \n{ webcalendar; ServletEngine;  }} Figure 7. Access control example (code) hiding possible.Weavoidthe \nneed forJava s import state\u00adments by specifying all class references with fully-quali.ed names. Note \nthat JSR s are against changing the syntax of class source .les in order to remain backward-compatible, \nwhich is why referring to individual modules from within the source is not possible. As outlined in \u00a72, \nmodule de.nitions limit the scope of public. To give the intuition of how the new access policy works, \nwe take the codein Figure7 as anexample: it shows the contents of .ve class .les and three module .les. \nFigure 8, shows the visibility between classes when the module .les have been compiled into module de.nitions \n(a.k.a. superpackages). From the .gure, you can see that xml.parser.Parser is visible to all classes \nin ServletEngine, since it is pub\u00adlic and exported by XMLParser. However, the class is not visible to \nWebCalendar, since it is not re-exported by ServletEngine. No class in WebCalendar can see engine.cache.Cache \nor engine.Config because they are, respectively, not exported or private. Discussionof the DesignDecisions \nModule Membership (1) Module .les specify their contents with a list of package names (not class names). \nThis design choice has been made recently in JSR-294. It is the only reasonable choice to make here, \nsince this Figure 8. Access controlexample(visibility) makes packages sub-members of module de.nitions, \nwhich in turn preserves theexisting inter-package visibility seman\u00adtics, i.e. the new access control \nwill not change the visibility semantics within a single module de.nition. Also, withinamodule de.nition, \nthe previous access con\u00adtrol semantics is preserved, e.g. engine.cache.Cache in Figure8cannot see package-private \nclass engine.Config. If we had a single module de.nition that contained all the packages in the system, \nwe would get Java-like semantics. Note, however, that module membership is internally speci.ed with individual \nclasses [31, \u00a73]. If one were to somehow ignore JSR-294 s interface, one could have only a part of a \nJava package in a module de.nition. The inter\u00adpackage visibility semantics would break, since a class \nref\u00aderence that before resolved to a class in the same package couldnowfail completely, or resolvetoadifferent \nclass.  3.3 Modules and Repositories (JSR-277) The compiled version of a module .le is known as a module \nde.nition:the compilation replaces each package name in a module .le with the corresponding class de.nitions. \nMod\u00adule de.nitions must be installed in a repository,a runtime concept, for their classes to be usable. \nThere can be many repositories at runtime to further control the dependencyand isolation between different \nmodule de.nitions. Repositories are organizedinto hierarchies with the boot\u00adstraprepository as its root \n[31, \u00a77.1]. The bootstraprepos\u00aditory always contains the core platform module de.ni\u00adtion [31, \u00a77.1], \nwhich in turn contains all the classes in the core SE platform [31, \u00a72.17]; however, we do not formal\u00adize \nthese classes explicitly. All modules de.nitions implic\u00aditly import the core platform;this is because \nof the way the class lookup function works (explained in \u00a73.7). For example, we might have the following \nrepository\u00admodule structure in the runtime (see Figure 9): the runtime system contains an XML parsers \nrepository, and two Codebase repositories;  each of the Codebase repositories contains a Main mod\u00adule \nde.nition, which imports its own Configuration;  both of the Configuration module de.nitions import \nthe XMLParser<3.0> module de.nition from the XML parsers repository; and  Figure 9. An example repository-module \nstructure By putting each codebase in its own repository, we made them almost completely isolated from \neach other this is due to the way the module de.nition lookup function works (explained later in\u00a73.6).Havingacommon \nrepository parent (XML parsers), allows themto share types (and their static data) de.ned in the module \nde.nition XMLParser<3.0>. We de.ne theabstract syntax of module de.nitions and repositories, in Figure \n10, which gives us a way of express\u00ading and manipulating them in our rules. The structure of a module \nde.nition md consists of its name mn, its exports fqn (fully-quali.ed class names), its member class \nde.ni\u00adtions cld (obtained from the package names pn of the corre\u00adsponding module .le), and its imports \nmn (module names). Arepository,R, is either a bootstrap repository, which cannothavea parent,ora standard \nrepository, which always hasaparent.Wealso distinguish between module de.nitions and module instances. \nThe former specify modules proper\u00adties, i.e. their members, imports andexports, whereas the lat\u00adter are \nexecutable, runtime instances of module de.nitions. As objects are runtime instances of classes, module \ninstances are runtime instances of module de.nitions. Both types of repositories contain both module \nde.nitions md and their instances, the latterof which are storedina module instance map f. md ::= module \ndef. rn |::= module mn { fqn cld mn } def. repository name R ||::= bootstrap r r bootstrap standard repository \n|| bootstrap repository { md ; f }repository r child of rn { md ; f } bootstrap standard Figure 10. The \nabstract syntax for module de.nitions and repositories  The module instance map(f)is a partial map, \nwhich maps module de.nitions md to module instanceidenti.ers mi, i.e. f : md . mi. It is, therefore, \nrepository s heap for module instances of its module de.nitions. Before anycode in a module de.nition \ncan be executed, all module de.nitions that the module de.nition (recur\u00adsively) depends on must be initialized, \nand the module in\u00adstanceslinked together.Ifwewantedtorunthecodein Main of CodebaseA in Figure 9, Main \nhas to be initialized. This triggers a recursive initialization procedure, which initial\u00adizes Configuration \n(in CodebaseA), XMLParser<3.0> (in XML parsers), and the core platform (in bootstrap repository). If \nwe then initialize Main of Codebase B, it will trigger initialization of Configuration (in Codebase B), \nwhich will not initialize XMLParser<3.0> again, but will simply link against the existing instance. Figure \n11 shows the resulting runtime structure, and the actual location of module instances. Octagons repre\u00adsent \nmodule instances, dotted arrows point from module in\u00adstances to their module de.nitions, and three-headed \narrows represent the linking between the module instances.For clar\u00adity, we removed the lines indicating \nthe implicit imports. Discussionof Design Decision2 coversvarious alternatives to this picture. DESIGN \nDECISION 2 (Creationof Module Instances). Any repository can instantiate only a single module instance \nof eachmodule de.nition installed in it. Discussionofthe DesignDecisions Creation of Module Instances \n(2) Anyrepository can instantiate onlya single module instance of eachmodule de.nition installed in it. \nThis design decision gives module instances a very lim\u00adited usage. The only use theyhave in our formalization \n(and probablyalsointhe upcomingsystem)isthefactthatwecan uninstall module de.nitions, and not need to \nworry about currently executing code. One might want to create many module instances of a single module \nde.nition in order to replicate the static data and so avoid various concurrency problems; however, there \ncan be only a single module in\u00adstance of a module de.nition. The only way to create two instances of \na module de.ni\u00adtion is to install the same module de.nition in two different repositories, and instantiate \nboth. However, because of the single-parent rule for repositories (see Figure 10), and be\u00adcause of the \nway module de.nition lookup function works (explained later in \u00a73.6), it is not possible to refer to \nboth of them from a single context. Going back to the example in Figure 3, we have both XSLT and ServletEngine \nmodule de.nitions importing the same XMLParser. Suppose XSLT and ServletEngine can execute in parallel, \nand XMLParser is not thread-safe. The easiest solution would be to make two module in\u00adstances of XMLParser, \none for each user. Because there can be only one instance per repository, we place XSLT and ServletEngine \nin separate repositories, both of which also contain identical copies of XMLParser. The problem is that \nWebCalendar needs to use module de.nitions from both repositories, which is not possibledue to the single-parent \nrule. Therefore,JAMdoesnothaveasolutionforthis high\u00adlevel separation problem. An alternative would be \nto allow eachrepository to cre\u00adate its own instance of any module de.nition it has access to, i.e. the \nmodule de.nition might originate froma different repository. Then each module instance could choose whether \nitwantstolinkagainstaremote instance,andsharedata(and types)with others,ora local instance,andhaveitsowncopy \nof module de.nition s state. Indeed, the early draft is not very clear about the creation of module instances, \nand we .rst thought that module instances were created only locally. We believe, however, that the above \ndescribed approach can be simulated by installing the same module de.nition lo\u00adcally, and then using \na user-de.ned import policy6 to let a module instance choose which one of the twoto link against. A more \nobject-oriented alternative would be to have a central registry for module instances, and allow anynumber \nof module instances per module de.nition in a single repos\u00aditory. Each module instancewould thenhavetobeputinthe \nregistry undera unique name (for that module de.nition), so that module instances could specify which \nones they want to import. One can then also imagine a single instance im\u00adporting multipleinstancesofthe \nsame module de.nition;for this,however,youwould also needawayof disambiguating class references w.r.t. \nmodule instances, i.e. classes would have to be module-aware. 3.4 Representing the Runtime State Apart \nfrom the usual state required for Java-like programs, we need a structure that holds the information \nabout the network of repositories, and about the network of module instances.We store this information \nwith two partial maps. The .rst one, a repository context RC , maps repository names rn to repository \nstructures R (de.ned in Figure 10), i.e. RC : rn . R. It is used when looking up class and module de.nitions. \nThe second, a module hierarchy MH , maps module in\u00adstance identi.ers mi to copies of their corresponding \nmod\u00adule de.nitions md and module instances mis, which mi is directly linked to through the import relation. \nIt is copies of module de.nitions, and not links to them, since origi\u00adnal de.nitions can be uninstalled. \nTherefore, MH : mi . (md *mis). The module hierarchyis used for resolving class references. We refer \nto the pair of the two maps (RC , MH ) as a program P. 3.5 Module De.nition (Un)Installation/Initialization \n(JSR-277) Module de.nitions can be installed and uninstalled from a repository. To use an installed module \nde.nition, we have to instantiate it, and link the instance in. We show these administrator actions in \nFigure 12. a ::= administator action init |||::= rn . install (md) ; rn . uninstall (mn) ; init install \nuninstall initialize initialization | mi = rn . get instance (mn) ; def. Figure 12. Administrator actions \n Module installation insertsagiven module de.nition into a speci.ed repository. The only check that \nwe perform dur\u00ading theinstallation is that module de.nition sname is unique in the repository. 6We do \nnot formalize it in our system at present. Module uninstallation simply removes the module def\u00adinition \nfrom the speci.ed repository, making subsequent searches for that module de.nition or its instancefail. \nSince module de.nitions are only searched at initialization time, and since module instances hold their \nown copies of the corresponding de.nitions, un-installing a module de.nition should not affect already \nexecuting code in \u00a74.5, we dis\u00adcuss this property in detail. Ifamodule de.nition has been initialized \npreviously,then the initialization command simply returns the existing in\u00adstance. Otherwise, we recursively \ninitialize itsimports, link an instance of the module de.nition with them, andupdate the programstructures.Typechecking \nhappens at initializa\u00adtion time, since this is the earliest that we know what a par\u00adticular class reference \nresolves to.We discuss the details of typechecking in \u00a74.4. 3.6 Module De.nition Lookup (JSR-277) Module \nde.nitions are looked up during module initializa\u00adtion in order to determine which module de.nition to \nini\u00adtialize and link up with. Given the current repository context RC , the name rn1 of the repository \nwhere we are starting the search, and the name mn of the module de.nition we are searching for, the module \nde.nition lookup function re\u00adturns the corresponding module de.nition md,and the name rn2 of the repository \nthat has it installed.7 The search proceeds as follows: rn1 .rst delegates the search to its parentrepository \nrecursively, only then search\u00ading itself; the result is the .rst match found. By de.nition, the bootstraprepository \nis at the top of the repository hier\u00adarchy. Classloaders search for class de.nitions in the same man\u00adner \nin order to prevent library classes from getting overrid\u00adden/hidden. Similarly, searching for module \nde.nitions in thisfashion weprevent the core platform module de.ni\u00adtion from getting overridden/hidden. \n 3.7 Class De.nition Lookup (JSR-277) In order to execute an object creation statement var = new cl \n();, we need to resolve a class reference cl.For this, we need to know where the statement is located, \ni.e. its mod\u00adule instance mi and its standard Java package pn, which we refer to as statement s context \nctx (= mi.pn).We solve this problem in the semantics by annotating each object creation statement with \nits context this context insertion happens at module initialization time, when we already know what \nmodule instance a certain statement belongs to. An imple\u00admentationwould carry the context aroundin the \nstack,but modelling a stack would unnecessarily complicate our se\u00admantics. Since modules can import other \nmodules, which can po\u00adtentially be in a different repository, the class de.nition we 7It returns the \nowning repository as well, because in case of a recursive initialization that is the repository used \nto lookup module de.nitions for uninitialized imports. are looking for can be in a different module (possibly \nin an ancestor repository) w.r.t. currently executing code. To search the runtime for class de.nitions, \nwe need a repre\u00adsentation of the runtime relation between modules, i.e. the module hierarchy MH introduced \nin \u00a73.4. Having access to the current repository structure RC and the current module hierarchystructure \nMH , and to the module instance mi we are currently executing in, we can resolve a class reference cl. \nThe search .rst checks the core platform module de.\u00adnition core m, then all of the module instance s \nimports re\u00adcursively,and .nally the module instanceitself, returning the .rst match found. Note that \nthe order in which the imports are searched is determined by the order they are speci.ed in the module \n.le. You can see an example class de.nition search in Fig\u00adure 13, where the search is started at mi1, \nwhich imports mi2 and mi3 (in this order), etc. The numbers below mod\u00adule instance names represents the \norder in which they are searched: note that this is not depth-.rst search,but rather a reverse depth-.rst \nsearch.For clarity, we do not showthe repository structure or the corresponding module de.nitions. Each \nmodule instance will have a classloader associated with it, and each imported module instance will be \nrep\u00adresented with a delegate classloader. Therefore, the class search will be implemented through multiple-siblings \ndel\u00adegation [31, \u00a78.3.1]. DESIGN DECISION 3 (Class Search Order). To.ndaclass, look .rst in the imports, \nand only after in the module in\u00adstance itself. There is a further restriction on the class names that \nis related to the class search order [31, \u00a78.2.2.1]: DESIGN DECISION 4 (Class Name Restriction). The \nfully\u00adquali.ed name of a class within a module instance must not clash with any of the fully-quali.ed \nnames of the classes that are exported from the imported module instances. Discussion of the Design Decisions \nClass Search Order (3) To.nda class,look.rstintheimports,andonly afterinthe module instance itself. Suppose \nwe have a module de.nition A, which de.nes andexportsaclass T,and module de.nitionsB and C,both of which \nimport A, and de.ne their own class T. B also de.nes a class S, which extends a class named T. Figure \n14 shows the situation described (we do not show packages, assuming that all T s and the S are fully-quali.ed \nclass names). It is important to note here that even if the de.nitions of T s are equal, their types \nare incompatible, because they are loaded by different classloaders (see \u00a72.2 for clari.cation). Design \nDecision 3 implies that any reference to type T in any of the three module de.nitions will resolve to \nclass T in module de.nition A. The argument for this is that if the module de.nitions were to somehow \nexchange objects of type T there would be no type clashes. However, this also means that the T s of both \nB and C are completely ignored, and there is no way the user can prevent that without changing A. The \nimplementers of B and C probably hada good reason to include their own de.nition of T for example, C \ncould be a local patch of A. All the classes in B that depend on the included de.nition, e.g. S that \nextends T, might have their invariants broken, making the module de.nition behave in an unexpected manner. \nThis is similar to the issue of .eld-shadowing for classes, i.e. lookingatFigure14,we analogouslyhavea \nclass A with a public .eld T, and two subclasses B and C, which also de.ne the .eld T (B also de.nes \na .eld S). Anyreference in class B to .eld S will resolve to the .eld S in class B. If an update of class \nA, the superclass of B, was to add a .eld named S, anyreference in B to .eld S should still resolve to \nS in B. This is whyJava has .eld-shadowing. Ifwewanted referencesin B to .eld S to insteadresolve to \nS in A, we would simply not de.ne S in B. Therefore, looking up classes in a depth-.rst fashion (self, \nthen imports) rather than in a reverse depth-.rst fash\u00adion (imports, then self)wouldgive more intuitive \nsemantics. It would also give the developer of the module de.nition an option whether to use its own \nclass, or the class de.ned in the imported module de.nition, and hence provide the ability to locally \npatch module de.nitions. Class Name Restriction (4) The fully-quali.ed name of a class within a module \nin\u00adstance must not clash with any of the fully-quali.ed names of the classes that are exported from the \nimported module instances. Shallow validation is an operation that guarantees the above property. It \nis performed by default during installa\u00adtionofa module de.nition,but can alsobe turnedoff. Deep validation \n(not performedbydefault) performs shallowvali\u00addationand additionallyvalidatesthe dependenciesof classes \ninthe module de.nition.Wesayvalidationto mean shallow validation. Let s consider the example in Figure \n14 again. If no vali\u00addation happens, all references to type T refer to the de.nition in A this is what \nwe assumed in Design Decision 3. How\u00adever, if validation is performedin ourexample,itfails, since there \nis a name-clash, and prevents execution. If the developer is aware of the name-clash and wants to use \nthe top-most de.nition of T (to allowfor sharing between the module de.nitions), she has to disable the \nvalidation for B and C (validation can be disabled per module de.nition). On the other hand, if the developer \nwants S to use the T de.ned in the same module de.nition(B), she can turn on the validation. This will \ntell her that there is a name-clash, and execution will stop. Even if execution was to somehow continue \n(by ignoring the exceptions thrown), all references to T would still resolve to the top-most T. Therefore,theonly \nguaranteevalidationgivesisthat,ifit succeeds, there will be no unexpected behaviour due to the unnatural \nclass lookup function.8 4. Formalization of the System Our informal discussion in the previous section \nis based on a fully rigorous formal de.nition of LJAM. As for LJ, this is produced using the Ott tool \n[25], generating a human-readable typeset version of the de.nition and an Is\u00adabelle/HOL formalization \nfrom a single source .le. The Ott and Isabelle typechecking guarantees that the meta-types of the semantic \nde.nitions and rules are well-formed. The def\u00ad 8JSR-277 statesthat names clashes shouldbeavoided,andarepreventedby \nvalidation; however, they are sometimes required as in the case of module de.nition patches or specializations \nshown in Design Decision 3. As name clashes are prevented by default, the speci.cation of class search \norder in JSR-277 is in most cases redundant. inition is available online [26]. It is a relatively large \nformal document, with around 140 semantic rules. This section dis\u00adcussessomeofthe most interestingaspectsofthe \nde.nition. Note that our focus is upon simplicity and accuracy of the semantics, not runtime ef.ciency. \nWhile optimizations are possible, it is important that they preserve observable behaviour. 4.1 Judgements \nOur formalizationinvolvesanumberofdifferent judgements relations over the abstract syntax of the language \n(and auxiliary semantic entities) de.ned by rules. These (62) judgement forms fall into .ve groups: \nexecution of state\u00adments (3); execution of actions (7); typechecking and well\u00adformedness(19); lookup \nfunctions (22); andvarious helper functions(11).InFigure15weshowasampleoftenof these judgement forms. \nThe.rstoneshowsthevariable translation:wedonotfor\u00admalizea stack,but rather .atten the method calls, which \nre\u00adquires the variables in method bodies to be fresh variable translation renames original names to \nfresh ones. In particu\u00adlar, variables in statement s are translated using the variable map .;the result \nis statements'. The second is the main statement reduction judgement, with a con.guration executing one \nstep (for the next state\u00adment in the given con.guration) to evolve into the subse\u00adquent state. The third \nline shows the administrative action reduction judgement, for an administrator action a, again producing \nthe subsequent state. The next twoare direct subtyping and transitivesubtyping judgements. Theyhave the \nusual meaning, i.e. t is a direct (resp. normal) subtype of t'. Eachofour structureshasitsown well-formednessjudge\u00adment, \nchecking that its contents are valid and correspond to its context.We show the judgements for well-formednessof \na statement (in the context of its current program state and typing environment G, which holds the types \nof the contain\u00ading method s parameters and this), a method de.nition (in the context of the class type \nt),anda module de.nition (cor\u00adresponding to the copybeingheldby module instance mi). Following are three \nlookup functions:.nd type returns the primary type (explained in \u00a74.4) of the given class ref\u00aderence, \nstarting the search in ctx; .nd cld .nds the class de.nition(and whereit originatesfrom)fora fully-quali.ed \nname, starting the search in ctx;andmtype .nds the pri\u00admary method type for the given method name and \nthe pri\u00admary type of the owner. 4.2 Con.guration and Statement Reduction Statement reduction is basically \nstraightforward.We de.ne its semantics in small-step, operational style. To avoid the complexities of \na stack, we freshly generate new variable names at every method call, renaming the method body s variables \nappropriately.We useavariable state(L : x -v) . f s . s ' variable translation con.g -. con.g ' statement \nreduction a con.g -. con.g ' action reduction P f t -t ' subtyping relation P, G f s well-formed statement \nP ft meth def well-formed method def. P fmi md well-formed module def. .nd type (P, ctx, cl)= t get \ntype for cl .nd cld (P, ctx, fqn)=(ctx, cld) get class def. for fqn mtype (P, t, meth)= p get meth s \ntype Figure 15. Selected judgement forms to store the value(null or reference oid)that a variable holds, \nand a heap(H : oid -(t * (f -v)))to store the type and values of .elds (belonging to that type) that \na reference points to. Statement reductionisexpressedassinglestepsfromone valid con.guration to another, \nwhere a con.guration is a four-tuple ofthe program state P (described in \u00a73.4), a vari\u00adable state L, \na heap H , and a list of statements yet to be ex\u00adecuted skk, i.e. con.g = (P, L, H , skk ). Figure 16 \nshows rules for two of the more complicated statement reductions, i.e. reduction of object creations \nand method calls.9  4.3 Semantics of (Un)Installation/Initialization The intuitive semantics of module \nde.nition (un)installation and initialization wereexplainedin \u00a73.5.We formally de.ne the reduction of \nadministrator actions in a similar manner a to normal statement reduction: con.g -. con.g', where a is \nan administrative action as in Figure 12. This says that ' the con.g reduces to con.gif action a was \nsuccessfully executed;if theaction for some reasonfails, the initial con\u00ad.guration is left unchanged. \nOur rules for these actions are shown in Figure 19. Note that the uninstallation action can only removemodule \nde.nitions with name m,whichbydef\u00adinition cannot refer to the core platform module de.ni\u00adtion. We explain \nthe initialization rule (R NEW INSTANCE) premise-by-premise as an example: 1. .nd the module de.nition \nin the program sruntime struc\u00adture; 2. identify the repository that owns this module de.nition; 3. \ninspect the repository; 4. check that no instance exists for it already; 5. inspect the module de.nition; \n 6. (recursively) get instances for its imports; 7. create a fresh module instance; 8. annotate the \nmodule de.nition;  9All statement reduction rules are identical to those in LJ; the differences in semantics \nare hidden in the lookup functions, e.g. .nd type. 9. update the module hierarchyappropriately;  10. \ntypecheck the annotated module de.nition in new con\u00adtext; 11. update the repository s module instance \nmap; 12. update the repository context.  As you can see from step 10, typechecking of a mod\u00adule de.nitionisdoneat \ninitialization-time,but beforeanyof the module de.nition s code canbeexecuted.Typechecking must be done \nat initialization time, since only then do we know which class de.nitions do class references resolve \nto, i.e.theymight resolveto class de.nitions presentinadiffer\u00adent module de.nition, possibly in a different \nrepository. The module de.nitions import relation could potentially contain cycles, which should be detected \nby the module system to guarantee termination of the lookup functions [31, \u00a78.3.4].Thisis straightforward,butisnotyet \nformalized.  4.4 Typechecking Typechecking happens at initialization-time, as explained in \u00a74.3. The \ntyping and well-formedness rules are fairly standard for an example, see Figure 17 for the rules that \ncheck for well-formedness of an object creation statement, a method call statement, anda method.For most \nlanguage constructs, including statements, these rules are identical in LJ and LJAM. This is possible \nbecause, by and large, only the lookup functions differ. For example, for the rules in Figure 17, the \nde.nitions of mtype and .nd type differ in LJ and LJAM. Types must uniquely identify the structure theyrefer \nto. To uniquely refer to a class de.nition in LJAM, it is enough to have a triple consisting of a module \ninstance name mi,a package name pn, and a class name dcl;therefore, we use this triple to represent our \ntype t, i.e. t = mi.pn.dcl. Since our context ctx is mi.pn (see \u00a73.7), and since our fully\u00ad quali.ed \nname fqn is pn.dcl (see Figure 6), we also have the following equivalences: t = ctx.dcl = mi.fqn. Note \nthat by including the name of the module instance that the type belongs to in the type itself we automati\u00ad \ncally distinguish between the (otherwise same-named) types loaded by different classloaders see the \nstart of \u00a72.2 and the end of \u00a73.7 for more on this. Two types referring to the same structure are not \nneces\u00ad sarily syntactically identical. Looking at Figure 13, suppose only mi5 de.nes a class with name \npn.dcl. Then both types mi2.pn.dcl and mi1.pn.dcl refer to pn.dcl in md5. In other words, the de.nition \nof types takes the class lookup function into account.We call mi5.pn.dcl the primary type of pn.dcl (in \nmd5), sinceitexactly speci.es wherethe classis located without having to search the runtime. We cannot \nknow whether a type is primary just by look\u00ad ingatit;however,inourformalization,allourlookup func\u00ad tions \nfor types, e.g. .nd type,always return primary types. All type references used in our subtyping judgements \nare k 1. .nd type (P, ctx, cl)= t 2. .elds (P,t)= fk k ' 3. oid ./dom (H )4. H = H [oid . (t, fk . \nnull )] R NEW ' (P, L, H , var = newctx cl(); sll ) -. (P, L [var . oid], H , sll ) 1. L (x)= oid 2. \nH (oid)= t kj ' 3. .nd meth def (P, t, meth)=(ctx, cl meth (clk vark ) { s return y ; }) j kk ' '' \n4. var . dom (L)5. distinct (var )6. x ./dom (L) kk kk '' 7. x ./var 8. L (yk )= vk k k '' 9. L' = L \n[var . vk ][x . oid] k ' ''' 10.. =[vark . var k ][this . x '] 11.. f s o s j k jj ' 12.. (y)= y R MCALL \nj '' (P, L, H , var = x . meth (ykk ); sll ) -. (P, L' , H , sj var = y ' ; sll ) 2. .nd type (P, ctx, \nclk )= tk 3. G=[vark . tkk ][this . ctx.dcl] 4. P, G f sl  5. .nd type (P, ctx, cl)= t 6. P f G(y) \n-t  Figure 16. Small-step operational semantics rules for two statements 1. y = yk k 2. G (x) = t \n3. mtype (P, t, meth) = tk k . t ' 1. .nd type (P, ctx, cl) = t 4. P f G (yk ) -tk k 5. P f t ' -G (var) \nP, G f var = x . meth (y) ; WF MCALL 2. P f t -G (var) P, G f var = newctx cl(); WF NEW 1. distinct (vark \nk ) k l WF METHOD k P fctx.dcl cl meth (clk vark ) { sll return y ; } Figure 17. Selected well-formedness \nrules k 1. .nd path (P,t )= (ctxk , cldk ) k 1. .nd path (P,t )= ctxcld 2. classname (cldk )= dclk \nSTY OBJ k P f t -Object ' 3. (ctx , dcl') . (ctxk, dclk) STY DCL '' P f t -ctx .dcl Figure 18. Selected \nsubtyping rules resolved with these lookup functions, so the judgements can assume they are dealing with \nprimary types. The well\u00adformedness of the object creation statements (the second rule in Figure 17) is \nan example how a type is looked up before it is compared to another. The subtyping rules are fairly standard \nas well, except for the two direct subtyping rules shown in Figure 18. The lookup function used here, \n.nd cld, takes a program state P,a contextctx (= mi.pn),anda fully-quali.edclass name fqn (= pn.dcl), \nand returns the appropriate class de.nition cld along with its context. Therefore, the .rst rule simply \nchecks that the supertype of the given type is an Object, whereas the second rule also looks up the de.nition \nof the superclass, and checks that its type matchesthe primary type given. Other rules can be found in \nthe full speci.cation of LJAM [6]. Our typechecking is slightly different to that of Java, since we typecheck \nall classes within a module instance as soon as it has been initialized. In Java, however, most typechecking \nacross module instances will happen during execution. Also, at the moment, our formalization looks up \nclass de.nitions at runtime we knowthose de.nitions will be found, since the typechecking already checked \nthat they exist, and since the network of module instances doesn t a ' con.g -. con.g reduction of an \nadministrative action k 1. RC (rn)= R 2. R body (R)=(mdk ,f) k 3. md name (md)= mn 4. md name (mdk )= \nmnk k k 5. mn ./mnk 6. R update (R, md mdk ,f)= R' ' 7. RC = RC [rn . R'] R INSTALL rn . install (md); \n' ((RC , MH ), L, H , sll ) - ---------. ((RC , MH ), L, H , sll ) 1. RC (rn)= R 2. R body (R)=(md, \nf) 3. .nd md in mds (md, m)= md ' 4. mds rm (md, md)= md ' 5. R update (R,md, f . md)= R' ' 6. RC = RC \n[rn . R'] R UNINSTALL rn . uninstall (m); ' ((RC , MH ), L, H , sll ) - ----------. ((RC , MH ), L, \nH , sll ) 1. .nd md (RC , rn1, mn)=(rn2, md)2. RC (rn2)= R2 3. R body (R2)=(md2,f2)4.f2 (md)= mi R EXISTING \nINSTANCE mi=rn1 . get instance (mn); ((RC , MH ), L, H , sll ) ------------------. ((RC , MH ), L, H \n, sll ) 1. .nd md (RC , rn1, mn)=(rn2, md)2. RC (rn2)= R2 3. R body (R2)=(md, f2)4.f2 (md)= null 5. md \n= module mn { fqn cld mnkk } k mik =rn2 . get instance (mnk ); ' 6. ((RC , MH ), L, H , sll ) --------------------. \n((RC , MH '), L, H , sll ) ' 7. mi ./dom (MH ')8. fmi md o md k '' ' 9. MH = MH ' [mi . (md, mik )] '' \n10. (RC , MH '') fmi md 11. R update (R2, md, f2 [md . mi]) = R'  2 '' 12. RC = RC ' [rn2 . R' ] 2 \nR NEW INSTANCE mi=rn1 . get instance (mn); '' ''), L, H , sl ((RC , MH ), L, H , sll ) ------------------. \n((RC , MH l ) Figure 19. Module de.nition installation/uninstallation/initialization change once .xed. \nTherefore, we could have cached class de.nitions found during typechecking, and used them during execution. \n 4.5 Lookup Functions andConcurrency The execution of normal statements accesses and changes the heap \nH , the variable state L, and the list of statements k sk of the con.guration. It does not change the \nprogram state P, however. In fact, only the class lookup function accesses the module hierarchy MH part \nof the program state, using the repository context RC only to locate the instance of the core platform \nmodule de.nition, which by de.nition cannot be removed. The administrator actions, on the other hand, \neither ad\u00add/remove module de.nitions, or create/fetch module in\u00adstances, i.e. they change both parts \nof the program state, but only add new mappings to the module hierarchy see step 9 in the module de.nition \ninitialization rule. The new mappings cannot override old ones, because all module instances are created \nfreshly, and the old mappings never change with execution once .xed by the module de.nition initialization \nstep.10 From the above it follows that administrator actions do not interfere with normal execution, \nand can therefore be done in parallel. This is also the reason why we made the two reduction relations \nappear similar. As long as intermediate states of structures that these actions operate on are invisible, \nor are read-only during action execution, actions can be done in parallel either on different repositories \nor on the same repository. There can be no circular dependencybecause of the hierarchical relation among \nrepositories. 10InJAM,a module instance willbegarbage collected once nothing refers to it anymore.  \n4.6 Modularizationof theSemantics We were able to reuse more than 80% of LJ s de.nition in the de.nition \nof LJAM. This was possible due to some software engineering techniques on the level of language design. \nIn LJ, we introduced an annotated version of the object creation statement: var = newctx cl();.We also \nde.ned the statement reduction semantics without assumptions about the structure of the program state \nP or the current context ctx. The program state and current context are interpreted by lookup functions. \nTherefore, all the statement reduction rules remain identical; and only the lookup functions had to be \nadapted for different structures of program states and contexts.We applied the same principles for the \ntyping and well-formedness rules. The bene.ts of this are demonstrated by the rule for well-formedness \nof a method in Figure 17. Thekeyconceptswe abstractedawayfromtoachievethis are shown in the following \ntable: Concept Def. in LJ Def. in LJAM fully-quali.ed name fqn dcl pn.dcl context ctx (empty) mi.pn program \nstate P cld (RC , MH ) 5. RelatedWork Classloaders Currently the most common practice used to control \nthe visibility and access policies of classes in Java is with specialized classloaders that delegate \nto each other in various patterns. These patterns can be quite complex, making the system s structure \nnon-obvious and error-prone. Agoodexampleofthe possible complexityisWebSphere s system of classloaders \n[23]. Open Source Gateway initiative OSGi [22] is a highly\u00adcustomizable frameworkbuiltontopofJavawhich \npromotes service-oriented programming, where services, speci.ed in bundles (components), are registered \ninto a global registry (Service Registry) with speci.c properties (Service descrip\u00adtion), which are used \nfor service-lookup. Eachbundle,aJAR .le containing some metadata, classes, native code, and re\u00adsources,is \nsimulated witha classloader. The framework al\u00adlows their installation, de/activation, update, and removal. \nOSGi is at the moment the most widespread framework foraJavamodule system[2,3,1]. Buildingamodule system \ninto the language, however, will probably achieve an even larger user base, and hopefully also increase \ncompatibility of module interfaces across software houses, although for backward-compatibility purposesJAMdoesallowtheuseof \ncustom classloaders through the re.ective API [31, \u00a79.4]. Component systems Probably the most similar \nsolutions to JAM are JavaMod [8] and Jiazzi [19]. Theyboth have con\u00adcepts of importing and exporting \nJava classes, where classes can link to each other across component boundaries. The user of a component \nhas to de.ne the interface of every im\u00adported class manually, but then gets separate compilation; provides \n catalina.jar ; import * from xerces; import com.sun.tools.* from tools; hide * in *; export org.apache.catalina.* \nto webapp; forbid org.apache.catalina.* in *; module catalina { public static void load() {...} public \nstatic void main(String[] args) {...} } } Figure 20. MJ s access control example compatibility between \nspeci.ed interfaces and actual classes is checked by the linker at initialization-time. Neither, how\u00adever, \nhas any notion of module instances or repositories, so state replication and location independence is \nnot as trans\u00adparent asinJAM. MJ[12]11isa module systembuiltontopofJava, where each module corresponds \nto a classloader, and its (static) relationshipsto other modules are representedbyimportand export relationships \namongst classloaders. Its access control mechanism is quite expressive, and so allows sophisticated relationships \nbetween different modules see Figure 20. MJ s compiler is used for module-aware compilation of classes, \nwhich basically checks the module constraints and sets the appropriate CLASSPATH for the standard Java \ncom\u00adpiler(javac). The module system only checks inter-module dependencies at runtime, even though many \nof them could be checked at installation/start time. There is no support for versions of modules or classes. \nMJ does not work with custom classloaders; however, it is supposed to be easy to rewrite them as MJ modules. \nBy having a more expressive access control language such as MJ s, JAM could avoid a few of its problems \nre\u00adgarding needless name clashes (described in\u00a73.7). There are a variety of theoretical proposals for \nrather different modularity features: .rst-class components [24] and mixin modules [7, 32]. Windows Fusion \n.NET assemblies [13] represent well\u00adde.ned boundaries of security, namespaces, and versions, i.e. an \nassembly is the smallest versionable unit. In many respects, they are very similar to Java module de.nitions. \nHowever, .NET assemblies are still very much .lesystem based, loaded into runtime by a loading system \ncalled Fu-sion[4].Even thoughtheyare,in this respect, lessexpressive thanJAM, .NET assemblies can have \nstrong names, which are basically an author s publickeys that canbe checked for 11 Not to be confused \nwith MJ [9]. validity at load-time, providing an easy way to increase se\u00adcurity of the system. This functionality \ncan be simulated in JAM by putting public keys into extensible metadata [31, \u00a72.5], and de.ning a custom \nimport policy [31, \u00a72.7.2] that checks them (neither of which we formalize). 6. Conclusion and FurtherWork \nIn this paper, we have designed and formalized a core mod\u00adulesystemforJava.Wehavede.nedthesyntax,thetypesys\u00adtem,andthe \noperational semanticsofan LJAM language rig\u00adorouslyinthe Isabelle/HOL automatedproof assistant.With the \nhelp of our formalization, we have identi.ed various is\u00adsues with the module system, highlighted the \nunderlyingde\u00adsign decisions, and discussed various alternatives and their bene.ts.Twoof the most signi.cant \nissues we found are: 1. The creation of module instances is too limited. Put to\u00adgether with a single-parent \nrepository structure, and we cannot solve a relatively simple software engineering problem, which we \nrefer to as high-level separation:hav\u00ading access to more than a single instance of a particular module \nde.nition from a single point in runtime; 2. The current class de.nition lookup function has unintu\u00aditive \nbehaviour, and gives the developer no control for disambiguating class name clashes across module de.\u00adnitions.We \nproposed an alternative, whichgivesa .eld\u00adhiding-like behaviour, .xes the disambiguation problem, and \nallows module de.nitionstobe locally patched.  The formalization is available online [26]. Our work \nis by no means the .rst to cover some aspect ofJava formally see, for example, that of Klein and Nipkow \n[17], and ref\u00aderences therein. It is, however, very rare (for anylanguage) to have a fully rigorous de.nition \nof a proposed language changeavailableduringthe design process.Wehopeit will provide a useful basis for \nprecise discussion. The full Isabelle/HOL de.nition of our system is crucial step towards our future \nwork: we aim (1) to obtain a refer\u00adence implementation of our system, tightly conforming to thede.nition; \nand (2) to rigorously prove properties such as type preservation, progress, and non-interference of admin\u00adistrator \nactions with normal execution. Currently, we are also extending this work to cover other featuresoftheJAM, \nwhich includesversioning, user-de.ned import policy, native libraries, resources, and legacy JAR .les. \nAs mentioned in \u00a74.3, all typechecking is currently done at module de.nition initialization time. An \nalternative, and more ef.cient, approach would be to typecheck each mod\u00adule de.nition as much as possible \nin isolation at installation time (or even before), generate the linking conditions, and check those \natlinking time. The idea of compositional com\u00adpilation [5] already solvesa similar problemfor class-level \ncompilation, and shouldbeinvestigatedin theJAM setting. Acknowledgments We thank JanVitek, Doug Lea, \nAlex Buckley and Stanley Ho, for introducing us to the topic and for important dis\u00adcussion. We also thank \nSophia Drossopoulou, Tom Ridge, Alisdair Wren, Nobuko Yoshida, Viktor Vafeiadis, John Billings, and Sam \nStaton for useful comments on earlier versions of this paper.We acknowledge the support of two EPSRC \ngrants, DTA-RG44132 andGR/T11715/01, a Royal Society University Research Fellowship (Sewell), and a Royal \nAcademy of Engineering/EPSRC Research Fellow\u00adship (Parkinson). References [1] Apache Felix. http://cwiki.apache.org/felix/. \n[2] Eclipse Callisto. http://www.eclipse.org/callisto/. [3] Equinox. http://www.eclipse.org/equinox/. \n[4] Fusion. http://en.wikipedia.org/wiki/.NET assembly#Fusion. [5] ANCONA, D., DAMIANI, F., DROSSOPOULOU, \nS., AND ZUCCA,E. Polymorphic Bytecode: Compositional Compila\u00adtion for Java-like Languages. In Proc. 32ndACM \nSIGPLAN-SIGACT Symposium on Principles of Programming Lan\u00adguages, POPL 05 (Long Beach, CA, USA, Jan. \n12-14, 2005), J.PalsbergandM.Abadi,Eds.,ACM,pp. 26 37. [6] ANCONA, D., LAGORIO, G., AND ZUCCA, E. Jam \n-a smooth extension of java with mixins. In Proc. European Conference on Object-Oriented Programming, \nECOOP 00 (Sophia Antipolis and Cannes, France, June 12-16, 2000), E. Bertino, Ed., vol. 1850 of Lecture \nNotes in Computer Science, Springer, pp. 154 178. [7] ANCONA, D., LAGORIO, G., AND ZUCCA, E. Smart Modules \nfor Java-like Languages. In Proc. 7thWorkshop on Formal Techniques for Java-like Programs, FTfJP 05 (Glasgow, \nScotland, July 26, 2005). [8] ANCONA, D., AND ZUCCA, E. True Modules for Java\u00adlike Languages. In Proc. \nEuropean Conference on Object-Oriented Programming, ECOOP 01 (Budapest, Hungary, June 18-22, 2001), J. \nL. Knudsen, Ed., vol. 2072 of Lecture Notes in Computer Science, Springer, pp. 354 380. [9] BIERMAN, \nG., PARKINSON, M., AND PITTS, A. MJ: An imperative core calculusforJavaandJavawithEffects.Tech. Rep. \n563, Cambridge UniversityComputer Laboratory, Apr. 2003. [10] BRACHA, G. Developing Modules for Development. \nhttp://blogs.sun.com/gbracha/, Mar. 2006. [11] BRACHA, G. Superpackages: Development Modules in Dolphin. \nIn Proc. JavaOneSM Conference (2006), Sun Microsystems, Inc. [12] CORWIN,J., BACON, D.F.,GROVE, D., AND \nMURTHY,C. MJ: a rational module system for Java and its applications. In Proc. ACM SIGPLAN Conference \non Object-Oriented Programming Systems, Languages and Applications, OOP\u00adSLA 03 (Anaheim, CA, USA, Oct. \n26-30, 2003), R. Crocker andG.L.S.Jr., Eds.,ACM,pp. 241 254. [13] DEVELOPMENTOR. Assemblies Module -.NET: \nBuilding Applications and Components with C#, Jan.2004. [14] FLATT, M., KRISHNAMURTHI, S., AND FELLEISEN,M. \nA Programmer s reduction semantics for classes and mixins. Tech. Rep. TR-97-293, Rice University, 1997. \nCorrected June, 1999. [15] GOSLING, J., JOY, B., STELLE, G., AND BRACHA,G. The JavaTM LanguageSpeci.cation, \nThird ed. Sun Microsystems, Inc., May 2005. [16]IGARASHI,A.,PIERCE,B.C., AND WADLER,P. Feather\u00adweight \nJava: a minimal core calculus for Java and GJ. ACM Trans. Program. Lang. Syst. 23,3(2001), 396 450. [17]KLEIN,G., \nAND NIPKOW,T. AMachine-Checked Model foraJava-Like Language,Virtual Machine and Compiler. ACMTransactionsonProgramming \nLanguagesand Systems, TOPLAS 06 28,4(July 2006), 619 695. [18]LIANG,S., ANDBRACHA,G. Dynamic Class Loadinginthe \nJavaVirtual Machine. In Proc.ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages \nand Applications, OOPSLA 98 (Vancouver, British Columbia, Canada, Oct. 18-22, 1998), pp. 36 44. [19]MCDIRMID,S.,FLATT,M., \nAND HSIEH,W. Jiazzi:New Age Components for OldFashioned Java. In Proc.ACM SIGPLAN Conference on Object-Oriented \nProgramming Systems, Languages and Applications, OOPSLA 01 (Tampa, Florida, USA, Nov. 2001), vol. 36, \npp. 211 222. [20] MICROSOFT. C# Speci.cation, 2.0 ed., Sept. 2005. [21] NIPKOW, T., PAULSON, L. C., AND \nWENZEL, M. Is\u00adabelle/HOL -A Proof Assistant for Higher-Order Logic, vol. 2283 of Lecture Notes in Computer \nScience. Springer, 2002. [22] OSGITM ALLIANCE. About the OSGi Service Platform, 4.1 ed., Nov. 2005. [23] \nROBINSON, R. Developing and Deploying Modular J2EE Applications with WebSphere Studio Application Developer \nand WebSphere Application Server. http: //www-128.ibm.com/developerworks/websphere/ library/techarticles/0206 \nrobinson/robinson. html, June 2002. [24]SECO,J.C., AND CAIRES,L. A Basic ModelofTyped Components. In \nProc. European Conference on Object-Oriented Programming, ECOOP 00 (Sophia Antipolis and Cannes, France, \nJune 12-16, 2000),E. Bertino, Ed.,vol. 1850 of LectureNotes in Computer Science,Springer,pp. 108 128. \n[25] SEWELL, P., ZAPPA NARDELLI, F., OWENS, S., PESKINE, G., RIDGE, T., SARKAR, S., AND STRNI.Ott: SA, \nR. Effective Tool Support for the Working Semanticist. In Proc. ICFP (Freiburg, Germany, Oct. 2007). \nTo appear in ICFP 07. [26] STRNI.http:SA, R. Lightweight Java Module System. //www.cl.cam.ac.uk/~rs456/ljam, \nFeb. 2007. [27] STRNI.SA, R., AND PARKINSON, M. Lightweight Java. http://www.cl.cam.ac.uk/~rs456/lj, \nSept. 2006. [28] SUN MICROSYSTEMS, INC. JavaTM SE 7. https: //jdk7.dev.java.net/. In development. [29] \nSUN MICROSYSTEMS, INC. JSR-294: Improved Modularity Support in the JavaTM Programming Language. http: \n//jcp.org/en/jsr/detail?id=294. [30] SUN MICROSYSTEMS, INC. OpenJDK: Modules project. http://openjdk.java.net/projects/modules/. \n[31] SUN MICROSYSTEMS, INC. JSR-277: JavaTM Module System. http://jcp.org/en/jsr/detail?id=277, Oct. \n2006. Early Draft. [32] ZENGER, M. Programming Language Abstractions for Extensible Software Components. \nPhD thesis, University of Lausanne, EPFL, 2003.   \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Java has no module system. Its <i>packages</i> only subdivide the class name space, allowing only a very limited form of component-level information hiding and reuse. Two Java Community Processes have started addressing this problem: one describes the runtime system and has reached an early draft stage, while the other considers the developer's view and only has a straw-man proposal. Both are natural language documents, which inevitably contain ambiguities.</p> <p>In this work we design and formalize a core module system for Java. Where the JCP documents are complete, we follow them closely; elsewhere we make reasonable choices. We define the syntax, the type system, and the operational semantics of an <i>LJAM</i> language, defining these rigorously in the Isabelle/HOL automated proof assistant. Using this formalization, we identify various issues with the module system. We highlight the underlying design decisions, and discuss several alternatives and their benefits. Our Isabelle/HOL definitions should provide a basis for further consideration of the design alternatives, for reference implementations, and for proofs of soundness.</p>", "authors": [{"name": "Rok Strni&#353;a", "author_profile_id": "81318491338", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P905213", "email_address": "", "orcid_id": ""}, {"name": "Peter Sewell", "author_profile_id": "81100511814", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "PP14177906", "email_address": "", "orcid_id": ""}, {"name": "Matthew Parkinson", "author_profile_id": "81406598777", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P707743", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297064", "year": "2007", "article_id": "1297064", "conference": "OOPSLA", "title": "The java module system: core design and semantic definition", "url": "http://dl.acm.org/citation.cfm?id=1297064"}