{"article_publication_date": "10-21-2007", "fulltext": "\n Jeannie: Granting Java Native Interface Developers Their Wishes Martin Hirzel IBMWatson Research Center \n hirzel@us.ibm.com Abstract Higher-level languages interface with lower-level languages such asC to access \nplatform functionality, reuse legacy li\u00adbraries, or improve performance. This raises the issue of how \nto best integrate different languages while also recon\u00adciling productivity, safety, portability, and \nef.ciency. This paper presents Jeannie, a new language design for integrat\u00adingJava withC.In Jeannie, \nbothJavaandCcode are nested within each other in the same .le and compile down to JNI, the Java platform \ns standard foreign function interface. By combining the two languages syntax and semantics, Jean\u00adnie \neliminates verbose boiler-plate code, enables static error detection across the language boundary, and \nsimpli.es dy\u00adnamic resource management.We describe the Jeannie lan\u00adguage and its compiler, while also \nhighlighting lessons from composing two mature programming languages. Categories and Subject Descriptors \nD.3.3[Programming Languages]: Language Constructs and Features; D.2.12 [Software Engineering]: Interoperability; \nD.3.4[Program\u00adming Languages]: Processors General Terms design, languages Keywords programming language \ncomposition, Java, C, JNI, foreign function interface, xtc, modular syntax, Rats! 1. Introduction Higher-level \nlanguages must interface with lower-level lan\u00adguages, typically C, to access platform functionality, \nreuse legacylibraries, and improveef.ciency.Forexample, most Java programs execute native code, since \nseveral methods of even class Object at the root of Java s class hierarchy are written in C.Foreign-function \ninterfaces (FFIs) accom\u00adplish this task, providing access to C code and data from Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, \n2007, Montr \u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; 2007ACM 978-1-59593-786-5/07/0010...$5.00 Robert \nGrimm NewYork University rgrimm@cs.nyu.edu higher-level languages and viceversa.Forexample,aJava project \ncan reuse a high-performance C library for binary decision diagrams (BDDs) through the Java Native Inter\u00adface[38](JNI), \nwhichis the standardFFIforJava. FFI designs aim for productivity, safety, portability, and ef.ciency. \nUnfortunately, thesegoals are often at odds.For instance, Sun s original FFI for Java, the Native Method \nIn\u00adterface[52,53](NMI), directlyexposedJava objects asC structs and thus provided simple and fast access \nto object .elds.However, thisis unsafe, sinceCcode can violateJava types, notably by storing an object \nof incompatible type in a .eld. Furthermore,it constrainsgarbage collectors and just\u00adin-time compilers, \nsince changes to the data representation may break native code. In fact, NMI required a conserva\u00adtive \ngarbage collector because direct .eld access prevents the Java virtual machine (JVM) from tracking references \nin native code. Finally, native code that depends on a virtual machine s object layout is hard to port \nto other JVMs. In contrast to the Native Method Interface, the Java Na\u00adtive Interface is well encapsulated. \nAs a result, C code is easily portable while also permitting ef.cient and differing Java virtual machine \nimplementations. But JNI s re.ection\u00adlike API requires verbose boiler-plate code, which reduces productivity \nwhen writing and maintaining native code. Fur\u00adthermore, it is still unsafe typing errors cannot be checked \nstatically, nor does the JNI speci.cation require dynamic checks. It is also less ef.cient than unportable \nFFIs that ex\u00adpose language implementation details. This paper presents Jeannie, a new FFI for Java that \npro\u00advides higher productivity and safety than JNI without com\u00adpromising the latter s portability. Jeannie \nachieves this by combiningJava andCinto one language that nests program fragments written in either language \nwithin each other. Con\u00adsequently, Jeannie inherits most of the syntax and semantics from the two languages, \nwith extensions designed to seam\u00adlessly bridge between the two. By analyzing both Java and C together, \nthe Jeannie compiler can produce high-quality error messages that prevent many a maintenance nightmare. \nOur compiler is implemented using Rats! [29], a parser gen\u00ad erator supporting modular syntax, and xtc \n[28], a language composition framework. It accepts the complete Jeannie lan\u00adFigure 1. JNIexample,withJavaontopandC \non bottom. guage, including Java 1.4 code and most gcc extensions to C, and its backend produces conventional \nJNI code. Future work will explore alternative backends that, for example, produce code optimized for \nspeci.c JVMs. Jeannie s contributions are threefold: Improved productivity and safety for JNI;  Deep \ninteroperability of full programming languages;  Language composition lessons from a large example. \nWe evaluate Jeannie based on a partial port of the JavaBDD library[60]and on micro-benchmarks thatexercise \nnew lan\u00ad guage features. Our results demonstrate that Jeannie code is simpler than the corresponding \nJNI code, while introducing  little performance overhead and maintaining JNI s portabil\u00adity. 2. Point \nof Departure: JNI This section provides a .avor of JNI, the Java Native Inter\u00adface, as described in Liang \ns book The Java Native Inter\u00adface: Programmer s Guide and Speci.cation [38]. Figure1 illustrates how \na socket abstraction can use JNI to interface with the operating system. The Java class on top declares \na native method available with no Java body. The method is implementedby the body(2)ofCfunction Java_my_net_\u00adSocket_available \non bottom.Adowncall fromJavatoC looks like anyother Java method call. On the other hand,C code uses a \nre.ection-like APIfor upcalls to Java methods  Figure 2. Jeannieversionof code fromFigure1. andforJava.eld \naccesses.Intheexample,CSnippet3reads the Java .eld this.native_fd. The JNI interface pointer env is the \n.rst argument to all C functions implementing Java native methods. The corresponding type JNIEnv, declared \nin jni.h, points to a struct of function pointers that are implemented by the Java virtual machine. In \nthe struct, the .eld access func\u00adtion GetIntField usedbySnippet3of Figure1is repli\u00ad cated for several \nother types, including GetBooleanField and GetObjectField. JNI also provides similar functions for calling \nmethods. Snippet4illustrates JNI sfacilities for raisingJavaexceptions. SinceClacksexception handlingfa\u00adcilities, \ntheCcode must emulatethe abrupt control.owwith anexplicit return statement. JNI also provides functions \nto checkfor pendingJavaexceptions, enteringandleavingsyn\u00adchronization monitors, acquiring and releasing \nJava arrays for direct accessinC,and manymore. Finally,JNI functions use types such as jint, jclass, \nand jfieldID, which are also declared in jni.h. Before .rst calling a native method, a Java virtual ma\u00adchine \nneeds to link the corresponding native library. The System.loadLibrary call in the static initializer \nof class Socket in Figure 1 identi.es the library s name, which is mappedtoa sharedobject .le(.so or \n.dll)on the JVM s library path. After loading the object .le, the JVM locates theC function implementing \navailable by following the name mangling rules of the JNI speci.cation. Repeated calls to System.loadLibrary \nfor the same library are ignored, so that the C functions for several Java classes can be in\u00adcluded in \nthe same library. 3. Jeannie Overview Figure 2 shows the JNI code from Figure 1 rewritten in Jeannie. \nThe outer Jeannie code in Figure 2 corresponds to the Java codein Figure1. Nested code snippets in both \n.gures that correspond to each other are labeled with the same numbers (1 through 5). The Jeannie .le \nstarts with a `.C block of top-levelCdeclarations included fromheader .les (1). It continues like a normal \nJava .le with a package declaration, imports, and one or more top-level Java class or interface declarations. \nUnlike in Java, native methods in Jeannie have a body (2). The backtick ` toggles to the opposite language, \nwhich is C in the case of Snippet 2. Consequently, Java code can be nested in C (Snippets 3 and 4), and \nC code can be nested in Java (Snippet 5), to arbitrarydepth.TheJNIcodeinFigure1illustratesthatsuch deep \nnesting occurs naturally. Nested Java code in Jeannie does not need to use fully quali.ed names: where \nSnippet 4 in Figure 1 refers to java.io.IOException,Snippet4inFigure2usesthesim\u00adple name IOException, \nwhich Jeannie resolves using the import declaration. The Jeannie compiler veri.es statically that names \nand types are used consistently across nested Java andCcode.It alsoveri.es that throws clauses declare \nall checked exceptions, while extending Java s exception han\u00addlingdisciplineto nestedCcodeand automatically \nreleasing resources such as locks and memory on abruptcontrol .ow. Asa result, Jeannie canavoidalarge \nclassofbugs thatJNI code is susceptible to. Figure 3 illustrates the Jeannie pipeline for compiling a \n.le. Socket.jni corresponds to Jeannie source code as shownin Figure2. The pipeline .rst injects #include \n<jni.h> into the initial `.C block (e.g., Snippet 1 in Figure 2). It then runs theC preprocessor, which \nis necessary to ensure that allC codein the Jeannie .leis syntactically valid and referentially complete. \nThe result is the intermediate .le Socket.jni.i, which serves as the input to the Jeannie compiler proper. \nThe Jeannie compiler converts the intermediate .le into two separate .les Socket.i and Socket.java, with \npure preprocessedCcode that uses JNI on the one hand and pure Javacode with native methods anda System.loadLibrary \ncall on the other hand. Jeannie s parser is generated by Rats! [29]froma grammar that reuses separateCandJava \ngrammars. The name and type analysis is based on xtc [28] and reuses separate C and Java semantic analyzers. \nIf the input program has syntactic or semantic errors, the compiler reports them to the user. Otherwise, \nthe code generator pro\u00adduces two separate abstract syntax trees (ASTs) forC and Java, which are converted \nback into source code by pretty\u00adprinters from xtc. From this point on, the compilation pipeline proceeds \nas if the JNI code hadbeen writtenby hand. The platformC compiler compiles Socket.i together with otherC.les \ninto a shared object .le Network.dll, and the Java compiler compiles Socket.java together with other \nJava .les into Java bytecode, which it may place into a .le Network.jar. Figure 3. The Jeanniebuild \nprocess and compiler stages. Later, the JVM s dynamic linker combines the code into a running application. \nIn general, the Network.dll and Network.jar .les are not self-contained,but interact with signi.cant \nother code written independentlyofJeannie, such as the operating systemkernel or theJava standard libraries. \n4. Jeannie Language Jeannie combines Java andC. It inherits most of the syntax and semantics from the \ntwo base languages[27, 34]. The primary contributionofthispaperistoshowhowtointegrate the two languages \ngenerally and seamlessly. 4.1 Syntax Jeannie nestsCcodeinJava andJava codeinC.It supports the complete \nsyntax of both C and Java and relies on the backtick operator ` to switch between the two languages. \nFor example, when the currentlanguage is Java, `{ int x=42; printf(\"%d\", x); } denotesaCblock nestedinJavacode.Conversely,whenthe \ncurrent language is C, `{ int x=42; System.out.print(x); } denotesaJava blocknestedinCcode.The backtick \nopera\u00adtor can also be applied to expressions; it has the same prece\u00addence as other unary pre.x operators \nsuch as logical nega\u00adtion !.For example, when the current language is Java, `((jboolean)feof(stdin)) \ndenotesaCexpression nestedinJava code.In thisexample, the parentheses around theC castexpression are \nnecessary because the cast operator has lower precedence than the backtick operator. Jeannie also supports \na quali.ed form of the backtick op\u00aderator for switching between the two languages; depending on the destination \nlanguage, it is denoted `.C or `.Java. The simple and quali.ed forms are interchangeable, allow\u00ading developers \nto trade offterseness and clarity as desired. Synchronization In Java, the synchronized (m){ CS } statement \nacquiresa monitor m, thenexecutesthe codein the critical section CS, then releases m. Java semantics \nare designed so that the monitor is always released, even in the presence of abrupt control.owdueto,forexample,exceptions.However, \nsince Clacks language support for synchronization, JNI provides two separate functions MonitorEnter and \nMonitorExit. It is the programmer s responsibilityto ensure the typestate propertiesofa monitorobjectalongall \ncontrolpathsforJNI code. Jeannie leverages Java s monitor discipline by allowing synchronized statements \nto be nested in C code with a backtick.For example, `synchronized (lock) { counter.incr(); } denotes \na Java synchronized statement nested inCcode. The monitor is the object in variable lock and the critical \nsection containsamethod call counter.incr(). Of course, the critical section can also useabacktickto \nswitch back into C.For example, `synchronized(flock) `{ fprintf(fd, s); } denotes a synchronized statement \nwhose body is a C block. Exception Handling In Java, a try/catch/finally statement .rst executes the \ntry block. If the try block abruptly terminates with an ex\u00adception and there is a matching catch block, \nit then exe\u00adcutes that exception handler. Either way, it then executes the finally block (if present). \nIn contrast,Cdoes not support exceptions. Instead, programmers rely on error codes and explicit control \ntransfer through goto and return. JeannieleveragesJava sexception handling disciplineby allowing Java \ntry statementstobe nestedinCcode witha backtick.For example, `try{ f(); } catch (Exception e) { h(e); \n} denotes a Java try statement nested inC code.Of course, anyof the try, catch, and finally blocks can \nuse a back\u00adtickto switch back intoC.Ccodecan also throwanexcep\u00adtion by using a Java throw statement witha \nbacktick.For example, `throw new Exception(\"boo\"); triesto startletheprogrambythrowinganexceptionfromC \ncode.To complete integrationofJava sexception handling discipline withC, Jeannie also allowsCfunctionsto \ndeclare exceptions with a `throws clause.For example, void printf(char* f, ...) `throws IOException; \n declaresaCfunction printf that may signal a Java IOEx\u00adception (instead of returning a status code). \nString and Array Access The Jeannie syntax presentedsofaralready supportsCcode accessing Java arrays \nand strings. For example, when the current language is C, cChar = `javaString.charAt(3); cFloat = `javaArray[3]; \n`(javaArray[3] = `sqrt(cFloat)); reads a character from a Java string, reads a .oating point number \nfrom a Java array, and writes that number s square root back into the Java array. While succinct, this \nidiom for accessing arraysand stringsmaybeinef.cient.Forexample, for (jint i=0, n=`ja.length; i<n; i++) \ns += `ja[`i];  repeatedly crosses language boundaries as it sums up the elements of Java array ja. To \nspeed up bulk access to strings and arrays, Jeannie provides the _copyFromJava and _copyToJava built-ins. \nComparable to C s memcpy and Java s System.arrayCopy, the two functions copy regions of strings and arrays, \nbut across languages.Forexample, _copyFromJava(ca, cStart, ja, jStart, len) copies the array elements \nja[jStart] through ja[jStart+ len-1] to ca starting at ca[cStart]. Java strings are treated as read-only \ncharacter arrays and can be copied in their native UTF-16 encoding or converted into UTF-8 en\u00adcoding.To \nletCcode allocate an appropriately sizedbuffer, the _getUTF8Length built-in returns the length of a Java \nstringin UTF-8 encoding. Furthermore,to convertCstrings into Java strings, the _newJavaString built-in \nillustrated in Figure2createsanewJavastringfromaCstring. Consis\u00adtent with C99 s practice for evolving \nthe language, Jeannie pre.xes newCbuilt-ins andkeywords with an underscore, thus reducing the likelihood \nof naming con.icts with exist\u00ading code. The jeannie.h header .le provides convenience macros such as \nExample Code Nonterminal Parsing Expression `.C { #include <stdio.h> } class A {} File = `.C { C.Declarations \n} Java.File Cnested in Java Modi.cations to Java grammar `{ int x=42; printf(\"%d\", x); } Java.Block += \n. . . / CInJava C.Block `((jboolean)feof(stdin)) Java.UnaryExpression += . . . / CInJava C.UnaryExpression \n`.C CInJava = `.C / ` Java nested in C Modi.cations to Cgrammar `{ int x=42; System.out.print(x); } C.Block \n+= . . . / JavaInC Java.Block `new HashMap(); C.UnaryExpression += . . . / JavaInC Java.UnaryExpression \n`java.util.Map C.TypeSpeci.er += . . . / JavaInC Java.Quali.edIdenti.er f(char *s) `throws IOException \nC.FunctionDeclarator := C.DirectDeclarator ( C.ParameterDeclaration ) ( JavaInC Java.ThrowsClause)? C.Statement \n+= . . . `synchronized(act) { act.deposit(); } / JavaInC Java.SynchronizedStatement `try { f(); } catch \n(Exception e) { h(e); } / JavaInC Java.TryStatement `throw new Exception(\"boo\"); / JavaInC Java.ThrowStatement \n`.Java JavaInC = `.Java / ` New Cconstructs Modi.cations to Cgrammar C.Statement += . . . _with (jint* \nca = `ja) { sendMsg(ca); } / _with ( WithInitializer) C.Block _abort ca; / _abort C.Identi.er ; _commit \nca; / _commit C.Identi.er ; WithInitializer = msg->data = `ja C.AssignmentExpression jint* ca = `v.toArray() \n/ C.Declaration Figure 4. Jeanniesyntax.Forexposition, parsingexpressions are somewhat simpli.ed when \ncomparedtothe actual grammar. Literals are set in monospace font, without double quotes. #define copyFromJava \n_copyFromJava to eliminate unsightly underscores from most programs. To avoid manual buffer management \nand enable opti\u00admizations that avoid copying altogether, Jeannie s _with statementprovidesa more disciplinedwayof \naccessingJava strings and arrays fromCcode.Forexample, _with (jint* ca = `ja) { for (jint i=0, n=`ja.length; \ni<n; i++) s += ca[i]; } acquires a copy of Java array ja s contents, sums up its elements, and then releases \nthe copy while also copy\u00ading back the contents. Following the example of Java s synchronized statement, \nJeannie s _with statement uses syntactic nesting to enforce the proper pairing of acquire and release \noperations on a resource. By default, the string or array is released when control reaches the end of \na _with block; Jeannie also supports leaving the statement abruptly by using a _commit ca or _abort ca \nstatement. Formal Syntax Figure4shows the Jeannie grammar. The .rst column shows example code for each \nconstruct, while the other columns specify the syntax using parsing expressions and the gram\u00admar modi.cationfacilitiesof \nRats! [29].For example, Java.Block += ... / CInJava C.Block modi.es the Java grammar: the nonterminal \nJava.Block, in addition (+=) to recognizing Java blocks(...)now recog\u00adnizes a backtick(CInJava)followedbyaCblock(C.Block). \nAs another example, the rule C.FunctionDeclarator := C.DirectDeclarator ( C.ParameterDeclaration ) ( \nJavaInC Java.ThrowsClause)?  modi.es theCgrammar:the nonterminal C.FunctionDeclar \u00adator, insteadof(:=) \nrecognizingjustaCfunction declarator, now recognizesaCfunction declarator followedby an op\u00adtional backtick \nand Java throws clause. The Jeannie grammar s start symbol is File. As illustrated in Figure2,a Jeanniesource \n.le starts withCdeclarations, which typically come from header .les, followed by the usual contentsofaJava \nsource.le,i.e.,thepackage,import, and top-level class and interface declarations. One modi.cation to \ntheCgrammar not yet discussed is the abilityto usea backtickedJavatype nameasaCtype speci.er.Forexample, \nwhen the current languageisC, const `java.util.Map m = ...; de.nes aC variable m that contains a constant \nopaque refer\u00adence to a Java Map.Asillustratedby thisexample,C code may not only use Java typesbut also \ncombine them withC quali.ers such as const. Most of Jeannie s syntax has been designed for orthogo\u00adnality.By \naddingonlya small numberof rulestoexistingC Figure 5. Example code with deep nesting and assignments. \n andJavagrammars,it enablesthe seamlessintegrationofthe twolanguages. However,Jeannie ssyntax does trade \northog\u00adonalityfor ef.ciencyfor string and array accesses. Further\u00admore, sinceJNI targetsCand Jeannie \nincludes the complete C language, it is possible to use JNI within Jeannie code. While generally discouraged, \nthis does allow for incremen\u00adtal ports of JNI code to Jeannie.  4.2 Dynamic Semantics For pure Java \nand pure C code, the dynamic semantics of Jeannie are just the dynamic semantics of the respectivebase \nlanguage. This section clari.es the behavior of variables, arrays, and abrupt control .ow at the language \nboundary. Formal Parameters and Local Variables Consider the Jeannie codein Figure5. Block1isaCblock. \nIt can use the local variable y and an implicit parameter JNIEnv* env for direct JNI calls. Block2isaJava \nblock. It can use the formal parameter x, the local variable z, and an implicit parameter T this, with \nT being the class that declares method f. Expression 3 is a C expression in the scopeof Block1and can \nhence use y and env. Expression4 isaJavaexpressionin the scopeofBlock2and can hence use x, z, and this. \nConsistent with the rule of least surprise, all Jeannie code in the same activation of a method observes \nthe same state. Consequently,in Block2ofFigure5, the statement System.out.println(x); prints 1, since \nthe preceding Expression4assigns thatvalue to x. Likewise, in Block 1, the statement printf(\"%d\\n\", y); \nprints 2, since the preceding Expression3assigns thatvalue to y. The Jeannie language does not specify \nthe dynamic se\u00admantics of unobserved state. For example, the C code in Figure5never applies the address-of \noperator &#38; to y. Con\u00adsequently, an implementation need not store y at the same address for Block \n1 and Expression 3. Likewise, the Java code never uses the implicit parameter this. Consequently, animplementationneednotpassit \naround.Byonly de.ning the runtime semantics of observed state, Jeannie enables dif\u00adferent implementation \nand optimization strategies. Notably, a backend more sophisticated than our current one may per\u00adform \ninliningandregister allocation acrosslanguage bound\u00adaries similar to[51]. Non-Local Variables and Garbage \nCollection JNI distinguishes between local and global references. Lo\u00adcal references are formal parameters \nand local variables in C that refer to Java objects. They pose little challenge for garbage collection: \na Java virtual machine simply treats ref\u00aderences passed into C code as additional roots for the du\u00adration \nof a native method call. Global references are static variables and heap-allocated data structures in \nC that re\u00adfer to Java objects. By de.nition, static variables and heap\u00adallocated data structures may \nhold a Java reference even af\u00adter a native method returns, thus raising the issue of how to prevent the \nreferenced objects premature collection. JNI addresses this problem by requiring explicit ac\u00adquire and \nrelease operations through NewGlobalRef and DeleteGlobalRef. The JVM sgarbage collector then treats these \nreferences as additional roots. However, this approach suffers from all the problems of manual memory \nmanage\u00adment: leaks, dangling references, and double deletes. The alternative of using syntactic nesting \nto enforce the pairing of acquire and release operations does not work for global references.Afterall,theyareintendedtoescapealanguage \ns stack discipline. Instead, Jeannie recommends that programmers do not storeJava referencesinC s staticvariablesor \nheap-allocated data structures. Rather, theyshould only store them in .elds ofJava classesandobjects.Forexample,to \naccessa static .eld f of class C, a developer merely writes `C.f, and, to access an instance .eld g of \nobject o, the developer writes `o.g.In either case,aJavareferenceisonlyabacktickaway, while taking full \nadvantage of garbage collection. Future work may explore an escape analysis that warns users when the \ncompiler cannot prove that local references indeed stay local. String and Array Access Figure 6 shows \nhow programmers should choose between Jeannie s different string and array access features. While the \nexpression semantics of regular Java capture the dy\u00adnamic semantics of backticked string or array accesses, \nthe _copyFromJava, _copyToJava, _newJavaString, and _with constructs merit discussion. The _copyFromJava \nand _copyToJava built-ins per\u00adform their copyoperation unless the Java reference is null or the Java \nindices are out of bounds; in those cases, the built-insthrowan appropriateexception.In contrastand con\u00adsistent \nwithCsemantics, an invalidCpointer or index pro\u00adduces unde.nedbehavior.Tryingtocopyastring to Java isa \nstatic error. When copyinga string from Java, the pointer can Figure 7. Example code for _with statement. \nNotethat new is notakeywordinCcodeeven thoughitis forJava.  be of type jbyte* or jchar*. In the former \ncase, the result isa UTF-8 encodedCarray;inthe latter case,itis UTF-16 encoded just like Java strings. \nIn both cases, the length ar\u00adgument counts Java characters in the Java string, while the returnvalue \ncountsCcharactersintheCstring. Comparable to _copyFromJava,the_newJavaString built-in acceptsa Cstring \nof typejbyte* or jchar*, converting from UTF-8 to UTF-16 for the former. As shown in Figure 4, the _with \nstatement takes the following form: _with (ca = ja){ ... } If ja is null, the _with statement signals \na NullPointer-Exception. Otherwise, it initializes ca to point to a copy of ja. As for the built-in copy \nfunctions, strings are UTF\u00ad8 encoded if ca is of type jbyte* and UTF-16 encoded if ca is of type jchar*. \nIndependent of encoding, modifying a string leads to unde.ned behavior. The _commit and _abort statements \ninitiate an abrupt control transfer to the code immediately following a _with statement. A _commit statement \ncopies any changes back into ja, whereas _abort discards them. For example, in Figure 7, the _abort statement \nindicates that no changes need to be copied back to ja. Both _commit and _abort release anyresources \nnecessary for implementing the _with statement, notably the copy s memory. Control .ow can also leave \na _with statement through completion of the block, a return statement, or an ex\u00adception. The .rst two \ncases represent an implicit _commit, while the third case represents an implicit _abort. In all three \ncases, Jeannie code behaves exactly as if the _commit or _abort was present, including releasing any \nresources. Forexample,in Figure7, thereturn i statement inside the loop represents an implicit _commit, \nand the modi.ed char\u00adacter array is copied back before control leaves the _with statement. Thanks to \nthe explicit _abort at the end of the _with statement s block, the array is not copied back if no character \nwas replaced. Abrupt Control Flow Jeannie has several language features that abruptly change control \n.ow: explicit function or method returns, excep\u00adtions, array aborts and commits, and break, continue, \nand goto statements.Toavoid unnecessary complexity, break, continue, and goto statements must not cross \nlanguage boundaries or _with statements. When abrupt control .ow leaves synchronized, _with, or try blocks, \nJeannie re\u00adleases anylocks or arrays while alsoexecuting any finally blocks just as it does for regular \ncontrol .ow. Function and method returnsgobacktothecallsite,justasinCandJava, andexceptions propagateto \nthe dynamically closest match\u00ading catch clause, just as in Java. 4.3 Static Semantics Similar to Jeannie \ns dynamic semantics, the static semantics of Jeannie are largely just the static semantics of the respec\u00adtive \nbase language withone crucial difference: the Jeannie compiler checks that Jeannie code is well-formed \nand well\u00adtyped for both base languages at the same time and across the language boundary.In otherwords, \nJeannienotonly replaces JNI s re.ection-like API with direct language support, but also enforces the \nstatic semantics of the combined language, thus signi.cantly reducing the potential for software errors. \nMost of the compile-time semantic rules forCand Java also apply to nested C and Java code in Jeannie. \nFor in\u00adstance, Jeannie resolves Java class names relative to imports and matchesCfunctionsto their prototypes, \nwhich are typ\u00adically declared in header .les included at the beginning of a Jeannie .le. Furthermore, \nJeannie veri.es that all checked exceptions are either caught locally or declared as thrown by the enclosing \nfunction or method. Next, Jeannie checks thatJava members areinfact accessible, i.e., that references \nto .elds, methods, and member types obey their visibility (private, protected, public, or default). In \nJeannie, native methods of a Java class must have a body and that body must be a backticked C block. \nNative methods also declare an implicitCparameter JNIEnv* env, so thatC code has access to JNI s API. \nConsequently,ex\u00adplicit parameters of native methods cannot have the name env. As discussed above under \ndynamic semantics, Jeannie provides this feature tofacilitate incremental conversion of JNI code to Jeannie, \nthough its use is discouraged in general. Typing Jeannie de.nes several type equivalences between Java \nand C types, denoted as JT = CT. Java s primitive types are equivalent to their corresponding typedefs \nin jni.h. For example: char = jchar int = jint Similarly, Java arrays of primitive types are equivalent \nto their typedefs in jni.h, including: char[] = jcharArray int[] = jintArray Additionally, Jeannie honors \nthe type equivalences provided by JNI for reference types, suchas: java.lang.Object = jobject java.lang.Object[] \n= jobjectArray java.lang.Throwable = jthrowable See the JNI speci.cation for a full list[38, \u00a712.1]. \nJeannie extends the C type system by introducing an opaque reference type for every Java class or interface. \nThe Java type andCtype are equivalent.Forexample: java.io.IOException = `java.io.IOException Jeannie \nhas the same rules for resolving simple type names to fully quali.ed type namesasJava.Forexample,Ccodein \nJeannie can use the type speci.er `IOException for class java.io.IOException if the current .le is part \nof package java.io or if it has the appropriate import declaration. Cassignments, variable initializers, \nfunction invocations, and return statements can implicitly widen opaque refer\u00adencestoJava classes or \ninterfaces. Forexample, whenthe current language is C, the second assignment in `java.util.HashMap h \n= ... ; `java.util.Map m = h; is legal because class HashMap implements interface Map. WhenaJavaexpressionis \nnestedinCcode, Jeannie type\u00adchecks theC codeasif theJavaexpression had the equiv\u00adalent C type. Likewise, \nwhen a C expression is nested in Javacode, Jeannietype-checkstheJavacodeasiftheC ex\u00adpression had the \nequivalent Java type.However,Cpointers, structs, and unions have no equivalent in Java, and a Jeannie \ncompiler.agsan errorwhena program attemptstousethem in Java code. In addition to these type equivalence \nand widening rules, each base language has its own implicit and explicit con\u00adversions, which are observedby \nthe Jeannie compiler.For example, when the currentlanguageisJava, if (`((jboolean)feof(stdin))) return; \n .rst explicitly casts the return value of the function call feof(stdin) to jboolean and then relies \non Jeannie s type equivalence rules to implicitly convert the C typedef jboolean into the Java primitive \ntype boolean. That type, in turn,istheexpectedtypeforthe if statement s condition. Jeannie treats Java \nreference types inC no more and no less opaquely than JNI.Forexample, Sun s default jni.h header de.nes \njobject tobea pointer to an unde.nedC struct _jobject. This prevents mistakes caused by inatten\u00adtiveness, \nsince dereferencing a variable of type jobject leads to a compile-time error. However, it cannot prevent \nprogrammersfrom casting jobject to a pointer to another, de.nedCstruct and then accessing the object \ns contents.In otherwords,Ccodein Jeannieisjustasweaklytypedasany Ccode, including JNI. At the same time, \nJeannie s support for opaque Java references and implicit widening operations within nestedCcode considerably \nreduces the need for us\u00adingexplicit and potentially unsafeCcasts. Storage Model Toensure well-de.ned \nsemantics, primary identi.ers require the contextofthe declaring language.Forexample,the fol\u00adlowing code \nis malformed: int x = 42; `f(x); . error: x used in wrong language More importantly, backticked expressions \nin Jeannie always return anr-value.Forexample, the following code is mal\u00adformed: `x[0] = y; . error: \nx[0] not an l-value Such cross-language assignments fundamentally have am\u00adbiguous semantics.Forinstance, \nassume thattheexample s language is C and that x is a Java array. Should Jeannie just execute the assignment, \nas pure C would? Or, should Jeannie .rst perform Java s checks against null references and out-of-bounds \nindices? Additionally, cross-language as\u00adsignments raise implementation issues.For instance, should theaboveCassignmentexecutea \nwrite barrierfortheJava garbage collector? To avoid these issues, Jeannie requires that operations on \nl-values occur in the language of the l\u00advalue.For instance, `(x[0] = `y); correctly performs the assignment \nin nested Java code. String and Array Access Each of Jeannie s _copyFromJava, _copyToJava, and _with \nconstructs for accessing strings and arrays requires aC pointer ca and a reference to a Java string or \narray ja. The reference ja has an opaque C type and is the result of a C expression. In practice, this \nC expression usually is a backticked Java expression, such as `v.toArray() or `o.toString(). If ja is \na jstring, then ca must be jbyte* for UTF-8 encoding or jchar* for UTF-16 encod\u00ading. Otherwise, ja mustbeaJava \narray, suchas jintArray, and ca must be of the corresponding pointer type, such as jint*. In contrast \nto the copy built-ins and the _with statement, the _newJavaString built-in requires onlyaC pointer ca, \nwhich must be jbyte* or jchar*. For the two copybuilt-ins _copyFromJava(ca, tgt, ja, src, len) _copyToJava \n(ja, tgt, ca, src, len) the tgt and src indices as well as the len element count must be of type jint. \nThe resultof the copybuilt-insisalsoof type jint and indicates the number of elements actually copied.We \ndid consider a single _copy built-in that relies on parameter ordering to determine whether to copyfrom \nor to Java. But unfortunately, C s memcpy and Java s System.\u00adarrayCopy disagree on whether to put the \nsource or tar\u00adget parameter .rst. As a result, Jeannie programmers might become confused about a single \n_copy construct s correct usage. By providing two separate constructs, the Jeannie compiler can statically \ndetermine parameter ordering errors based on argument types. Either way, it rejects attempts to copyinto \nJava strings. In a _with statement _with (ca = ja){ ... } theC pointer ca either must be newly declared \nor must be modi.able, i.e., not const. The identi.er ca in _commit ca and _abort ca statements must be \nthe formal of a directly enclosing _with statement. It is illegal to jump in to or out of _with statements \nusing a break, continue, or goto statement. However, control may leave a _with statement through a return, \nexception, or by completing the block. Abrupt Control Flow Besides preventing break, continue, or goto \nstatements from crossinga _with boundary,Jeannie also prevents them from crossingalanguage boundary.In \ncontrast,regular func\u00adtion or method returns and thrownexceptions may cross lan\u00adguage boundaries.WhenaC \nreturn statement returns from aJava method,a Jeannie compiler converts the returnedC value to its equivalent \nJava type and then checks that it con\u00adforms to the method s return type. Similarly, when a Java return \nstatement returns fromaCfunction,a Jeannie com\u00adpilerconvertsthe returnedJavavaluetoitsequivalentCtype \nand then checks that it conforms to the function sreturn type. Athrownexception mustbe either(1) unchecked, \ni.e.,a sub\u00adclass of Java s RuntimeException or Error,(2) caught lo\u00adcally, or (3) declared as thrown by \nthe enclosing function or method. 5. Pragmatics This sectionexploresthe pragmaticsofthe Jeannie compiler, \nfocusing on two main issues. The .rst issue is how to trans\u00adlate Jeannie code to Java and C. The second \nissue is how to achieve scalable composition[45]. Fundamentally, lan\u00ad guage composition is only practicalif \nthe development effort for realizing the composed language is commensurate with the newly added features \nand not with the entire language. The Jeannie compiler largely achieves this goal and directly reuses \ngrammars, semantic analyzers, and pretty printers for Java 1.4 andC with most gccextensions.Infact, manyof \nthese components predate the Jeannie project and have been developed by different programmers for the \ndifferent lan\u00adguages. 5.1 Syntactic Analysis Any real-world code written in C relies on the preproces\u00adsor \nto include header .les, resolve conditionals, and expand macros, notably for platform-speci.c declarations. \nFor ex\u00adample, Sun s default jni.h header declares several types such as jint and macros such as JNI_TRUE, \nwith several declarations conditional on the computer architecture (32-bit or 64-bit) andlanguage(Cor \nC++). Furthermore, before pre\u00adprocessing,Ccode need not be well-formed, since the pre\u00adprocessor considers \nonly tokens and not syntactic units. Con\u00adsequently, as shown in Figure3, Jeannie invokes theCpre\u00ad processor \nbefore parsing the resulting code, and Java code is also subjectto preprocessing.To somedevelopers,thismay \nrepresenta welcome feature;forothers,itmayleadtounde\u00adsirable results due to inadvertent name capture. \nThis issue is not uniqueto Jeannie,as preprocessing posesa challengefor anytool acceptingCcode.One solutionwouldbetodevelop \na Jeannie-aware version of the preprocessor that ignores Java code.Amore general solutionwouldbeto integratethe \npreprocessor s features withthe language[40]. The actual Jeannie grammar is written for the Rats! parser \ngenerator[29], which is well-suited to this task for three reasons. First, Rats! has a module system, \nand, as shown in Figure 4, the Jeannie grammar reuses existing C and Java grammars as modules, modi.es \nseveral productions, and adds a few new ones. Second, Rats! is scannerless, i.e., integrates lexical \nanalysis with parsing. Consequently and as illustrated in Figure7for new, Java tokens andCtokens are \nonly recognized in the respective language s context. In other words, the Jeannie parser can recognize \ncode written without regard for Jeannie s union of Java and C, notably code included from platform-speci.c \nheader .les. Third, Rats! has built-in support for parser state, which lets the Jeannie parser resolve \nambiguities between typedef names and other names in C code without complicating the Java grammar. Rats! \ngrammars specify not onlya language s syntaxbut also the structure of its abstract syntax tree (AST) \nthrough productions marked as generic. The corresponding AST public Node getThisDotField(String name) \n{ Node v$1 = GNode.create(\"ThisExpression\", null); Node v$2 = GNode. create(\"SelectionExpression\", v$1, \nname); return v$2; } Figure 8. Example method createdby xtc s concrete syntax tool. nodes are instances \nof a generic node class GNode. The generic node s name is the unquali.ed nonterminal on the left-hand \nof a production, though individual alternatives can override this default. The generic node s children \nare the values of non-void expressions on the right-hand side. Since the Jeannie grammar reusesexistingJava \nandCgrammars, it also reuses their AST declarations. However, since several productions in the Java and \nC grammars have the same names, the Jeannie AST may also contain generic nodes with the same namebutdifferent \nsemantics.Asa result, semantic analysis needs to track the current backtick nesting depth during AST \ntraversal. Discussion Thanks to Rats!, the development of Jeannie s syntactic analysis phase was largely \nstraightforward. However, we did encounter two issues when tryingto write code process\u00ading the resulting \nASTs; the solutions to both problems, in turn, depend on Rats! and are useful beyond Jeannie. First, \na grammar is a rather circuitous starting point for understand\u00ading a language s AST, since the grammar \ncontains many ex\u00adpressions that do not contribute to the AST such as punctua\u00adtion and layout.To address \nthis issue, we modi.ed Rats! to automatically generate the necessary documentation: given the corresponding \ncommand line .ag, it loads a grammar, removes any expression that does not contribute to the AST, and \nthen pretty prints the reduced grammar, optionally as hyperlinked HTML. Second, Jeannie s translation \nphase needs to create new AST fragments for Java and C from scratch, but doing so programmatically in \nhandwritten code is tedious and error\u00adprone.To address this issue, we added support for concrete syntax[14]to \nxtc. Our concrete syntax toolbuilds onvari\u00adantsoftheCandJava grammars created with Rats! module system; \nboth grammars recognize individual declarations, statements, or expressions with embedded pattern variables. \nThetool convertsthe correspondingAST intoJava code that recreates the AST, while also replacing the AST \nnodes of patternvariables withJavavariables.Forexample, our tool translates the Java code template getThisDotField \n{ this.#name } into the method shownin Figure8, which takesa parameter name representing the template \ns only pattern variable and returns a generic node representing the .eld access expres\u00adsion.  5.2 Semantic \nAnalysis Comparable to the syntactic analysis phase, the Jeannie com\u00adpiler s semantic analysis phasebuilds \non separate semantic analysis phases for Java and C. Each author separately de\u00adveloped one of the semantic \nanalyzers, with little coordina\u00adtion ontheir internals.At the same time, both semantic ana\u00adlyzers sharefacilities \nfor (1) traversing abstract syntax trees through visitors, (2) tracking identi.ers through a symbol table, \nand (3) representing types and their annotations. Be\u00adfore discussing the composition of the two semantic \nanalysis phases, weexplore the commonfacilities. Theyare provided bythextc (eXTensibleC)toolkit[28]and \nalso usedby other source-to-source transformation tools including Rats! [29] and C4[22, 61]. Visitors \nThe visitor design pattern enables type-safe tree traversal through double dispatch[24].Visitors implementa \ncommon interface V that has a visit(N) method for every distinctly typed node N, and nodes implement \nan accept(V) method that invokes the visitor on the node. While effective, we have also found the visitor \ndesign pattern to be limiting. Notably, it does not support visit methods that accept a superclass of \nseveral nodes, thus leading to code duplication when processing several types of nodes in the same way. \nFurthermore, it cannot dispatch on properties of a node, in particular,the namesofgeneric nodes createdby \ninlineAST declarations for Rats!. Finally,changes to an AST sstructure tend to ripple through the entire \ncode base, since the visitor design pattern requires changing the common interface V and thus all classes \nthat implement V. xtc addresses these concernsbyprovidinga moreexpres\u00adsive alternative through dynamic \nvisitor dispatch[9]. Under this model, the appropriate visit method is dynamically se\u00adlected and invoked \nthrough Java re.ection; method resolu\u00adtions are cached to reduce the overhead of future dispatches. Intuitively,for \na given node N, xtc s visitor dispatch selects the visit method with the closest supertype N as its only \nargument (which includes N itself). In practice, xtc s visi\u00adtor dispatch also considers interfaces, starting \nwith the inter\u00adfaces implementedby the node s class.Forgeneric nodes, it precedes type-based resolution \nwith a name-based resolu\u00adtion step, seekingamethod visitName(GNode) for generic nodes with name Name. \nWhile xtc s visitor dispatch pro\u00advides a simple solution that meets our needs, it does eschew type safety \nfor expressivity; other efforts have explored dif\u00adferent trade-offs between expressivity, safety, and \ncomplex\u00adity[30, 42, 58]. Symbol Table xtc s symbol table maps identi.ers to types, organizes the mapping \ninto hierarchically nested scopes, partitions each public void visit(Node n) { table.enter(n); for (Object \no : n) if (o instanceof Node) dispatch((Node)o); table.exit(n); } Figure 9. Example code for synchronizing \ngeneric AST traversal with the current symbol table scope. scope amongst different namespaces, and supports \nthe ob\u00advious define, isDefined, and lookup operations. It also tracks the current scope and supports \nboth absolute and rel\u00adative name resolution. Probably its most interesting feature is support for synchronizing \nAST traversal with the current scope.When creatinganewscope,avisitorinvokesthesym\u00adbol table s mark method \non each node corresponding to the new scope. That method uses Node s support for arbitrary propertiesto \nannotatethe node withthe scope s identity.Be\u00adfore and after processing a node, other visitors then call \nthe symbol table s enter and exit methods, which rely on the node s annotations to update the current \nscope. When com\u00adbined with xtc s dynamic visitor dispatch, this feature sup\u00adports generic AST traversal \nthat is also synchronized with the symbol table. Forexample,theCanalyzerveri.eslabels, whichmaybe used \nbefore they are de.ned, in two passes. During the .rst pass,itcollectsall label de.nitionsinthe symbol \ntable.Dur\u00ading the second pass,it checks that each label appearingina goto statement or label addressexpression \nhas been de.ned. (The latter constructisagccextensionto accessa label sad\u00addressasavalue.)The secondpassis \nimplementedasavisitor with only three methods. The .rst two methods visit goto statements and label addressexpressions, \nchecking that each labelis de.ned. Figure9showsthe third method, which vis\u00ad its all other AST nodes. \nIt simply enters the node s scope, iterates over its children, dispatching the visitor on children that \nare also nodes, and .nally exits the node s scope again. Type Representation xtc represents typing information \nforJava andCina single, uni.ed class hierarchy, whose common interface is de.ned by the base class Type. \nLeafs of the hierarchy correspond to distinct kinds of types, and intermediate classes capture major \ncategoriesof types.Forexample, both IntegerT and FloatT are subclasses of NumberT, while both ArrayT \nand PointerT are subclasses of DerivedT. In addition to cap\u00adturing each type s inherent properties, such \nas the integral kind for IntegerT or the pointed-to type for PointerT, ev\u00adery type instance can have \nseveral annotations. Theycapture a type s source language and location, scope, compile-time constant \nvalue, memory shape, and other attributes includ\u00adingC quali.ers such as const and Java modi.ers such \nas public. The common interface de.ned by Type provides methods to  determine a type s kind such as \nisClass,  convert to a particular kind such as toFunction,  read annotations such as hasScope and getConstant, \n  add annotations such as attribute. The base class Type also de.nes a Java enum over all type kinds; \nit is accessible through tag tofacilitateef.cient case analysis with Java switch statements. The overall \nhierarchyof types comprises one base class, six intermediate classes, and 21 leaf classes, representing \nthe relativerichnessofthe combinedtype systemsofJavaandC. To makethis information manageable, the hierarchyof \ntypes is supplemented by language-speci.c classes whose meth\u00adods directly capture the corresponding language \nstandard s instructions such as The type of each of the operands of a multiplicative operator must be \na primitive numeric type, ora compile-time error occurs [27, \u00a715.17] or If both the operands have arithmetic \ntype, the usual arithmetic conver\u00adsions are performed [34, \u00a76.5.8]. The hierarchyof types is also supplemented \nby a hierarchyof references, whichrep\u00adresent the shapes of l-values memory regions, are used by theCanalyzer \nto track compile-time constantseven across  (de)reference operations, and are based on the corresponding \nfeature of CIL[43]. Combined Semantic Analyzer With the semantic analyzers for Java andC relying on the \nsame visitor framework, symbol table, and type represen\u00adtation hierarchy(but otherwise having independent \ninternal structures), the composition of the twoanalyzers is relatively straightforward. As illustrated \nin Figure 10,the Jeannie com\u00ad piler s semantic analysis phasebuilds on subclasses of the two analyzers, \nwith each subclass implementingadditional visit methods for that particular language s extensions. Both \nvisitors reference each other and, on encounteringa backtick operator, dispatch the other visitor on \nthe backticked con\u00adstruct. Both visitors also reference the same symbol table, thus ensuring that mappings \nbetween identi.ers and types are shared and that either visitor correctly enters and exits scopes while \ntraversing the AST. Finally, both visitors di\u00adrectly reference types for the other language, since all \ntypes are represented as subclasses of the same base class Type. For example, when processing Jeannie \ns opaque refer\u00adence types, that is, Java types appearing in C s type speci\u00ad.ers,theextended analyzerforCdeferstotheextended \nan\u00adalyzer for Java to determine the appropriate Java type rep\u00adresentation. It then continues processing \nthe variable decla\u00adration with the original, non-extended code. Associating a variable withaJava typein \ntheCanalyzer does notresultin a typing error as long as the variable is only referenced in constructs \nthat support Java types and that have been appro\u00adpriatelyextendedinthe Jeannie analyzer,notably initializers \nand assignments. To process C s function declarators, the extended an\u00adalyzer for C overrides the visitFunctionDeclarator \nmethod. The extended version .rst delegates to the origi\u00adnal method, which ignores the generic node s \nextra child, and then processes the throws clause if present. The type representation for C functions \nFunctionT can seamlessly store the extra information, since its superclass Function-OrMethodT already \ncaptures the union of Java methods and Cfunctions, i.e.,a return type, name, listof parameter types, \nand list of exception types. Discussion We didencounter one obstacle while combining the two se\u00admantic \nanalyzers. The C analyzer relies on a nested class tofactor out the state machine necessary for processing \nC s declaration speci.ers such as const or int. The Jeannie compiler extends this nested visitor with \nsupport for Java types. But, as originally written, theC analyzer created in\u00adstancesof this class througha \nnew expression thus prevent\u00ading substitution with theextendedversion.Weaddressed this issue by introducing \nan explicit (and overridable) factory method. Our.x certainly illustrates the utilityof thefactory design \npattern; though the issue itself could be avoided with dedicated language supportfor composition[45]. \nWhile the composition itself raised only one, relatively minor, concern, developing the sharedfacilities \nand seman\u00adtic analyzers themselves has proven to be a little more chal\u00adlenging. In particular, we encountered \nthree signi.cant is\u00adsues. First, while Java s and C s primitive types are seem\u00adingly similar, theyhave \nsubtle differences. Notably,Ctreats the boolean type _Bool introduced in C99 as an integer, while Java \ndoes not treat its boolean type boolean as an integer. As a result, xtc s type framework must distinguish \nbetweenthetwo languageswhen testingforintegralor arith\u00admetic types and when performing integral promotion. \nWe originally tried including these operations in the common in\u00adterface for Type,but thenfactoredthem \ninto separate classes that provide language-speci.c operations without clutter\u00ading Type s interface. \nFollowing the lesson from the previ\u00adous paragraph, the language-speci.c operations are imple\u00admented by \ninstance methods and the corresponding classes are accessed through factory methods, with the result \nthat operations can be easily overridden. Second, C s integers have only relative rank restrictions, \nwhile Java s integers have .xed in-memory representations. At the sametime, either analyzer must contain \nan interpreter for a substantialsubset of the language s expression syntax to track compile-time constantvalues. \nMoreover,the Jeannie analyzer must be able to map between Java andCintegers. xtc s type framework addresses \nthese concerns by includ\u00ading (1) a class capturing the local platform s type limits and (2) support for \nperforming arithmeticoperations on compile\u00adtime constants independent of the underlying representation. \nThe class representing local type limits can easily be regen\u00aderatedby compilingand runninga simpleCprogram.In \nour testsof 32-bit MacOSX, Linux, andWindows systems, the limits are the same. Third, while C translation \nunits must be self-contained, i.e., must incorporate declarations for all referenced types and variables \nafter preprocessing, Java compilation units may reference types and variables in other source and bi\u00adnary \n.les. While resolution to external classes is lazy, i.e., performed only when encountering an appropriate \nname, it stillrequiresthattheJavaanalyzerbeabletolocate sourceas well as binary .les and determine their \ntypesignatures.For source .les, the Java analyzer parses each .le and then per\u00adformsa lightweight analysisto \ndetermineonlythe signature. For binary .les, our implementation can fortunately avoid most of the complexity \nof resolving and inspecting class .les because it is also written in Java and can use re.ection. Jean\u00adnie \ns analyzerleverages thesefacilitiesto resolve three code formats: Jeannie source,Java source, andJava \nbinary. 5.3 Translation As described in Section 4, the Jeannie language has been carefully designed \nto allow for different implementations. For this paper, we built a compiler that translates Jean\u00adnie \ncode intofairly straightforward JNI code. Consequently, code generated by our Jeannie compiler has the \nsame porta\u00adbility properties as handwritten JNI code: it makes no as\u00adsumptions about the implementation \nof the Java virtual ma\u00adchine. The translator converts a Jeannie AST into two separate ASTs, one forJava \nand one forC.As illustratedin Figure3, the input Jeannie AST combined with a symbol table holds the resultsof \nsemanticanalysis.TheoutputJavaandCASTs are converted to source code using xtc pretty printers, which \nare implemented as visitors. The code generator itself also is a visitor. In the spirit of scalable composition, \nit only has explicit visit methods for a small subset of AST nodes, using a catch-all visit method similar \nto the one shown in Figure9for processing intermediate AST nodes unaffected by Jeannie semantics. Environments \nConsider the Jeannie code example from Figure 5. Snip\u00ad pets1and3 areCcode, whereas Snippets2and4 are \nJava code. The translator turns each snippet into a method as shown in Figure 11:nativemethods m1 and \nm3 for theCsnip\u00adpets and Java methods m2 and m4 for the Java snippets. Snip\u00adpets 1 and 2 are blocks, \nso the corresponding methods m1 and m2 return void.Snippets3and4areexpressions, so the corresponding \nmethods m3 and m4 return non-void values. The formal JNIEnv* env for theCfunctions implementing native \nmethods is the JNI interface pointer. In our translation scheme, nested snippets are executed through \nmethod calls.Forexample,Java Snippet2in Fig\u00adure5containsCSnippet3, and, consequently,Java method m2 in \nFigure 11 calls native method m3. Likewise,C Snip\u00adpet 3 contains Java Snippet 4, and the C function imple\u00admenting \nnativemethod m3 calls Javamethod m4 through JNI. Since JNI s method invocation API requires a class pointer \nand methodID,the translator isolatesthe correspondingdec\u00adlarationsand actual methodinvocationinastatementexpres\u00adsion.Astatementexpression \n({ ... }) is a gcc extension to Cthat introducesa new scope within anexpression; itsvalue is the result \nof executing the last statement. Consistent with Jeannie s semantics,CSnippets1and3 need to share the \nsame dynamicCstate, and Snippets2and 4needto sharethe same dynamicJava state.Forexample, Snippet4modi.esJavavariable \nx, and Snippet2observes that state in the System.out.println(x) statement. Our translator addresses this \nissue by reifying each base lan\u00adguage s dynamic state through explicit environments. The Java environment \nis implemented as a member class that is a sibling of the original method and allocated on the heapon \ncallstothatmethod.Forexample,inFigure11,class JavaEnvFor_f contains .elds _x and _z. Field _x corre\u00adsponds \nto the formal parameter x of f and is initialized in the constructor. Field _z corresponds to the local \nvariable z and is initialized in Snippet 2. The environment s instance meth\u00adods are the methods synthesized \nfor nested snippets, which ensures that all methods have access to the environment s state through the \nimplicit this for Java code and an explicit jobject jEnv forC code. The environment class itselfis static \nfor static methods and non-static for instance meth\u00adods, thus providing access tothe enclosing instance \nonly for instance methods, which is the desired behavior. TheC environmentis implemented asa globalC \nstruct and allocated on the stack in the function implementing the outermost C block. For example, struct \nCEnvFor_f in Figure 11 contains .eld _y, which corresponds to the local variable y of Snippet1in Figure5.Apointer \nto theC environment is passed to all methods implementing nested code snippets. Since Java does not support \npointer types, the corresponding parameteris declaredtobeaJavaintegerand, as illustrated for m3, cast \nbacktoan actual pointerinCcode. Note that the example code uses a 32-bit Java int because the targeted \narchitectureis 32-bit. Of course, the translator avoids name clashes of synthe\u00adsized methodsand .eldswithmembersofexisting \nclassesby generating names distinct from any names free in the body of the original Jeannie method. String \nand Array Access The translation of the _copyFromJava and _copyToJava built-in functions is straightforward. \nIt simply uses one of JNI s copy functions such as GetStringUTFRegion or SetIntArrayRegion, which is \nselected based on the type of the Java string or array and, in the case of strings, the type of the C \npointer to distinguish between UTF-8 and UTF-16 encodings. Similarly, the _getUTF8Length and _newJavaString \nbuilt-ins are translated into the corre\u00adsponding JNI functions such as GetStringUTFLength and NewStringUTF. \nIn contrast, the translation of a _with statement _with (ca = ja){ ... } is moreinvolved.To capture _with \ns semantics, the Jeannie translator introduces two additional bindings in a method s Cenvironment: _caJavaObject, \nwhich cachesaCreferencetotheJava object resulting from expression ja and is used to release the string \nor array;  _caReleaseMode, which can be JNI_COMMIT or JNI_-ABORT andis updatedbytranslated _commit and \n_abort statements.  Again, synthesized names avoid accidental name capture and maythus differ from the \nnames shown here.To actually acquire and release arrays, the translation uses the same JNI copyfunctions \ndiscussed above, allocating theC array on the stack. To acquire and release strings, it uses JNI functions \nsuch as GetStringChars and ReleaseString-Chars, which, depending on the JVM, may provide direct access \nto a string s contents. This does not violate _with statement semantics because Java strings are immutable \nand thus should not be updated by native code. Abrupt Control Flow Consistent with Jeannie s dynamic \nsemantics as described in Section 4.2, the return i statement in Figure7abruptly transfers control to \nthe method s caller while also releasing the array s.To implement these semantics, the translator in\u00adtroducestwoadditional \nbindingsinamethod sJavaenviron\u00adment: _returnResult to hold the return value of non-void methods;  _returnAbrupt \nto indicate whetheramethod sdynamic execution has initiated a return.  Figure 12 shows the complete \ntranslation of Figure 7 s return i statement. It .rst sets _returnResult and _re\u00adturnAbrupt in the Java \nenvironment. It then sets _sRe\u00adleaseMode in the C environment; as described in Sec\u00adtion 4.2 under string \nand array access , the return state\u00adment is an implicit _commit. Finally, it jumps to label release_s \nat the end of the translated _with statement. After releasing the array s, the code at the end of the \ntrans\u00adlated _with statement checks whether _returnAbrupt is true and, if so, re-initiates the pending \nabrupt method termi\u00adnation. Abrupt termination checks occur not only at the end of _with statements,butalso \nat the language boundary,since the method returns generated for abrupt control .ow do not propagate beyond \nthe method calls generated for nestedcode snippets. Notably, abrupt termination checks are generated \nfor calls from Java to native methods implementingCsnip\u00adpets, if the snippets contain return statements. \nThey are also generatedfor callsfromCtoJava methods implement\u00ading Java snippets, if the snippets may \nthrow exceptions or contain return statements. Figure 13 shows an abrupt termination check inC gen\u00ad erated \nfor a nested Java expression. The Java expression itself is executed by method m1. The abrupt termination \ncheck .rst cachesthe method s resultinvariable tmp. It then checks for a pending Java exception or a \nreturn .agged by _returnAbrupt. If so, it propagates the abrupt control .ow through a return (orajumptotheend \nlabelofasur\u00adrounding _with). Otherwise, the statement expression sim\u00adply evaluates to the cached result \ntmp. Discussion Our translation of Jeannie focuses on completeness. It cor\u00adrectly implements the whole \nlanguage,but the resultingcode may be inef.cient, because it tends to be more general than necessary. \nWe are aware of several opportunities for opti\u00admization. For instance, when a nested code snippet only \nreadsbutnever writesavariable,itsuf.cestopassthatvari\u00adable s value down through a parameter instead of \nplacing it in an environment class or struct. In manycases, the transla\u00adtor could thus avoid reifying \nenvironments altogether. Furthermore,whenaJava snippet nestedinCcodeper\u00adforms only a single Java operation \nthat has a corresponding JNI function, the translator can directly use the JNI function instead of synthesizing \nan entire method wrapping the oper\u00adation.Typically, the JNI function willbe moreef.cient than an upcall \nfromC toJava. After transformingaJava opera\u00adtionintoa directJNI functioncall,the translatormayalsobe \nable to skip a language transition. More speci.cally, when the current language is C, code of the form \n`( java-op (`c-expr )) can be translated into code of the form ({ T tmp=c-expr; (*env)->jni-function(tmp); \n}) where theC expressionisevaluated before theJava opera\u00adtion rather than in a callback from within \nthe operation. Finally, a _with statement can avoid copying an array and instead provide direct access \nto its contents if the ob\u00adservable behavior is the same. Notably, this is the case if the _with statement \ns block cannot abort and other threads cannot prematurely observe anymodi.cations. JNI already { jclass \ncls = (*env)->GetObjectClass(env, jEnv); jfieldID fidResult = (*env)->GetFieldID(env, cls, \"_returnResult\", \n\"I\"); (*env)->SetIntField(env, jEnv, fidResult, pcEnv->_i); jfieldID fidAbrupt = (*env)->GetFieldID(env, \ncls, \"_returnAbrupt\", \"Z\"); (*env)->SetBooleanField(env, jEnv, fidAbrupt, JNI_TRUE); pcEnv->_sReleaseMode \n= JNI_COMMIT; (*env)->DeleteLocalRef(env, cls); goto release_s; } Figure 12. Ccode generated for the \nreturn i statement from Figure7. ({ jclass cls = (*env)->GetObjectClass(env, jEnv); jmethodID mid = (*env)->GetMethodID(env, \ncls, \"m1\", \"(I)I\"); jint tmp = (*env)->CallNonvirtualIntMethod(env, jEnv, cls, mid, (jint)pcEnv); jfieldID \nfid = (*env)->GetFieldID(env, cls, \"_returnAbrupt\", \"Z\"); (*env)->DeleteLocalRef(env, cls); if ((*env)->ExceptionCheck(env) \n|| (*env)->GetBooleanField(env, jEnv, fid)) return; tmp; }) Figure 13. Ccode generated fora nestedJavaexpression \nwith abrupt termination check, simpli.edfor readability. Description Pseudo-code EmptyCblockinJava EmptyJava \nblockinC ConstantC expr. in Java Constant Java expr. inC Exception inCin Java Direct array read Direct \narray write With array read With array write `{} `{} `1 `1 try `{ `throw } catch {} s += `a[`i] `(a[`i] \n= `1) _with (a) { s += a[i]; } _with (a) { a[i] = 1; } Table 1. Summary of micro-benchmarks. allows \nfor direct access to(some) arrays throughthe, for example, GetPrimitiveArrayCritical and Release-PrimitiveArrayCritical \nfunctions. But it relies on the programmer to restrict the code bracketed by these func\u00adtions. In contrast, \nJeannie s _with statement is more general and enables direct access as an optimization when the code, \ninfact, observes the necessaryrestrictions.We willinvesti\u00adgate the relative priority of these and other \noptimizations in future work. 6. Evaluation We evaluated our Jeannie compiler by porting part of the \nJavaBDD library [60] to Jeannie. JavaBDD de.nes an object-oriented API for manipulating binary decision \ndia- Program Jeannie Java C BuDDy wrapper 1,433 660 1,340 Micro-benchmarks 110 102 74 Table 2. Lines \nof code for Jeannie and JNIversions. grams and can interface with several implementations, in\u00adcluding \nthe BuDDy library written inC[39]. Our port re\u00ad places the JNI-based wrapper for BuDDy with the corre\u00adsponding \nJeannie version; this entailed rewriting 92 native methods across three classes. Additionally, we implemented \na set of micro-benchmarks, which, as shown in Table 1, exercise all major language features new to Jeannie. \nEach micro-benchmark is implemented in Jeannie as well as plain Java andCusing JNI. The JNIversionsdo \nnot useexplicit environments, thus incorporating the optimization discussed at the end of Section 5.3. \nTo demonstrate portability, all experiments run on two platforms with different Java virtual machines \nand operat\u00ading systems. The .rst platform ( HS/OS X ) is Apple s port of Sun s HotSpot JVM running on \na MacBook Pro laptop with Mac OS X. The second platform ( J9/Linux ) is IBM s J9 JVM running on an off-the-shelf \nIntel PC with Linux. De\u00adspite the different Java virtual machines and operating sys\u00adtems, all benchmarks \nseamlessly run across the two plat\u00adforms. Portability is a strong point of JNI, and the Jeannie compiler \npreserves it. Benchmark HS/OS X J9/Linux 11-Queens Rubik s Cube 1.04 1.15 1.04 1.14 Empty Cblock in Java \nEmpty Java block in Constant C expr. in Java Constant Java expr. in C Exception in Cin Java With array \nread With array write 0.98 C 1.86 1.05 1.45 1.05 1.09 1.19 1.23 1.41 1.06 1.36 0.95 1.65 1.06 Table \n3. Speedup of JNI over Jeannie code. To provide an indication of productivity, Table 2 com\u00adpares the \nnumber of non-commenting, non-empty lines of code (LoC) between the Jeannie and JNI versions of the BuDDy \nwrapper and the micro-benchmarks. It does not count theC header .les automatically generatedby javah \nfor the JNI versions. The LoC counts show that Jeannie is more concise than JNI, with JNI requiring 40% \nmore code for the BuDDy wrapper and 60% more code for the micro\u00adbenchmarks. Additionally, the JNI versions \nrequire picking all the rightAPI functions, with mistakes manifesting them\u00adselves as either linker or, \nworse, runtime errors. Jeannie not only prevents these mistakes in the .rst place,but also per\u00adforms \nadditional staticchecks across the language boundary. Finally, the JNI versions incur a higher maintenance \ncost, since they are spreadover three separate .les(.h, .c, and .java)instead of just one for Jeannie. \nTo quantify the overhead of the Jeannie compiler s trans\u00adlation scheme, Table 3 shows the speedup of \nthe JNI ver\u00ad sions over the Jeannie versions in a head-to-head perfor\u00admance comparison. The .rst two \nbenchmarks exercise the BuDDy library through N-Queens and Rubik s Cube solvers distributed with JavaBDD. \nSpeedup numbers are based on three iterations for each of the BuDDy benchmarks and one million iterations \nfor each of the micro-benchmarks. The results show that the translation scheme s overhead is reasonable, \nespecially for the end-to-end benchmarks using BuDDy, which see an overhead of at most 15%. By com\u00adparison, \nthe micro-benchmarks showmorevariance, ranging from no speedup to overheads of several tens of percent \nfor most micro-benchmarks to an outlier at 1.86.For compari\u00adson,the Jeannieversionsofthe 11-Queensand \nRubik sCube solvershavea speedup between1.16 and 1.28overa pure Java implementationofJavaBDD.Weexpect \nthis speedup to increase, and JNI s speedup over Jeannie to decrease, as we implement the optimizations \ndiscussed in Section 5.3. Initial testing exhibited a performance anomaly for one micro-benchmark. Further \ntesting showed that this anomaly was causedby creating too manylocal references, which the garbage collector \nuses to track pointers fromCto Java ob\u00adjects. Consequently changing the Jeannie translator to ex\u00adplicitly \nand eagerly release local references eliminated the anomaly. Thisexperience demonstrates an additional \nadvan- Access HS/OS X J9/Linux Read 74.2 69.6 Write 74.7 83.8 Table 4. Speedupof array accessesthrough \n_with. tage of Jeannie over JNI. Once an optimization has been im\u00adplemented in the Jeannie compiler, \nall Jeannie code bene\u00ad.ts througha simple recompilation.Incontrast,JNI requires manually updating all \nC code in this particular case, all method and .eld accesses through JNI s re.ection-like API. To quantify \nthe bene.ts of the_with statement,Table4 shows the speedupof accessing an array through _with over backticked \nsubscript expressions. Each experiment either reads or writes each element in a 1,000 element int array. \nOverall, Jeannie obtains roughly a factor 75 speedup by providing the _with construct, which clearly \njusti.es this non-orthogonalextensiontothetwo base languages. Finally,we consider the Jeannie compiler \nitself. The Jean\u00adnie grammaraddsfour moduleswith250LoCtotheexisting grammars for Java and C. The Java \ngrammar, in turn, com\u00adprises8 modules with 800 LoC, and theC grammar com\u00adprises 10 modules with 1,200 \nLoC. The Jeannie compiler s Java code, excluding any machine-generated code, com\u00adprises 1,900 non-commenting \nsource statements (NCSS), which approximately corresponds to 1,900 semicolons and open braces and is \na more conservative measure than the lines of code used above. By comparison, the C analyzer alone comprises \n4,200 NCSS, the Java analyzer alone also comprises4,200 NCSS, and the common type representation comprises \n2,600 NCSS. Based on these statistics, we con\u00adclude that our composition of existing compiler components \nforJavaandC was successful;the Jeannie compiler s com\u00adplexity directly re.ects the complexity of Jeannie \ns added features and not of the two embeddedlanguages. Addition\u00adally,the compiler s performancewas reasonablein \nour inter\u00adactions; it did not feelnoticeably slower than other compilers in the tool chain. 7. Related \nWork Work related to Jeannie can be categorized into work on (1) the Java native interface in particular \nand foreign function interfaces in general, as well as on (2)combined languages and support for implementing \nlanguageextensions and com\u00adpositions. 7.1 Bridging Java, Other Languages with C BesidesJeannie,several \nothereffortshaveexplored implica\u00adtionsoftheJava native interface.Outof these, Janet[15,36] comes closestto \nJeannieby embeddingCinJavaas well;it even relies on the backtick operator to switch between Java and \nC. However, Janet performs only limited semantic anal\u00adysis forJava and none forC.Infact,even its syntactic \nanal\u00adysis forCis incomplete, tracking only curly braces and em\u00adbeddedJavaexpressions.Asaresult, Janet \ncan abstractaway explicit JNI invocations, but also suffers from two signi.\u00adcant limitations. First, \nJanet supports only Java embedded inC embedded in Java, with the embedded Java code lim\u00adited to a few, \nsimple expressions that have direct equivalents in JNI. Second, while Janet veri.es that methods and \n.elds referencedfrom embeddedJavado,infact,exist,itdoesnot determine their types nor does it determine \nthe correctness ofthe embeddedCcode.Asa result, programbugs arede\u00adtected either when compiling the resultingCcode \nor,worse, at runtime. UnlikeJanet, Jeannie fully composes the twolan\u00adguages and thus is more expressive, \nwhile also ensuring the correctness of programs. Other work on JNI has explored the safety, ef.ciency, \nand portability implications of interfacing a safe, high-level language with an unsafe, low-level language. \nIn particular, Furr andFoster[23]havedevelopeda polymorphic type in\u00ad ference system for JNI, which statically \nensures that literal names used in JNI invocations are consistent with the dy\u00adnamic typesofCpointers. \nAlternatively,Tanetal.[54]have extended CCured[19]to ensure thatCcode cannot subvert the safety of Java \ncode. Their system relies on a combina\u00adtion of static analysis and runtime checks, thus guaranteeing \nsafety.Inthe opposite direction,TanandMorrisett[55]show how to improve the reach of Java analyses in \nthe presence of native code.To this end, they introduce three new JVM bytecodes that model the behavior \nof C code and present a tool that automatically extracts models from native code. Next, Stepanian et \nal.[51] explore how to reduce the perfor\u00admanceoverheadofJNIinvocationsfor small native methods such as \nObject.hashCode by inlining the code in the vir\u00adtual machine s just-in-time (JIT) compiler. Finally, \nthe Java JNI bridge[18]supports interfacing witha dynamic binary translator to run C code compiled for \na different architec\u00adture than the JVM s. These efforts are largely orthogonal to our own work, though \nJeannie s combined language is more amenable to semantic analysis and code generation than JNI with its \nre.ection-like callbacks into the Java runtime. Of course, JNI itself represents only one point in the \ndesign space of foreign function interfaces (FFIs). As dis\u00adcussed in detail in[46], FFIs provide both \nmechanism and policy for bridging between a higher-level language and C. The mechanism typically entails \nglue code to convert between the different data representations and calling con\u00adventions.Forexample, \nlike JNI, the FFIs for O Caml[37] and SML/NJ[33] as well as the Swig FFI generator for scripting languages \n[7] rely on glue code written in C. However, the FFI for the Scheme-based esh shell[47], the Haskell \nFFI[17], NLFFI forSML/NJ[10], and Charon for Moby[21] extend the higher-level language so that glue code \ncan be written in the higher-level language. The policy determines how to abstract C s low-level data \nstructures and functions in the higher-level language. For most FFIs, this policy is .xed. For example, \nJNI enforces an object-oriented view ofC code and data. However, FIG for Moby[46]allows for domain-speci.c \npoliciesby tailor\u00ad ing the FFI based on developer annotations.Similarly, Exu for Java[35]allows for customized \npolicies through a meta\u00ad object protocol. In contrast, PolySPIN[6] and Mocking\u00adbird[2]hidemostofanFFI \nsmechanismandpolicybyauto\u00ad matically mapping between data structures and functions of languages with \nrecursive (but not polymorphic) types. Like\u00adwise, Jeannie hides mostofJNI s mechanism and policy,but \nit eschews the type mapping machinery for a direct embed\u00adding of languages within eachother.  7.2 Combined \nLanguages and Their Pragmatics Language composition hasa long history back to literalC code appearing \nin speci.cations for lex and yacc and shell code appearing in speci.cations for sed and awk. However, \nthese systems largely treat snippets of the embedded lan\u00adguage as opaque strings. More recently, web \nscripting en\u00advironments, such as PHP[5] or JSP[48], ensure that em\u00adbedded HTML markup is at least syntactically \nwell-formed. Next, XJ[31],XTATIC[26],C. [8],and LINQ[41]takelan\u00ad guage composition one step further, \ncombining a program\u00adming language withadata query language while also provid\u00ading an integrated semantics. \nJeannie shares the integration of syntax and semantics with the latter efforts,but also differs in scope: \nto our knowledge, we are the .rstto fully combine two mature, real-world programming languages. To effectively \ncombine or even to just extend program\u00adming languages, developers require tool and/or language support. \nWhile Jeannie relies on Rats! and xtc to make the compositionofJava andCpractical,a considerable bodyof \nwork explores support for modular syntax, frameworks for languageextension and composition, and in-language \nmacro or meta-programming systems. A .rst attempt at providing modular syntax was moti\u00advatedbytheembeddingofadata \nlanguage withinaprogram\u00adming language[16];itis,however, limitedbythe useofLL parsing, which is not closed \nunder composition. In contrast, SDF2[14, 57]achieves full modularity for syntactic speci.\u00ad cations and \nhas several similarities with Rats!. Notably, both systems support the organization of grammar fragments \ninto modules and the composition of modules through parameter\u00adized de.nitions, called grammar mixins \nin SDF2[12]. Both systems also integrate lexical analysis with parsing and sup\u00adport the inline declaration \nof abstract syntax trees. At the same time, SDF2 and Rats! differ in the under\u00adlying formalism and parsing \ntechnique, thus leading to dif\u00adferent trade-offs. SDF2builds on CFGs and GLR parsing, which support arbitrary \nleft-recursion but also lead to un\u00adnecessary ambiguities, thus requiring explicit disambigua\u00adtion[56]. \nRats! builds on PEGs and packrat parsing, which avoid unnecessary ambiguities through ordered choicesbut \ndo not support left-recursion. It mitigates this limitation somewhat by translating directly left-recursive \nproductions into equivalent right-iterations. Rats! also differs from SDF2 in its support for parser \nstate: it enables parsers that pro\u00adduce a single AST, even if the language is context-sensitive, while \nSDF2 sC parser requires non-trivial post-processing to disambiguate a forest of ASTs[1]. Finally, as \nshown in [29], Rats!-generated parsers are notably faster than SDF2-generated parsers. While modular \nsyntax helps with the composition of lan\u00adguages, developers still need support for realizing their lan\u00adguages \nsemantics. Notable alternatives to xtc include Poly\u00adglot[44], JastAdd[20], CIL[43], and Stratego/XT[13]. \nPolyglot and JastAdd provide frameworks for extending Java; they have been carefully designed to promote \nexten\u00adsibility and maximize code reuse. Similarly, CIL provides a framework forextendingC,but with less \nemphasis onexten\u00adsibility and more emphasis on the analysis ofC programs. All three frameworks have been \nused to realize major lan\u00adguageextensions, includingJ&#38;withPolyglot[45],Java1.5 ontopofversion1.4 \nwith JastAdd[32],and CCured with CIL[19]. Stratego/XTisnottargetedatextensionsofapar\u00ad ticular programming \nlanguage. Rather,itprovidesa domain\u00adspeci.c language for specifying program transformations in general; \nit is also integrated with other language processing tools such as SDF2. As a language extension/composition \nframework, xtc is not yet as fully developed as these sys\u00adtems; however, as illustrated in this paper, \nit is suf.ciently expressive to carry the full composition of Java andCinto Jeannie. Unlike the previous \nefforts, which distinguish between the syntactic and semantic aspects of language extension and composition, \nmacro systems such as MS2 forC[59], Dylan[49], the Java Syntactic Extender[3], MacroML[25], MayaforJava[4],Template \nHaskell[50],andthelanguage\u00ad independent metafront [11] combine both aspects into a single speci.cation.For \nthese systems,a macro de.nes, at the same time, how to express a language extension, i.e., the syntax, \nand how to translate it to a more basic version of the language, i.e., the semantics. Overall, macros \ntend to hide manyof the complexities of grammars, abstract syntax trees, and semantic analysis from developers \nand thus are more accessible and precise. However, as a result, they are also less expressive and more \nsuitable for relatively targeted language modi.cations. 8. Conclusions This paper presented Jeannie, \na new language design for integrating Java with C. Jeannie nests both Java and C code within eachother \nin the same .le and supports a rela\u00adtively straightforward translationtoJNI, theJava platform s foreign \nfunction interface. By fully combining the syntax and semantics of both languages, Jeannie eliminates \nver\u00adbose boiler-plate code, enables static error detection even across the language boundary, and simpli.es \ndynamic re\u00adsource management. As a result, Jeannie provides improved productivity and safety when compared \nto JNI, while also retaining the latter s portability. At the same time, the Jean\u00adnie language does not \nrequire an implementation with JNI, and future work will explore how to optimize the translation for \nspeci.c Java virtual machines, thus improving ef.ciency as well. Weimplemented our Jeannie compiler \nbased onRats! [29], a parser generator supporting modular syntax, and xtc [28], a language composition \nframework. The compiler directly reuses grammars, semantic analyzers, and pretty printers for Java 1.4 \nand C with most gcc extensions. As a result, the complexity of the Jeannie compiler is largely commensurate \nwith the newly added features and not the entire language. However, our experiences also illustrate the \nneed for paying careful attention to shared infrastructure, notably the type representation, and to provide \nsoftware hooks for overrid\u00ading default behaviors. The open source release of our Jean\u00adnie compilerisavailableat \nhttp://cs.nyu.edu/rgrimm/ xtc/.  Acknowledgments This material is based upon work supported by the Na\u00adtional \nScienceFoundation underGrants No. CNS-0448349 and CNS-0615129 and by the Defense Advanced Research Projects \nAgency under ContractNo. NBCH30390004.We thank Joshua Auerbach, Rodric Rabbah, Gang Tan, David Ungar, \nand the anonymous reviewers for their feedback on earlier versions of this paper. References [1]R. Anisko,V.David,andC.Vasseur. \nTransformers:aC++ program transformation framework. Tech. Report 0310, Laboratoire de Recherche etD\u00b4eveloppement \nde l Epita, Le Kremlin-Bic etre cedex, France, May 2004. [2] J. Auerbach, C. Barton, M. Chu-Carroll, \nand M. Raghavachari. Mockingbird:Flexible stub compilation from pairs of dec\u00ad larations. In Proc. 19th \nIEEE International Conference on Distributed Computing Systems, pp. 393 402, May 1999. [3]J.BachrachandK. \nPlayford. TheJava syntacticextender (JSE). In Proc. 2001ACM Conference on Object-Oriented Programming \nSystems, Languages, and Applications, pp. 31 42, Oct. 2001. [4] J. Baker andW. C. Hsieh. Maya: Multiple-dispatch \nsyntax extension in Java. In Proc. 2002 ACM Conference on Programming Language Design and Implementation, \npp. 270 281, June 2002. [5] S. S. Bakken, A. Aulbach, E. Schmid, J. Winstead, L. T. Wilson, R. Lefdorf, \nA. Zmievski, and J. Ahto. PHP Manual. PHP Documentation Group, Feb. 2004. http: //www.php.net/manual/. \n[6] D. J. Barrett, A. Kaplan, and J. C. Wileden. Automated supportfor seamless interoperability in polylingual \nsoftware systems. In Proc. 4th ACM SIGSOFT Symposium on Foundations of Software Engineering, pp. 147 \n155, Oct. 1996. [7] D. M. Beazley. SWIG: An easy to use tool for integrating scripting languages withCand \nC++. In Proc. 4th USENIX Tcl/TkWorkshop, July 1996. [8]G. Bierman,E. Meijer,andW. Schulte. The essenceof \ndata access inC.. In Proc. 19th European Conference on Object-Oriented Programming, vol. 3586 of LNCS, \npp.287 311, July 2005. [9] J. Blosser. Java tip 98:Re.ect on the visitor design pattern. JavaWorld, July \n2000. http://www.javaworld.com/ javaworld/javatips/jw-javatip98.html. [10] M. Blume. No-longer foreign:Teaching \nan ML compiler to speakC natively . Electronic Notes in Theoretical Computer Science, 59(1):36 52, Sept. \n2001. [11] C. Brabrand, M. I. Schwartzbach, and M.Vanggaard. The metafront system: Extensible parsing \nand transforma\u00ad tion. Electronic Notes in Theoretical Computer Science, 82(3):592 611, Dec. 2003. \u00b4and \nextensible syntax de.nition for AspectJ. In Proc. 2006 ACM Conference on Object-Oriented Programming \nSystems, Languages, and Applications, pp. 209 228, Oct. 2006. [12] M. Bravenboer, E.Tanter, andE.Visser. \nDeclarative, formal, [13] M. Bravenboer, A. van Dam, K. Olmos, and E. Visser. Program transformation \nwith scoped dynamic rewrite rules. Fundamenta Informaticae, 69(1 2):123 178, 2005. [14]M.BravenboerandE.Visser. \nConcrete syntaxfor objects.In Proc. 2004ACM Conference on Object-Oriented Program\u00adming Systems, Languages, \nand Applications, pp. 365 383, Oct. 2004. [15] M. Bubak, D.Kurzyniec, andP. Luszczek. Creating Java to \nnative code interfaces with Janet extension. In Proc. SGI Users s Conference, pp. 283 294, Oct. 2000. \n[16] L. Cardelli,F. Matthes, and M. Abadi. Extensible syntax with lexical scoping. Tech. Report 121, \nDigital Equipment, Systems Research Center, Feb. 1994. [17] M. Chakravarty, S. Finne, F. Henderson, M. \nKowalczyk, D. Leijen, S. Marlow, E. Meijer, S. Panne, S. P. Jones, A. Reid,M.Wallace, andM.Weber. The \nHaskell98 foreign function interface 1.0. http://www.cse.unsw.edu.au/ ~chak/haskell/ffi/, 2003. [18] \nM. Chen, S. Goldenberg, S. Srinivas,V. Ushakov,Y.Wang, Q. Zhang,E.Lin,andY. Zach.JavaJNI bridge:Aframework \nfor mixed native ISA execution. In Proc. International IEEE Symposium on Code Generation and Optimization, \npp. 65 75, Mar. 2006. [19] J. Condit, M. Harren, S. McPeak, G. C. Necula, and W. Weimer. CCured in the \nreal world. In Proc. 2003 ACM Conference on Programming Language Design and Implementation, pp. 232 244, \nJune 2003. [20] T. Ekman and G. Hedin. The JastAdd extensible Java compiler. In Proc. 2007ACM Conference \non Object-Oriented Programming Systems, Languages, and Applications, Oct. 2007. [21] K. Fisher, R. Pucella, \nand J. Reppy. A framework for interoperability. Electronic Notes in Theoretical Computer Science, 59(1):3 \n19, Sept. 2001. [22] M. E. Fiuczynski, R. Grimm, Y. Coady, and D. Walker. patch (1) considered harmful. \nIn Proc. 10thWorkshop on HotTopicsin Operating Systems, pp. 91 96, June 2005. [23] M. Furr andJ.S.Foster. \nPolymorphic type inference for the JNI. In Proc. 15th European Symposium on Programming, pp. 309 324, \nMar. 2006. [24] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Elements of Reusable \nObject-Oriented Software. Addison-Wesley, Jan. 1995. [25] S. E. Ganz, A. Sabry, and W. Taha. Macros as \nmulti\u00ad stage computations:Type-safe, generative, binding macros in MacroML. In Proc. 2001ACM International \nConference on Functional Programming, pp. 74 85, Sept. 2001. [26]V.Gapeyev,M.Y.Levin,B.C. Pierce,andA. \nSchmitt.XML goes native: Run-time representations for XTATIC. In Proc. 14th International Conference \non Compiler Construction, vol. 3443 of LNCS, pp. 43 58, Apr. 2005. [27] J. Gosling, B. Joy, G. Steele, \nand G. Bracha. The Java Language Speci.cation. Addison-Wesley, second edition, June 2000. [28] R. Grimm. \nxtc (eXTensible C). http://cs.nyu.edu/ rgrimm/xtc/. [29] R. Grimm. Better extensibility through modular \nsyntax. In Proc. 2006 ACM Conference on Programming Language Design and Implementation, pp. 38 51, June \n2006. [30]C. Grothoff.Walkaboutrevisited:The runabout.In Proc. 17th European ConferenceonObject-OrientedProgramming,vol. \n2743 of LNCS, pp. 101 125, July 2003. [31] M. Harren, M. Raghavachari, O. Shmueli, M. G. Burke, R. Bordawekar, \nI. Pechtchanski, andV. Sarkar. XJ:Facili\u00ad tating XML processingin Java. In Proc. 14th International WorldWideWeb \nConference, pp. 278 287, May 2005. [32] G. Hedin. The JastAdd extensible Java compiler. http: //jastadd.cs.lth.se/web/extjava/index.shtml. \n[33]L. Huelsbergen.AportableCinterfacefor StandardMLof NewJersey.Tech. report,AT&#38;T Bell Laboratories, \nJan. 1996. http://www.smlnj.org/doc/SMLNJ-C/smlnj-c.ps. [34] International Organization for Standardization. \nInformation Technology Programming Languages C. ISO/IEC Stan\u00ad dard 9899:TC2, May 2005. [35] A. Kaplan, \nJ. Bubba, and J. C.Wileden. The Exu approach to safe, transparent and lightweight interoperability. In \nProc. 25th IEEE Computer Software and Applications Conference, pp. 393 400, Oct. 2001. [36] D.Kurzyniec. \nCreating Java to native code interfaces with Janet extension. Master s thesis, University of Mining and \nMetallurgy, Krak\u00b4ow, Poland, Aug. 2000. http: //janet-project.sourceforge.net/papers/janet msc.pdf. [37] \nX. Leroy,D. Doligez,J.Garrigue,D.R\u00b4emy, andJ.Vouillon. The Objective Caml system release 3.09. http://caml. \ninria.fr/, Oct. 2005. [38] S. Liang. TheJavaNative Interface: Programmer s Guide and Speci.cation. Addison-Wesley, \nJune 1999. [39] J. Lind-Nielsen. BuDDy. http://buddy.sourceforge. net/. [40] B. McCloskeyandE. Brewer. \nASTEC:A new approach to refactoringC. In Proc. 10th European Software Engineering Conference, pp. 21 \n30, Sept. 2005. [41] E. Meijer, B. Beckman, and G. Bierman. LINQ: Reconciling object, relations and XML \nin the .NET framework. In Proc. 2006 ACM SIGMOD International Conference on Management of Data, p. 706, \nJune 2006. [42] T. Millstein. Practical predicate dispatch. In Proc. 2004 ACM Conference on Object-Oriented \nProgramming Systems, Languages, and Applications, pp. 345 364, Oct. 2004. [43] G. C. Necula, S. McPeak, \nS. P. Rahul, and W. Weimer. CIL: Intermediate language and tools for analysis and transformation ofCprograms. \nIn Proc. 11th International Conference on Compiler Construction, vol. 2304 of LNCS, pp. 213 228, Apr. \n2002. [44] N. Nystrom, M. R. Clarkson, and A. C. Myers. Polyglot: An extensible compiler framework for \nJava. In Proc. 12th International Conference on Compiler Construction, vol. 2622 of LNCS, pp. 138 152. \nSpringer, Apr. 2003. [45] N. Nystrom, X. Qi, and A. C. Myers. J&#38;: Nested intersection for scalable \nsoftware composition. In Proc. 2006 ACM Conference on Object-Oriented Programming Systems, Languages, \nand Applications, pp. 21 36, Oct. 2006. [46] J. ReppyandC.Song. Application-speci.c foreign-interface \ngeneration. In Proc. 5th International Conference on Generative Programming and Component Engineering, \npp. 49 58, Oct. 2006. [47] J. R. Rose and H. Muller. Integrating the Scheme and C languages. In Proc. \n1992 ACM Conference on LISP and Functional Programming, pp. 247 259, June 1992. [48] M. Roth and E. Pelegr\u00b4i-Llopart. \nJavaServerPages speci.\u00adcation version 2.0. Tech. report, Sun Microsystems, Nov. 2003. [49] A. Shalit. \nThe Dylan Reference Manual. Addison-Wesley, Sept. 1996. [50]T.Sheard andS.Peyton Jones.Template meta-programming \nfor Haskell. ACM SIGPLAN Notices, 37(12):60 75, Dec. 2002. [51] L. Stepanian, A. D. Brown, A. Kielstra, \nG.Koblents, and K. Stoodley. Inlining Java native calls at runtime. In Proc. 1stACM/USENIX Conference \nonVirtual Execution Environments, pp. 121 131, June 2005. [52] Sun Microsystems. Javanativeinterface \nspeci.cation, release 1.1, Jan. 1997. [53] Sun Microsystems. Integrating native methods into Java programs. \nhttp://java.sun.com/docs/books/ tutorialNB/download/tut-native1dot0.zip, May 1998. [54] G. Tan, A. W. \nAppel, S. Chakradhar, A. Raghunathan, S. Ravi, and D.Wang. Safe Java native interface. In Proc. 2006 \nIEEE International Symposium on Secure Software Engineering, pp. 97 106, Mar. 2006. [55] G. Tan and G. \nMorrisett. ILEA: Inter-language analysis across Java and C. In Proc. 2007 ACM Conference on Object-Oriented \nProgramming Systems, Languages, and Applications, Oct. 2007. [56] M. G. J. van den Brand, J. Scheerder, \nJ. J. Vinju, and E.Visser. Disambiguation .lters for scannerless generalized LR parsers. In Proc. 11th \nInternational Conference on Compiler Construction, vol. 2304 of LNCS, pp. 143 158. Springer, Apr. 2004. \n[57] E.Visser. Syntax De.nition for Language Prototyping. PhD thesis, University of Amsterdam, Sept. \n1997. [58] J.Visser.Visitor combination and traversal control. In Proc. 2001 ACM Conference on Object-Oriented \nProgramming Systems, Languages, and Applications, pp. 270 282, Oct. 2001. [59] D.Weise and R. Crew. Programmable \nsyntax macros. In Proc. 1993 ACM Conference on Programming Language Design and Implementation, pp. 156 \n165, June 1993. [60] J. Whaley. JavaBDD. http://javabdd.sourceforge. net/. [61]M.Yuen,M. Fiuczynski,R.Grimm,Y.Coady,andD.Walker. \nMakingextensibilityofsystemsoftware practicalwiththeC4 toolkit. In Proc.AOSDWorkshop on Software Engineering \nPropertiesof LanguagesandAspectTechnologies,Mar. 2006.   \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Higher-level languages interface with lower-level languages such as C to access platform functionality, reuse legacy libraries, or improve performance. This raises the issue of how to best integrate different languages while also reconciling productivity, safety, portability, and efficiency. This paper presents Jeannie, a new language design for integrating Java with C. In Jeannie, both Javaand C code are nested within each other in the same file and compile down to JNI, the Java platform's standard foreign function interface. By combining the two languages' syntax and semantics, Jeannie eliminates verbose boiler-plate code, enables static error detection across the language boundary, and simplifies dynamic resource management. We describe the Jeannie language and its compiler, while also highlighting lessons from composing two mature programming languages.</p>", "authors": [{"name": "Martin Hirzel", "author_profile_id": "81100572340", "affiliation": "IBM Watson Research Center, Hawthorne, NY", "person_id": "PP39049113", "email_address": "", "orcid_id": ""}, {"name": "Robert Grimm", "author_profile_id": "81100553777", "affiliation": "New York University, New York, NY", "person_id": "P245049", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297030", "year": "2007", "article_id": "1297030", "conference": "OOPSLA", "title": "Jeannie: granting java native interface developers their wishes", "url": "http://dl.acm.org/citation.cfm?id=1297030"}