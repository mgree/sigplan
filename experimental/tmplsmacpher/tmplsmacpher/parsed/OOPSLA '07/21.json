{"article_publication_date": "10-21-2007", "fulltext": "\n STARC: Static Analysis for Ef.cient Repair of Complex Data Bassem Elkarablieh Sarfraz Khurshid Duy \nVu Kathryn S. McKinley University of Texas at Austin University of Texas at Austin {elkarabl,khurshid}@ece.utexas.edu \n{duyvu,mckinley}@cs.utexas.edu Abstract Data structure corruptions are insidious bugs that reduce the \nreliability of software systems. Constraint-based data structure repair promises to help programs recover \nfrom potentially crippling corruption errors. Prior work repairs a variety of relatively small data structures, \nusually with hundreds of nodes. We present STARC which uses static analysis to repair data structures \nwith tens of thousands of nodes. Given a Java predicate method that describes the integrity constraints \nof a structure, STARC statically analyzes the method to identify: (1) the recurrent .elds, i.e., .elds \nthat the predicate method uses to traverse the structure; and (2) local .eld constraints, i.e., how the \nvalue of an object .eld is related to the value of a neighboring object .eld. STARC executes the predicate \nmethod on the structure and monitors its execution to identify corrupt object .elds, which STARC then \nrepairs using a systematic search of a neighborhood of the given structure. Each repair action is guided \nby the result of the static analysis, which enables more ef.cient and effective repair compared to prior \nwork. Experimental results show that STARC can repair structures with tens of thousands of nodes, up \nto 100 times larger than prior work. STARC ef.ciency is probably not practical for very large data structures \nin deployed systems, but opens a promising direction for future work. Categories and Subject Descriptors \nD.2.5 [Software En\u00adgineering]: Testing and Debugging Symbolic execution; D.2.5 [Software Engineering]: \nTesting and Debugging Error handling and recovery General Terms Reliability Keywords Static analysis, \ndata structure repair, symbolic execution Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4ebec, Canada. eal, Qu\u00b4Copyright \nc . 2007 ACM 978-1-59593-786-5/07/0010. . . $5.00 1. Introduction As software systems are growing in \ncomplexity, reliability is becoming harder to achieve. Efforts to improve reliabil\u00adity are directed toward \ndesign, testing, and validation [2]. All these activities are performed before the software is de\u00adployed. \nSuch approaches are fundamental for providing a certain level of con.dence in program correctness and \nro\u00adbustness, yet they do not prevent errors and anomalies from occurring dynamically in deployed software. \nFor example, a single bit .ip, say due to a cosmic ray, can compromise the safety of a Java Virtual Machine \nwith high probability and allow an intruder to run arbitrary code [19]. Usually, when an error occurs \nin a running application, programmers terminate the application, debug, test, and re\u00addeploy it. While \nthis halt-on-error approach is sometimes necessary, e.g., during the execution of a security protocol, \nthere are situations where alternative approaches are more desirable. For example, with corruption of \npersistent data, such as a .le system, a simple reboot is unlikely to help. As another example, consider \nan intentional naming server for service location in a dynamic network [1]. If the server fails due to \na malformed query, a continual subjection to the query will force perpetual failures. This problem compounds \nfor deployed software, which cannot be promptly debugged and re-installed. An alternative to halt-on-error \nis to repair the state of the program and let it continue. In several cases, this alterna\u00adtive allows \nsystems to resume their correct behavior. For ex\u00adample, a server that does not crash on a malformed query \nbut repairs it, can continue to correctly resolve well-formed ones. Similarly, repairing a .le system \nor a database can re\u00adcover valuable data. For deployed software, repair, even if it degrades performance, \nis an attractive alternative. Traditionally, special routines perform repairs [20, 36]. Recently, generic \nrepair techniques have been introduced [10, 11, 12, 13, 28]. These techniques use constraints (given \nas .rst-order logic formulas, imperative predicates, or asser\u00adtions), which describe desired properties \nof program states, as a basis for repairing corrupt states that violate the prop\u00aderties. While generic \ntechniques repair a variety of complex data structures, their execution time limits them to relatively \nsmall structures with up to a few hundred nodes. This paper presents STARC, an assertion-based frame\u00adwork \nfor ef.cient and effective repair of data structures, that may consist of tens of thousands of objects. \nSTARC sys\u00adtematically explores a neighborhood of the given corrupt structure using a backtracking search \n[8, 18, 21, 22] and performs repair actions, i.e., mutations of object .elds, to transform the structure \ninto one that satis.es the desired as\u00adsertion. STARC draws its key strength from a static analysis that \nenables it to perform repair actions that are more likely to correct the corruption. Given a Java predicate \nmethod that represents the struc\u00adtural integrity constraints, the static analysis identi.es two key characteristics. \nOne, it identi.es a set of recurrent .elds, i.e., .elds that the Java predicate primarily uses to traverse \nits input structure, using a forward data-.ow analysis [6]. Two, it identi.es a set of local .eld constraints, \ni.e., how the value of an object .eld is related to the value of a neighbor\u00ading object .eld, using symbolic \nexecution [17]. STARC uses the result of the static analysis to (1) prioritize the order of repair actions \nbased on the role of the corrupt .eld (recur\u00adrent or not), which makes ef.cient local repairs of corrupt \n.elds and (2) monitor .eld accesses based on their relation\u00adship with their neighboring .elds, which \nenables effective pruning of the search space. We evaluate our repair algorithm by using STARC to re\u00adpair \na set of complex data structures that violate their struc\u00adtural integrity constraints. Experiments show \nthat STARC feasibly repairs faulty structures with tens of thousands of nodes. These results show that \nconstraint-based data struc\u00adture repair is promising and may be able to reach the perfor\u00admance required \nfor on-the-.y repair of in deployed systems. We make the following contributions: Static analysis for \nrepair. We use static analysis for ef.cient search-based repair.  Algorithm to repair data structures. \nWe present an algorithm that builds on previous work, and combines static analysis with systematic search \nto enable ef.cient and effective repair of structures using imperative predi\u00adcates.  Implementation. \nWe present the STARC tool that imple\u00adments our repair algorithm.  Evaluation. We evaluate our implementation \nusing a va\u00adriety of subjects and present experimental results that show two orders of magnitude improvement \nover the pre\u00advious work.  2. Examples In this section, we present two examples to describe the use of \nour repair algorithm. The .rst example is a circular doubly linked list. This example illustrates how \nSTARC can repair faults in the structure of the list, and how static analysis improves the performance \nof repair. The second example is an acyclic binary search tree. This example illustrates how boolean \nrepOk() { // if the list is empty, size must be 0 L1. if (header == null) L2. return size == 0 ; L3. \nSet visited = new HashSet(); L4. visited.add(header); L5. Node current = header; L6. while (true) { L7. \nNode n = current.next; // next fields must not be null L8. if (n == null) L9. return false; // prev \nmust be the transpose of next L10. if (n.prev != current) L11. return false; L12. current = n; L13. if \n(!visited.add(n)) L14. break; } // reachability constraint L15. if (visited.size() != size) L16. return \nfalse; L17. return true; } Figure 1. Class invariant for the DoublyLinkedList. STARC repairs errors \nin the structure, as well as errors in the values of the primitive .elds of the tree to satisfy its data \nconstraints. 2.1 Doubly Linked List Consider the following class declaration of a circular doubly linked \nlist: class DoublyLinkedList { Node header; int size; static class Node { int element; Node next; Node \nprev; } } The inner class Nodemodels the entries in a list. Each list has a headerand a size.eld, and \neach node has an integer element and two node pointers (next and prev). The size .eld represents the \nnumber of unique node objects reachable from the header node by following the next (or the prev) .elds \nof the nodes. The structural integrity constraints (class invariant) of DoublyLinkedList are: (1) circular \nstructure along next; (2) transpose relation between the next and prev .elds; and (3) number of nodes \nreachable from the header .eld following nextis cached in size. The structural constraints of the DoublyLinkedList \ncan be written as a predicate that returns true if and only if its input satis.es all the constraints. \nFollowing the litera\u00adture, we term such a Java predicate repOk and for object\u00adoriented programs, we term \nstructural invariants, class in\u00advariants [33]. The class invariant for the DoublyLinkedList class is \ndisplayed in Figure 1. To repair a doubly linked list, STARC analyzes the repOk predicate and detects \nthat nextis the recurrent .eld, and that the prev .eld is always equal to the transpose of the next Figure \n2. Repairing a circular doubly linked list. The dashed lines represent violations of the structural constraints \nof a doubly linked list. (a) An erroneous structure with two corruptions in the next .eld of node N2 \nand the prev .eld of node N3. (b -g) Mutations that an assertion based repair algorithm performs to repair \nthe structure. .eld. Then, given an erroneous structure STARC mutates the structure to satisfy the constraints \ndescribed in repOk. STARC uses static analysis to scale the performance of pre\u00advious assertion based \nrepair algorithms [13, 17, 28, 39]. To illustrate, consider the DoublyLinkedList instance in Figure 2(a). \nThis list violates both the transpose constraint between next and prev .elds of nodes N2 and N3, as well \nas the reachability constraint where the next .eld of node N2 points to the node N1 rather than node \nN3. Figure 2(b-g) shows the steps and mutations that an assertion-based repair tool, Juzi [28], performs \nto repair the structure. To repair the corruption in the next .eld of node N2, Juzi .rst sets the .eld \nto null (Figure 2(b)). If null does not repair the corruption, Juzi tries all the previously visited \nnode during traversal, (Figure 2(c,d)). Finally, Juzi tries one new non\u00advisited node (Figure 2(e)) which \nin this example repairs the corruption in the next.eld. Juzi applies the same procedure to repair the \nprev.eld, and thus, performs a total of 7 repair actions in order to repair the corrupt list. STARC, \non the other hand, only performs 2 mutations, Figures 2(e) and 2(h), to repair the corrupt structure. \nSTARC uses the static analysis result to prioritize the order of the mutations on the corrupt .eld. For \na recurrent .eld, STARC gives a higher priority for selecting a new non-visited node rather than a visited \none or null, since recurrent .elds are used for traversal, and are highly likely to point to a new node. \nFor this example, STARC .rst sets the next .eld of node N2 to the new non-visited node N3, and thus, \nrepairs the next .eld in one try. STARC also detects the transpose relation between the prev and the \nnext .eld using static analysis. Using this information, STARC directly sets the prev .eld of node N3 \nto node N2, and repairs the structure. Figure 3. Repairing a binary search tree. The dashed lines represent \nviolations of the structural constraints of a binary search tree. (a) An erroneous tree with four faults \nin the structure, and faults in the data. (b-d) The steps that STARC takes to repair the structure of \nthe tree, i.e., break all the cycles. (e) The constraints on the order of the data computed using symbolic \nexecution. (f) Resulting tree after applying our repair algorithm. 2.2 Binary Search Tree The DoublyLinkedList \nexample illustrates the use of STARC to repair faults that violate the structural constraints of a list. \nWe now present an example that illustrates the use of STARC in generating primitive values that satisfy \nthe data constraints of a data structure. Consider the following class declaration of a binary search \ntree, i.e., an acyclic graph that satis.es the search constraints on the values of its nodes: class BinarySearchTree \n{ Node root; int size; static class Node { int elem; Node left; Node right; }} Each BinarySearchTree \nobject has a root node and stores the number of nodes in the .eld size. Each Node object has an integer \nvalue called elem and has a left and a right child. The class invariant of BinarySearchTree can be formulated \nas follows. boolean repOk() { if (!isAcyclic()) return false; if (!sizeOk()) return false; if (!searchConstraintsOk()) \nreturn false; return true; } When invoked on a BinarySearchTree object o, the predicate repOk traverses \nthe object graph rooted at o and checks all the constraints that characterize a binary search tree. If \nany constraint is violated the predicate returns false; otherwise, it returns true. The implementation \nof the helper methods is presented elsewhere [14]. To collect constraints on the order of the data in \na binary search tree, STARC uses symbolic execution [31]. After repairing the faults in the structure \nof the tree, STARC solves the data constraints and generates values that complete the repair of the binary \nsearch tree. To illustrate, consider the binary search tree in Fig\u00adure 3(a). The dashed lines represent \n.elds that violate the acyclicity constraints. Figures 3(b-d) show the steps that STARC takes to break \nthe cycles in the structure. Follow\u00ading a depth .rst traversal which accesses the left .eld before the \nright .eld, STARC breaks a cycle each time it encounters an already visited node. Figure 3(e) shows the \npath condition after symbolically executing repOk on the repaired structure. The path condition contains \nthe con\u00adstraints on the order of the data values. Figure 3(f) shows the repaired structure after solving \nthe path condition and reordering the values in the tree. This example illustrated how STARC repairs \nfaults in the structure as well as data. However, STARC could be con.gured not to alter the data values, \nif the developers preferred to only repair the structure (Section 6.5). 3. Background This section gives \na brief description of forward symbolic execution and search-based repair. 3.1 Forward Symbolic Execution \nForward symbolic execution is a technique for executing a program on symbolic values [31]. There are \ntwo fundamen\u00adtal aspects of symbolic execution: (1) de.ning semantics of operations that are originally \nde.ned for concrete values and (2) maintaining a path condition for the current program path being executed. \nA path condition speci.es necessary con\u00adstraints on input variables that must be satis.ed to execute \nthe corresponding path. As an example, consider the follow\u00ading program that returns the absolute value \nof its input: int abs(int i) { L1. int result; L2. if(i<0) L3. result = -1 * i; L4. else result = i; \nL5. return result; }  boolean repair(Object s, Pred repOk) throws Exception { Search.initialize(s); \nPathCondition.initialize(); boolean done = false; do { try { if (repOk.invoke(s)) { if (!PathCondition.isFeasible()) \ncontinue; done = true; break; } } catch (Exception e) { if (e.getClass() != BacktrackException.class) \nthrow e; } } while (Search.incrementCounter()); return done;  } Figure 4. Search-based repair algorithm. \n To symbolically execute this program, we consider its be\u00adhavior on a primitive integer input, say I. \nWe make no as\u00adsumptions about the value of I (except what can be deduced from the type declaration). \nSo, when we encounter a condi\u00adtional statement, we consider both possible outcomes of the condition. \nTo perform operations on symbols, we treat them simply as variables, e.g., the statement on L3 updates \nthe value of result to be -1 * I. Of course, a tool for symbolic execution needs to modify the type of \nresult to note updates involving symbols and to provide support for manipulating expressions, such as \n-1*I. Symbolic execution of the above program explores the following two paths: path 1: [I < 0] L1 -> \nL2 -> L3-> L5 path 2: [I >= 0]L1 -> L2 -> L4 -> L5 Note that for each explored path, there is a corresponding \npath condition (shown in square brackets). While execution on a concrete input would have followed exactly \none of these two paths, symbolic execution explores both. 3.2 Search Based Repair This section describes \nJuzi [13, 17, 28, 39], a search based algorithm for assertion-based repair. Given a structure s and a \nrepOk method that represents desired structural in\u00adtegrity constraints such that !s.repOk(), Juzi performs \nmutations on s to transform it into a structure s such that s .repOk(). Figure 4 gives an overview of \nthe repair algorithm, which performs a systematic search and uses symbolic execu\u00adtion. The class Search \nrepresents the backtracking engine; PathCondition represents integer constraints that arise during symbolic \nexecution. The algorithm repeatedly in\u00advokes repOk. Each invocation results in a repair on s. The algorithm \nterminates when s is repaired, i.e., s.repOk() returns true and the corresponding path condition is satis\u00ad.able, \nor when the search is exhausted. The do-whileloop performs a systematic search by im\u00adplicitly enabling \nnon-deterministic .eld assignments within a standard Java Virtual Machine: the repeated invocations of \nrepOk inside the loop body systematically tries different Figure 5. STARC framework for automatic data \nstructure repair. The bold rectangles are the components that STARC adds on previous work on assertion-based \nrepair. The static analysis guides the search of the dynamic repair framework. values for .elds that \nrepOk accesses. The .rst invocation of repOk uses the original values for all .elds. Each subse\u00adquent \ninvocation modi.es the value of the .eld that was ac\u00adcessed last by repOk according to the ordering of \n.elds by their .rst access. If all values for the current .eld have been exhausted, the algorithm backtracks \nby resetting the original value for the current .eld, and modifying the value of the .eld accessed before \nthe current one in the ordering. Let repOk read .eld f of object o such that o.f == v for some value \nv. There are two cases to consider: reference and primitive .eld accesses. References. Let f be a reference \n.eld of type T . The algorithm non-deterministically assigns o.f: v, i.e., its current value; null, if \nv .= null; value w of a type T , such that v . = w and w has already been encountered during repOk \ns invocation;  a new value of type T , if v is not different from all values of type T already encountered \nduring repOk s invocation.  Primitives. Let f be a primitive .eld of type T . The algorithm non-deterministically \nassigns o.f: v, i.e., its current value;  if T == int, a new symbolic value I, and adds the constraint \nI . = v to the current path condition;  if T ..  = int, a primitive value w (= v) non-deterministically \nchosen from domain(t) Notice that a primitive .eld access may introduce sym\u00adbolic integer values. For \nthese values, invocation of repOk follows forward symbolic execution [29, 31], and satis.abil\u00adity of \npath conditions is checked using CVC Lite [3]. Since reference as well as non-integer primitive .elds \ninitially have concrete values, the .rst execution of repOk follows stan\u00addard Java semantics for these \nvalues. 4. STARC This section describes STARC, an ef.cient engine for per\u00adforming data structure repair. \nSTARC incorporates both static and dynamic analysis to provide an ef.cient frame\u00adwork for automatic data \nstructure repair. Figure 5 shows the repair framework. STARC has two main modules, a static analyzer \nand a dynamic search-based repair frame\u00adwork. STARC takes two inputs: (1) the class declaration of the \ndesired structure, and (2) a predicate method repOk that describes the structural integrity constraints. \nThe repair pro\u00adcess is performed in three phases. First, STARC performs static analysis on the structure \ndeclaration and repOk to de\u00adtect the recurrent .elds of the structure (Section 4.1) and to extract constraints \non references that can be solved statically (Section 4.2). Then, STARC uses the results of the static \nanalyzer to instrument the structure declaration. Structure instrumentation includes replacing .eld access \nwith invoca\u00adtions of get methods, adding boolean variables to monitor the initialization of the .elds, \nand inserting calls into the repair routines. Details are available elsewhere [29, 39]. Fi\u00adnally, STARC \nmonitors the execution of the predicate and, if necessary, triggers the repair framework which uses (1) \nsymbolic execution [31] to populate the constraints of prim\u00aditive values, (2) systematic search to repair \nthe faults in the structure [5], and (3) integer constraint solver to solve the constraints on primitives \n(Section 4.3). We next describe each of the components of STARC in detail, and illustrate the performance \nadvantage of STARC over Juzi with an example (Section 4.4). 4.1 Detecting recurrent .elds of a structure \nThe performance of Juzi depends on the number of repair actions1 that are required to repair a structure. \nTo scale the performance of the search algorithm, STARC .rst imple\u00adments a static analyzer that detects \nthe recurrent .elds of the data structure. A key observation behind .nding the re\u00ad 1 We use the term \nrepair action to indicate a mutation that the algorithm tries when exploring the space for repairing \na .eld current .elds is that such .elds satisfy the reachability con\u00adstraint of the structure. A recurrent \n.eld is more likely to point a new un-visited object rather than an already visited one. STARC uses this \ninformation to prioritize the repair ac\u00adtions, as well as prioritizing .elds to repair when exploring \nthe neighborhood of the faults. Cahoon and McKinley [6, 7] proposed a data .ow analy\u00adsis framework for \ndetecting the recurrent .elds for prefetch\u00ading of linked structures. We use this analysis to prioritize \nthe repair actions. The problem is modeled as a forward data .ow analysis problem. We .rst de.ne some \nterms that we use to describe the components of the framework, then we describe the data-.ow framework \nand illustrate how STARC uses the recurrent .eld information to prioritize repair ac\u00adtions. 4.1.1 Terminology \nWe start by de.ning the following terms: Information unit (IU): An information unit is the left hand \nside of an assignment operation on objects or object .elds. An information unit is used to save and propagate \ninformation in the data .ow framework.  Object .eld (F): An object .eld is a reference .eld in the data \nstructure.  Recurrent status (RS): The recurrent status of an object .eld can have one of three values: \nnon recurrent (nr), possibly recurrent (pr), and recurrent (r), where the el\u00adements are ordered such \nthat nr = pr = r.  Information site (IS): An information site is a program statement of interest.  \nFor example, consider the repOkmethod for the doubly LinkedList class (Section 2.1). The information \nunits are the local variables visited, current, n, and the implicit variable this. The object .elds are \nthe header .eld of the variable this, and the nextand prev.elds of the variables current and n respectively. \nThe information sites are lines L3, L5, L7, L12, and L0, the entry of the method.  4.1.2 Data-.ow framework \nThe basic data unit in the data .ow framework is the infor\u00admation tuple T : T . (IU \u00d7 F \u00d7 IS \u00d7 RS) The \ndata .ow framework includes: Initialization: When initializing an information tuple, all the components \nof the tuple are initialized to the bottom element of their lattices. For an information unit, iu, the \nbottom element is iu, for an object .eld, the bottom element is null, for an information site, the bottom \nelement is L0, and for the recurrent status, the bottom element is nr. The data-.ow functions: The propagation \nof informa\u00adtion in the framework occurs at the information sites. We consider two types of information \npatterns: equality patterns and access patterns. Given an input set of information tuples, Rin, we compute: \n Equality patterns: Equality patterns take the form: (information unit) = (information unit)' GEN(iu \n= iu', Rin)= {(iu, f, is, rs)|(iu', f, is, rs) . Rin} KILL(iu = iu', Rin)= {(iu, f, is, rs)} Access patterns: \nAccess patterns take the form: (information unit) = (information unit)'.(object .eld) if {(iu', null, \nL0, nr)}. Rin (iu, f, is, pr)GEN(iu = iu'.f, Rin)= if {(o, f, is, pr)}. Rin (iu, f, is, r) KILL(iu = \niu'.f, Rin)= {(iu, f, is, pr), (iu, null, L0, nr)}  The meet operation: The meet operation (U) is de.ned \non sets of tuples. Given two sets T1 and T2, the meet opera\u00adtion is de.ned as follows: T 1 U T 2= {t|t \n. T 1 . t . T 2}.{t|t . T 1 . t . T 2}.{(iu, f, is, rs1 U rs2)|(iu, f, is, rs1) . T 1 .(iu, f, is, rs2) \n. T 2} The transfer functions: The transfer functions are: Ain(ip)= Aout(p) p.pred(ip) Aout(ip)=(Ain(ip)/KILL(ip, \nAin(ip))) U GEN(ip, Ain(ip)) Starting at the entry of the analyzed method (repOk), all the tuples are \ninitialized. The algorithm proceeds by propagating information and iterating until a .xed point is reached. \nTo illustrate, the .rst three iterations of the data .ow analysis for the DoublyLinkedList s repOk are \ndis\u00adplayed in Table 1. The framework converges in the fourth iteration. At the end of the analysis, the \n.eld objects in the tu\u00adples that have a recurrent status r are considered the recur\u00adrent .elds of the \nclass as used by repOk. For example, as expected, in Table 1 all the tuples that have r as a recur\u00adrent \nstatus have next as an object .eld. Thus, next is the .eld used for traversing a list in the repOk method \nof the DoublyLinkedList class. The prev .eld is not reported by the analysis as a recurrent .eld since \nit is not used by repOk to traverse the structure. Note that interprocedural analysis is performed similarly. \nAt the call site, information is propagated to the entry of the called method by following a set of equality \npatterns for each argument in the method signature. At the return site, information is propagated from \ncalled method to the caller by following an equality pattern at the caller side. 4.1.3 Prioritizing \nrepair actions STARC uses the information about the reference .elds to prioritize the candidates for \nrepairing the structure .elds. Re\u00adcall that Juzi follows the same search pattern (Section 3.2) stmt RA \nIteration 1 Iteration 2 Iteration 3 L5 in (current, null, L0, nr) (current, null, L0, nr) (current, null, \nL0, nr) (n, null, L0, nr) (n, null, L0, nr) (n, null, L0, nr) L5 out (current, header, L5, pr) (current, \nheader, L5, pr) (current, header, L5, pr) (n, null, L0, nr) (n, null, L0, nr) (n, null, L0, nr) L7 in \n(current, header, L5, pr) (current, header, L5, pr) (current, header, L5, pr) (current, null, L0, nr) \n(current, next, L12, pr) (current, next, L12, r) (n, null, L0, nr) (n, null, L0, nr) (n, null, L0, nr) \n(n, next, L7, pr) (n, next, L7, r) (n, next, L7, r) L7 out (current, header, L5, pr) (current, header, \nL5, pr) (current, header, L5, pr) (current, null, L0, nr) (current, next, L12, pr) (current, next, L12, \nr) (n, next, L7, pr) (n, next, L7, r) (n, next, L7, r) L9 in (current, header, L5, pr) (current, header, \nL5, pr) (current, header, L5, pr) (current, null, L0, nr) (current, next, L12, pr) (current, next, L12, \nr) (n, next, L7, pr) (n, next, L7, r) (n, next, L7, r) L9 out (current, next, L12, pr) (current, next, \nL12, r) (current, next, L12, r) (n, next, L7, pr) (n, next, L7, r) (n, next, L7, r) Table 1. The .rst \nthree iterations of the data .ow framework. The bold tuples indicate an update in the tuple information \nduring successive iterations. The tuples for the information unit this and visited are never updated \nand thus they are omitted for brevity. The .elds of the tuples that have a recurrent status r are recurrent \n.elds of the structure. when taking repair actions to .x an error in a reference .eld. The recurrent \n.elds of a linked data structure are used to traverse the structure starting from a given root node. \nFor traversing a structure, recurrent .elds are more likely to point to new (non visited) nodes or nullrather \nthan pointing to previously visited nodes. STARC orders its repair candi\u00addates based on the type of the \nfaulty .eld (recurrent or not). For recurrent .elds, STARC gives higher priority for choos\u00ading a new \n(non-visited) candidate over choosing a visited one or null. For the non-recurrent .elds, STARC chooses \nthe same order presented in Section 3.2; STARC gives higher priority to choosing a visited node over \na new node. This op\u00adtimization not only improves performance (Section 4.4) but also guarantees that the \nreachability of the structure is pre\u00adserved by repair.  4.2 Detecting constraints on references Structural \nproperties often constrain aliasing possibilities, e.g., o.f == p . p.g == o for objects o and p, and \n.elds f and g. Solving such constraints can be ef.ciently performed symbolically without enumerating \nthe search space. STARC implements a static constraint solver that re\u00adpairs particular .elds instantaneously; \nwithout triggering the search algorithm. Some of the imperative constraints on ref\u00aderence .elds take \nthe following pattern: if (iu != iu ) { ... return false; } For example, the transpose relation between \nthe next and prev .elds of the DoublyLinkedList class takes the fol\u00adlowing form: Node n = current.next; \nif (n.prev != current) return false; The solution of such constraints is embedded in the nega\u00adtion of \nthe condition. STARC performs static analysis on the control .ow graph of the repOk method to detect \nthese pat\u00adterns. Once these patterns are detected, the solver injects the solution of the constraint \ninto the repOkmethod. All the analysis that STARC performs is at the Java byte\u00adcode level. To detect \npatterns in a method, STARC builds the control .ow graph (CFG) and searches for basic blocks where the \nentry instruction is a conditional branch and the exit instruction is an integer return. To detect the \nitems be\u00ading compared in the conditional statement, STARC uses the JVM speci.cation [32] to trace the \nlast two items produced on the stack. For example, consider the bytecode example of the transpose constraint \nof the DoublyLinkedList as de\u00adscribed in repOk lines L10and L11 in Section 2.1: // compare prev to current \n42: aload_3 43: getfield #32; //Field DoublyLinkedList\\$Node.prev; 46: aload_2 47: if_acmpeq 52 // return \nfalse 50: iconst_0 51: ireturn STARC detects the parameters of the conditional state\u00adment by following \nthe consumer/producer chain of the pre\u00advious instruction until two items are produced in the stack. In \nthe above example, the instructions used to produce the comparison objects are: 42: aload_3 // consume: \n0 produce: 1 43: getfield #32; // consume: 1 produce: 1 and 46: aload_2 // consume: 0 produce: 1 (a) \n(b) Figure 6. Data constraint graph for the BinarySearch Tree in Figure 3(e). The dotted lines are the \nedges from the newly added root. (a) Before solving the constraints, all the dotted edges are labeled \nwith ? . (b) Solution for the dif\u00adference constraints; each ? has been replaced with a value that satis.es \nthe constraints. These instructions are then used to produce the solution for the constraint and add \nthe solution to the byte code as follows: 42: aload_3 43: getfield #32; //Field DoublyLinkedList\\$Node.prev; \n46: aload_2 47: if_acmpeq 57 // set the field of prev to current 51: aload_3 52: aload_2 53: putfield \n#32; //Field DoublyLinkedList\\$Node.prev; Using this solver, STARC identi.es equality constraints and \ndirectly solves such constraints without using any non\u00addeterministic search. This optimization enables \nhighly ef.\u00adcient solving of a variety of local constraints. To illustrate, STARC automatically detects \nthe transpose relation at lines L10 and L11 in Figure 1 of DoublyLinkedList and .xes any violation in \nthe prev .eld by setting it to the transpose of its predecessor s next .eld.  4.3 Solving data constraints \nPrevious work on assertion based repair proposed different approaches for checking the satis.ability \nof the data con\u00adstraints of a data structure. Demsky [10] proposed an ap\u00adproach similar to the one taken \nin Alloy [23] and the Alloy Analyzer. Their framework translates the constraints written in their language \ninto a disjunctive normal form formula and solves the formula for satis.ability. Juzi uses symbolic exe\u00adcution \non repOk to extracts the path condition that the data variables should satisfy and checks the satis.ability \nof the path condition using a theorem prover (CVClite [3]). We have previously developed Dicos [14], \na difference constraint solver for primitive integers. Dicos handled inte\u00adger constraints that take the \nform x<y and x = y. We extended the implementation of Dicos to handle equality constraints of the form \nx .y and x == y. Following a = textbook algorithm [9], the current implementation builds a constraint \ngraph where the vertices are the primitive .elds, and the edges are the constraints. Dicos adds a root \nnode in the graph that is a predecessor of all the nodes. Once the graph is built, the problem simpli.es \nto .nding the single source shortest path from the added root node. To check the satis.ability of the \nconstraints, Dicos checks for nega\u00adtive cycles in the graph. A negative cycle indicates a con\u00adtradiction \nin the constraints. Dicos implements the Bellman-Ford [15] algorithm to .nd the shortest path in time \nO(v.e). Since the complexity of the data constraints varies between structures, Dicos uses faster algorithms \nfor handling simple constraints. For example, the data integrity constraints of the binary search tree \nexample (Section 2.2) are translated into a directed acyclic graph (DAG) rather than a cyclic one. For \na directed acyclic graph with v nodes and e edges, Dicos can compute the primitive values in O(v + e) \nusing a topologi\u00adcal traversal. To illustrate, Figure 6 shows the data constraint graph for the path \ncondition in Figure 3(e). The topological distance from the added root node to each node determines the \norder of the data and solves the path condition. Dicos keeps track of the nature of the graph being constructed \nand then decides on which algorithm to use. Dicos even performs some simpli.cations on the path condition \nthat might solve satis.ability without the need of a solver. These simpli.ca\u00adtions include transforming \nconstraints in a path condition to a canonical form, performing subsumption checking for sim\u00adple cases, \nand propagating constants. Dicos also handles more complex constraints like linear programs, and quadratic \nprograms, yet using this capability requires user intervention to pre-select the desired algorithm based \non the target problem. Note that Dicos still uses CV-Clite to check satis.ability if the constraints \ndo not .t a cat\u00adegory that it can handle. 4.4 Illustration We next illustrate the performance gain that \nSTARC achieves due to the aforementioned optimizations. We compare the performance of Juzi and STARC \nin repairing faults in the doubly linked list example from Section 2.1. We .rst con\u00adsider the example \nof the erroneous list in Figure 7(a). All the prev .elds in the list point to the header node. We repair \nthis list using Juzi and STARC. Juzi made 25 repair actions and required 15ms to repair the structure \nwhereas STARC took 5 repair actions in less than 1ms. We then consider the erroneous list in Figure 7(b). \nIn this list, the faults occur in the next .eld of node N3 and in the prev .eld of nodes N0 and N2. For \nrepairing this list Juzi took 47 repair actions in 37ms whereas STARC took three repair actions again \nin less than 1ms. This improvement in performance is due to the optimizations applied in STARC which \ndirect the repair algorithm to select the most-likely option .rst. This reduces the number of attempts \nneeded to repair a .eld. (c) Figure 7. (a) An erroneous list with all the prev .elds pointing to the \nheader node. (b) An erroneous list with a fault in the next.eld of the fourth node and the prev.eld of \nthe third node. (c) The resulting list after applying our repair algorithm; all the constraints are satis.ed. \n5. Evaluation This section evaluates the ef.ciency of STARC in repairing large data structures. First, \nwe present the methodology for evaluating STARC. We then use STARC to repair a set of standalone subject \ndata structures. Finally, we demonstrate STARC on an application that implements a software cache. 5.1 \nMethodology We evaluate STARC by applying it to faulty implementa\u00adtions of ten subject structures. For \neach subject, we eval\u00aduate the time it takes to repair a faulty structure for sizes: 100, 1,000, 10,000, \nand 100,000. We repeat the repair pro\u00adcedure using 50 different randomization seeds and report the average \nrepair time. We also compare the number of re\u00adpair actions required to .x the errors. This metric measures \nthe growth of the search algorithm and the ef.ciency of the added optimizations. We consider one example \nin detail to illustrate how STARC generates structures that can automat\u00adically repair themselves when \nan error occurs. We compare the results of STARC with those of Juzi. We set a threshold time of 10 minutes \nto repair a faulty structure, and stop the execution after that period. To study the ef.ciency of both \nthe static analyzer and the constraint solver, we consider subjects that vary in the types and complexity \nof their constraints. We .rst consider struc\u00adtures with constraints on the structure only, that do not \nre\u00adquire the integer constraint solver. We then consider struc\u00adtures with constraints on both the structure \nand data that re\u00adquire the use of the integer constraint solver to determine the satis.ability of the \nconstraints on primitive data. In or\u00adder to clearly expose the advantage of the static analyzer, we consider \nstructures with complex structural and data con\u00adstraint and use our constraint solver in both Juzi as \nwell as in STARC. Any performance advantage is thus due to the improvement in the performance of the \nsearch algorithm. We next describe the data structure subjects and the repair results. All experiments \nused a 1.7 GHZ Pentium M proces\u00adsor with 1 GB of RAM. 5.2 Subjects Table 2 lists the subject structures \nand the integrity con\u00adstraints. The binary search tree and the doubly linked list are both presented \nin Section 2. Disjoint set is a linked-based implementation of the fast union-.nd data structure [9]; \nthis implementation uses both path compression and rank esti\u00admation heuristics to improve ef.ciency. \nFibonacci heap is a dynamic data structure that implements a heap, but dif\u00adfer from a binary heap in \ncomplexity for certain opera\u00adtions [9]. Singly linked list is the simplest structure with constraints \nonly on the acyclicity of the structure. Sorted list is structurally identical to a singly linked list \nbut the ele\u00adments are sorted. Red-black and AVL tree implement a bal\u00adanced search tree, with red-black \ntrees having complex con\u00adstraints on the colors of the nodes along the paths from the root [9]. N-ary \ntrees are used in the implementations of XML documents and .le systems. Software cache is a more com\u00adplex \nstructure that comprises both a hash table and a doubly linked list. For each of the subjects, we constructed \na set of faulty structures by generating valid structures using available API s calls, and randomly traversing \nand mutating their ref\u00aderence and value .elds. 5.3 Results Table 3 displays the time and the number \nof repair actions taken by Juzi and STARC to repair the described subject structures. Singly linked list \nhas the simplest of the con\u00adstraints and the least number of faults and its repair is there\u00adfore the \nfastest. The n-ary tree data structure is similar in complexity to the singly linked list, yet the number \nof faults is larger. Note that the performance of Juzi and STARC is in\u00addistinguishable for simple constraints \nlike acyclicity. Break\u00ading cycles is achieved by setting the value of the corrupt .eld to null. The performance \nof the integer constraint solver is tested in the sorted list and the binary search tree examples. Recall \nthat Juzi uses a theorem prover (CVClite [3]) to check for the satis.ability of the path condition. The \nresults show that using a dedicated integer constraint solver provides up to one order of magnitude improvement \nfor STARC espe\u00adcially in large structures. For the rest of the subjects, we use the same constraint solver \nfor Juzi and STARC in order to study the improvement due to the static analysis. The doubly linked list, \nand the disjoint set data structure are structurally more complex than the singly list and the n-ary \ntrees. Results show that for solving constraints like transpose, sentinel (all pointers point to a sentinel \nnode) and reachabilitiy, STARC outperforms Juzi by more than two orders of magnitude. Juzi did not .nish \nthe execution within Table 2. Subject structures and their integrity constraints. Subjects vary in the \ncomplexity of their structural and data constraints. We generated a valid set of structures for each \nsubject, and randomly injected faults that violate the integrity constraints. subject structural constraints \ndata constraints Singly linked list acyclicity, reachability N/A Sorted linked list acyclicity, reachability \nsorted elements n-ary tree acyclicity, reachability, one parent N/A Binary Search tree acyclicity, reachability, \none parent natural order on elements Doubly linked list reachability, transpose, circularity N/A Disjoint \nsets acyclicity, reachability, sentinel disjoint members AVL tree acyclicity, reachability, one parent, \nbalance natural order on elements Red-black tree acyclicity, reachability, one parent, transpose, path, \ncolor natural order on elements Fibonacci heap acyclicity, reachability, transpose, circularity min, \nheap property Software cache reachability, transpose, circularity, hash correct binning of items the \ngiven time when repairing a doubly linked list with 1,000 nodes and 100 faults, whereas STARC was able \nto repair a doubly linked list with 100,000 nodes in less than a minute. Note that although the algorithm \nis complete for both Juzi and STARC, the former took 21,656 repair actions to re\u00adpair 10 faults in a \ndoubly linked list of size 1,000 whereas the latter only took 9 actions. The static analyzer in STARC \nbias the repair algorithm toward solving the reachability con\u00adstraint while repairing a recurrent .eld. \nJuzi on the other hand repairs the faults in the structure, yet the repaired struc\u00adture might not satisfy \nthe reachability constraint, thus it keeps searching for a structure that satis.es all the con\u00adstraints. \nThis explains the large performance gain of STARC over Juzi. We test the ef.ciency of STARC on repairing \nmore com\u00adplex constraints like balance (AVL), color and path (red\u00adblack). Again for these structures, \nSTARC is able to repair structures with one hundred thousand nodes within the given time. Recall that \nthe performance of STARC is directly propor\u00adtional to the number of repair actions taken while repairing \na structure. In our experiments, the number of repair actions grows linearly with the number of corruptions \nin the struc\u00adture. We plot the repair time versus the number of faults in the structure (Figure 8) for \na doubly linked list with ten thou\u00adsand nodes. The repair time grows essentially linearly with the number \nof faults in the structure. We plot the repair time versus the size of the structure (Figure 9) for a \ndoubly linked list with 10 corruptions. The repair time grows quadratically with the size of the structure \nfor a .xed number of corrup\u00adtions. This result is justi.ed as follows: the static analysis in STARC direct \nthe search algorithm to the most likely value to repair a fault, and thus most of the faults are repaired \nfrom the .rst attempt. The backtracking algorithm that STARC uses is stateless. Each execution of repOk \nre-initializes the state of the structure. Thus, the structure is constructed with every repair action, \nwhich adds a quadratic effect on the run\u00adtime of STARC. An alternative approach is to implement a stateful \nsearch, which allows real backtracking similar to that in the Java PathFinder (JPF) model checker [40] \nand obviates the need of repeated invocations of repOkfrom the beginning. We ap\u00adplied both approaches \nto repair, and preliminary experimen\u00adtal results showed that due to the high overhead of saving the state, \na stateful approach, as in JPF, is less ef.cient when re\u00adpairing small structure (less than .ve thousand \nnodes). How\u00adever, as the size of the structure increases, JPF outperforms stateless backtracking. The \nresults open a direction for fu\u00adture work. We believe that, since repOk is a pure function, i.e., does \nnot change the state of the structure, using an incre\u00admental approach, i.e., saving only sections of \nthe state that are of interest for repair, reduces JPF s overhead and leads to more ef.cient repair. \n 5.4 Overhead In this section, we study the runtime overhead of STARC. Overhead occurs in two forms. \n(1) Delays due to the ex\u00adtra method calls performed when running the instrumented code. This overhead \nis minimal since it only includes calling simple accessor methods rather than direct .eld accesses. (2) \nRuntime overhead that arises from calling repOk to check the validity of the structure. Each call to \nrepOk performs a linear traversal of all the .elds in the structure when the structure is valid. Similar \nto other techniques on automatic data structure repair [11, 10, 12, 28], our repair algorithm does not \nstate when to check for the validity of the structure, but it leaves it to the user to decide when to \ndo so. In this section, we study the overhead due to a conservative checking which calls repOk at the \nboundaries of the public methods that modify the structure, and an optimistic checking which only checks \nfor the validity of the structure when an exception is thrown in the program. To study the runtime overhead, \nTable 3. Results for repairing large structures with up to 100,000 nodes. The tabulated times are in \nmilliseconds. t represents a time threshold of 10 minutes. d represents a threshold one million repair \nactions. STARC is able to repair structures with 100 times more faults than Juzi. Subject Structure Size \n# of faults Time(ms) # of repair actions Juzi STARC Juzi STARC Singly linked list 1,000 1 43 41 1 1 10,000 \n1 138 118 1 1 100,000 1 1,698 1,581 1 1 Sorted list 1,000 1 6178 53 1 1 10,000 1 13,142 1,411 1 1 100,000 \n1 89,656 8,733 1 1 Doubly linked list 100 10 516 31 1,525 9 1,000 10 100 34,046 = t 63 234 21,656 = d \n9 99 10,000 10 100 = t = t 656 4,078 = d = d 9 99 100,000 10 100 = t = t 4,594 53,828 = d = d 9 99 N-ary \ntree 100 10 17 16 11 10 1,000 10 100 96 374 88 328 11 101 10 100 10,000 10 100 715 3,781 656 3,672 11 \n101 10 100 100,000 10 100 7,268 57,468 6,656 55,327 11 101 10 100 Binary search tree 100 10 128 24 11 \n10 1,000 10 100 7,424 8,173 137 428 11 101 10 100 10,000 10 100 182,817 210,577 5,211 10,755 11 101 10 \n100 Disjoint set 100 10 2,781 31 2,376 12 1,000 10 100 45,103 = t 63 438 32,941 = d 12 112 10,000 10 \n100 = t = t 734 4,672 = d = d 12 112 100,000 10 100 = t = t 5,149 61,751 = d = d 12 112 AVL tree 100 \n10 1,006 78 1,675 11 1,000 10 100 12,521 = t 738 1,597 9,648 = d 11 101 10,000 10 100 = t = t 4,816 9,483 \n= d = d 11 101 100,000 10 100 = t = t 7,469 58,422 = d = d 11 101 Red-Black tree 100 10 3,107 169 1,811 \n29 1,000 10 100 16,437 = t 1,382 2,810 24,399 = d 49 139 10,000 10 100 = t = t 6,942 14,385 = d = d 109 \n299 100,000 10 100 = t = t 10,191 117,491 = d = d 153 244 Fibonacci heap 100 10 799 26 1,833 19 1,000 \n10 100 17,903 = t 622 6,953 10,899 = d 24 99 10,000 10 100 = t = t 18,615 45,703 = d = d 9 99 100,000 \n10 100 = t = t 37,197 117,366 = d = d 9 99 subject original code optimistic checking conservative checking \nSingly linked list 36 47 3,314 Sorted linked list 250 301 3,847 n-ary tree 206 241 5,203 Binary Search \ntree 351 388 5,612 Doubly linked list 42 56 3,609 Disjoint sets 148 162 4,601 AVL tree 409 472 6,215 \nRed-black tree 573 627 7,243 Fibonacci heap 366 402 6,682 Figure 8. Variation in the repair time of \na doubly linked list with 10000 nodes with the number of corruptions. Figure 9. Variation in the repair \ntime of a doubly linked list with 10 corruptions with the size of the structure. we created a simple \nprogram that, for each of the subjects, performs the following: 1. builds a structure with 5,000 nodes \n 2. injects up to 5 faults in the structure 3. adds another 5,000 nodes 4. traverses the structure \n We .rst measure the overhead when there are no faults in the structures. We run the original code, \nand the instru\u00admented code when the structure has no faults, i.e., without performing step 2, and measure \nthe overhead due to call\u00ading repOk in the optimistic and the conservative checking methods. Table 4 shows \nthe runtime in milliseconds for the experiment. Since the structures have no faults, no exceptions are \nthrown, and thus, the runtime of the original code and the instrumented code when performing an optimistic \ncheck is very similar. Conservative checking adds one order of mag\u00adnitude for complex structures, such \nas AVL trees, and al\u00admost two orders of magnitude for simple structures, such as a singly linked lists. \nThis overhead is expected as the pro\u00adgram traverses the structure every time a node is added. We next \nmeasure the overhead when there are faults in the structure, i.e., with step 2. Table 5 shows the results \nfor the Table 4. Overhead imposed by the repair framework when running an application which manipulates \nstructures with up to 10,000 nodes. Column 2 shows the runtime for the origi\u00adnal code. Column 3 shows \nthe runtime for the instrumented code when performing optimistic checking. Column 4 shows the runtime \nfor the instrumented code when performing con\u00adservative checking. All the times are in milliseconds. \n subject original code optimistic checking conservative checking Singly linked list 26 118 3,550 Sorted \nlinked list 150 634 4,188 n-ary tree 116 470 5,597 Binary Search tree 224 2,622 6,271 Doubly linked list \n39 462 3,916 Disjoint sets 87 566 4,809 AVL tree 294 3,814 7,083 Red-black tree 503 5,048 9,730 Fibonacci \nheap 263 10,411 10,169 Table 5. Results for performing optimistic versus conserva\u00adtive checking when \nrepairing a corrupt structure. original code, the optimistic checking, and the conservative checking. \nThe original code crashes while adding nodes after the faults are injected for some structures, and while \ntraversing the nodes for other structures. For optimistic checking, the structure is repaired whenever \nan exception is thrown during addition or traversal, and the program safely terminates. For the conservative \nchecking, the structures are repaired on the .rst node addition after the fault injection process since \nrepOk is checked with every addition. As expected, conservative checking takes more time than optimistic \nchecking in almost all the subject structures. However, for the optimistic checking, the structure imple\u00admentation \nshould throw exceptions when performing the traverse or the add operations. If no exceptions are thrown, \nthe program might end up crashing, say because of an in.\u00adnite loop. For the conservative checking this \nproblem might Figure 10. An erroneous the cache entries are set to Figure 11. An LRUCache example with \ncapacity 6. Each entry in the cache is part of both a hash table and a doubly linked list. The entry \nis an instance of the Dataclass. It has two pointers to the nextand prevelements in the list, and a keypointer \nto the corresponding entry in the hash table. The doubly linked list re.ects the order of access from \nmost recently accessed to least recently accessed. not be possible, yet the overhead of checking repOk \nwith every node addition is high. The decision of when to check the validity of the structure depends \non the type of the structure, and the performance and reliability requirements. It is up to the user \nto decide when to check for validity. Section 6.7 describes more ways to check for the validity and to \ntrigger repair.  5.5 Case-study: repairing a software cache In this section, we illustrate how STARC \ncreates a repairable application that can automatically recover from a dynamic error when the application \nis already deployed. We use STARC to create a repairable software cache, a small, but interesting application \nwith a complex data structure. Soft\u00adware caches are gaining popularity in service oriented ap\u00adplications \n(SOA) [4] such as online business applications. These applications are expected to be online any time \nthe user requests a transaction. The cost of failure in such ap\u00adplications is prohibitively high. We \n.rst describe a faulty implementation for a software cache that implements the least recently used (LRU) \n[38] replacement algorithm, and then describe how the cache repairs without halting. Software Cache: \nA software cache is a data structure that supports constant time addition, access, and removal. To support \nthese requirements, it implements a hash table. The capacity of a cache is limited. Once the cache is \nfull, elements are replaced. The cache described in this section implements the least recently used algorithm. \nThis algorithm requires the cache to keep track of the least and the most recently accessed elements. \nThus, in addition to the hash table a software cache implements a doubly linked list to keep track of \nthe order in which data is accessed. When replacing an element, the LRU algorithm removes the entry from \nboth the linked list and the hash table. Thus, each entry in the list should have a pointer to its key \nin the hash table as shown in Figure 11. Faulty Implementation: We illustrate how STARC re\u00adpairs a faulty \ncache and corrects the program behavior on\u00adthe-.y. The class LRUCache declares the subject structure: \nclass LRUCache { int capacity; int size; HashTable cache; DoublyLinkedList lru; static class Data { Object \nvalue; Object key; Data next; Data prev; } } Each cache has a capacity .eld which represents the maximum \nnumber of nodes that the cache can hold, a size .eld to represent the current number of nodes, a hash \ntable to support constant time data access, and a doubly linked list to keep track of the order in which \nthe data is accessed. The inner class Data models the entries in the cache. Since each element in the \ncache is a node in the doubly linked list, each entry has two .elds indicating the next and prev entries \nin their recent access order in the cache, a value .eld to represent the saved data, and a key .eld which \nsaves the corresponding key entry in the hash table. Consider the method add that given a key and a value \nperforms the following: adds an entry to the cache if the key is not already in the cache and if the \ncache is not full,  updates an entry in the cache if the key is already in the cache and tags it as \nthe most recently accessed node, and  replaces an element in the cache if the key is not found in the \ncache and the cache is full.  The following code gives an implementation of the add method: void faultyAdd(Object \nkey , Object value) { // get the data entry if its in the cache Data oldData = (Data)cache.remove(key); \n// remove it from the list if it is in the list if (oldData != null) { lru.remove(oldData); } else { \n// if the cache is not full, increment the size if (size < capacity) ++size; // if the cache is full, \nremove the LRU node else if (size == capacity) { Data removed = lru.removeLast(); cache.remove(removed.key); \n} } // add the node in the top of the list Data add = lru.addFirst(key,value); // add the entry to the \ncache cache.put(key, add); } The state of the cache after six additions using the above method is displayed \nin Figure 10. All the keypointers in the Data objects are set to null. The bug is in the implementa\u00adtion \nof the addFirst method of the doubly linked list. The key.eld of the Dataclass is set to nullrather than \nthe key entry in the hash table. The program reports an unhandled null pointer exception when adding \nan additional node in to the cache (trying to replace the LRU entry from the cache). We instrument the \nLRUCacheand the Dataclasses using STARC and run the add method again. The repair routine is triggered \nwhenever the null pointer exception is thrown, and restores the cache to a valid state. We randomly add \n1,000 entries to the cache and the code reports 89 calls to the repair routine in less than two seconds \nwithout any crash in the program. 6. Discussion We next present some characteristics and limitations \nof STARC and discuss some promising future directions. 6.1 Constraint generation Our repair algorithm \nexpects the user to provide the integrity constraints by writing the repOk method. For complex con\u00adstraints, \nwriting a precise predicate can be error-prone. Ex\u00adisting constraint-synthesis tools can be used to help \nusers formulate the predicates correctly. Daikon [41] (a tool for in\u00advariant discovery) stores a dictionary \nof invariants and uses a learning algorithm to discover what invariants apply to the structure. Cork \n[26] builds on the garbage collector to take snapshots of the structure being collected. Using these \nheap snapshots, Cork can learn some properties of the structure We have recently developed Deryaft [34], \na tool that spe\u00adcializes in generating constraints of complex data structures. Deryaft takes as input \na handful of concrete data structures of small sizes and generates a repOk predicate that repre\u00adsents \ntheir structural integrity constraints. For example, for all our benchmarks except red-black trees and \ndisjoint set, Deryaft can generate the precise repOk s using .ve sample structures for each subject. \nEven in cases when Deryaft is unable to output a complete repOkpredicate, Deryaft s out\u00adput helps the \nusers correctly formulate the predicate, say by using the output as a skeletal implementation.  6.2 \nCompleteness of the Repair Algorithm The Juzi algorithm is based on Korat [5], a systematic search based \ntest input generator. Juzi explores all the non\u00adisomorphic structures that satisfy the integrity constraints. \nThus, if there exists a structure that satis.es the integrity constraints, Juzi will .nd it. We point \nout that the optimiza\u00adtions added in STARC do not affect the completeness of the original algorithm. \nUsing the recurrent .eld information, STARC only changes the order of the search and does not skip any \nvalid structure from being explored. The reference constraint solver statically detects and solves constraints \nthat are not yet initialized by the search algorithm. Thus, instru\u00admentation of repOkdoes not affect \nits behavior. The algorithm is complete for integer constraints. Once a structure is repaired, the problem \nof solving the data con\u00adstraints is decidable. If the path condition is satis.able then the solver generates \na solution to it. It is important to point out that STARC relies on the user to provide correct and sat\u00adis.able \nconstraints in repOk. If the constraints are not satis\u00ad.able, STARC noti.es the user after exploring \nall the search space. 6.3 Reachability of the Repaired Structure An important characteristic of STARC \nis that it solves two problems: the structural constraints as described in repOK and the reachability \nof the original structure nodes. Recall in Section 4.1.3 that STARC prioritizes the order of choices \naccording to the type of the faulty .eld. Using the recurrent analysis information, the recurrent .elds \nare assigned to new non-visited nodes. Thus, STARC .rst solves the reachability problem, and then satis.es \nrepOk. This feature is not present in previous work on assertion based repair, which usually .nds the \n.rst structure that solves the constraint disregarding the original size and the number of nodes reachable \nfrom the root of the structure. For example, a faulty doubly linked list of 100 nodes might be repaired \ninto a list with 10 nodes that satis.es the structural integrity constraints. Since STARC algorithm is \ncomplete, and prioritizes reachability, it will .rst try to .nd a solution with all reach\u00adable nodes. \nIf none exists, it will satisfy repOk with a smaller structure, if possible.  6.4 Generation Based Repair \nSTARC can easily be used for test input generation [14]. A key observation behind this idea is that while \nthe problem of generating an input that satis.es all the given constraints is hard, generating a structure \nat random, which may or may not satisfy the constraints but has a desired number of objects is straightforward. \nIndeed, a structure generated at random is highly unlikely to satisfy any of the desired constraints. \nHowever, it can be repaired using STARC to transform it so that it to satisfy all the desired constraints. \n 6.5 Data Repair Data repair is one of the most challenging problems in repair. To illustrate, consider \nrepairing a binary search tree whose elements are not in the correct search order. One way to repair \nthis structure is to replace the elements with new elements that appear in the correct search order. \nHowever, this choice is unlikely to be a good one, since it might end up corrupting all the information \nin the tree. Our approach gives the user some control on how to re\u00adpair the data. (1) The user can provide \nin a con.guration .le, the list of primitive .elds that are not to be instrumented, and thus, never changed \nby the repair algorithm. (2) The user can specify a ranges of data values for primitive .elds and use \nthese ranges to constrain the repair algorithm. (3) The user can state speci.c relations between the \nvalues of a corrupted structure and a repaired structure akin to specifying post\u00adconditions that relate \npre-state with post-state. For example, if the user speci.es an order relation between the elements of \nthe structure, say a binary search tree or a sorted list, the repair algorithm will reorder the values \nin the structure using the order of the values generated by the constraint solver. 6.6 Controlling the \nFields to Repair STARC provides a con.guration .le for the user to spec\u00adify what classes to instrument \nand what .elds to repair. This feature allows the user to add more constraints on the repair algorithm, \nwhich might be needed in some cases. For exam\u00adple, when the structure needs to have a certain number \nof nodes, the user can specify not to repair the size .eld and keep it concrete rather than symbolic. \nIn this case, STARC cannot modify the size .eld to satisfy other constraints, and if the reachability \nproperty is not satis.ed, STARC reports the structure as non-repairable. This feature has both its ad\u00advantages \nand drawbacks. On one hand, it gives .exibility to the user to specify some .elds as concrete all the \ntime of execution, but on the other hand these .eld will not be re\u00adpairable and if a fault occurs in \nthese .elds, STARC cannot repair it.  6.7 When to Trigger the Repair Routine? One open question in data \nstructure repair is when to trig\u00adger the repair routine. STARC provides the framework for repair, and \nlets the user decide when to use the repair rou\u00adtines. It is unknown when an error is going to occur \nin the program, which makes triggering the repair routine a tricky decision, as we do not want to affect \nthe performance of the running applications by continuously checking the validity of the constraints. \nIn Section 5.5, we provided an example where the repair routine is triggered when an exception is thrown \ndue to an error in the implementation of the struc\u00adture s API. This technique was ef.cient when repairing \nthe software cache yet in some cases it is unfeasible to wait for an exception to be thrown to perform \nthe repair. For example, I/O operations that are performed on the faulty structure are persistent, and \nit is very expensive to invalidate such opera\u00adtions. Another approach is to give the Java Virtual Machine \n(JVM) the control over when to trigger repair, and run the in\u00adtegrity checks periodically analogous to \ngarbage collection. The ef.ciency of this approach is yet to be studied. 7. Related Work This section \ncompares STARC to prior work on error recov\u00adery, dedicated repair routines, and constraint-based repair. \nError recovery has been part of software systems for a couple of decades [25, 37]. System reboot is a \ntraditional er\u00adror recovery mechanisms. In this approach, the user reboots the system when it crashes, \nuses system logs to analyze the cause of the problem, and creates patches to .x the errors. One disadvantage \nof this approach is that the system state before the crash is lost and the system returns to its initial \nstate. Check-pointing [30] tackles the problem of state loss when rebooting by recovering the program \nstate to the last saved state rather than the initial one [27]. One drawback still exists when persistent, \nrather than volatile, faults occur in a system. In this case, it is very dif.cult to automate recovery \nusing traditional approaches. Another technique for error recovery is to implement ded\u00adicated repair \nroutines that are triggered when speci.c prob\u00adlems occur during a system s execution. For example, .le \nsystem utilities, such as fsck and chkdsk, routinely check and correct the underlying .le structure. \nSome commercially developed systems, such as the IBM MVS operating sys\u00adtem [36] and the Lucent 5ESS telephone \nswitch [20], provide routines for monitoring and maintaining properties of their data structures. These \nroutines, however, do not perform re\u00adpair using a description of the data structure constraints, and \nthus it is hard to build a robust generic repair framework us\u00ading such approaches, since the developer \nmust envision all possible bugs. The use of structural integrity constraints as a basis to perform repair \nis relatively new. Demsky and Rinard [10, 12] are the .rst to use constraints as repair routines. Their \nframe\u00adwork performs repairs based on constraints written in a new declarative language that is similar \nto the .rst-order rela\u00adtional language Alloy [24]. Repair is performed by trans\u00adlating the constraints \nto disjunctive normal form and solv\u00ading them using an ad hoc search. To help the user formu\u00adlate constraints \ncorrectly, they have taken a promising new approach [11] of integrating repair with dynamic invariant \ngeneration using Daikon [16]. Our work differs from theirs as our algorithm allows writing constraints \nusing the language of implementation, while they require using a declarative language. Since this language \ndoes not support transitive closure [10], it is very hard to model the complex structural constraints \nthat STARC solves and which are easily expressed in Java. Previous work presented Juzi [13, 17, 28, 39], \na constraint\u00adbased repair framework, which uses constraints written as Java predicates. In contrast with \nDemsky and Rinard s ap\u00adproach where the search is adhoc, Juzi uses a systematic search, which is based \non symbolic execution [29, 31] and Korat [5], an ef.cient tool for constraint-based generation of data \nstructures. To decide the feasibility of path conditions that arise during symbolic execution, Juzi uses \nthe CVC-lite theorem prover [3]. STARC builds on Juzi and introduces a novel static anal\u00adysis that enables \nef.cient and effective repair. Additionally, STARC implements a dedicated constraint solver, which provides \nsigni.cantly faster constraint solving (for a range of integer constraints) than the automated theorem \nprover used by Juzi. Experimental results show that STARC can re\u00adpair structures that are up to 100 times \nlarger in size than those feasibly handled by Juzi. 8. Conclusions This paper introduced the idea of \nusing static analysis to guide the search and scale the performance of assertion\u00adbased repair. It presented \nSTARC, an ef.cient framework for repairing large data structures. STARC builds on previ\u00adous work on error \nrecovery. Given a Java predicate that rep\u00adresents the desired structural and data integrity constraints, \nand a faulty structure, STARC .rst performs static analysis on the structure to detect the recurrent \n.elds, then performs systematic search of the neighborhood of the faults to .nd candidates that repair \nthe structure to satisfy the given con\u00adstraints. Experiments on repairing data structures using subjects \nwith complex structural and data constraints show that STARC can ef.ciently repair structures with up \nto 10,000 nodes. In comparison with previous work on assertion-based repair, STARC feasibly repairs structures \nthat are up to 100 times larger. We believe that using static analysis is a highly promising approach \nto improve the performance of constraint-based approaches for error recovery as well as automated testing. \n Acknowledgments We would like to thank Christine Kehyayan, Feras Karablieh, Darko Marinov, and the anonymous \nreferees for their helpful comments on the paper. This work is supported by the EDGE scholar program, \nNSF ITR-0438967, NSF CCF-0429859, NSF CCR-0311829, NSF EIA-0303609, DARPA F33615\u00ad03-C-4106, Intel, IBM, \nand Microsoft. Any opinions, .nd\u00adings and conclusions expressed herein are the authors and do not necessarily \nre.ect those of the sponsors. References [1] William Adjie-Winoto, Elliot Schwartz, Hari Balakrishnan, \nand Jeremy Lilley. The design and implementation of an intentional naming system. In Proc. 17th ACM Symposium \non Operating Systems Principles (SOSP), Kiawah Island, December 1999. [2] C. Artho, H. Barringer, A. \nGoldberg, K. Havelund, S. Khur\u00adshid, M. Lowry, C. Pasareanu, G. Rosu, K. Sen, W. Visser, and R. Washington. \nCombining test case generation and runtime veri.cation. Theoretical Computer Science, 2005. [3] Clark \nBarrett and Sergey Berezin. CVC Lite: A new implementation of the cooperating validity checker. In Proceedings \nof the 16th International Conference On Computer Aided Veri.cation, Boston, MA, July 2004. [4] Douglas \nBarry. Web Services and Service-Oriented Architec\u00adtures: The Savvy Manager s Guide., chapter Service \nOriented Architecture. Morgan Kaufmann Publishers, 2003. [5] Chandrasekhar Boyapati, Sarfraz Khurshid, \nand Darko Marinov. Korat: Automated testing based on Java predicates. In Proc. International Symposium \non Software Testing and Analysis (ISSTA), July 2002. [6] B. Cahoon and K. McKinley. Recurrence analysis \nfor effective array prefetching in java. Concurrency and Computation Practice and Experience, 17, February \n2005. [7] Brendon Cahoon. Effective Compile-Time Analysis for Data Prefetching in Java. PhD thesis, University \nof Massachusetts, Boston, MA, 2002. [8] Edmund M. Clarke, Orna Grumberg, and Doron A. Peled. Model Checking. \nThe MIT Press, Cambridge, MA, 1999. [9] Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. \nIntroduction to Algorithms. The MIT Press, Cambridge, MA, 1990. [10] Brian Demsky. Data Structure Repair \nUsing Goal-Directed Reasoning. PhD thesis, Massachusetts Institute of Technol\u00adogy, January 2006. [11] \nBrian Demsky, Michael D. Ernst, Philip J. Guo, Stephen McCamant, Jeff H. Perkins, and Martin Rinard. \nInference and enforcement of data structure consistency speci.cations. In Proc. International Symposium \non Software Testing and Analysis (ISSTA), July 2006. [12] Brian Demsky and Martin Rinard. Automatic detection \nand repair of errors in data structures. In Proc. Conference on Object-Oriented Programming, Systems, \nLanguages, and Applications (OOPSLA), 2003. [13] Bassem Elkarablieh, Iv\u00b4an Garc\u00b4ia, Yuk Lai Suen, and \nSarfraz Khurshid. Assertion-based repair of structurally complex data. (Under submission). [14] Bassem \nElkarablieh, Yahya Zayour, and Sarfraz Khurshid. Ef.ciently generating structurally complex inputs with \nthousands of objects. In Proc. European Conference on Object-Oriented Programming (ECOOP), July 2007. \n[15] Sanguthevar Rajasekaran Ellis Horowitz. Computer Algo\u00adrithms. W. H. Freeman, second edition, 1997. \n[16] Michael D. Ernst. Dynamically Discovering Likely Program Invariants. PhD thesis, University of Washington \nDepartment of Computer Science and Engineering, Seattle, Washington, August 2000. [17] Iv\u00b4an Garc\u00b4ia. \nEnabling symbolic execution of Java programs using bytecode instrumentation. Master s thesis, The University \nof Texas at Austin, May 2005. [18] Patrice Godefroid. Model checking for programming languages using \nVeriSoft. In Proc. 24th Annual ACM Symposium on the Principles of Programming Languages (POPL), Paris, \nFrance, January 1997. [19] Sudhakar Govindavajhala and Andrew W. Appel. Using memory errors to attack \na virtual machine. In SP 03: Proceedings of the 2003 IEEE Symposium on Security and Privacy, 2003. [20] \nG. Haugk, F. Lax, R. Royer, and J. Williams. The 5ESS(TM) switching system: Maintenance capabilities. \nAT&#38;T Technical Journal, 64(6 part 2), 1985. [21] Klaus Havelund and Thomas Pressburger. Model checking \nJava programs using Java PathFinder. International Journal on Software Tools for Technology Transfer, \n1999. [22] Gerald Holzmann. The model checker SPIN. IEEE Transactions on Software Engineering, 23(5), \nMay 1997. [23] Daniel Jackson. Micromodels of software: Modelling and analysis with Alloy, 2001. [24] \nDaniel Jackson. Software Abstractions: Logic, Language and Analysis. The MIT Press, Cambridge, MA, 2006. \n[25] B. Jobstmann, A. Griesmayer, and R. Bloem. Program repair as a game. In 17th Conference on Computer \nAided Veri.cation (CAV 05), 2005. [26] Maria Jump and Kathryn S. McKinley. Cork: Dynamic memory leak \ndetection for java. In Proc. 34th Annual ACM Symposium on the Principles of Programming Languages (POPL), \n2007. [27] Feras Karablieh, Rida A. Bazzi, and Margaret Hicks. Compiler-assisted heterogeneous checkpointing. \nIn Sym\u00adposium on Reliable Distributed Systems (SRDS), October 2001. [28] Sarfraz Khurshid, Iv\u00b4ia, and \nYuk Lai Suen. Repairing an Garc\u00b4structurally complex data. In Proc. 12th SPIN Workshop on Software Model \nChecking, 2005. [29] Sarfraz Khurshid, Corina Pasareanu, and Willem Visser. Generalized symbolic execution \nfor model checking and testing. In Proc. 9th Conference on Tools and Algorithms for Construction and \nAnalysis of Systems (TACAS), Warsaw, Poland, April 2003. [30] J. L. Kim and T. Park. An ef.cient protocol \nfor checkpointing recovery in distributed systems. IEEE Transactions on Parallel and Distributed Systems, \nAug 1993. [31] James C. King. Symbolic execution and program testing. Communications of the ACM, 19(7), \n1976. [32] Tim Lindholm and Frank Yellin. The Java Virtual Machine Speci.cation. Addison Wesley, second \nedition, 1999. [33] Barbara Liskov and John Guttag. Program Development in Java: Abstraction, Speci.cation, \nand Object-Oriented Design. Addison-Wesley, 2000. [34] Muhammad Zubair Malik, Aman Pervaiz, and Sarfraz \nKhur\u00adshid. Generating representation invariants of structurally complex data. In Proc. 11th Conference \non Tools and Algo\u00adrithms for Construction and Analysis of Systems (TACAS), 2007. [35] Darko Marinov. \nAutomatic Testing of Software with Struc\u00adturally Complex Inputs. PhD thesis, Computer Science and Arti.cial \nIntelligence Laboratory, Massachusetts Institute of Technology, 2004. [36] Samiha Mourad and Dorothy \nAndrews. On the reliability of the IBM MVS/XA operating system. IEEE Transactions on Software Engineering, \n13(10), 1987. [37] Alexey Smirnov and Tzi-cker Chiueh. DIRA: Automatic detection, identi.cation, and \nrepair of control-hijacking attacks. In The 12th Annual Network and Distributed System Security Symposium, \nSan Diego, CA, February 2005. [38] William Stallings. Computer Organization and Architecture., chapter \nCache Memory. Prentice-Hall, Englewood Cliffs, NJ, 2006. [39] Yuk Lai Suen. Automatically repairing structurally \ncomplex data. Master s thesis, Department of Electrical and Computer Engineering, The University of Texas \nat Austin, May 2005. [40] Willem Visser, Klaus Havelund, Guillaume Brat, and SeungJoon Park. Model checking \nprograms. In Proc. 15th Conference on Automated Software Engineering (ASE), Grenoble, France, 2000. [41] \nTao Xie and David Notkin. Tool-assisted unit test generation and selection based on operational abstractions. \nAutomated Software Engineering Journal, 2006.    \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Data structure corruptions are insidious bugs that reduce the reliability of software systems. Constraint-based datastructure repair promises to help programs recover from potentially crippling corruption errors. Prior work repairs a variety of relatively small data structures, usually with hundreds of nodes.</p> <p>We present STARC which uses static analysis to repair data structures with tens of thousands of nodes. Given a Java predicate method that describes the integrity constraints of a structure, STARC statically analyzes the method to identify: (1) the recurrent fields, i.e., fields that the predicate method uses to traverse the structure; and (2) local field constraints, i.e., how the value of an object field is related to the value of a neighboring object field. STARC executes the predicate method on the structure and monitors its execution to identify corrupt object fields, which STARC then repairs using a systematic search of a neighborhood of the given structure. Each repair action is guided by the result of the static analysis, which enables more efficient and effective repair compared to prior work. Experimental results showthat STARC can repair structures with tens of thousands of nodes, up to 100 times larger than prior work.</p> <p>STARC efficiency is probably not practical for very large data structures in deployed systems, but opens a promising direction for future work.</p>", "authors": [{"name": "Bassem Elkarablieh", "author_profile_id": "81339498368", "affiliation": "The University of Texas at Austin, Austin, TX", "person_id": "P905207", "email_address": "", "orcid_id": ""}, {"name": "Sarfraz Khurshid", "author_profile_id": "81100052115", "affiliation": "The University of Texas at Austin, Austin, TX", "person_id": "PP14029411", "email_address": "", "orcid_id": ""}, {"name": "Duy Vu", "author_profile_id": "81339533957", "affiliation": "The University of Texas at Austin, Austin, TX", "person_id": "P905209", "email_address": "", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "The University of Texas at Austin, Austin, TX", "person_id": "P157900", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297056", "year": "2007", "article_id": "1297056", "conference": "OOPSLA", "title": "Starc: static analysis for efficient repair of complex data", "url": "http://dl.acm.org/citation.cfm?id=1297056"}