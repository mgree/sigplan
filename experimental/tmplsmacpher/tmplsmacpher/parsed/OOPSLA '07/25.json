{"article_publication_date": "10-21-2007", "fulltext": "\n Ownership Transfer in Universe Types uller\u00a8PeterM Arsenii Rudich Microsoft Research, USA mueller@microsoft.com \nAbstract Ownership simpli.es reasoning about object-oriented pro\u00adgrams by controlling aliasing and modi.cations \nof objects. Several type systems have been proposed to express and check ownership statically. For ownership \nsystems to be practical, they must allow objects to migrate from one owner to another. This owner\u00adship \ntransfer is common and occurs, for instance, during the initialization of data structures and when data \nstructures are merged. However, existing ownership type systems either do not support ownership transfer \nat all or they are too restric\u00adtive, give rather weak static guarantees, or require a high an\u00adnotation \noverhead. In this paper, we present UTT, an extension of Universe Types that supports ownership transfer. \nUTT combines own\u00adership type checking with a modular static analysis to con\u00adtrol references to transferable \nobjects. UTT is very .exi\u00adble because it permits temporary aliases, even across cer\u00adtain method calls. \nNevertheless, it guarantees statically that a cluster of objects is externally-unique when it is transferred \nand, thus, that ownership transfer is type safe. UTT provides the same encapsulation as Universe Types \nand requires only negligible annotation overhead. Categories and Subject Descriptors D3.3 [Programming \nLanguages]: Language Constructs General Terms Languages, Veri.cation Keywords Universe Types, Ownership \nTransfer, Aliasing, Uniqueness 1. Introduction Ownership allows programmers to structure the object store \nand to control aliasing and modi.cations of objects. The ownership structure makes programs easier to \nunderstand, to maintain, and to reason about. Ownership has been used to Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 07 October 21 25, Montr\u00e9al, Qu\u00e9bec, \nCanada. Copyright c . ACM 978-1-59593-786-5/07/0010. . . $5.00 ETH Zurich, Switzerland arsenii.rudich@inf.ethz.ch \nverify object invariants [29, 31, 33, 34], to show the absence of data races in multi-threaded programs \n[7, 26], to facili\u00adtate memory management for real-time programs [3, 9], to check object immutability \n[24], and to prove representation independence [4]. In the existing ownership systems, each object has \nat most one owner object. The ownership relation is a tree order. We call the set of all objects with \nthe same owner a context. The root context is the set of objects with no owner. Ownership type systems \nallow programmers to express and check own\u00adership properties statically. In these type systems, a type \ncon\u00adveys information about the class of an object as well as the object s owner. Besides the ownership \ntopology, ownership type systems also enforce restrictions on references between objects in different \ncontexts. The owner of an object is .rst determined when the object is created. In many common designs, \nthe owner is not .xed throughout an object s lifetime, but changes dynamically. The need for this ownership \ntransfer is illustrated by the following examples: Merging data structures: data structures such as \nlists are merged ef.ciently by transferring the internal representa\u00adtion of one structure to the context \nof the other [15].  Object initialization: constructors often take an existing object as parameter and \nthen capture this object, that is, transfer ownership to the object being constructed [17]. A special \ncase of object initialization is the Factory pattern, where product objects are created in the context \nof a global factory and then transferred to the client [36].  Work .ow systems: tasks in work .ow systems \nare trans\u00adferred repeatedly from processor to processor.  The .rst example is illustrated in Fig. 1. \nA list consists of a main object of class List and a doubly-linked cyclic struc\u00adture of Node objects. \nThe node referenced by the List s first .eld is a dummy node to simplify the handling of empty lists. \nIn our example, a List object owns its nodes. Therefore, ef.cient merging of two lists requires ownership \ntransfer. We assume here that all nodes of a context are trans\u00adferred together. The resulting structure \nis shown in Fig. 2. Static type safety of an ownership type system means essentially that the static \ntype of an expression e correctly re.ects the owner of the object e evaluates to. Consequently, Figure \n1. Ownership structure of two lists. Each List ob\u00adject owns its Node objects. Objects are depicted by \nboxes; references are depicted by arrows, which are labeled with the name of the .eld holding the reference. \nRounded boxes delimit ownership contexts. The owner sits atop the context it owns. Figure 2. Ownership \nstructure after the nodes of List ob\u00adject 1 have been transferred to List object 4 and the two node structures \nhave been merged. To preserve type safety, the first .eld of List object 1 is set to a fresh node in \nits context (object 8). The dummy Node object 2 is not reach\u00adable after the merge operation and will \nbe garbage collected. in the presence of ownership transfer, objects may change their type dynamically. \nFor instance, Node object 2 in Fig. 1 is owned by List object 1. This is re.ected in the type of List \ns .eld first. In Universe Types [20], this .eld has type rep Node, where the rep modi.er indicates that \nthe referenced object is owned by this. However, after the transfer (Fig. 2) Node object 2 is owned by \nList object 4. Therefore, the rep modi.er of the first .eld of List 1 does no longer re.ect the owner \nof the referenced Node correctly. This is type safe only if the transfer sets the first .eld of List \nobject 1 to a different value, for instance, a new dummy node, before the .eld is accessed again. In \ngeneral, type safety requires that the well-typedness of each variable (local variable, method parameter, \nor .eld) that is affected by an ownership transfer is re-established before the next access to the variable. \nTo enforce this condition, an ownership type system must be able to determine statically all stack and \nheap locations that reference a transferred ob\u00ad vo id retain(List list4) { rep Node node3 = first . next \n; list4 . merge ( th i s ); // node3 points to object owned by list4 node3 . next = nul l ; } Figure \n3. Unsafe method of class List. The last statement destroys the node structure of list4. ject. In general, \nthis requires knowledge of the whole call stack because method executions in progress may have local \nvariables that point to the transferred objects and knowledge of all subclasses because a subclass may \ncon\u00adtain .elds that point to the transferred objects. For instance, consider an execution of method retain \n(Fig. 3) with List object 1 as receiver and List object 4 as parameter. In the state before calling merge \n(illustrated by Fig. 1), local variable node3 holds a reference to Node object 3. The well-typedness \nof node3 is violated when merge transfers the nodes of this to list4. In the state after the call (Fig. \n2), node3 points to an object owned by list4, even though its rep modi.er indicates that the object is \nowned by this. Method retain exploits the ill\u00adtypedness of node3 to destroy the link structure of list4 \ns nodes by setting the next .eld of node3 to null. To avoid this problem, node3 s well-typedness must \nbe re-established after the call to merge. However, this cannot be done by method merge because node3 \nis not in the stack frame of merge. To prevent the problem of ill-typed aliases on transferred objects, \nexisting type systems for ownership transfer use uniqueness [2, 25, 32] to control the possible references \nto objects that may be transferred. A reference is unique if the referenced object is not aliased. Unique \nvariables may only hold unique references and the null value. Therefore, trans\u00adferring an object using \na unique variable does not affect any other stack or heap locations, and it suf.ces to assign a new value \nto the unique variable. If all objects of a context are transferred together, it even suf.ces to guarantee \nthat there is only one reference from the owner into the whole context, whereas aliasing within the context \nis not restricted. This no\u00adtion of external uniqueness [15, 42] is far more expressive. For instance, \nthe first references in Fig. 1 are not unique in the strict sense because the nodes are also referenced \nby their neighbor nodes. However, they are externally-unique because all other references to Node objects \ncome from ob\u00adjects within the context. The problem with method retain is caused by the fact that the \nfirst .eld of List object 1 is not externally-unique when the lists are merged because the local variable \nnode3 holds a second reference into the context of List 1. Although (external) uniqueness enables type-safe \nowner\u00adship transfer, the existing techniques building on (external) uniqueness have severe shortcomings: \n(1) They impose a high annotation overhead on programmers. (2) Even external uniqueness is too restrictive \nfor common implementations. For instance, when a list stores references to its .rst and last node, these \nreferences are not externally-unique. (3) Some of the techniques provide encapsulation that is too weak \nfor certain applications of ownership such as the veri.cation of object invariants. We explain these \nshortcomings in more de\u00adtail in the next section. In this paper, we present an extension of Universe \nTypes [19, 20] that supports ownership transfer. Our system com\u00adbines ownership type checking with a \nstatic analysis to en\u00adforce an alias invariant that is even less restrictive than ex\u00adternal uniqueness. \nThis alias invariant permits temporary aliases on transferable objects. In particular, a context need \nnot be externally-unique while a method executes on an object inside this context. This provides .exibility \nthat is needed in many implementations. On the other hand, our alias invariant is strong enough to obtain \nan externally\u00adunique reference on a cluster of objects and to transfer the cluster in a type-safe way. \nThe alias invariant is enforced by a modular, intraprocedural static analysis. This analysis makes each \nvariable that is potentially affected by a transfer unusable and enforces that it is assigned a new value \nbefore it is accessed. For instance, our static analysis would make the variable node3 in method retain \n(Fig. 3) unusable, thereby preventing its abuse after the transfer. Our approach solves the shortcomings \nof the existing approaches based on uniqueness. The main contributions are: An alias invariant that \nis less restrictive than external uniqueness, but strong enough to enable type-safe own\u00adership transfer. \nIn particular, it permits several external references on transferable objects.  A modular static analysis \nto enforce the alias invariant. This analysis requires only negligible annotation over\u00adhead.  An extension \nof Universe Types to support ownership transfer. The extended type system can handle almost all common \nexamples for ownership transfer. Like Uni\u00adverse Types, it enforces the owner-as-modi.er discipline, which \nenables the veri.cation of object invariants [34].  Outline. In the next section, we discuss existing \nwork on (external) uniqueness. Sec. 3 provides the background on Universe Types that is needed in the \nrest of the paper. Our approach to ownership transfer in explained in Sec. 4 and formalized in Sec. 5. \nSec. 6 illustrates our technique by examples. We present an informal soundness theorem in Sec. 7. We \ndescribe our implementation in Sec. 8, discuss related work in Sec. 9, and offer conclusions in Sec. \n10. 2. Background on Uniqueness A very strong notion of uniqueness is to enforce that unique variables \nhold unique references (or null) in all execution states. This is typically achieved using destructive \nreads, which assign null to a unique variable when it is read [25]. Enforcing uniqueness in all execution \nstates is overly restric\u00adtive. For instance, calling a method on the unique .eld f creates a temporary \nalias on the stack and, therefore, nul\u00adli.es f. This is cumbersome since the caller has to restore the \nvalue of f after the call. Moreover, destructive reads suf\u00adfer from several problems [11]: (1) They require \na change of the language semantics, which is unintuitive for pro\u00adgrammers. (2) They make it dif.cult \nto query information about the unique object, especially in side-effect free meth\u00adods. (3) They are not \ncompatible with non-null type systems [12, 23]. A more practical approach is to permit unique objects \nto be temporarily aliased from stack locations. Temporary aliases enable method calls on unique variables \nwithout nul\u00adlifying the receiver. Techniques that allow temporary aliases on unique objects have to address \ntwo problems: 1. Callbacks: If a method with receiver o calls another method m while o s unique .elds \nare temporary aliased, m must be prevented from calling back into o under the false assumption that o \ns unique .elds are actually unique. 2. Capturing: A method that receives a temporary alias of a unique \nobject must be prevented from storing this ref\u00aderence in a .eld, which would create a permanent alias \nfrom a heap location.  In the following, we discuss how existing approaches solve these problems. Clarke \nand Wrigstad [15, 42] enforce external unique\u00adness, but permit temporary aliases. They use borrowing \nto handle callbacks and capturing. borrow blocks permit tem\u00adporary aliases on unique objects. When a \nunique .eld f is borrowed, its value is copied into a non-unique local vari\u00adable l, which can then be \nused in method calls. The callback problem is prevented by nullifying f at the beginning of the borrow \nblock. Therefore, callbacks do not .nd the external uniqueness invariant violated. Capturing is prevented \nby giv\u00ading l a fresh owner such that storing the reference in a .eld is prevented by the ownership type \nsystem. At the end of a borrow block, the value of f is restored. Borrowing per\u00admits temporary aliases \non unique objects in a safe way. How\u00adever, it introduces annotation overhead and requires owner\u00adpolymorphic \nmethods to support the fresh owner of a bor\u00adrowed object. Moreover, assigning null to the borrowed variable \nleads to similar problems as destructive reads. AliasJava [2] permits temporary aliases through lent \nref\u00aderences. A lent reference may point to unique objects in any ownership context. The types of lent \nreferences do not convey ownership information. Therefore, lent references do not compromise the type \nsafety of ownership transfer. Lent references are the only temporary aliases to an otherwise unique object. \nAssigning a unique variable to a non-lent vari\u00adable makes the unique variable unusable. To prevent the \ncall\u00adback problem, a new unique value must be assigned to each unusable unique .eld before the next method \ncall. Captur\u00ading is prevented by disallowing lent references to be stored in .elds. Lent references permit \ntype-safe ownership trans\u00adfer. However, they weaken encapsulation drastically because they may point \nto arbitrary ownership contexts and may be used to modify objects. For instance, method retain (Fig. \n3) type checks in AliasJava if node3 is declared lent. This lent variable is used to break list4 s encapsulation \nand to destroy its link structure. It is unclear how to maintain ob\u00adject invariants in the presence of \nlent references [34]. Alias burying [10] relies on a static analysis to track tem\u00adporary aliases on unique \nobjects. Whenever a unique vari\u00adable is read, all existing aliases become unusable. There\u00adfore, a unique \nvariable effectively behaves as if it was actu\u00adally unique even though unusable aliases may exist. To \npre\u00advent capturing, unique variables may be passed to methods only as borrowed parameters. Like lent \nvariables in Alias-Java, borrowed parameters cannot be stored in .elds. To handle callbacks, methods \nare annotated with read effects. If a method potentially reads a unique .eld f, all temporary aliases \nof f are made unusable before the method is called. Therefore, every .eld read by a method is effectively \nunique, including .elds that are read during callbacks. Alias bury\u00ading permits temporary aliasing without \ndestructive reads and borrowing. However, it has major drawbacks. Its expressive\u00adness is limited by the \nunderlying static analysis. Moreover, borrowed annotations and read effects cause a high annota\u00adtion \noverhead. Capabilities systems [11, 22] model uniqueness through universal capabilities, which permit \narbitrary access to an object. Callbacks are handled by annotating methods with the capabilities they \nexpect. Therefore, a method expecting a .eld f to be unique cannot be called while f is aliased because \nthe caller cannot provide the expected capabilities. Capturing is handled by passing capabilities. If \na caller of a method m passes the capabilities of an argument p to m then the caller will not consider \np to be unique after the call unless m returns the capabilities back to the caller. If the capabili\u00adties \nare not retained by m, m can capture the argument, but not use it since it does not have the necessary \ncapabilities. While capabilities systems are very .exible, they require a large overhead because methods \nhave to be annotated with the capabilities they expect and return. Moreover, capabili\u00adties have not been \nintegrated with ownership type systems and external uniqueness. 3. Background on Universe Types Universe \nTypes [19, 20] is an ownership type system that permits arbitrary aliasing, but restricts modi.cations \nof ob\u00ad c lass List { rep Node first = new rep Node (); // dummy void add ( any Object o) { rep Node n; \nn= new rep Node(o, first, first.next); first.next.prev = n; first.next = n; } // constructors and other \nmethods omitted. } Figure 4. Implementation of a list in Universe Types. List objects own their Node \nobjects, as indicated by the rep modi.er in all occurrences of class Node. jects. In this section, we \nexplain the main concepts of Uni\u00adverse Types by an example. A formalization of non-generic Universe Types \nin Isabelle is given in [27], and a formaliza\u00adtion of Generic Universe Types is presented in [18]. Ownership \nModi.ers. A type consists of an ownership modi.er and a class name. The ownership modi.er ex\u00adpresses \nobject ownership relative to the current receiver ob\u00adject this1. Programs may contain the ownership modi.ers \npeer, rep, and any. peer expresses that an object has the same owner as the this object, rep expresses \nthat an object is owned by this, and any expresses that an object may have any owner. any types are supertypes \nof the rep and peer types with the same class because they convey less speci.c ownership information. \nThe use of ownership modi.ers is illustrated by classes List (Fig. 4) and Node (Fig. 5), which implement \na doubly\u00adlinked list of objects. For simplicity, we omit access mod\u00adi.ers from all examples. A List object \nowns its Node ob\u00adjects since they form the internal representation of the list and should, therefore, \nbe protected from unwanted modi.ca\u00adtions. This ownership relation is expressed by the rep mod\u00adi.er of \nList s .eld first, which points to the dummy node of the list. All nodes of a list have the same owner, \ntherefore, the prev and next .elds of Node have a peer modi.er. Fi\u00adnally, the elements stored in the \nlist may have any owner, which is indicated by the any modi.er of Node s elem .eld. Owner-as-Modi.er \nDiscipline. Universe Types allow an object o to be referenced by any other object, but reference chains \nthat do not pass through o s owner must not be used to modify o. This allows owner objects to control \nmodi.ca\u00adtions of owned objects, for instance, to maintain invariants. This owner-as-modi.er discipline \nis enforced by disallow\u00ading modi.cations of objects through any references. That is, an expression of \nan any type may be used as receiver of .eld reads and calls to side-effect free (pure) methods, but not \nof .eld updates or calls to non-pure methods. To check 1 We ignore static methods in this paper, but \nan extension is possible [33]. class Node { peer Node next , prev ; any Object elem ; Node () { next \n= this ; prev = this ;} Node ( any Object e, peer Node p, peer Node n) { elem =e; prev =p; next =n; } \nvoid flip () { peer Node tmp = next ; next = prev ; prev = tmp; } // other methods omitted. } Figure \n5. Nodes form the internal representation of lists. Method flip is used to reverse the list as we discuss \nlater. this property, Universe Types require side-effect free meth\u00adods to be annotated with the keyword \npure. As a consequence of the restriction on any receivers, Uni\u00adverse Types prevent certain callbacks. \nWhen an object o calls a method m on a rep receiver, m cannot call back into o us\u00ading a non-pure method. \nSince m s receiver is owned by o, it can reach o only by a reference chain that contains at least one \nany reference. Consequently, this reference chain can\u00adnot be used to call a non-pure method on o. Our \ntechnique for ownership transfer uses this property to address the call\u00adback problem described in Sec. \n2. Viewpoint Adaptation. Since ownership modi.ers express ownership relative to this, they have to be \nadapted when this viewpoint changes. Consider the second parameter of Node s second constructor. The \npeer modi.er expresses that the parameter object must have the same owner as the re\u00adceiver of the constructor. \nOn the other hand, List s method add calls the constructor on a rep receiver, that is, an ob\u00adject that \nis owned by this. Therefore, the second parameter of the constructor call also has to be owned by this. \nThis means that from this particular call s viewpoint, the second parameter needs a rep modi.er, although \nit is declared with a peer modi.er. In the type system, this viewpoint adap\u00adtation is done by combining \nthe modi.er of the receiver of a call (here, rep) with the modi.er of the formal parameter (here, peer). \nThis combination yields the argument modi.er from the caller s point of view (here, rep). Field accesses \nand calls on receiver this do not require any viewpoint adaptation, because the viewpoint does not change. \nWe model this behavior by an additional ownership modi.er this, which is used internally by the type \nsystem for the this variable. Combining the this modi.er with any modi.er u yields u. In particular, \nfor a rep .eld f, the .eld access this.f has a rep type, whereas for any other receiver p, the .eld access \np.f has an any type. This allows us to keep the contexts of different objects separate. Runtime Model. \nEach object stores a reference to its owner. The owner of an object is determined by the creation expression. \nFor instance, the rep modi.er in the initializa\u00adtion of List s first .eld (Fig. 4) indicates that the \nnew object is owned by this. The runtime ownership informa\u00adtion is used to check downcasts from any to \nrep or peer types as well as to evaluate instanceof expressions. Universe Invariant. Universe Types guarantee \nthe follow\u00ading properties [27]: 1. Type safety: The ownership modi.er of the type of a well\u00adtyped expression \ne correctly re.ects the owner of the object e evaluates to. 2. Tree order: In all execution states of \na well-typed pro\u00adgram, the ownership relation among the objects in the heap is a tree order. 3. Owner-as-modi.er: \nThe evaluation of a well-typed ex\u00adpression modi.es only those objects that are (transitively) owned by \nthe owner of this.  4. Ownership Transfer Our solution to ownership transfer builds on external unique\u00adness \n[15, 42]. Like in Clarke and Wrigstad s work, we transfer whole groups of objects, for instance, all \nnodes of a doubly-linked list. We call such a group a cluster. We provide a release statement to obtain \nan externally\u00adunique reference into a cluster. A capture statement uses an externally-unique reference \nto transfer the cluster. In this section, we extend Universe Types to support clus\u00adters, present the \nrelease and capture statements, and discuss the alias invariant that enables type-safe ownership transfer. \nThe type rules and static analysis to maintain this alias invariant are presented in Sec. 5. 4.1 Clusters \nClusters can be handled by a simple extension of Universe Types. We call the extended type system Universe \nTypes with Transfer or UTT for short. We explain the extensions in the following. Clusters are declared \nexplicitly by a class member dec\u00adlaration of the form cluster cn, where cn is a globally unique cluster \nname. We illustrate the use of clusters by a revised version of the doubly-linked list (class MList in \nFig. 6). This list implementation declares a cluster R to store the nodes. In UTT, an object is owned \nby a pair consisting of an owner object and a cluster name. This pair uniquely iden\u00adti.es a cluster. \nObjects in the root context are owned by <null, root>. We use the phrase the cluster cn of an ob\u00adject \no to refer to the cluster of objects owned by <o, cn>. class MList { cluster R; rep <R> Node first = \nnew rep <R> Node(); void reverse () { rep <R> Node p = first; do { p. flip (); p = p.prev; } while \n(p != first ); } f ree Node getNodes() { f ree Node res = release ( first ); first = new rep <R > Node \n(); return res ; } void merge ( peer MList l) { f ree Node un = l.getNodes(); rep <R> Node rn = capture \n(un , rep <R >); first.prev.next = rn.next; rn.next.prev = first.prev; rn.prev.next = first; first.prev \n= rn.prev; } // constructors and other methods omitted. } Figure 6. A list implementation using the \ncluster R to store the nodes. Class Node is presented in Fig. 5. De.nition 4.1 (External reference). \nA reference is an exter\u00adnal reference into the cluster cn of an object o if and only if the following \nconditions hold: 1. The origin of the reference is external to the cluster, that is, the variable holding \nthe reference is either a .eld of an object that is not (transitively) owned by <o, cn> or a stack location \nof a stack frame whose receiver object is not (transitively) owned by <o, cn>. 2. The target of the \nreference is internal to the cluster, that is, the reference points to an object (transitively) owned \nby <o, cn>. 3. The reference is not an any reference.  Since any references do not convey any ownership \ninforma\u00adtion, they are not affected by ownership transfer and, thus, are not considered external. Type \nsafety guarantees that the variable holding the external reference into o s cn cluster is a .eld of o \nor a variable in a stack frame for a method exe\u00adcution on receiver o. We use a static analysis to control \nexternal references into clusters. As explained in Sec. 5.4, this analysis makes certain variables unusable, \nthat is, enforces that new values are assigned to these variables before they are accessed. We say that \na reference is unusable if it is held by an unusable variable.  Figure 7. Object structure of an MList. \nClusters are de\u00adpicted by dashed boxes. The reference from the Iter object to Node object 3 is an any \nreference. De.nition 4.2 (External uniqueness). A reference to an ob\u00adject o is externally-unique if it \nis the only usable external reference into the cluster containing o. Fig. 7 shows an instance of class \nMList with two nodes. The reference held by the first .eld is an external reference into the cluster \nR of MList object 1. It is externally-unique provided that no stack variable points to one of the nodes \nby a non-any reference. Type-safe ownership transfer requires restrictions on the external references \ninto a cluster. Since these restrictions are not met by all implementations, it is useful to distinguish \nbetween transferable and non-transferable clusters. Exter\u00adnal references into non-transferable clusters \nneed not be re\u00adstricted beyond the encapsulation of Universe Types. To sim\u00adplify the presentation, we \ndo not consider non-transferable clusters in this paper. However, our implementation [41] and the formalization \nin our technical report [35] support them. Ownership Modi.ers. The peer modi.er indicates that two objects \nbelong to the same cluster, that is, have the same owner object and cluster name. Like in Universe Types, \nthe any modi.er does not provide any ownership information, neither about owner objects nor about cluster \nnames. We replace the rep modi.er of Universe Types by a para\u00admetric version rep (cn) that speci.es a \ncluster name. For instance, the modi.er rep (R) in the declaration of MList s .eld first indicates that \nthe node is in the R cluster of this. The modi.er rep (cn) may be used in the class C that declares cn \nand its subclasses. However, we impose an additional restriction on .eld declarations: Fields with the \nmodi.er rep (cn) may be declared only in class C, but not in C s subclasses. This restriction guarantees \nthat the only .elds that are affected by a transfer of cluster cn are declared in class C and, thus, \ncan be found by a modular analysis. The ownership modi.er free indicates that a reference is externally-unique. \nIn our system, external uniqueness is enforced at the time a cluster is transferred, but typically not \nmaintained over many execution states because every access to a free variable destroys its external uniqueness. \nConse\u00adquently, we disallow the free modi.er in the declaration of a .eld. However, a .eld of an object \no can nevertheless point to transferable objects in o s clusters if it is declared with a rep modi.er. \nrep (cn) types and free types are subtypes of the any types with the same class. For different cluster \nnames cn1 and cn2, rep (cn1) and rep (cn2) types are incomparable because they refer to different clusters. \nViewpoint Adaptation. The viewpoint adaptation operator [ of UTT is de.ned by the following table. The \n.rst argu\u00adment (rows) is the ownership modi.er of the receiver. The second argument (columns) is the \nownership modi.er of the .eld, method parameter, or method result to be viewpoint\u00adadapted. For instance, \nthe modi.er of the access p.prev in MList s method reverse is determined by combining the modi.er of \nthe receiver p (rep (R)) with the modi.er of .eld prev (peer), which yields rep (R). [ peer rep (cn2) \nany free this peer rep (cn2) any free peer peer any any free rep (cn1) rep (cn1) any any free any any \nany any free free any any any free Accessing a .eld or calling a method on a free receiver yields an \nany reference, unless the modi.er of the method is free. This ensures that the receiver reference stays \nexternally-unique. Calling a method with a free return type yields a free reference, independent of the \nmodi.er of the receiver. For instance, the call l.getNodes() in MList s method merge has type free Node. \nRuntime Model. Besides its owner object, each object stores the name of the cluster it belongs to. The \ncluster in\u00adformation is used to check downcasts from any to rep (cn)types. Like the owner object, the \ncluster name is .rst deter\u00admined when the object is created. For instance, the dummy node created in \nthe initializer of first (Fig. 6) is owned by <this, R>. A new object of type free T is put into a new \nfree cluster. A cluster is free if the objects in the cluster are owned by <null, cf>, where cf is a \nfresh cluster name that is not used in the program. In the following, we use cf as cluster name for free \nclusters and cn for non-free clusters.  4.2 Release and Capture Ownership transfer is performed by a \ncombination of two polymorphic statements, release and capture. The release statement takes an argument \nof type rep (cn) T and transfers all objects in the cn cluster of this to a new free cluster. The release \noperation returns its argument, Figure 8. The object structure from Fig. 7 after releasing the R cluster \nof the MList object. The first .eld is un\u00adusable because it is ill-typed after the release. The well\u00adtypedness \nof the any reference from the Iter object is not affected by the release.  but with static type free \nT . Our static analysis ensures that the reference is actually externally-unique by making all other \nexternal references unusable. The capture statement takes an argument y of type free T and an ownership \nmodi.er u. It transfers the objects in the free cluster containing y to the owner indicated by u. The \nmodi.er u must be peer or rep (cn), because any and free do not indicate an owner. The capture operation \nreturns y, but with static type uT . MList s method getNodes uses the release statement to obtain an \nexternally-unique reference res to the dummy node. Fig. 8 shows the object structure after releasing \nthe R cluster of MList object 1. The .eld first still refer\u00adences the dummy node. However, to enforce \nthat res is externally-unique, our static analysis makes first unus\u00adable. Method getNodes returns an \nexternally-unique refer\u00adence into the free cluster after setting first to a new dummy node. Method merge \ncalls getNodes to obtain a free refer\u00adence to the .rst node of list l. It then uses capture to trans\u00adfer \nl s nodes to the R cluster of this. After the capture, the nodes of both lists are in the same cluster \nand can be merged. Note that the release statement can be used to release clusters of this, but not of \nany other object. For instance, method merge cannot directly release l s nodes because the .eld access \nl.first has an any type, whereas the release statement expects a rep (cn) argument. Therefore, merge \nmust call method getNodes on l to release the nodes. This restriction of release improves encapsulation \nbecause it prevents objects from stealing another object s cluster. release and capture change the owner \nof the objects in the released and captured clusters. Therefore, both state\u00adments have side-effects and \nmust not be used in pure meth\u00adods.  4.3 Alias Invariant UTT restricts external references into clusters \nas described by the following con.nement property. De.nition 4.3 (Con.nement). An object o is con.ned \nif and only if each external reference into a cluster cn of o is held by a variable v that satis.es at \nleast one of the following conditions: 1. v is a .eld of o. 2. v is a local variable or parameter of \nthe current method execution, and o is the receiver of this method. 3. v is unusable.  When the this \nobject is con.ned, a static analysis can deter\u00admine modularly all variables that point into a cluster \nof this and to make them unusable when the cluster is released. For Case 1, we know that v is declared \nin the class C that de\u00adclares cn because .eld declarations may only mention clus\u00adter names declared in \nthe enclosing class. Therefore, we can determine all variables affected by releasing cn by inspect\u00ading \nthe .elds of C and local variables and parameters of the enclosing method. Note that the con.nement property \ndoes not restrict any references since we do not consider any ref\u00aderences to be external references (see \nDef. 4.1). The capturing problem described in Sec. 2 violates con\u00ad.nement by storing an external reference \ninto o s cn cluster in a .eld of an object different from o. In our system, this is prevented by viewpoint \nadaptation. Consider a method call x.m(p) where p is a temporary alias into a cluster of the current \nreceiver o. We may assume that p has modi.er rep (cn). If the receiver x is this, con.nement of o is \npre\u00adserved because o and x are the same object. If x has modi\u00ad.er rep (cn), then x and p point into the \nsame cluster, and storing p does not create an external reference. For all other modi.ers of x, m receives \nan any reference to p, which can\u00adnot be used to create an external reference. Since Universe Types prevent \ncallbacks via non-pure methods into the (transitive) owners of this (see Sec. 3), not all objects need \nto be con.ned in all execution states. The following alias invariant de.nes when objects must be con.ned. \nIt holds in all execution states of a well-typed pro\u00adgram. De.nition 4.4 (Alias invariant). Each object \no is con.ned unless the method currently executing is pure or o is one of the (transitive) owner objects \nof the current receiver object. This de.nition allows con.nement to be violated in two situations. First, \nwhile a pure method is executed; since pure methods must not perform release statements, they do not \nrely on con.nement. Second, for a (transitive) owner object o of the current receiver. This is possible \nbecause m can neither release a cluster of o (because o is different from this) nor call a non-pure method \nof o to perform the release. Therefore, it does not rely on o being con.ned.  Figure 9. Object structure \nof an MList during the execu\u00adtion of p.flip. The box on the left-hand side depicts the call stack. MList \nobject 1 is not con.ned since p holds a reference into the R cluster, but is not a local variable of \nthe current method execution. This violation is permitted be\u00adcause the MList object 1 is the owner object \nof the current receiver, Node object 2. Permitting (transitive) owners of this not to be con.ned enables \na very natural programming style as we illustrate by method reverse of class MList (Fig. 6). Let s assume \nthat reverse is executed on receiver x. The .rst assignment to p creates an additional external reference \ninto the R cluster of x. During the execution of flip, x is not con.ned because p holds an external reference \ninto the R cluster of x, but is not a variable of the current method execution (see Fig. 9). This violation \nis permitted by the alias invariant because x is the owner of p. Therefore, p need not be made unusable \nbefore the call to flip. When the call terminates, x is con.ned again and we know that p still points \ninto the R cluster of x because this cluster cannot be transferred by flip. The treatment of temporary \naliases and calls on owned objects is one of the key virtues of our technique. We need neither borrowing \n[15, 42] nor read effects [10] to handle the call to p.flip because callbacks are prevented by the type \nsystem. We also do not have to prevent flip from storing its receiver in a .eld because this would not \ncreate an external reference. In contrast to alias burying [10], our static analysis does not make p \nunusable when the .eld first is read in the condition of the loop. This is because we do not enforce \nexternal uniqueness when a variable is read, but only at the time of a transfer. In summary, our alias \ninvariant: does not restrict references within a cluster (since we use external uniqueness),  does \nnot restrict references from any variables (which are not considered external references),  does not \nrequire the owner objects of the current receiver to be con.ned (since our type system prevents callbacks \nto these objects via non-pure methods), and  does not require con.nedness while a pure method is executed \n(since pure methods must not transfer objects).  Each of these exceptions to the standard notion of \nunique\u00adness makes our system more .exible without losing static type safety. 5. Formalization In this \nsection, we present the UTT rules for a subset of Java including classes and inheritance, instance .elds, \ndynamically-bound methods, and the usual operations on objects (allocation, .eld read, .eld update, casts). \nFor sim\u00adplicity, we omit several features of Java such as interfaces, exceptions, constructors, static \n.elds and methods, inner classes, primitive types and the corresponding expressions, and all statements \nfor control .ow. We do not expect that any of these features is dif.cult to handle. We only show the \nstatic rules here. A full formalization including the runtime model, operational semantics, and proofs \nis presented in our technical report [35]. Judgments. Our formalization uses the following two main judgments. \nA type judgment has the form G; Uf s and expresses that statement s is well-typed in a declaration environment \nG. U is the set of unusable variables before the execution of s as de.ned by the static analysis in Sec. \n5.4. The judgment G; Uf s : U' expresses that U' is the set of unusable variables after statement s if \nU is the set of unusable variables before s. 5.1 Programming Language Fig. 10 summarizes the syntax of \nour language. We assume that all identi.ers of a program are globally unique except for this as well \nas method and parameter names of overrid\u00adden methods. This can be achieved easily by preceding each identi.er \nwith the class or method name of its declaration (but we omit this pre.x in our examples). T denotes \na se\u00adquence of T s. In such a sequence, we denote the i-th element by Ti. We sometimes use sequences \nof tuples S = XT as maps and use a function-like notation to access an element S(Xi)= Ti. A program P \nconsists of a sequence of classes. We keep the current program implicit in the notations. Each class \nCls has a class identi.er C, a superclass C', a list of cluster declarations cn, a list of .eld declarations \nTf, and a list of method declarations M. F ieldId is the set of all .eld identi.ers. A type T consists \nof an ownership modi.er u and a class identi.er C. A method M consists of a result type T , a method \nname m, exactly one formal parameter Tx, a list of local vari\u00adable declarations Tx, and a statement s. \nThe method returns the value of the prede.ned local variable res. V arId is the set of variable names \ncontaining this, the explicit formal method parameter, and all local variables including res. For simplicity, \nwe do not support pure methods in our formal\u00adization, but we include them in the discussion. An extension \nto pure methods is straightforward and does not reveal any interesting aspects. The set of statements \nincludes assignment, .eld read, .eld update, method call, object creation, cast, sequential composition, \nrelease, and capture. We provide the usual expressions in the form of assignment statements because our \nstatic analysis depends on the modi.er of the variable a value is assigned to. For instance, reading \na free variable does not create an external reference if the value is assigned to an any variable. This \nform is obtained by introducing auxiliary variables for sub-expressions. These variables have the static \ntypes (including the ownership modi.ers) of the corresponding sub-expressions. For simplicity, we omit \nall literals including null. A declaration environment G maps this, the formal method parameter, and \nall local variables to their types. P ::= Cls Cls ::= class C extends C' { cn; T f; M } u ::= this | \npeer | rep (cn) | any | free T ::= u C M ::= T m(T x){ T x; s } s ::= x := x; | x := x.f; | x.f := x; \n| x := x.m(x); | x := new T ; | x := (T ) x; | s1 s2 | x := release(x); | x := capture(x,u); G ::= x \nT U . F ieldId . V arId Figure 10. Syntax and declaration environment.   5.2 Well-Formedness The well-formedness \nrules for types, methods, and classes are presented in Fig. 11. If a type uC has a rep (cn)modi.er then \nuC is well-formed in an environment G only if cn is declared in a (not necessarily proper) superclass \nof the enclosing class. The enclosing class is the class of this in G (WF-TYPE). The function clusters(C0) \nyields the names of all clusters declared in class C0 and its superclasses. A method m is well-formed \nin a class C if the statement s constituting its body is well-typed in the environment G. The types of \nthe parameter, result, and local variables must be well-formed in G, and m must respect the rule for \nover\u00adriding, see below. G maps m s formal parameter and de\u00adclared local variables to their declared types, \nthis to the type this C, and the result variable res to m s result type (.C ' : C = C ' . u = rep (cn). \nG(this)= this C0. .cn . clusters(C0) WF-TYPE G .wf uC G= pTp,y T, this (this C), res Tr G .wf Tp,T,Tr \noverride(C, m) G; \u00d8 . s G; \u00d8 . s : U (F ieldId .{res}) nU = \u00d8 WF-METHOD C .wf Tr m(Tp p) {Ty; s} mType(C \n' ,m) is unde.ned . mType(C, m)= mType(C ' ,m)) WF-OVERRIDE override(C, m) C .wf MTi = ui Ci ui =.free \n(ui = rep (cn ' ). cn ' . cn) WF-CLASS ' .wf class C extends C {cn; Tf; M } Figure 11. Well-formedness \nrules. (WF-METHOD). Moreover, after the method body s, nei\u00adther the result variable nor any .eld is unusable. \nMethod m respects the rule for overriding if it does not override a method or if all overridden methods \nhave the identical signa\u00adture (WF-OVERRIDE). Function mType yields the signature of a method m in a class \nC, and is unde.ned if C does not contain a method m. A class C is well-formed if all of its methods are \nwell\u00adformed, none of the .elds has ownership modi.er free, and all cluster names used in .eld declarations \nare declared in C (WF-CLASS). As discussed in Sec. 4.3, the last constraint allows us to determine all \n.elds affected by a release statement by inspecting the .elds that are declared in the same class as \nthe released cluster. In particular, this analysis does not have to consider .elds of subclasses, which \nis important for modularity. Well-formed programs do not contain the ownership modi.er this. We do not \nmake this requirement explicit in our rules. The this modi.er is used implicitly for the this variable \nas shown by the de.nition of G in WF-TYPE and WF-METHOD.  5.3 Type Rules Two types u1 C1 and u2 C2 are \nsubtypes (denoted by u1 C1 = u2 C2) if (1) C1 is a subclass of C2 according to the rules of Java and \n(2) the ownership modi.ers are iden\u00adtical, u2 is any, or u1 is this and u2 is peer. The type rules are \npresented in Fig. 12. The judgment G; Uf s expresses that statement s is well-typed in environ\u00adment G \nand unusable-set U. Our type rules implicitly require types to be well-formed, that is, a type rule is \napplicable only if all types involved in the rule are well-formed in the respec\u00adtive environment. All \nrules require that no unusable param\u00adeter, local variable, or .eld of this is read. Our type rules implicitly \nrequire types to be well-formed in the respective environment. The rules for assignment (T-ASSIGN), object \ncreation (T-NEW), and sequential composition (T-COMP) are straight\u00adforward. As explained in Sec. 3, the \nownership modi.er of a .eld access is determined by combining the modi.er of the receiver and the modi.er \nof the .eld (T-READ). The func\u00adtion fType(C, f) yields the declared type of a .eld f that is declared \nin or inherited by class C. For a .eld update, the right-hand side variable must be a subtype of the \nviewpoint-adapted .eld type (T-WRITE). The rule is analogous to .eld read, but has two additional requirements. \nFirst, the modi.er of the receiver variable must not be any or free. any is forbidden to enforce the \nowner-as-modi.er discipline. It would be type safe to permit updates of any .elds on free receivers, \nbut we forbid this for simplicity. Second, a rep (cn) .eld f must be updated through receiver this. Otherwise, \nthe viewpoint adaptation u[uf yields any, but it is obviously unsafe to update f with an object with \nan arbitrary owner. The rule for method calls (T-CALL) is in many ways similar to .eld reads (for result \npassing) and updates (for argument passing). The last antecedent of T-CALL requires that the unusable \nset does not contain any .elds. This is necessary to ensure that the invoked method may assume all .elds \nto be usable. T-CAST could be strengthened to prevent more cast er\u00adrors statically, but we omit this \ncheck since it is not strictly needed. Casts from any types to free types are forbidden because we cannot \nensure ef.ciently that the right-hand side reference is actually externally-unique. T-RELEASE requires \nthe argument y to have a rep (cn)type. It yields a free reference. T-CAPTURE requires the captured variable \nto have a free type. The ownership mod\u00adi.er u must determine an owner, that is, must be peer or rep (cn). \n 5.4 Static Analysis In this subsection, we present a modular, intraprocedural static analysis to determine \nunusable variables. The static analysis makes the following variables unusable: First, free variables \nif it is not statically guaranteed that the reference held by the free variable is actually externally-unique. \nSec\u00adond, variables of rep (cn) types if the cluster is potentially transferred. G(y) = G(x) G; U. s1 \nG; U ' . s2 y/.U .uC = G(x) G; U. s1 : U ' u = any T-ASSIGN T-NEW T-COMP G; U. x := y G; U. x := new \nuC G; U. s1 s2 G(x)= uC uf Cf = fType(C, f ) G(y)= uC uf Cf = fType(C, f) G(y) = (u [ uf ) Cf u .. {any, \nfree}(u [ uf ) Cf = G(x) uf = rep (cn). x = this y/.U y = this . f/.U x,y /.U T-READ T-WRITE G; U. x \n:= y.f G; U. x.f := y G(y)= uC mType(C, m)= up Cp . ur Cr G(z) = (u [ up) Cp (u [ ur) Cr = G(x) u .. \n{any, free} G(y)= uy Cy uC = G(x) uC = uy Cy up = rep (cn). y = this u = free . uy = free y,z /.U F ieldId \nnU = \u00d8 y/.U T-CALL T-CAST G; U. x := y.m(z) G; U. x := (uC) y G(x)= uC G(y)= free C G(x)= free C G(y)= \nrep (cn) Cu .{peer, rep (cn)}y/.U y/.U T-RELEASE T-CAPTURE G; U. x := release(y) G; U. x := capture(y,u) \nFigure 12. Type rules. G(x)= ux Cx G(y)= uy Cy U ' = if (ux .G; U. s1 : U1 = any . uy = free) then U \nelse U.{y} G; U1 . s2 : U2 U-ASSIGN U-NEW U-COMP G; U. x := y : U ' \\{x} G; U. x := new T : U\\{x} G; \nU. s1; s2 : U2 U ' = if (x = this) then U\\{f} else U U-READ U-WRITE G; U. x := y.f : U\\{x} G; U. x.f \n:= y : U ' mType(Cy,m)= up Cp . Tr G(y)= uy Cy G(z)= uz Cz U1 = if (up = any . uz .else U.{z} G(x)= ux \nCx G(y)= uy Cy = free) then U U2 = if (uy .{peer, this}) then U1 else U = if (ux = any . uy = free) U1 \n.{v . dom(G) | G(v)= rep () Cv} then U else U.{y} U-CALL U-CAST G; U. x := y.m(z) : U2 \\{x} G; U. x := \n(T ) y : U ' \\{x} G(y)= uy Cy G(this)= this C0 U ' = U.{v . dom(G) | G(v)= uy Cv}. {f . fields(C0) | \nfType(C0,f )= uy Cf }U ' = U.{y} U-RELEASE U-CAPTURE G; U. x := release(y) : U ' \\{x} G; U. x := capture(y,u) \n: U ' \\{x} Figure 13. Rules of static analysis. Our static analysis computes for each program point a \nset unusable if it has a free type and x does not have an U of unusable variables. U is a subset of the \n.elds declared in any type. Under this condition, the assignment creates an or inherited by the enclosing \nclass as well as the parameters external reference into the cluster into which y points such and local \nvariables of the enclosing method. The rules of that y is no longer externally-unique and, thus, must \nbecome the static analysis are presented in Fig. 13. The judgment unusable. '' G; Uf s : U expresses \nthat in an environment G, U is the Creating a new object makes the left-hand side variable unusable-set \nafter the statement s if U is the unusable-set x usable (U-NEW). The rule for sequential composition \nis before the statement. straightforward (U-COMP). Assigning to a variable x removes x from the unusable \nField read (U-READ) is similar to assignment, but sim\u00adset (U-ASSIGN). The right-hand side variable y \nbecomes pler because the .eld f and, therefore, the right-hand side cannot have a free type. Updating \na .eld removes it from the unusable set if the receiver is this. Since the static anal\u00adysis only tracks \n.elds of this, there is no effect for other receivers. The most interesting rule handles method calls \n(U-CALL). Analogously to assignments, the actual argument z becomes unusable if it has modi.er free and \nis passed to a non-any parameter. If the receiver has a peer or this mod\u00adi.er then all parameters and \nlocal variables with a rep ()modi.er become unusable. These variables hold external references into clusters \nthat are potentially transferred by the called method if this method is executed on receiver this or \ncalls back into this. Therefore, we conservatively make these variables unusable. Note that this is only \ndone for peer or this receivers. For rep (cn) receivers, UTT prevents callbacks into this via non-pure \nmethods. Even in the presence of pure methods, this rule is suf.cient because pure methods must not release \nany cluster. Even though our treatment of calls on receivers with a peer or this modi.er is conservative, \nit is not a severe restriction in practice. Local variables with a peer or any modi.er remain usable \nafter the call (as do variables point\u00ading into non-transferable clusters [35]). Moreover, the value of \na variable with a rep (cn) modi.er can be carried over by assigning it to an any variable before the \ncall and cast\u00ading it back to a rep (cn) modi.er after the call. The runtime check associated with the \ncast fails if the cluster has been transferred by the call. This allows programmers to by-pass our conservative \ntype rules in cases they know that a certain cluster is not transferred by a method call. Casts are completely \nanalogous to assignments (U-CAST). A release(y) operation makes all variables un\u00adusable that point into \nthe released cluster. These are the pa\u00adrameters and local variables with the same ownership mod\u00adi.er \nas y as well as all .elds declared in or inherited by the enclosing class with this modi.er. This guarantees \nthat the reference returned by the release is externally-unique. capture makes the captured variables \nunusable because it is no longer externally-unique. Note that the static analysis only tracks parameters \nand locals of the enclosing method as well as .elds of the en\u00adclosing class and its superclasses. Therefore, \nthe analysis is fully modular and intraprocedural. An interprocedural anal\u00adysis would permit a less conservative \ncall rule for receivers with modi.er peer and this. However, in the presence of dynamic method binding, \ninterprocedural analyses are in\u00adherently non-modular because they require knowledge of all method overrides. \n6. Examples In this section, we illustrate UTT by four examples: the merging of data structures, object \ninitialization, the Factory pattern, and a work .ow system. In the examples, we use a Java-like syntax \nwith constructors and expressions. A trans\u00ad class Lexer { cluster S; rep <S> InputStream stream; Lexer \n( free InputStream s) { stream = capture (s, rep <S >); } } class Client { cluster T; void main ( any \nString file ) { rep <T> InputStream s; s= new rep <T> InputStream(file); free InputStream fs = release \n( s ); rep <T> Lexer lexer = new rep <T> Lexer(fs); // ... } } Figure 14. Example of an object initialization. \nLexer s constructor captures its parameter. lation into the language subset supported by UTT is straight\u00adforward: \nconstructors can be replaced by initialization meth\u00adods and expressions can be eliminated using temporary \nvari\u00adables. 6.1 List Merging In this subsection, we revisit the implementation of class MList (Fig. 6). \nIt is easy to see that reverse is well-formed (WF-METHOD, Fig. 11). First, throughout the method body, \nthe set of unusable variables U is empty. Second, the method body type checks because all expressions \nexcept for the loop condition have type rep<R> Node and no unusable variables are accessed. Method getNodes \nillustrates the release statement. Releasing first makes all local variables and .elds with modi.er rep<R> \nunusable. WF-METHOD requires that upon termination, all .elds are usable. This is achieved by setting \nfirst to a new node. Without this .eld update, getNodes would not be well-formed. Method merge performs \nthe actual ownership transfer. By capturing un, this variable becomes unusable because it is no longer \nexternally-unique. However, we need not assign a new value to un because it dies when the method terminates. \nLike in alias burying [10], we defer the update of a variable until it is used, and the update is not \nnecessary for local variables that are never used again. The MList example illustrates that our technique \nrequires very little overhead beyond the Universe annotations. In particular, methods that do not perform \ntransfers, such as reverse, can be written like in standard Universe Types. class Product { /* ... */ \n} class Factory { cluster T; pure free Product create() { rep <T> Product t = new rep <T> Product(); \nreturn release (t ); } } class Client { cluster P; rep <P> Product getProduct( any Factory f) { free \nProduct p = f.create(); return capture (p, rep <P >); } } Figure 15. Implementation of the Factory pattern. \n 6.2 Object Initialization The example in Fig. 14 is adapted from [17]. It illustrates how our system \nsupports object initialization. The construc\u00adtor of class Lexer expects a free InputStream, which is \ncaptured by the lexer. That is, it is transferred to the S cluster of this and then stored in a .eld. \nMethod main of class Client creates a Lexer. It .rst creates an InputStream in cluster T and then releases \nit. We do not create a free InputStream here, because a constructor call corresponds to a method call, \nand our system does not permit calls on free receivers. The input stream is then passed to the constructor \nof the Lexer, where it is captured. The release(s) operation makes all variables with modi.er rep (T) \nunusable. This prevents the following statements from using s. 6.3 Factory Pattern Fig. 15 shows an \nimplementation of the Factory pattern. The create method of Factory creates a new product, releases it, \nand returns it. Like in Client s main method (Fig. 14), we do not create a free object to be able to \ncall a construc\u00adtor. Since create does not modify any existing objects, we declared it pure. This allows \ngetProduct to call it on the any receiver f. After obtaining a free Product from the factory, getProduct \ntransfers it to cluster P. 6.4 Work Flow The examples we considered so far transfer either the whole \ninternal representation of a data structure (MList) or newly created objects (Lexer and Factory). The \nnext example re\u00adpeatedly transfers ownership of a single object. This pattern occurs for instance for \npackets in a communication system or tasks in a work .ow application. It can be implemented in UTT using \nmultiple clusters. Fig. 16 shows the implementation of a simple work .ow system, where a dispatcher (class \nDispatcher) sends or\u00adders (class Order) through a pipeline of processors (abstract class Processor). \nAs illustrated by method process of Processor, each processor captures the order in cluster O, stores \nit in the .eld current, performs its operations, and releases the order again. Note that our implementation \ndoes not maintain exter\u00adnal uniqueness of Order objects throughout the work .ow. Orders are temporarily \nstored in the .eld current to re\u00adduce parameter passing for more complex implementations of doWork. Capturing \nthe order also allows processors to modify it. Nevertheless, we can release the Order object again for \nthe transfer to the next processor. Concrete implementations of a processor (such as class Pricer) may \ndeclare additional clusters to store local data. For instance, Pricer maintains a collection of special \noffers in its P cluster. The local data could also contain any refer\u00adences to orders in cluster O, for \ninstance, to maintain a cache or statistical information. Using a separate cluster for local data allows \nmethod process to release the order without making the local data unusable. 7. Soundness In this section, \nwe summarize the properties guaranteed by UTT. The formalization and proof of these properties is beyond \nthe scope of this paper, but see our technical report [35]. The static guarantees provided by UTT are \nsummarized by the following soundness theorem: Theorem 7.1 (Soundness). In each execution state of a \nwell\u00adformed program, the following properties hold: 1. Type safety: The ownership modi.er of the type \nof a us\u00adable variable v re.ects the owner of the object referenced by v. 2. Tree order: The ownership \nrelation among the objects in the heap is a tree order. 3. External uniqueness: There is at most one \nexternal refer\u00adence into each free cluster. 4. Alias invariant: The alias invariant (Def. 4.4) holds. \n Moreover, the following property holds for each well-typed statement s: 5. Owner-as-modi.er: The execution \nof s modi.es only .elds and ownership of those objects that, in the state before executing s, are (transitively) \nowned by the owner of this or by an object in a free cluster. Type safety is restricted to usable variables. \nIt includes, in particular, that a usable free variable references an object in a free cluster. In combination \nwith external uniqueness, this implies that free variables hold externally-unique ref\u00aderences. The owner-as-modi.er \nproperty permits modi.ca\u00adtions of objects in a free cluster. These modi.cations occur class Order { // \norder data : int clientId ; rep List items ; // fields to be filled during work flow: int total ; // \nother fields and methods omitted } ab stract class Processor { cluster O; rep <O> Order current; free \nOrder process ( free Order order ) { current = capture ( order , rep <O >); doWork (); free Order res \n= release ( current ); current = null ; return res ; } abstract void doWork (); } class Pricer e x tends \nProcessor { cluster P; rep <P> HashMap offers; void doWork () { int price = /* determine price */ current \n. total = price ; } // other methods omitted } class Dispatcher { Processor[] pipeline; void handleOrder \n( free Order o) { for ( int i = 0; i < pipeline.length; i++) o = pipeline[i].process(o); } // other \nmethods omitted } Figure 16. Work Flow Example. if the cluster is captured during the execution of the \nstate\u00adment s. We proved the conjunction of all properties of Theo\u00adrem 7.1 by rule induction on an operational \nsemantics [35]. The base case covers all primitive statements; the induction step covers sequential composition \nand method calls. The execution of each statement preserves properties 1 4 and satis.es property 5. We \nonly sketch the proofs of the most interesting cases here. External uniqueness for release. Consider \nthe state\u00adment x := release(y). By T-RELEASE, y has ownership modi.er rep (cn). The statement transfers \nall objects owned by <this, cn> to a new free cluster. By type safety be\u00adfore the release, we know that \nno usable free variable v references one of the transferred objects. Since these ob\u00adjects are transferred \nto a new cluster, v remains externally\u00adunique. It remains to show that x is externally-unique after the \nrelease. Since the alias invariant holds for this before the release, we know that all usable external \nreferences to ob\u00adjects owned by <this, cn> are held by .elds of this that are declared in the same class \nas cn (WF-CLASS and type safety) or by local variables or parameters of the current method execution. \nAccording to U-RELEASE, these vari\u00adables are unusable after the release. Therefore, x holds the only \nusable external reference into the released cluster. Type safety for capture. Consider the statement \nx := capture(y,u). The statement transfers all objects in the cluster referenced by y to a non-free cluster \ndescribed by u. By T-CAPTURE, y is usable and has ownership modi.er free. By external-uniqueness, y holds \nthe only usable ex\u00adternal reference to a transferred object. Consequently, y is the only variable whose \ntype safety is potentially affected by the capturing. In particular, the type safety of peer variables \nis not affected because all objects in the captured cluster are transferred together, that is, they remain \npeers. Since y is un\u00adusable after the capture (U-CAPTURE), type safety is pre\u00adserved. Variable x is well-typed \nbecause it has the ownership modi.er u (T-CAPTURE). Alias invariant for method calls. Consider the call \nx := y.m(z). By T-CALL, we know that y has modi.er this, peer, or rep (cn). We continue by case distinction. \nCase (1): y has ownership modi.er this or peer. By type safety, this and y have the same owner. Therefore, \nthe same set of objects S must be con.ned in the caller and the callee method. First, we show that passing \ncontrol to the callee preserves the alias invariant. For all objects o . S other than the ob\u00adjects referenced \nby this and y, con.nement is preserved by passing control because .elds are unchanged and unusable variables \nremain unusable. For this, the local variables and parameters with owner\u00adship modi.er rep () for any \ncluster name become unusable (U-CALL). Because of type safety, these are the only vari\u00adables that hold \nexternal references into a cluster of this. There are no usable external references into a cluster of \ny before control is passed. If y and this hold different references, this property follows from the alias \ninvariant before the call. If y and this reference the same object, this is the case because the local \nvariables with ownership modi.er rep () are unusable. Therefore, after parameter passing, the only local \nvariables and parameters that hold external references into a cluster of y belong to the execution of \nthe callee method. In summary, the alias invariant holds after control has been passed to the callee \nmethod. By the induction hypothe\u00adsis, it is preserved by the method body. When control returns to the \ncaller, the top stack frame is removed, which trivially preserves the alias invariant by reducing the \nnumber of vari\u00adables. Assigning the result value to x preserves the alias in\u00advariant because x is a local \nvariable of the caller. Case (2): y has ownership modi.er rep (cn). By type safety, we know that the \nowner object of y is this. There\u00adfore, this need not be con.ned while the callee method ex\u00adecutes. By \nthe alias invariant before the call, we know that the alias invariant holds after passing control to \nthe callee. By the induction hypothesis, the alias invariant is pre\u00adserved by the method body. By the \nowner-as-modi.er prop\u00aderty, the callee method does not change .elds of this. Be\u00adcause of type safety, \nthese are the only .elds that hold exter\u00adnal references into a cluster of this. Moreover, if the callee \ntransfers objects into a cluster of this, then we know that these objects are not referenced from the \nstack. This is the case because the callee can transfer either free clusters (in this case, we use external \nuniqueness) or clusters released by the callee (in this case, the clusters are transitively owned by \ny; therefore, their owner object is con.ned before the call). Consequently, the method body also preserves \ncon.nement of this. Removing the stack frame for the callee does not affect the local variables and parameters \nof the caller. Finally, as\u00adsigning the result value to x preserves the alias invariant be\u00adcause x is \na local variable of the caller. . 8. Implementation We implemented UTT as part of the MultiJava compiler \n[41]. In this section, we highlight the most interesting as\u00adpects of this implementation, namely runtime \nsupport, infer\u00adence of release and capture statements, and inference of cluster information for local \nvariables. Runtime Support. As explained in Sec. 4.1, conceptually each object stores a reference to \nits owner object and the name of the cluster it belongs to. In the implementation, we represent the owner \nof an object by a designated pseudo owner object. The objects in one cluster can have different pseudo \nowners, which are organized in a union .nd struc\u00adture. The indirection through pseudo owners enables \nan ef.\u00adcient implementation of release and capture. Capturing a cluster is implemented by connecting \nthe union .nd struc\u00adtures of pseudo owners for the involved clusters. Releasing a cluster is implemented \nby setting the owner reference in the union .nd structure of pseudo owners for that cluster to null. \nBoth operations require amortized constant time. Inference of Release and Capture. To reduce the anno\u00adtation \noverhead, our implementation infers release and capture statements through the following simple rules. \nWhenever a program attempts to assign a rep (cn) expres\u00adsion to a free variable, a release is performed. \nWhen\u00adever a program attempts to assign a free expression to a rep (cn) or peer variable, a capture is \nperformed. For instance in method getNodes of class MList (Fig. 6), our implementation permits the assignment \nfree Node res = first, and infers the release. Sim\u00adilarly, the capture in method merge is inferred. Inference \nof Cluster Information. To further reduce the annotation overhead, we also infer the clusters of local \nrep variables from the clusters declared for .elds, method pa\u00adrameters, and method results. This inference \nis done by a data .ow analysis that keeps track of all possible clusters a variable may point to at each \nprogram point. For most of our examples, the inference seems trivial because there is only one cluster \nin each class. However, our implementation also supports an implicitly declared non\u00adtransferable cluster. \nTherefore, the inference has to choose at least among two clusters. For instance in method reverse (Fig. \n6), our implementation allows programmers to omit the cluster information for the local variable p. The \ndata .ow analysis determines from the declarations of the .elds first and prev that p points to the R \ncluster throughout the method body. In method merge, we infer from the various .eld updates that local \nvariable rn points to cluster R. This cluster is then used for the inferred capture statement. The inference \nof release and capture statements as well as of clusters for local variables eliminates almost all annotation \noverhead of UTT over Universe Types. Program\u00admers merely have to declare clusters and annotate .eld dec\u00adlarations \nand method signatures with cluster information. 9. Related Work We discussed uniqueness and capabilities \nin Sec. 2. In this section, we discuss related work on ownership. The existing ownership type systems \nenforce different forms of encapsulation. Ownership type systems following the owner-as-dominator discipline \n[6, 8, 13, 14, 16, 15, 38, 42] require that all reference chains from an object in the root context to \nan object o in a different context go through o s owner. This restriction on aliasing allows owners to \ncontrol all accesses to owned objects, for instance, to guarantee representation independence. UTT enforces \nthe owner-as\u00admodi.er discipline. Since this discipline does not restrict aliasing, it can handle some \npatterns that are not supported by the owner-as-dominator discipline such as collections with iterators \nor the Flyweight pattern [20, 36]. The owner\u00adas-modi.er discipline is also used in Universe Types [20], \nGeneric Universe Types [19], and Lu and Potter s work [30]. Most existing ownership type systems do not \nsupport transfer [8, 13, 14, 16, 19, 20, 30, 38], but could adopt the technique presented in this paper. \nOur technique requires that a method cannot call non-pure methods on (transitive) owners of its receiver. \nThis requirement is not enforced by the existing owner-as-dominator systems, but an adaptation is straightforward. \nHogg s islands [25] use (strictly) unique variables with destructive reads to permit transfer. We have \ndiscussed the problems of this approach in Sec. 2. Our system solves these problems by building on external \nuniqueness and by permitting temporary aliases. Flexible alias protection [37] offers a free mode for \n(strictly) unique references, but does not provide a technique to enforce uniqueness. Clarke and Wrigstad \n[15, 42] permit ownership transfer using external uniqueness, destructive reads, and borrowing. While \nour system builds on their idea of external uniqueness, it requires less annotation overhead. Clarke \nand Wrigstad s type system is owner-parametric. Therefore, they have to en\u00adforce that an object o is \ntransferred only to contexts where o s ownership parameters are available. In our system, ob\u00adjects can \nbe transferred to any context. SafeJava [6] adopted Clarke and Wrigstad s approach. A notion similar \nto exter\u00adnal uniqueness was also proposed by Banerjee and Naumann [5], but without details of how to \nenforce it. AliasJava [2] supports ownership transfer using destruc\u00adtive .eld reads and lent variables. \nAs discussed in Sec. 2, lent variables compromise encapsulation, whereas our any references preserve \nencapsulation because they cannot be used for modi.cations. Making lent variables in AliasJava read-only \nwould be too restrictive since they allow the only temporary aliases on unique objects in AliasJava. \nTherefore, passing a unique reference to a non-pure method would be as cumbersome as without temporary \naliases. Ownership domains [1] adopt ideas from AliasJava, but use external uniqueness, although the \npaper does not describe how it is enforced. Our clusters are a restricted version of ownership domains. \nIn particular, we do not provide public clusters and links between clusters. Our con.nement property \nwas inspired by our veri.\u00adcation methodology for ownership-based object invariants [34]. The treatment \nof callbacks is analogous: Both con\u00ad.nement and object invariants need not hold for the (transi\u00adtive) \nowners of the current receiver object because callbacks via non-pure methods are prevented by Universe \nTypes. The ownership-based invariant of this is checked before peer calls to avoid problems with callbacks, \njust like con.nement is enforced before peer calls by making local variables and parameters unusable. \nSpec# [29] uses a dynamic encoding of ownership via a ghost .eld owner and object invariants. With dynamic \nown\u00adership, transfer amounts to an update of the owner .eld. Like in our system, the invariants of the \ntransitive owners of an object o may be temporarily violated when o is trans\u00adferred. While dynamic ownership \nis very .exible, it requires program veri.cation to check ownership properties, whereas our system permits \nsyntactic checking. In Sing# [21], processes can own data in a designated ex\u00adchange heap. Ownership is \ntransferred when the data is sent to another process. A static data-.ow analysis enforces that a process \nonly accesses data it owns. To track local aliases, Sing# builds on capabilities [22], which we discussed \nin Sec. 2. Sing# does not support deep (hierarchic) ownership, and the use of a designated exchange heap \nis too restrictive for general object-oriented programming. Shape analysis [40] can be used to infer \nalias structures. However, most shape analyses are whole-program analyses, whereas our technique is fully \nmodular. Rinetzky et al. [39] present a technique to realize modular shape analyses based on dynamic \nownership. Their system supports ownership transfer using constraints and annotations similar to Clarke \nand Wrigstad s work [15, 42]. We expect that our work can be combined with the modular shape analysis \nto overcome the shortcomings of destructive reads and to reduce the an\u00adnotation overhead. Role analysis \n[28] is a general technique to describe alias\u00ading relationships between objects via types. It requires \npro\u00adgrammers to provide role descriptions, role speci.cations for method signatures, as well as read \nand write effects for meth\u00adods. UTT expresses simpler properties, but requires signi.\u00adcantly less annotation \noverhead. Role analysis does not pro\u00advide encapsulation, which is one of the main motivations of our \nwork. In both role analysis and UTT, the recon.guration of object structures changes the types of objects \nto re.ect a change of roles or ownership, respectively. Role analysis permits objects referenced from \nthe stack to violate their type; dangerous callbacks are detected by an interprocedu\u00adral, non-modular \nanalysis. UTT enforces modularly that all potential receivers of calls to non-pure methods are con.ned; \ntherefore, ownership transfer cannot violate type safety. 10. Conclusions We presented UTT, an extension \nof Universe Types that sup\u00adports clusters and ownership transfer. Even though many ref\u00aderences may point \ninto a cluster, our modular static analy\u00adsis enforces that a cluster is externally-unique at the time \nof transfer. UTT is very .exible because is permits temporary aliases, several .elds pointing into one \ncluster, and any ref\u00aderences. UTT can handle most ownership transfer examples. An example it cannot handle \nis the splitting of lists because we have no operation to split a cluster into two. Such an op\u00aderation \nin general requires a whole-program analysis or ref\u00aderence counting to ensure that the alias invariant \nis preserved by the split. As future work, we plan to use our implementation to as\u00adsess the expressiveness \nof UTT in case studies. Two exten\u00adsions seem particularly useful. First, Universe Types provide very \nlimited support for static .elds; type-safety requires that all static .elds have any modi.ers, which \nprevents mod\u00adi.cation of global data. We will investigate an extension of UTT where static .elds are \nfree such that methods can cap\u00adture the global data, modify it, and release it again. Second, when releasing \na cluster, UTT makes all external references except for one unusable. To retain several usable references, \nfor instance, to the .rst and last node of a list, programmers have to introduce arti.cial bridge objects. \nA bridge object sits in the same cluster as the nodes and holds peer references to the .rst and last \nnode. Releasing the clus\u00adter yields a free reference to the bridge object, which can be captured and \nthen accessed to obtain usable references to the .rst and last node. We are working on an extension of \nUTT that can release a cluster while retaining several usable external references, without requiring \nbridge objects. Finally, we are working on an extension of the type infer\u00adence for local variables to \ninfer all ownership modi.ers for locals. This will further reduce the annotation overhead. Acknowledgments \nThanks to Werner Dietl, James Noble, and Joseph Ruskiewicz for insightful discussions and suggestions, \nand to the anonymous reviewers for their helpful comments. This work was funded in part by the Information \nSociety Tech\u00adnologies program of the European Commission, Future and Emerging Technologies under the \nIST-2005-015905 MO-BIUS project. M\u00a8uller s work was carried out at ETH Zurich. References [1] J. Aldrich \nand C. Chambers. Ownership domains: Separating aliasing policy from mechanism. In M. Odersky, editor, \nEuropean Conference on Object-Oriented Programming (ECOOP), volume 3086 of LNCS, pages 1 25. Springer-Verlag, \n2004. [2] J. Aldrich, V. Kostadinov, and C. Chambers. Alias anno\u00adtations for program understanding. In \nObject-oriented pro\u00adgramming, systems, languages, and applications (OOPSLA), pages 311 330. ACM Press, \n2002. [3] C. Andrea, Y. Coady, C. Gibbs, J. Noble, J. Vitek, and T. Zhao. Scoped types and aspects for \nreal-time systems. In D. Thomas, editor, European Conference on Object-Oriented Programming (ECOOP), \nvolume 4067 of LNCS. Springer-Verlag, 2006. [4] A. Banerjee and D. Naumann. Representation independence, \ncon.nement, and access control. In Principles of Program\u00adming Languages (POPL), pages 166 177. ACM, 2002. \n[5] A. Banerjee and D. Naumann. Ownership: transfer, sharing, and encapsulation. In S. Eisenbach, G. \nT. Leavens, P. M\u00a8 uller, A. Poetzsch-Heffter, and E. Poll, editors, Formal Techniques for Java-like Programs, \n2003. [6] C. Boyapati. SafeJava: A Uni.ed Type System for Safe Programming. PhD thesis, MIT, 2004. [7] \nC. Boyapati, R. Lee, and M. Rinard. Ownership types for safe programming: Preventing data races and deadlocks. \nIn Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 211 230. ACM Press, \n2002. [8] C. Boyapati, B. Liskov, and L. Shrira. Ownership types for object encapsulation. In Principles \nof Programming Languages (POPL), pages 213 223. ACM Press, 2003. [9] C. Boyapati, A. Salcianu, J. W. \nBeebee, and M. Rinard. Ownership types for safe region-based memory management in real-time Java. In \nProgramming language design and implementation (PLDI), pages 324 337. ACM Press, 2003. [10] J. Boyland. \nAlias burying: unique variables without destructive reads. Software Practice and Experience, 31(6):533 \n553, 2001. [11] J. T. Boyland and W. Retert. Connecting effects and uniqueness with adoption. In Principles \nof programming languages (POPL), pages 283 295. ACM Press, 2005. [12] P. Chalin and P. James. Non-null \nreferences by default in Java: Alleviating the nullity annotation burden. In E. Ernst, editor, European \nConference on Object-Oriented Programming (ECOOP), LNCS. Springer-Verlag, 2007. To appear. [13] D. Clarke. \nObject Ownership and Containment. PhD thesis, University of New South Wales, 2001. [14] D. Clarke and \nS. Drossopoulou. Ownership, encapsulation and the disjointness of type and effect. In Object-Oriented \nProgramming, Systems, Languages, and Applications (OOP-SLA), pages 292 310. ACM Press, 2002. [15] D. \nClarke and T. Wrigstad. External uniqueness is unique enough. In L. Cardelli, editor, European Conference \non Object-Oriented Programming (ECOOP), volume 2743 of LNCS, pages 176 200. Springer-Verlag, 2003. [16] \nD. G. Clarke, J. M. Potter, and J. Noble. Ownership types for .exible alias protection. In Object-Oriented \nProgramming Systems, Languages, and Applications (OOPSLA), volume 33(10) of ACM SIGPLAN Notices, 1998. \n[17] D. L. Detlefs, K. R. M. Leino, and G. Nelson. Wrestling with rep exposure. Research Report 156, \nDigital Systems Research Center, 1998. [18] W. Dietl, S. Drossopoulou, and P. M\u00a8uller. Formalization \nof Generic Universe Types. Technical Report 532, ETH Zurich, 2006. sct.inf.ethz.ch/publications. [19] \nW. Dietl, S. Drossopoulou, and P. M\u00a8uller. Generic Universe Types. In E. Ernst, editor, European Conference \non Object-Oriented Programming (ECOOP), LNCS. Springer-Verlag, 2007. To appear. [20] W. Dietl and P. \nM\u00a8uller. Universes: Lightweight ownership for JML. Journal of Object Technology (JOT), 4(8), 2005. [21] \nM. F\u00a8ahndrich, M. Aiken, C. Hawblitzel, O. Hodson, G. Hunt, J. R. Larus, and S. Levi. Language support \nfor fast and reliable message-based communication in Singularity OS. In EuroSys 06, pages 177 190. ACM \nPress, 2006. [22] M. F\u00a8ahndrich and R. DeLine. Adoption and focus: practical linear types for imperative \nprogramming. In Programming language design and implementation (PLDI), pages 13 24. ACM Press, 2002. \n[23] M. F\u00a8ahndrich and K. R. M. Leino. Declaring and checking non-null types in an object-oriented language. \nIn Object\u00adoriented programing, systems, languages, and applications (OOPSLA), pages 302 312. ACM Press, \n2003. [24] C. Haack, E. Poll, J. Sch\u00a8afer, and A. Schubert. Immutable objects for a Java-like language. \nIn R. D. Nicola, editor, European Symposium on Programming (ESOP), volume 4421 of LNCS. Springer-Verlag, \n2007. [25] J. Hogg. Islands: Aliasing protection in object-oriented languages. In Object-oriented programming \nsystems, languages, and applications (OOPSLA), pages 271 285. ACM Press, 1991. [26] B. Jacobs, F. Piessens, \nK. R. M. Leino, and W. Schulte. Safe concurrency for aggregate objects with invariants. In Software Engineering \nand Formal Methods (SEFM), pages 137 147. IEEE Computer Society, 2005. [27] M. Kleberma\u00df. An Isabelle \nformalization of the Universe Type System. Master s thesis, Technische Universitat\u00a8M\u00a8unchen, 2007. sct.inf.ethz.ch/projects/student_ \ndocs/Martin_Klebermass. [28] V. Kuncak, P. Lam, and M. Rinard. Role analysis. In Principles of programming \nlanguages (POPL), pages 17 32. ACM Press, 2002. [29] K. R. M. Leino and P. M\u00a8uller. Object invariants \nin dynamic contexts. In M. Odersky, editor, European Conference on Object-Oriented Programming (ECOOP), \nvolume 3086 of LNCS, pages 491 516. Springer-Verlag, 2004. [30] Y. Lu and J. Potter. Protecting representation \nwith effect encapsulation. In Principles of programming languages (POPL), pages 359 371. ACM Press, 2006. \n[31] Y. Lu, J. Potter, and J. Xue. Object Invariants and Effects. In European Conference on Object-Oriented \nProgramming (ECOOP), LNCS. Springer-Verlag, 2007. To appear. [32] N. H. Minsky. Towards alias-free pointers. \nIn P. Cointe, edi\u00adtor, European Conference on Object-Oriented Programming (ECOOP), volume 1098 of LNCS, \npages 189 209. Springer-Verlag, 1996. [33] P. M\u00a8uller. Modular Speci.cation and Veri.cation of Object-Oriented \nprograms, volume 2262 of LNCS. Springer-Verlag, 2002. [34] P. M\u00a8uller, A. Poetzsch-Heffter, and G. T. \nLeavens. Modular invariants for layered object structures. Science of Computer Programming, 62:253 286, \n2006. [35] P. M\u00a8uller and A. Rudich. Formalization of ownership transfer in Universe Types. Technical \nReport 556, ETH Zurich, 2007. sct.inf.ethz.ch/publications. [36] S. N\u00a8ageli. Ownership in design patterns. \nMaster s the\u00adsis, ETH Zurich, 2006. sct.inf.ethz.ch/projects/ student_docs/Stefan_Naegeli. [37] J. Noble, \nJ. Vitek, and J. M. Potter. Flexible alias protection. In E. Jul, editor, European Conference on Object-Oriented \nProgramming (ECOOP), volume 1445 of LNCS. Springer-Verlag, 1998. [38] A. Potanin, J. Noble, D. Clarke, \nand R. Biddle. Generic ownership for generic Java. In Object-Oriented Programming Systems, Languages, \nand Applications (OOPSLA), ACM SIGPLAN Notices, pages 311 324. ACM Press, 2006. [39] N. Rinetzky, A. \nPoetzsch-Heffter, G. Ramalingam, M. Sagiv, and E. Yahav. Modular shape analysis for dynamically encapsulated \nprograms. In R. D. Nicola, editor, European Symposium on Programming (ESOP), volume 4421 of LNCS. Springer-Verlag, \n2007. [40] M. Sagiv, T. Reps, and R. Wilhelm. Parametric shape analysis via 3-valued logic. ACM Transactions \non Programming Languages and Systems, 24(3):217 298, 2002. [41] Y. Takano. Implementing uniqueness and \nownership transfer in the Universe Type System. Master s thesis, ETH Zurich, 2007. sct.inf.ethz.ch/projects/student_docs/ \nYoshimi_Takano. [42] T. Wrigstad. Ownership-Based Alias Management. PhD thesis, Royal Institute of Technology \nStockholm, 2006.   \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Ownership simplifies reasoning about object-oriented programs by controlling aliasing and modifications of objects. Several type systems have been proposed to express and check ownership statically.</p> <p>For ownership systems to be practical, they must allow objects to migrate from one owner to another. This <i>ownership transfer</i> is common and occurs, for instance, during the initialization of data structures and when data structures are merged. However, existing ownership type systems either do not support ownership transfer at all or they are too restrictive, give rather weak static guarantees, or require a high annotation overhead.</p> <p>In this paper, we present UTT, an extension of Universe Types that supports ownership transfer. UTT combines ownership type checking with a modular static analysis to control references to transferable objects. UTT is very flexible because it permits temporary aliases, even across certain method calls. Nevertheless, it guarantees statically that a cluster of objects is externally-unique when it is transferred and, thus, that ownership transfer is type safe. UTT provides the same encapsulation as Universe Types and requires only negligible annotation overhead.</p>", "authors": [{"name": "Peter M&#252;ller", "author_profile_id": "81100614430", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP40040940", "email_address": "", "orcid_id": ""}, {"name": "Arsenii Rudich", "author_profile_id": "81384618932", "affiliation": "ETH Zurich, Zurich, Switzerland", "person_id": "P905206", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297061", "year": "2007", "article_id": "1297061", "conference": "OOPSLA", "title": "Ownership transfer in universe types", "url": "http://dl.acm.org/citation.cfm?id=1297061"}