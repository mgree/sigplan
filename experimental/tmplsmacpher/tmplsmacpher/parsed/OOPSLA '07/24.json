{"article_publication_date": "10-21-2007", "fulltext": "\n Multiple Ownership Nicholas R Cameron, James Noble * Matthew J Smith Sophia Drossopoulou School of \nMathematics, Statistics Department of Computing, Department of Computing, Imperial College London, UK \n{ncameron, sd}@doc.ic.ac.uk &#38; Computer Science, Victoria University of Wellington, New Zealand kjx@mcs.vuw.ac.nz \nImperial College London, UK mjs198@doc.ic.ac.uk Abstract Existing ownership type systems require objects \nto have precisely one primary owner, organizing the heap into an ownership tree. Unfortunately, a tree \nstructure is too restrictive for many programs, and prevents many com\u00admon design patterns where multiple \nobjects interact. Multiple Ownership is an ownership type system where objects can have more than one \nowner, and the resulting ownership structure forms a DAG. We give a straightforward model for multiple \nownership, focusing in particular on how multiple ownership can support a powerful e.ects system that \ndetermines when two computations interfere in spite of the DAG structure. We present a core programming \nlanguage MOJO, Multiple Ownership for Java-like Objects, including a type and e.ects system, and soundness \nproof. In com\u00adparison to other systems, MOJO imposes absolutely no restrictions on pointers, modi.cations \nor programs structure, but in spite of this, MOJO s e.ects can be used to reason about or describe programs \nbehaviour. Categories and Subject Descriptors D.3.3 [Soft\u00adware]: Programming Languages Language Constructs \nand Features General Terms Languages, Theory * This work was developed while James Noble was on leave \nat Imperial College London, and Microsoft Research, Cambridge. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4eal, \nQu\u00b4ebec, Canada. Copyright c . 2007 ACM 978-1-59593-786-5/07/0010. . . $5.00 1. Introduction We re tired \nof trees... We should stop believ\u00ading in trees, roots, and radicles. Deleuze and Guattari, A Thousand \nPlateaus [17] In ownership systems, each object has one owner and the ownership relation forms a tree. \nWhile di.erent versions of ownership have proved e.ective for a variety of tasks [2, 7, 8, 14, 18], empirical \nstudies have shown that this ownership structure does not suit all programs [1, 6, 34, 43]. In this paper \nwe present an ownership type system that removes this restriction and does not require the owners to \nbe dominators, so that an object may have multiple owners, and the ownership relation forms a DAG. We \nmake the following contributions: the objects in boxes model, a simple, straightfor\u00adward model of object \nownership based on sets of objects, which describes the fundamental features of single ownership, and \ngeneralises smoothly to multi\u00adple ownership.  a language design incorporating Multiple Ownership into \na Java-like language with Objects (MOJO). MOJO s novel constructs include multiple ownership types, constraint \ndeclarations to indicate that two boxes either intersect or are disjoint, and a restricted form of existential \nownership. Thus, existing owner\u00adship type systems can support multiple ownership via relatively small \nextensions.  a formal de.nition for MOJO, including a type sys\u00adtem which we have proved sound.  an \ne.ects system for MOJO that works with multiple ownership, that again, we have proved sound.  The next \nsection informally introduces our concep\u00adtual model of ownership, the language MOJO, and the e.ects system. \nWe then give a formal presentation of the syntax, operational semantics, type and e.ects sys\u00adtem of MOJO, \nand its soundness. The paper concludes Figure 1. A Single Ownership Structure. Three Workers belongtothe \nCompany, each Worker is working on several Projects, and and each Project has Tasksthe Worker must complete. \n with a discussion of MOJO idioms and extensions and a brief survey of related work. 2. The Bene.ts \nof Putting Objects into Boxes In this section we present our conceptual model the objects in boxes model \n[19] of multiple ownership and e.ects in object-oriented systems. We begin by modelling single ownership, \nthen show how the objects in boxes model generalises to multiple owners. Inter\u00adleaved with the conceptual \npresentation, we show how these models can be described using ownership types in programming languages. \nThe examples are expressed in our core language MOJO but would apply in most lan\u00adguages with ownership \ntypes. Upon re.ection, given that ownership has been stud\u00adied for at least ten years [38], and alias \ncontrol for .fteen [25], it seems odd that only now we are pre\u00adsenting something as na\u00a8ive as a model \nbased purely on sets. Compared with previous work, the objects\u00adin-boxes model focuses on ownership sets \n(boxes), the objects in the boxes, and the e.ects of computation, and abstracts away from language constructs, \ntypes, messages, capabilities, and especially the pointer struc\u00adtures that feature prominently in most \nother treatments of object ownership [2, 12, 14, 35, 37]. While some of these concerns must be reintroduced \nas we move from a conceptual model to a programming language, we have found the abstraction o.ered by \nthe objects in boxes model to be very useful in designing and reasoning about ownership, and multiple \nownership in particular. Section 5.1 discusses how features of other ownership systems can be reintroduced \ninto our model. 2.1 Single Ownership The object structure from .gure 1 shows a company that carries out \na range of di.erent Projects. Each Project has one or more Workers allocated to it, and each Worker has \none or more Tasks they need to com\u00adplete. The key relationship this diagram brings out is object ownership:each \nTask is owned by a Project,and each Project in turn is owned by the Worker responsible for it. Ownership \nmodels abstraction, encapsulation and aggregation: Tasksare part of their Projects; Workers are part \nof the Company they work for. A change to one of the parts say a Project being cancelled necessarily \na.ects the whole abstraction in which that part is contained. Similarly, a change to a whole say a Worker \ngoing on leave may change any of its subparts perhaps delaying all of the Tasks comprising its Project. \nPartitioning objects is key to ownership systems, whether they use types [14] or speci.cations [36]. \nDi.er\u00adent systems have chosen di.erent names for these par\u00adtitions: islands [25], balloons [4], domains \n[2], contexts [12], regions [22] with each name being associated with a particular detailed proposal. \nWe propose the neutral term boxes to describe these partitions: in a sense, every ownership system puts \nob\u00adjects into boxes and di.ers in the details of those boxes. Figure 1 also gives a hint to the most \nfundamental se\u00admantics of these boxes: a box is a set of objects.So, for example, we could write [ Worker2 \n] to mean all the objects contained within Worker2 s box. Here we have: [[ Project2 ]] = {Task3} [[ Project3 \n]] = {Task4, Task5} The .rst consequence of this model is that diagrams such as Figure 1 (which have \nadorned almost every ownership paper ever published) can now be ascribed clear semantics: they are just \nthe diagrams of sets we are familiar with from primary school. The second consequence of this model is \nthat seman\u00adtics of object composition box nesting follows nat\u00adurally. So, for example, reading from \nthe diagram: [[ Worker1 ]] = {Project1, Project2, Task1, Task2, Task3}[[ Worker3 ]] = {Project5, Task6, \nTask7} We also have the invariant that if x is inside o, written x \u00ab o,then x belongs to the box of o.Inother \nwords: x \u00ab o . x . [[ o ]] Objects in Boxes An object s box must be a subset of its owner s box: x \u00ab \no . [[ x ]] . [[ o ]] Box Nesting And, in single ownership, the inside relation is a tree: [[ o1 ]] n \n[[ o2 ]] = \u00d8 . Single owners [[ o1 ]] . [[ o2 ]] . [[ o2 ]] . [[ o1 ]] These invariants should hold however \nwe model heaps, and also independently of whether objects are permitted to change owner type systems \ngenerally do not support ownership change; speci.cation languages do. 2.1.1 Single Ownership Languages \nIn an ownership-aware programming or speci.cation language we could de.ne these classes as follows. First, \nthe Task class contains two .elds straightforward value types giving the tasks s name and duration: \nthe single method delays a task by increasing its duration. class Task<o> { String name; int time; void \ndelay() {time++;} } The Task class also has an ownership parameter o that is a special form of type parameter \n(a phantom type [24]) that records ownership information. The Task class needs to be ownership parametric, \nbecause di.er\u00adent tasks will have di.erent owners (e.g. in Figure 1, Task1 is owned by Project1 while \nTask4 is owned by Project3). Ownership parameters connect compile\u00adtime static types to run-time dynamic \nboxes. An ob\u00adject s owner parameter in its type represents the box it is inside: x : C<o> . x . [[ o \n]] Owners as Boxes In ownership type languages, actual ownership parame\u00adters may be the formal parameters \nof the enclosing class (including the distinguished .rst parameter represent\u00ading an instance s owner); \nthis establishing that the current this instance is the owner of the new type; or .nal .elds, establishing \nthat the object contained in the .eld is the owner. The Project class is also ownership parametric. Projects \ndelay themselves by delaying every con\u00adstituent task. class Project<o> { TaskList<this,this> tasks; void \ndelay(){ for(var t : tasks) {t.delay();}} } The .eld tasks stores a list of the project s tasks, and \nis declared as TaskList<this,this>. This means that the list of tasks pointed to by the .eld, and each \nTask stored in the List, will be owned by this particular project instance, and therefore will be inside \nthe box belonging to this Project instance, a member of the set [ this ]], which will be di.erent for \neach di.erent project. The box nesting invariant ensures that an object s box is inside its owner. That \nis, this \u00ab o, and thus [ this ]] . [[ o ]]. The Worker class is quite straightforward, keeping a list \nof Projectsowned by this Worker (i.e. inside its box) and delaying itself by delaying those projects. \nclass Worker<o> { ProjectList<this,this> projects; void delay(){ for(var p : projects) {p.delay();} } \n} Consider now the TaskList class (the ProjectList class is similar) whose instances we omitted in Figure \n1 for space reasons. Its implementation is rudimentary, as our focus is the ownership types involved: \nclass TaskList<o, tO> { Task<tO> t; TaskList<o,tO> next; TaskList<o,tO> prev; void add(Task<tO> tt){ \nif (next==nil) { next=new TaskList<o, tO>(); next.t=tt; next.prev = this; } else { next.add(i); } } \nTask<tO> get(int i){ return (i==0) ? item : next.get(i-1); } } TaskList has two ownership parameters. \nThe .rst, o, is the primary owner parameter, just as in the other classes we ve seen. The second, tO, \nis the ownership of the Task stored in each list node. In this way the ownership of the node and its \ncontents do not have to be the same. The .elds next and prev have type TaskList<o, tO> saying that the \nadjacent list entries have the same item ownership as this list entry, and the same owner as this object: \nall entries in a single list will be members of the same enclosing box; as will all the tasks although \nthey may be in di.erent boxes. This di.ers from the .elds in classes Project and Worker, which have this \nownership, meaning that they belong to the box owned by the current object itself. 2.1.2 E.ects within \nSingle Ownership Ownership can help determine the e.ects of a computa\u00adtion in terms of the objects read \nor written. Two com\u00adputations do not interfere (they do not write the same objects, or do not read objects \nthe other writes) if the the boxes involved do not intersect. E.ects systems [13, 22, 33] annotate methods \nwith e.ects speci.cations, describing the boxes read or writ\u00adten. In Task, the .elds name and time hold \nsimple types, are local to the object, and can only be changed by the object itself. The delay method \nmakes just such an assignment to time. The e.ects of, say, reading the name .eld would be this / empty \nmeaning reading the this object and not writing anything. The e.ects of the delay method would be this \n/ this reading and writing the object to which the method is sent. class Task<o> { ... void delay() \n//effect: this/this ... } class Project<o> { TaskList<this,this> tasks; void delay() //effect: this/this \n{ for(var t : tasks) {t.delay();} } The Project s delay method reads the tasks variable, the .elds of \nthose subordinate Task objects, and calls delay on them. From the e.ects of delay(),(reads this,writes \nthis) we know that it will write whatever object it is called upon. The question is: which Task objects \nwill be written? E.ects systems without ownership [22, 30] cannot easily distinguish which Task may be \na.ected; e.ects like all.Task / all.Task say that delay on any project may read and write any Task. The \nupshot of this is that delaying any project must be assumed to delay every other project in the system. \nThis is precisely where boxes come to the rescue. Looking again at Figure 1, only the Tasksin the Project \ns box are written. The type of these tasks, i.e. Task <this> gives that information. We interpret e.ects \nso that they apply to boxes, rather than objects: e.ects such as .../this means that a computation may \nwrite the this object itself, or any other object in its box [ this ] . The e.ects for Project s delay \nmethod are this / this, so the method may read or write the object itself or any other object that it \nowns, but may not read or write any object outside its own box. The Worker s delay method also has e.ects \nthis / this.  2.2 Multiple Ownership Single ownership requires every object to have a sin\u00adgle direct \nowner, thus the ownership structure is a tree. While easy to understand, easy to model, and (rela\u00adtively) \neasy to formalise and enforce, single ownership is too restrictive for many kinds of programs. Empiri\u00adcal \nstudies have shown that relationships between ob\u00adjects and between the classes that de.ne them are scale \nfree networks tangled graphs where every object is only a few hops from every other object [34, 43]. \nNon\u00adhierarchial relationships cannot be modeled by trees. In [34], a study of heaps (up to 1.4 GB), found \nthat up to 75% of ownership structures require multiple (shared) ownership, and up to 50% required butter.y \nstruc\u00adtures. The need for multiple ownership has been inde\u00adpendently identi.ed in investigations of large \nlibraries [1]. For example, imagine the following change to the Projects, Workers, and Tasks model in \n.gure 2. The company has been restructured from an hierarchical style, where every project is carried \nout by just one worker, into a matrix management style where every task is assigned to both a project \nand a worker. As a result, tasks have to belong to both projects and workers; delaying a project must \ndelay all employees who must work on tasks on that project, and similarly delaying an employee will delay \nall projects with which they are involved. The topology in .gure 2 cannot be described with ex\u00adisting \nownership type systems. Classical ownership en\u00adforces a very strong owners-as-dominators policy over \npointers all paths to an object must be via its owner so if programmers attempt to write programs de\u00adscribing \nthis interconnected ownership structure, their programs will be rejected as type-incorrect. Other sys\u00adtems \nsupport owners-as-modi.ers or e.ective owner\u00adship, rather than pointer control [35]; so they would at \nleast be able to pick one of either Projectsor Workers as a primary axis of organisation say Projects \nand grant permission to Workers to have pointers into tasks even though they belonged to projects. Unfortunately, \nwhen a Worker is delayed in such a system, it would not have permission to modify its Project objects \nbecause it does not own them. Company Worker 1 Worker 2 Worker 3 Project 1 Task1 Task4 Task5 Task7 Project \n2 Task2 Task8 Project 3 Task3 Task6 Task9 Figure 2. A Multiple Ownership Structure. The Company now \nrequires its Workers to work on many di.erent Projects and di.erent Tasks in a project can be carried \nout by di.erent Workers. In single ownership systems, programmers get around these restrictions by .attening \nor lifting the own\u00adership hierarchy: rather than nesting boxes, every task, worker, and project can exist \nin one very large company box, and use peer ownership types like Task<o> that refer to other objects \nin the same box as this, rather than this s box to access every required ob\u00adject directly. In both owners-as-dominators \nand owners\u00adas-modi.ers systems, this would typecheck and allow e.g. projects and workers to update their \ntasks: there is no longer one primary dominant decomposition. The problem with this design is that it \nloses any bene.t of ownership types: with everything in one large box, we cannot distinguish between \ntasks belonging to one project, or another project, or a worker. Once again, a change to one task will \nbe taken as a change to all tasks. This is where the interpretation of .gure 2, mod\u00adelling boxes as sets, \nshows us the way out. Just as an element can be a member of more than one set,an ob\u00adject can be inside \nmore than one box, that is, be owned by more than one object. Where two boxes overlap, ob\u00adjects in their \nintersection are within both boxes, and so have multiple owners. So all the Tasks belonging to Project1, \nsay, will still be inside Project1 s box [[ Project1 ] . Similarly, Tasks belonging to Worker2 will \nbe inside [ Worker2 ] . And, crucially, Tasks (or any other object) belonging to both Project1 and Worker2 \n(for example, Task2 in .gure 2) will reside in both boxes, that is, in the intersection of the two sets: \n[ Project1 ]]n [[ Worker2 ] . This semantics follows directly from inter\u00adpreting .gure 2 as a set diagram. \nThe set interpretation generalises equally well to ef\u00adfects in a multiple ownership setting. Read or \nwrite ef\u00adfects upon an object with multiple owners must be taken to be e.ects within the intersection \nof all the boxes to which that object belongs and if this intersection it\u00adself intersects the e.ects \nof another computation, then those two computations potentially interfere. 2.2.1 MOJO: Language Support \nfor Multiple Ownership We generalise a single-owner language to support mul\u00adtiple owners. Our core language, \nMOJO, is a relatively simple extension to existing single-ownership languages such as JOE and OGJ [2, \n13, 42]; with the simpli.ca\u00adtion that we drop the requirement that owners should be dominators. In the \nrest of this section we present the various new features of MOJO based on the multiple\u00adownership version \nof task management. First, we reconsider the Task class. Surprisingly, this is exactly the same as the \nsingle owner version.In particular, Task retains just one ownership parameter even though in the design \n .gure 2 every Task has multiple owners. In MOJO, multiple owners are supplied upon class instantiation, \nrather than upon declaration; therefore classes can be parametric in the number of owners they will have1 \n. To instantiate objects with multiple owners, MOJO supports a special ownership combinator that provides \nmultiple (intersection) ownership. The actual ownership argument a&#38;b describes multiple owners a \nand b:a sin\u00adgle formal argument is bound by multiple actual argu\u00adments (similar to a type-generic system, \nwhere List<T> instantiated by Pair<A,B> gives List<Pair<A,B>>,and the formal argument T is instantiated \nwith a pair of ar\u00adguments A and B). For example, we can declare a Task 1 This is an innovation of the \ncurrent work; in our earlier work [19] multiple class owners were provided upon class declaration. object \nthat will be owned by a Worker and a Project object, both previously created: final Project<this> prj \n= new Project<this>(); final Worker<this> wrk = new Worker<this>(); Task<prj &#38; wrk> tsk = new Task<prj \n&#38; wrk>(); The interpretation of a&#38;b follows clearly from the Objects in Boxes constraint. If \nan object x s owner is a&#38;b then we can assume that there will exist a and b,and x be inside both \nof them: x \u00ab a . x \u00ab b . x . [[ a ]] n [[ b ]] or via the Owners as Boxes constraint: x : C<a&#38;b> \n. x . [[ a ]] n [[ b ]] The single ownership constraint Single Ownership does not hold for multiple ownership. \nThus [[ o1 ]] n [[ o2 ]] = \u00d8 . Multiple owners [[ o1 ]] . [[ o2 ]] . [[ o2 ]] . [[ o1 ]] Returning to \nour example, the TaskList is slightly modi.ed compared to the single owner version class TaskList<o, \nt0> { Task<t0&#38;?> t; TaskList<o, t0> next; void add(Task<t0 &#38; ?> tt){ ... } } The owner of each \ntask t is now t0&#38;?,which says three things: First, that the Tasks are inside more than one box they \nhave multiple ownership. Second, that one of those owners is t0, the second owner parameter of the current \nTaskList object. And .nally, that at this point in the program we do not know what the other owner(s) \nof each Task are. The code for Project class is mostly unchanged, class Project<o> { TaskList<this, this> \ntasks; void delay(){ for(var t : tasks) {t.delay();} } void add(Task<this &#38; ?> t) { tasks.add(t); \n} } except for the ownership type used to declare the formal parameter of the add method. The ? wildcard \n(similar to Java s ? wildcard for generics) can be thought of as an existential owner; these have become \ncommon ina range ofownership type systems [18, 31, 50]. Wildcard owners are crucial in a multiple ownership \nsystem because one owner often does not, or cannot, know the other potential owners. In our example, \nthe TaskList knows that its second owner parameter (t0) is one of the owners of the tasks, but does not \nknow who the other owners will be. The Worker class is now symmetrical to the Project class: class Worker<o> \n{ TaskList<this, this> tasks; void delay(){ for(var t : tasks) {t.delay();} } void add(Task<this &#38; \n?> t) { tasks.add(t); } } Task<p1 &#38; w1> is a subtype of Task<p1 &#38; ?> and of Task<w1 &#38; ?>. \nThis allows us to add tasks owned by, say, project p1 and worker w1 to both p1 and w1 as in the following \ncode (we discuss the meaning of intersects in the following section): final Project<this> p1 = new Project<this>(); \nfinal Worker<this> w1 = new Worker<this>(); w1 intersects p1 Task<p1 &#38; w1> t1 = new Task<p1 &#38; \nw1>(); p1.add(t1); w1.add(t1); 2.2.2 E.ects within Multiple Ownership Given the straightforward extension \nfrom single to mul\u00adtiple ownership promised by the objects in boxes model, it is tempting to expect that \ne.ects would generalise similarly; however, that is not quite the case. In the following example we create \ntwo tasks, one shared between project p1 and worker w1, the other shared between p2 and worker w1: class \nTest { final Project<this> p1 = new Project<this>(); final Project<this> p2 = new Project<this>(); final \nWorker<this> w1 = new Worker<this>(); w1 intersects p1; w1 intersects p2 Task<p1 &#38; w1> t1 = new Task<p1 \n&#38; w1>(); p1.add(t1); w1.add(t1); Task<p2 &#38; w1> t2 = new Task<p2 &#38; w1>(); p2.add(t2); w1.add(t2); \n} In this program p1.delay() and w1.delay() poten\u00adtially interfere. Given our intuition from the .gure \n2, we expect p1.delay() and p2.delay() not to inter\u00adfere. The expressions have e.ects: p1.delay() : p1/ \np1 p2.delay() : p2/ p2 w1.delay() : w1/ w1 and with the machinery we have got so far, we have insu.cient \ninformation to distinguish the relationship between p1 and p2 from that between p1 and w1. 2.2.3 Intersection \nand Disjointness To solve this problem we have to provide more informa\u00adtion about which boxes intersect, \nand which boxes are disjoint. Instantiating types with multiple owners like p1&#38;w1 creates objects \nin the set intersection [ p1 ]] n [[ w1 ] , which means that the p1 box and the w1 box must intersect. \nConversely, for disjoint boxes p1 and p2 (like in the .gure) the multiple owner p1&#38;p2 is illegal. \nWe introduce two declarations that make box topolo\u00adgies explicit. In the example, we d need to declare \nw1 intersects p1 and w1 intersects p2 if we want to have workers whose tasks are in both p1 and p2. Simi\u00adlarly, \nwe need to declare p1 disjoint p2 to ensure the p1 and p2 boxes are independent. Only one relation\u00adship \n(intersects or disjoint) may be declared between any two boxes: if no relationship is declared, then \nwe don t know what the topology is and we make conser\u00advative assumptions. Then, multiple ownership like \na&#38;b is legal only if it can be shown that a and b are legal, and that a intersects b. In our example, \np1&#38;w1 and w1&#38;p1 and p2&#38;w1 are all legal ( &#38; , intersects and disjoint are symmetric; \nintersects and &#38; are re.exive; disjoint is irre.exive) while p1 &#38; p2 is not legal because p1 \nand p2 are not declared as intersecting. E.ects are independent when we can show that their boxes will \nbe disjoint. For e.ects involving multiple owners (like p2 &#38; w1) it is enough to consider owners \npairwise, and to .nd one pair that is de.nitely disjoint: in the example, p1 and p2 are declared to be \ndisjoint, so their intersection is empty, i.e. [[ p1 ]] n [[ p2 ]] = \u00d8 = [[ p1 &#38; w1 ]] n [[ p2&#38;w1 \n]]= [ p1 &#38; ? ]] n [[ p2 &#38; ? ] . Therefore p1.delay() and p2.delay() cannot interfere. On the \nother hand, because p1 intersects with w1,weare able to create types like w1&#38;p1, while we cannot \ncreate p1&#38;p2 the e.ects [ w1&#38;? ]]and [ p1 &#38; ? ]] are not independent; thus computations \nlike w1.delay() and p1.delay() may interfere.  2.2.4 Ownership Type Constraints To make MOJO modular, \nwe provide where clauses to constrain owner parameters. Inside a class C with three owner parameters, \na, b,and o, we can create objects with ownership a&#38;o only if we are sure that a intersects with o. \nWe give this guarantee through a where clause: class C<o, a, b> where a intersects o { Object<a &#38; \no> f1; // legal Object<a &#38; b> f2; // illegal } but then we can only instantiate C with ownership \nparameters that are de.nitively known to intersect. In the example in the previous section, C<w1,p1,p2> \nis legal (because w1 intersects p2) while C<p1,p2,w1> is illegal because p1 does not intersect p2. Where \nclauses can also be used to express disjoint\u00adness constraints a declaration such as: class D<o, e> where \ne disjoint o { // ... } requires that the actual ownership parameters be dis\u00adjoint. In the above example, \nD<p1,p2> is a legal owner\u00adship type because p1 disjoint p2, but D<w1,p1> is not, because those boxes \nare not disjoint. Note that a disjointness constraint also prevents both parame\u00adters being instantiated \nwith the same actual ownership type, because disjoint is irre.exive, so D<p1,p1> and D<this,this> are \nalso illegal. In practice, we expect that many ownership pa\u00adrameters will use neither intersection nor \ndisjointness constraints. This gives maximal polymorphism: uncon\u00adstrained parameters can be instantiated \nwith either intersecting or disjoint boxes. A class which does not create objects with multiple owners \nwill not need inter\u00adsection constraints, and a class which is not susceptible to interference between \nparameters will not need dis\u00adjointness constraints. Most collection classes, for exam\u00adple, will fall \ninto this category, as will pairs, tuples, and many other generic classes. 3. MOJO In this section we \npresent the MOJO language, a mini\u00admal object-oriented imperative language, in the Feath\u00aderweight Java \n(FJ) [26] style with extensions for (mul\u00adtiple) ownership. It is closely related to JOE [13] and ODE \n[47]. The major change from FJ is that MOJO types and classes are parameterised by a sequence of owner \nparameters, the .rst of which is the owner of objects of that type. Actual ownership parameters may consist \nof multiple owners which may include the wildcard owner, ? . To support the topology of boxes described \nin section 2.2.3, constraints on ownership parameters and .nal .elds may be speci.ed. MOJO supports imperative \nfeatures, including a heap and .eld assignment, and .nal .elds that may be used as ownership parameters \n(non-.nal .elds would be unsafe as ownership parameters as they may change during execution). The interesting \nfeatures in MOJO are the support for multiple owners, through the opera\u00adtion n which combines owners \ninto a multi-box ,  support for annotations on class declarations, which require disjointness, or allow \nintersection of owner\u00adship parameters,  P ::= class * program class ::= class c < p > pCnstr < c' < \nQ > C pCnstr ::= ::= {.n.d fCnstr .d mth }..| .. p C p class de.nition interesects or disjoints parameter \nconstraints .n.d ::= fin t. .nal .eld de.nition fCnstr .d ::= ::= . C. tf |. Cp .eld constraints .eld \nde.nition mth t ::= ::= tm (tx) { e c < Q > } method body static type path Q q ::= ::= ::= ::= this | \nx |q | qnQ path | path.. path actual own. param. (poss. multiple) one actual ownership parameter runtime \nactual ownership parameters e c, p ::= ::= ::= x | this | e.f || e.f =e new t | e.m(e) | . id one runtime \nactual ownership parameter expressions class identif., form. ownership param. f , . , m ::= id .eld identif., \n.nal .eld identif., method identif.   Figure 3. Syntax, runtime entitites in  support for .nal .elds, \nand annotations guaranteeing the disjointness and allowing intersection of objects boxes,  support for \npaths appearing as actual ownership parameters in types.  MOJO does not require owners to be dominators, \nand thus does not provide encapsulation guarantees. The guarantees it provides have to do with the e.ects \nof computations. In comparison to the concrete, surface syntax de\u00adscribed in section 2.2.1, the formalism \nadopts a more succinct abstract syntax: class declarations use < in\u00adstead of extends. Constraints on \n.elds or ownership parameters use . for intersects and .. for disjoint. To emphasize the connection with \nset theory, multiple owners use n rather than &#38;.Actualownership param\u00adeters consist of a set of formal \nparameters, this, .nal .elds, method parameters, the ? wildcard or, at run\u00adtime, addresses. The syntax \nis given in .gure 3. 3.1 Runtime Model Heaps (h) map addresses to objects. Objects are triples of a runtime \ntype, a mapping from .nal .eld identi.ers (Id.d ) to addresses, and a mapping from non-.nal .eld identi.ers \n(Id.d ) to addresses. Runtime types consist of class identi.ers and sequences of nonempty sets of addresses, \nrepresenting actual owners, including ?2 h . Heap = N-. Object address to object 2 Allowing ? gives meaning \nto the expression new Task<?,p>. In MOJO, objects with unknown owners may be desirable, in contrast to \nJava, where no object is instantiated with wildcard types. Object = c< R > \u00d7 runtime type ( Id.d -. N) \n\u00d7 .nal .d. values ( Id.d -. N) non-.nal .d. values . . N object addresses Note, that at runtime, types \nmay mention paths, e.g. c<.4.. 1 .. 2>. We implicitly replace such paths by the lookup of the values \nof the .nal .elds in the heap, i.e. we implicitly apply the following rule whenever required, in order \nto obtain a c<R> out of a c<Q>. h(.) .2(. )= .' t = h [.'/... ]t  3.2 Subclasses, Field and Method Lookup \nFunctions ' In .gure 4 we de.ne c<p > < c<Q' >, the subclass relation. We can prove that the judgment \nc<p> < ... implies that the formal parameters of c are p,and that for given classes c and c' ,the c<p> \n< c<Q' > uniquely determines the Q' . Lemma 1. ' c <p > < c< > implies that class c<p > ... in the program. \n < c' <Q'' > c <p > < c<Q' > and c <p > implies that Q'' = Q' .  Based on the subclass relation, in \n.gure 4 we then de\u00ad.ne the auxiliary .eld lookup function fTypeaux which looks up .eld types as de.ned \nin a class, or as inherited from superclasses. Similarly, we de.ne for the auxiliary method lookup functions \nmTypeaux and mBodyaux . Subclasses class c<p> ... < c ' <Q' > {... } class c <p> ... < c ' <Q' > {... \n} c<p> < c<p> c <p> < c ' <Q' > '' ''' '' '' > ' c<p> < c < Q> c <p < c < Q> ''''' c<p> < c ' < [Q/p \n]Q> Field lookup ' class c<p> ... < ... c ' < Q> class c<p> ... < ... {...tf... } fT ypeaux(c ' <p '>, \nf)= t fT ypeaux(c<p>, f)= t fTypeaux(c<p>, f)=[Q'/p ']t allF ields(c)= {f |fT ypeaux(c<p>, f) is de.ned \nfor some p} finF ields(c)= allF ields(c) n{. |. is .nal} nonfinF ields(c)= allF ields(c) n{f |f is not \n.nal} fT ype(c<Q>, f, e, G) = [Q/p](tG\u00b7e) where t = fT ypeaux(c<p>, f) . . t, if this ./t; tG\u00b7e =[path/this]t \nif this .t, e is a path in G, . ., otherwise. Method lookup ' class c<p> ... < ... c ' < Q> '' class \nc<p> ... < ... {...t m(t ' x){...}... } mT ypeaux(c <p ' >, m)= t .t '' mT ypeaux(c<p>, m)= t ' .t mT \nypeaux(c<p>, m)=[Q'/p ]t ' -> [Q/p ']t ' class c<p> ... < ... {...t m(t ' x){e }... } class c<p> ... \n< c < Q ' > ... mBodyaux(c<p>, m)=(x, e) mBodyaux(c<p>, m)=[Q ' /p ' ]mBodyaux(c ' <p ' >, m) mBody(c<Q>, \nm)=[Q/p]mBodyaux(c<p>, m) Figure 4. Subclasses, .eld, and method lookup functions. e, h ., h ' e, h ., \nh ' v, h v, he.. , h h ' (.) .2 (. ), h ' e.f , h h ' (.) .3 (f ), h ' '' '''' . ' e, h ., he , h \n, h '' ' e.f = e , h . ' , h [..(h ' (.) .1, h ' (.) .2, h (.) .3 [f . ' ])] . Figure 5. Operational \nsemantics for .eld access and .eld assignment Lemma 2. If fT ypeaux(t, ) or mT ypeaux(t, ),or mBodyaux(t, \n) '' is de.ned, then t = c<p> and class c<p> ... in c<p> < c<Q>,and fT ypeaux(c ' <p ' >, f)= t the program, \nfor some c and p. implies that fT ypeaux(c<p>, f)=[Q' /p ']t ' c<p> < c ' < Q>,implies mT ypeaux(c ' \n<p ' >, f)= t ' . t,then mT ypeaux(c < p >, m)=[Q' /p ']t ' . The functions allF ields, finF ields and \nnonfinF ields [Q' /p ']t. return, respectively, the identi.ers of all the .elds of a class, all .nal \n.elds of a class, all non-.nal .elds de.ned in a class. The function fT ype(c<Q>, f, e, G) returns the \ntype of .eld f as accessed from e, which has type c<Q>,in an environment G. It .rst obtains the type \nof the .eld as de.ned in class c (using the function fT ypeaux,then it replaces any occurrences of this, \nprovided that e is a path (using the operation tG\u00b7e), and then replaces the formal owner parameters p \nby the actual owner param\u00adeters Q. For example, fT ype(Worker<o>, tasks, w, G) is TaskList<w,w>3 .  \n3.3 Execution Execution is de.ned in terms of a large steps operational semantics, with format e, h v, \nh', which maps an expression and a heap to a result and a new heap. The operational semantics for .eld \nassignment and .eld access is the obvious one and appears in .gure 5. The semantics of object creation \nand method call is more intricate, and we discuss it here in more detail. To create an object of type \nc<R >, we .rst create a new object at a fresh address . with temporary type Object4. We then initialize \nthe .nal .elds . 1 , .... n of c and obtain objects . ,and a heap hn. We then initialize the non-.nal \n.elds f 1 ,...f m and obtain objects . ',and a heap h ' . Finally, in h ' we update the class of the \nnew mm object, and connect the .nal .eld identi.ers to . ,and the non-.nal .eld identi.ers to . ' . . \nfresh in hh1 = h[. . (Object, \u00d8, \u00d8)] finF ields(c<R>)= . 1 , .... n new fT ype(c<R>, . i ,., h), hi .i, \nhi+1 i . 1, ..n h ' 1 = hn+1 nonfinF ields(c<R>)= f 1 , ...f m ' . '' new fT ype(c<R>, f i ,.,h), hi \ni, hi+1 i . 1, ..m new c<R >, h ., h ' [. . (c<R >, . . ., f . . ' )] m Method calls evaluate the receiver \nand the argument, and look up the method body in the class as usual. More interestingly, in e3, the method \nbody, we replace the formal receiver by the actual one (./this), and the formal parameter by the actual \none (. ' /x). The class s ownership parameters will have already been replaced by the corresponding sets \nof owners in the object s runtime type (R/p)by the mBody function. 3 The order of the last two operations \nin the de.nition of fT ype is crucial; if the order was reversed, then the [Q/p] could introduce this \ninto the type, which would be incorrectly replaced (free variable capture) by the tG\u00b7e operation. For \nexample, in: class A<a>{ B<a> f; } class C<c>{ final A<this> a1; ... a1.b ... } thetypeof a1.b is B<this>. \nHowever, reversing the two operations would give to a1.b the (wrong) type B<a1>. 4 We do not give the \nnewly created object the class c<R>,in order to avoid objects with uninitialized .nal .elds. We give \n. the type c<R> only after the values for all new .elds are available. '' '' . '' ''' e1 , h ., he2 \n, h, hh'''(.)=(c<R>, ..., ...) mBody(m, c<R >)=(x, e3) '''' [./this,. '' /x]e3 , h . ' , h ' e1 .m(e2 \n), h . ' , h 3.4 Well-formed types In .gure 6 we de.ne the following .ve judgments: G f q \u00ab q ' q guaranteed \nto be inside q ' G f Q . Q ' Q allowed to intersect Q ' ' ' . Q G f Q .Q guaranteed disjoint with Q \nG f QQ consists of qs allowed to intersect G f c<Q> c<Q> well-formed type An environment, G, maps this, \nx and . to types, and contains a set of formal ownership parameters (p) and intersects and disjoints \nrelationships declared in the class of the receiver. The operator n is associative and commutative, and \nthe empty sequence E is neutral, i.e. E n Q = Q. An object is inside another, if its box (that is, the \nset of objects it owns) is a subset of the box of the other. The relations . and .. extend the declared \nintersec\u00adtions and disjointness of owner parameters and .elds. The disjoint relation makes use of the \ninside (\u00ab) relation for owner parameters. Atype c< Q > is well-formed in the context of an environment \nG, i.: a) there is a Q for each formal parameter p;b)each Q is well-formed (i.e. consists of ownership \nparameters which are allowed to intersect); and c) if two parameters are declared to intersect or be \ndisjoint in the class declaration, then the environment G will allow the parameters to intersect or guarantee \nthem to be disjoint, respecively.  3.5 Subtypes ' In .gure 7 we de.ne the subtype relation t <: t which \nis based on the subclass relationship. The auxiliary '' judgment Q [ Qguarantees that Qis thesameas Q \nexcept that some of the contents of Q may be replaced by ?.Note that [ is re.exive and transitive, but \nnot symmetric. We can easily prove that subtyping is transitive. For types c<Q> and c<Q' >,if no ? appears \nin Q or Q', subtyping is invariant with respect to the own\u00adership parameters. For example, C <o1 n o2> \nis not a subtype of C <o1 > to allow such a relation would be unsound. Similarly to Java Wildcards [11, \n49], the ? owner introduces variance (with respect to ownership parameters, as opposed to type parameters). \nHowever, in MOJO, ? also denotes variance in the number of own\u00aders. For example, as well as the obvious \nrelationship C <o><: C <?>,wealso have C <o1 n o2><: C <?>5 . 5 Q n ? r Q is not part of the subtyping \nrules, it is not sound because it would allow us to add variance to an invariant type. Objects allowed \nto intersect, or guaranteed to be disjoint G fq ' C q q C q ' .G G fq : t . C . ' .fCnstrs(t) G fq . \nq G fq C q ' G fq. ? G fq C q ' G fq.. C q.. ' G fq \u00abq ' G fq ' \u00abq '' G fq '' .. q G fq . q ' G fq .. \nq ' Q = Q1 nqQ ' = Q2 nq ' G fq..q ' Q = Q1 nq, Q ' = Q2 nq ' =. G fq . q ' G fQ ..Q ' G fQ . Q ' Well-formed \ntypes q .Dm(G) G fq : t . .fFields(t) G fQ G fq Q = Q ' nq ' =. G fq . q ' G fq G f? G fq.. G fQ nq \nclass c < p > ... < ... |Q|= |p| G fQQi C Qj .pCnstrs(c<Q >)=. G fQi C Qj G fc< Q > Inside relation for \nowner parameters '' ''' ' G fq \u00abq G fq \u00abq G(q)= c <q ' nQ,Q > G fq \u00abq ' G fq \u00abq ' G fq \u00abq Figure 6. \nWell-formed types and the inside , intersects and disjoint relations for owner parameters Wildcards in \nboth MOJO and Java are a use-site vari\u00adance mechanism, as opposed to declaration-site vari\u00adance, found \nin, for example, Scala [39] (again in the contex of type, not ownership, parameters).  3.6 Types of \nexpressions Thetypeof an expression e depends on an environment G and is given by the judgment G f e \n: t de.ned in .g\u00adure 7. The rules are as expected for an ownership type system, with some special care \ntaken for .eld assign\u00adment and parameter passing when the types involve ?, this is done using the strict \nversions of the .eld and method type functions, also given in .gure 7. Consider the following classes: \nclass B<b1>{ ... } class C<c1>{ B<c1> f1; B<?> f2; } in the example: class Test<t1,t2>{ void m1(C<t1> \nx, C<?> y){ x.f2 = new B<t2>; // type correct x.f2 = new B<?>; // type correct y.f1 = new B<t2>; // type \nerror y.f1 = new B<?>; // type error y.f2 = new B<?>; // type correct } } the assignments to x.f2 are \ntype correct because from the point of view of x its .eld f2 may contain a D<Q>, for any actual owners \nQ. On the other hand, any assign\u00adment to y.f1 is type-incorrect, because from the point of view of y \nits .eld f1 must contain a D<Q>,for some .xed actual owners Q, which are unknown in the cur\u00adrent context. \nIn terms of our formal description, the .rst two and the last assignment are type correct, because for \nall Q, it holds that [Q/c1]strictB<any> = B<any>; the next two assignments are type incorrect, because \n[?/c1]strictB<c1> is unde.ned. Furthermore, the types of .elds and methods need to treat the actual ownership \nparameter this specially; ie it replaces this by the expression whose .eld or method is being selected, \nprovided that e denotes a constant value. This is described through tG\u00b7e, de.ned in .gure 4, where this \n. t means that this appears in t: The following lemma is used to prove soundness of the type system (in \nTheorem 1 for the cases of .eld assignment and method call): ' Lemma 3. If e and e are paths evaluating \nto the '' /p]strict same the address in heap h,and [Qt = .,and '' [Q' /p ']Qi = Qfor all i,then: i ' \n[Q'/p '](([Q/p]t)h\u00b7e)=h [Q''/p](th\u00b7e). '' /p]strict Note that without the requirement [Qt = ., the left \nhand side type would have been a pure subtype of the righthand side. Subtypes Q c Q ' q c q ' q c qq \nc ? Q n q c Q ' n q ' Q c Q n ? c<p> < c ' <Q' > Q c Q' c<Q><: c ' <[Q/p]Q ' > c<Q><: c<Q ' > Strict \nmethod and .eld type lookup  [Q/p]strict[Q/p]t, if ?.Qi . pi ./t t = ., otherwise. fT ypestrict'' G\u00b7e \n (c<Q>, f, e, G) = [Q/p]strictt , where t = fT ypeaux(c<P>, f)and t = t. mT ypestrict(c<Q>, m, e, G) \n= [Q/p]strictt3 . [Q/p]t4, G\u00b7e G\u00b7e where t1 . t2 = mT ypeaux(c<p>, m)and t3 = t1 and t4 = t2 . Types \nof Expressions G f t G f e : t ' t ' <: t G f q :G(q)G f new t : t G f e : t G f e : t G f e : t fT ypestrict' \nmT ypestrict' '' G f e : t (t, f, e, G) = t (t, m, e, G) = t . t ' '' '' fT ype(t, f, e, G) = t G f e \n: t G f e : t ' '' ''' G f e.f : t G f e.f =e : t G f e.m(e ): t Figure 7. Subtypes, and Typing rules. \n 3.7 Well-formed Class and Program A class is well-formed if it has the same owner as the superclass, \nthe superclass type is well-formed, types mentioned in .elds and methods are well-formed, and method \nbodies are well typed. For checking well\u00adformedness of the superclass, constraints between own\u00adership \nparameters are taken into account. For checking types of .nal .elds, this is allowed to appear in t. \nFor checking types of .elds and method bodies, con\u00adstraints between .nal .elds are also taken into account; \nthis happens implicitly, through the introduction of this c <p> into the environment G''. Fields must \nnot overlap with those from the superclass. Finally, the con\u00adstraints on ownership parameters and .nal \n.elds must be well-formed. ' class c<p> pCnstr < c ' <Q> { fin t. fCnstr t f mth }Q1 = p1 G= p, pCnstrs(c \n<p>)G f c ' < Q > G ' G ' =G, this f t G '' G '' G '' ' =G ' , this c <p> f t f mth '' finF ields(c ' \n< Q >)= t . ' . ' n . = \u00d8 ''' ' nonfinF ields(c ' < Q >)= tf f ' n f = \u00d8 f G '' o Because MOJO does not \nrequire owners to be dom\u00adinators, there is no need for annotations requiring that certain owner parameters \nshould be inside others. Thus, we have omitted them for simplicity, although such an\u00adnotations allow \nmore information about disjointness to be deduced, and should be part of a full language. The constraints \non owner parameters and .elds are well-formed if they contain no contradictions: ' . p ' G f p . p . \nGf p . . p '' G f p .. Gf p . p f Go A method body is well typed if it contains an expres\u00adsion of the \nsame type as the return type of the method, and if overriding is legal (de.ned in .gure 9). G(this)= \nc <p> class c <p> pCnstr < c ' < Q > ... G f t G f t ' G, t ' x f e : t override(m, c ' < Q >, t ' . \nt) ' c < p > well formed G f tm(t x){e}  3.8 Runtime Types The function env maps heaps to typing environments, \nenriching these with information about the values of .nal .elds: De.nition 1. We de.ne env as follows: \n env(. .obj)= env(. .obj)  env(. .obj)= {. : c<R> }.{... .. }. {(.i C.j ) |. i C . j .fCnstrs(c<R>)} \n  where obj =(c<R>, . .., ... ) Wherever an environment gives a judgment, a corre\u00adsponding heap gives \nthe same judgment: h fjudg x .. env(h) fjudg x Thus we obtain judgements for typing expressions, well\u00adformed \ntypes, the inside relation, etc: h f. \u00ab. ' h fQ . Q ' h fQ ..Q ' fho h fQ h fc<Q>h fe : t 3.9 Well-formed \nHeap [[ . ]]h = {. ' |h f. ' \u00ab. } h(.)=(c<R>, , ) h fc<R> fT ype(c<R>, f, ., h)= t =. h fh(.)(f ): t \nh f. .. .Dm(h): h f. [[ . ]]h n[[ . ' ]]h = \u00d8 =. h f. . . ' h f. ... ' =. [[ . ]]h n[[ . ' ]]h = \u00d8 fh \no fh Figure 8. Well-formed objects and heaps In .gure 8 we de.ne well-formed objects and heaps. An object \n. in the heap is well-formed, expressed by h f., if its type is well-formed, and all its .elds have types \naccording to their static types. The heap is well\u00adformed if all objects in the heap are well-formed; \nwhere the boxes of objects intersect in the heap, the heap can show that these objects are in a . relationship; \nif the heap can show that two objects are in a .. relationship, then their boxes do not overlap; .nally, \nthe heap must contain no contradictions, i.e. there exist no objects ., . ' such that h f. . . ' and \nh f. ... ' .  3.10 Soundness of the Type System Theorem 1. For a well formed program, if h fe : t '' \nand fhand e, h ., h',then hf. : t, and fh. Proof. By structural induction, and using lemmas 6, 7, 9, \n10 and 11, listed in this section. The proofs of lemmas 6, 7, 9, 10, and 11 use further auxiliary lemmas. \nLemma 4 (Inversion Lemma). We de.ne the inver\u00adsion lemma in the usual way, that is, in a well-formed \nprogram, if G fe : t then the premises of the appropri\u00adate type rule holds. The only case that is interesting \nis where e = q, in which case we must insist that G(q) is de.ned. This ensures q is not a path, but a \nvariable. Lemma 5. In a well-formed program, if fhand h f e : t then 1. neither x nor this appear in \ne; 2. t = c<R>.  We .rst prove that runtime types and the inside relation are invariant with execution, \nwhile disjointness and possible intersection of objects are monotonic: Lemma 6. In a well-formed program, \nif ., . ' .Dm(h), and e,h . '' ,h ',and h fe : t ',then 1. h f. : t if and only if h ' f. : t 2. h f. \n\u00ab. ' if and only if h ' f. \u00ab. ' 3. h f.C. ' if and only if h ' f.C. '  As usual in soundness proofs, \nwe need a substitu\u00adtion lemma; in our particular setting, the substitution needs to be aware of ownership \nand allowed/forbidden intersections. For a substitution s which maps this and x to addresses, we de.ne \nits expansion, sh,so that italso maps formal ownership parameters (p). We then de.ne the concept of an \nappropriate substitution G, h fs,as one which preserves all constraints impledinG: De.nition 2. Given \na s : {this, x}-.N, we de.ne: sh : id -.Pwr(N) as follows: 1. sh(this)= s(this), sh(x)= s(x). 2. sh(p)= \nRi if h(s(this)) = (c< R >, ..., ...) and Dm(c)= pand p = pi ; unde.ned otherwise.   sh .t indicates \nthe application of sh on type t.  sh .e indicates application of sh on expression e.  G, h fs i. for \nany constraint C: 1. q C q ' .G=. h fsh(q) Csh(q ' ), 2. h fs(this): sh .G(this), 3. h fs(x): sh .G(x), \n 4. p .Dm(G) =. sh(p) .Dm(h), 5. p .Dm(G),.,. ' .sh(p)=. h f. . . ' .  We can now prove the substitution \nlemma: Lemma 7. If G, h fs then: ' 1. G fq \u00abq implies h fsh(q) \u00absh(q '). ' 2. G fq C q implies h fsh(q) \nCsh(q '). ' 3. G fQ C Qimplies h fsh(Q) Csh(Q'). Constraint lookup and method override class c <p> pCnstr \n< c ' <Q' > ... pCnstrs(c<Q>)=[Q/p]pCnstr, pCnstrs([Q/p]c ' <Q' >) pCnstrs(Object)=\u00d8 class c<p> pCnstr \n< c ' <Q' > { fin t. fCnstr t ' f mth }fCnstrs(Object)=\u00d8 fCnstrs(c < Q >)=[Q/p]fCnstr,fCnstrs([Q/p]c \n' <Q' >) mT ype(m, c<Q>)undefined mType(m, c<Q>)=t ' . t override(m, c<Q>, t ' . t) override(m, c<Q>, \nt ' . t) Figure 9. Constraint lookup functions and overrride function. ' 4. t<: t implies sh(t ') <: \nsh(t). 5. G f q : timplies h f sh(q): sh(t). 6. G f t implies h f sh(t). 7. G f e : timplies h f sh(e): \nsh(t). We de.ne t[c<c ' ] the projection of a type t as seen  ' from a class c to the way it is seen \nfrom a subclass c , and similarly, of an environment or an expression: De.nition 3. For environment G, \nclasses c, c ' ,type t, expression e,p = Dm(c),p ' = Dm(c '), we de.ne: [c<c ' ] ' e=[Q/p]e,if c<p ' \n><: c<Q> unde.ned, otherwise. [c<c ' ] ' t=[Q/p]t,if c<p ' ><: c<Q> unde.ned, otherwise. [c<c ' ] '' \nG=[Q/p]t x,c <p ' > this, p ' , pConstr' if c ' <p ' ><: c<Q> for some Q, and G=t ' x,c <p> this, p, \npConstr, and pConstr ' =[Q/p]pConstr. unde.ned, otherwise. We then prove that projection to subclasses \npreserves typing. In other words, if a type t is well formed in an environment from class c, then the \nprojection of t ' onto the subclass c is well-formed in the environment ' as de.ned in the subclass c \n. Lemma 8. For classes c,and c ', environments G so that G[c<c ' ] is de.ned: ' ][c<c ' ] t <:t ' implies \nt[c<c <:t '. [c<c ' ] f q[c<c ' ][c<c ' ] Gf q :timplies G:t. [c<c ' ] f t[c<c ' ] Gf timplies G. [c<c \n' ] f e[c<c ' ][c<c ' ] Gf e :timplies G:t. Using the above lemma we can prove that in well\u00adformed programs \nthe method body always satis.es its type: Lemma 9. If mT ypeaux(c< p >, m)= t1 . t2 and mBodyaux(c<p>, \nm)=(x, e),and G= this : c<p>, x : t1, p,pCnstrs(c<p>),then G f e : t2. We prove that subclassing preserves \nmethod types: Lemma 10. In a well-formed program, if c<p> '' < c< Q' > and mT ypeaux(c <p ' >, m)= t1 \n. t2 ' and class c <p ' > ... then mT ypeaux(c< p>, m)= [Q' /p ']t1 . [Q' /p ']t2. . '' Lemma 11. In \na well-formed program, if e, h , hand h(.)=(t, ...) then h'(.)=(t, ...). 4. E.ects E.ects are used to \ngive a conservative estimate of the area of the heap read or written by an expression. We describe these \nareas through one or more boxes, where the . operator describes the union of such boxes. The .rst part \nof an e.ect is the area being read; the second is the area being written: f ::= E | Q . f boxes . . E.ect \n::= f/f e.ect We expect programs to come equipped with a func\u00adtion to give us the e.ects of a method6: \n):Idclass \u00d7 Idmth -. E.ect Meff (, 4.1 The Example with E.ects We now revisit the example from section \n2, and give the values for the function Meff ( , ) through comments in the code. class Duration<d1> { \nDate<this> start; Date<this> end; void delay(){...} // EFF: this / this } class Task<t1> { Duration<this> \nduration; void delay(){...} // EFF: this / this } class Worker<w1>{ TaskList<this, this> tasks; void \nadd(Task<this &#38; ?> t){...} 6 Through the lookup function we skip the requirement for the de.nition \nof syntax. E.ects of expressions q .{this,x} Gft Gfe e :f1 /f2 Gff1 \u00abe f3 Gff2 \u00abe f4 Gff3 \u00abe f4 Gfe \nq :E/E Gfe new t :E/E Gfe e :f3 /f4 Gfe q :f/f '' ' Gfe e :f/f Gfe :c<Q,Q > Gfe q.f :f.q /f Gfe e.f :f.Q \n/f ' ' ' Gfe q :f1 /f2 Gfe e :f3 /f4 Gfe e :f1 /f2 Gfe e :f3 /f4 Gfe :c<Q,Q > ' ' Gfe q.f =e :f1 .f3 \n.q /f2 .f4 .q Gfe e.f =e :f1 .f3 .Q /f2 .f4 .Q ' ''' f/f =Meff (c<p>,m)Gfe q :f1 /f2 Gfe e :f3 /f4 Gfe \n:[Q/p]t Gfe q.m(e ' ):f1 .f3 .q .[Q/p]([q/this]f) /f2 .f4 .[Q/p]f ' ' ' ' ' Gfe :c<Q> f/f =Meff (c<p>,m) \nGfe e :f1 /f2 Gfe e :f3 /f4 Gfe :[Q/p]t Gfe.m(e ' ):f1 .f3 .Q1 .[Q/p]([Q1 /this]f) /f2 .f4 .[Q/p]f ' \ne E.ects inside other e.ects ' Gff1 \u00abe f3 Gff2 \u00abe f4 Gfq \u00ab q ' Gff1 \u00abe f2 Gff2 \u00abe f3 Gff1 . f2 \u00abe f3 \n.f4 . f5 GfE\u00abe f Gfq \u00abe q Gff1 \u00abe f3 Disjoint e.ects ' Gf f#f Gf f#f ' Gf f#f '' Gfq ..q ' Gf E#f Gf \nf ' #f Gf f#f ' . f '' Gf q nQ #q ' nQ ' Figure 10. E.ect rules for expressions, inside and disjointness \nrelations for e.ects.  // EFF: this / this for e.ects. We go on to prove soundness of the e.ect void \ndelay( ){...} // EFF: this / this system (theorem 3): that is, if the e.ects of two expres\u00ad} sions are \ndisjoint, then the order of their execution is unimportant. class TaskList<l1,l2>{ The e.ects of expressions \nare de.ned through the TaskList<l1,l2> next; ' judgment G fe e : f/f, given in .gure 10. The Task<l2 \n&#38; ?> task; void add(Task<l2 &#38; ?> t) // EFF: l1 / l1 rules are fairly straightforward, with e.ects \nof sub\u00advoid delay( ){...} // EFF: l2 / l2 expressions propagated to the enclosing expression; } reading \nor writinga.eld causingaread or write ef\u00adfect. Method invocation is more interesting: care must class \nProject<p>{ // be taken to substitute the owners of the receiver into TaskList<this, this> tasks; the \ne.ects of the method body correctly. The order of void add(Task<this &#38; ?> t){...} // substitutions \nis crucial, as it was for the type rules. // EFF: this / this void delay( ){...} // EFF: this / this \nFurthermore, if the receiver of a .eld read, .eld write } or method call is a path (i.e. a q), then the \ne.ect can be calculated more precisely. In our example: 4.2 E.ects of Expressions In this and the following \nsections we introduce e.ects final Worker<this> w1 = new Worker<this>; for expressions and the disjointness \nand inside relations final Worker<this> w2 = new Worker<this>; w1 disjoint w2; w1.delay(); // EFF: w1 \n/ w1 w2.delay(); // EFF: w2 / w2 final Project<this> p1=new Project<this>; p1.delay(); // EFF: p1 / \np1 The inside relation for e.ects (\u00abe ) is given in .gure 10; one e.ect is inside another if it covers \na smaller part of the heap.  4.3 Well-formed Programs with E.ects A program is well formed if, in addition \nto the require\u00adments from section 3.7, a) the read/write e.ect of a method body is inside its declared \ne.ect, b) the declared write e.ect of a method body is within its declared read e.ect, and c) the e.ect \nof an overriding method is inside the e.ect of any overridden method. Formally, ' we require that a) \ntm(tx){e} in c <p > implies that G feff e : Meff (c,m), b) Meff (c,m)= f1 /f2 implies that G f f2 \u00abe \nf1 ,where G = p,c<p > this,and c) Meff (c,m)= f1 /f2 and Meff (c ' ,m)= f3 /f4 and c<p> <c ' <Q> implies \nthat G f f1 \u00abe [Q/p]f3 and G f f2 \u00abe [Q/p]f4 ,where G = p,c<p> this. As a counterpart to lemma 8, lemma \n12 guarantees that the e.ect of an expression is preserved in a subclass modulo the necessary renamings \nfor ownership param\u00adeters: ' De.nition 4. For environment G, classes c and c, where p = Dm(c),p ' = Dm(c \n'),and e.ect f, we de.ne: ' f[ c <c ] ' =[Q/p]f,if c<p ' ><: c<Q> unde.ned, otherwise. Lemma 12. For \nclasses c,and c ', and environments G ] so that G[ c <c ' is de.ned: ' ] f f[ c <c ] '[ c <c ] G f f\u00abe \nf implies G[ c <c '' \u00abe f ' . ''' ' [ c <c ] : f[ c <c '[ c <c ] G fe e : f/f implies G[ c <c ] fe e] \n/f ' . In well-formed programs, the write e.ect is always inside the read e.ect for any expression: Lemma \n13. In a well-formed program, if G fe e : ' f/f ',then G f f \u00abe f. ' Proof. Straightforward induction \non G fe e : f/f.  4.4 Projecting E.ects onto the Heap Based on the \u00ab relation for objects (from .gure \n6), we de.ne [ f]]h , the projection of an e.ect f to a heap: De.nition 5. [[ r ]] h = { . | h f . \u00ab \nr} [[ r n R ]] h =[ r ]] h n [[ R ]] h [[ f . f ' ]] h =[ f ]] h . [[ f ' ]] h We can prove that the \ntype of an expression describes the boxes to which its evaluation will belong: ' Lemma 14. If h f e : \nc <R,R > and e,h .,h, then . . [[ R ]]h' . Proof. Straightforward application of the de.nitions (def \n5, and \u00ab from .g. 6), and theorem 1. We give rules for judging the disjointness relation (G f f# f ') \nin .gure 10. The rules state that the empty e.ect is disjoint from all e.ects; that the disjoint relation \nis symmetric and distributive with respect to the union of e.ects; and that if any pair of owners in \na pair of sets of multiple owners are disjoint (by the .. relation), then the e.ects denoted by this \npair of sets is disjoint (by the # relation). In the following lemma, the .rst two assertion guar\u00adantee \nsoundness of the inside and disjointness judg\u00adments are sound wrt. the projection of e.ects. The last \nassertion is the counterpart to lemma 7. Lemma 15. For any e.ects f, f , environment G, substitution \ns with G,h f s,and f h, we have If G f f\u00abe f ',then [[ sh . f]]h . [[ sh . f ' ]]h . ' If G f f# f ,then \n[[ sh . f]]h n [[ sh . f ' ]]h = \u00d8. ' If G fe e : f/f ',then h fe sh . e : sh . f/sh . f . Proof. by \ninduction on derivations of G f f\u00abe f ' ,resp. G f f# f ',resp. G fe e : f/f ', and using lemma 7.  \n4.5 Soundness of the E.ects System Soundness of the e.ects system guarantees that the read and write \ne.ects completely describe the areas of the heap read and written during some execution. We use the * \noperator, inspired by separation logic notation, for concatenation of functions with disjoint domains. \n' Thus, the construction h* h implicitly guarantees dis\u00adjointness of h and h '. The notation h|A means \nthe re\u00adstriction of the mapping h to the domain A. Theorem 2. In a well formed program, if G,hf s,and \n' G fe e : f/f ',and s . e,h .,h, then there exist ' heaps h1 ,h2 ,h3 ,h4 and h so that: 2 ' h=h1 * h2 \n* h3 ,and h ' =h1 * h2 * h3 * h4 , ' e,h1 * h2 .,h1 * h * h4 , 2 h1 * h2 =h|[[ s h.f ]] h and h2 =h|[[ \ns h.f ' ]] h '' h1 * h2 =h ' |[[ s h.f ]] h ' and h2 =h ' |[[ s h.f ' ]] h ' Proof. By induction on the \nderivation of e,h .,h '.We ' use an e.ects inversion lemma , e.g. G fe e.f : f/f implies that G fe e \n: f1 /f2 ,and G f e : c<Q,Q >, and G f f1 . Q \u00abe f,and G f f2 \u00abe f ',and ' G f f \u00abe f for some f1 and \nf2 . Wealso use thefact ' ''' that e,h .,h implies that if h and h are disjoint, '' '' then e,h* h .,h \n' * h . We now prove that the execution of two expressions with disjoint e.ects is independent, in the \nsense that the order of their execution is immaterial: Theorem 3. In a well formed program, if G,h f \ns, and f h and G fe e1 : f1 /f2,and G fe e2 : f3 /f4, and G f f1 # f4 and G f f2 # f3,then '' ''' s. \ne1,h . ' ,h , s. e2,h .,h , implies ''' ''' ' s. e2,h .,h , s. e1,h . ' ,h Proof. The proof is based \non Matthew Smith s thesis [47], which develops an abstract model of independence of expressions based \non disjointness of e.ects for any languages satisfying a set of basic requirements. Theo\u00adrem 3.5.2 from \n[47] guarantees the assertion of our the\u00adorem provided that the heap satis.es basic composition and decomposition \nproperties (SH1-SH6 in [47]), that execution also satis.es basic decomposition properties (LL2,L1-L5 \nin [47]), and that e.ects also satisfy de\u00adcomposition properties (LS1-LS5). Property LS4 cor\u00adresponds \nto theorem 2. All the other properties can be easily proven for MOJO. In terms of our example w1 disjoint \nw2; w1.delay(); // EFF: w1 &#38; ? / w1 &#38; ? w2.delay(); // EFF: w2 &#38; ? / w2 &#38; ? p1.delay(); \n// EFF: p1 &#38; ? / p1 &#38; ? From e1#e2 we obtain that e1&#38;?#e2 &#38; ? and there\u00adfore e1.delay() \nand e2.delay() are independent of each other in the sense of the above theorem. On the other hand, e1.delay() \nand p1.delay() are not neces\u00adsarily independent as we have no information regarding the disjointness \nof w1 and p1. 5. Discussion and Future Work We plan to implement MOJO, investigate its applicabil\u00adity, \nespecially extensions to support race-free programs and atomicity [9, 20]. In this section we discuss \nthe repercussions of giving up owners as dominators, outline some idioms of multiple ownership, and some \nshortcom\u00adings in our use of ?. 5.1 Giving up Owners as Dominators As we said earlier, MOJO does not \nattempt to enforce the owners as dominators discipline. In other words, MOJO is a descriptive system: \nownership characterizes the topology of the heap, rather than constrains it. This is why MOJO does not \nrequire that ownership parameters preserve some inside relationship. Fur\u00adthermore, without the owners \nas dominators discipline, and with the use of paths as actual owner parameters, some idioms, e.g. multiple \niterators over one list, are straightforward to implement, i.e. class List<l1,l2>{ Node<this,l2> head; \nIterator<this,l2> makeIterator() { new Iterator<this,l2>.next = head; } ... } class Node<n1, n2> { Data<n2> \nd; Node<n1,n2> next; ... } class Iterator<i1,i2>{ Node<i1,i2> next; ... } ... final List<o1,o2> list1; \n Iterator<list1,o2> iter1 = list1.makeIterator(); In our example, iter1.next points to a node owned by \nlist1. Notethatwedid not make use of multiple ownership, since all the nodes pointed at by one iterator \nbelong to the same list. In contrast, owners-as-dominators systems [7, 23, 5]) impose topological restrictions \non heaps: a box s owner must be a dominator on all paths leading into the objects in the box: there can \nbe no incoming pointers into a box (except from the box s owner). This amounts to requiring that a-. \nb=. a. [[ owner(b)]] that is, if a points to b,then a is inside b s owner. We want to extend the MOJO \ntype system so that references are permitted only if they come from within one of the owners (note we \nsay a . owners(b)rather than a . owner(b)). Thus, owners as dominators will apply to types instantiated \nwith a single owner, and will be extended to owners as articulation points otherwise. Furthermore, owners-as-modi.ers \nsystems, e.g. [31, 18], allow incoming pointers but forbid incoming mes\u00adsages that may modify an object: \nall modi.cations must pass via an object s owner. To represent owners-as\u00admodi.ers in MOJO, one would \nallow non-pure method calls only if the sender is inside the receiver s owners boxes.  5.2 Idiom 1: \nBoxes for Variables In contrast to many e.ects systems, e.g. OOFX [22], MOJO does not directly distinguish \nbetween object .elds. For example, if Task had methods delay and bribe updating .eld cost and time respectively, \nthen these methods would have e.ect this / this and MOJO would be unable to deduce their noninterference. \nField e.ects, although not directly included in our formal system, can be modelled with a simple idiom: \nDe.ne a IntBox class with a single .eld, and getter and Project Task1 Task2 Cost 1 Time1 Cost 2 Time2 \n Figure 11. Cost and Time boxes inside Task boxes setter methods for that .eld, a.ecting only that object. \nRewrite the Task class to store each .eld in an IntBox with its own separate .nal .eld owner (see Figure \n11), and use the getter and setter methods. The e.ect of each method is localised to its IntBox, so wherever \nIntBoxes are visible, the methods can be distinguished. 5.3 Idiom 2: Multiple Boxes per Object In some \ncases it is useful to link boxes between nested objects. For example, in .gure 12 the project has cost \nand duration boxes. We require each task s cost to be inside the project s cost, and similarly duration \ninside the project s duration. That would allows us to show that delay methods on projects a.ect only \ndurations, and do not a.ect the cost of the project or any of its tasks (and vice versa). We can code \nthis by giving two additional owner\u00adship parameters to Task (e.g. timeO representing time, costO representing \ncost), and placing the time and cost objects into the intersection of the respective ownership boxes, \ne.g. through Duration<this &#38; timeO> time.  5.4 Generics, and the meaning of ? An obvious extension \nof MOJO would be the introduc\u00adtion of generic types, so as, e.g. to allow the de.nition of generic lists \n[18, 42]. Another challenge is a more powerful notion of exis\u00adtential quanti.cation than our current \n?,which is,we believe, adequate but could be more powerful. In par\u00adticular, in our current solution, \nthe TaskList is aware that its tasks have two owners, and the second one is unknown to the list. Thus, \na TaskList whose tasks have three owners would require the declaration of a further class. This clearly \nrestricts the reuse of the classes. It would be better if only classes Worker and Project were aware \nof the possible other owners of the tasks involved, and class TaskList was unaware of that. We plan to \nex\u00adtend our approach so as to address this issue. Seen from a related viewpoint, ? is related to the \nno\u00adtion of existential types. Thus, a list of tasks which share the same hidden owner would be .X.List<Task<X>> \nwhile a list of tasks where each tasks has a potentially Project Task1 Task2 Cost Time Figure 12. Nested, \ninterlocking ownership.  di.erent, hidden owner would be List<.X.Task<X>>. Note that the counterpart \nto the former is expressible but not denotable using Java wildcards [11]. 6. Related Work MOJO draws \non two primary sources on e.ects systems and on ownership types and more recently, on work combining \nthe two. Larger surveys of these areas can be found in [15, 41, 47]; here we provide an overview. E.ects \nsystems and other approaches for syntactic control of interference have been developed for over thirty \nyears [33, 44]. After interesting precursor work by Daniel Jackson [27], work on e.ects systems for object\u00adoriented \nprograms began with Leino s Data Groups [30] and Greenhouse and Boyland s Object-Oriented E.ects System \n(OOFX) [22]. Data Groups were designed to support framing of changes across inheritance hierarchy, while \nOOFX provides a more general framework for reasoning about object-oriented programs. Ownership types \n[14] were created by Clarke [12] to implement the .exible alias protection proposal [38]. Several variants \nof ownership types have been built including Con.ned Types [7, 23], Ownership Domains [2, 28], Generic \nOwnership [41, 42], Universes [35, 18], and have been used for purposes ranging from program veri.cation \n[29, 36] to concurrency [8], to real-time memory management [5]. While these systems vary in the provided \nlanguage constructs, type systems, and invariants, they all main\u00adtain the key constraint that every object \nhas one owner at any given time. While some precursor work specu\u00adlates about shared ownership, ours is \nthe .rst to provide multiple owners. The .rst system to combine e.ects and some form of ownership was \nGreenhouse and Boyland s OOFX [22]: e.ects from encapsulated subcomponents could be in\u00adcorporated into \ne.ects upon their owners provided the subcomponents were accessed via a unique pointer. This system has \nrecently been proven correct using adoption and separation logic [10]. OOFX includes a restricted form \nof multiple ownership in that instance regions can simultaneously belong to the instance, and to a corre\u00adsponding \nregion of a superordinate object. OOFX boxes (regions) cannot otherwise overlap, even though in e.g. \nData Groups one .eld could be in more than one group. Boyland argues that intersecting regions limit \ne.ect sep\u00adaration: however multiple ownership s intersection and disjointness constraints remove this \nproblem by making the program s local ownership topology clear: compu\u00adtations will be independent if \ntheir e.ects are known to be disjoint. Clarke and Drossopoulou s JOE combines ownership with e.ects [13]. \nUnlike OOFX, JOE does not provide regions for variables or data groups within objects; JOE e.ects describe \nobjects from a particular depth inside their owners. Smith subsequently constructed an e.ects system \nfor ownership domains [46]. Lu and Potter designed a number of interesting own\u00adership type systems based \non e.ects [31, 32]. E.ec\u00adtive ownership provides e.ect encapsulation en\u00adforcing an owners-as-modi.ers \ndiscipline without any constraints on inter-object references. They have built on this work to describe \nhow ownership and e.ects can model invalidating (and obligations to revalidate) ob\u00adjects invariants. \nMost recently, Clifton s MAO [15, 16] uses an own\u00adership and e.ects system to manage interference in \nan aspect-oriented language. MAO s ownership model is static, similar to that of con.ned types, with \na set of global domains, generally one per aspect instance plus one for the base program. MAO s model \nis su.cient to detect aspect interference, and can be modelled in MOJO as a series of global boxes (a \nlarger scale ver\u00adsion of idiom 2 from section 5.3). More generally, Multiple Ownership is related to \nother approaches to managing objects, e.ects, and allo\u00adcation, such as region-based memory management \n[48] and alias types [45]. Multiple Ownership is also related to separation logic, in particular, Parkinson \nand Bier\u00adman s abstract invariants [40] can be seen as de.ning regions in the heap, as well as giving \ninvariants for those regions. The key di.erence is that separation logic for\u00admul\u00e6 implicitly de.ne the \nregions to which they apply, whereas ownership (types or assertions) de.ne regions explicitly and independently \nof any formul\u00e6. Finally, our ownership diagrams are related to set diagrams used in OO modelling, e.g. \nSpider and Constraint diagrams [21]. 7. Conclusion ...structures like the city, which do require overlapping \nsets within them, are nevertheless persistently conceived as trees. Christopher Alexander, ACityisnotaTree[3] \nA city is not a tree, and neither is a program [6, 34, 43]. Multiple ownership does not impose an ownership \ntree onto the objects in a program: it allows DAGs, and places objects into boxes sets that may inter\u00adsect \nor remain disjoint as best serves the program s de\u00adsign. Using this objects in boxes model for ownership, \nwe show how multiple ownership can be described as a smooth generalisation of single ownership systems. \nWe have incorporated multiple ownership into the MOJO programming language design, including an e.ect \nsys\u00adtem, that we have proven sound. Acknowledgments This work was funded in part by the Information Society \nTechnologies program of the European Commission, Future and Emerging Technolo\u00adgies under the IST-2005-015905 \nMOBIUS project; by the EPSRC DTA grants; by the EPSRC grant Practi\u00adcal Ownership Types for Objects and \nAspect Programs, EP/D061644/1; by Microsoft Research Cambridge; by a gift from Microsoft Research; and \nby the Royal Society of New Zealand Marsden Fund. We are grateful to David Cunningham and Alex Buckley \nfor their insightful comments, and to the anonymous OOPSLA referees for their encouraging and useful \nfeedback. References [1] Marwan Abi-Antoun and Jonathan Aldrich. Ownership domains in the real world. \nIn IWACO workshop at ECOOP, 2007. [2] Jonathan Aldrich and Craig Chambers. Ownership domains: Separating \naliasing policy from mechanism. In ECOOP, 2004. [3] Christopher Alexander. A city is not a tree. Design, \n(206), 1966. [4] Paulo S\u00b4ergio Almeida. Balloon types: Controlling sharing of state in data types. In \nECOOP, 1997. [5] Chris Andreae, Yvonne Coady, Celina Gibbs, James Noble, Jan Vitek, and Tian Zhao. Scoped \ntypes and aspects for real-time Java. In ECOOP, 2006. [6] Gareth Baxter, Marcus R. Frean, James Noble, \nMark Rickerby,Hayden Smith,Matt Visser, Hayden Melton, and Ewan D. Tempero. Understanding the shape of \nJava software. In OOPSLA, 2006. [7] Boris Bokowski and Jan Vitek. Con.ned types. In OOPSLA, 1999. [8] \nChandrasekhar Boyapati, Robert Lee, and Martin Rinard. Ownership types for safe programming: Preventing \ndata races and deadlocks. In OOPSLA, November 2002. [9] Chandrasekhar Boyapati and Martin Rinard. A Parameterized \nType System for Race-Free Java Programs. In OOPSLA, pages 56 69, Tampa Bay, FL, USA, 2001. [10] John \nBoyland and William Retert. Connecting e.ects and uniqueness with adoption. In POPL, 2005. [11] Nicholas \nCameron, Erik Ernst, and Sophia Drossopoulou. Towards an existential types model for Java with wild\u00adcards. \nIn FTfJP workshop at ECOOP, 2007. [12] Dave Clarke. Object Ownership and Containment.PhD thesis, UNSW, \nAustralia, 2002. [13] Dave Clarke and Sophia Drossopoulou. Ownership, Encapsulation, and the Disjointness \nof Type and E.ect. In OOPSLA, 2002. [14] David Clarke, John Potter, and James Noble. Owner\u00adship types \nfor .exible alias protection. In OOPSLA, 1998. [15] Curtis Clifton. A design discipline and language \nfeatures for modular reasoning in aspect-oriented programs. PhD thesis, Iowa State, 2005. [16] Curtis \nClifton, Gary T. Leavens, and James Noble. Ownership and e.ects for more e.ective reasoning about aspects. \nIn ECOOP, 2007. [17] Gilles Deleuze and F\u00b4elix Guattari. A Thousand Plateaus: Capitalism and Schizophrenia. \nU. Minnesota, 1987. [18] Werner Dietl, Sophia Drossopoulou, and Peter M\u00a8uller. Generic universe types. \nIn ECOOP, 2007. [19] Sophia Drossopoulou. The bene.ts of putting objects into boxes. ESOP, 2006. Invited \nTalk. [20] Cormac Flanagan, Stephen N. Freund, and Marina Lifshin. Type inference for atomicity. In TLDI, \n2005. [21] Joseph Gil, John Howse, and Stuart Kent. Towards a formalization of constraint diagrams. In \nHCC, 2001. [22] Aaron Greenhouse and John Boyland. An object\u00adoriented e.ects system. In ECOOP, 1999. \n[23] Christian Grotho., Jens Palsberg, and Jan Vitek. Encapsulating Objects with Con.ned Types. In OOPSLA, \n2001. [24] Ralf Hinze. The Fun of Programming, chapter Fun with Phantom Types, pages 245 262. Palgrave \nMacmillan, 2003. [25] John Hogg. Islands: Aliasing protection in object\u00adoriented languages. In OOPSLA, \n1991. [26] Atsushi Igarashi, Benjamin Pierce, and Philip Wadler. Featherweight Java: A minimal core calculus \nfor Java and GJ. In OOPSLA, November 1999. [27] Daniel Jackson. Aspect: Detecting bugs with abstract \ndependences. ACM ToSEM, 4(2), 1995. [28] Neel Krishnaswami and Jonathan Aldrich. Permission\u00adbased ownership: \nEncapsulating state in higher-order typed languages. In PLDI, 2005. [29] K. R. M. Leino and P. M\u00a8uller. \nObject invariants in dynamic contexts. In ECOOP, 2004. [30] K. Rustan M. Leino. Data groups: Specifying \nthe modi.cation of extended state. In OOPSLA, 1998. [31] Yi Lu and John Potter. Protecting representation \nwith e.ect encapsulation. In POPL, pages 359 371, 2006. [32] Yi Lu and John Potter. Object invariants \nand e.ects. In ECOOP, 2007. [33] John M. Lucassen and David K. Gi.ord. Polymorphic e.ect systems. In \nPOPL, 1988. [34] Nick Mitchell. The runtime structure of object ownership. In ECOOP, 2006. [35] Peter \nM\u00a8uller. Modular Speci.cation and Veri.cation of Object-Oriented Programs, volume 2262 of Lecture Notes \nin Computer Science. Springer-Verlag, 2002. [36] Peter M\u00a8uller. Reasoning about object structures using \nownership. In Veri.ed Software: Theories, Tools, Experiments, LNCS. Springer-Verlag, 2007. [37] James \nNoble, Robert Biddle, Ewan Tempero, Alex Potanin, and Dave Clarke. Towards a model of encapsulation. \nIn IWACO workshop at ECOOP, 2003. [38] James Noble, Jan Vitek, and John Potter. Flexible alias protection. \nIn ECOOP, 1998. [39] Martin Odersky and Matthias Zenger. Scalable component abstractions. In OOPSLA 05, \npages 41 57, New York, NY, USA, 2005. ACM Press. [40] Matthew Parkinson and Gavin Bierman. Separation \nlogic and abstraction. In POPL, 2005. [41] Alex Potanin. Generic Ownership A Practical Approach to Ownership \nand Con.nement in OO Programming Languages. PhD thesis, 2007. [42] Alex Potanin, James Noble, Dave Clarke, \nand Robert Biddle. Generic ownership for generic Java. In OOPSLA, 2006. [43] Alex Potanin, James Noble, \nMarcus Frean, and Robert Biddle. Scale-free geometry in object-oriented programs. Communications of the \nACM, May 2005. [44] John C. Reynolds. Syntactic control of interference. In POPL, 1978. [45] Frederick \nSmith, David Walker, and Greg Morrisett. Alias types. In ESOP, 2000. [46] Matthew Smith. E.ects system \nfor ownership domains. In FTfJP workshop at ECOOP, 2005. [47] Matthew Smith. A Model of E.ects with an \napplication to Ownership Types. PhD thesis, Imperial College, 2007. [48] Mads Tofte and Jean-Pierre Talpin. \nRegion-Based Memory Management. Information and Computation, 132(2):109 176, 1997. [49] Mads Torgersen, \nChristian Plesner Hansen, Erik Ernst, Peter von der Ah\u00b4e, Gilad Bracha, and Neal Gafter. Adding wildcards \nto the Java programming language. In SAC 04, pages 1289 1296, 2004. [50] Tobias Wrigstad and Dave Clarke. \nExistential owners for ownership types. JOT, 2007.    \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Existing ownership type systems require objects to have precisely one primary owner, organizing the heap into an ownership tree. Unfortunately, a tree structure is too restrictive for many programs, and prevents many common design patterns where multiple objects interact.</p> <p>Multiple Ownership is an ownership type system where objects can have more than one owner, and the resulting ownership structure forms a DAG. We give a straightforward model for multiple ownership, focusing in particular on how multiple ownership can support a powerful effects system that determines when two computations interfere-in spite of the DAG structure.</p> <p>We present a core programming language MOJO, Multiple ownership for Java-like Objects, including a type and effects system, and soundness proof. In comparison to other systems, MOJO imposes absolutely no restrictions on pointers, modifications or programs' structure, but in spite of this, MOJO's effects can be used to reason about or describe programs' behaviour.</p>", "authors": [{"name": "Nicholas R. Cameron", "author_profile_id": "81339492259", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "P905212", "email_address": "", "orcid_id": ""}, {"name": "Sophia Drossopoulou", "author_profile_id": "81100331741", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "PP39075778", "email_address": "", "orcid_id": ""}, {"name": "James Noble", "author_profile_id": "81100588708", "affiliation": "Victoria University of Wellington, Wellington, New Zealand", "person_id": "PP39049797", "email_address": "", "orcid_id": ""}, {"name": "Matthew J. Smith", "author_profile_id": "81339529301", "affiliation": "Imperial College London, London, United Kingdom", "person_id": "PP39108667", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297060", "year": "2007", "article_id": "1297060", "conference": "OOPSLA", "title": "Multiple ownership", "url": "http://dl.acm.org/citation.cfm?id=1297060"}