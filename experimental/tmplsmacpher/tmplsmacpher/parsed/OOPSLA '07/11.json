{"article_publication_date": "10-21-2007", "fulltext": "\n StreamFlex: High-throughput Stream Programming in Java Jesper H. Spring Ecole Polytechnique F\u00b4erale \nde Lausanne ed\u00b4 Jean Privat Computer Science Dept. Purdue University JanVitek IBM Research and Computer \nScience Dept. Purdue University Rachid Guerraoui Ecole Polytechnique F\u00b4erale de Lausanne ed\u00b4 Abstract \nThe stream programming paradigm aims to expose coarse\u00adgrained parallelism in applications that must process \ncontin\u00aduous sequences of events. The appeal of stream program\u00adming comes from its conceptual simplicity.Aprogramisa \ncollection of independent .lters which communicate by the means of uni-directional data channels. This \nmodel lends it\u00adself naturally to concurrent and ef.cient implementations on modern multiprocessors. As \nthe output behavior of .lters is determined by the state of their input channels, stream programs have \nfewer opportunities for the errors (such as data races and deadlocks) that plague shared memory con\u00adcurrent \nprogramming. This paper introducesS TREAMFLEX, an extension to Java which marries streams with objects \nand thus enables to combine, in the same Java virtual machine, stream processing code with traditional \nobject-oriented com\u00adponents.STREAMFLEXtargets high-throughputlow-latency applications with stringent \nquality-of-service requirements. To achieve these goals, it must, at the same time, extend and restrict \nJava. To allow for program optimization and provide latencyguarantees, the STREAMFLEX compiler re\u00adstricts \nJava by imposing a stricter typing discipline on .l\u00adters.On the other hand,STREAMFLEX extends theJava \nvir\u00adtual machine with real-time capabilities, transactional mem\u00adory and type-safe region-based allocation. \nThe result is a rich and expressive language that can be implemented ef\u00ad.ciently. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, \n2007, Montr \u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; 2007ACM 978-1-59593-786-5/07/0010...$5.00 Categories \nand Subject Descriptors D.3.4 [Program\u00adming Languages]: Processors run-time environments; D.3.3[Programming \nLanguages]: Language Constructs and Features classes and objects; D.4.7[Operating Systems]: Organization \nand Design real-time systems and embedded systems. General Terms Languages, Experimentation. Keywords \nReal-time systems, Java virtual machine, Mem\u00adory management, Ownership types, Stream processing. 1. Introduction \nStream processing is a programming paradigm .t for a class of data driven applications which must manipulate \nhigh\u00advolumesofdatainatimelyand responsivefashion. Example applicationsinclude video processing, digital \nsignal process\u00ading, monitoring of business processes and intrusion detec\u00adtion. While some applications \nlend themselves naturally toa distributed implementation, we focus on single node systems and, in particular, \non programming language support for ef\u00ad.cient implementation of systems that require microsecond latencies \nand low packet drop rates. Inastream processing language,aprogramisacollection of .lters connected by \ndata channels. Each .lter is a func\u00adtional unit that consumes data from its input channels and produces \nresults on its output channels. In their purest form, stream processing languages are ideally suited \nto parallel im\u00adplementationsastheoutputbehaviorofa.lterisa determin\u00adistic function of the data on its \ninput channels and its inter\u00adnal state. As .lters are independent and isolated from one another, they \ncan be scheduled in parallel without concern about data races or other concurrent programming pitfalls \nthat plague shared memory concurrent programs. The appeal of this modelisevidencedbya numberof stream \nprocessing languages and systems include Borealis [2], Infopipes [10], StreamIt[32]and Gryphon[9]. These \nlanguageshavealong lineage which can be traced back toWadge and Ashcroft s Lucid [5] data .ow language \nand, to some extent, to the Es\u00adterel and Lustrefamilyof synchronous languages [17, 13]. High performance \nstream processing systems that deal with large volumes of data should be designed to ful.ll at least \nthe following two key requirements (out of the eight requirements given in [31]): keep the data moving \n: this means messages must be processed with as littlebuffering as possible;  respond instantaneously \n: any substantial pause may result in dropped messages and must be avoided.  Stream processing applications, \nif theyare to meet their non\u00adfunctional requirements, must be engineered with great care. Moreover, the \nunderlying infrastructure, the stream process\u00ading language and its runtime system, must be designed and \nimplementedsoastoavoid inherentinef.ciencies.The chal\u00adlenge for stream processing language designers \nis to provide abstractions that are expressive enough to allow rapid devel\u00adopment of applications without \ngiving up on ef.ciencyand predictability. Consider,for instance,anetwork intrusion de\u00adtection system \nwith a number of detection modules de.ned as .lters over a stream of network packets. Throughput of the \nsystem is crucial to process event streams at rates in the hundreds of MBps and latency is important \nto avoid drop\u00adping packets and thereby possiblyfailing to detect attacks. These requirements have obvious \nimplications on both user\u00adde.ned streaming code and the underlying infrastructure. Unlike stream programming \nlanguages such as StreamIt, Lucid or Esterel, we propose to provide only a limited set of new abstractions \nfor stream processing and leverage a host language for its general purpose programming con\u00adstructs.Thishastheadvantageofprovidingafamiliar \nframe\u00adwork for developersbut comes at the cost of having to deal with the impedance mismatch between \nthe requirements of stream processing and features provided by the host lan\u00adguage. In this paper, we \nintroduce STREAMFLEX, an ex\u00adtension to the Java programming language with support for high-throughput \nstream processing. Java is a pragmatic choice as it is a mainstream language with a wealth of li\u00adbrariesandpowerful \nIDEs. Not only does this makeit easier for programmersto acceptthenew abstractions,butit opens up opportunities \nfor seamlessly integrating stream proces\u00adsors in larger applications written in plain Java. However, \nJava presents signi.cant implementation challenges.Infact, it is not obvious at .rst that Java is at \nall suitable for applica\u00adtions with stringent quality of service requirements.AJava virtual machine implementationisthe \nsourceof manypoten\u00adtial interferences due to global data structures, just-in-time compilation and, of \ncourse,garbage collection. In [30], we have performed empirical measurements of the performance of standard \nand real-timegarbage collectors. Our stop-the\u00adworld collector introduced pauses of 114 milliseconds; \nus\u00ading a real-time collector pause time went down to around 1 milliseconds at the expense of application \nthroughput. In both cases, the pauses and performance overheads were too severe for some of our target \napplications. The STREAMFLEX programming model is inspired both by the StreamIt language and, loosely, \nby the Real-time Speci.cation forJava [11].S TREAMFLEX includes changes to the virtual machine to support \nreal-time periodic execu\u00adtion of Java threads, a static type system which ensures iso\u00adlation of computational \nactivities, a type-safe region-based memory model that permits .lters to compute even when thegarbage \ncollector is running, and software transactional memory for communication between .lters and Java. The \ncontributions of this paper are the following: Programming Model: We present a new programming model \nfor real-time streaming which allows developers to write stream processors in Java. The proposal does \nnot require changes to Java syntax. Filters are legal Java pro\u00adgrams and, STREAMFLEX can be manipulated \nby main\u00adstream IDEs such as Eclipse. A number of standard li\u00adbraries and API can be used within .lters, \nand .lters can be integrated into Java applications.  Filter Isolation: STREAMFLEX .lters are isolated \ncom\u00adponents that communicate by non-blocking bounded channels. Software transactional memory is used \nfor syn\u00adchronization of shared data channels.  Zero-Copy Message Passing: The STREAMFLEX type system \nallows mutable data objects to be transefered along linear .lter pipelines without requiring copies. \n Implementation: We have implemented our proposal on topofa real-time virtual machineandextendedaversion \nof the javac compiler to enforce the STREAMFLEX type system.  Evaluation: We present an empirical evaluation \nof our system. We show that STREAMFLEX programs outper\u00adformthe correspondingJavavariants.Wealsoshowour \nimplementation achieves a high degree of predictability.  STREAMFLEXisbuiltontopoftheOvm virtual machine[4] \nwhich comes with an implementation of the Real-time Spec\u00adi.cation for Java (RTSJ). While we initially \nenvisaged us\u00ading the RTSJ directly, we found the API too complex and error prone for our needs. Instead, \nwe based STREAM-FLEX ona simpler real-time programming model called Re\u00ad.exes [30]. Re.exes already provide \nsome of the features that are required by STREAMFLEX, namely, real-time pe\u00adriodic threads, region-based \nallocation and software trans\u00adactional memory. The main differences are in the program\u00adming model, Re.exes \nare stand alone components with no support for cooperation across multiple Re.exes. TheS TR-EAMFLEX type \nsystem is an extension to the ScopeJ type system of [34]. The relationship with previous work is fur\u00adther \ndetailed in Section 8.  class Gen extends Filter {IntChannel out; TimeChannel t; class Mid extends Filter \n{IntChannel in, out; class Sink extends Filter {IntChannel in; int counter; void work() {out.put(counter++); \nvoid work() {out.put(in.take()); void work() {print( got +in.take()); }} }} }} (a) Filter Gen (b) Filter \nMid (c) Filter Sink Figure 1. ExampleofaSTREAMFLEX pipeline. 2. Stream Processing This section introducesthemain \nconceptsofSTREAMFLEX. Astream processing applicationisbuilt outofa numberof .lters connected by channels \nto form a .lter graph. Filter graphs are executed by the STREAMFLEX runtime engine which manages both \nconcurrency within any given graphs and across multiple graphs. The basic computational unit for processing \none or more data streams is the .lter.A.lter is a schedulable entity con\u00adsisting of user-de.ned persistent \ndata structures, typed in\u00adput and output channels, an activity and an (implicit) trig\u00adger on channel \nstates. An activity can become schedulable anytime new data appears on one of the associated .lter s \ninput channel, more precisely a .lter becomes schedulable when it s trigger predicateevaluate to true. \nTheSTREAM-FLEXscheduler is responsible for releasing the activity with\u00adout any guarantee of timeliness. \nIt only promises that any schedulable activity will eventually be released. If program\u00admersrequiretimelyexecutionof \n.lters,theymustuse clocks. Clocks generateeventson time channels. When .lteris con\u00adnected to a clock, \nthe scheduler arranges for the .lter to be released periodically. Simple Example. Figure1presentsa purposefully \nsimple STREAMFLEX graph. User-de.ned .lters are Java classes that extend the pre-de.ned Filter class. \nThe .lters in this example are arranged to form a simple pipeline. Activi\u00adties are implemented by the \nwork() method of each .lter, these methods are invoked repeatedly by the STREAMFLEX schedulerwhenthe \n.lter striggerpredicateevaluatestotrue. By convention, work() methods are expected to eventually yield \nin most applications it would be a programming er\u00adror for an activitytofail to terminate as this could \nprevent evaluation of other triggers and block the entire pipeline. The .rst .lter in Figure 1 is an \ninstance of the built-in Clock class. The clock periodically puts a signal on the tim\u00ading channel of \nthe .rst .lter, an instance of the user-de.ned class Gen shown in Figure 1(a). Gen is a stateful .lter \nwith a single integer output channel. Like anyJava class, a .lter may have instance variables and methods. \nIn this case, Gen keeps a counter which it increments at each release before puttingthe counter svalueonits \noutput channel.The .lterin Figure 1(b) is simple and stateless. It consists of two integer channels, \none for input and one for output. Its only behavior istoreadasinglevaluefromitsinputandputitonits output \nchannel. Finally, Figure 1(c) is a seemingly innocuous .lter for printing the value received on its input \nchannel. Constructing Filter Graphs. STREAMFLEX .lter graphs are constructedbyextending thebuilt-in StreamFlexGraph. \nThe protocol is simple: the constructor creates and connects all .lters and clocks and then calls validate() \nto verify that the graph is well formed. Once validate() has been called the graph cannot be changed. \nFigure 2 demonstrates the construction of the graph of Figure 1. class Simple extends StreamFlexGraph \n{ Simple(int period) { Clock clk = makeClock(period); Filter gen = makeFilter(Gen.class); Filter mid \n= makeFilter(Mid.class); Filter sink = makeFilter(Sink.class); connect(clk, gen, timer ); connect(gen, \nout , mid, in , 1); connect(mid, out , sink, in , 1); validate(); }} Figure 2. Constructing the .lter \ngraph of Figure 1. Interaction with Java. Runningastream processing appli\u00adcation ona standard JVMwould \nuncovera numberof draw\u00adbacks of Java for applications with any quality of service requirements.For starters,the \nprint() statement in Figure1 allocates a StringBu.er and a String at each release. Even\u00adtually .lling \nup the heap, triggeringgarbage collection and blocking the .lter for hundreds of milliseconds. Another \nis\u00adsue is the default Java scheduler may decide to preempt a .lter at any point of time in favor of a \nplain Java thread. STREAMFLEX ensures low-latencyby executing .lters in a partition of the JVM s memory \nwhich is outside of the con\u00adtrolofthegarbage collector. This allowstheSTREAMFLEX scheduler to safely \npreempt any Java thread, including the garbage collector. Activities can thus run without fear of being \nblockedby thegarbage collector. Another danger is potential for priority inversion.To prevent synchronization \nhazards, such as an activity blocking on a lock held by a Java thread which in turn can block for the \nGC, .lters are isolated from the Java heap. Non-blocking synchronization in the form of software transactional \nmemory is used when Java threads need to communicate with .lters. With these protectionsin place, integratingaSTREAM-FLEX \n.lter graph into a Java application is simply a matter of having plain Java code invoke public methods \nof a .lter. Memory Model. We mentioned that in STREAMFLEX .l\u00adters are protected from interference from \nthegarbage collec\u00adtor. But then, how does STREAMFLEX deal with the alloca\u00adtions occurring in Figure 1(c)? \nThe answer is that we use a region-based allocation scheme. Each time an activity is re\u00adleased, a new \nmemory region is created and, by default, all newly allocated objects are created in that region. When \nthe activity terminates, at the return of the corresponding work() method, all objects allocated in the \nregion are reclaimed at the same time. Region-based allocation allows programmers to use standard Java \nprogramming idioms without having to incur disruptive pauses. In termsof memory management,aSTREAMFLEXgraph \nis thus composed of three kinds of objects: stable objects, transient objects and capsules. Stable objects \ninclude the .l\u00adter instance itself and its internal state, their lifetime is equal tothatofthe .lter.Transientobjectsliveaslongastheactiv\u00adity. \nFinally, capsules are data objects used in messages and are managedby theSTREAMFLEXruntime engine. Specify- \n Figure 3. Valid cross-regions references. Arrows indicate allowed reference patterns between objects \nallocated in dif\u00adferent regions. ing whether an object is stable, transient or capsule is done at theclasslevel.Bydefault,data \nallocatedbyaSTREAMFLEX thread is transient. Only objects of classes marked stable or thatextend Filter \nwill persist between invocations. Stable ob\u00adjects must be managed carefully by the programmer as the \nsizeofthe stable areais.xedandthe areaisnotgarbagecol\u00adlected. Figure3gives an abstract representationof \nmemory. In order to preserve type safety, theSTREAMFLEXcompiler enforce constraints on patterns of references \nacross the dif\u00adferent partitions. Arrowsin Figure3indicates allowed direc\u00adtionality for references. STREAMFLEX \nallows allocation and transfer of user\u00adde.ned data types along channels. This should be contrasted to \nsystems that limit communication to primitives and ar\u00adrays. The advantage of using primitives is that \none does not need to worry about memory management or aliasing for data transferred between .lters, on \nthe other hand if, for ex\u00adample, one wants to communicate complex numbers, they have to be sent as a \npair of .oats over a .oat channel. While this may be acceptable in the case of simpledata, encoding richer \ndata structuresislikelytobe cumbersome.InS TR-EAMFLEX,a channel can carry objects, thus Figure4shows \na natural way to express channels of complex numbers. Primitive types only: .oat realv = in.take(); .oat \nimage = in.take(); STREAMFLEX Complex c = in.take(); Figure 4. Communicating complex numbers as pairs \nof primitive numbers over a channel. In STREAMFLEX com\u00adplex numbers can be communicated as objects. As \nsuggested above, there are good reasons for restricting the data types transferred on a channel. As soon \nas one adds objects to the computational model, it is necessary to provide support for their automatic \nmemory management. The problemis compoundedifgarbage collection pauses are tobeavoided. Considerforexamplethe \n.lter Err in Figure 5. This .lters retainsa referencetoavalue thatwastaken from a channel and puts the \nsame value down its output channel. When is it safe to reclaim the instance of Complex? There is noobviousway, \nshortofgarbage collection,of ensuring class Err extends Filter { Complex retain; void work() { out.put( \nretain = in.take() ); } } Figure 5. When is it safe to reclaim the retain?. that the virtual machine \nwill not run out of memory. The STREAMFLEXapproachistousea statictype disciplineand rule out this program \nas ill-typed. Example: Processing biological data. To conclude, we considera slightly more sophisticatedexample \ninspiredbya stochastic algorithm for protein backbone assignment [33]. The class MutatingFilter of Figure \n6 processes a stream of Strand objects which are capsules representing a se\u00adquence of protein pseudoresidues \nand a score summarizing the quality ofan assignment[33].The .ltertakesa Strand object, performsa random \nmutation andevaluates the result\u00ading score. If this score indicates an improvement, the data is copied \nto the Strand object and the Strand is sent on to the next .lter. The example illustrates the use of \ncapsules. Here a Strand extends the Capsule class. Capsule can contain ar\u00adrays and primitive .elds. What \nis most noteworthyabout this code is that it looks exactly like normal Java. class Strand extends Capsule \n{ .nal double[] residues; double score; } class MutatingFilter extends Filter { Channel<Strand> in, out; \nvoid work() { Strand strand = in.take(); double[] rds, mutated; rds = strand.residues; mutated = new \ndouble[rds.length]; mutate(rds, mutated); double score = compute(mutated); if (score < strand.score) \n{ arraycopy(mutated,rds); strand.score = score; } out.put(strand); }} Figure 6. An example of a .lter \nusing capsules to commu\u00adnicate with other .lters. 3. The Programming Model This sectiongivesa more detailed \npresentationoftheSTR-EAMFLEX programming model. 3.1 Graphs AStreamFlexGraph isthe abstractionofastream \nprocessing application. This class must be subclassed, and the program\u00admer must implement at least one \nconstructor and possibly rede.ne the start() method. The constructor is responsible of creating .ltersand \nconnecting them.Onceagraphisfully constructed, the validate() method must be invoked to check consistency \nof the graph. The checking involves verifying that all channels are connected to .lters with the right \ntypes, that thereissuf.cient spaceavailableforthe stableand tran\u00adsient stores of .lters, and that clocks \nare given periods sup\u00adported by the underlying virtual machine.1 Once validate() returns the graph cannot \nbe changed supporting dynamic .lter graphs is left for future work. The other methods of the class are \nall declared protected and support the re.ective creation of .lters and channels. Re.ection is needed \nbecause the creation of both channels and .lters must be performed in speci.c memory areas under the \ncontrolof theSTREAM-FLEX runtime, it would be unsafe to construct anyof these objects on the heap. public \nabstract class StreamFlexGraph { ... public void start(); public void stop(); protected void validate() \nthrows StreamFlexError; protected Filter makeFilter(Class f); protected Filter makeFilter(Class f, int \nstbSz, int tranSz); protected Clock makeClock(int periodInMicrosecs); protected void connect(Clock src, \nFilter tgt, String tgtField); protected void connect(Filter src, String srcField, Filter tgt, String \ntgtField, int size); } Figure 7. Graph interface (extract). 3.2 Filters The abstract class Filter, shown \nin Figure 8 provides the basic functionality for stream processing.A .lter s activity is speci.ed by \nproviding an implementation of the work() method ofthe abstract class.A.lter can, optionally, imple\u00adment \nthe boolean trigger() method that indicates whether an activity is schedulable or not. public abstract \nclass Filter { ... public abstact void work(); protected boolean trigger(); } Figure 8. Filter interface(extract). \nThe previous section introduced the notion of partitioned memory for Filters. Objects allocated by a \n.lter can have either a lifetime that is bound to the lifetime of the entire 1Most operating systems \ncan go down to the millisecond. In our experi\u00adments,weuseareleaseofLinuxthathasbeenpatchedtoprovide microsec\u00adond \nperiods. .lter graph or to the activation of the work() method. Oper\u00adationally, this is achieved by associating \nthe .lter with two memoryregions,shown pictoriallyinFigure9,the stable re\u00adgion is used for allocation \nof persistent data while the tran\u00adsient regionisusedasa scratchpad.The .lter instance itself is allocated \nin stable memory to ensure that it is also pro\u00adtected from thegarbage collector. The default allocation \ncontext while executing a .lter s work() method, or anyof its public methods, is always tran\u00adsient memory. \nThus, by default any occurrence of new will result in allocation of a transient object. In order to allocate \nan object in stable memory, the class of that object must im\u00adplement the Stable marker interface. The \nassumption behind this design choice is that allocation of persistent state is the exception and that \nthere is only a small number of object types that will be used in stable memory. Figure 9. Memory modelofaStreamFlexGraph \napplication having two .lters. When the work() method returns, all transient data allo\u00adcated during its \nexecution is reclaimed in constant time.2 In the current version of the STREAMFLEX, the sizes of both \nmemory regions are .xed and are chosen at .lter instan\u00adtiation. Supporting dynamically sizedregionsis \npossiblebut has not been implemented. Exceptions that escape from the work() method must be treated specially \nas the exception object and stack trace in\u00adformation are allocatedin transient memory.Toavoid creat\u00ading \na dangling pointer, the exception will be discarded and replacedbya BoundaryError object which will terminate \nthe executionof theSTREAMFLEX graph. The implementation of .lters is subject to a number of constraints \nthat aim to prevent dangling pointer errors. These are detailed in Section 4. 2Finalizers are not supported \nfor objects allocated in transient memory, al\u00adlowing them would violate the constant time deallocation \nguarantee. Con\u00adsidering the isolated nature of .lters, they are of dubious value anyway. 3.3 Channels \nAChannel isa.xed-sizebuffer. Figure10givesanoverview of the channel interface which is straightforward. \nEach chan\u00adnel has methods for querying the number of available da\u00adtums, for adding a value at the end, \ntaking a value from the front of the buffer, and .nally for returning a value to the front. Channels \nare strongly typed. STREAMFLEX supports generic channels, time channels as well as primitive chan\u00adnels \nfor all of Java sprimitivetypes(IntChannel,FloatChan\u00adnel, etc.). public class Channel<T extends Capsule> \n{ ... public int size(); public put(T val); public T take(); public void untake(T val); } public class \nTimeChannel { public double getTime(); public int missedDeadlines(); } Figure 10. Channel interface(extract). \nOperations performed on the set of channels attached to a .lter are atomic. From the point the work() \nmethod is invoked to the point where it returns, all of the put/take operations are buffered, it is only \nafter work() returns that all channels are updated. The current version of STREAMFLEX does not support \ngrowable channels and, in case of over.ow, silently drops capsules. Other policies are being considered \nbut have not been implemented.Variable sized channel, forexample, can be added if users are willing to \ntake the chance that resize operation triggersagarbage collection(an unlikelybut pos\u00adsible outcome). \nTiming channels are a special kind of primitive channel. Their size is .xed to 1 and the replacement \npolicy is to retain the oldest value and keep a counter for over.ows. The only components allowed to \nwrite to a time channel are clocks. Filters have access to only two methods: getTime() which returns \nthe .rst unread clock tick in microseconds and missedDeadlines() which returns the number of clock ticks \nthat have been missed. All time channels of a .lter are emptied when the work() method returns and their \nover.ow counters are reset to zero. 3.4 Triggers Atriggerisa predicateonthe stateoftheinput channelsofa \n.lter.A.lterissaidtobe schedulableifitstriggerevaluates to true. The default trigger supported by all \nSTREAMFLEX .lter is to yield true if data is present on anyof the .lter s input channels. More sophisticated \ntrigger expressions are planned but have not yet been incorporated in the system. A simple one is to \nsupport rate speci.cations as proposed by [32]. Rate speci.cations let users de.ne the minimal accept \nrate for channels. The trigger will only yield true if suf.cient inputisavailable.Auser-de.ned trigger() \nmethod which evaluates an arbitrary predicate over the channels of the .lter could be used to ensure, \nfor example, the presence of data on all channels. 3.5 Clocks Toallowfor periodic .lters,STREAMFLEXprovides \nClocks. Clocks are special kind of .lters which can not be subclassed or extended. Theyhave a single \noutput TimeChannel. Like all other .lters, theyare created re.ectively, using the make-Clock() method, \nand con.gured with a period in microsec\u00adonds. During execution, a clock outputs a tick on its time channel \nat the speci.ed period. In the current STREAMFLEX prototype, a periodic real\u00adtime thread is associated \nwith each clock. At each period the following operations are performed: a new time is written to thetimechannel,thetriggerofthe \nattached.lterisevaluated and if it yields true the .lter s work() method is evaluated. The evaluation \nstrategy is eager in the sense that, when a work() method returns the same thread will try to evaluate \nall of the subsequent .lters.To ensure timeliness, the Clock instance should be con.gured with a period \nthat is larger than the maximum processing time of the sequence of .lters that will be evaluated at each \nrelease. 3.6 Capsules Subclassesof thebuilt-inclass Capsule are used as messages on channels. Capsules \nare designed with one key require\u00adment: allow for zero-copy communication in a linear .lter pipeline. \nThis seemingly simple requirement turns out to be challenging as it is necessary to answer the twin questions \nof where to allocate capsules, and when to deallocate them. Capsules cannotbe allocatedinthe transient \nmemoryofa.l\u00adterastheywouldbe deallocatedas soonasthe .lter s work() method returns.Theyshouldnotbe allocatedina \n.lter ssta\u00adble memory as that area would quickly run out of space. In\u00adstead, we allocate them froma pool \nmanagedby theSTR-EAMFLEX runtime.Acapsuleis deallocatedifitwastaken froma channeland,bythetime work() \nreturns, not been put back onto another channel. Capsules are user-de.ned classes that must abide by \ncertain structural constraints. They are restricted to having .elds of primitive types or of primitive \narrays types. They are constructed re.ectively by the STREAMFLEX runtime, as theymust be allocated in \na special memory area. While we strive for zero-copy communication, there is one case where copying capsules \nis necessary, this is when a .lter needs to put the same capsule on multiple output chan\u00adnels. The copies \nare done when modi.cations to channels are published after the work() method returns.  3.7 Borrowed \nArguments and Atomic Methods Interacting with Java presents two main challenges. Firstly, it is necessary \nto ensure that the interaction does not cause the .lters to block for the GC. Secondly, we would like \nto avoid having to copydata transferred from the Java world. We achieve these two goals with features \ninherited from the underlying Re.exes system [30]: borrowed arguments and atomic methods. STREAMFLEXprevents \nblocking operationsbyreplacing lock-based synchronization with a simple form of transac\u00adtional memory \ncalled preemptible atomic regions in [24]. Anymethod on a .lter that is invoked from plain Java code \nmust be annotated @atomic.For such methods, the STR-EAMFLEX runtime ensures that their execution is logically \natomic,but with the possibility of preemption if the .lter is released. In which case the Java call is \naborted and transpar\u00adently re-executed later. The @borrow annotation is used to declare a reference to \na heap-allocated object that can be read by a .lter with the guarantee that it is in consistent state \nand that the .lter will not retain a reference to it. The guarantee is enforced by the STREAMFLEX type \nsystem discussed in Section 4.3 Figure 11 shows a .lter with an atomic method that takes a borrowed array. \nThis method can be safely invoked from Java code with a heap-allocated argument. public class Writeable \nextends Filter { ... @atomic public int write(@borrow short[] b) { for (int i=0,j=0; i<b.length; i++) \nif (b[i]>64) data[j++]=b[i]; }} Figure 11. The method write() is invokable from Java. The method is declared \n@atomic and the parameter b is borrowed as it references a heap allocated object. 4. Type System Wepresentatype \nsystem that ensures memory safetybypre\u00adventingdangling pointers.TheSTREAMFLEXtypesystemis avariantofourworkonScopeJ[34]and \nRe.exes[30].We givea succinct presentationof the type system. TheSTR-EAMFLEX type system is an implicit \nownership type sys\u00adtem. As in other ownership type systems [14] there is a no\u00adtion of a dominator that \nencapsulates access to a subgraph of objects in our case every Filter instance encapsulates all objects \nallocated within its stable and transient memory regions. The type system ensures that references to \nobjects 3The @borrow is retained for backwards compatibility with [30], theSTR-EAMFLEX type system treats \nall reference arguments as implicitly bor\u00adrowed. owned by a .lter are never accessed from outside and \npre\u00advents dangling pointers causedbyreferences to transient ob\u00adjects from stable ones. This remainder \nof this section reviews the constraints imposed on the implementation of .lters. 4.1 Partially Closed-World \nAssumption A requirement for type-checking a .lter is that all classes that willbe used withinthe .lter \nmustbeavailable.We re\u00adfer to this as a partially closed-world assumption, as there are no constraints \non code outside of a .lter. Classes used within a .lter fall in one of three categories: stable, tran\u00adsient \nand capsule classes. The reachable class set (RCS) de\u00adnotes the union of these sets of classes. The .rst \ntask of the checker is to compute the RCS. This done by a straightfor\u00adward reachabilityanalysis starting \nwith subclasses of Filter and Capsule. Rapid type analysis [8] is used to resolve the targets of method \ncalls. The following informal rules de.ne the RCS and are implemented in a straightforward way in the \nchecker. D1: Any subclass of Filter or Capsule is in RCS. D D2: If class C is in RCS, all parents of \nC are also in RCS. D D3: Given the instance creation expression new C(...) in class D, if D is in RCS \nthen C is in RCS. D D4: Given an invocation of a static method C.m() in class D, if D is in RCS then \nC is in RCS. D The type checker validates all classes in the RCS. Taken together rule D1-3 ensure that \nanyobject that can be created whileexecutingamethodofa.lter arein RCS. Furthermore, the de.ning class \nof anystatic method that can be invoked will be added to RCS. Native methods are currently allowed on \na case by case basis and are validated by hand. Observe that the above rules do not prevent a class in \nthe RCSfromhaving subclasses which are notin RCS except for .lters and capsules. Basically, it means \nthat the closed\u00adworld assumption does not preclude the modular evolution of software through subclassing \nwhich is standard strategy used to evolve Java programs. While these rules are an ac\u00adcurate description \nof the current implementation, they are stricter than necessary.A more precise analysiswould only consider \nreachable methods, while our analyzers checks all methodsofaclass. Similarly,for static methodsitisnot \nnec\u00adessary to add the de.ning class to the RCS, one only need to verify the methods reachable from static \nmethod being in\u00advoked. While the imprecision has not affected the applica\u00adtions we have considered, we \nplan a more precise analysis, along the lines of [6], for future versions of the system. 4.2 Implicit \nOwnership Thekeypropertytobe enforcedbythetypesystemisthat all objects allocated within a .lter must \nbe properly encap\u00adsulated. No object allocated outside of a .lter may refer to a stable or transient \nobject of that .lter. Conversely, no stable or transient object may refer to an object allocated outside \nof the .lter. R1: The type of arguments to public and protected methods of any subclass of Filter can \nbe primitive types as well as arrays of primitive types. Returns types of these methods are limited to \nprimitive types. The type of public and protected .elds of any subclass of Filter are limited to primitive \ntypes. D R1 ensures that methods and .elds visible to clients of a .lterdo not leak references across \nthe .lter boundary.Tobe safe the rule requires encapsulation in both direction. Arrays are a special \ncase described in Section 4.4. Within a .lter is it necessary to prevent a stable object from retaining \na reference to a transient one, as this would leadtoadanglingpointer.This enforcedbymakingitillegal fora \nstable objecttoeverhavea referenceoftransient type, and similarly for static variables (see Section 4.3). \nThis is done at the class granularity. If a class is declared stable, then it can only refer to other \nstable classes. Again arrays are a special case discussed in Section 4.4. Since the type system tracks \nclasses, rather than objects aswouldbedonebyamorepreciseescape analysis,wemust ensurethatthe subtyping \nrelation cannotbeusedbytransient types to masquerade as stable types. D5makes it so that any subtype \nof stable type is stable. D5: Any class in RCS (transitively) implementing the marker interface Stable \nis stable. The Filter class is stable. D R2: An instance .eld occurring either in a stable class or in \na parent of a stable class in RCS must be of either a primitive type or a stable type. D 4.3 Static \nReference Isolation Enforcing encapsulation requires that communication through static variables be controlled. \nWithout any limi\u00adtations, static variables could be used to share references across encapsulation boundaries \nand open up opportunities for memory errors. Adrastic solution would be to prevent code in RCS from reading \nor writing static reference variables. Clearly this is safe as the only static variables that a .lter \nis allowed to use are ones with primitive types and these can not cause dangling pointer errors. The \nquestion is of course how re\u00adstrictive is this rule? While, for newly written code, it may be straightforward, \nif a little awkward, to replace static vari\u00adables with context objects threaded through constructors, \nthe same can not be said for library classes. It would be dif.cult to refactor them and if one did, they \nwould loose backwards compatibility.We should thus strive to be as permissive as possible to increase \nopportunities for code reuse. The key observation here is that errors can only occur if it is possible \ntostoreanobject allocatedwithina.lterinastatic.eldorin a .eld of an object reachable from a static .eld. \nThis obser\u00advation motivates extending the type system with the notion of reference-immutable types. These \nare types that are tran\u00adsitively immutable in their reference .elds. D6: A class C is reference-immutable \nif all non-primitive .elds in the class and parent classes are declared .nal and are of reference-immutable \ntypes. D7: AtypeT is reference-immutable if it is primitive, an ar\u00adray of reference-immutable types, \nor a reference-immutable class. D The analysis infers which types must be immutable based on the use \nof static variables. R3: Let C be a class in RCS, an expression reading a static .eld of reference type \nT is valid only if the .eld is declared .nal and T is reference-immutable. D 4.4 Encapsulating Arrays \nThe rules as stated until now allow programs to use prim\u00aditive arrays if they are static .nal .elds as \nthey are then reference-immutable. Furthermore, anykind of array can be safely allocated in transient \nmemory. But it is not possible to allocate an array in stable memory or use an array within a capsule.We \nproposeanextensiontothetypesystemthatis just large enough to allow some common stream processing coding \npatterns. R4: An instance .eld of a uni-dimensional array type is allowed in a stable class if it is \ndeclared private .nal and is assignedtoafreshly allocatedarrayinall constructors. D This ensures that \narray .elds of stable objects cannot refer\u00adence either transient objects nor borrowed objects.  4.5 \nCapsules Acapsuleisanobjectthatis manipulatedina linearfashion. At anygiven time the type system enforce \nthat both of the following holds: (1) there is at most a single reference to the capsule from data channels, \nand (2) there are no references to a capsule from stable memory. These invariants permit zero-copy common \nuses of capsules. R5: The type of .eld of a subclass of Capsule may be either primitive or an array of \nprimitive. D The above rule ensures that capsules are reference-immu\u00adtable, while the next rule ensures \nthat capsules can only be instantiatedby theS TREAMFLEX runtime. R6: A subclass of Capsule must have \nonly a single con\u00adstructor. It must be private and without parameters. D The motivation for R6is that \nSTREAMFLEX must man\u00adage all allocation and reclamation of capsules. Otherwise, it would be possible to \nallocate a capsule in transient mem\u00adory and pusha transient object an output channel,eventually leading \nto dangling pointer error. R7: Subclasses of Capsule cannot be stable classes. D From the point of view \nof stable and transient classes, a capsule is just like any other transient class. Thus, we inherit the \nguarantee that when work() returns there will be no reference to the capsule in the state of a .lter. \n5. Intrusion Detection System Example Toevaluatethepowerand applicabilityofSTREAMFLEXon real-world applications, \nwe have implemented a real-time Intrusion Detection System (IDS), inspiredby[28], which analyzes a stream \nof raw network packets and detects intru\u00adsions by pattern matching. Figure 12 shows the declaration of \nthe .lter graph class Intrusion which instantiates and con\u00adnects the six .lters that implement the intrusion \ndetection system. Figure 14 gives a graphical representation of the .l\u00adter graph. The capsules being \npassed around the system repre\u00adsent different network packets: Ethernet, IP, TCP and UDP. Object-oriented \ntechniques are useful in the implementation as we model nested structure of protocol headers by inheri\u00adtance.For \ninstance, the IP capsule(IP Hdr)is a subclass of the Ethernet capsule(Ether Hdr)withextra .eldsto storeIP \nprotocol information. Figure 15 shows PacketReader. This .lter creates cap\u00adsules representing network \npackets from a raw stream of bytes.For ourexperiments we simulate the network with the Synthesizer class \n(see start() in Figure 12). The synthesizer runs as a plain Java thread, and feeds the reader with a \nraw stream of bytes to be analyzed. Communication between the synthesizer and the PacketReader is done \nby calling Pack\u00adetReader.write(). This methodtakesa referencetoabuffer of data allocated in plain Java \nand parses it to create packets. write() is annotated @atomic to ensure thata .lter can safely preempt \nthe synthesizer at anytime. The PacketReader buffers data in its stable memory with the Bu.er class. \nBu.er implements the Stable interface and contains an array of bytes.To satisfy the type system, this \narray had to be declared .nal and is freshly allocated in the constructor. The reader uses the readPacket() \nto initialize capsules from the data stored in the buffer. startRead(), com\u00admitRead(), and abortRead() \nare used to ensure that only whole packets are read from the buffer. They do not need synchronization \nsince (i) potential higher priority .lters have no way to access the buffer (thanks to the isolation), \nand public class Intrusion extends StreamFlexGraph {private Clock clock; private PacketReader read; private \nFilter trust, vsip, tear, join, dump; public Intrusion(int period) { clock = makeClock(period); read \n= (PacketReader) makeFilter(PacketReader.class); trust = makeFilter(TrustFilter.class); vsip = makeFilter(VSIPFragments.class); \ntear = makeFilter(TearDrop.class); join = makeFilter(Joiner.class); dump = makeFilter(PacketDumper.class); \nconnect(clock, read); connect(read, trust, 10); connect(trust, vsip, 10); connect(trust, ok , join, 10); \n... validate(); } public void start() { new Synthetizer(read).start(); super.start(); }} Figure 12. \nStreamFlex graph of the Intrusion Detection Sys\u00adtem Example. public class TearDrop extends Filter {private \nChannel<Ether Hdr> in, out, fail; private TearMatcher pm = new TearMatcher(); public void work() { Ether \nHdr p = in.take(); if (p instanceof TCP Hdr) { TCP Hdr t = (TCP Hdr) p; if (pm.step(t)) { p..ltered \n= true; p..ltered by TearDrop = true; fail.put(p); return; } } out.put(p); }}  public class PacketReader \nextends Filter {private Channel<Ether Hdr> out; private Bu.er bu.er = new Bu.er(16384); public int underruns; \npublic void work() {TCP Hdr p; p = (TCP Hdr) makeCapsule(TCP Hdr.class); if (readPacket(p) < 0) underruns++; \nelse out.put(p); } @atomic public void write(byte[] b) { bu.er.write(b); } private int readPacket(TCP \nHdr p) { try { bu.er.startRead(); for (int i=0; i<Ether Hdr.ETH LEN; i++) p.e dst[i] = bu.er.read 8(); \n... return bu.er.commitRead();  } catch (UnderrunEx e) { bu.er.abortRead(); ... }}} public class Bu.er \nimplements Stable {private .nal byte[] data; private int pos, lastpos; public Bu.er(int cap) { data = \nnew byte[cap]; } public int write(byte[] b) { ... } public void startRead() { lastpos = pos; }public \nint commitRead() { return pos-lastpos; }public void abortRead() { pos = lastpos; } public int read 32 \nthrows UnderrunEx { ... } public short read 16 throws UnderrunEx { ... } public byte read 8 throws UnderrunEx \n{ ... }  } Figure 13. TearDrop, a .lter of IDS. Figure 15. PacketReader and Bu.er implementation. (ii) \nplain Java threads, that can access the buffer trough write(), cannot preempt the .lter execution.4 The \npackets .rst go to the TrustFilter which looks for packets that match a trusted pattern, these will not \nrequire further analysis. Other packets are forwarded to VSIPFrag\u00adment. This .lter detects IP fragments \nthat are smaller than TCP headers. These are dangerous as they can be used to bypass packet-.ltering \n.rewalls. The TearDrop .lter of Fig\u00adure 13 recognizes attacks that involves IP packets that over\u00adlap. \nThe three .lters, TrustFilter, VSIPFragment, and TearDrop,havea similar structure: an input channel(in)for \nincoming packets to analyse and two output channels, one for packets caughtby the .lters(ok or fail), \nthe other one for uncaught packets(out). These .lters also mark caught packets with meta-data that can \nbe used in further treatment, logging or statistics. The TearDrop .lter implementations rely on an automaton(TearMatcher \nin Figure 13) stored in stable space to recognize patterns on packet sequences that correspond to attacks. \nA special built-in .lter, Joiner, is used to transform a stream of data from multiple input .lters to \na single stream of data. The last Filter, PacketDumper,gather statistics of the whole intrusion detection \nprocess thanks to the meta-data written on packed by the previous .lters. 6. Implementation We have implemented \nSTREAMFLEX on top of Ovm, a freely available Java virtual machine with an optimizing ahead-of-time compiler \nand support for real-time computing on uniprocessor embedded devices. The Ovm virtual machine comes with \na priority-preemp\u00adtive scheduler. The complete priority range is from 1-42, where the subrange 12-39 \nrepresents real-time priorities and the remaining are used for Java threads. The Clock class is implemented \nas a thread with a real-time priority. The thread is started as a result of an invocation of StreamFlex\u00adGraph.start(). \nThis causes all .lter threads to be scheduled at a start time that may be the current time, or a user \nde.ned future time. 6.1 Memory Regions For each .lter, the underlying implementation allocates a .xed \nsize continuous memory region for stable storage and another region for its transient data. The size \nof each of the aboveis set programmaticallyin the API.A.lter and allof its implementation speci.c data \nstructures are allocated in the stable area. Theseregionshavethekeypropertythatthey are notgarbage collected.In \nOvm, each thread hasa default allocation area. The VM exposes low-level functionality for setting allocation \nareas. The method setCurrentArea() al\u00adlows the implementation to change the allocation area for 4Weassume \nthat .lter runat higher priorities than plainJavathreadsaswell as a priority-preemptive scheduling policy. \nthe current thread. Regions are reference counted, each call to setCurrentArea() increase the count of \nactive threads by one. reclaimArea() decrease the counterbyone for that area, if the counter is zero \nall objects in the area are reclaimed. reclaimAreaAndWait() is a blocking version of the above. Essentially, \nthey reset the allocation pointer to the start of the area. The VM statically identi.es stable classes, \nand whenever an instance of a stable class is created by a thread running in a .lter, the stable region \nis used instead of the transient region to allocate the object. The allocation of arrays encap\u00adsulated \nwithinthe constructorofa stable classisrewrittento add code that checks if the thread is running within \na .lter and, if yes, allocates the array in stable memory. The virtual machine also supports allocation \npolicies for meta-data. In particular, we rely on a policyfor lock in.ation that ensures that a lock \nis always allocated in the same area as the object with which it is associated, regardless of the current \nalloca\u00adtion area. Capsules are managed by the implementation. The only way for a capsule to become garbage \nis if it is created or removed from an input channel and not put back on an output channel before the \nend of the .lter s work() method. Wethuskeeptrackofallcapsules createdandusedduringan invocation of work() \nand reclaim those that are not published on output channels. Capsules are managed internally with object \npools allocated in dedicated regions. When an exception is thrown within a .lter, the object is createdwith \nnormalJavasemantics.Bydefaulttheexception object and its stack trace are created in transient memory. \nIf the exception propagates out of the work() method, the stack trace is printed and the STREAMFLEX computation \nis terminated. 6.2 Atomicity The implementation avoids blocking synchronization by supplementingJava \nmonitors witha simple transactionalfa\u00adcilitybuiltontopofthe preemptible atomicregionsof[24]. We implement \nchannels using the @atomic annotation for methods that would otherwise be synchronized. The seman\u00adtics \nof @atomic is simple: the method will execute atom\u00adically, unless another higher-priority thread preempts \nthe current thread in which case the method is aborted. Since threads are scheduled with a priority preemptive \nscheduler, weknowthatathreadcanonlybe preemptedbyahigherpri\u00adority thread. If an atomic method is aborted, \nall changes per\u00adformed within the atomic method are undone and the method will automatically be re-executed \nwhen the higher priority thread yields. For a schedulable task set, it is possible to prove the absence \nof livelocks [24]. For each write within an atomic the VM records the original value and address of .eld \nin a log. An abort boils down to replaying the log in reverse order. Enters and commits are constant \ntime. 6.3 Borrowing Borrowed arguments should not move or cause a garbage collection.Ageneralwaytodo \nthiswouldbeto identifyall borrowed objects, in.ate their locks, and pin the objects to ensure that thegarbage \ncollector does not try to move them. As our prototype runs on uniprocessor VMs, careful assign\u00adment of \npriorities together with the use of @atomic methods ensures that a .lter can never observe an inconsistent \nbor\u00adrowed object. 6.4 Type Checking The STREAMFLEX type checker is implemented as a plug\u00adgable type \nsystem. The checker is approximately 300 lines of code integrated as an extra pass in the javac 1.5 com\u00adpiler. \nThe type systemde.nesa strict subsetof theJava lan\u00adguage [20] without requiring any changes to Java syntax. \nThis approach is convenient as the rules arefairly compact and that error messages are returned by the \nJava compiler no extra tool is required and message are returned with line numbersina format thatisfamiliarto \nprogrammers.  6.5 Static analysis The use of re.ection and native methods in STREAMFLEX code is limited \nto small set of operations. This together with the partially closed-world assumption (see Section 4.1) \nenforcedbythetype system permitsthe compilerto perform aggressive devirtualization and inlining. 7. Evaluation \nWe conducted a number of experiments to evaluate to which extent STREAMFLEX can be used to achieve high\u00adthroughput \nwhile remaining predictable, both important properties for streaming applications.We used the Intrusion \nDetection System of Section 5 as a larger, more realistic, benchmark. We evaluated STREAMFLEX on two \nmetrics: throughput and precision of inter-arrival time for periodically triggered STREAMFLEX .lters.For \nthe performance results, we con\u00adsidered two benchmark stream applications, and compared them head-to-head \nwith baseline numbers from similar tests we conducted using plain Java. The baseline numbers are made \nup of test executions in Java using our virtual machine infrastructure as well as a standard Java platform \nas refer\u00adence. 7.1 Base Performance To evaluate the performance of STREAMFLEX, we per\u00adformed various \nmeasurements of our implementation on the Ovm Java virtual machine.We considered here two bench\u00admark \napplications developed at MIT for the StreamIt project, which we modi.ed to make use of the STREAMFLEX \nAPI. The benchmark applications used were(1)a beam-form cal\u00adculation on a set of inputs, and (2) a .lter \nbank for multirate signal processing.5 Figure 16 shows a graphical represen\u00adtation of the STREAMFLEX \nimplementation of the Beam-Former benchmark. It shows the structure and number of .l\u00adters as well as \ntheir interconnections. Both benchmark applications were con.gured to exe\u00adcute in a uniprocessor, single-threaded \nmode, and thus did not take advantage of the parallelization possibilities of the stream programming \nparadigm. All performance exper\u00adiments were performed on a 3.8Ghz Pentium 4, with 4GB of physical memory. \nThe operating system used was Linux (vanillakernel,version 2.6.15-27-server).For the Ovm vir\u00adtual machine, \nwe con.gured it with a heap size of 512MB. For the sake of comparison, we performed baseline mea\u00adsurements \non the automatically generated Java variants of the StreamIt benchmark applications.TheJavavariants were \nbenchmarked both on the Ovm virtual machine as will as the Java HotSpot virtual machine, version 1.5.0 \n10-b03, in mixed mode. Reported values are for the third run of the benchmark. STREAMFLEX Java Java Ovm \nOvm HotSpot BeamFormer 314 ms 1285 ms 1282 ms FilterBank 1260 ms 4350 ms 3213 ms Figure 17. Performance \nmeasurements showing actual run\u00adtime in milliseconds of performing 10,000 iterations of the benchmark \napplications using respectively S TREAMFLEX andtheJavavariantsofthe StreamItcodeontheOvm virtual machine \nand on the Java HotSpot virtual machine. 5A description as well as the actual code for both the utilized \nStreamIt benchmark applications, SerializedBeamFormer.str and Filter-BankNew.str are available for download \nat cag.csail.mit.edu/streamit.  SerializedBeamFormer benchmark. The x-axes depict iterations of the \n.lter whereas the y-axis shows the deadline misses in \u00b5s. As depictedin Figure17,STREAMFLEXperforms signif\u00adicantly \nbetterthantheJavavariantexecutedonOvm. Specif\u00adically, the performance improvement amounts toafactor 3.5 \nto 4. It is interesting to compare Ovm and HotSpot. Look\u00ading at the results for the Java code, we see \nthat HotSpot is somewhatfaster (25%) than Ovm for FilterBank. The slow\u00addown canbein partexplainedby thefact \nthat HotSpotisa more mature infrastructure and also because of known inef\u00ad.ciencyin Ovm s treatment of \n.oating point operations. It is interestingto observe thatSTREAMFLEX isafactor 2.5\u00ad4timesfasterthan theJava \ncode running on HotSpot. This underlines that the performancegains are not causedby the virtual machine \nitself.  7.2 Predictability Toevaluate predictability,we measured the inter-arrival time andthe numberof \ndeadline missesforaSTREAMFLEX.lter triggered periodically.Amissed deadline occurs forthe i th .ring of \na .lter with a period p if the actual completion time, ai,comes after itsexpected completion time,Ei,where \nEi = p(l(ai-1/p)l + 1). Weconsidered theSerializedBeamFormer benchmark ap\u00adplication mentioned above, \nwhich we modi.ed by schedul\u00ading the entry .lter, a void splitter .lter, with a period of 80 \u00b5s instead \nof being executed continuously. Experiments were performed on an AMD Athlon 64 X2 Dual Core pro\u00adcessor \n4400+ with 2GB of physical memory. The operating system usedwas Linux(kernelversion 2.6.17-hrt-dyntick5), \nextended with high resolution timer (HRT) patches [1] con\u00ad.gured withatick periodof1 \u00b5s.Webuilt Ovm with \nsupport for POSIX high resolution timers, and con.gured it with an interrupt rate of 1 \u00b5s. The time-critical \nSTREAMFLEX .l\u00adters were all scheduled to run at a 80 \u00b5s period and were executed over 10,000 periods. \nAs depicted in Figure 18, nearly all interesting observa\u00adtions of the inter-arrival time are centered \naround the 80 \u00b5s period with only a few microseconds of jitter. This is as it should be considering that \nthe average iteration time of the benchmark is to be around 50 \u00b5s, leaving suf.cient time for the underlying \nvirtual machine to prepare and schedule the next period. In addition to the expected peak at 80 \u00b5s, there \nis a number of outliers around 160 \u00b5s. We attribute these perturbations to coincidental measurement noise, \nprobably causedbybuffering or .ushingin the underlying operating system. Figure 19 depicts missed deadlines \nover time for the STREAMFLEX benchmark application. Speci.cally, out of 10,000 periodic executions, we \nobserved 223 missed dead\u00adlines, corresponding to a miss-rate of 2%. The missed dead\u00adlines are primarily \ncentered around a range between 15-20 \u00b5s throughout the iterations. Most likely, these missed dead\u00adlines \nare a consequence of a slight jitter in the inter-arrival time, as depicted in Figure 18. Additionally, \nFigure 19 con\u00adveys a few observations randomly scattered around 30-50 \u00b5s. These deadline misses are directlylinked \nwith the out\u00adlier observations of inter-arrival time around 160 \u00b5s in that, generally speaking, a deadline \nmiss between two consecu\u00adtive periodic executions can cause for the inter-arrival time of the two to \nbe larger than twice the actual period, as de\u00adpicted in Figure 20. Figure20showsthatintheeventofadeadlinemiss(when \nactual completion time, ai-1, lies after the expected com\u00adpletion time, Ei-1)ofa .ring,i - 1,theexpected \ncompletion time, Ei, of the subsequent .ring, i, is set to be the end of the .rst-coming complete period, \ni.e., any time remaining in the current period is skipped. If the start of the subse\u00adquent periodic execution, \ni, is delayed (re.ected in the ac\u00adtual start time, .i, lying after the period start) it can cause the \ninter-arrival time between the two consecutive periodic executions, i - 1 and i, to be larger than twice \nthe period p. 7.3 Intrusion Detection System We performed various measurements of the Intrusion De\u00adtection \nSystem, Section 5, on the Ovm virtual machine. The PacketReader creates capsulesata rateof 12.5kHz(aperiod \nof 80\u00b5s). At this rate, the .lter is able to generate packets in to the attack detection pipeline without \nexperiencing any underruns from the simulator. In other words, at a rate of 12.5KHz the simulator can \nprovide packets at the rate which matches the rate with which the IDS can analyze them. The time used \nto analyze a single network packet (from the cap\u00adsule creation to the end of the Dumper .lter)varies \nfrom4\u00b5s to 10\u00b5s withanaverageof5\u00b5s. One reason for thisvariation is that some packets are identi.ed as \na possible suspects by one of the .lters, and thus require additional processing in the automata.If we \nconsider raw bytes ona periodof0\u00b5s (no idle time), the intrusion detection system implemented using the \nSTREAMFLEX API delivers an analysis rate of 750Mib/s. 7.4 Event Correlation Toevaluate the performanceofaSTREAMFLEX \napplication executed on Ovm with re.ex support compared to a plain Java variant executed on Ovm without \nre.ex support. We implemented a transaction tracking scenario in which a .l\u00adter graph is set up to analyze \na real-time stream containing a constant.owof threedifferentevent types.Withinthisevent .ow, the .lter \ngraph searches for and puts together transac\u00adtion tuples consisting of one of each of the three different \nevent types; all sharing the same transaction number. The plain Java version only differs from the STREAMFLEX \nver\u00adsion by replacing realtime threads by plain Java thread and notexploiting memory area management,but \ninstead allo\u00adcating all objects on the heap. The .lter graph is composed of three .lters: Event-Creator \n.EventMatcher .EventSummarizer, where the former randomly generates a real-time stream of the three event \ntypes, the subsequent .lter analyzes the stream for matching event types, and the .nal .lter maintains \nreal-time statistics of number of found transactions, the latency be\u00adtween the time the individual event \ntimes were found etc. Figure 21 depicts the inter-arrival time between consec\u00adutive executions when executing \nthe application variants scheduledwithaperiodof200 microseconds.BothforS TR-EAMFLEX and the plain Java \nvariant, Ovm can achieve a 200 microsecond period. However, in the plain Java variant, huge deadline \nmisses are observed (2 peaks of 67 millisec\u00adonds) due to thegarbage collection. No deadline misses are \nobserved with theSTREAMFLEX application.  Figure22 depictsthe processing time whenexecutingthe applicationvariants \nwith .lters that .re continuously.As can be seen, the plain Java variant suffer regular delays that cor\u00adrespond \nto GC activations that cost around 67 milliseconds each.Asexpected thereis noGC activations forSTREAM-FLEX. \nNote that, even if we ignore activations that involve GC, theSTREAMFLEX versionis stillfaster than the \nplain Java one. 8. Related Work There are many languages and systems supporting stream processing. The \nfollowing stand out among them, Bore\u00adalis [2], Infopipes [10] and StreamIt [32]. These languages have \na history that can be traced back to Wadge and Ashcroft s Lucid[5]data.ow languageandthe Esterelfam\u00adily \nof synchronous languages [13, 21]. Infopipes [10] come as an extension to a variant of Smalltalk (Squeak) \nand has very rich set of operators. StreamIt [32], although it started as a subset of Java, now comes \nwith its own language and compiler infrastructure that generate both Java and native code and has a number \nof restrictions to ensure ef.cient compilation to native code. STREAMFLEX resembles these projects in \nthat it in\u00adtroduces a set of abstractions, such as .lters, pipes/chan\u00adnels, splitters, and joiners designed \nfor programming stream\u00adbased applications. Using the Java programming language for stream processing, \nand especially when aiming for high\u00adthroughput is not obviously a good idea. Java is a general purpose \nlanguage whereas the above mentioned languages enjoyimplementations and compilers specially tuned for \nef\u00ad.cient execution of streaming applications. A Java virtual machine introduces overheads due to, e.g.,garbage \ncollec\u00adtion and array bound checks, and must support dynamic loading a major drawback for compiler optimizations. \nThe bene.ts of using Java are signi.cant as it has: a large com\u00admunity of programmers, high-quality IDEs \nsuch as Eclipse, and numerous libraries. STREAMFLEXand Infopipes support periodic scheduling of .lters. \nInfopipes, to the best of our knowledge, have to deal withgarbage collectionby the underlying runtime \nsys\u00adtem. Hence, one must be very careful to ensure to limit al\u00adlocation in order not to which might hamper \nresponsiveness and thus predictability. In contrast, STREAMFLEX relies on Re.exes to provide high responsiveness \nand, as demon\u00adstrated earlier, is easily able to operate at periods of 80 \u00b5s. High Responsiveness. Achieving \nsub-millisecond re\u00adsponse time in Java has been the topic for numerous research papers. The Achilles \nheel of Java is its reliance ongarbage collection. In order reach such response time one must cir\u00adcumvent \nthe abrupt interference from thegarbage collector which for a standard Java virtual machine means freezing \nof threadsupto100 milliseconds.We conducteda compar\u00adative study of the Real-time Java Speci.cation (RTSJ) \n[11] region-based memory management API and a state-of-the art real-timegarbage collection algorithm \n[7]. Our conclu\u00adsion [27] is that real-time collectors are not suited for sub\u00admillisecond response timesand \nthatRTSJ scoped memoryis too error-prone for widespread adoption. STREAMFLEX relies ona simpli.edversionof \ntheRTSJ region API to ensure that sub-millisecond deadlines can be met.We depart from theRTSJby our useof \nstatic type sys\u00adtem to ensure memory safety. This has the major advantage of avoiding the brittleness \nof RTSJ applications and also brings performance bene.ts as we do not have to implement run-time checkstoprevent \ndangling pointers.S TREAMFLEX isbuiltontopofOvmanda simple real-time programming model [30] which provides \nreal-time threads, region-based allocation and an extended type system. S TREAMFLEX ex\u00adtends that model \nwith stream programming constructs and adapts the type system to particular needs of stream process\u00ading. \nRelated approaches include Eventrons [29] and Exo\u00adtasks [6]. Eventrons6 are closely related to Re.exes \nin that theyprovide very low latency real-time processing, with pe\u00adriods of down to 50 \u00b5s. Unlike the \napproach presented in this paper,Eventrons usearun-time data-sensitiveprogram anal\u00adysistoverifythelogicofthe \nreal-timepartofan application. This has the advantage of being more precise, at the cost of a heavier \nrun-time and delayed error reporting. Exotasks are closer to STREAMFLEX as theyallow allocation and can \nbe arranged in a graph of communicating real-time processors. One of the main difference is that Exotasks \nuse real-time GC.Foreach.lterinanexotaskgraphthereisone real-time collector. This means that Exotasks \ndo not need to differen\u00adtiate between stable and transient data,but this comes at the price of a higher \nlatency. Ownership types. Ownership types were .rst proposed by Noble, Potter and Vitek in [25] as a \nway to control alias\u00ading in object-oriented systems. Most ownership type sys\u00adtem requirefairlyextensive \nchangestothe codeof applica\u00adtions to add all the annotations needed by the type checker. The STREAMFLEX \ntype system is an extension of the im\u00adplicit ownership type system of [34] which is the latest in a line \nof research that emphasized lightweight type systems for region-based memory [3, 35]. STREAMFLEX ownership \nis implicit because, unlike e.g. [14, 12], no ownership pa\u00adrameters are needed. Instead, ownership is \ndefaulted using straightforward rules. Most other ownership type systems require each class to be equipped \nwith one ore more owner parameter.MuchlikeJava generics,these parametersareex\u00adpected to be erased at \ncompile time. This approach has how\u00adever an important drawback: it requires a complete refactor\u00ading of \nall library classes and does not interact well with raw types. While an implicit ownership type system \nis less ex\u00adpressive, the cost in complexity and the disruption to legacy codearguably outweighsthe bene.tsofthe \naddedexpressive power [34]. Real-time Event Channels. Previous work on event chan\u00adnels,in particulartheFacet[23]event \nchannel,is relatedto ourwork.Facetis an aspect-oriented CORBA event chan\u00adnel written in Java with theRTSJ \nAPI.Facet is highly con\u00ad.gurable and provide different event models. However, it shares the drawbacksgiven \nabove for theRTSJ.In theRTSJ it is very dif.cult to implement a zero-copymessage safely. 6Eventronsareavailableunderthe \nnameXRTsintheIBMWebsphereReal\u00adtime product. The Zen real-time CORBA platform [22], written with the RTSJ, \nis another platform on which one could conceivably implement a stream processor. Unfortunately, its implemen\u00adtation \nstill suffers some performance problems. In our ex\u00adperiments with Zen, we have not been able to achieve \nsub\u00admillisecond message round-trip times. Zero-Copy Message Passing. The Singularity operating system \nsupports a notion of channels with messages allo\u00adcated in a region of restricted inter-process shared \nmem\u00adory [18].The useof language techniquestoavoidcopyingis similar to our approach for capsules. Singularity \nmessages are owned by a single process and are transferred in a lin\u00adearfashion. Ennals et al. presented \na linear type system for programming networkprocessors which ensured that every packet is owned by a \nsingle thread at a time [15]. Logical Execution Time. Programming language based on the logical execution \ntime assumption such as Giotto [19] have garnered much interest in the real-time community lately. Using \nLET, the programmer speci.es with every task invocationthe logicalexecutiontimeofthetask,thatis,the time \nat which the task provides its outputs. If the outputs are ready early, then they are made visible only \nwhen the speci.ed logical execution time expires. This buffering of outputs achieves determinacyin both \ntiming and functional\u00adity. We believe STREAMFLEX could be a good platform to investigate LET in the context \nof Java. Our .lters are already deterministic (due to the isolation invariant), what seems to be missing \nis the scheduling and deadline monitoring com\u00adponent. Exotasks [6] use a scheduling policy based on LET \nto ensure time portability of real-time programs. Considering the similarities between the two models, \nwe believe that it would be possible to have time portable STREAMFLEX graphs. This makes for an interesting \ndirection for future work. 9. Conclusion We presented a programming model, STREAMFLEX, for high-throughput \nstream processing in Java. On the one hand, STREAMFLEX extends the Java virtual machine with trans\u00adactional \nchannels and type-safe region-based allocation. On the other hand, STREAMFLEX restricts Java in that \nit pro\u00advides a stricter typing discipline on the stream components of the code. STREAMFLEX relies on \nthe notion of priority\u00adpreemptive threads that can safely preempt all other Java threads, including the \ngarbage collector. By introducing a STREAMFLEX type system based on an implicit ownership, we showed \nthat using a simple set of type constraints, we are able to provide a statically type-safe region-based \nmem\u00adory model. Our evaluation of STREAMFLEX is encouraging both in termsof performance and predictability.Infact, \nwhen com\u00adparing the benchmark applications using STREAMFLEX to equivalent implementations in Java, STREAMFLEX \nran up to4timesfasterthantheJavaversion.Asfor predictability, our evaluation indicated that we can achieve \n80 \u00b5s response times withonly2%oftheexecutionsfailingto meet their deadlines. In thisworkwehaveonly lookedat \nstatic .lter graphs.In future work we intend to investigate more dynamic commu\u00adnication mechanisms such \nas type-based publish/subscribe systems [16].We will also look at alternative memory man\u00adagement models \nsuch as the hierarchical real-timegarbage collection technique of [26]. Acknowledgments. We thank Filip \nPizlo, Jason Baker and the member of the Purdue Ovm team for their help with Ovm internals. We thank \nRodric Rabbah and Joshua Auerbach for helpful comments on this text. Finally, our work greatly bene.ted \nfrom the availability of the StreamIt benchmarks. Thisworkis supportedinpartbyNSF grants501 1398-1086 \nand 501 1398-1600, an IBMFacultyAward, as well as the EU 6th Framework Programme, project IST-002057. \nReferences [1] http://www.tglx.de/projects/hrtimers/2.6.17/. [2] D. J. Abadi, Y. Ahmad, M. Balazinska, \nU. Cetintemel, M. Cherniack, J.-H. Hwang, W. Lindner, A. S. Maskey, A. Rasin,E. Ryvkina,N.Tatbul,Y. Xing, \nandS. Zdonik. The Design of the Borealis Stream Processing Engine. In Second Biennial Conference on Innovative \nData Systems Research (CIDR 2005), Asilomar, CA, January 2005. [3] C. Andreae, Y. Coady, C. Gibbs, J. \nNoble, J. Vitek, and T. Zhao. ScopedTypes and Aspects for Real-Time Java. In Proceedings of the European \nConference on Object-Oriented Programming (ECOOP), pages 124 147, Nantes, France, July 2006. [4] A. Armbuster, \nJ. Baker, A. Cunei, D. Holmes, C. Flack, F. Pizlo, E. Pla, M. Prochazka, and J.Vitek. A Real-time Java \nvirtual machine with applications in avionics. ACM Transactions in Embedded Computing Systems (TECS),2006. \n[5]E.A. AshcroftandW.W.Wadge. Lucid,a non-procedural language with iteration. Communications of the ACM, \n20(7):519 526, July 1977. [6] J. Auerbach, D. F. Bacon, D. T. Iercan, C. M. Kirsch, V.T. Rajan, H. Roeck, \nand R.Trummer. Java takes .ight: time-portable real-time programming with exotasks. In Proceedings of \nthe Conference on Languages, Compilers, andTools for Embedded Systems(LCTES 07), pages 51 62, 2007. [7] \nD.F. Bacon,P. Chang, andV. Rajan. Areal-timegarbage collector with low overhead and consistent utilization. \nIn Conference Record of theACM Symposium on Principles of Programming Languages, pages 285 298, New Orleans, \nLouisiana, Jan. 2003. [8]D.F. BaconandP.F. Sweeney. Fast static analysisofC++ virtual function calls. \nIn Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOP-SLA), pages 324 \n341, 1996. [9] G. Banavar, M. Kaplan, K. Shaw, R. Strom, D. C. Sturman, and W. Tao. Information .ow based \nevent distribution middleware. In Proceedings of the MiddlewareWorkshop at the International Conference \non Distributed Computing Systems, 1999. [10] A. P. Black, J. Huang, R. Koster, J. Walpole, and C. Pu. \nInfopipes: An abstraction for multimedia streaming. Multi\u00admedia Syst., 8(5):406 419, 2002. [11] G. Bollella, \nJ. Gosling, B. Brosgol,P. Dibble, S. Furr, and M.Turnbull. The Real-Time Speci.cation forJava. Addison-Wesley, \nJune 2000. [12] C. Boyapati, A. Salcianu,W. Beebee, Jr., and M. Rinard. Ownership types for safe region-based \nmemory management in Real-Time Java. In Proceedings of Conference on Pro\u00adgramming Languages Design and \nImplementation (PLDI). ACM Press, 2003. [13] P. Caspi, D. Pilaud, N. Halbwachs, and J. A. Plaice. LUSTRE: \nA declarative language for programming synchronous systems. In Conference Record of the Fourteenth Annual \nACM Symposium on Principles of Programming Languages (POPL),pages 178 188, Munich,West Germany,Jan. 21 \n23, 1987.ACM SIGACT-SIGPLAN,ACM Press. [14] D. G. Clarke, J. M. Potter, and J. Noble. Ownership types \nfor .exible alias protection. In OOPSLA 98 Conference Proceedings, volume 33(10) of ACM SIGPLAN Notices, \npages 48 64.ACM, Oct. 1998. [15] R. Ennals, R. Sharp, and A. Mycroft. Linear types for packet processing. \nIn Proceedings of the 13th European Symposium on Programming (ESOP), pages 204 218. Springer, 2004. [16] \nP. Eugster. Type-based publish/subscribe: Concepts and experiences. ACMTrans.Program. Lang. Syst., 29(1), \n2007. [17] F. Boussinot and R. De Simone. The ESTEREL language. Proc. IEEE, 79(9):1293 1304, Sept. 1991. \n[18] M.F\u00a8ahndrich, M. Aiken, C. Hawblitzel, O. Hodson, G. C. Hunt,J.R. Larus, andS.Levi. Language support \nforfast and reliable message-based communication in Singularity OS. In Proceedings of EuroSys2006, Leuven, \nBelgium, Apr. 2006. ACM SIGOPS. [19] A. Ghosal, T. Henzinger, C. Kirsch, and M. Sanvido. Event-driven \nprogramming with logical execution times. In Proceedings of the 7th InternationalWorkshop, Hybrid Systems \nComputation and Control, March 2004. [20] J. Gosling, B. Joy, G. Steele, Jr., and G. Bracha. TheJava \nLanguage Speci.cation. Addison-Wesley, second edition, 2000. [21]P.L. Guernic,M.L. Borgne,T. Gauthier, \nandC.L. Maire. Programming real time applications with signal. Proceedings of the IEEE, September 1991. \n[22] A. Krishna, D. Schmidt, and R. Klefstad. Enhancing Real-Time CORBA via Real-Time Java Features. \nIn 24th International Conference on DistributedComputing Systems (ICDCS 2004), pages 66 73, Hachioji,Tokyo, \nJapan, March 2004. [23] R. P. M, R. K. Cytron, D. Sharp, and E. Pla. Transport layer abstraction in event \nchannels for embedded systems. In LCTES 03: Proceedings of the 2003 ACM SIGPLAN conference on Language, \ncompiler, and tool for embedded systems, pages 144 152, 2003. [24] J. Manson, J. Baker,A. Cunei, S. Jagannathan, \nM. Prochazka, B.Xin,andJ.Vitek. Preemptible atomicregionsfor real-time Java. In Proceedings of the 26th \nIEEE Real-Time Systems Symposium (RTSS), Dec. 2005. [25] J. Noble,J. Potter, andJ.Vitek. Flexible alias \nprotection. In 12th European Conference on Object-Oriented Programming (ECOOP), Brussels, Belgium, July \n1998. [26] F. Pizlo, A. Hosking, and J. Vitek. Hiearchical real\u00adtime garbage collection. In ACM SIGPLAN/SIGBED \n2007 Conference on Languages, Compilers, andTools for Embedded Systems (LCTES), pages 123 133, 2007. \n[27]F. Pizlo andJ.Vitek. An empiricalevalutationof memory management alternatives for Real-time Java. \nIn 27th IEEE Real-Time Systems Symposium (RTSS), Dec. 2006. [28] R. Sekar,Y. Guang, S.Verma, andT. Shanbhag. \nA high\u00adperformance network intrusion detection system. In ACM Conference on Computer and Communications \nSecurity, pages 8 17, 1999. [29]D. Spoonhower,J. Auerbach,D.F. Bacon,P. Cheng, and D. Grove. Eventrons: \na safe programming construct for high-frequencyhard real-time applications. In Proceedings of the conference \non Programming language design and implementation (PLDI), pages 283 294, 2006. [30] J. Spring, F. Pizlo, \nR. Guerraoui, and J. Vitek. Re.exes: Abstractions for highly responsive systems. In Proceedings of the \n2nd International Conference onVirtual Execution Environments (VEE), 2007. [31] M. Stonebraker, U. C\u00b8 \netintemel, and S. Zdonik. The 8 requirements of real-time stream processing. SIGMOD Rec., 34(4):42 47, \n2005. [32] W. Thies, M. Karczmarek, and S. Amarasinghe. Streamit: A language for streaming applications. \nIn International Conference on Compiler Construction (CC 02), Apr. 2002. [33] O.Vitek,B. Craig,C. Bailey-Kellog, \nandJ.Vitek. Inferential backbone assignment for sparse data. Journal of Biomolecu\u00adlar NMR, 2006. [34]T. \nZhao,J. Baker,J. Hunt,J. Noble, andJ.Vitek. ScopeJ: Simpleownership types for memory management. Submitted \nfor publication, Dec. 2006. [35]T. Zhao,J. Noble, andJ.Vitek. Scoped types for real-time Java. In Proceedings \nof the 25th IEEE International Real-Time Systems Symposium (RTSS), Lisbon, Portugal, Dec. 2004.   \n\t\t\t", "proc_id": "1297027", "abstract": "<p>The stream programming paradigm aims to expose coarse-grained parallelism inapplications that must process continuous sequences of events. The appeal ofstream programming comes from its conceptual simplicity. A program is acollection of independent filters which communicate by the means ofuni-directional data channels. This model lends itself naturally toconcurrent and efficient implementations on modern multiprocessors. As theoutput behavior of filters is determined by the state of their inputchannels, stream programs have fewer opportunities for the errors (such asdata races and deadlocks) that plague shared memory concurrent programming. This paper introduces S&lt;scp&gt;tream&lt;/scp&gt;F&lt;scp&gt;lex&lt;/scp&gt;, an extension to Java which marries streams with objects and thus enables to combine, in the same Java virtual machine, stream processing code with traditional object-oriented components. S&lt;scp&gt;tream&lt;/scp&gt;F&lt;scp&gt;lex&lt;/scp&gt; targets high-throughput low-latency applications with stringent quality-of-service requirements. To achieve these goals, it must, at the same time, extend and restrict Java. To allow for program optimization and provide latency guarantees, the S&lt;scp&gt;tream&lt;/scp&gt;F&lt;scp&gt;lex&lt;/scp&gt; compiler restricts Java by imposing a stricter typing discipline on filters. On the other hand, S&lt;scp&gt;tream&lt;/scp&gt;F&lt;scp&gt;lex&lt;/scp&gt; extends the Java virtual machine with real-time capabilities, transactional memory and type-safe region-based allocation. The result is a rich and expressive language that can be implemented efficiently.</p>", "authors": [{"name": "Jesper H. Spring", "author_profile_id": "81330498582", "affiliation": "Ecole Polytechnique Federale de Lausanne, Lausanne, Switzerland", "person_id": "P870762", "email_address": "", "orcid_id": ""}, {"name": "Jean Privat", "author_profile_id": "81309481459", "affiliation": "Purdue University, lafayette, IN", "person_id": "PP39105491", "email_address": "", "orcid_id": ""}, {"name": "Rachid Guerraoui", "author_profile_id": "81100348136", "affiliation": "Ecole Polytechnique Federale de Lausanne, Lausanne, Switzerland", "person_id": "PP40026317", "email_address": "", "orcid_id": ""}, {"name": "Jan Vitek", "author_profile_id": "81100018102", "affiliation": "IBM Research and Purdue University, Fafayette, IN", "person_id": "PP39023418", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297043", "year": "2007", "article_id": "1297043", "conference": "OOPSLA", "title": "Streamflex: high-throughput stream programming in java", "url": "http://dl.acm.org/citation.cfm?id=1297043"}