{"article_publication_date": "10-21-2007", "fulltext": "\n Inferring Aliasing and Encapsulation Properties for Java Kin-Keung Ma Jeffrey S. Foster University \nof Maryland, College Park University of Maryland, College Park kkma@cs.umd.edu jfoster@cs.umd.edu Abstract \nThere are many proposals for language techniques to con\u00adtrol aliasing and encapsulation in object oriented \nprograms, typically based on notions of object ownership and pointer uniqueness. Most of these systems \nrequire extensive manual annotations, and thus there is little experience with these properties in large, \nexisting Java code bases. To remedy this situation, we present Uno, a novel static analysis for automatically \ninferring ownership, uniqueness, and other aliasing and encapsulation properties in Java. Our analysis \nrequires no annotations, and combines an intraprocedural points-to analysis with an interprocedural, \ndemand-driven predicate resolution algorithm. We have applied Uno to a va\u00adriety of Java applications \nand found that some aliasing prop\u00aderties, such as temporarily lending a reference to a method, are common, \nwhile others, in particular .eld and argument ownership, are relatively uncommon. As a result, we believe \nthat Uno can be a valuable tool for discovering and under\u00adstanding aliasing and encapsulation in Java \nprograms. Categories and Subject Descriptors D.1.5 [Programming Techniques]: Object-oriented Programming; \nD.2.11 [Soft\u00adware Engineering]: Software Architectures Information hiding; D.3.2 [Programming Languages]: \nLanguage Class\u00adi.cations Object-oriented languages; F.3.2 [Logics and Meanings of Programs]: Semantics \nof Programming Lang\u00aduages Program analysis General Terms Languages, Measurement Keywords Uno, Java, ownership, \nuniqueness, lending, en\u00adcapsulation, aliasing, ownership inference, uniqueness infer\u00adence Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October \n21 25, 2007, Montr\u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; 2007 ACM 978-1-59593-786-5/07/0010. . \n. $5.00. 1. Introduction Understanding and controlling aliasing is a fundamental part of building robust \nsoftware systems. In recent years, re\u00adsearchers have proposed many systems that reason about various \naliasing properties in programs, including unique\u00adness [1, 2, 7, 8, 15, 28, 31] and ownership [2, 3, \n6, 11, 12, 16, 18, 24, 30]. Unique objects are those referred to by only one pointer, and thus are guaranteed \nunaliased with any other ob\u00adjects in the system. Owned objects are encapsulated inside of their owner, \nand hence cannot be directly accessed by other components. Many of these systems include static checking \nof these properties in Java-like source code, but usually require that the programmer manually add extensive \nannotations. More\u00adover, while the properties modeled seem quite useful, it is unclear how often they \noccur in existing programs. To date, experience with using such systems on large software appli\u00adcations \nhas either been with coarse analysis [16, 30] or via case studies [2]. In this paper, we present a novel \ntool called Uno1 that .lls this gap. Uno takes as input unannotated Java source code and infers uniqueness \nof method arguments and results; lending (temporary aliasing) of method arguments and re\u00adceiver objects; \nand ownership and non-escaping of param\u00adeters and .elds. These properties capture key aliasing and encapsulation \nbehavior, and can give important insight into Java code. For example, a programmer might use Uno to check \nthat a factory method always returns a unique object as expected, or that a proxied object is owned by \nits proxy, which therefore controls all access to it. Uno performs inference using a novel two-phase \nalgo\u00adrithm. The .rst phase is an intraprocedural (within one func\u00adtion) may-alias analysis that computes \nlocal points-to in\u00adformation. Our alias analysis is mostly standard, but uses an interesting mix of .ow-sensitive \nand .ow-insensitive in\u00adformation. The second phase is a demand-driven interpro\u00adcedural analysis that \ncomputes a set of mutually-recursive predicates. For example, for each method m, Uno deter\u00admines whether \nthe predicate UNIQRET(m) holds, meaning that m always returns a unique object when it is called. If m \nreturns its ith argument, then UNIQRET(m) holds only 1 Uniqueness aNd Ownership, http://www.cs.umd.edu/projects/PL/uno \nif UNIQPAR(m, i) holds, meaning m is always called with a unique ith argument. Uno incorporates several \nother inter\u00addependent predicates that capture the aspects of aliasing and encapsulation mentioned above. \nWe have applied Uno to more than one million lines of Java code, including SPEC benchmarks, the DaCapo \nbench\u00admarks [5], and larger programs found on SourceForge. Our goal was to demonstrate the utility of \nUno, and to discover how often the ownership and encapsulation properties it in\u00adfers actually occur in \nJava programs. We found that, on av\u00aderage across our benchmarks, the monomorphic ownership inferred by \nUno holds for 16% of the private .elds and only 2.7% of the arguments of called constructors. Somewhat \nsur\u00adprisingly, Uno infers that more than 30% of all methods (constructors not included) that do not return \na primitive return a unique value, and approximately 50% of all non\u00adprimitive method parameters are lent \n(i.e., only temporarily aliased by the method and not captured). Our results show that programmers do \ncontrol aliasing and encapsulation in some ways suggested in the literature but less so in oth\u00aders, modulo \nthe precision of Uno s sound but conservative analysis. To our knowledge, Uno is the .rst ownership and \nuniqueness inference tool that has been demonstrated on a wide variety of Java applications. In summary, \nthe contributions of this paper are: We describe a .ow-sensitive, intraprocedural points-to analysis \nalgorithm tuned to compute the information needed for evaluating Uno s predicates. (Section 3)  We present \na novel interprocedural algorithm that infers a range of aliasing and encapsulation properties. Our anal\u00adysis \nis structured as a set of mutually-recursive predi\u00adcates. The algorithm is demand-driven, so that only \nthe predicates and points-to information necessary to answer a query are actually computed. (Section \n4)  We describe our implementation, Uno, and apply it to a number of benchmarks. Uno .nds that some \naliasing and encapsulation properties such as lending of arguments occur often, and other properties, \nsuch as monomorphic ownership, occur rarely. As a result, we believe that Uno is a valuable tool for \ndiscovering and understanding alias\u00ading and encapsulation in Java. (Section 5)  2. Overview We begin \nour presentation by illustrating Uno s core notions of uniqueness and ownership for methods and constructors, \nand by describing the key predicates Uno computes to per\u00adform inference. Uniqueness We say that a pointer \nis unique if it is the only reference to the object it points to. Uniqueness is a very useful pointer \nproperty because its strong notion of non\u00adaliasing permits modular reasoning [1, 2, 7, 8, 15, 28, 31]. \nFigure 1(a) illustrates one kind of uniqueness Uno infers. In this example, instances of ConcreteSubject \n(lines 4 7) Ownership Uno s notion of ownership is based on the .ex\u00adible alias protection framework of \nNoble, Potter, Vitek, and Clarke [12, 24]. Their system uses a notion called represen\u00adtation containment, \nin which if object o contains or owns object p, then only o may access p. This system is de\u00adsigned to \nbe more .exible than previous proposals [3, 18] in two important ways: First, an object need not own \nev\u00adery object it refers to. For example, a container object might own the backbone of the container but \nnot the elements themselves. Second, ownership is polymorphic or context\u00adsensitive, which allows an owner \nto grant some objects it owns access to other objects it owns [12]. 1 interface Subject { 2 void setData(int \nd); 3 } 4 class ConcreteSubject implements Subject { 5 private int data; 6 void setData(int d) { data \n= d; } 7 } 8 class Factory { 9 public Subject getSubject() { // returns unique 10 Subject r = new ConcreteSubject(); \n11 Subject s = r ; 12 return r ; 13 } 14 } (a) Uniqueness of method return 15 class Proxy implements \nSubject { 16 private Subject s; // owned by this 17 public Proxy(Subject s) { 18 this.s = s; 19 } 20 \npublic void setData(int d) { 21 s.setData(d*d); 22 } 23 } 24 class Main { 25 public void main(Factory \nf) { 26 Subject t = f .getSubject(); 27 t .setData(1); // uses t directly 28 Proxy proxy = new Proxy(t); \n// proxy owns t 29 proxy.setData(2); // t now used through proxy 30 } 31 } (b) Ownership of method argument \nFigure 1. Source code example are created by getSubject (lines 9 12). Notice that when getSubject returns, \nthe only other pointers to its result are r and s, both of which are dead at the method exit. Thus, Uno \nconcludes the return value of getSubject is always unique. Knowing a return value is unique can be useful \nbecause uniqueness typically implies the returned value is fresh. This is particularly helpful in this \nexample, when we are calling a factory method rather than a constructor, which is at least guaranteed \nto allocate a new object. Uno also checks uniqueness of constructor return values a pathological con\u00ad \nstructor that stores this in a .eld of another object would vi\u00ad olate uniqueness and we found that all \nconstructors in our experiments return a unique value. In Section 4, we formally de.ne a predicate UNIQRET(m) \nthat describes the necessary conditions for method m to re\u00ad turn a value that is unique when the method \nexits. Uno s inference algorithm is speci.ed in terms of this and other predicates, and for a given input \nprogram and selection of predicates, Uno reports whether those predicates hold for the methods and constructors \nof interest. Uno uses a slight variation of this notion of representa\u00adtion containment for ownership, \nbut in a monomorphic or context-insensitive form. We say that object o owns object p if o has the only \npointer to p, and if only o may access p. In particular, the only reads and writes to p must either occur \ninside of o s methods, or inside of other methods that o calls, where those other methods have only transient \npointers to p. Moreover, none of o s methods may leak p by returning it or storing it in a .eld of another \nobject. Ownership is a useful property because it enforces en\u00adcapsulation. Owned objects are not accessible \noutside the owner, and thus the owner can safely assume that no other objects can manipulate them. For \nexample, we might use a security proxy to perform access control before delegating to a proxied object. \nWe can help ensure complete mediation by checking that the proxy owns the proxied object. Figure 1(b) \ngives an example. This code extends Fig\u00adure 1(a) with two new classes. Proxy (lines 15 23) has a private \n.eld s that stores instances of Subject, and Proxy s setData method delegates to s. Then the class Main \nhas a main method that creates a new ConcreteSubject (line 26), uses it (line 27), creates a Proxy for \nit (line 28), and then uses it through the Proxy (line 29). When Uno analyzes this code, it infers several \nthings. By the uniqueness of getSubject s return value, we see that t is unique on line 26. Then on line \n27, we invoke a method of t, but that method (line 6) does not change the uniqueness of t. When a unique \nobject o is passed to a method that does not change its uniqueness meaning the method has only transient \npointers to o we say that o is lent to the method. We de.ne the predicate LENTTHIS(m) to mean that calling \nmethod m lends the receiver object to m, and LENTTHIS holds for our example method. We also de.ne a corresponding \npredicate LENTPAR(m, i) to mean parameter number i is lent to method m. Next, on line 28, we pass the \nunique pointer t to the Proxy constructor, and t is never used again in the caller. Thus we say that \nProxy s .rst parameter is unique, and we de.ne predicate UNIQPAR(m, i) to mean that method or constructor \nm is always called with a unique ith argument that is not used after the call. In essence, if UNIQPAR(m, \ni) holds, then the ith argument may become owned by the receiver object after the call. Examining the \nProxy class further, Uno observes that on line 18, s is stored in a private .eld. Furthermore, that .eld \nvalue never escapes in particular, the only instance method, setData, does not leak s. For example, although \ns is passed on line 21 as the receiver object of Concrete\u00adSubject.setData, that method does not capture \nthe value of this. Thus predicate NESCFIELD(s) holds for Proxy, mean\u00ading that none of Proxy s methods \nleak private .eld s. Finally, putting this all together, we see that the Proxy constructor has a unique \nargument that is stored in a pri\u00advate .eld and does not escape the method. We de.ne two ownership predicates. \nFirst, OWNPAR(m, i) means that after calling the method or constructor m, the receiver object owns the \nith argument that was passed in. Here OWNPAR(Proxy(Subject), 1) holds. Second, OWNFIELD(f) means that \n.eld f is encapsulated inside its containing ob\u00adject and has a unique reference to its contents, and \nin our example, OWNFIELD(s) holds. Notice that ownership critically depends on uniqueness, since without \nit, we cannot reason about whether we have the sole pointer to an object. Of our two ownership predi\u00adcates, \nOWNFIELD(f) is more standard, modeling ownership of a .eld f no matter where the contents of that .eld \ncame from, including objects locally constructed within a class. The predicate OWNPAR(m, i), on the other \nhand, models an\u00adother important kind of ownership, where we are concerned with which objects coming from \noutside of a method or con\u00adstructor become owned. Previous ownership systems sup\u00adport this pattern [12, \n24], though they do not call attention to it speci.cally. Another important aspect of Uno is that it \nsupports .ow-sensitivity, to allow unique objects to become owned later on in a method. In our example, \nline 27 in main uses t directly. Only after t is captured by the Proxy object on line 28 does it becomes \nowned by proxy. We believe this .exibility is important to allow objects to be initialized be\u00adfore they \nbecome owned. Predicate Violations Next consider Figure 2, a slight mod\u00adi.cation of Figure 1 that shows \nseveral of the ways in which Uno s predicates may fail to hold. In this code, getSubject (lines 10 14) \nno longer returns a unique value because on line 12, r is stored in a public .eld, and hence there are \nmultiple pointers to the return value of getSubject after it returns. Furthermore, the bad method on \nlines 21 25 falsi.es both NESCFIELD(s) and OWNFIELD(s), in several ways. On line 22, s is stored in some \nclass Other (not shown), and thus s leaks from Proxy. Line 23 accesses the s .eld of a different Proxy \nobject, causing s to leak again. On line 24, the value of s is returned by the method, and since the \nmethod is public, that means s might leak yet again. The middle case illustrates a key difference between \nownership and Java s private keyword. In Java, a private .eld can still 1 interface Subject { 1 public \nclass ShimpleOptions { 2 void setData(int d); 2 private Map options; 3 } 3 public ShimpleOptions(Map \noptions) { // owns options 4 class ConcreteSubject implements Subject { 4 this.options = options; \n5 private int data; 5 } 6 void setData(int d) { data = d; } 6 } 7 } 7 public class ShimpleBody extends \nStmtBody { 8 class Factory { 8 protected ShimpleOptions options; 9 public Subject cur; 9 ShimpleBody(Body \nbody, Map options) { 10 public Subject getSubject() { // should return unique 10 this.options = new \nShimpleOptions(options); 11 Subject r = new ConcreteSubject(); 11 } 12 cur =r; // violates UniqRet \n 12 } 13 return r; 13 public class Shimple { 14 } 14 public static .nal String PHASE = shimple ; \n 15 } 15 public ShimpleBody newBody(Body b) { // unique 16 class Proxy implements Subject { 16 Map \noptions = PhaseOptions.v().getPhaseOptions(PHASE); 17 return new ShimpleBody(b, options); 18 } 19 \n} 20 public class PhaseOptions { 21 public Map getPhaseOptions(String phaseName) { // unique 22 return \ngetPhaseOptions(getPM().getPhase(phaseName)); 23 } 24 public Map getPhaseOptions(HasPhaseOptions phase) \n{ 25 return Collections.unmodi.ableMap(ret); // unique 26 } 27 } 28 public class Collections { 29 \npublic static Map unmodi.ableMap(Map m) { // unique 30 return new Unmodi.ableMap(m); 31 } 32 } Figure \n3. Example from Soot follows. First, Uno determines on lines 29 31 that unmodi.\u00adableMap returns a unique \nobject. Thus so does getPhaseOp\u00adtions(HasPhaseOptions) (lines 24 26), and therefore so does getPhaseOptions(String) \n(lines 21 23). Thus on line 16, Uno infers that options points to a unique object. This unique ob\u00adject \nis passed to the ShimpleBody constructor declared on line 9, which in turn passes it to the ShimpleOptions \ncon\u00adstructor declared on line 3, which stores it into a private .eld on line 4. The remaining code (not \nshown) does not cause the .eld to leak. Putting this all together, ShimpleOptions owns its .eld options, \nand the ShimpleOptions(Map) constructor owns its argument. As this example shows, we often need to follow \nse\u00adquences of calls to infer uniqueness and ownership. Sec\u00adtion 5 includes sample output from Uno showing \nthis chain of reasoning on the Soot code corresponding to Figure 3. 3. Points-to Analysis The .rst step \nof Uno s inference algorithm is an intraproce\u00addural points-to analysis that determines aliasing information \nwithin each method. We use a may points-to analysis, so that the points-to sets determined by our algorithm \ndescribe a su\u00adperset of all possible run-time objects that may be pointed 17 private Subject s; 18 \npublic Proxy(Subject s) { 19 this.s =s; 20 } 21 public Subject bad(Proxy p) { 22 Other.f = s; 23 \np.s.setData(1); 24 return s; 25 } 26 public void setData(int d) { 27 s.setData(d*d); 28 } 29 } \n 30 class Main { 31 public void main(Factory f) { // not owned by this // violates NEscField // violates \nNEscField // violates NEscField 32 Subject t = f.getSubject(); 33 t .setData(1); // valid 34 Proxy proxy \n= new Proxy(t); // proxy should own t 35 proxy.setData(2); // valid 36 t .setData(2); // violates UniqPar \n37 } 38 } Figure 2. Violations of predicates be accessed by a different instance of the same class. In \nour experiments, we found that approximately 40% of private .elds may leak in this way, using the fairly \ncoarse analysis discussed in Section 3. Lastly, on line 36, t is used directly after being passed to \nthe Proxy constructor on line 34, and thus that constructor is no longer always called with a unique \nargument. Since at least one (in fact several) conditions for ownership are violated, Uno concludes that \nthe Proxy constructor no longer owns its argument. This example demonstrates that aliasing and encapsula\u00adtion \nproperties can be subtle to check and are interdependent. In Section 5.3, we present measurements on \nwhich predi\u00adcates most often cause ownership to fail to hold. Ownership and Uniqueness in Practice Finally, \nfor a more complex example, consider the code in Figure 3, which is extracted and simpli.ed from Soot \n[29], one of our benchmarks. In this example, Uno infers that the Shim\u00adpleOptions constructor (lines \n3 5) owns its argument, as RET Objects returned by this method FLD(f) Objects pointed to by .eld f of \nthis PAR(\u00a3, i) Objects passed to ith parameter of \u00a3 BAD Objects pointed to externally THIS(\u00a3) Receiver \nobjects of \u00a3 BADFLD Private .elds accessed by other instances LIVE(\u00a3) Objects live after \u00a3 of the same \nclass, and all non-private .elds SUPTHIS(i) ith parameters of super(. . .) or this(. . .) Statement \nTransfer Function Points-to Set Constraints 8 Method entry Out(x) = < : {\u00a3pi} x is ith param {\u00a3this} \nx is this \u00d8 otherwise FLD(f) . {\u00a3f } .f in class BAD . {\u00a3bad}BADFLD . {non-private .elds} x1 = x2 Out(x1) \n= In(x2) x = new\u00a3 C(x1, . . . , xn) Out(x) = {\u00a3} PAR(\u00a3, i) . In(xi) i . 1..n LIVE(\u00a3) . Out(x) .live x \nx1.f = x2  if x1 = this then FLD(f) . In(x2) else BAD . In(x2) if class(x1) = class(this) then BADFLD \n. {f} x1 = x2.f Out(x1) = j FLD(f) if x2 = this BAD otherwise if x2 = this . class(x2) = class(this) \nthen BADFLD . {f} C.f = x  BAD . In(x) x = C.f Out(x) = BAD xr = x0.m\u00a3(x1, . . . , xn) Out(xr) = {\u00a3} \nPAR(\u00a3, i) . In(xi) i . 1..n THIS(\u00a3) . In(x0) LIVE(\u00a3) . Out(x) .live x super(x1, . . . , xn)  SUPTHIS(i) \n. In(xi) i . 1..n this(x1, . . . , xn)  SUPTHIS(i) . In(xi) i . 1..n return x  RET . In(x) Figure \n4. Intraprocedural points-to analysis to by variables and .elds. Our analysis includes both .ow\u00adsensitive \nand .ow-insensitive components, discussed below. We formalize our points-to analysis by associating each \nsyntactic allocation site in the program with a fresh label \u00a3 that represents objects constructed at \nthat site. Thus points-to sets are sets of labels. For example, if we see an assignment x = new\u00a3 C(x1,...,xn) \nin the program, we add \u00a3 to the points-to set for x. In an interprocedural points-to analysis, we would \nonly need to label occurrences of new, and then propagate those labels throughout the whole program. \nHowever, since our points-to analysis is intraprocedural and thus only operates on one method at a time, \nwe also need labels for objects that come from outside the method we are analyzing. For each method parameter \nxi, we create a label \u00a3pi to represent the object initially pointed to by xi. Similarly, we use label \n\u00a3f for the initial contents of this.f, label \u00a3bad for the initial contents of any other .eld, and label \n\u00a3this for the object stored in this. Lastly, we also label method invocations as x.m\u00a3(...), and use \u00a3 \nto represent objects returned by the call. To infer aliasing and encapsulation properties, we need to \ndetermine how objects in the program .ow through each method. For example, to decide whether a method \nreturns a unique object, we need to compute the set of objects that may be returned by the method and \nensure there are no other pointers to them when the method exits e.g., the returned object was not stored \nin a .eld. To support this process, our points-to analysis computes a series of .ow-insensitive sets, \nsummarized at the top of Figure 4. By .ow-insensitive, we mean that there is only one copy of the set \nfor the entire method body. This is in contrast to our modeling of local variables, which is .ow\u00adsensitive, \nallowing variables points-to sets to change from one program point to the next (see below). The .ow-insensitive \nset RET tracks the objects returned by the current method. For each method invocation labeled \u00a3 in the \ncurrent method, PAR(\u00a3, i) tracks the objects passed in as the ith argument, THIS(\u00a3) tracks the possible \nreceiver objects, and LIVE(\u00a3) tracks the objects pointed to by local variables that are live after the \ncall. We do not treat calls to super or this constructors as method invocations, in order to handle certain \nspecial cases for constructors. Thus if we see a super or this constructor call, we store the points-to \nset of the ith parameter in SUPTHIS(i) (rather than as a PAR set). Note that a constructor includes exactly \none (possibly implicit) super or this constructor call, and the call must be the .rst action of the constructor \n[4]. The .ow-insensitive set FLD(f) tracks the objects stored in this.f. Any object written to a .eld \nnot of this (i.e., the write is not of the form this.f = ...), or to a static .eld, is added to the set \nBAD, rather than trying to track other objects .elds precisely. This greatly simpli.es our points\u00adto \nanalysis, since it means that anything stored outside of the current object in the heap is aliased to \neverything in BAD. In Section 4, we assume that any object in BAD is not unique and escapes. The last \nset, BADFLD, is a set of .eld names rather than a points-to set. This set contains .elds that may be \naccessed by other instances. It contains all non-private .elds, along with private .elds that the current \nmethod accesses from other instances of the same class as this. Recalling line 24 of Figure 2, we use \nthis set to .nd .elds that are private but are accessed from outside the object containing them. Note \nthat BADFLD is a global set, shared across all points-to analyses. The bottom of Figure 4 summarizes \nthe data.ow anal\u00adysis we use to compute points-to information. The various kinds of statement are listed \nin the left column, and are de\u00adrived from the Jimple [29] representation of Java bytecode, which we use \nin our implementation. We omit some lan\u00adguage features such as arrays, which are discussed in Sec\u00adtion \n5. Our analysis tracks information for local variables .ow-sensitively, maintaining a mapping Out that \ngives the points-to set for local variables just after each statement ex\u00adecutes. We use In to stand for \nthe union of the Out maps of all preceding statements. For brevity, Out(x)= In(x) for all x unless stated \notherwise. For each statement, we list the corresponding transfer function and constraints on the .ow-insensitive \npoints-to sets. At the method entry, we set Out so that each formal parameter xi points to \u00a3pi, this \npoints to \u00a3this, and other variables points-to sets are empty. We add \u00a3f to FLD(f) for each f, we set \nBAD to contain \u00a3bad, and we add any non\u00adprivate .elds to BADFLD. At an assignment statement, we copy \nthe right-hand side points-to set to the left-hand side, with no effect on the .ow\u00adinsensitive sets. \nFor a constructor call, we set the left-hand side to point to the label of the call, and we include the \npoints-to set of each argument in PAR, and add to LIVE the set of objects pointed to by live local variables \nafter the call. We omit the live variable computation, since it is standard. When writing to a .eld of \nthis, we add the points-to set of the right-hand side to FLD(f). When writing to a .eld of any other \nobject, we instead add to the set BAD. Additionally, if the object whose .eld is written has the same \nclass as this, then we add f to the set BADFLD. When reading from an instance .eld, we set the points-to \nset of the left-hand side either to FLD(f) or BAD, as appropriate, and add f to BADFLD if needed. Static \n.elds are shared by all instances of the class, and so any objects pointed to by them are added to BAD. \nTo keep notation simpler, we assume that .elds are not inherited. In our implementation, inherited .elds \nare in BAD, so they always escape and are not unique. For method and super or this constructor calls, \nwe add the points-to sets of the arguments to PAR or SUPTHIS, as appropriate. For method calls, the points-to \nset of the left\u00adhand side contains the returned label, and we constrain LIVE and THIS appropriately. \nLastly, for method return we add the points-to set of the returned variable to RET. Resolution Algorithm \nThe points-to analysis described in Figure 4 could be implemented using an iterative .xpoint algorithm. \nHowever, we found that the .xpoint algorithm was too slow for large benchmarks, because it computed information \nthat was not necessary to infer Uno s predicates. Thus our implementation instead uses a lazy, constraint\u00adbased \nsolving algorithm. We represent each points-to set A as a lazy set {\u00a31,...,A1,...}, consisting of labels \n\u00a3i and other points-to sets Ai. For a transfer function of the form A = B, we set A to {B}. For a constraint \nA . B, we add B to the lazy set for A (i.e., A is now of the form {...,B}). For an In set, which is \na union of the form Outi (recall this is not shown in Figure 4), we set In = {Out1,...}. Later on, when \nwe need the contents of a set, we .atten it on demand, where .atten({\u00a31,...,A1,...})= {\u00a31,...}. j .atten(Aj \n). Flattening a lazy set can be time consuming, and if we needed to .atten all sets this approach would \nbe too slow. However, we discovered that most sets computed in the points-to analysis are not needed \nby the predicate resolution algorithm. In particular, any .ow sensitive information (e.g., Out(x)) is \nnot used directly in predicate resolution. Thus we have found that laziness in the points-to analysis \ngreatly improves the running time of our algorithm. 4. Predicate Inference The second step of our inference \nalgorithm is an interpro\u00adcedural analysis that determines aliasing and encapsulation properties of methods \nand constructors. As discussed in Sec\u00adtion 2, we specify our analysis as a set of mutually-recursive \npredicates. For presentation purposes, we split the predicates into two groups, but in practice, Uno \ncomputes all predicates simultaneously. Our de.nitions of the predicates depend on the various .ow-insensitive \npoints-to sets computed by the algorithm in Section 3. Thus, we believe that any other points-to analysis \n(e.g., a more precise one [20, 26, 27, 32]) that could be modi.ed to produce the same summary information \ncould be integrated into Uno without dif.culty. 4.1 Uniqueness Predicates Figure 5 de.nes the predicates \nrelated to uniqueness, most of which we saw earlier in Section 2. There are .ve main predicates, described \nin the left column. UNIQRET(m) is the basic uniqueness predicate, which holds if method m always returns \na unique object. To cut down on verbiage, throughout the rest of this section we use the word method \nand the sym\u00adbol m to mean either a method or a constructor. If m is a con\u00adstructor, UNIQRET(m) holds \nif the newly constructed object is unique after the constructor call. LENTPAR(m, i, no-.d) holds if calling \nmethod m does not affect the uniqueness of its ith argument, i.e., if the ith argument is lent to m. \nHere the .ag no-.d (omitted earlier for simplicity) is true when checking ordinary method calls, and \nis false in certain cases of checking calls to super or this constructors, as discussed subs(m) methods \nthat override m supthis(m) super or this constructor called by m sups(m) methods m overrides mth(\u00a3) method \ninvoked by call \u00a3 callee(m) methods called by m before(\u00a3) labels of calls that happen before \u00a3 a N b \n= (a n b = \u00d8), a N b = (a n b = \u00d8) Predicate Local Constraints Non-local Constraints UNIQRET(m) Method \nm returns a unique object (L1) RET N BAD (L2) RET N {\u00a3this}(L3) RET N FLD(f) (1) UNIQRET(subs(m)) (2) \nUNIQPAR(m, i, true) if RET N {\u00a3pi}(3) UNIQRET(mth(\u00a3)) if RET N {\u00a3}(4) LENTPAR(mth(\u00a3), j, true) if RET \nN PAR(\u00a3, j) (5) LENTTHIS(mth(\u00a3)) if RET N THIS(\u00a3) (6) LENTTHIS(m) if m is constructor LENTPAR(m, i, no-.d) \nCalling method m does not change the uniqueness of its ith argument (L1) {\u00a3pi} N BAD (L2) {\u00a3pi} N RET \n(L3) If no-.d then {\u00a3pi} N FLD(f) (1) LENTPAR(subs(m), i, no-.d) (2) LENTPAR(mth(\u00a3), j, true) if {\u00a3pi} \nN PAR(\u00a3, j) (3) LENTTHIS(mth(\u00a3)) if {\u00a3pi} N THIS(\u00a3) (4) LENTPAR(supthis(m), j, no-.d) if {\u00a3pi} N SUPTHIS(j) \nLENTTHIS(m) Calling method m does not change the uniqueness of the re\u00adceiver object (L1) {\u00a3this} N BAD \n(L2) {\u00a3this} N RET (L3) {\u00a3this} N FLD(f) (1) LENTTHIS(subs(m)) (2) LENTPAR(mth(\u00a3), j, true) if {\u00a3this} \nN PAR(\u00a3, j) (3) LENTTHIS(mth(\u00a3)) if {\u00a3this} N THIS(\u00a3) (4) LENTPAR(supthis(m), j, true) if {\u00a3this} N SUPTHIS(j) \n(5) LENTTHIS(supthis(m)) UNIQPAR(tgt, i, no-.d) Method tgt s ith parameter is al\u00adways unique  (1) UNIQPAR(sups(tgt), \ni, no-.d) (2) UNIQPAR-IN(m, i, tgt, true) if tgt . callee(m) (3) UNIQPAR-IN(m, i, tgt, no-.d) if tgt \n. supthis(m) UNIQPAR-IN(m, i, tgt, no-.d) Method m always passes a unique object as the ith parameter \nwhen it calls tgt .\u00a3 s.t. mth(\u00a3) = tgt (L1) PAR(\u00a3, i) N BAD (L2) PAR(\u00a3, i) N {\u00a3this}If no-.d then (L3) \nPAR(\u00a3, i) N LIVE(\u00a3) (L4) PAR(\u00a3, i) N FLD(f) (L5) PAR(\u00a3, i) N PAR(\u00a3, j), j = i (L6) PAR(\u00a3, i) N THIS(\u00a3) \n.\u00a3 s.t. mth(\u00a3) = tgt (1) UNIQPAR(m, j, true) if PAR(\u00a3, i) N {\u00a3pj }(2) UNIQRET(mth(\u00a32)) if PAR(\u00a3, i) N \n{\u00a32}.\u00a32 . before(\u00a3) . (3) LENTPAR(mth(\u00a32), j, true) if PAR(\u00a3, i) N PAR(\u00a32, j) (4) LENTTHIS(mth(\u00a32)) if \nPAR(\u00a3, i) N THIS(\u00a32) (5) LENTPAR(supthis(m), j, no-.d) if PAR(\u00a3, i) N SUPTHIS(j) Figure 5. Predicates \nrelated to uniqueness below. LENTTHIS(m) holds if calling m does not change the uniqueness of the receiver \nobject. (We could combine LENT-THIS and LENTPAR into one predicate, but keep them dis\u00adtinct for expository \npurposes, and because our experimental results show that this is often treated differently than param\u00adeters.) \nLastly, UNIQPAR(tgt, i, no-.d) holds if method tgt is always called with a unique ith argument. This \npredicate is de.ned in terms of UNIQPAR-IN(m, i, tgt, no-.d), which checks the same property but for \nthe calls to tgt inside of m. In both cases, no-.d is used the same as in LENTPAR. The middle and right \ncolumns of Figure 5 give a set of conditions that must hold for the predicate to be true. We use several \nconventions in the .gure to simplify notation. Almost all of the conditions involve checking whether \nvari\u00adous points-to sets are disjoint, and we write aN b to mean anb = \u00d8, and a N b to mean anb= \u00d8. In \ngeneral, we use m and tgt to range over methods and constructors, i and j for parameter numbers, and \nf for .elds. Many of the predicates are parameterized by an argument m, and any points-to set mentioned \nin a predicate comes from the analysis of m. We also use a number of sets when de.ning the predi\u00adcates, \nas summarized at the top of Figure 5. We use subs(m) and sups(m) for the set of methods that override \nm and that m overrides, respectively. We write callee(m) for the set of methods that m may call according \nto the compile-time types, and we write supthis(m) for the super or this construc\u00adtor called in m; this \nis only de.ned if m is a constructor, and otherwise predicates depending on supthis(m) are ignored. For \na label \u00a3 corresponding to a method call, we use mth(\u00a3) to denote the method invoked by the call \u00a3, according \nto the compile-time types. Lastly, we use before(\u00a3) for the set of labels \u00a3' such that there is a path \nfrom \u00a3' to \u00a3 in the control\u00ad.ow graph, i.e., \u00a3' may happen before \u00a3. We divide the conditions into two \nparts. Local conditions are those that can be decided just from the intraprocedural alias analysis results \nfor the method in question, and thus do not depend on other methods. For example, UNIQRET(m) requires \nthat any return value of m not be in BAD, since a BAD value might have come from a .eld of another object. \nThus we require RET N BAD. Non-local conditions are those that require recursively checking predicates \nfor other methods. For example, if method m1 returns the result of method m2, then to decide whether \nm1 s result is unique, we need to check unique\u00adness of m2 s result. Each recursively-checked predicate \nmay have side-conditions that describe exactly what must be checked. For example, UNIQRET(m) recursively \nchecks (3) UNIQRET(mth(\u00a3)) where side-condition RET N {\u00a3} holds, i.e., UNIQRET is recursively checked \nfor all \u00a3 that are in\u00adcluded in RET. Note the implicit universal quanti.cation here to keep the conditions \nreadable, we assume that any free variables not de.ned by the predicate range over all reasonable values \n(e.g., j ranges over parameter numbers, \u00a3 ranges over invocations, f ranges over .elds, etc.) For convenience \nin discussing the predicates and in evalu\u00adating Uno, we number all of the conditions. We next discuss \nthe predicates in more depth. UNIQRET(m) For this predicate to hold, the returned ob\u00adject must not be \nreachable in any way except via the return value of the call. Thus nothing in BAD (L1) or {\u00a3this} (L2) \nmay be in RET, since objects in BAD may be pointed to by other objects, and we assume this is not unique. \nThe returned object must also not be pointed to by a .eld (L3). Note the implicit quanti.cation in (L3) \nwe require this condition holds for all .elds f of method m. We also need to account for objects that \ncome from out\u00adside method m. Any parameter \u00a3pi in RET must be unique (2), meaning that the caller does \nnot keep a pointer to that object, and similarly any method label \u00a3 in RET must come from a method that \nreturns a unique object (3). Further\u00admore, any object in RET that is passed in to a call, either as a \nmethod argument (in some PAR(\u00a3, j), (4)), or as a re\u00adceiver object (in THIS(\u00a3), (5)) must not have its \nuniqueness changed by the call, meaning it must have been lent to the callee. If m is a constructor, \nit must not change the unique\u00adness of this (6), which is not included in RET. Finally, a call to m at \ncompile time might at run time invoke a method that overrides m. Hence m can have a unique return value \nonly if all methods that override it do also (1). LENTPAR(m, i, no-.d) For method m not to change the \nuniqueness of its ith argument, represented by \u00a3pi in the alias analysis, it must be that \u00a3pi not appear \nin BAD (L1), be returned by m (L2), or be stored in a .eld (L3). If no-.d is false, we omit the last \ncheck. We use this feature when testing LENTPAR for a call to a super or this constructor. In these cases, \nthe calls by de.nition are received by the same object as the caller, and so if such a call stores a \nparameter in a local .eld, we still treat the argument as if it were lent (since it is stored in the \nsame object). Forthenon-localpredicates, LENTPAR requiresthatif \u00a3pi is passed to a method (2) or super \nor this constructor (4), or has one of its methods invoked (3), then those calls must not change its \nuniqueness. Finally, any methods that override m must also not change parameter i s uniqueness (1). LENTTHIS(m) \nThis predicate is analogous to LENTPAR, except it checks properties of \u00a3this instead of \u00a3pi. There is \nno no-.d .ag, since storing \u00a3this in a .eld always makes it non\u00adunique, and there is an extra check (5) \nfor a call to a super or this constructor, since such calls are invoked on \u00a3this as well. UNIQPAR(tgt, \ni, no-.d) This predicate and UNIQPAR-IN are the most complex of the uniqueness predicates. The base predicate, \nUNIQPAR, must check that all callers to tgt pass a unique object as tgt s ith argument. Similarly to \nthe other predicates, we .rst must ensure the same prop\u00aderty holds for methods that tgt overrides (1), \nsince tgt may be called in place of methods it overrides. Then we check UNIQPAR-IN(m, i, tgt, no-.d) \nfor all m that are methods (2) or constructors (3) that may call tgt. For the former, we set no-.d to \ntrue, since we assume the call may be received by another object, and for the latter no-.d remains the \nsame. In turn, UNIQPAR-IN examines all calls \u00a3 inside of m that invoke tgt. We want to ensure that each \ncall always passes a unique argument to position i. Thus PAR(\u00a3, i) must not intersect BAD (L1) or this \n(L2), and nothing in PAR(\u00a3, i) can be live after the call (L3) or be stored in a .eld (L4). We relax \nthe last two checks if no-.d is false, to allow calls to super or this constructors to retain pointers \nacross a call or store parameters in the current object. We also require that the points-to set PAR(\u00a3, \ni) for parameter i not overlap any other parameter s points-to set (L5) or the receiver object of the \ncall (L6), since then that parameter may be aliased, and therefore not unique, inside of the callee. \nUNIQPAR-IN also requires that any parameters \u00a3pj or method return values \u00a32 in PAR(\u00a3, i) must themselves \nhave been unique (1 2). We also ensure that for any calls \u00a32 that happen before the call \u00a3, if any labels \nin PAR(\u00a3, i) are passed to those calls either as a parameter PAR(\u00a32,j) or as a receiver object THIS(\u00a32) \nthen their uniqueness must not have been changed by the call \u00a32 (3 4). This ensures that only one call \nin a method can transfer uniqueness of an object to another method. We also check this condition for \nparameters passed to super or this constructor calls (5), which, if they exist, occur at the beginning \nof the constructor. 4.2 Ownership Predicates Figure 6 de.nes the remaining predicates, which focus on \nownership and encapsulation. OWNPAR(m, i) holds if method m owns its ith argument. NESCPAR(m, i) holds \nif the ith parameter of method m does not leak from the object via a call to m. NESCFIELD(f) holds if \n.eld f does not leak from the object, and NESCFIELD-IN(f, m) holds if f does not leak via method m. A \nre.nement of NESCFIELD, OWNFIELD(f) holds if f is owned by the object, mean\u00ading it does not escape and \ncontains a unique pointer, and OWNFIELD-IN(f, m) holds if .eld f is owned locally within method m. Lastly, \nSTORE(m, i) holds if method m stores parameter i in some .eld. In more detail, the predi\u00adcates are: OWNPAR(m, \ni) As discussed in Section 2, an argument to a method or constructor is owned if it becomes fully encap\u00adsulated \ninside its owner after the call. Thus for ownership of the ith argument to hold, it must be unique (2), \nso that this method or constructor can acquire ownership. We call Predicate Local Constraints Non-local \nConstraints OWNPAR(m, i) Method m owns its ith argument  (1) OWNPAR(subs(m), i) (2) UNIQPAR(m, i, false) \n(3) NESCPAR(m, i) If supthis(m) = \u00d8 or .j s.t. SUPTHIS(j) N {\u00a3pi}(4) then STORE(m, i) (5) else OWNPAR(supthis(m), \nj) if SUPTHIS(j) N {\u00a3pi} NESCPAR(m, i) The ith parameter of method m does not escape (L1) (L2) {\u00a3pi} \nN BAD {\u00a3pi} N RET (1) NESCPAR(subs(m), i) (2) LENTPAR(mth(\u00a3), j, true) if {\u00a3pi} N PAR(\u00a3, j) (3) LENTTHIS(mth(\u00a3)) \nif {\u00a3pi} N THIS(\u00a3) (4) LENTPAR(supthis(m), j, false) if {\u00a3pi} N PAR(\u00a3, j) (5) NESCFIELD(f) if {\u00a3pi} N \nFLD(f) NESCFIELD(f) Field f does not escape (L1) f is private (1) NESCFIELD-IN(f, m) if method m uses \nf NESCFIELD-IN(f, m) Field f does not escape in method m (L1) (L2) (L3) FLD(f) N BAD FLD(f) N RET f . \nBADFLD (1) LENTPAR(mth(\u00a3), j, true) if FLD(f) N PAR(\u00a3, j) (2) LENTTHIS(mth(\u00a3)) if FLD(f) N THIS(\u00a3) (3) \nLENTPAR(supthis(m), j, true) if FLD(f) N SUPTHIS(j) OWNFIELD(f) Field f is owned by this object  (1) \nNESCFIELD(f) (2) OWNFIELD-IN(f, m) if method m uses f OWNFIELD-IN(f, m) Field f is owned by this object \nwithin method m (L1) FLD(f) N {\u00a3this} (1) UNIQPAR(m, j, false) if FLD(f) N {\u00a3pj }(2) OWNFIELD(g) if FLD(f) \nN FLD(g) (3) UNIQRET(mth(\u00a3)) if FLD(f) N {\u00a3} STORE(m, i) Method m stores its ith parameter in a .eld \n(L1) (.f s.t. FLD(f) N {\u00a3pi}) . (.j s.t. SUPTHIS(j) N {\u00a3pi}) (1) STORE(subs(m), i) Figure 6. Predicates \nrelated to ownership UNIQPAR with no-.d set to false to allow m to own its argu\u00adment even if a super \nor this caller retains a reference to the argument, since both calls are received by the same object. \nThe ith argument also must not escape (3), so that the owned object is contained inside of the owner. \nTo suppress some vacuous cases of argument ownership, we also require that the ith parameter is either \nstored in some .eld (4) or passed to a super or this constructor that owns it (5), although our check \nfor this is heuristic, as discussed below. Finally, any method that overrides m must have the same ownership \nbehavior (1). NESCPAR(m, i) This predicate requires that the ith pa\u00adrameter, represented by \u00a3pi, not \nappear in BAD (L1) and not be returned by the method (L2), since either would cause \u00a3pi to escape. As \nusual, this predicate must hold for all meth\u00adods that override m (1), since they may be called in place \nof m. If \u00a3pi is used in a call, either as an argument (2) or as a receiver (3), then that call must not \nchange its uniqueness except that a call to a super or this constructor may cap\u00adture \u00a3pi, hence for that \ncase we call LENTPAR with no-.d as false (4). Finally, if \u00a3pi is stored in a .eld, then that .eld cannot \nescape this object (5). NESCFIELD(f) This predicate checks that f is private (L1) and checks NESCFIELD-IN(f, \nm) for all methods m that use f (1). This predicate in turn ensures that nothing in FLD(f) may be in \nBAD or RET (L1 L2), and that f is not in BADFLD (L3), so that it cannot leak via a different instance \nof the same class. Furthermore, anything in FLD(f) from a method invocation or constructor call must \nhave been unique (1), and anything in FLD(f) that is passed to a call must not have its uniqueness changed \nby the call (2 3). OWNFIELD(f) This predicate requires that .eld f not escape (1), and also requires \nthat f is locally owned within each method m that refers to f. The latter is checked by predicate OWNFIELD-IN(f, \nm), which requires that this not be stored in f (L1), and that only unique or otherwise owned objects \n(1 3) are stored in f. STORE(m, i) This predicate checks whether \u00a3pi, which represents the ith parameter, \nmay be pointed to by some .eld or was passed to a call to a super or this constructor. (Note that OWNPAR(m, \ni), which uses this predicate, ensures that the called constructor owns the argument.) Since we use a \nmay-alias analysis, STORE(m, i) is a heuristic we might think m stores its ith argument when it actually \ndoes not at run time. Nevertheless, we have found this predicate useful in practice for eliminating uninteresting \ncases of ownership. Init: .p. visited(p)= false, Val(p)= true RESOLVE(p)= if visited(p) return end if \nvisited(p)= true if p can be determined false locally Val(p)= false else for each s .{predicates p \ndepends on} do RESOLVE(s) if Val(s)= false break end if end for end if if Val(p)= false FALSIFY(p) end \nif FALSIFY(p)= Val(p)= false for each q that directly depends on p such that Val(q)= true do FALSIFY(q) \nend for Figure 7. Predicate resolution algorithm. 4.3 Predicate Resolution To compute whether the predicates \nhold, we can think of each predicate p as a node in a graph, with an edge from p to q if p depends on \nq, meaning that p uses q in one of its non-local conditions. Then we can check whether p is false by \nperforming a forward search from p, looking for a node whose local conditions are false. If such a node \nexists then p is false, and otherwise it is true. Figure 7 gives a depth-.rst search variant RESOLVE(p) \nto check whether p holds. The algorithm uses a map Val from predicates to truth values, and initially \nVal(p) is set to true for all p. The algorithm also keeps a .ag visited(p) that indicates whether we \nhave already tried to resolve predicate p, to stop the search from revisiting predicates. During resolution, \nvisited nodes have had their local conditions checked, and non-visited nodes have not. To check whether \np holds, the algorithm traverses the predicate dependency graph. If p has been visited before, we exit. \nOtherwise we mark p as visited and check p s local conditions. If they show that p is false, we update \nVal accordingly. Otherwise we resolve each predicate p depends on. We stop iteration at the .rst predicate \nthat is false by the last step of the algorithm (below), that predicate being false has already caused \nVal(p) to be set false. After computing the value of predicate p, if we determine it was false, we invoke \nFALSIFY(p) to .nd all other predicates that p depends on and mark them false as well, pruning the graph \ntraversal if we encounter a false predicate. If after this algorithm p is not set to false, it remains \ntrue. The key feature of this algorithm is short-circuiting recur\u00adsively computing predicates. As soon \nas one predicate p de\u00adpends on is discovered to be false, there is no need to check the other predicates \np depends on. We found that when Uno is used to compute a partial set of predicates, this feature can \nimprove the running time of predicate resolution. When we attempted to turn off lazy sets in our experiments, \nwe found that the larger experiments no longer completed, even if given several days to run. 5. Implementation \nand Experiments Uno is implemented using the Soot Java analysis frame\u00adwork [29]. Soot operates on Java \nclass .les, translating them into Jimple, a typed 3-address intermediate representation that uses instructions \nsimilar to those in Figure 4. To analyze the full Java language, Uno needs to handle some language features \nwe have not discussed. We treat arrays and their contents as BAD, which is conservative but sound, because \nit causes those objects to be treated as non\u00adunique and escaping. We do the same for native method arguments \nand results, though we cannot be fully sound for native methods since they may carry out arbitrary operations. \nJava type casts are ignored by our points-to analysis, since they do not change the object stored in \na reference. We also make two unsound assumptions in our analysis. First, we analyze code in exception \nhandlers, but do not track aliasing through exceptions, or the uniqueness or ownership of objects that \nare thrown. We also do not model re.ection API calls specially. We leave soundly handling these features \nto future work; for example, the work of Livshits et al [23] can be used to remove re.ection from programs. \nUno begins by performing the points-to analysis from Section 3. Since our points-to analysis is demand-driven, \nthe contents of the points-to sets are not computed until they are demanded by the second step the algorithm, \nwhich resolves the predicates from Section 4. Recall that the predicates involve some additional sets. \nThe sets subs(m), sups(m), supthis(m), and callee(m) can be determined trivially from the call graph \nand class hierarchy, and the set before(\u00a3) can be easily computed from the control-.ow graph. Once we \ncompute these sets, we use the predicate resolu\u00adtion algorithm from Section 4 to infer ownership and \nunique\u00adness. As mentioned earlier, that algorithm is demand-driven, so that it does not compute any more \npoints-to sets or pred\u00adicates than it must. In our experiments, we ran Uno exhaus\u00adtively, to compute \nall predicates for all methods and con\u00adstructors, but Uno can also be used selectively. For example, \nwe could use Uno to .nd all methods that return unique ob\u00adjects, or to .nd all constructors that own \ntheir arguments. Since Uno s predicates are somewhat complex and have many interdependencies, understanding \nwhy a predicate holds or does not hold is sometimes dif.cult. Figure 8 gives an example of Uno s output, \nwhich is designed to address this problem. This particular output is from the analysis of 1 UniqPar \nof <Shimple: ShimpleBody newBody(SootMethod,Map)> parameter 1 : True 2 UniqPar of <ShimpleBody: ShimpleBody(SootMethod,Map)> \nparameter 1 in <Shimple: ShimpleBody newBody(SootMethod,Map)> : True 3 UniqRet of <NullPointerException: \nNullPointerException()> : True 4 UniqRet of <Collections$Unmodi.ableMap: Unmodi.ableMap(Map)> : True \n5 UniqRet of <Collections: Map unmodi.ableMap(Map)> : True 6 UniqRet of <PhaseOptions: Map getPhaseOptions(HasPhaseOptions)> \n: True 7 UniqRet of <PhaseOptions: Map getPhaseOptions(String)> : True 8 UniqPar of <ShimpleBody: ShimpleBody(SootMethod,Map)> \nparameter 1 in <Shimple: ShimpleBody newBody(SootMethod)> : True 9 UniqPar of <ShimpleBody: ShimpleBody(SootMethod,Map)> \nparameter 1 : True 10 UniqPar of <ShimpleOptions: ShimpleOptions(Map)> parameter 0 in <ShimpleBody: \nShimpleBody(SootMethod,Map)> : True 11 UniqRet of <PhaseOptions: Map getPhaseOptions(String)> : True \n12 UniqPar of <ShimpleBody: ShimpleBody(Body,Map)> parameter 1 in <Shimple: ShimpleBody newBody(Body)> \n: True 13 UniqPar of <Shimple: ShimpleBody newBody(Body,Map)> parameter 1 : True 14 UniqPar of <ShimpleBody: \nShimpleBody(Body,Map)> parameter 1 in <Shimple: ShimpleBody newBody(Body,Map)> : True 15 UniqPar of \n<ShimpleBody: ShimpleBody(Body,Map)> parameter 1 : True 16 UniqPar of <ShimpleOptions: ShimpleOptions(Map)> \nparameter 0 in <ShimpleBody: ShimpleBody(Body,Map)> : True 17 UniqPar of <ShimpleOptions: ShimpleOptions(Map)> \nparameter 0 : True 18 NEscField-In of <ShimpleOptions: Map options> in <ShimpleOptions: ShimpleOptions(Map)> \n: True 19 NEscField-In of <ShimpleOptions: Map options> in <ShimpleOptions: boolean enabled()> : True \n20 NEscField-In of <ShimpleOptions: Map options> in <ShimpleOptions: boolean node elim opt()> : True \n21 NEscField-In of <ShimpleOptions: Map options> in <ShimpleOptions: boolean standard local names()> \n: True 22 NEscField-In of <ShimpleOptions: Map options> in <ShimpleOptions: boolean extended()> : True \n23 NEscField-In of <ShimpleOptions: Map options> in <ShimpleOptions: boolean debug()> : True 24 NEscField \nof <ShimpleOptions: Map options> : True 25 NEscPar of <ShimpleOptions: ShimpleOptions(Map)> parameter \n0 : True 26 Store of <ShimpleOptions: ShimpleOptions(Map)> parameter 0 : True 27 OwnPar of <ShimpleOptions: \nShimpleOptions(Map)> parameter 0 : True Figure 8. Example output of Uno running on Soot, from Figure \n3 Figure 9. Benchmark characteristics the original version of the code in Figure 3, and the predicate \nkind of output is critical in understanding Uno s results. For in question is whether ShimpleOptions(Map) \nowns its .rst our experiments we disabled this output, because we found argument. For each predicate, \nUno displays the non-local printing all this information noticeably slowed the analysis. conditions that \nit depends on and their truth values. We use indentation to match up conditions for the same predicate. \n5.1 Experiments For example, the conditions on lines 17, 25, and 26 show that We applied Uno to a number \nof SPEC JVM98 benchmarks, OWNPAR holds on line 27. In this case all the predicates that version 1.03 \n05, to the DaCapo benchmark suite 2006-10\u00ad ownership transitively depends on hold, and so line 27 in-MR2 \n[5], and to a selection of programs downloaded from dicates that OWNPAR is true. Our experience suggests \nthis SourceForge. Our goal was to determine how often Uno s Name Byte code LoC Cls + Intfs Methods Constrs \nFields Time (s) Soot Uno spec201-compress 48k 451 12 44 12 53 816 173 spec209-db 16k 512 3 34 3 10 814 \n174 spec200-check 92k 1,235 17 107 14 42 823 172 spec205-raytrace 120k 1,429 25 176 37 93 817 171 spec202-jess \n688k 4,736 151 690 164 265 861 172 spec222-mpegaudio 272k  55 322 55 270 857 184 spec228-jack 300k \n 56 315 57 255 851 181 spec213-javac 964k  176 1,190 189 851 861 214 DaCapo-antlr 1,004k  294 3,170 \n363 1,279 912 214 DaCapo-luindex 1,005k  411 3,218 502 1,564 476 109 DaCapo-lusearch 1,010k  413 3,219 \n504 1,575 488 112 DaCapo-bloat 1,505k  426 4,584 451 1,815 499 140 DaCapo-eclipse 1,557k  475 4,242 \n448 2,431 472 128 DaCapo-hsqldb 1,828k  556 6,427 649 4,161 1,137 300 DaCapo-jython 2,113k  969 9,130 \n1,140 3,139 1,146 502 DaCapo-xalan 2,170k  700 7,089 854 3,339 1,017 312 DaCapo-chart 3,156k  795 9,933 \n1,186 6,534 1,213 502 DaCapo-pmd 3,549k  1,392 11,805 1,609 5,894 1,293 518 DaCapo-fop 5,561k  2,389 \n15,073 2,262 8,342 1,484 497 middleware 2.3.1 1,084k 15,360 218 1,070 208 793 661 128 xui 2.0 1,060k \n23,542 187 1,946 178 681 876 195 hsqldb 1.8.0 2,176k 51,362 362 4,973 434 3,343 1,061 310 .ndbugs 1.2.0 \n12,564k 60,744 2,297 18,034 2,639 7,125 1,395 759 pooka 1.1 13,248k 108,204 2,603 16,358 3,218 7,507 \n1,683 602 azureus 2.4.0.2 19,240k 126,398 3,763 22,809 3,574 10,665 1,891 1,032 soot 2.2.3 15,856k 196,858 \n2,958 23,704 3,205 6,525 2,782 2,091 visad 2.0 18,176k 435,227 2,652 29,082 4,152 19,004 3,886 2,117 \n UNIQ RET LENT PAR LENT THIS UNIQ PAR OWNPAR All Call Cons NESC PAR NESC FIELD OWN FIELD STORE All Call \nspec201-compress  35 100 20 0.0 0.0 0.0 80 77 38 69 73 spec209-db 100 92 100 11 0.0 0.0 92 0 0 0 0 \nspec200-check 0 67 99 40 0.0 0.0 92  0 0 spec205-raytrace 0 65 90 11 0.8 0.8 2.6 73 6 6 27 28 spec202-jess \n35 71 99 7 0.0 0.0 0.0 78 50 46 12 12 spec222-mpegaudio 0 79 100 0 0.4 0.0 0.0 86 27 24 13 12 spec228-jack \n60 69 100 10 5.4 4.3 30.0 79 43 29 15 14 spec213-javac 27 42 81 2 0.0 0.0 0.0 53 15 0 18 18 Average 32 \n65 96 13 0.8 0.6 5.4 79 31 20 19 20 DaCapo-antlr 22 46 86 11 0.4 0.4 1.4 55 48 22 21 21 DaCapo-luindex \n44 34 93 20 2.2 2.0 4.9 49 40 16 34 33 DaCapo-lusearch 44 34 93 20 2.2 2.0 4.8 49 40 16 35 34 DaCapo-bloat \n24 44 76 4 0.6 0.6 3.0 53 52 9 18 18 DaCapo-eclipse 29 42 90 13 0.6 0.7 1.8 49 31 15 23 25 DaCapo-hsqldb \n34 53 94 12 0.4 0.4 1.6 61 40 12 19 20 DaCapo-jython 33 32 81 7 0.1 0.1 0.5 43 13 5 23 22 DaCapo-xalan \n33 43 91 13 0.6 0.3 1.3 51 38 18 24 25 DaCapo-chart 33 50 87 14 0.2 0.2 0.6 55 10 5 21 17 DaCapo-pmd \n27 41 87 11 0.3 0.2 1.2 51 35 16 19 18 DaCapo-fop 37 37 90 12 0.6 0.4 1.1 45 33 10 27 27 Average 33 41 \n88 12 0.7 0.7 2.0 51 35 13 24 24 middleware 2.3.1 27 73 92 27 0.2 0.3 1.2 81 70 28 19 18 xui 2.0 22 39 \n92 14 0.6 0.4 2.8 46 41 17 17 16 hsqldb 1.8.0 36 54 95 12 0.1 0.1 0.6 61 33 12 18 18 .ndbugs 1.2.0 29 \n46 90 7 1.3 0.4 1.9 55 32 15 20 18 pooka 1.1 31 43 91 14 1.1 0.6 1.6 55 40 13 31 30 azureus 2.4.0.2 23 \n40 88 14 1.1 1.1 2.8 56 50 9 34 35 soot 2.2.3 31 46 89 6 0.3 0.2 0.9 53 33 11 15 15 visad 2.0 24 59 82 \n8 0.3 0.2 0.8 66 35 18 19 18 Average 28 50 90 13 0.6 0.4 1.6 59 42 15 22 21 Average of all 31 51 91 13 \n0.7 0.6 2.7 62 36 16 22 22 Figure 10. Predicate inference results (all numbers are percentages)  aliasing \nand encapsulating predicates held across a wide va\u00adriety of Java programs. Currently Uno requires a signi.cant \namount of memory, both because it is an early prototype and because it uses Soot, which is memory and \ntime intensive. Accordingly, we ran Uno on a multiprocessor (but Uno is only single-threaded) UltraSparc \nIII 750Mhz machine with 72GB of memory. The maximum Java heap size was set to 15GB, although all except \nthe largest benchmarks required less memory. We believe that by switching front-ends and with more engineering \neffort, Uno could run comfortably on commodity hardware. Figure 9 summarizes the characteristics of our \nbenchmark suite and gives the running times for Uno. For each bench\u00admark, we list the size of the bytecode \nin kilobytes, the num\u00adber of non-comment, non-blank lines of code, and the num\u00adber of classes and interfaces. \nIn these and all other counts, we include only code from the benchmarks, although Uno also analyses portions \nof the Java library. The DaCapo suite and three of the SPEC benchmarks, mpegaudio, jack and javac, include \nonly bytecode but no source. Additionally, the Da-Capo benchmarks come in a single large jar .le; we \niden\u00adti.ed the class .les belonging to each benchmark by name, and also included any other classes in \nthe jar .le that are reachable from them based on the compile-time types. This resulted in a different \nnumber of classes and a different byte\u00adcode size for the version (1.8.0.4) of hsqldb in the DaCapo suite \nversus the version we downloaded from SourceForge. Figure 9 also lists the number of methods, constructors, \nand .elds for each benchmark. The right two columns of the .gure give the running time for Uno, as the \naverage of .ve runs. We divide the running time into two parts. The Soot time includes class .le loading \nand conversion into Jimple. The Uno time includes everything else, including computing the class hierarchy \n(we did not use Soot s hierarchy), per\u00adforming the points-to analysis, and resolving the predicates. \nAs these results show, Soot consumes a large fraction of the running time. Figure 10 gives the results \nof running Uno on the bench\u00admarks. For each predicate, we report the percentage of po\u00adsitions for which \nit holds. The exact metric depends on the predicate, as we discuss below. Blank entries indicate there \nare no positions on which to check the predicate. We omit the -IN versions of the predicates, since those \nare included in their non-IN counterparts. For LENTPAR and UNIQPAR, we evaluated the predicates with \nno-.d set to true. We also com\u00adpute the average percentage for each predicate, over each group of benchmarks \nand across the entire benchmark suite. Next we discuss each of the predicates in turn. UNIQRET We report \nwhat percentage of methods (not constructors) return unique objects. We do not include meth\u00adods that \nreturn primitives, void, or String in our count, ei\u00adther in the numerator or the denominator. (Strings \nare im\u00admutable, so their uniqueness is most likely uninteresting.) These results show that on average, \nUno .nds uniqueness of a return value for 31% of the methods, which suggests this property is fairly \ncommon. We examined a selection of the results manually, and found that many of these cases were effectively \nfactories i.e., methods that, at the end, created a new object, initialized it, and returned it. We found \nthat all constructors in our benchmarks returned unique results, al\u00adthough Uno reported that a small \nnumber (0.03% of called constructors) did not due to conservatism in its analysis. LENTPAR We measured \nthe number of non-primitive parameters that Uno determines are lent, for both methods and constructors. \nWe found that 51% of all parameters are lent on average across all of our benchmarks. This result suggests \nthat lending parameters is common, which makes sense if methods typically retained pointers to their \nargu\u00adments, it would complicate local reasoning. In this case, we suspect that LENTPAR is even more common, \nand that con\u00adservatism in our analysis may be causing us to underestimate parameter lending. LENTTHIS \n We counted the number of non-static meth\u00adods (not constructors) whose receiver object is lent. Uno in\u00adfers \nthat this holds on average 91% of the time, and 96% of the time for the SPEC benchmarks. This result \nis to be expected, since it is uncommon for Java methods to capture this, although it does happen in \nsome cases. Examples are code with callbacks, e.g., x.addActionListener(this), or when (non-static) inner \nclass instances are created, since they may refer to the outer class object. UNIQPAR For this predicate, \nwe report the number of non-primitive, unique parameters of methods and construc\u00adtors. We only include \nmethods and constructors that are po\u00adtentially called in the program, according to the compile\u00adtime types, \nsince otherwise UNIQPAR is trivially true. We found that only 13% of parameters are unique. Thus Uno \ndiscovers relatively few possible handoffs of an object from one method to another (one reason UNIQPAR \nmay hold). OWNPAR We counted the number of non-primitive parameters of non-static methods and constructors \nthat are owned. The .rst column lists the fraction for all methods and constructors; the second column \nlists the fraction for only those that are called; and the last column lists the frac\u00adtion for only constructors \nthat are called. Our results show that argument ownership in the strict, monomorphic sense de.ned in \nUno is a fairly rare property, holding for only 2.7% of the constructors called in a program, on average. \nIn Section 5.2, we show some examples of argument ownership that we found, and we examine the causes \nof why ownership does not hold. NESCPAR We found that 62% of method and construc\u00adtor parameters do not \nescape the callee, on average across all benchmarks. NESCPAR is very similar to LENTPAR, except it is \nslightly less restrictive in NESCPAR, a parameter may be written to a .eld as long as that .eld does \nnot escape. Thus the difference between the two, roughly 11% on aver\u00adage for all benchmarks, shows how \noften an argument that is passed to a method may be captured in a non-escaping .eld. 1 public class \nEventWidget extends ... { 2 private AmandaFile .leData; 3 public EventWidget(AmandaFile .leData, ...) \n{ 4 this. .leData = .leData ; 5 slider = buildSlider ( .leData .getNumberOfEvents()); 6 } 7 } 8 public \nclass NuView extends ... { 9 private static .nal 10 JPanel buildMainDisplay (..., AmandaFile .le ,...) \n{ 11 setRange(xMap,.le.getXMin(),.le.getXMax(),halfRange); 12 EventWidget eventWidget = new EventWidget(.le,...); \n13 return panel; 14 } 15 public NuView(String[] args) { 16 AmandaFile .le = openFile(.leName); 17 JPanel \nwidgetPanel = buildMainDisplay(..., .le ,...); 18 } 19 private static .nal AmandaFile openFile(String \n.leName) { 20 AmandaFile .le; 21 if (.leName.startsWith( http :// )) { 22 .le = new AmandaFile(new URL(.leName)); \n23 } else { 24 .le = new AmandaFile(.leName); 25 } 26 return .le ; 27 } 28 } Figure 11. Argument and \n.eld ownership in visad NESCFIELD For this predicate, we restricted our mea\u00ad surement to private .elds, \nsince the predicate trivially does not hold for non-private .elds. We found that about 36% of private \n.elds do not escape. This is another reason argument ownership is rare many objects stored in private \n.elds are considered shared by Uno, rather than encapsulated. OWNFIELD We found that 16% of private \n.elds across our benchmark suite are considered owned by Uno, with a slightly higher percentage in the \nSPEC benchmarks. Re\u00ad call that OWNFIELD is a more restrictive version of NESC- FIELD, since it further \nrequires that objects stored in .elds be unique or only aliased to other owned .elds. Our results show \nthat .eld ownership, while not that common, occurs signi.cantly more often than argument ownership. We \ndis\u00ad cuss some examples of .eld ownership below in Section 5.2. STORE Finally, we measured the number \nof non-static methods and constructors that store their non-primitive, non- String arguments. We count \nboth all such methods and con\u00ad structors and only those that are called. Only around a .fth of called \nmethods store their arguments. 5.2 Examples of Ownership We examined a selection of the ownership results \nmanually to con.rm them and to understand the ownership patterns that Uno discovers. Figure 11 shows \na typical example of argument owner\u00ad ship and .eld ownership, in which an object is generated at a single \nunique return and then reaches a constructor in a few 1 class SynchronizedList extends SynchronizedCollection \n... { 1 2 List list ; 2 3 SynchronizedList(List list ) { 3 4 super(list ); 4 5 this. list = list ; 5 \n6 } 6 7 } 7 8 class SynchronizedCollection implements ... { 8 9 Collection c; 9 10 SynchronizedCollection(Collection \nc) { 11 this.c = c; 12 } 13 } Figure 12. Potential ownership in java.util.Collections 1 2 3 1 public \nclass PEMReader extends ...{ 4 2 private PasswordFinder pFinder; 5 3 6 4 public PEMReader(..., PasswordFinder \npFinder) { 7 5 this (..., pFinder ,...); 8 6 } 9 7 public PEMReader(..., PasswordFinder pFinder, ...) \n{ 10 8 this.pFinder = pFinder; 11 9 } 12 10 } 13 11 public class ReaderTest extends ...{ 14 12 public \nvoid performTest() throws Exception{ 13 PasswordFinder pGet = 14 new Password( secret .toCharArray()); \n15 PEMReader pemRd = new PEMReader(..., pGet); 16 } 17 } Figure 13. Argument and .eld ownership in pooka \nsteps. More precisely, in this code (simpli.ed and with some .elds and methods not shown), Uno reports \nthat openFile on lines 19 27 returns a unique object. This method is called on line 16, and the result \nis passed as argument .le on line 17 to buildMainDisplay. This method in turn invokes some meth\u00ad ods \nof .le that do not capture it (line 11, callee not shown). Then .le is passed to the EventWidget constructor, \nde.ned on lines 3 5, which stores it in a private .eld .leData. Since that .eld is not leaked by the \ncall on line 5 (code not shown), Uno reports that the EventWidget constructor owns its argu\u00ad ment, and \nthat .leData is an owned .eld. In Section 2, we saw a similar example from Soot, in which the path from \nunique return to owning constructor was slightly more convoluted but had the same basic pattern. Most \nof the other cases of ownership that we looked at also fell into this pattern. Another ownership pattern \nthat Uno sometimes .nds in\u00ad volves super or this constructors. Recall from Section 4 that certain predicates \nuse the no-.d .ag to treat super and this constructor calls specially. We added this .ag after running \nUno on some sample classes from the Java standard library. We had expected Uno to infer that the SynchronizedList \ncon\u00ad structor, sketched in Figure 12, owns the list it synchronizes Figure 14. Field ownership in Soot \n public class ASTSynchronizedBlockNode ... {private ValueBox localBox; public void setLocal(Local local){ \nthis.localBox = Jimple.v (). newLocalBox(local); } public Local getLocal() { return (Local) localBox.getValue(); \n }} public .nal class IPAddressGatekeeper ... {private File m databaseFile; private IPAddressGatekeeper \n(String .lename) { m databaseFile = new File(.lename); } private void loadDatabase () {long modi.cationTime \n= m databaseFile.lastModi.ed(); BufferedReader reader; try {reader = new BufferedReader( new FileReader(m \ndatabaseFile)); } catch (IOException e) { ... } } } Figure 15. Field ownership in Middleware access \nto. However, without the no-.d .ag, this turned out to be false, because both the class SynchronizedList \nand its su\u00adperclass, SynchronizedCollection, keep a pointer to the list. Adding the no-.d .ag .xed this \nproblem, allowing both to point to the list and maintain ownership. Ultimately, how\u00adever, Uno still does \nnot infer ownership for this example, be\u00adcause both classes store the Collection in a non-private .eld, \ncausing it to leak. Figure 13 shows a example of argument ownership that Uno does .nd that involves a \ncall to a this constructor. In this code, class PEMReader has two constructors, both with a common PasswordFinder \nargument. One of them simply calls the other one through a this() call (line 5). The other constructor \n(lines 7 9) stores the PasswordFinder argument into a .eld. Uno infers that both constructors own their \nPasswordFinder argument if that argument is unique, which holds because fresh objects are passed in on \nlines 13 and 15. Uno also infers that pFinder is an owned .eld. In general, we found this argument ownership \npattern was uncommon in the cases we examined, which mostly matched the example in Figure 11. We also \nexamined some cases where .eld ownership but not argument ownership held. Figure 14 shows an exam\u00adple \nfrom Soot. On line 4, the .eld localBox is set to the re\u00adsult of calling newLocalBox, which returns a \nunique result. Moreover, the call to getValue on line 7 does not change the uniqueness of localBox, and \nthus that .eld is owned. Figure 15 shows a slightly more complex example from Middleware. Here on line \n4, the .eld m databaseFile is initialized to a fresh object. That .eld has one of its methods invoked \non line 7, and is passed to a constructor on line 11, but neither of those calls affects its uniqueness, \nand thus m databaseFile is owned. Many of the .eld ownership examples we found in our benchmark suite \nwere similar to these examples, where a .eld is initialized to a fresh object locally within a class, \nand then does not escape via method calls of returns. Re\u00adcall that argument ownership requires that arguments \nare unique, which is relatively uncommon. We believe this is why .eld ownership is signi.cantly more \ncommon than ar\u00adgument ownership in our benchmarks local uniqueness of fresh objects is much more likely \nthan a unique argument. 5.3 When Ownership Does Not Hold Finally, we also investigated the reasons that \nownership does not hold in our benchmarks, to try to understand why that property is fairly rare. For \neach predicate, we computed how often its local and non-local conditions were false, thereby causing \nthe predicate to be false. Figure 16 gives the average percentages for several predicates across our \nbenchmarks. For example, condition 2 of OWNPAR, which is UNIQPAR(m, i, false), did not hold 79% of the \ntime, as shown in the upper-left corner of the .gure. Note that to avoid biasing our results by the order \nof the conditions, we computed the truth value of all conditions of a predicate, rather than stopping \nat the .rst one that was false. Thus the columns in Figure 16 can add up to more than 100%, since several \nconditions may be false simultaneously. Looking at the results, we see that OWNPAR is most of\u00adten false \nbecause of conditions 2 and 4 the method or con\u00adstructor does not receive a unique argument, or the method \ndoes not store the argument in one of its .elds. Clearly not storing an argument is a valid reason for \nnot owning it. Note that our STORE predicate is heuristic, because it only checks storing directly via \na .eld or via a super or this call, and it could miss writes to .elds via other means, e.g., calling \na setter method. The other condition, uniqueness of the argument, is more complex. UNIQPAR(m, i, false) \nonly depends on itself (con\u00addition 1) and UNIQPAR-IN for regular (condition 2, called with no-.d set \nto true) and super or this calls (condition 3, called with no-.d set to false). Following condition (2) \nfur\u00adther, we see that calls to UNIQPAR-IN(..., true) fail for a variety of reasons. Most often they fail \nbecause of local con\u00addition L3, i.e., the argument in question is live after the call. Local conditions \nL1 and L4 (the value is BAD or stored in a .eld) also contribute somewhat to non-uniqueness of argu\u00adments. \nThe last major reason UNIQPAR-IN fails to hold is because the argument is either a non-unique parameter \nfrom the caller (condition 1) or a non-unique return value from another call inside this method (condition \n2). Looking at our other ownership predicate, OWNFIELD, we see that it fails most often because NESCFIELD \n(condi\u00adtion 1) is false, and almost as often because of OWNFIELD-IN (condition 2). For the latter, we \ncan see that condi\u00adtion 1, having a non-unique parameter stored in a .eld, is the most common cause the \npredicate fails to hold. Thus again, uniqueness is a key culprit in lack of ownership. Note that in computing \nthe percentages for OWNFIELD-IN, we measure over all .elds and all methods, including methods that do \nnot use a particular .eld. This lowers the percentages by a constant factor compared to the other predicates, \nbut does not change the relative magnitudes within the histogram. Lastly, examining NESCFIELD, we ignore \ncondition L1, that the .eld is private, in our measurements. Thus we con\u00adcentrate on condition 1, NESCFIELD-IN. \nWe can see that the latter predicate fails for a wide variety of reasons, all roughly equally common. \nIndeed, the only uncommon conditions to fail are condition L3, a .eld potentially being accessed from \nanother instance of the same class, and condition 3, param\u00adeter capture by a this or super call. Note \nwe have the same measurement issue with NESCFIELD-IN as OWNFIELD-IN, making the percentages low but not \nchanging the relative magnitudes in the histogram. It is important to recognize that these results only \napprox\u00adimate the reasons ownership fails for example, we mea\u00adsure when UNIQPAR-IN is false over all combinations \nof the predicate, not just the ones that cause OWNPAR to be false. However, they do provide some insight. \nAlmost 80% of non-primitive method and constructor arguments are not stored according to Uno, and so \nclearly they are not owned. One future direction would be implementing a more com\u00adplete must-store analysis, \nto .nd out how many methods truly store their arguments. However, it makes sense that storing arguments \nis not a property that holds for most pa\u00adrameters, since that would complicate local reasoning. Stor\u00ading \nan argument should happen most often for constructors and methods that create fresh objects. Uniqueness \nis the other major culprit in preventing own\u00adership, and one way to increase the opportunities for owner\u00adship \nmay be to improve the precision of the uniqueness anal\u00adysis. Another approach may be to relax the uniqueness \nre\u00adquirement, e.g., by allowing polymorphic ownership so that an owned object can be pointed to by a \n.eld of more than one object. We ran an additional experiment in which we re\u00admoved the UNIQPAR requirement \n(condition 2) from OWN-PAR, and we found this resulted in nearly 20% of the param\u00adeters of called constructors \nbeing owned, as opposed to the 2.7% result with uniqueness. This is a coarse upper bound on how improved \nuniqueness analysis might improve inference of owned arguments, and we leave pursuing this further as \nan interesting direction for future work. 5.4 Threats to Validity There are a number of potential threats \nto the validity of our evaluation. First, our selection of benchmarks could be un\u00adrepresentative, and \nmight be missing certain coding styles that would cause Uno to behave differently. We have tried to address \nthis by applying Uno to a wide variety of applica\u00adtions, include several that are large enough that they \nshould contain many interesting coding patterns. Second, our algorithm for inferring uniqueness and own\u00adership \nmay not be sound. We have high con.dence that the points-to analysis is correct, because that problem \nhas been well-studied, and our analysis is similar to proven ap\u00adproaches. It is harder to be certain \nthat the speci.cation of our uniqueness and ownership predicates is correct and that there are zero implementation \nbugs. We have tried to address this both by testing Uno on our own small examples and by verifying a \nselection of Uno s ownership and uniqueness re\u00adsults on our benchmark suite manually. We leave a formal \nproof of correctness as future work. Lastly, and perhaps most importantly, our de.nitions of uniqueness \nand ownership might not match a programmer s. Hence we might either report ownership and uniqueness that \nis not interesting, or we might fail to .nd useful in\u00adstances of ownership and uniqueness. Indeed, our \nexperi\u00adments show that OWNFIELD sometimes holds, and OWN-PAR rarely holds. We believe that using a more \nsophisticated uniqueness analysis may increase the amount of ownership we discover in programs, and we \nleave that challenge to fu\u00adture work. 6. Related Work Many researchers have studied encapsulation in \nobject\u00adoriented languages. Islands [18] and Balloons [3] allow ob\u00adjects to be fully encapsulated. Clarke \net al [11, 12] and Boy\u00adapati et al [6] propose ownership type systems that statically enforce encapsulation. \nThese systems allow rich ownership patterns, including owner parameterization and weakening ownership \nfor inner classes, neither of which is supported by Uno. The key difference between these systems and \nUno is that Uno performs inference and can therefore be applied to existing Java programs, whereas the \nother systems require often extensive user annotations. AliasJava [2] is a dialect of Java that includes \nannota\u00adtions for uniqueness, ownership, and allows classes to be parameterized by owners. AliasJava s \nannotations are stat\u00adically checked, and Aldrich et al report on case studies in which annotations were \nsuccessfully added by hand to Java programs [2]. AliasJava also includes polymorphic annota\u00adtion inference, \nbut the only reported results are for toy pro\u00adgrams and for the Java standard library; and the library \nre\u00adsults are not reported very precisely. We show that Uno can infer uniqueness and ownership on a wide \nvariety of Java programs, and we report summary statistics of uniqueness and ownership properties, which \ncomplements case studies. Liu and Milanova [22] present static analyses for in\u00adferring ownership and \nimmutability in Java. Their owner\u00adship inference algorithm constructs a may points-to graph and then \nuses that to approximate the run-time domina\u00adtor relationship among objects. Liu and Milanova .nd that \n28% of the reference-valued instance .elds are owned across their benchmark suite. As discussed earlier, \nUno .nds that roughly 16% of private, reference-valued .elds are owned. The cause of the difference between \nthe two results is un\u00adclear. It may be due to variations in the de.nition of owner\u00adship or due to measurement \ntechniques. One key difference between the Liu and Milanova approach and Uno is that they infer only \n.eld ownership, whereas Uno infers many other related properties, including argument ownership, unique\u00adness, \nand lending, which their system cannot reason about. Cherem and Rugina [9] present a lightweight escape \nand effects analysis for Java. Among other things, their analy\u00adsis computes which parameters are lent \nto methods (69% on average), similar to LENTPAR, and what methods return fresh objects (43% on average), \nsimilar to UNIQRET. Both percentages were measured on the GNU Classpath library. These numbers are not \nthat close to Uno s averages of 51% and 31%, respectively, but it is unclear whether this is a sig\u00adni.cant \ndifference, since the GNU library s aliasing behavior might be different than aliasing in other programs. \nIn follow-up work, Cherem and Rugina develop a .eld uniqueness analysis for object reclamation in Java. \nThey .nd that approximately 22% of .elds in the SPEC benchmark suite are unique [10]. This corresponds \nclosely to our result that 20% of .elds in the SPEC benchmark suite are owned. These two properties seem \nto be closely related, suggesting that notions of ownership may be useful in a wide variety of applications \nin addition to program understanding. Con.ned types [30] operate at a coarser granularity than the systems \ndiscussed so far. In this approach, static check\u00ading ensures that con.ned types are not exposed outside \nof their packages. Grothoff et al [16] present an inference algo\u00adrithm for con.ned types, and show that \nover a wide range of benchmarks, many classes can be marked as con.ned. This system is signi.cantly more \nscalable than Uno, but also pro\u00advides much coarser information about encapsulation. Heine and Lam [17] \npresent Clouseau, a static analy\u00adsis for .nding memory that leaks in C and C++ programs. Clouseau reports \na leak when the owning pointer of an ob\u00adject is discarded before the object is freed. In this system, \nan owner has the responsibility to free an object, but does not necessarily have the only pointer to \nit. In contrast, in Uno, owned objects must be encapsulated inside of their owner. Uniqueness also has \na long research history. Uniqueness is closely related to linear types, which can be used to rea\u00adson \nprecisely about aliasing in programs [28, 31]. Several re\u00adsearchers have studied making uniqueness and \nlinear types easier to use at the language level [1, 7, 8, 15]. These systems allow a more .exible interpretation \nof uniqueness than Uno, but mostly focus on checking annotations, and inference is not available for \nobject-oriented languages. Finally, alias analysis has been extensively studied in the research literature \n[13, 14, 19, 20, 21, 25, 26, 27, 32] (to name only a few). Our alias analysis is similar to existing \nsystems, but is tuned for inferring Uno s predicates. 7. Conclusion We have presented a new technique \nfor automatically in\u00adferring aliasing and encapsulation in Java programs. Our analysis begins with an \nintraprocedural points-to analysis that tracks local variables .ow-sensitively, and summarizes .elds, \nexternal data, and method calls .ow-insensitively. We then perform a demand-driven, interprocedural algorithm \nto resolve predicates that describe aliasing and encapsulation of method and constructor arguments and \nreturn values, and .elds. To test our ideas, we developed a tool called Uno that implements our analysis \nand applied it to a number of Java applications. Uno discovered many lent method arguments, a moderate \nnumber of unique arguments and results, some .eld ownership, and occasional argument ownership. We be\u00adlieve \nthat Uno is the .rst ownership and uniqueness infer\u00adence tool that has been demonstrated on a wide variety \nof Java applications. Acknowledgments We would like to thank Nicholas Chen, Bin Zhao, and Taiga Nakamura \nfor working on predecessors to Uno. We would also like to thank Mike Hicks and the anonymous reviewers \nfor helpful comments on an earlier version of this paper. This research was supported in part by NSF \nCCF-0346982 and CCF-0430118. References [1] A. Aiken, J. S. Foster, J. Kodumal, and T. Terauchi. Checking \nand Inferring Local Non-Aliasing. In PLDI 03, pages 129 140, 2003. [2] J. Aldrich, V. Kostadinov, and \nC. Chambers. Alias Anno\u00adtations for Program Understanding. In OOPSLA 02, pages 311 330, 2002. [3] P. \nS. Almeida. Balloon Types: Controlling Sharing of State in Data Types. In ECOOP 97, pages 32 59, 1997. \n[4] K. Arnold, J. Gosling, and D. Holmes. The Java Program\u00adming Language. Addison-Wesley, 3rd edition, \n2000. [5] S. M. Blackburn, R. Garner, C. Hoffman, et al. The DaCapo benchmarks: Java benchmarking development \nand analysis. In OOPSLA 06, pages 169 190, 2006. [6] C. Boyapati, B. Liskov, and L. Shrira. Ownership \nTypes for Object Encapsulation. In POPL 03, pages 213 223, 2003. [7] J. Boyland. Alias burying: Unique \nvariables without destructive reads. Software Practice and Experience, 31(6):533 553, May 2001. [8] \nJ. T. Boyland and W. Retert. Connecting effects and uniqueness with adoption. In POPL 05, pages 283 295, \n2005. [9] S. Cherem and R. Rugina. A Practical Escape and Effect Analysis for Building Lightweight Method \nSummaries. In CC 07, 2007. [10] S. Cherem and R. Rugina. Uniqueness inference for compile\u00adtime object \ndeallocation. In ISMM 07, 2007. To appear. [11] D. G. Clarke and S. Drossopoulou. Ownership, Encapsulation \nand the Disjointness of Type and Effect. In OOPSLA 02, pages 292 310, 2002. [12] D. G. Clarke, J. M. \nPotter, and J. Noble. Onwership Types for Flexible Alias Protection. In OOPSLA 98, pages 48 64, 1998. \n[13] M. Das. Uni.cation-based Pointer Analysis with Directional Assignments. In PLDI 00, pages 35 46, \n2000. [14] M. Emami, R. Ghiya, and L. J. Hendren. Context-Sensitive Interprocedural Points-to Analysis \nin the Presence of Func\u00adtion Pointers. In PLDI 94, pages 242 256, 1994. [15] M. F\u00a8ahndrich and R. DeLine. \nAdoption and Focus: Practical Linear Types for Imperative Programming. In PLDI 02, pages 13 24, 2002. \n[16] C. Grothoff, J. Palsberg, and J. Vitek. Encapsulating Objects with Con.ned Types. In OOPSLA 01, \npages 241 253, 2001. [17] D. L. Heine and M. S. Lam. Static Detection of Leaks in Polymorphic Containers. \nIn ICSE 06, pages 252 261, 2006. [18] J. Hogg. Islands: Aliasing Protection In Object-Oriented Languages. \nIn OOPSLA 91, pages 271 285, 1991. [19] W. Landi and B. G. Ryder. A Safe Approximate Algorithm for Interprocedural \nPointer Aliasing. In PLDI 92, pages 235 248, 1992. [20] O. Lhot\u00b4ak and L. J. Hendren. Jedd: A BDD-based \nrelational extension of Java. In PLDI 04, pages 158 169, 2004. [21] D. Liang and M. J. Harrold. Ef.cient \nComputation of Parametrized Pointer Information for Interprocedural Analy\u00adses. In SAS 01, pages 279 298, \n2001. [22] Y. Liu and A. Milanova. Ownership and Immutability Inference for UML-based Object Access Control. \nIn ICSE 07, pages 323 332, 2007. [23] V. B. Livshits, J. Whaley, and M. S. Lam. Re.ection Analysis for \nJava. In APLAS 05, pages 139 160, 2005. [24] J. Noble, J. Vitek, and J. Potter. Flexible Alias Protection. \nIn ECOOP 98, pages 158 185, 1998. [25] A. Rountev and B. G. Ryder. Points-to and Side-Effect Analyses \nfor Programs Built with Precompiled Libraries. In CC 01, pages 20 36, 2001. [26] A. Salcianu and M. C. \nRinard. Pointer and escape analysis for multithreaded programs. In PPOPP 01, pages 12 23, 2001. [27] \nM. Sridharan and R. Bodik. Re.nement-Based Context-Sensitive Points-To Analysis for Java. In PLDI 06, \npages 387 400, 2006. [28] D. N. Turner, P. Wadler, and C. Mossin. Once upon a type. In FPCA 95, pages \n1 11, La Jolla, California, 1995. [29] R. Vall\u00b4ee-Rai, P. Co, E. Gagnon, L. J. Hendren, P. Lam, and V. \nSundaresan. Soot -a Java bytecode optimization framework. In CASCON 99, 1999. [30] J. Vitek and B. Bokowski. \nCon.ned types in java. Software Practice and Experience, 31(6):507 532, 2000. [31] D. Walker and G. Morrisett. \nAlias Types for Recursive Data Structures. In TIC 00, 2000. [32] J. Whaley and M. S. Lam. Cloning-Based \nContext-Sensitive Pointer Alias Analysis Using Binary Decision Diagrams. In PLDI 04, pages 131 144, 2004. \n\t\t\t", "proc_id": "1297027", "abstract": "<p>There are many proposals for language techniques to control aliasing and encapsulation in object oriented programs, typically based on notions of object ownership and pointer uniqueness. Most of these systems require extensive manual annotations, and thus there is little experience with these properties in large, existing Java code bases. To remedy this situation, we present Uno, a novel static analysis for automatically inferring ownership, uniqueness, and other aliasing and encapsulation properties in Java. Our analysis requires no annotations, and combines an intraprocedural points-to analysis with an interprocedural, demand-driven predicate resolution algorithm. We have applied Uno to a variety of Java applications and found that some aliasing properties, such as temporarily lending a reference to a method, are common, while others, in particular field and argument ownership, are relatively uncommon. As a result, we believe that Uno can be a valuable tool for discovering and understanding aliasing and encapsulation in Java programs.</p>", "authors": [{"name": "Kin-Keung Ma", "author_profile_id": "81100447919", "affiliation": "University of Maryland, College Park, MD", "person_id": "P905211", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey S. Foster", "author_profile_id": "81338488852", "affiliation": "University of Maryland, College Park, MD", "person_id": "PP39087107", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297059", "year": "2007", "article_id": "1297059", "conference": "OOPSLA", "title": "Inferring aliasing and encapsulation properties for java", "url": "http://dl.acm.org/citation.cfm?id=1297059"}