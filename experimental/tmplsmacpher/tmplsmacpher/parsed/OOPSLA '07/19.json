{"article_publication_date": "10-21-2007", "fulltext": "\n Modular Veri.cation of Higher-Order Methods with Mandatory Calls Speci.ed by Model Programs Steve M. \nShaner Gary T. Leavens Iowa State University, Ames, IA 50011 USA {smshaner, leavens}@cs.iastate.edu \nAbstract What we call a higher-order method (HOM) is a method that makes mandatory calls to other dynamically-dispatched \nmethods. Examples include template methods as in the Tem\u00adplate method design pattern and notify methods \nin the Ob\u00adserver pattern. HOMs are particularly dif.cult to reason about, because standard pre-and postcondition \nspeci.ca\u00adtions cannot describe the mandatory calls. For reasoning about such methods, existing approaches \nuse either higher\u00adorder logic or traces, but both are complex and verbose. We describe a simple, concise, \nand modular approach to specifying HOMs We show how to verify calls to HOMs and their code using .rst-order \nveri.cation conditions, in a sound and modular way. Veri.cation of client code that calls HOMs can take \nad\u00advantage of the client s knowledge about the mandatory calls to make strong conclusions. Our veri.cation \ntechnique val\u00adidates and explains traditional documentation practice for HOMs, which typically shows \ntheir code. However, speci\u00ad.cations do not have to expose all of the code to clients, but only enough \nto determine how the HOM makes its manda\u00adtory calls. Categories and Subject Descriptors D.2.1 [Software \nEn\u00adgineering]: Requirements/Speci.cations languages, me\u00adthodologies; D.2.4 [Software Engineering]: Software/Pro\u00adgram \nVeri.cation correctness proofs, formal methods, programming by contract; D.3.3 [Programming Languag\u00ades]: \nLanguage Constructs and Features classes and ob\u00adjects, control structures, frameworks, procedures, functions, \nand subroutines; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about \nPrograms Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n07, October 21 25, 2007, Montr\u00e9al, Qu\u00e9bec, Canada. Copyright c .2007 ACM 978-1-59593-786-5/07/0010. . \n. $5.00 David A. Naumann Stevens Institute of Technology, Hoboken, NJ 07030 USA naumann@cs.stevens.edu \nassertions, logics of programs, pre-and post-conditions, speci.cation techniques. General Terms Languages, \nVeri.cation Keywords Model program, veri.cation, speci.cation lan\u00adguages, grey-box approach, higher order \nmethod, mandatory call, Hoare logic, re.nement calculus. 1. Introduction No program exists in a vacuum. \nInstead, developers use components from libraries and frameworks. For example, a Java programmer may \nuse Swing, Java s input/output frame\u00adwork, and Jakarta Commons. Such reuse improves produc\u00adtivity. It \ncan also improve other attributes of software, such as its performance or maintainability. The importance \nof reusable OO components is both a challenge and opportunity for software engineering. It is an opportunity \nbecause better documentation of such compo\u00adnents can payoff in productivity and quality. In this paper \nwe focus on some of reuse s technical chal\u00adlenges, namely the speci.cation language design and ver\u00adi.cation \nchallenges posed by higher-order methods. For us, the term higher-order method (HOM) means a method whose \nrequirements include one or more mandatory calls. A mandatory call is a method call that must occur under \ncertain speci.ed conditions. The HOM s speci.cation de\u00adscribes how it sequences these mandatory calls, \nand in what states these calls are made. A HOM may also make calls that are not mandatory. Reasoning \nabout HOMs is a long-standing hard problem [25, 42]. Our contribution is a practical technique that builds \non the grey-box approach [7, 8, 9]. We show its practical\u00ad ity for sequential Java programs by integrating \nit with JML [24, 29], and by showing how to do modular reasoning sim\u00ad ply. For veri.cation of client \ncode, we show how the use of a copy rule [33] in conjunction with grey-box speci.cations allows one to \ndraw strong conclusions. Our veri.cation tech\u00adniques are explained using a Hoare logic, and we give a \nnew soundness proof. Remarkably, re.nement style reasoning is not needed to use the grey-box approach, \nthough re.nement is used in our soundness proof. In what follows we .rst give more details on the problem. \nOur solution approach is described in Section 3. Section 4 formalizes our approach and gives a soundness \nproof. After that, we discuss other issues, future work, and conclude. 2. The Problem Several standard \nand important examples of HOMs are found in common design patterns [18]. These include: The Notify method \nof the Observer pattern, which makes mandatory calls to the Update method in each observer object.  \nThe kind of method described by the Template Method pattern, which makes mandatory calls to several abstract \nprimitive operation methods in some particular order.  The HandleRequestmethod of the Chain of Respon\u00adsibility \npattern, which, if it cannot directly handle a re\u00adquest, makes a mandatory call to the next such method. \n(This illustrates that such mandatory calls need not hap\u00adpen in every execution, despite the name.) \n In addition, clients of methods found in behavioral design patterns are often HOMs that make mandatory \ncalls to the pattern s methods. This includes callers of: the Interpret method in the Interpreter pattern, \nthe Execute method in the Command pattern, the Handle method in the State pattern, the Accept method \nin the Visitor pattern, and the strategy method in a strategy object. As can be seen from the above examples, \ntypically a mandatory call is both dynamically-dispatched and calls a method with a weak speci.cation. \nA method speci.cation is weak if it does not completely describe the state transfor\u00admation that the caller \nof the HOM cares about, but instead only states some limited property (such as that a manda\u00adtory dynamic \ncall will terminate, or that it does not write to certain .elds). For example, in a Java implementation \nof the Observer pattern, the actionPerformed method of a Listener, which corresponds to the Update method \nof an observer, has such a weak speci.cation, which al\u00adlows Listener objects to perform many different \ntasks. The code sequencing calls to such methods thus has very weak dependencies on their effects. Mandatory \ncalls will typi\u00adcally be dynamically dispatched, because they will typically be calls to abstract methods. \nFor example, the call to the actionPerformed method of a Listener object will be dynamically dispatched. \n2.1 Client Reasoning Because the mandatory calls of a HOM typically have weak speci.cations, the HOM \ns speci.cation will typically not be suf.cient for client-side reasoning. That is, if a client wants \nto know that a call to a HOM accomplishes some speci.c state transformation, then the HOM s weak speci.cation \nwill generally not be enough to prove what the client wants. As an example of this problem and of the \nproblem of integrating with an interface speci.cation language such as JML, we show a very simple instance \nof the Observer pat\u00adtern. First, consider the class Counter, shown in Figure 1, whose HOM bump is to \nbe observed, and which holds a single listener to observe it. This class declares two private .elds, \ncount and lstnr. The JML annotations declare both .elds to be spec_public, meaning that they can be used \nin public speci.cations [26]. The .eld count is the main state in counter objects. The .eld lstnr holds \na possibly null Listener object.1 Counter s register method has a Hoare-style speci.cation. The precondition \nis omitted, since it is just true. Its assignableclause gives a frame axiom, which says that it can only \nassign to the .eld lstnr. Its postcondition is given in its ensures clause. The .gure does not specify \nthe HOM bump, as a major part of the problem is how to specify such methods. public class Counter { private \n/*@ spec_public @*/ int count = 0; private /*@ spec_public nullable @*/ Listener lstnr = null; /*@ assignable \nthis.lstnr; @ ensures this.lstnr == lnr; @*/ public void register(Listener lnr) { this.lstnr = lnr; } \n public void bump() { this.count = this.count+1; if (this.lstnr != null){ this.lstnr.actionPerformed(this.count); \n} } } Figure 1. A Java class with JML speci.cations. JML spec\u00adi.cations are written as annotation comments \nthat start with an at-sign (@), and in which at-signs at the beginnings of lines are ignored. The speci.cation \nfor method register is written before its header. The interface Listener, speci.ed in Figure 2, con\u00ad \ntains a very weak speci.cation of its actionPerformed method. Counter s bump method noti.es a listener \nby calling actionPerformed. Its speci.cation is weak be\u00adcause it has no pre-and postconditions. The only \nthing con\u00adstraint on its actions is given by the speci.cation s assignable clause. This clause names \nthis.objectState, which is a datagroup de.ned for class Object. A datagroup is a de\u00adclared set of .elds \nthat can be added to in subtypes [29, 31]. The class LastVal, speci.ed in Figure 3 is a subtype of Listener. \nObjects of this type track the last value 1 In JML .elds are automatically speci.ed to be non-null by \ndefault [11, 29], so nullablemust be used in such cases. public interface Listener { //@ assignable \nthis.objectState; void actionPerformed(int x); } Figure 2. Speci.cation of the interface Listener. passed \nto their actionPerformed method in the .eld val. This .eld is placed in the objectState datagroup by \nthe in clause following the .eld s declaration. Making vala member of the objectStatedatagroup allows \nthe actionPerformedmethod to update it [29, 31]. Objects of this class also have a method getVal, which \nallows Java code to access the .eld s value. public class LastVal implements Listener { private /*@ spec_public \n@*/ int val= 0; //@ in objectState; /*@ also @ assignable this.objectState; @ ensures this.val == x; \n@*/ public void actionPerformed(int x) { this.val = x; } //@ ensures \\result == this.val; public /*@ \npure @*/ int getVal() { return this.val; } } Figure 3. The JML speci.cation of LastVal. With these pieces \nin place, we can now show a typical example of client reasoning with the observer pattern. Con\u00adsider \nthe code in Figure 4. This code creates a LastVal object lv and a Counter object c. It passes lv to c \nby calling c s registermethod. Hence, as the second asser\u00adtion states, the lstnr.eld of the Counterobject \ncholds lv. This sets the stage for calling c s HOM bump. LastVal lv = new LastVal(); //@ assert lv != \nnull &#38;&#38; lv.val == 0; Counter c = new Counter(); c.register(lv); //@ assert c.lstnr == lv &#38;&#38; \nlv != null; //@ assert c.count == 0; c.bump(); //@ assert lv.val == 1; Figure 4. A Java example that \ndraws a strong conclusion (the assertion in the last line) about a call to the HOM bump. The call to \nbump increments c s count .eld to 1, and then passes 1 to lv s actionPerformed method. This causes lv \nto store 1 in its .eld val, which makes the last assertion in Figure 4 hold. The problem we address is \nhow to write modular speci.cations that enable modular and static veri.cation of such assertions. For \nproving the last assertion in Figure 4, a normal Hoare\u00ad style speci.cation for Counter s method bump, \nsuch as the one shown in Figure 5, is not suf.cient. The problem //@ assignable this.count, lstnr.objectState; \n//@ ensures this.count == \\old(this.count+1); public void bump(); Figure 5. A standard JML speci.cation \nfor bump. with using Figure 5 to prove assertions like the last one in Figure 4 is that Figure 5 does \nnot say anything about the particular state change that may occur in the lstnrobject. Furthermore, a \n.rst-order speci.cation like this has no way to even say that the mandatory call is made. Proving such \nan assertion requires that the speci.cation talk about the mandatory call and that there is some way \nto use the speci.cation from LastVal to reason about that call. Thus bumpmust be speci.ed so that the \ncaller can use a speci.cation like the one in LastVal, even though mod\u00adularity prohibits Counter from \nknowing anything about LastVal.  2.2 Related Work Several solutions to this problem of how to modularly \nrea\u00adson about HOMs have appeared previously in the literature, albeit not dealing with OO issues like \nbehavioral subtyping. Ernst, Navlakha, and Ogden [15] use higher-order logic to handle such problems. \nAs shown in Figure 6, one would use pre and post to refer to the pre-and postcondi\u00adtions of called methods.2 \nHowever, this technique makes bump s speci.cation more complex and involved than its /*@ requires this.lstnr \n!= null @ ==> this.lstnr.actionPerformed @.pre(this.count); @ assignable this.count, this.lstnr.objectState; \n@ ensures this.lstnr != null @ ==> (this.count == \\old(this.count+1) @ &#38;&#38; this.lstnr.actionPerformed \n@.post(\\old(this.count), @ this.count)); @*/ public void bump(); Figure 6. A speci.cation in the style \nof Ernst, et al. [15] for bump. code. Furthermore, veri.cation takes place in a higher-order logic, since \nthe speci.cation of bumptakes a description of actionPerformed as a parameter, and thus quanti.es over \nfunction or predicate symbols. This makes automated veri.cation dif.cult, as most theorem provers for \nhigher\u00adorder logic are interactive. Besides these shortcomings, their work does not technically require \nthe function object to be called by an implementation, only that the effect speci.ed by the parameter \nbe achieved. 2 Similarly, Damm and Josko [12] allow use of Hoare triples as predicates on procedure parameters. \nFindler and Felleisen also use higher-order logic to de\u00adscribe higher-order contract checking [16]. Their \ncontract language is able to express contracts for HOMs, including examples such as the Observer pattern. \nHowever, they focus on techniques for producing helpful error messages (blame assignment) and run-time \nchecking of contracts. Thus, in comparison to our work, they have a more complex language for HOM contracts \nand they do not investigate static veri.c\u00adtion (such as how do draw strong conclusions about calls to \nHOMs). Soundarajan and Fridella [42] solve the problem of mak\u00ad ing sure that a higher order method actually \nmakes the mandatory calls by writing speci.cations that track a trace of method calls. For example, Counter \ns bump method could be speci.ed in their style as shown in Figure 7. In this .gure, the trace, t has \none element, which is a call to lstnr s actionPerformedmethod (which would have to be declared as a hook \nmethod , hence the notation .hm for retrieving the name of this method from the trace). Us\u00ading Soundarajan \nand Fridella s Enrichment Rule (R2), one can prove assertions like the last one in Figure 4, by using \nknowledge of the value of the .eld lstnr, and the spec\u00adi.cation in LastVal. However, writing such trace-based \nepre.Counter.bump()= [t = o] epost.Counter.bump()= [(this.lstnr null). = ((|t |=1) . (t [1].hm = this.lstnr.actionPerformed))] \n.[(this.lstnr = null). t = o] Figure 7. A speci.cation in the style of Soundarajan and Fridella [42] \nfor bump. speci.cations is still not very intuitive for programmers, es\u00adpecially when they involve sequencing \nseveral calls. Also, reasoning about such speci.cations involves intricate proofs about traces. For example, \nSoundarajan and Fridella s paper spends about 8 pages to describe a case study of specifying and verifying \na single HOM (for bank accounts) [42, pages 321 329]. B\u00fcchi and Weck s grey-box approach [7, 8, 9], is \na sim\u00ad pler way to specify such HOMs. We build on and adapt their work in this paper, integrating it \nwith JML. In their work, speci.cations of HOMs are written as abstract pro\u00adgrams, which in JML are called \nmodel programs. A model program exposes information about the method s mandatory calls, while hiding \nsome details. Details can be hidden by using speci.cation statements in the model program to de\u00adscribe \nthe effect of the hidden code. As we will show, the resulting sequence of hidden behaviors and exposed \nmanda\u00adtory calls allows variation in implementations while permit\u00adting clients to draw strong conclusions. \nB\u00fcchi and Weck also did not explain a practical technique for verifying that an im\u00adplementation of a \nHOM satis.es a model program speci.ca\u00adtion, nor did they give a veri.cation rule for client reason\u00ading. \nOur paper s contribution is a solution to these technical problems, a new soundness proof, and a practical \nadaptation to JML. Barnett and Schulte [5] support run-time veri.cation of model programs in the .NET \nenvironment. Their model pro\u00adgrams are similar to ours in spirit, although expressed in AsmL. Their work, \nlike ours, addresses the speci.cation and checking of HOMs with mandatory calls. Their contribution is \na technique for checking conformance of a running im\u00adplementation, even when the speci.cation may involve \nnon\u00addeterminism. For simplicity, in this paper we only consider model programs with limited syntactic \nsupport for nonde\u00adterminism, although it is present, due to the ability to write speci.cation statements. \nFinally, instead of run-time check\u00ading we seek to provide static guarantees.  3. Solution Approach \nOur solution approach relies on grey-box, model program speci.cations [7, 8, 9] and uses a copy rule \n[33] to reason about calls to HOMs speci.ed with model programs. A model program speci.cation for Counter \ns HOM bumpis shown in Figure 8. In this .gure, the publicmodi\u00ad /*@ public model_program { @ @ normal_behavior \n@ assignable this.count; @ ensures this.count == \\old(this.count+1); @ @ if (this.lstnr != null) { @ \nthis.lstnr.actionPerformed(this.count); @ } @} @*/ public void bump(); Figure 8. Model program that \nspeci.es the mandatory call to the actionPerformedmethod. .er says that this speci.cation is intended \nfor client use [26]. The keyword model_programintroduces the model pro\u00adgram. Its body contains a statement \nsequence consisting of a speci.cation statement followed by an if-statement. The speci.cation statement \nstarts with normal_behavior and includes the assignable and ensures clauses. Speci.cation statements \ncan also have a requiresclause, which would give a precondition; in this example the precon\u00addition defaults \nto true. A speci.cation statement describes the effect of a piece of code that would be used at that \nplace in an implementation. Such a piece of code can assume the precondition and must establish the postcondition, \nassigning only to the datagroups permitted by its assignable clause. Thus speci.cation statements can \nhide implementation de\u00adtails and make the model program less speci.c. Although the example uses a speci.cation \nstatement in a trivial way, they can be used to abstract arbitrary pieces of code, and have been used \nto do so in the re.nement calculus [2, 34]. Our approach prescribes how to do two veri.cation tasks: \n Veri.cation that a HOM implementation satis.es a model program speci.cation. Our approach imposes veri.ca\u00adtion \nconditions on the code by .rst matching the code against the model program, which yields a set of veri.\u00adcation \nconditions for parts of the code that implement the model program s speci.cation statements.  Veri.cation \nof calls to HOMs speci.ed with model pro\u00adgrams. Our approach uses a veri.cation rule that copies the \nmodel program to the call site, with appropriate sub\u00adstitutions. The caller can then draw strong conclusions \nusing a combination of the copied speci.cation and the caller s knowledge of the program s state at the \ncall site. In particular, at the site of the mandatory calls made by the substituted model program, the \nclient may know more speci.c types of such calls receivers. These more speci.c receiver types may have \nstronger speci.cations, which client reasoning can exploit.  3.1 Verifying Implementations Veri.cation \nof implementation code takes place in two steps. The .rst step is matching, which checks whether code \nhas the form speci.ed by the model program. The matching we use in verifying that code satis.es a model \nprogram is simple, requiring exact matches except where the model program contains a speci.cation statement. \nA speci.cation statement can only be matched by a refining statement, which must have the same speci.cation \nas the speci.cation statement. In our example, bump s code in Figure 9 matches the model program in Figure \n8. This is because the refining statement in the code matches the speci.cation statement in the model \nprogram, and the call to actionPerformedin the code matches the same (mandatory) call in the model program. \nThus each piece of the code matches a correspond\u00ading piece of the model program. Note that bump s code \nin Figure 1 does not match, since it has no re.ning statement. public /*@ extract @*/ void bump() { /*@ \nrefining normal_behavior @ assignable this.count; @ ensures this.count == \\old(this.count+1); @*/ this.count \n= this.count+1; if (this.lstnr != null){ this.lstnr.actionPerformed(this.count); } } Figure 9. Code matching \nthe model program speci.ca\u00adtion for Counter s actionPerformed method. The extractsyntax is explained \nin Section 3.3. The second stage is a proof that each re.ning statement in the code implements its speci.cation. \nThat is, one must check that, assuming the speci.cation statement s precondi\u00adtion, the body of the re.ning \nstatement achieves the speci.\u00adcation s postcondition and only assigns to the .elds permit\u00adted by its \nframe. Since all other matches are exact, this is suf.cient to show that the code must re.ne the model \npro\u00adgram. It also ensures that the mandatory calls occur in the implementation in the speci.ed states. \nIn our example, the speci.cation statement has no pre\u00adcondition, and so one simply has to prove that \nthe code s assignment this.count = this.count+1 meets the postcondition and only assigns to this.count. \nThis proof is straightforward. Despite its simplicity, our technique is practical. In par\u00adticular, it \nallows programmers to trade the amount of ef\u00adfort they invest in speci.cation and veri.cation for .exibility \nin maintenance. Programmers writing abstract speci.cations that hide some details gain the ability to \nchange code that implements those speci.cations. Conversely, programmers can choose to avoid most of \nthe overhead of speci.cation and veri.cation and simply use the code for a HOM as a (white-box) speci.cation, \nwith the obvious loss of .exibility in maintenance. The only details that our technique forces programmers \nto reveal are the mandatory calls for which client-side reasoning is to be enabled and the control struc\u00adtures \nsurrounding such calls. For all other details the choice is left to them and is not dictated by our technique. \n 3.2 Client Reasoning Our technique for veri.cation of calls to HOMs with model program speci.cations, \nclient reasoning, can reach strong conclusions without the use of higher-order logic or traces in speci.cations. \nAs mentioned above, it uses a copy rule [33], in which the body of the model program speci.cation is \nsubstituted for the HOM call at the call site, with appropriate substitutions.3 For example, to reason \nabout the call to c.bump() in Figure 4, one copies the body of the model program speci\u00ad .cation to the \ncall site, substituting the actual receiver c for the speci.cation s receiver, this. This produces the \ncode shown in Figure 10. From the code shown in Figure 10 it is easy to verify the .nal assertion, since \nthe call to actionPerformed is present. Thus the client can continue reasoning by us\u00ading the assignable \nclause of the speci.cation statement to show that, just before the call to actionPerformed, c.lstnr == \nlv. This allows the client to use the speci\u00ad.cation of actionPerformed from Lastval to prove the .nal \nassertion. 3 The copy rule can be used repeatedly to verify recursive calls, as long as there is a way \nto limit the depth of recursive copying for each use. We do not provide a rule for determining such limits. \nLastVal lv = new LastVal(); //@ assert lv != null &#38;&#38; lv.val == 0; Counter c = new Counter(); \nc.register(lv); //@ assert c.lstnr == lv &#38;&#38; lv != null; //@ assert c.count == 0; /*@ normal_behavior \n @ assignable c.count; @ ensures c.count == \\old(c.count+1); @*/ if (c.lstnr != null){ c.lstnr.actionPerformed(c.count); \n} //@ assert lv.val == 1; Figure 10. Result of substituting the model program s body for the call c.bump()from \nFigure 4. The reason this approach works well for clients is that their reasoning does not have to rely \non a weak, pre-and postcondition speci.cation of the HOM or the very weak speci.cation of its mandatory \ncalls. Instead clients can use the model program and their knowledge of (stronger) speci.\u00adcations for \nthe actual mandatory calls. Thus clients reasoning can use their knowledge of speci.c arguments to the \nHOM, or the states and types of objects, to draw strong conclusions. 3.3 Extraction of Model Programs \nfrom Code Due to matching, model program speci.cations necessarily duplicate all of the implementation \ncode that is not hidden by speci.cation statements. This duplication introduces the possibility of errors \nand is a maintenance headache. However, the ability to keep model program speci.ca\u00adtions separate from \nthe code they specify is useful in two cases. The .rst is when there is no code, i.e., for an abstract \nmethod. The second is when the code cannot be changed at all, e.g., when the code is owned by a third \nparty. If the speci.cation does not have to be kept separate from the code, we can avoid the problems \nof duplication by writ\u00ading the code and the speci.cation together. An example of how this would be done \nis shown in Figure 9. The method modi.er extractsays to extract the speci.cation from the code. The extraction \nprocess forms a model program speci\u00ad.cation, in this case the one shown in Figure 8, by taking the speci.cation \nof each refining statement as a speci.ca\u00adtion statement in the model program (thus hiding its imple\u00admentation \npart), and by taking all other statements as writ\u00adten in the code. This extracted model program automatically \nmatches the code. Figure 9 s use of extractis syntactic sugar for writing the speci.cation shown in Figure \n8. The speci.cation shown in Figure 8 would be what a speci.cation browsing tool would show to readers, \neven if the speci.cation was written in the code as in Figure 9. 3.4 Template Method Example We have \nworked several nontrivial examples to validate our approach, and they worked beautifully. However, due \nto lack of space, we can only present one of these, an instance of the Template Method design pattern \n[18]. Template methods are HOMs that are used in frame\u00adworks, where they sequence calls to hook methods \nthat are overridden (customized) by the framework s users. Typ\u00adically the hook methods have weak speci.cations. \nThe tem\u00adplate method makes mandatory calls to these hook methods, which works very well with model program \nspeci.cation. As an example, consider the HOM prepare in Fig\u00adure 11. The model program speci.cation extracted \nfrom the import java.util.Stack; public abstract class CakeFactory { public /*@ extract @*/ Object prepare() \n{ Stack pan = null; /*@ refining normal_behavior @ assignable pan; @ ensures pan.isEmpty(); @*/ pan = \nnew Stack(); this.mix(pan); this.bake(pan); return pan.pop(); } //@ requires items.size() == 0; //@ \nassignable items.theCollection; //@ ensures items.size() == 1; public abstract void mix(Stack items); \n //@ requires items.size() == 1; //@ assignable items.theCollection; //@ ensures items.size() == 1; public \nabstract void bake(Stack items); } Figure 11. The class CakeFactory, with its template method prepare, \nand two hook methods: mixand bake. method prepare is shown in Figure 12. This model pro\u00ad gram has two \nmandatory calls to the weakly speci.ed hook methods: one each to mixand bake. /*@ public model_program \n{ @ Stack pan; @ @ normal_behavior @ assignable pan; @ ensures pan.isEmpty(); @ @ this.mix(pan); @ this.bake(pan); \n@ return pan.pop(); @ } @*/ public Object prepare(); Figure 12. The extracted speci.cation for prepare. \nA specializer, like StringyCakein Figure 13, supplies code and stronger speci.cations for the hook methods. \nimport java.util.Stack; public class StringyCake extends CakeFactory { /*@ also @ requires items.size() \n== 0; @ assignable items.theCollection; @ ensures items.size() == 1 @ &#38;&#38; items.peek().equals(\"batter\"); \n @*/ public void mix(Stack items) { items.push(\"batter\"); } /*@ also @ requires items.size() == 1 @ &#38;&#38; \nitems.peek().equals(\"batter\"); @ assignable items.theCollection; @ ensures items.size() == 1 @ &#38;&#38; \nitems.peek().equals(\"CAKE\"); @*/ public void bake(Stack items) { items.pop(); items.push(\"CAKE\"); } } \nFigure 13. StringyCake, a subclass of CakeFactory. The keyword also indicates that the given speci.cation \nis joined with the one it overrides [23, 27]. A client of StringyCake would be able to use the model \nprogram speci.cation of prepareand the speci.ca\u00adtions of the hook methods to prove the assertion in Figure \n14. This works because the client can substitute the model pro\u00adgram speci.cation for the call to prepare, \nwhich allows use of the extended speci.cations for the hook methods. CakeFactory c; Object r; c= new \nStringyCake(); r = c.prepare(); //@ assert r.equals(\"CAKE\"); Figure 14. Client code that uses prepare. \nThe result of substituting the actuals into the model pro\u00adgram from Figure 12 for the call to the prepare \nmethod is shown in Figure 15. In this substitution, we have changed the return in the code into the assignment \nto the variable re\u00adceiving the call s value, as usual [41]. From Figure 15, it is straightforward to \nprove the .nal assertion, taking advantage of the fact that c is an instance of StringyCake and the speci.cations \nof its hook methods.  4. Formalization of Reasoning with Model Programs This section formalizes the \ntwo kinds of veri.cation de\u00adscribed above: veri.cation of the correctness of methods CakeFactory c; Object \nr; c= new StringyCake(); { Stack pan = null; normal_behavior assignable pan; ensures pan.isEmpty(); \nc.mix(pan); c.bake(pan); r = pan.pop(); } //@ assert r.equals(\"CAKE\"); Figure 15. Client code that \nuses prepare, after using the copy rule and substituting the actual receiver cfor this. against model \nprogram speci.cations and veri.cations of calls to such methods. To precisely investigate their sound\u00adness, \nwe .rst give details of the subset of JML we study, and then formalize matching and the Hoare logic for \nthis lan\u00adguage. 4.1 Model Program Language We study a subset of Java enriched with a subset of JML speci.cation \nconstructs. Except for model program speci\u00ad.cations, this subset is essentially that of Core JML [28], \nwhich has classes and interfaces. Classes can declare .elds and methods; we do not consider JML s model \n.elds or invariants. Model .elds could be simulated with JML s speci.cation-only ghost .elds, which Core \nJML handles, but we omit them from this paper s formal treatment, as they are orthogonal to our main \nconcerns; likewise for interfaces. The remainder of this paper focuses on methods and their speci.cations. \nOur subset of JML allows two kinds of method speci.ca\u00adtions. A method may have either a Hoare-style pre-and \npost\u00adcondition speci.cation or a model program speci.cation. For simplicity, we ignore frame axioms (JML \ns assignable clause) in the formalism (they can be encoded in postcondi\u00adtions), and we concentrate on \npartial correctness. A grammar for the subset of JML model programs that we formalize is shown in Figure \n16. Examples, such as the one in Figure 12 were shown with JML-style annotation com\u00ad ments and the full \nJML syntax, but our formalism ignores these lexical details as well JML s visibility modi.ers for method \nspeci.cations. We use the abbreviation spec(P, Q) for a JML speci.cation statement with precondition \nP and postcondition Q. We also write re.ning P, Q as S for a re.ning statement with precondition P , \npostcondition Q and body S. Statements (S, S) in Figure 16 include both the statements that can appear \nin model programs and the code statements that can appear in method bodies. However, we do not allow \nre.ning statements to appear in model programs and we do MD ::= method declarations -. MS voidm(Tx)S \nMS ::= method speci.cation requiresP ;ensuresQ; requires-ensures model_program S model program S, S ::= \nJML statement ; skip |x =E; assignment |x.m(xx); method call |{DS} block |S1 S2 sequence |if (x)S1 else \nS2 if |spec(P, Q) speci.cation |re.ning P, Q as S re.ning D ::= declaration T x; local of type T |D* \nsimultaneous E, P, Q ::= expression this|x |x1.x2 |x0.m(xx)|newT (xx) |x1 ==x2 |x1 <x2 |x1 &#38;&#38;x2 \n|x1 || x2 |!x |x1 +x2 |x1 %x2 |... |\\old(E) Figure 16. A core JML grammar for model programs. The nonterminal \nT stands class names and primitive types, and x stands for identi.ers. not allow speci.cation statements \nto appear in method bod\u00adies. Re.ning statements are also not allowed in the bodies of re.ning statements. \nWe sometimes use S for statements in model programs, in contexts where S is used only for code. However, \nto avoid duplication of de.nitions, we do not technically de.ne two different syntactic categories. To \navoid complications arising from speci.cations that may fail to terminate, method calls and new object \nconstruc\u00adtions are not allowed in requires and ensures clauses. 4.2 Structural Similarity from Matching \nMatching an implementation against a model program is straightforward. The matches predicate merely checks \nthat the code could have had the model program extracted from it, as would be done if the extract keyword \nhad been used. So matches is de.ned using an operator extract, which takes a statement and recursively \nreplaces each refining statement with the speci.cation statement it contains. This (very simple) algorithm \nis given in Figure 17. As can be seen in Figure 17, statements match only against themselves, with the \nexception of statements that contain re.ning statements, which can only match speci.\u00adcation statements. \nFor example, the statement that forms the matches :S \u00d7 S . Boolean matches(S, S ' )=(extract(S)= S ' \n) extract :S . S extract(re.ning P, Q as S)= spec(P, Q) extract({DS})= {D extract(S)} extract(S1 S2)= \nextract(S1) extract(S2) extract(if(Et) St elseSf ) = if(Et) extract(St) elseextract(Sf ) extract(S)= \nS (if none of the above cases apply) Figure 17. De.nition of when a code statement matches the statement \nof a model program, which is built on a de.nition of how to extract a model program from code. The = \nnotation used to compare statements means textual equality. body of the bump method shown in Figure 9 \nmatches the model program given in Figure 8. This de.nition of matches allows speci.cation statements \nto match themselves. However, because speci.cation state\u00adments do not appear in normal code, but only \nin model pro\u00adgram speci.cations, this does not matter for matching. 4.3 Veri.cation and its Soundness \nIn this section we formalize our veri.cation technique in the manner of Hoare logic. Section 4.3.1 gives \nproof rules, fo\u00ad cusing on the rule for client reasoning and the rule for ver\u00adifying method implementations \nwith respect to model pro\u00adgram speci.cations. In order to justify these rules with actual behavior of \nprograms, we .rst de.ne a semantics for ordi\u00adnary statements (without speci.cation statements) as state \ntransformers (Section 4.3.2). Then we de.ne a predicate transformer semantics for the language extended \nwith spec\u00adi.cation statements (Section 4.3.3). Finally, Section 4.3.4 uses the semantics to de.ne notions \nof satisfaction and Sec\u00adtion 4.3.5 shows soundness of the proof rules for statements and for complete \nprograms. Notations and judgments used in the formalism are sum\u00admarized in Figure 18. 4.3.1 Veri.cation \nLogic As in our Core JML formalism [22, 28], we let Grange over typing assignments, which are maps from \nvariable names to types. The judgment G . S says that S is well formed in the context G and the class \ntable CT . The class table CT is implicit, and can be thought of as a compiled version of the program \ns class-level declarations. In particular, for a method in class T with parameters xx :Ux, its body will \nbe type checked in context this:T, xx :Ux. (We only consider void-returning methods, for simplicity.) \nHoare triples are found in judgments of the following form G . P {S} Q. Such a judgment means that if \nP holds, and if the statement S terminates normally, then Q is true in its post-state. Such a judgment \nis well-formed if CT class table (declarations) G type assignment G . SS is well formed G . E :TE has \ntype T T '' = TT is subtype of T mtype(T, m) type of method m in class T G . P {S} Q Hoare triple is \nderivable ST speci.cation table re(P, Q) requires-ensures method spec. mp(S) model program method spec. \nG . S sat ST (T, m) S satis.es T.m s spec. matches(S, S) S matches model program S CT . ST declarations \nprovably correct \u00b5 method environment [ G. S] state transformer semantics {|G . S|} predicate transformer \nsemantics wlp weakest liberal precondition s.. {s ' |(s, s ' ). .} \u00b5 |= P {S} QP {S} Q is valid in \u00b5 \n\u00b5 |= ST ST is valid in \u00b5 f . gf is re.ned by g Figure 18. Summary of notations and judgment forms. The \ntype assignment G is sometimes omitted if clear from con\u00adtext, e.g., [ S] instead of [ G. S] . G . S, \nand if the precondition P is also well formed in G, and if the postcondition Q is also well formed. Well\u00adformedness \nof Q allows its \\old expressions to refer to the statement s initial state. (For Q used as postcondition \nin a method speci.cation, occurrences of this and of the parameters are implicitly treated as if inside \n\\old so they have a sensible interpretation at invocation sites.) The formal rules apply only to well \nformed correctness statements, but for brevity we sometimes we omit the context G. There is some variation \namong logics and veri.cation systems about how the heap is modeled, and this affects the rules for .eld \nupdate and object construction (at least). For example, the Jive system [35, 40] uses an explicit global \nvariable that stands for the heap, and the .eld assignment rule uses an update expression for the heap; \nESC/Java [17] and Spec# [4] encode the heap as a collection of arrays, one per .eld, and treat .eld assignment \nas array update; de Boer and Pierik [13, 39] use another approach and Parkinson [38] yet another (separation \nlogic). Our results do not depend on such particulars of the assertion language or proof rules, with \nthe exception of the rules for method invocation and the rules for verifying method implementations. \nWe refrain from stating a rule for .eld update and also omit the standard rules [20] for assignment, \ncontrol structures, consequence, etc. The key rules appear in Figure 19, which we explain below. Speci.cation \nstatements do not occur in method imple\u00admentations but they occur in model programs and therefore (SPEC \nSTMT) G . P {spec(P, Q)} Q (REF) G . P {S} Q G . P {re.ning P ' ,Q ' as S} Q (MCALL) ST (T ' ,m)= re(P \n' ,Q ' ) G . x :TT ' = T mtype(T ' ,m)= xy :Tx.void P = P ' [x, xx/this, xy] Q = Q ' [x, xx/this, xy] \n G . P &#38;&#38;x instanceofT ' {x.m(xx);} Q (HOCALL) ST (T ' ,m)= mp(S ' ) mtype(T ' ,m)= yx:Tx.void \nthis:T ' , xy :Tx. S ' T ' = T S ' does not assign to xy S = S ' [x, xx/this, xy]G,x :T ' . P {S} Q \nG,x :T . P &#38;&#38;x instanceofT ' {x.m(xx);} Q (CLASS TABLE) for all (T, m)in CT : if class T declares \nm with body S and mtype(T, m)= xy :Tx.void then this:T, xy :Tx. S sat ST (T, m) CT . ST (SAT RE) ST (T, \nm)= re(P, Q)G . P {S} Q G . S sat ST (T, m) (SAT MP) ST (T, m)= mp(S) matches(S, S) for all (G ' . re.ning \nP, Q as S ') in S: G ' . P {S ' } Q G . S sat ST (T, m) Figure 19. Selected proof rules. Subtyping is \nwritten =. in the antecedent of rule (HOCALL) so our logic needs a rule for them. Rule (SPEC STMT) is \nstraightforward [2, 34]. Rule (MCALL) is an ordinary rule for method call.4 It is similar to the rule \n(SPEC STMT) in that the pre-and post\u00adcondition are obtained directly from the speci.cation given by the \nprogram s speci.cation table, ST . The speci.cation table, ST , is .xed for a given pro\u00adgram. It maps \na pair consisting of a class type and a method name to that method s speci.cation. The speci.cation ta\u00ad \n4 Some logics use more complicated adaptation rules for recursive proce\u00addure calls [21, 37], but adaptation \nis needed for auxiliary variables which we omit in favor of the \\old notation. So, for reasoning about \nrecursive calls, the substitutions in rule (MCALL) suf.ce. ble contains two kinds of speci.cations: pre-/post-condition \n(requires/ensures) pairs, written re(P, Q), and model pro\u00adgram speci.cations, written mp(S). The (MCALL) \nrule is only used for calls where the speci.cation table contains a pre-/postcondition pair. In JML, \noccurrences of parameters and this in a post\u00adcondition Q ' are interpreted to refer to the initial state, \nwhich is why straightforward substitutions account for parameter ' passing in rule (MCALL). Note that \nthe assumed type T of the receiver must be a subtype of the static type of x, other\u00ad ' wise the precondition \nwould be ill formed. When T = T , ' the condition x instanceofT is trivially true and can be ' omitted. \n(Note that in Java mtype(T ,m)= mtype(T, m).) Of course, rule (MCALL) relies on behavioral subtyping \n[1, 32]: the method implementation dispatched according to the receiver s dynamic type must satisfy the \nspeci.cations of its supertypes [14, 23, 27, 30]. ASSUMPTION 4.1. The speci.cation table, ST , has behav\u00adioral \nsubtyping, i.e., for all classes T, T ' with T = T ', and ' all methods m declared or inherited in T \n, ST (T, m)re.nes ' ST (T ,m). In Section 4.3.4 we formalize the notion of re.nement with which the assumption \ncan be made precise, but this is not a central issue in this paper and we do not dwell on it. In the \n(HOCALL) rule, the antecedent this:T ', xy :Tx. S ' says that the model program s body S ' type checks \nin a type context appropriate for the method s type.5 This en\u00adsures that the substitution S ' [x, xx/this, \nxy] that produces S is well-typed. (Substitution renames locals to avoid cap\u00ad ' ture.) Note that the \nantecedent G,x :T . P {S} Q uses ' the type context G with the receiver x s type changed to T . This \nchange of x s type is necessary because S ' type checks with this:T '. Assignments to parameters are \ndisallowed, without loss of generality, as usual in proof systems. Rules (MCALL) and (HOCALL) are to \nbe used for reason\u00ading about both invocations by clients and recursive invoca\u00adtions within method declarations. \nBy contrast, some Hoare logics include a separate rule for verifying the implementa\u00adtion of a recursive \nprocedure, which is allowed to assume the correctness of the procedure for recursive invocations. Since \nrules (MCALL) and (HOCALL) take for granted that the in\u00advoked method satis.es its speci.cation, we also \nformalize the obligation to verify every method implementation, using three more rules. We use the judgment \nCT . ST to signify that every method implementation in every class satis.es its speci.\u00adcation. We say \nthat P {S} Q is derivable iff it has a proof using the rules discussed earlier, and P {S} Q is provable \niff it is derivable and moreover CT . ST can be derived using rule (CLASS TABLE) 5 This is best viewed \nas a well-formedness condition on ST, and the same for assignment to iy. We include these in the rule \nonly for clarity. The judgment S sat ST (T, m) says that S satis.es its speci.cation. (Its semantics \nis given later, by De.nition 4.7.) In the case of ordinary requires/ensures speci.cations, the rule (SAT \nRE) requires that statement S is veri.ed in the usual way. Here S could be any statement, but the only \nuse for rule (SAT RE) is for method bodies in the antecedent of rule (CLASS TABLE). Note that in the \nderivation of P {S} Q one can use the method call rules. In case ST (T, m) is a model program speci.cation \nof the form mp(S), rule (SAT MP) says that an implementation S must match S and for each sub-statement \nin S of the form re.ning P, Q as S ', the statement S ' must satisfy speci.cation P, Q. In the rule, \neach typing context G ' is determined by the surrounding declarations. Rule (REF) for the re.ning statement \nis a bit surprising. ' This rule ignores the re.ning statement s predicates, P and Q ', and instead only \nrequires one to prove P {S} Q. The ' reason this rule can ignore P and Q ' is that execution of a re.ning \nstatement just executes its body, S. However, if such a statement is used in a method with a model program \n' Q ' speci.cation, then a proof that S satis.es P {S} will be required as part of the (SAT MP) rule. \n 4.3.2 State Transformer Semantics To prove soundness of the Hoare logic described above, we need an \nindependent semantics. We present a denotational semantics in this subsection. One reason for using such \na semantics is that it is a good match for our Hoare logic, in which reasoning about method calls is \nbased on their spec\u00adi.cations. The denotational semantics is similarly composi\u00adtional. For this purpose \nwe adopt an existing denotational semantics of Java/JML [28], which is based on earlier work [3, 36]. \nIn this section we let S range over method body (code) statements, excluding speci.cation statements. \nWe write State(G)for the set of program states appro\u00adpriate for the typing context G. Each such state \nconsists of a heap of objects together with a mapping of the variables declared in Gto values. We consider \nonly states that are well formed in the sense that every object reference that occurs as the value of \na variable or in an object .eld is in the domain of the heap, and all .eld and variable values are type \ncorrect. A statement S in context G denotes a state transformer, i.e., a (total) function from State(G) \nto State(G).{.} where .represents divergence or runtime error. Note that . is not a state. Because S \ncan invoke methods, its semantics is de.ned in terms of a method environment \u00b5 that gives the denotations \nof all methods on receivers of all classes. Ulti\u00admately we are interested in a particular method environment, \nnamely the one, written \u00b5/, denoted by the class table CT as described below. The semantics of method \ncall x.m(xx).rst checks if the receiver x is null, in which case the result is .. Otherwise, the value \nof x is an object of some runtime type T . The state transformer denoted by the body of the method m \ndeclared or inherited in T is given by \u00b5(T, m), and the semantics of the call simply applies this state \ntransformer to a state where this is mapped to the value of x and parameters xy are mapped to the values \nof x . The denotation of a statement S that type checks in context G, written [ G. S] , is de.ned in \nterms of an arbi\u00adtrary \u00b5, so that [ G. S] (\u00b5)is a function from State(G)to State(G).{.}. For given \u00b5, \nthe de.nition of [ G. S] (\u00b5) goes by induction on the structure of S. It is entirely straight\u00adforward \nand most of the details are not relevant here. We de.ne the semantics for re.ning statements as follows: \n[ G. re.ning P, Q as S] (\u00b5)=[ G. S] (\u00b5) Recall that the speci.cation part is only present to make the \nconnection with a corresponding speci.cation statement in a model program speci.cation. Speci.cation \nstatements only occur in model programs and their semantics is given in Section 4.3.3. Some work is needed \nto de.ne a method environment, \u00b5/, that models the semantics of the class table. This is done by taking \nthe least upper bound, in a straightforward order\u00ading,6 of a countable sequence of approximate method \nenvi\u00adronments \u00b5i . For each i, the semantics [ G. S] (\u00b5i ) accu\u00adrately models an operational semantics \nfor S in which the method call stack is bounded in depth by i, with outcome . if the depth is exceeded. \nThe limit, \u00b5/, models an operational semantics with unbounded calling stack. In detail, de.ne \u00b50 to interpret \nevery method as the everywhere-. function. For i = 0, construct \u00b5i+1 as fol\u00adlows: for each class T and \nmethod named m with body S in T , the meaning of the method in \u00b5i+1 is given by S in terms of \u00b5i, that \nis: \u00b5i+1(T, m) =[ S] (\u00b5i ). In case m is inherited in T from some superclass T ' , \u00b5(T, m)is de.ned to \nbe \u00b5(T ' ,m). (Owing to this treatment of inheritance, the method call semantics can simply look up in \nthe environ\u00adment the method meaning associated with the dynamic type of the receiver.) For any terminating \ncomputation, there is some .nite maximum size of the calling stack, and this is re.ected in the fact \nthat for any S and any s there is some i such that [ S] (\u00b5/)(s)=[ S] (\u00b5j )(s) for all j = i (1) Hence \nif S is the body of m in T then \u00b5/(T, m)=[ S] (\u00b5/). We now de.ne a semantics for Hoare triples. We write \nP red(G)for the powerset of State(G), noting that . is not a state and therefore not an element of any \n. . P red(G). For P well formed in G, written G . P , we write [ G. P ] for its denotation, which is \nan element of P red(G). This is consistent with the semantics [ G. E] of expressions; a boolean expression \nmaps states to true or false, which can be 6 State transformers are ordered, as usual, by the pointwise \norder on func\u00adtions, with respect to the order with states incomparable and . less than every state. \nThat is, f = g iff forall s, if f(s) .. then f(s)= g(s). = seen as the characteristic function of a set. \nWe assume that pre-and post-conditions never evaluate to .. The semantics of boolean expressions is straightforward, \nand our results do not depend on the particular syntax of assertions. A postcondition Q can refer to \nboth initial and .nal state, and we overload notation to write [ Q] for the subset of State(G)\u00d7 State(G)denoted \nby Q. We omit details, but recall in the case of method speci.cations, some desugaring is needed so that \nmention of this and method parameters in Q refer to the initial state, so that rule (MCALL) is sound. \nDEFINITION 4.2 (valid triple). Let \u00b5 be a method environ\u00adment. Then P {S} Q is valid for \u00b5 iff for all \ns, s ' . State(G), (2) if s . [ P ] and s ' =[ S] (\u00b5)(s), then (s, s ' ). [ Q] . Note that this is partial \ncorrectness, because it imposes no constraint in case [ S] (\u00b5)(s)= . since . is not a state and s, s \n' range over states. This de.nition is our touchstone, since it is the standard meaning of partial correctness \nspeci.cations and it is based on a semantics that is essentially operational, in the sense that it describes \ndirectly how each construct manipulates the program states. However, this semantics is written in a denotational \nstyle. 4.3.3 Predicate Transformer Semantics De.nition 4.2 has one limitation: for client reasoning, \nfor\u00admalized by the rule (HOCALL), we need Hoare triples for model programs. Since model programs may \ncontain speci\u00ad.cation statements, a deterministic state transformer seman\u00adtics would be insuf.cient. \nIt is convenient to use predicate transformers which are a standard model for re.nement cal\u00adculi [2]. \nOurs is a weakest liberal precondition (wlp) seman\u00adtics, for partial correctness. Since the meaning of \na speci.cation statement is only needed during client reasoning, predicate transformer se\u00admantics is \nonly needed at the level of statements, not at the level of method environments. Hence mutual recursion \namong methods does not need to be directly addressed in the predicate transformer semantics. The predicate \ntransformer semantics of S with respect to method environment \u00b5 is written {|G . S|}(\u00b5). We continue \nto interpret methods as state transformers, hence the use of the same kind of method environment as de.ned \nearlier. For function f :State(G) . State(G) . {.}, de\u00ad.ne the semantic weakest liberal condition function, \nwlp(f ):P red(G). P red(G), by s . wlp(f )(.)iff f (s)= .or f (s). .. for all s . State(G)and . . P red(G). \nFor all primitive statements S, other than speci.cation statements, we de.ne {|G . S|}(\u00b5)by {|G . S|}(\u00b5)= \nwlp([ G. S] (\u00b5)) (3) In particular, (3) applies in case S is a method invocation. This is why the predicate \ntransformer semantics can be de\u00ad.ned in terms of ordinary method environments, rather than storing predicate \ntransformers in the method environment (as in [10]). Equation (3) turns out to hold for all S without \nspeci.cation statements, because we adopt the usual seman\u00adtic de.nitions for control structures: {|G \n. S1;S2|}(\u00b5)(.)= {|G . S1|}(\u00b5)({|G . S2|}(\u00b5)(.))  {|if(E)S1 elseS2|}(\u00b5)(.) =([ E] n{|S1|}(\u00b5)(.)).([ \n!E] n{|S2|}(\u00b5)(.))  As in the state transformer semantics, the meaning of a re.ning statement is given \nby its body: {|G . re.ning P, Q as S|}(\u00b5)= {|G . S|}(\u00b5) It remains to de.ne the semantics for speci.cation \nstate\u00adments. De.ne, for all typing contexts G, for all \u00b5, for all . in P red(G), and for all s and s \n' in State(G): s .{|G . spec(P, Q)|}(\u00b5)(.) (4) iff s . [ P ] .(.s ' :(s, s ' ). [ Q] . s ' . .) To de.ne \nthe meaning of Hoare triples we need one more technical ingredient. For each G, two-state predicate . \n. State(G)\u00d7 State(G), and s . State(G), de.ne s.. by s.. = {s ' |(s, s ' ). .}. DEFINITION 4.3. For all \nwell formed G . P {S} Q, where S may include speci.cation statements, and every method environment \u00b5, \nde.ne \u00b5 |= P {S} Q iff .s . State(G): s . [ P ] . s .{|S|}(\u00b5)(s.[ Q] ). In case Q does not depend on \nthe initial state, so that we can consider [ Q] to be a set of states rather than pairs, note that \u00b5 \n|= P {S} Q is equivalent to [ P ] .{|S|}(\u00b5)([ Q] ) our rendering of the usual P . wlp(S,Q). LEMMA 4.4. \nSuppose S contains no speci.cation state\u00adments. Then \u00b5 |= P {S} Q if and only if P {S} Q is valid for \n\u00b5. This is a straightforward consequence of the relation (3) which can be shown to hold for all S. 4.3.4 \nSatisfaction for methods and method environments The method call rules are only sound if the invoked \nmethod implementations satisfy their speci.cations. This subsection de.nes satisfaction for an individual \nmethod body i.e., the semantics of the notation S sat ST (T, m) used in rules (SAT RE) and (SAT MP). \nThis is closely related to satisfac\u00adtion by all methods in the class table i.e., the semantics of the \nnotation CT . ST used in rule (CLASS TABLE). The .rst step is to de.ne the re.nement order .. For predicate \ntransformers f , g over Gwe de.ne f . g .. .. . P red(G): f (.). g(.). The semantics of spec is justi.ed \nby the following. LEMMA 4.5. For all \u00b5, P, S, Q: {|spec(P, Q)|}(\u00b5).{|S|}(\u00b5) iff \u00b5 |= P {S} Q. The proof \nis straightforward. The next notion expresses that each method in environ\u00adment \u00b5 satis.es its speci.cation. \nDEFINITION 4.6. \u00b5 |= ST iff for all T and all methods m declared or inherited in T with parameters xy \n:Tx, and for G= this:T, xy :Tx: if ST (T, m)= re(P, Q)then {|G . spec(P, Q)|}(\u00b5). wlp(\u00b5(T, m)); if ST \n(T, m)= mp(S)then {|G . S|}(\u00b5). wlp(\u00b5(T, m)). The de.nition applies to any \u00b5 but consider what it means \nin case \u00b5 is the actual semantics \u00b5/of the program. That is, suppose \u00b5/(T, m)is the state transformer \ndenoted by method body S. Then wlp(\u00b5/(T, m)) is the same thing as {|S|}(\u00b5/) recall (1). So in the case \nthat ST (T, m)is a requires/en\u00adsures form re(P, Q), the de.nition amounts to saying \u00b5/|= P {S} Q owing \nto Lemma 4.5. A consequence of Assumption 4.1 is that \u00b5 |= ST im\u00adplies ' ' T = T . wlp(\u00b5(T, m)). wlp(\u00b5(T \n,m) (5) De.nition4.6isfortheconsequentofrule (CLASS TABLE) and the following for its antecedent. DEFINITION \n4.7. De.ne \u00b5 |= S sat ST (T, m)by cases: if ST (T, m)is re(P, Q)then \u00b5 |= P {S} Q  if ST (T, m)is mp(S)then \n{|S|}(\u00b5).{|S|}(\u00b5)  4.3.5 Soundness This section proves the main results. The .rst, Theorem 4.12, says \nthat if CT . ST is derivable using the rules, then \u00b5/|= ST , where \u00b5/is the semantics of CT . The second, \nCorollary 4.13, says that the Hoare rules for statements are sound with respect to \u00b5/and the state transformer \nsemantics. The .rst steps are somewhat technical; the reader may skip to Theorem 4.9 on .rst reading. \nIt is easy to show that wlp(f )is monotonic, in the sense that . . . implies wlp(f )(.) . wlp(f )(.), \nfor any state transformer f . Moreover, the semantics for other constructs also yields monotonic predicate \ntransformers, i.e., {|S|}(\u00b5) is monotonic for all S and all \u00b5. A standard result in re.nement calculus \nis that forms that combine statements (such as sequencing and if) are monotonic with respect to re.nement \n[2]. For example, if {|S1|}(\u00b5) . {|S ' |}(\u00b5), then {|S1S2|}(\u00b5) . {|S ' S2|}(\u00b5). 1 1 This case of .-monotonicity \ndepends on {|S2|}(\u00b5)being a monotonic predicate transformer. To deal with the substitutions, we de.ne \nsemantic sub\u00adstitution for predicate transformers, in particular for those x denoted by methods of some \nmtype(T, m)= xy :T .void. Note that for expressiveness in the programming language we do not require \nthat arguments in method calls are dis\u00adtinct, which means we must consider non-injective substitu\u00adtions, \nso we cannot just invert the substitution and apply that to the .nal state. x Let G be this:T, xy :Txand \nlet G ' be x :T, x :T . Sup\u00adpose f is a predicate transformer on P red(G) that is in\u00addependent from the \n.nal values of this, xy, i.e., f (.)= f (.this, xy \u00b7 .). De.ne f [x, x /this, xy]on P red(G ' )by s . \nf [x, x /this, xy](.)iff s[x, x /this, xy]. f (.this, xy \u00b7 . -x, x ) where we use an obvious notation \nfor state substitutions and we write .this, xy \u00b7 .-x, x for the G '-predicate obtained by dropping x, \nx from states and then adding all possible values for this, xy. It is straightforward to show that this \nsemantic substitu\u00adtion is monotonic and to prove the following. LEMMA 4.8 (substitution). Consider G, \nG ' as just above. Suppose G . S and suppose S does not assign the variables in G(but may assign locals \nand the heap). Then, for any \u00b5 {|G ' . S[x, x /this, xy]|}(\u00b5) =({|G . S|}(\u00b5))[x, x /this, xy] We omit \nthe similar details for the semantic substitution operation on state transformers that do not assign \nxy, but note the connection for state transformer f on State(G): (wlp(f ))[x, x /this, xy]= wlp(f [x, \nx /this, xy]) (6) Now we can proceed to soundness of the statement rules. The modularity of reasoning \nin terms of speci.cations is re.ected in the fact that they are sound with respect to every method environment \nthat satis.es the speci.cation table. THEOREM 4.9 (Soundness of statement rules). For any \u00b5, if \u00b5 |= \nST and P {S} Q is derivable then \u00b5 |= P {S} Q. Proof: by induction on derivation of P {S} Q. We omit \nproofs of the standard rules for assignment, etc. For (MCALL) we must show ' \u00b5 |= P &#38;&#38;x instanceof \nT {x.m(x );} Q assuming the antecedents of the rule. As per De.nition 4.3, consider any state s in [ \nP &#38;&#38;x instanceof T ' ] . By type soundness, the dynamic type of the receiver is some subclass \n'' ' T of T '. By an antecedent of the rule we have ST (T ,m)= re(P ' ,Q ' ). By hypothesis of the Theorem \nwe have \u00b5 |= ST . So by De.nition 4.6 we have {|spec(P ' ,Q ' )|}(\u00b5) . ' '' wlp(\u00b5(T ,m)). So {|spec(P \n' ,Q ' )|}(\u00b5) . wlp(\u00b5(T ,m)) by behavioral subtyping, (5). To complete the argument that s is in {|S|}(\u00b5)(s.[ \nQ] ), one unfolds the semantics of '' x.m(x ), which passes the argument values to \u00b5(T ,m))in a way that \nmatches the substitutions. We omit further details, which rely on substitution properties above, since \nthe rule is not novel. For rule (HOCALL) we must show ' \u00b5 |= P &#38;&#38;x instanceof T {x.m(x );} Q \nBecause method call is a primitive and does not contain speci.cation statements, we can prove the Hoare \ntriple in the simpler form (2) as per Lemma 4.4. That is, for any s we must show if s . [ P ] and [ x.m(x \n)] (\u00b5)(s))= . (7) then (s, [ x.m(x )] (\u00b5)(s)). [ Q] assuming the antecedents of rule (HOCALL). So suppose \n' ST (T ,m)= mp(S ' )and let S = S ' [x, x /this, xy]. From the key antecedent P {S} Q, by induction \non its deriva\u00adtion, we have \u00b5 |= P {S} Q. By Lemma 4.5 we get '' '' ' {|spec(P, Q)|}(\u00b5) . {|S|}(\u00b5). For \nany T with T = T '' we have {|S ' |}(\u00b5) . wlp(\u00b5(T ,m))by behavioral subtyp\u00ading and hypothesis \u00b5 |= ST \nof the Theorem. So by mono\u00adtonicity of substitution we have {|S ' |}(\u00b5)[x, x /this, xy] (8) '' . wlp(\u00b5(T \n,m))[x, x /this, xy]. (By the antecedent that S ' does not assign to this, xy, its se\u00admantics {|S ' |}(\u00b5)is \nindependent from variables in the post\u00adcondition, so the semantic substitution is de.ned.) Now (8) is \nequivalent to '' {|S|}(\u00b5) . wlp(\u00b5(T ,m))[x, x /this, xy] by Lemma 4.8 and de.nition of S. Since we already \nproved '' ' {|spec(P, Q)|}(\u00b5) . {|S|}(\u00b5)we get, for every T = T , '' that {|spec(P, Q)|}(\u00b5) . wlp(\u00b5(T \n,m))[x, x /this, xy]. Thus for each T '', unfolding the de.nition of ., for all ., {|spec(P, Q)|}(\u00b5)(.) \n(9) '' . wlp(\u00b5(T ,m))[x, x /this, xy](.). Finally let us show (7). Suppose s . [ P ] . If s(x) is null, \nthen by semantics [ x.m(x )] (\u00b5)(s) is . and we are done. Otherwise, [ x.m(x )] (\u00b5)(s) is de.ned to be \n'' '' \u00b5(T ,m)[x, x /this, xy](s)where T is the dynamic type of x in s. We show that the consequent in \n(7) holds, provided '' that \u00b5(T ,m)[x, x /this, xy](s)= .. Consider some s . [ P ] and instantiate (9) \nwith . := (s.[ Q] ). Using the semantics of spec(P, Q)and de.nition of s.[ Q] , the left side of the \ninclusion contains s, so '' s . wlp(\u00b5(T ,m))[x, x /this, xy](s.[ Q] ). Rewriting by de.nition of wlp \nand using (6) we get (\u00b5(T '' ,m)[x, x /this, xy])(s). (s.[ Q] ), whence by de.nition of s.[ Q] (s, (\u00b5(T \n'' ,m)[x, x /this, xy])(s)). [ Q] . LEMMA 4.10 (Soundness of (SAT RE)). Let T be a class and m a method. \nSuppose \u00b5 |= ST and ST (T, m)= re(P, Q). If the antecedents of rule (SAT RE) hold then \u00b5 |= S sat ST \n(T, m). Proof: By premise of the rule we have P {S} Q and so by Theorem 4.9 we get \u00b5 |= P {S} Q, whence \n\u00b5 |= S sat ST (T, m)by De.nition 4.7 and Lemma 4.5. THEOREM 4.11 (Soundness of (SAT MP)). Let class T \nand method m be given. Let ST , and \u00b5 be such that ST (T, m)= mp(S) and \u00b5 |= ST . If the antecedents \nof rule (SAT MP) hold then \u00b5 |= S sat ST (T, m). Proof: The premises of (SAT MP) are match(S, S)and also \nP {S ' } Q for each re.ningP, Q as S ' in S. So for each such S ' we get, by Theorem 4.9, that \u00b5 |= P \n{S ' } Q. Thus by Lemma 4.5 we have {|spec(P, Q)|}(\u00b5) .{|S ' |}(\u00b5). By de.nition of matches(S, S), the \nonly difference between S and S is that S may contain some speci.cation statements spec(P, Q)that correspond, \nin S, to sub-statements of the form re.ning P, Q as S ' . Recall that the semantics of re.ning P, Q as \nS ' is just the semantics of S '. Hence, by using {|spec(P, Q)|}(\u00b5).{|S ' |}(\u00b5)and .-monotonicity of \nall program constructors we get {|S|}(\u00b5).{|S|}(\u00b5), whence \u00b5 |= S sat ST (T, m)by De.nition 4.7. The preceding \nresults give soundness of the rules for ver\u00adifying statements and method bodies, under the assumption \nthat a method environment \u00b5 is given such that \u00b5 |= ST . The next result says that if every method body \nis veri.ed, the assumption can be discharged by using the actual program semantics. Since methods can \nmake recursive and mutually recursive calls, the proof resembles proofs of soundness for the recursive \nprocedure rule in simple imperative languages. THEOREM 4.12 (Soundness of rule (CLASS TABLE)). Let \u00b5/be \n[ CT ] . If CT . ST then \u00b5/|= ST . Proof: We prove, by induction on i, that \u00b5i |= ST for every \u00b5i in \nthe approximation chain that de.nes \u00b5/. Hence by (1) the least upper bound also satis.es ST , i.e., \u00b5/|= \nST . The base case i =0is trivial since each \u00b50(T, m)is .s.. which satis.es every speci.cation. For the \ninduction step, suppose \u00b5i |= ST . Now \u00b5i+1 is de.ned using [ S] (\u00b5i) for each method body S. We need \nto show that [ S] (\u00b5i) satis.es ST (T, m). By CT . ST according to rule (CLASS TABLE) we have S sat ST \n(T, m), from either rule (SAT RE) or (SAT MP). For the case of (SAT RE), we instantiate Lemma 4.10 to \nget \u00b5i |= S sat ST (T, m) which is equivalent to {|spec(P, Q)|}(\u00b5i) . {|S|}(\u00b5i) and since the body S \nhas no speci.cation statements this is equivalent to {|spec(P, Q)|}(\u00b5i). wlp([ S] (\u00b5i ) which was to \nbe proved. For the case of (SAT MP), we instantiate Theorem 4.11 and the rest of the argument is similar. \nCOROLLARY 4.13. If S has no speci.cation statements and if P {S} Q is provable, then it is valid in the \nstate\u00adtransformer semantics. Proof: Recall that provable means P {S} Q is derivable and in addition CT \n. ST is derivable. By the latter and Theorem 4.12 we have \u00b5/|= ST . Using P {S} Q and Theorem 4.9 we \nget \u00b5/|= P {S} Q. By Lemma 4.4 we get satisfaction in terms of state transformers, i.e., (2) for \u00b5/. \n  5. Discussion 5.1 Generality of our Approach We formalized our approach as a Hoare logic, but it can \nbe adapted to other ways of doing veri.cation, for example, us\u00ading veri.cation conditions based on weakest \npreconditions, or using a re.nement calculus. It was a pleasant surprise that, although re.nement un\u00adderlies \nsoundness of our technique, the grey-box approach can be deployed without need for explicit reasoning \nin the style of re.nement calculi. Nor does our technique require features of JML other than speci.cation \nstatements and re\u00ad.ning statements. Adaptation to total correctness should be easy, beyond the inherent \ncomplication of measure functions for mutually\u00adrecursive, dynamically-dispatched methods. An important \nextension is to take speci.cation visibil\u00adity into account. Rules (MCALL) and especially (HOCALL) could \nallow use of any speci.cations visible at the call site, e.g., those with protected visibility in the \ncaller s and there\u00adfore not necessarily visible in the callee s class. This is easily added to our formalism \nand speci.cation visibility is already well integrated in JML [26]. 5.2 Speci.cation Inheritance To \n.t in with the rest of JML, our technique must not cause major disruptions in JML s semantics. In particular, \nmodel program speci.cations must .t in with JML s ability to give multiple speci.cations (what it calls \nspeci.cation cases) for each method. This feature is used as a way to explain speci\u00ad.cation inheritance \nfor methods in JML [14, 23, 27]. However, viewing model program speci.cations as just another kind of \nspeci.cation case in JML seems to work well. Reasoning happens as follows. To verify an imple\u00admentation, \nthe programmer must show that the code satis.es each speci.cation case that applies to that method, including \nall speci.cation cases inherited from supertypes. Similarly, clients reasoning about a call can pick \none of the available speci.cation cases to use in reasoning about the call. That is, a simple interpretation \nof the meaning of speci.cation inheritance (and joins) for model program speci.cations is that implementers \nmust satisfy all of the given model pro\u00adgram speci.cations and that clients can choose a particular model \nprogram speci.cation when reasoning about a HOM call. This idea could be formalized as follows. First, \ngeneral\u00adize the speci.cation table ST so that ST (T, m)returns a set of speci.cations. The set ST (T, \nm)is the set of all speci\u00ad.cations declared in T or some supertype of T for m; this gives meaning to \nspeci.cation inheritance for both model programs and requires/ensures speci.cations. Second, gen\u00aderalize \nthe (HOCALL) and (MCALL) rules so that clients can use any sc . ST (T, m). Third, for veri.cation of \nimplemen\u00adtations, verify that the code satis.es each sc . ST (T, m). This would guarantee that all types \nare behavioral subtypes of each of their supertypes, and that supertype abstraction is valid [14, 23, \n27]. If m has two model program speci.cations S1 and S2 and if there is no body S that matches both S1 \nand S2, then m cannot be correctly implemented. That is, speci.cation inheritance may strengthen a speci.cation \nso much that it becomes unsatis.able. (This also happens with standard re\u00adquires/ensures speci.cations.) \nPrevious work formalized the join of requires/ensures speci.cation cases [14, 23, 27] using state predicates. \nThe ability to use joined speci.cation cases adds power to the proof system. However, it is not clear \nhow to succinctly express the join of model program speci.cation cases, unless they all have code that \nis identical except for having possibly different speci.cation statements in the same places. 5.3 Veri.cation \nof Implementations Our approach uses simple syntactic matching for veri.cation of implementations. Its \nsimplicity allows us to focus on the big picture, making explanations of the ideas and soundness proof \nclear. However, a disadvantage of our technique s use of simple syntactic matching is that it only allows \nthe speci.cation of mandatory calls when the surrounding control structures are also exposed. An example \nof this exposure is shown in Figure 20. The control structure around the call to f is simple enough that \nits model program must reveal the order of iteration or cannot identify the mandatory call at all. While \na more complex notion of matching could be used, it would have to rely on semantical (e.g., proof-based) \ntech\u00adniques, such as those used in the re.nement calculus [2, 34] or in program transformation. To obtain \nmore .exibility, one could generalize match\u00ading in various ways. One way would be to generalize the patterns, \nthat is, the model program speci.cations. For ex\u00adample, one could allow more constructs from the re.nement \ncalculus, such as nondeterministic if statements. Although public class HashTable { /* ... */ private \nObject[] values = new Object[17]; public /*@ extract @*/ void applyToValues(IntFun s) { for (int i = \n0; i < values.length; i++) { if (values[i] != null){ s.f(values[i]); } } } } Figure 20. A hash table \nwith an applyToValuesHOM. speci.cation statements can simulate many re.nement cal\u00adculus features, they \nmay not be a good basis for partially specifying control structures. Another way to obtain more .exibility \nwould be to allow the re.ning statement to match other statements. Since the soundness of our technique \nrelies on the semantic notion of re.nement, any complementary notion of matching and re\u00ad.nement could \nwork. However, then veri.cation would re\u00adquire a real re.nement calculus, whereas a key contribution \nof our approach is that use of model programs does not force the reasoner beyond Hoare logic. 5.4 More \nabout Re.ning Statements Re.ning statements themselves are interesting. Their design arose through discussions \non the JML interest mailing list, although they are only partially implemented in the Com\u00admon JML tools. \nSeveral tool builders want something like a re.ning statement to give frame axioms (JML s assignable \nclause) for arbitrary statements, particularly for loop state\u00adments [6, 19]. Although the re.ning statement \nin our for\u00admalism does not include JML s assignable clause, it is easy to add such clauses to a re.ning \nstatement, as it is essentially a way to attach a speci.cation case to a statement. The idea of attaching \na speci.cation to a statement is remarkably .exible. For example, one can use a re.ning statement to \nreplace loop invariant declarations. Suppose S is the body of a loop for which P is to be declared as \nits invariant. This can be done by writing refining normal_behavior requires P ; ensures P ; S in place \nof the body S. However, if this is done, it requires a slightly more complex notion of pattern matching, \nsince some refiningstatements will appear in model programs. 5.5 Runtime Assertion Checking In our approach, \nrefining statements would be the fo\u00adcus of runtime assertion checking for higher order methods. That \nis, to dynamically check that code implements a model program speci.cation, it suf.ces to statically \nmatch the code against the speci.cation, check the assignable clause, and then to dynamically check that: \nthe precondition given in the re.ning statement s requires clause holds just before execut\u00ading its body, \nand its ensures clause holds just after executing its body.  6. Future Work Future work includes extending \nthe theoretical and practi\u00adcal treatment of grey-box speci.cations in several directions. Frame axioms \nseem to work .ne using the datagroup con\u00adcept (see Section 2.1), so a formal treatment may be easy. Other \nextensions to our approach could include termination, or treating exceptions and concurrency. 7. Conclusions \nDocumentation of HOMs is an important problem [25, 42]. It occurs in connection with most behavioral \ndesign pat\u00adterns, and is quite important for frameworks using such pat\u00adterns. Besides the grey-box approach \n[7, 8, 9], we know of two other approaches to documenting such methods: writ\u00ading speci.cations in higher-order \nlogic [12, 15] and writing trace-based speci.cations [42]. Both of these techniques are dif.cult to use, \nespecially informally. We are unaware of any use of the higher-order logic approach for OO programs. \nOn the other hand, the grey-box approach corresponds well to standard documentation practice, which presents \nthe method s code, perhaps omitting some details. Our formal\u00adization explains this technique s soundness \nand gives insight into how to use it more effectively. First, we have precisely explained how one can \nuse this technique in client reasoning, by using a copy rule [33] to explain calls to methods with such \nspeci.cations. (See rule (HOCALL) in Section 4.3.1.) In essence one copies the model program speci.cation \ns code to the call site, and replaces formals with actuals. Second, we have shown the soundness of the \ngrey-box technique for suppressing details by writing speci.cation statements. Programmers can use this \nidea informally, by us\u00ading speci.cation statements in their documentation to stand for pieces of hidden \ncode. In doing so, programmers provide a speci.cation for the hidden piece of code. Our examples show \nthat, by using refiningstatements to mark pieces of code as implementing speci.cation state\u00adments, grey-box \nspeci.cations can be extracted from code automatically. This make specifying HOMs more practical.  Acknowledgments \nThanks to Hridesh Rajan, Neeraj Khanolkar and the OOP-SLA program committee for comments on earlier drafts. \nThanks to the members of IFIP working group 2.3, with whom Leavens discussed these ideas, and who suggested \nthe idea of extracting model program speci.cations. Thanks to Robby, John Hatcliff, Erik Poll, and Wojciech \nMostowski for additional discussions about this work. Shaner and Leav\u00adens were supported in part by NSF \ngrant CCF-0429567, and Naumann by NSF grant CCF-0429894. References [1] P. America. Designing an object-oriented \nprogramming language with behavioural subtyping. In J. W. de Bakker, W. P. de Roever, and G. Rozenberg, \neditors, Foundations of Object-Oriented Languages, REX School/Workshop, Noordwijkerhout, The Netherlands, \nMay/June 1990, volume 489 of Lecture Notes in Computer Science, pages 60 90. Springer-Verlag, New York, \nNY, 1991. [2] R.-J. Back and J. von Wright. Re.nement Calculus: A Systematic Introduction. Graduate Texts \nin Computer Science. Springer-Verlag, 1998. [3] A. Banerjee and D. A. Naumann. Ownership con.nement ensures \nrepresentation independence for object-oriented programs. J. ACM, 52(6):894 960, Nov. 2005. [4] M. Barnett, \nK. R. M. Leino, and W. Schulte. The Spec# programming system: An overview. In G. Barthe, L. Burdy, M. \nHuisman, J.-L. Lanet, and T. Muntean, editors, Construc\u00adtion and Analysis of Safe, Secure, and Interoperable \nSmart devices (CASSIS 2004), volume 3362 of Lecture Notes in Computer Science, pages 49 69. Springer-Verlag, \n2005. [5] M. Barnett and W. Schulte. Runtime veri.cation of .NET contracts. The Journal of Systems and \nSoftware, 65(3):199 208, Mar. 2003. [6] B. Beckert, R. H\u00e4hnle, and P. H. Schmitt, editors. Veri.cation \nof Object-Oriented Software: The KeY Approach. LNCS 4334. Springer-Verlag, 2007. [7] M. B\u00fcchi. Safe language \nmechanisms for modularization and concurrency. Technical Report TUCS Dissertations No. 28, Turku Center \nfor Computer Science, May 2000. [8] M. B\u00fcchi and W. Weck. A plea for grey-box compo\u00adnents. Technical \nReport 122, Turku Center for Computer Science, Presented at the Workshop on Foundations of Component-Based \nSystems, Z\u00fcrich, September 1997, 1997. http://tinyurl.com/2833tr. [9] M. B\u00fcchi and W. Weck. The greybox \napproach: When blackbox speci.cations hide too much. Technical Report 297, Turku Center for Computer \nScience, Aug. 1999. http://tinyurl.com/ywmuzy. [10] A. L. C. Cavalcanti and D. Naumann. A weakest precondition \nsemantics for an object-oriented language of re.nement. IEEE Transactions on Software Engineering, 26(8):713 \n728, Aug. 2000. [11] P. Chalin and F. Rioux. Non-null references by default in the Java Modeling Language. \nIn Proceedings of the Workshop on the Speci.cation and Veri.cation of Component-Based Systems (SAVCBS \n05), volume 31(2) of ACM Software Engineering Notes. ACM, 2005. [12] W. Damm and B. Josko. A sound and \nrelatively complete Hoare-logic for a language with higher type procedures. Acta Informatica, 20(1):59 \n101, Oct. 1983. [13] F. S. de Boer. A WP-calculus for OO. In W. Thomas, editor, Foundations of Software \nScience and Computation Structures (FOSSACS), volume 1578 of Lecture Notes in Computer Science, pages \n135 149. Springer-Verlag, 1999. [14] K. K. Dhara and G. T. Leavens. Forcing behavioral subtyping through \nspeci.cation inheritance. In Proceedings of the 18th ICSE, Berlin, Germany, pages 258 267. IEEE CS Press, \nMar. 1996. A corrected version is ISU CS TR #95-20c, http://tinyurl.com/s2krg. [15] G. W. Ernst, J. K. \nNavlakha, and W. F. Ogden. Veri.cation of programs with procedure-type parameters. Acta Informatica, \n18(2):149 169, Nov. 1982. [16] R. B. Findler and M. Felleisen. Contracts for higher-order functions. \nIn Proceedings of ICFP, pages 48 59, Oct. 2002. [17] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. \nNelson, J. B. Saxe, and R. Stata. Extended static checking for Java. In Proceedings of the ACM SIGPLAN \n2002 Conference on Programming Language Design and Implementation (PLDI 02), volume 37(5) of SIGPLAN, \npages 234 245, New York, NY, June 2002. ACM. [18] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design \nPatterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, Reading, Mass., 1995. [19] E. \nC. R. Hehner. Speci.ed blocks. Veri.ed Soft\u00adware: Theories, Tools, Experiments (VSTTE), Oct. 2005. http://tinyurl.com/2a7kf2. \n[20] C. A. R. Hoare. An axiomatic basis for computer program\u00adming. Commun. ACM, 12(10):576 580,583, Oct. \n1969. [21] C. A. R. Hoare. Procedures and parameters: An axiomatic approach. In E. Engeler, editor, Symposium \non Semantics of Algorithmic Languages. Springer-Verlag, 1971. [22] A. Igarashi, B. Pierce, and P. Wadler. \nFeatherweight Java: A minimal core calculus for Java and GJ. In L. Meissner, editor, Proceedings of the \n1999 ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages &#38; Applications (OOPSLA \n99), volume 34(10) of ACM SIGPLAN Notices, pages 132 146, N. Y., Nov. 1999. ACM. [23] G. T. Leavens. \nJML s rich, inherited speci.cations for behavioral subtypes. In Z. Liu and H. Jifeng, editors, Formal \nMethods and Software Engineering: 8th International Conference on Formal Engineering Methods (ICFEM), \nvolume 4260 of Lecture Notes in Computer Science, pages 2 34, New York, NY, Nov. 2006. Springer-Verlag. \n[24] G. T. Leavens, A. L. Baker, and C. Ruby. Preliminary design of JML: A behavioral interface speci.cation \nlanguage for Java. ACM SIGSOFT Software Engineering Notes, 31(3):1 38, Mar. 2006. [25] G. T. Leavens, \nK. R. M. Leino, and P. M\u00fcller. Speci.cation and veri.cation challenges for sequential object-oriented \nprograms. Formal Aspects of Computing, 19(2):159 189, June 2007. [26] G. T. Leavens and P. M\u00fcller. Information \nhiding and visibility in interface speci.cations. In International Conference on Software Engineering \n(ICSE), pages 385 395. IEEE, May 2007. [27] G. T. Leavens and D. A. Naumann. Behavioral subtyping, speci.cation \ninheritance, and modular reasoning. Technical Report 06-20b, Department of Computer Science, Iowa State \nUniversity, Ames, Iowa, 50011, Sept. 2006. [28] G. T. Leavens, D. A. Naumann, and S. Rosenberg. Prelim\u00adinary \nde.nition of Core JML. CS Report 2006-07, Stevens Institute of Technology, Sept. 2006. [29] G. T. Leavens, \nE. Poll, C. Clifton, Y. Cheon, C. Ruby, D. R. Cok, P. M\u00fcller, J. Kiniry, and P. Chalin. JML Reference \nManual. Department of Computer Science, Iowa State Uni\u00adversity. Available from http://www.jmlspecs.org, \nFeb. 2007. [30] G. T. Leavens and W. E. Weihl. Speci.cation and veri.cation of object-oriented programs \nusing supertype abstraction. Acta Informatica, 32(8):705 778, Nov. 1995. [31] K. R. M. Leino. Data groups: \nSpecifying the modi.cation of extended state. In OOPSLA 98 Conference Proceedings, volume 33(10) of ACM \nSIGPLAN Notices, pages 144 153. ACM, Oct. 1998. [32] B. H. Liskov and J. M. Wing. A behavioral notion \nof subtyping. ACM Trans. Prog. Lang. Syst., 16(6):1811 1841, Nov. 1994. [33] C. Morgan. Procedures, parameters \nand abstraction: separate concerns. Science of Computer Programming, 11(1), Oct. 1988. Reprinted in the \nbook On the Re.nement Calculus. [34] C. Morgan. Programming from Speci.cations: Second Edition. Prentice \nHall International, Hempstead, UK, 1994. [35] P. M\u00fcller. Modular Speci.cation and Veri.cation of Object-Oriented \nPrograms, volume 2262 of Lecture Notes in Computer Science. Springer-Verlag, 2002. [36] D. A. Naumann. \nVerifying a secure information .ow ana\u00adlyzer. In J. Hurd and T. Melham, editors, 18th International Conference \non Theorem Proving in Higher Order Logics TPHOLS, volume 3603 of Lecture Notes in Computer Sci\u00adence, \npages 211 226, 2005. [37] E. Olderog. On the notion of expressiveness and the rule of adaptation. Theoretical \nComput. Sci., 24:337 347, 1983. [38] M. J. Parkinson. Local reasoning for Java. Technical Report 654, \nUniversity of Cambridge Computer Laboratory, Nov. 2005. The author s Ph.D. dissertation. [39] C. Pierik. \nValidation Techniques for Object-Oriented Proof Outlines. PhD thesis, Universiteit Utrecht, 2006. [40] \nA. Poetzsch-Heffter, P. M\u00fcller, and J. Sch\u00e4fer. The Jive tool. http://tinyurl.com/3cke34, Apr. 2006. \n[41] P. V. Roy and S. Haridi. Concepts, Techniques, and Models of Computer Programming. The MIT Press, \nCambridge, Mass., 2004. [42] N. Soundarajan and S. Fridella. Incremental reasoning for object oriented \nsystems. In O. Owe, S. Krogdahl, and T. Lyche, editors, From Object-Orientation to Formal Methods, Essays \nin Memory of Ole-Johan Dahl, volume 2635 of Lecture Notes in Computer Science, pages 302 333. Springer-Verlag, \n2004.  \n\t\t\t", "proc_id": "1297027", "abstract": "<p>What we call a''higher-order method\" (HOM) is a method that makes mandatory calls to other dynamically-dispatched methods. Examples include template methods as in the Template method design pattern and notify methods in the Observer pattern. HOMs are particularly difficult to reason about, because standard pre- and postcondition specifications cannot describe the mandatory calls. For reasoning about such methods, existing approaches use either higher order logic or traces, but both are complex and verbose.</p> <p>We describe a simple, concise, and modular approach to specifying HOMs We show how to verify calls to HOMs and their code using first-order verification conditions, in asound and modular way.</p> <p>Verification of client code that calls HOMs can take advantage of the client's knowledge about the mandatory calls to make strong conclusions. Our verification technique validates and explains traditional documentation practice for HOMs, which typically shows their code. However, specifications do not have to expose all of the code to clients, but only enough to determine how the HOM makes its mandatory calls.</p>", "authors": [{"name": "Steve M. Shaner", "author_profile_id": "81339527385", "affiliation": "Iowa State University, Ames, IA", "person_id": "P905216", "email_address": "", "orcid_id": ""}, {"name": "Gary T. Leavens", "author_profile_id": "81452614743", "affiliation": "Iowa State University, Ames, IA", "person_id": "P94154", "email_address": "", "orcid_id": ""}, {"name": "David A. Naumann", "author_profile_id": "81100447696", "affiliation": "Stevens Institute of Technology, Hoboken, NJ", "person_id": "PP14157099", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297053", "year": "2007", "article_id": "1297053", "conference": "OOPSLA", "title": "Modular verification of higher-order methods with mandatory calls specified by model programs", "url": "http://dl.acm.org/citation.cfm?id=1297053"}