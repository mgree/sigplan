{"article_publication_date": "10-21-2007", "fulltext": "\n * ILEA: Inter-Language Analysis acrossJava andC Gang Tan GregMorrisett Boston College Harvard University \ngtan@cs.bc.edu greg@eecs.harvard.edu Abstract Javabug .nders perform static analysis to .nd implementa\u00adtion \nmistakesthatcanleadtoexploitsandfailures;Javacom\u00adpilers perform static analysis for optimization. If \nJava pro\u00adgrams contain foreign function callstoClibraries,however, static analysis is forced to make \neither optimistic or pes\u00adsimistic assumptions about the foreign function calls, since modelsof theClibraries \nare typically notavailable. We propose ILEA (stands for Inter-LanguagE Analysis), which is a framework \nthat enables existing Java analyses to understandthebehaviorofCcode.Our framework includes: (1) a novel \nspeci.cation language, which extends the Java Virtual Machine Language (JVML) with a few primitives that \napproximate the effects that theCcode might have; (2) an automatic speci.cationextractor, whichbuilds \nmodelsof theC code. Comparing to other possible speci.cation lan\u00adguages, our languageisexpressive,yetfacilitates \nconstruc\u00adtion of automatic speci.cation extractors. Furthermore, be\u00adcause the speci.cation language is \nbased on the JVML, ex\u00adisting Java analyses can be easily migrated to utilize speci\u00ad.cations in the language.We \nalso demonstrate the utility of the speci.cations generated, by modifying an existing non\u00adnull analysis \nto identify null-related bugs in Java applica\u00adtions that containC libraries. Our preliminary experiments \nidenti.ed dozensof null-relatedbugs. Categories and Subject Descriptors D.2.4[SoftwareEngi\u00adneering]: \nSoftware/ProgramVeri.cation; F.3.1[Logic and Meanings of Programs]: Specifying andVerifying and Rea\u00adsoning \nabout Programs; D.3.4[Programming Languages]: Processors Compilers GeneralTerms Languages, Reliability,Veri.cation \n* This work was supported in part by AFOSR Grant F49620-01-1-0298. Anyopinions, .ndings, and conclusions \nor recommendations in this publi\u00adcation are those of the authors and do not re.ect the views of this \nagency. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n07, October 21 25, 2007, Montr \u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; 2007ACM 978-1-59593-786-5/07/0010... \n$5.00 Keywords Inter-language analysis, Java Native Interface, JNI, JVML, Speci.cation extraction 1. \nIntroduction Compilers have long used static analysis to determine when itis safeto perform optimization.Today, \nwhen securityand reliability are as much of a concern as performance, many tools (c.f., [11, 34, 19, \n21, 5]) rely on static analysis to .nd implementation errors that can leadtoexploitsandfailures. In both \nsettings, the precision of a given analysis is limited by a combination of the approximations used for \nmodeling code and data, as well as the horizon of the analysis the size of the program unit that is analyzed \n(i.e., whole program, module, class, method, etc.) When looking for bugs in security-critical code, high \nprecision is needed to ensure all potential .aws are found and thatfalse positives are minimized. Similarly,in \ncontexts where high performance is desired, high precision enables advanced optimizations.In both settings,extendingthe \nhori\u00adzonofan analysis canhavea signi.cant impact.Forexam\u00adple, recent studies show that inter-procedural \nanalysis can resultin signi.cant performancegainsover intra-procedural techniques, even in the context \nof just-in-time Java compil\u00aders [22, 31, 33, 32]. Unfortunately, the horizon of most analyses is limited \na priori to code written in a single language, and yet most real applications consist of a mixture of \ncode written in different languages.Forexample, manyrealJava applications utilize theJava Native Interface \n(JNI [24])to accessClibraries. In\u00addeed, almost anyuseful Java application mixes Java and na\u00adtiveCcode \nsince manyclassesprovidedbyaJava platform areinfactjust wrappersfor underlyingnativeCcode.Forin\u00adstance, \nthe often-usedjava.io.FileInputStream classin Sun s JDK uses the JNI to invoke operating-system functions \nto perform .le operations. Another example is the classes un\u00adderjava.util.zip,whicharejust wrappersthatinvokethepop\u00adular \nZlibC library.For functionality and convenience, any Javaplatform containsasigni.cant amountof nativeCcode. \nForexample,Sun sJDK1.5.0 containsover700,000linesof native C/C++ code.1 1We measured the lines of C/C++ \ncode under the directories j2se/src/share/native, j2se/src/solaris/native, and j2se/src/windows/native \nin Sun s JDK 1.5.0. Around 80,000 lines are in C++, while the rest are in C. Since native C code in Java \napplications is plentiful, one may wonder how existing Java analyses treat a native\u00admethod call from \nJava. Typically, they make one of two choices: Either theymake an optimistic assumption, which essentially \nassumes the native method call is a nop, or they makea pessimistic assumption, which assumes anything \ncan happen in the native method. Bug .nders tend to make the former choice,toavoidtoomanyfalsepositives(whichalso \nmeans that theymay miss some realbugs). Java optimizers tend to make the latter choice, as theyneed to \nguarantee the correctness of the optimizations that theyperform. This paper asks the question how can \nwe extend the horizonofexistingJavaanalysestocovernativeCcode? .A solutionto this problem enablesaJavabug-.nderto \nsearch forbugs acrossJavaandC,and enablesaJava optimizerto catch more optimization opportunities. The \nbasic approach that we advocate is to use a separate tool to construct a speci.cation (i.e., model) of \ntheCcode, andthenextendthe analysissothatit understandsthespeci\u00ad.cation. Given this general approach, \ntwo questions remain: What speci.cation language would be the best for all anal\u00adyses? and Howdo we generate \nspeci.cations for nativeC methods? 1.1 Possible speci.cation languagesfor nativeCcode The nativeCcode \nitself,isin some sense, the most accurate speci.cation in that it loses no information. However, the \nactual code is a poor model for two reasons: First, to use the model, we must modify each Java analysis \nso that it understandsCcode, which isn tportable and often demands a complete reworking of abstract domains. \nSecond, many parts of the C code may not be relevant to a given Java analysis.Asanexample,the fdlibmlibrary(amathlibraryin \nC)usedbythe classesinjava.lang.StrictMathhasover8,500 linesofCcode. Almostallthecodein fdlibmperformpure \ncomputation and makes no modi.cation to the Java heap. Thus,thevast majorityofthe8,500linesofcodeis irrelevant \nfor e.g., a points-to analysis. Another possible speci.cation language is some anno\u00adtation language, \ndesigned for the particular property that a Java analysisisinterestedin.Forexample, one could usethe \nimmutability speci.cations advocated by Pechtchanski and Sarkar [32] to annotate side-effect-free native \nmethods. If a Java bug .nder intends to search for bugs of null derefer\u00adences across native code, one \ncould use the nonnull speci.\u00adcations (as in [7]) to annotate the return values and parame\u00adters of native \nmethods. As a last example, Guyer and Lin s annotation language [17] could be used for specifying data \n.ow properties. However, this approach is also problematic. As withCcode, we must teachexisting analyses \nto under\u00adstand the syntax and semantics of the annotations. Further\u00admore,whenanew propertyof interest \ncomesalong,wemust invent a new kind of annotation. In short, anysimple set of annotations will be incomplete \nas a speci.cation language. To achieve completeness, we could specify the behav\u00adior of C code using pre-and \npost-conditions in the style of Hoare logic, and as advocated by both Spec# [1] and ESC/Java [11]. Here, \nwe effectively model the C code as a relation that captures connections between the parame\u00adters, the \nreturn value, and the initial and .nal Java heaps, but that abstracts over the actual steps of the C \ncode, and the state outside the Java abstract machine. The approach is more .exible than simple annotations \nbecause we can pro\u00advide a range of speci.cations, from simple summaries to a (relatively) complete characterization \nof the effect of theC codeontheJavaheap.Forexample,we can summarizethe effect of any Cprocedure by using \nthe everywhere-de.ned relation (which effectively tells an analysis nothing), or if we haveapowerful \nlogic,we can capturea precise speci.cation of theCcode, at least with respect to the state of the JVM. \nThekeyproblem with logic-based summaries,is thatit may require signi.cant effort to change an existing \nJava analysis to understand and utilize the speci.cations, as they are in a different language from Java \nor C. The approach that we advocate is to use a slightly ex\u00adtendedJavaVirtual MachineLanguage(JVML)tomodelthe \nCcode.Thekeyadvantageis thatexisting analyses already understand the syntax and semantics of the JVML \nlanguage, and our proposed extensions are relatively modest. Further\u00admore, if the nativeC code can befaithfully \ncompiled into the JVML, then we canbuilda completely accurate model. Of course, we cannot hope to compile \nallCcode,but as we argue below, ourextensionsmakeit possibletobuild use\u00adful, conservative models of the \nbehavior of the C code, at least with respect to the inputs, outputs, and the changes to the Java heap. \nIn effect, our extended JVML code is an al\u00adternative representation of a relational speci.cation and \nthus enjoys the expressiveness and portability of the logic-based approach. 2. Extended JVML Our proposed \nspeci.cation languageextends the JVML with a few extra primitives for approximating the behavior of C \ncode that cannot be faithfully compiled into Java. For instance, supposewewishtomodelaCfunctionthatinvokes \na system call such as getpid. We could approximate the behavior of this call by using JVML code that \nreturns a random number. Of course, there are no JVML instructions that will truly give us back a random \nnumber, so we add a new operation, choose t , which returns a random t value. Nowtomodelahigher-level \nsystemcall,suchas gettime\u00adofday(), which might allocateaJava objectof typeTime {int sec; int msec; }, \nwe could use JVML code that does ef\u00adfectively: new Time(choose(int), choose(int)) We also add an operation \nmutate(x:object), which has the effect of causing some (type-preserving) mutation to the object referencedbyx.Soto \nmodelaCfunctionthatmight mutate anyobject in the heap, we could do: Object x = choose(Object); mutate(x); \n The existing JVML instructions, together with choose and mutate, can specifyavarietyof properties.We \npresent a few examples. 1)The program can mutateexisting objectsofanytypebut cannot allocate: for (int \ni = 0; i < choose(int); i++) { Object x = choose(Object); mutate(x); } 2) The program can allocate arbitrary \nnumber of objects of typeT: for (int i = 0; i<choose(int); i++) { new(T); } 3)The programcan accessanyobjectoftypeT,butdoesnot \nmodify anything, nor does it access objects of incompati\u00adble types: for (int i = 0; i<choose(int); i++) \n{ T x = choose T; boolean b = x.equals(x); } Wehave presented theseexamples usingJava source syn\u00adtax, \nfor its simplicity and clarity. Nevertheless, we base our speci.cation language on the JVML, for the \nexpressiveness of the JVML. Furthermore, users can still write speci.ca\u00adtions in Java source syntax, \nand a separate tool can convert them into JVML speci.cations. To make our speci.cation language precise, \nwe have ex\u00adtended the syntax and semantics of the JVMLf model, for\u00admalizedbyFreundand Mitchell[13].Asummaryofthesyn\u00adtax \nfor our extended-JVML model is given in Figure 1. The change2 over the syntax of JVMLf is the addition \nof the fol\u00adlowing instructions: choose t : choose a random object of type t and place it on the operand \nstack.  mutate: mutate the object (or array) whose reference is on the top of the operand stack.  top: \nmay have any type-preserving effect on the JVM heap (including mutation and allocation).  2We also add \na label instruction, and use abstract labels instead of offsets in jump instructions.We then use the \nJasmin [26] assembler to compute the offsets of labels; see later discussion. instruction I ::= choose \nt | mutate | top | label l | ifeq l | goto l | new s | nop | push v | pop | store d | load d | add | \nnewarray t | arraylength | arrayload t | arraystore t | return | returnval | ... JVML type t ::= int \n| void | Array t | s | ... class name s ::= java/lang/Object | java/lang/String | ... label l var id \nd Figure 1. Extended JVML syntax (An excerpt) This set of new primitives is designed considering the \npossibleeffectsthataCfunctionmayhaveontheJVMheap. Note that we do not have a separate primitive for allocating \nobjects, since the JVML instruction new s already cov\u00aders the job of allocation. From the JVM s perspective, \nthe changes to the JVM heap is the most relevant effect thatC code might have.For analyses such as dead-code \nelimina\u00adtion, other effects such as the I/O effect of theCcode may also be relevant. More primitives \ncan be added to accommo\u00addate those,but we restrict ourselves to the JVM-heap effect in this paper. We \nhave a top primitive in the language, for a couple of reasons. First, it serves as a safe exit for cases \nthat are dif.cult or impossible to specify accurately. It provides a coarse, yet safe, speci.cation. \nSecond, although we focus on the JVM-heap effect in this paper, the semantics of top can be easily changed \nto have anyeffect, such as the I/O effect. Existing JVML instructions are partial functions; their semantics \ndeterministically maps a JVM state to the next JVM state. The new primitives, on the other hand, are \nnon\u00addeterministic, and thus denote relations between JVM states. For example, mutate(x) relates a JVM \nstate to anynew state that is the result of performing (type-preserving) mutations to the object.To specifyaCfunction, \nwe useexisting JVML instructions for characterizing the function s deterministic part, and leave its \nnon-deterministic part for the new primi\u00adtives. The idea of using the JVML plus a few relational primi\u00adtives \nas the speci.cation language has manybene.ts: This speci.cation language is expressive: It can model \nthe input/output effects of well-behaved C code. Intu\u00aditively, well-behavedC code respects well-typedness \nof Java heaps; we formalize the notion of well-behavedC code later.We regardexpressivenessa considerable \nad\u00advantage over other speci.cation languages. Anyexisting analysis on the JVML will be easily carried \nover to our speci.cation language. The additional work is to handle the new primitives, which is usually \nan easy augmentation.Forexample,in an intra-procedural anal\u00adysis, the treatment of top should be no different \nfrom the treatment of procedural calls. The smooth transition for existing analysesis demonstratedby \nourexperience with modifyinganexisting nonnull analysis,whichwillbede\u00adtailed in Section 4.  The new \nprimitives make it possible to automatically extract a range of models for C code. In particular, an \nextractor always has safe exits through the new primi\u00adtives. In Section 3, we describe one speci.cation \nextrac\u00adtor, which takes full advantage of the new primitives; for example, theextractor does not modelC \nmemory, soit always return choose int for any integer from the C memory.  It also supports by-hand construction \nof models. Pro\u00adgrammers can easily specify coarse modelsofClibraries by writing small snippets of (extended) \nJava code which are then compiled to extended JVML speci.cations. (Of course, verifying that the model \nis correct would be gen\u00aderally impossible.)  2.1 Models of our extended JVML language We have informally \ndiscussed the meanings of the new JVML instructions. In this section, we make their seman\u00adtics precise,by \npresenting their formal de.nitions. We base our de.nitions on Freund and Mitchell s JVML model. Relevant \nconcepts from their model are presented in Figure2.Asa summary,thedynamic semanticsof JVMLf is captured \nby the judgment G f C0 . C1, meaning that a program representedby G moves from con.guration C0 to C1.AJVMLf \nmachine con.guration C isa pair A; h,where A is a stack of activation records and h is a JVM heap. Both \nA and h are detailed in Figure 2; we only mention that all objects and arrays in the heap h contain runtime \ntype tags, andTag(h, a) returns the type tag for the object at location a in h. We extend the semantics \nof JVMLf for our new instruc\u00adtions in Figure 3. Each of the instructions has a relatively straightforward \nde.nition. Havinga model for ourextended JVML, we next formal\u00adize the assumption of well-behavedC code.C \ncode has its own world, including its memory heap, I/O behaviors, and so on. Therefore, when consideringthe \nJVM andCtogether, a machine state consistsofa JVML con.guration A; h anda Cworld w.We write a complete \nmachine state as (A; h; w). 3JVMLf has additional components for exception handling and object initialization; \nwe omit them in our formalism. G f C0 . C1 A program represented by G moves from con.guration C0 to C1. \nG A global environment; the representation of a JVMLf program. C = A; h AJVMLf machine con.gura\u00adtion. \nA Astack of activation records. (M, pc, f, stk) One activation record3: M : the method reference of the \ncurrent activation record. pc : the address of the next in\u00adstruction to be executed. f : a map from the \nset of local-variable indexes to values. stk : the operand stack. h A JVMLf heap, mapping lo\u00adcations \nto objects or arrays. (({|si, li, .i|} = vi))i.I s An object, mapping .eld ref\u00aderences to values; i . \nI refers to the i-th .eld in the object. {|s, l, .|} A .eld reference, with class name s, label l, and \ntype .. [ vi] i.[0,n) Array t An array, with length n. Tag(h, a) The runtime type tag of aheap object \nor array at location a. Judgments: Notations: A stack of activation records, (M, pc, f, stk)\u00b7 A whose \ntop is (M, pc, f, stk). An operand stack, whose top v \u00b7 stk is v. Figure 2. Summary of the dynamic semantics \nof the JVMLf G f M (pc)= choose t the current instruction is choose t G,h f v : tv has type t G f(M, \npc, f, stk)\u00b7 A; h .(M, pc +1, f, v \u00b7 stk)\u00b7 A; h G f M(pc)= mutate the current instruction is mutate h[b]= \n[ vi] i.[0,n) array of element type t at location b Array t ] i.[0,n) o =[ vi i Array t , and .i . [0,n). \nG,h f vi i : t mutate the array toget o G f(M, pc, f, b \u00b7 stk)\u00b7 A; h .(M, pc +1, f, stk)\u00b7 A; h[b . o] \nG f M(pc)= mutate the current instruction is mutate h[b]= (({|isi,li,.i|} = vi))i.I iobject of type s \nat location b s o = (({|si,li,.i|} = vi))i.I , and .i . I. G,h f v: .i mutate the object toget o si \nG f(M, pc, f, b \u00b7 stk)\u00b7 A; h .(M, pc +1, f, stk)\u00b7 A; h[b . o] G f M(pc)= top the current instruction \nis top G f h [ hi type-preserving heap extension G f(M, pc, f, stk)\u00b7 A; h .(M, pc +1, f, stk)\u00b7 A; hi \nFigure 3. Models of choose t , mutate, and top. DEFINITON 1. (Rule for type-preserving heap extensions.) \nG f h wt G f hi wt .a . dom(h).a . dom(hi) . Tag(h, a)= Tag(hi,a) G f h [ hi DEFINITON 2. (Well-behavedCcode.) \nGiven an initial ma\u00adchine state (A; h; w) such that G f h wt, C code is well behavedif for anyresultof \nitsexecution, say (Ai; hi; wi),we have Ai = A and G f h [ hi. Inwords,wesayCcodeis well behavedifit does \nnot change the activation records of the JVM, and performs only type\u00adpreserving modi.cations to the Java \nheap, including alloca\u00adtion.(It can perform arbitrary changestoitsownworld.)We believe the well-behaved \nassumptionof theCcodeisa rea\u00adsonable one. On the other hand, it is possible to intentionally or unintentionally \nwrite ill-behavedC code, e.g., code that writes random integers to random memory addresses. In this case, \nwe rely on our previouswork, the SafeJNI [35] system, to prevent ill-behavedCcode from destroying the \nJVM state. For instance, the SafeJNI system inserts dynamic checks to theCcodesothatthecodeisstoppedifit \ndirectly writesto the memory addresses that belong to the JVM. Our language is expressive in the sense \nthat we can use a combination of the primitives to conservatively simulate the Java-heap effects of any \nwell-behaved C program. In particular, a loop similar to the one given at the beginning of this section \ncan be written that relates a heap to all of its well-typed mutations. When followed by a loop to allocate \nobjects of the correct types (passing the constructors values obtained via choose), we geta program that \nrelatesa heap to anyof its well-behaved relatives. Ideally, our speci.cation language would satisfy a \n(rela\u00adtive) completeness property in the sense that for any well\u00adbehavedCprogram, we could write anextended-JVML \npro\u00adgram that relates only those heaps relatedby theCprogram. Unfortunately, this property does not hold.Forexample,aC \nprogram could use pointer arithmetic togain access toa par\u00adticularobjectintheJavaheapand mutateit,buttheonlyway \nwe can model thisisthroughthe useof choose . While this is sound, it is not precise as we may end up \nchoosing other objects. In general, the only way to establish completeness would be to either add more \ninstructions to the JVML, or to fur\u00adther restrict our de.nition of well-behaved Ccode to the point where \nwe can always effectively compile its actions on theJava heap into deterministic JVML code.We resisted \nadding more instructions because this would make it harder to integrate with an analysis.We resisted \nstrengthening the de.nition of well-behaved to admit moreCcode into the framework. 3. Automatic speci.cation \nextraction We have written an automatic speci.cation extractor, which takesCcode as input, and outputs \nitsextended-JVML spec\u00adi.cation. Our speci.cation extractor is implemented in the CIL framework [29] as \na CIL feature. Before our extractor isinvoked,theCIL frontend convertsCtotheCIL interme\u00addiate language. \nThe conversion compiles away many com\u00adplexities of C, thus allowing our extractor to concentrate on a \nrelatively clean subset of C. Our speci.cationextractor can deal with nearly allCfea\u00adtures, thanks to \nthe extra instructions; in the worst case, the top speci.cation is issued. The extractor makes the compi\u00adlation \nof common and easy cases precise, while leaving rare or dif.cult cases for approximation. One of the \nmost dif.\u00adcult issuesof analyzingCishowto deal with pointer aliases; ourextractor depends onapoints-to \nanalysis providedbythe CIL.Wewouldliketo stressthatour speci.cationextractor is not the only possible \none. Our speci.cation language al\u00adlows the construction of a range of speci.cation extractors, each of \nwhich can make its own trade-offbetween precision and approximation. To present the main ideas behind \nour speci.cation ex\u00adtractor, we have formalized the extraction process for a sub\u00adset of C language, including \npointers, assignments, condi\u00adtional statements, and a representative set of JNI API func\u00adtions.For simplicity, \nthis subset omits loops, function calls, struct/union types, and others.We will discuss how our im\u00adplementation \ntreats these features in Section 3.2. Csyntax. The syntax fora subsetof theClanguage repre\u00adsenting the \nCIL intermediate language is given in Figure 4. There are CIL expressions, which have no side effects \nand no control .ow, and CIL statements, which may have side effects or control .ow. In an assignment \nstatement lv = d , the l-value lv refers to a region of storage; it is either a vari\u00adable x, or *e, which \ndenotes the memory slot pointed to by e. The right hand of the assignment (or d)can be either an expression, \nor a JNI API call4. Our formalism includes a subset of JNI API functions, which are related to array \noperations. The meaning of these functionsisexplainedinTable1. Notice that the JNI treats primitive-type \narrays and object arrays differently. Primitive\u00adtype arrays are accessed through direct pointers (returnedby \nfunctions such as GetIntArrayElements); object arrays are accessed on a per-element basis. We use the \nsymbol t for a C type, to distinguish it from a JVML type t. The type jint * is a pointer to an array \nof integers in the JVM; it is the return type of GetIntArrayElements. The type jobject is the type for \nref\u00aderences to Java objects. The CIL front end compiles away manycomplexities of C.Forexample, our syntax \ndoes not allow if (japi) s1 s2 : the CIL front end creates a new local variable tmp, and transforms the \nstatement to tmp = japi; if (tmp) s1 s2; In a similar fashion, the CIL converts C expressions, which \nmay have nondeterministic order of side effects[30], to CIL statements and side-effect-free CIL expressions. \nEf\u00adfectively, the CIL linearizes the order of side effects present 4Instead of being invoked directly, \nJNI API functions are invoked through the function pointers stored in an interface table. We simplify \nthis in the formalism. 5GetIntArrayElements in the JNI has an extra argument isCopy; we omit it in the \nformalism. l-value lv ::= x |*e expression e ::= n | e1 + e2 | lv JNI API japi ::= GetArrayLength(e) \n| GetIntArrayElements(e) | ReleaseIntArrayElements(e, e) | GetObjectArrayElement(e, e) | SetObjectArrayElement(e, \ne, e) | NewIntArray(e) | NewObjectArray(e, e, e) exp orJAPI d ::= e | japi statement s ::= s1; s2 | if \n(e) s1 s2 | lv = d | japi | return(e) | return Ctype t ::= int | void | t * | jint *| jobject function \nfn ::= t Fun-Name(t1 x1, ...,tn xn) { ti 1 y1; ... ; ti ym; m s; } Figure 4. OurCSyntax in the C expressions. \nIn the following discussion, we will equate expressions with CIL expressions. Notation. Weuse the notationI1forasequenceofextended-JVML \ninstructions, and similarly use 1e for a sequence of expressions.We use the notation [] for the empty \nsequence, and use I11@I12 to denote the concatenation of I11 and I12. Fi\u00adnally, since the speci.cation \nextractor essentially performs a compilation from C to the extended-JVML, we will use the phrase speci.cation \nextraction and compilation in\u00adterchangeably throughout the discussion. Compiling C functions. The rules \ngiven in Figure 5 de\u00ad.ne a compiler that maps aC function into a sequence of extended-JVML instructions \nI1. The compiler .rst constructs a compilation environment F. This construction is formal\u00adized using \nthe de.nitions mapTy(-) and mapVar(-, -). The de.nition mapTy(t) mapsaCtype t to a JVML type t. This \nde.nition is partial; in general, it does not map C pointer types. The de.nition mapVar([t1 x1; t2 x2; \n...],d) maps C variables to JVML local variables, starting from the index d. It maps only those variables \nwhose types are mapped. With the help ofmapTy(-) and mapVar(-, -), we get a compilation environment F \nof the form {x1 :(d1,t1),...,xn :(dn,tn)}. It mapsCvariables into its JVML local-variable indexes and \ntypes.6 The body of theC function is then compiled under the environment F, and a return type tret, which \nis mapped from the return type of the function. 6NoticethatinFigure5,wealwaysstartfromindex1,asindex0is \nreserved for the self object. JNI API Functions Description int GetArrayLength(jobject array) Get the \narray length. jint * GetIntArrayElements(jobject array)5 . Return a pointer to the elements of the integer \narray, or null if the operation fails. void ReleaseIntArrayElements(jobject array, jint * body) Release \nthe body pointer to array. jobject GetObjectArrayElement(jobject array, int n) array is a reference to \nan array of Java objects; return the n-th element. void SetObjectArrayElement(jobject array, int n, jobject \nobj ) Set the n-th element of array to obj . jobject NewIntArray(int len) Construct a new integer array, \nwith length len. jobject NewObjectArray(int len, jclass t, jobject init) Construct a new object array, \nwith length len and element type t;all elements are initially set toinit. Table 1. JNI API functions \nii F= mapVar([t1 x1; ... ; tn xn; t1 y1; ... ; tym], 1) a m t, if mapTy(t)= t tret = void, otherwise \nF,tret f s I1 .. t Fun-Name(t1 x1, ...,tn xn) f . { ti 1 y1; ... ; ti ym; . I1 m s; } mapVar([t1 x1; \nt2 x2; ...],d) .t . {x1 :(d, t1)}. mapVar([t2 x2; ...],d + 1), = if mapTy(t1)= t1 . mapVar([t2 x2; ...],d), \notherwise mapTy(int)= int mapTy(jint *)= Array int mapTy(jobject)= java/lang/Object Figure 5. Ruletoextract \nJVML speci.cations fromCfunc\u00adtions Compiling expressions. Figure 6 presents our rules for compiling expressions. \nWhen compiling an expression e under an environment F, there are two possible outcomes. The .rst is that \nthe compilation is successful it is able to accurately track the result of e: F f e (1 I,t ) In this \ncase, the compilation produces a list of extended-JVML instructions that put the value of the expression \non the top of the JVML stack, and also returns the JVML type ofthevalue.Anexampleistheruleforaconstant \nn,in which it just pushes the constant onto the stack. The second case is that the compilationfails it \ncannot track the value of the expression: F f e ? F f e (1 I,t ) or F f e ? F f n ([push n], int) F f \ne1 (I11, int)F f e2 (I12, int) F f e1 + e2 (I11@I12@[add], int) F f e1 + e2 ? F(x) = (d, t) x /. dom(F) \nF f x ([load d], t ) F f x ? F f *e ? Figure 6. Rules for compiling expressions In this case, the compilation \nreturns ? . An example is the rule for compiling *e,in which it always return ? ; the rules do not modelCmemory. \nRules in Figure6 are all straightforward. The only point we would like to make is that the two rules \nfor e1 + e2 are ordered, in the sense that only if the .rst rule is not applicable, the second rule applies.Manyrules \nthat we will see later are in this style. Compile or choose. Compilation of an expression may produce \n? , an untracked value. In certain cases, however, a value for the expression is needed even though it \nmay be untracked. For example, to compile if (e) s1 s2 , we always need an integervalue for e thisisexactly \nwherethe new JVML instruction choose t can come into play. In Figure 7, we de.ne a notion of compileOrChoose(F, \ne, t), which tracks the exact value of e if the compilation of e succeeds in producing a value of type \nt, and otherwise choosesarandomvalueoftype t.In additiontoexpressions, this compile-or-choose concept \nis also de.ned on JNI API calls; we defer this de.nition to the place when we discuss the compilation \nof JNI API calls. compileOrChoose(F, e, t ) a 1 (1 I, if F f e I,t) = [choose t], otherwise jvmE.ects(F,e) \n= [] 1 F,tret f sI F,tret f s1 I11 F,tret f s2 I12 F,tret f s1; s2 I11@ I12 1 Ie = compileOrChoose(F, \ne, int) Figure 7. The de.nitions of compileOrChoose(-, -, -)  F,tret f s1 I11 F,tret f s2 I12 and jvmE.ects(-, \n-), for expressions lfalse and 1lend fresh Ie@ Compiling statements. In Figure 8 we present rules for \n[push 0; ifeq lfalse]@ compilingCstatements, using the judgment F,tret f if (e) s1 s2 I11@[goto lend]@ \n1 [label lfalse]@I12@ F,tret f s I. [label lend]Inwords, theCstatement s is compiled to a sequence I1of \nextended-JVML instructions, underF and tret. The type tret F(x)=(d, t) is mapped from the declared return \ntype of the function that I1= compileOrChoose(F, d, t ) s belongs to. It is used in the rule for return(e) \nstatement to F,tret f x = d I1@[store d] inform it of the expected type of e. Most rulesin Figure8 are \nstraightforward.As anexam\u00ad x/. dom(F) I1= jvmE.ects(F,d) ple, to compile if (e) s1 s2 , we .rst compile \ne, s1, and s2; then we insert appropriate comparisons, labels and jumps. F,tret f x = d I1Furthermore, \nin the case that the compilation of e fails, a choose int is inserted in the place of e. 1 I1 = jvmE.ects(F,d) \nThere are two rules for the case of x = d. The second a 1[top], if mayPtJVM(e) = true I2 = rule uses \na jvmE.ects(F,d) function, which returns a se\u00ad [], otherwise quenceofinstructions that re.ectsthe possibleeffectsofex\u00ad \nmayModVar = {F(x) | mayPtTo(e, x) . x . dom(F)}ecuting d. This is because d may be a JNI API call that \nhas 1 I3 =[choose t; store d; ...], for each (d, t ) . mayModVar effects on the JVM heap. Since expressions \nhave no effects, jvmE.ects(F,e) is de.ned to be the empty sequence in Fig-F,tret f *e = d I11@I12@I13 \nure 7. a 1 (1 The compilation rule for *e = d deserves explanation. 1I@[pop], if F f japi I,t) It uses \ntwo auxiliary predicates described below; the com-I1 = I, (1 1if F f japi I, ?) putation of these predicates \nwill be described in Section 3.2. F,tret f japi I11 mayPtJVM(e): expression e may point to the JVM . \n. [return], if tret = void heap mayPtTo(e, x): expression e may point to the address I1= . compileOrChoose(F, \ne, tret)@[returnval], otherwise of variable x If e may point to the JVM heap, then the assignment F,tret \nf return(e) I1 *e = d may modify the heap. In this case, we give it a a top speci.cation, which means \nthe assignment may have 1[return], if tret = void any effect on the JVM heap. To ensure soundness of \nthe I =[choose tret; returnval], otherwise speci.cation, this rule is very conservative. Other extractors \n1 F,tret f return I may produce a more precise speci.cation, by using a more accurate analysis. Figure \n8. Rules for compiling statements The assignment *e = d can modify some local vari\u00adables, since *e may \nbe aliases of the local variables. This is why the rule for *e = d also sets all the possibly affected \nconditional statement is approximated by the choose int variables to random values. instruction. Other \nthan this approximation, the rest of the To be concrete, we present a toy C function and its functionis \ncompiledfaithfully. extended-JVML speci.cation in Figure 9. In the example, the variables i and j are \nmapped to JVML local vari\u00ad 7Note that there is a difference between the ifeq in the JVMLf by Freund ables \nwith indexes1and2, respectively. The pointervariable and Mitchell and the one in the JVML. The version \nin JVMLf takes two p is not mapped; this is why the *p expression in the operands, while the version \nin JVML takes only one. (a)ATOY CFUNCTION. int f(int i, int *p) { int j; 1(1 I, if F f japi I,t) 1(1 \nI@[pop; choose t ], if F f japi I,ti) if(*p)j =i; = else j = i + i; return j; } (b)EXTENDED-JVMLSPECIFICATION \ncompileOrChoose(F, japi,t ) jvmE.ects(F, japi)= .. .. . a and t i . = t 1(1 I@[choose t], if F f japi \nI, ?) = 1(1 I@[pop], if F f japi I,t) ; We use ; to start comments ; Phi = {i : (1, int), j : (2, int)} \n; for if (*p) ... choose int push 0 ifeq7 lfalse ;forj =i load 1 store 2 goto lend label lfalse: ;forj \n=i+i load 1 load 1 add store 2 label lend: ; for return j load 2 returnval Figure 9. Acompilation example \nCompiling JNI API calls. Java applications that interact withCcode through the JNI changes the JVM state \nmostly through the JNI API functions.We could possiblygive the top speci.cation to all JNI API calls,but \nthatwouldlosea lot of useful information. Therefore, the extractor treats JNI API calls as special, interpreting \nthem at a higher-level of precision. Figure 11 presents the rules for compiling JNI API calls. The compilation \nmay result in two cases. The .rst case is (1 F f japi I,t), in which the instruction sequence I1performs \nthe side effects of the JNI API call, and also puts a value of type t on the top of the stack. The second \ncase is that F f japi (1 I, ?), in which the compilation cannot track the return value of the JNI API \ncall. However, it may still have side effects on the 1(1 I, if F f japi I, ?) [choose int; push 0; ifeq \nlfalse]@I1@ mayNull(I1)= [goto lend; label lfalse; push null]@ [label lend], where lfalse and lend are \nfresh labels. Figure 10. The de.nitions of compileOrChoose(-, -, -) and jvmE.ects(-, -), for JNI API \ncalls, and the de.nition of mayNull(-) JVM heap, whichis capturedbyI1. Note that in this case, the stack \nbefore the execution of I1will be the same as the stack after. The rules in Figure 11 are straightforward \ntranslations of the semantics described in Table 1. The rules for GetIntArrayElements use an auxiliary \nde.nition mayNull(-) in Figure 10, to capture the case of null return values when the operationfails. \nUsing null returnvaluesto indicate error conditions is very common in the JNI. The semantics of JNI API \nfunctions is described in the JNI manual [24].Afaithful compilationinvolvesa careful reading of the manual. \nThis process is straightforward, al\u00adthough laborious. 3.1 Properties of the speci.cation extractor We \ndescribe a few interesting theorems about the speci.ca\u00adtion extractor, based on the formalism. The proofs \nof these theorems are presented in appendix B. First, the compilation is complete in the following sense: \nTHEOREM 1. (Compilation Completeness)For anyCfunc\u00adtion fn, thereexistsa sequence I1of extended-JVML instruc\u00ad1 \ntions suchthat f fn I. Next, we show a theorem that states the list of instruc\u00adtions produced is always \nwell-typed in the extended JVML. Stating this theorem requires typing rules for the new in\u00adstructions; \nthe typing rules are shown in the appendix A. THEOREM 2. (Well-typed Compilation) If f fn I1, then I1is \na sequence of well-typed extended-JVML instructions. The de.nition of well-typed extended-JVML instruction \nse\u00adquences and the proof of the theorem are sketched in ap\u00adpendix B. We also conjecture that the sequence \nof extended-JVML instructionsisa conservative approximationof theC func\u00adtion, in terms of effects on \nthe JVM heap. CONJECTURE 1. (Conservative Compilation) Assuming a well-behaved and well-typedC function \nfn. If f fn I1, then the semantics of I1conservatively approximates the se\u00ad F f japi (1 I,t) mantics \nof fn:if theCfunctionfn bringsa state (A; h; w) to (1 or F f japi I, ?) (Ai; hi; wi), then the dynamic \nsemantics of I1can bring the JVM state (A; h) to (Ai; hi). F f e (1 I, Array t ) Proving this conjecture, \nhowever, requires modeling the F f GetArrayLength(e)(w@[arraylength], int) CIL s intermediate language \nsemantics; we leave it to fu\u00adture work. F f GetArrayLength(e) ([], ?)  3.2 Additional features (11 F \nf e I, Array int) In = mayNull(w) Having formalizeda subsetof our speci.cationextractor,we F f GetIntArrayElements(e)(I1n, \nArray int) discuss its other features. At a high level, the extractor tries to capture common and easy \ncases. An example is that com\u00adF f GetIntArrayElements(e) ([], ?) paring Java references to null isfairly \ncommon in JNI glue code, since JNI API functions often use null return values to indicate error conditions. \nThe system compiles such null F f ReleaseIntArrayElements(e) ([], ?) comparisons directly to ifnull and \nifnonnull instructions. On the other hand, the system leaves rare or dif.cult cases for F f e1 (I11, \nArray t ) approximation. For example, it does not track values in C I12 = compileOrChoose(F,e2, int) \n structs, unions, or arrays; these values are approximated us\u00adF f GetObjectArrayElement(e1,e2) ing the \nchoose t instruction. . (I11@I12@[arrayload t],t) The extractor can handle nearly all C features: loops; \nstructs; unions; arrays; global variables; type casts; function calls, includingClibrary function calls; \nJNI API functions, F f GetObjectArrayElement(e1,e2) ([], ?) including those that perform .eld accesses, \nJava-method in\u00advocations, catching/throwing exceptions, among manyoth\u00ad F f e1 (I11, Array t ) 1 I2 = \ncompileOrChoose(F,e2, int) ers. Before we describe a few important features of the ex- I13 = compileOrChoose(F,e2,t) \n tractor, we would like to point out two assumptions of the SetObjectArrayElement(e1,e2,e3) . extractor. \nFirst,it generates speci.cations thatfaithfully cap\u00ad F f (I11@I12@I13@[arraystore t ], ?) ture the JVM-heap \neffect, but may ignore other effects. If a Java analysis depends on other effects such as whether a Java \nobject may be referenced, the extractor needs to be ad- SetObjectArrayElement(e1,e2,e3) . F f justed \naccordingly. Second, the extractor assumes a single\u00ad ([choose (java/lang/Object); mutate], ?) threadedenvironment.It \ncannot handleCcodethatspawnsa newthread. It also does not handle JNI API functions related I1= compileOrChoose(F, \ne, int) to threads, such as MonitorEnter and MonitorExit. Having F f NewIntArray(e)(I1@[newarray int], \nArray int) stated these assumptions, we believethat theyare limitations oftheextractor,notofthe speci.cation \nlanguage.Forexam\u00ad ple, the speci.cation language can specify the read access of F f NewObjectArray(e1,e2,e3) \n([top], ?) Java objects,as demonstratedbyoneoftheexamplesinSec\u00adtion 2. It can also specify creation of \nnew threads by new Figure 11. Rules for compiling JNI API calls Thread().start() . Accessing .elds. The \nJNI uses a multi-step process to ac\u00adcess a .eld of an object: get the class object of the object; get \nthe .eld ID; then use the .eld ID to access the value of the .eld. An example of reading the value of \nan integer .eld named x is as follows: //Get the class object jclass cls = (*env)->GetObjectClass(env, \nobj); //Get the field ID fid = (*env)->GetFieldID(env, cls, \"x\", \"I\"); if (fid != NULL) { //Get the \nint field int i = (*env)->GetIntField(env, obj, fid); }; Our extractor could track the local dependencyinforma\u00adtion \nbetween Java-object references to compile the above code intoJVML get.eld instructions; it could even \nuse the techniquesbyFurr andFoster [15] that perform polymorphic type inferencesto tracktheJava typesofCreferences \ninter\u00adprocedurally.We decided to followa simpler route, which compiles GetObjectClass, GetFieldID, and \nGetIntField into JVML instructions that use the Java re.ection API.8 There are cases when it is dif.cult \nto even know which .eld the program is accessing (e.g., when the .eld name in GetFieldID is a computed \nstring). In such situations, the system uses choose t to approximate the value in a .eld of type t, and \nmutate for the effect of writing to a .eld. Pointer analysis. The compilation rule for *e = d in Fig\u00adure8usestwopredicates: \nmayPtTo(-, -),andmayPtJVM(-). The .rst one is computed by a generic pointer-analysis en\u00adgineprovidedbytheCIL.We \ncomputethe second predicate as follows: 1.We de.neaCattribute jref;a type having this attribute meansthatvaluesofthetypemaybeapointertotheJVM \nheap. 2.We annotate return typesof certainJNIAPI functionsto have the jref attribute; we also annotate \ncertainC types such as jobject to have the jref attribute. 3.We implemented a module that propagates \njref through theC program asa whole-program analysis.Forexam\u00adple, if there is an assignment p = q, and \nq has the jref attribute, then p also gets the attribute. The CIL front end merges allC.les intoasingle \n.le and thus allows whole\u00adprogram analysis. After these steps, any pointer of jref attribute may be a \npointer to the JVM heap. More on type mapping. The JNI includes a number of Java-reference types, such \nas jintArray and jstring. When used in C, all these reference types are aliases of jobject. Nevertheless, \nour system takes advantage of these reference typestomap themto more re.ned JVML types.Forexam\u00adple: mapTy(jintArray)= \nArray int mapTy(jstring)= java/lang/String 8Certain Java analyses may not admit speci.cations that use \nthe re.ection API. In this situation, we can always approximate the .eld operations; see the following \ntext. Cutting down the number of functions to compile. Our speci.cationextractor usesasimple strategytocutdownthe \nnumber of functions that it compiles. It performs a JVM\u00adeffect analysis onC functions, and only if the \nanalysis de\u00adcides that a function may have JVM effects, does the ex\u00adtractor compile theCfunction. This \nJVM-effect analysis is based on the jref attribute and the call graph of the whole program. Function \ncalls. We distinguish two kinds of function calls inC: callingaJVML function,or calling anotherCfunction. \nCallingaJVML functioninCgoes throughasimilar process as accessing .elds; thus we treat it similar to \nhow we treat .eld accesses. In the worst case, calling a JVML function produces the top effect. CallingaCfunction \neither resultsina real function call, or produces a nop if that function is not compiled (which means \nit does not have anyJVM effect). C system-library functions. For C system-library func\u00adtions that may \nproduce effects, we hand built models, and communicated these models to our system using C at\u00adtributes. \nSince manyofClibrary functions do not have ef\u00adfects, the default model is nop and thus theydo not require \nanyannotation. Loops. Since the environment F in our speci.cation ex\u00adtractor is .ow insensitive, compilingCloops \ndoes not pose much more dif.culty. It is possible to have a more re.ned analysis in which the environment \nF is .ow sensitive; that is, local variables have different types at different locations. A.ow-sensitiveversion \nmeans thatthe system needsto deal with merging environments at join points. Having discussed the major \nfeatures of our speci.cation extractor, in AppendixC we present the compilation of two example C functions. \nThe speci.cations there are in Jas\u00admin [26] JVML assembly syntax. 4. Utilizing speci.cations Wehaveproposedanextended-JVML \nlanguageasthespeci\u00ad.cation languagefor modelingCcomponentsin applications with mixedJava andCcomponents.Wehave \nalso described a speci.cation extractor for automatically generating mod\u00adels of C components. We claim \nthat via these models, an existing Java analysis, with small changes, can understand the behaviorofCcomponents. \nTherefore,aJavabug .nder can catch morebugs, andaJava optimizer can capitalize on more optimization opportunities.We \nsupport this claimby next reporting our preliminary experience with a Java bug .nder called Jlint[21]. \nJlint is a tool that .nds bugs in Java class .les, in the spirit of lint-like tools [20]. It performs \ndata.ow analysis to identifybugs in Java class .les, including null dereferences and deadlocks, among \nothers.We limit ourexperiments to .nding null-relatedbugs, whichis oneof the most common and troublesome \nerrors in OO programs. C code that interacts with the JVM through the JNI is particularly prone to null-relatedbugs. \nFirst, manyJNI API functions use nullvalues to report errors. Forexample, the GetFieldID function returns \nnull when the operationfails.9 The following code crashes Sun s JVM, when fid gets null. //Get the field \nID fid = (*env)->GetFieldID(env, cls, \"x\", \"I\"); //Get the int field int i = (*env)->GetIntField(env, \nobj, fid); The correct usage should .rst check if .d is non-null, before calling GetIntField. Another \nsource of null-related bugs is when Java code invokesa nativeC method with null parameters and theC method \nforgets to check it is non-null before dereferencing it, and vice versa. Jlint performs inter-procedural \ndata.ow analysis to iden\u00adtify null-relatedbugs.10We retro.tted Jlint sothatit accepts our extended-JVML \ninstructions. The changes to Jlint are minor, and we describe them next. At every program loca\u00adtion, \nJlintkeepsacontext, tracking states (null or non-null) of localvariables andvaluesin the operand stack.For \ntop, the context will not change (since Jlint does not track the nul\u00adlity of object .elds); for mutate, \nthe context will not change except for popping the top value on the stack; for choose t, we add a value \nto the operand stack, and mark it as possibly null if t is a reference type. 4.1 Preliminary experiments \nWe compileda setof fourJava programs that accessCcode through the JNI: java.lang.StrictMath: extracted \nfrom Sun s JDK 1.5.0; It performs basic numeric operations, and uses the JNI to invoke the methods in \ntheC Freely Distributable Math Library (fdlibm).  java.lang.zip: extracted from Sun s JDK 1.5.0; It \nper\u00adforms compression and decompression, and uses the JNI toinvoke the ZlibClibrary.  posix 1.0: a package \nthat provides JNI wrappers for ac\u00adcessing operating-system functions.  libreadline-java-0.8.0: a package \nthat provides JNI wrap\u00adpers for accessing the GNU readline library.  We ran preliminary experiments \non the above set of pro\u00adgrams.We .rst used the speci.cation extractor to generate extended-JVML models \nfor the C components in the pro\u00adgrams. The output syntax of the extractor is the assembler\u00adlike syntaxof \nJVML de.nedin Jasmin [26].We used Jasmin to convert the models generated by the extractor into Java 9Itfailsif \nthe speci.ed .eld cannotbe found, orif the class initializerfails, or if the system runs out of memory \n[24]. 10 More precisely, Jlint performs limited inter-procedural analysis in terms of tracking null values: \nIt tracks the case of passing null values to methods as parameters,butdoesnottrackthe caseof possiblynull \nreturnvalues;it also does not track the nullity of .elds. class .les; Jasmin relieves us of the work \nsuch as construct\u00ading constant pools, calculating label offsets, among others. Jasmin was changed slightly \nto encode the extra JVML in\u00adstructions via unused JVML opcodes.We then fed the class .lesfortheCcode, \ntogether withthe onesfortheJava code, tothe modi.ed Jlintto identify null-relatedbugsinthepro\u00adgrams. \nTable 2 shows the results. For each program, Table 2 lists the number of lines of C glue/library code \nand the number of lines of Java code. Next, it lists speci.cation\u00adextraction statistics, which include \ntime(averageof3runs) spentonextractingthe speci.cation,the numberof functions compiled vs. the number \nof total functions in the program, and the number of lines of code in the extended-JVML speci.cation. \nFinally, the table presents the number of error messages reported by Jlint, and also the number of false \npositives. Theexperiments were performed ona PentiumM processor (1.86 GHz) with 1GB of RAM. The modi.ed \nJlint does not report any null-related bug in the two programs that are extracted from Sun s JDK 1.5.0: \njava.lang.StrictMath and java.util.zip. This is per\u00adhaps because the code from JDK was developed and \nre\u00adviewed rigorously. The absence of null-related bugs in java.lang.StrictMath is hardly surprising. \nEvery nativemethod in the package accepts a double from the JVM, invokes the corresponding routine in \nthe fdlibm library, and returns the resultasa double; there areno object referencesinvolved.A typical \nspeci.cation, which is for the cosine function, is as follows: .method Java_StrictMath_cos(Ljava/lang/Class;D)D \nchoose double dreturn .end method Readers may wonder whether speci.cations like the above convey any \ninformation at all. They certainly do. For ex\u00adample, this speci.cation tells a Java optimizer that the \nJVM heap is not changed (or is immutable during the invocation of the native method); furthermore, noexceptions \nare raised. Manyoptimizations are enabled by just knowing these two facts. Pechtchanski and Sarkar [32] \nshow that simple im\u00admutability speci.cations result in measurable speedups (5% to 10%) in certain benchmark \nprograms. For the remaining two programs, libreadline-java-0.8.0 and posix 1.0, the modi.ed Jlint reports \na number of null\u00adrelated bugs. For posix 1.0, Jlint reports 15 bugs in total: 12bugs are due to not checking \nfor nullity of .eld IDs be\u00adfore using them; 3 bugs are due to not checking for nul\u00adlity of the result \nof the JNI API functions FindClass, Get-StringUTFChars, and AllocObject, respectively. Of the 15 bugs, \n13 are intra-procedural (which means a possibly null value is used in the same procedure as where it \nis produced); the othertwoare inter-procedural.For libreadline-java-0.8.0, Jlintreports10bugs:7bugsareduetonot \ncheckingfornul\u00adlityof the resultof the JNI API GetStringUTFChars;2bugs Program Glue/Library C LOC Java \nLOC Time Compiled/Total # of Functions JVML LOC Errors FP java.lang.StrictMath 153/8505 1128 0.69s 22/112 \n323 0 0 java.util.zip 262/8933 824 0.79s 19/109 1771 0 0 posix 1.0 1874/0 860 0.24s 33/33 1361 15 0 libreadline-java-0.8.0 \n659/1151 1196 0.13s 19/38 1130 10 1 Table 2. Preliminaryexperimental results for identifying null-relatedbugs \nthrough modi.ed Jlint are due to not checking for the nullity of the result of New-StringUTF. Of the9 \nrealbugs,8 are inter-procedural. One bugis betweenJava andC: theCcode callsaJava method witha possiblynull \nparameter,andtheJava methoddoesnot check for null before dereferencing the parameter. The one false positive \nis due to Jlint treating one control-.ow path as a possible one for null dereferences, even though the \ncontrol .ow along that path is impossible to happen. The preliminary experimental results show the utility \nof the speci.cations of native C code to existing Java-code analyzers: with small changes, Jlint can \n.nd null-related bugs in nativeCcode, and propagate information from the Ccode back into Java. 5. Relatedwork \nWork related to this paper can be divided into twocategories: (1) work related to alternative speci.cation \nlanguages and automatic speci.cation extraction; (2) work in the area of analyzing software applications \nwritten in multiple program\u00adming languages. In Section 1.1, we have already mentioned much re\u00adlated work \non alternative speci.cation languages. Compar\u00ading to them, our speci.cation language, in general, is \nex\u00adpressive, yet facilitates automatic extraction of speci.ca\u00adtions. The Hoare-logic style speci.cations \nused by Spec# and ESC/Java are also expressive, and ESC/Java has a sys\u00adtem called Houdini [10] that can \nautomatically adds speci\u00ad.cations to programs, similar to our speci.cation extractor. Compared to our \nspeci.cations, speci.cations in ESC/Java are more compact. On the other hand, to teach an exist\u00ading Java \nanalysis to accept and utilize logic-based speci.\u00adcations may be a nontrivial effort, while it is relatively \neasy to change it to accept our new instructions. Finally, it is worth remarking that the program logics \nused in ESC/Java and Spec# are not complete, as they are based on .rst-order predicate logic [4]. Our \nwork belongs to the general category of analyzing software systems written in multiple programing languages, \nor multilingual software. Representative work in this cate\u00adgory includes: tracking types of data passed \nfrom a strongly typed language to a weakly typed language to prevent the second language from misusing \nthe types [14, 15]; the inter\u00adoperation between twosafe languages when theyhavediffer\u00adent systems of \ncomputation effects such as exceptions [36]; ensuring safe interoperation between statically typed lan\u00adguages \nand dynamically typed languages [16, 25]; and in\u00adterfacing different languages with C code through Foreign \nFunction Interfaces (FFI) [2, 23, 8, 9]. One approach for re\u00adducing the number of programming errors \nin the JNI is to haveaframeworkthatallows programmerstodevelopmixed Java andCcodeina single language. \nSuch frameworks in\u00adclude Jeannie [18] and Janet [3]. Jeannie is particularly ex\u00adpressive in that it allows \narbitrary Java code to be embed\u00addedinCcode, and viceversa; Jeannie also performs many checks to detect \nprogramming errors such as type errors. Other analysis tools (and compilers) handle multilingual is\u00adsuesby \ncompiling toa common intermediate representation. Forexample, theFortify Source Code Analyzer [12] com\u00adpiles \nJava, C, and C++ to a common intermediate repre\u00adsentation. As another example, Microsoft compiles a vari\u00adety \nof languages to its MSIL intermediate representation [6]. Thesesystemshavethekeyadvantage thattheycan,in \nprin\u00adciple, perform extremely precise analyses across language boundaries.However,building sucha general \ninfrastructure is much more dif.cult than the approachwe propose as it re\u00adquires an analysis to work \nwith least common denominator representations and code. 6. Conclusion and future work In understanding \nmultilingual software applications, which speci.cation languageto useisworth discussion.We believe that \nthe speci.cation language we have proposed offers a good trade-offbetween completeness, easy migration \nof ex\u00adisting tools,andeasy constructionofa rangeof speci.cation extractors. We mention some possible \nfuture work. In our frame\u00adwork, the speci.cation extractor is part of the trusted com\u00adputing base (TCB). \nIf the generated speci.cations have mis\u00adtakes, an analysis based on them may get wrong results.We believe \nthat most of the speci.cation extractor can be re\u00admoved from the TCB using the PCC/TAL techniques [28, \n27]. Second, although our framework is based on the JVML, the techniques should be applicable to .NET \nCLR [6]. Fi\u00adnally, we plan to remove the assumption of single-threaded Ccodeintheextractor.We believethe \ngeneral methodology canbeextendedto specify multi-threadedCcodeintheex\u00adtended JVML. The extension will \nenable an analysis to .nd concurrency-relatedbugs such as deadlocks acrossJava and Ccode. Acknowledgments \nWe are grateful to Martin Hirzel and the anonymous review\u00aders for their constructive comments. References \n[1] M. Barnett, K. R. M. Leino, andW. Schulte. The Spec# programming system: An overview. In Post Proceedings \nof InternationalWorkshop on Construction and Analysis of Safe, Secure, and Interoperable Smart Devices, \npages 49 69, 2004. [2] M. Blume. No-longer-foreign:Teaching an ML compiler to speakC natively . Electronic \nNotes in Theoretical Computer Science, 59(1), 2001. [3] M. Bubak, D.Kurzyniec, andP. Luszczek. Creating \nJava to native code interfaces with Janet extension. In First Worldwide SGI Users Conference, pages 283 \n294, 2000. [4] E. Clarke. Completeness and incompleteness theorems for Hoare-like axiom systems. PhD \nthesis, Cornell University, 1976. [5] J. C. Corbett, M. B. Dwyer, J. Hatcliff, S. Laubach, C. S. Pasareanu, \nRobby, and H. Zheng. Bandera: extracting .nite-state models from Java source code. In International Conference \non Software engineering (ICSE), pages 439 448, 2000. [6] Ecma International. Common Language Infrastructure(CLI), \n4th edition, June 2006. Standard ECMA-335. [7] M.F\u00a8 ahndrich and K. R. M. Leino. Declaring and checking \nnon-null types in an object-oriented language. In ACM Conference on Object-Oriented Programming, Systems, \nLanguages, and Applications (OOPSLA), pages 302 312, 2003. [8] S. Finne, D. Leijen, E. Meijer, and S.P. \nJones. Calling hell from heaven and heaven from hell. In ACM International Conference on Functional programming \n(ICFP), pages 114 125, 1999. [9] K. Fisher, R. Pucella, and J. H. Reppy. A framework for interoperability. \nElectronic Notes in Theoretical Computer Science, 59(1), 2001. [10] C. Flanagan and K. R. M. Leino. Houdini, \nan annotation assistant for ESC/Java. In FME 2001:Formal Methods for Increasing Software Productivity, \npages 500 517, 2001. [11] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. \nStata. Extended static checking for Java. In ACM Conference on Programming Language Design and Implementation \n(PLDI), pages 234 245, 2002. [12] Fortify. http://www.fortifysoftware.com/. [13] S. N. Freund and J. \nC. Mitchell. A type system for the Java bytecode language and veri.er. Journal ofAutomated Reasoning, \n30(3-4):271 321, 2003. [14] M. Furr and J. S.Foster. Checking type safety of foreign function calls. \nIn ACM Conference on Programming Language Design and Implementation (PLDI), pages 62 72, 2005. [15] M. \nFurr andJ.S.Foster. Polymorphic type inference for the JNI. In 15th European Symposium on Programming \n(ESOP), pages 309 324, 2006. [16] K. E. Gray, R. B. Findler, and M. Flatt. Fine-grained interoperability \nthrough mirrors and contracts. In ACM Conference on Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA), pages 231 245, 2005. [17] S. Z. Guyer and C. Lin. An annotation language for \noptimizing software libraries. In Proceedings of the Second Conference on Domain-Speci.c Languages, pages \n39 52, 1999. [18] M. Hirzel and R. Grimm. Jeannie: Granting Java Native Interface developers their wishes. \nIn ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), 2007. \nTo appear. [19] D. Hovemeyer andW. Pugh. Findingbugs is easy. In the Companion to the 19thACM Conference \non Object-Oriented Programming, Systems, Languages, and Applications, pages 132 136, 2004. [20] S. Johnson. \nLint,aCprogram checker. Unix Documentation, 1977. [21] K. Knizhnik and C. Artho. Jlint manual, 2002. \nhttp: //artho.com/jlint/manual.html. [22] A. Le, O. Lhot\u00b4ak, and L. Hendren. Using inter-procedural side-effect \ninformation in JIT optimizations. In International Conference on Compiler Construction (CC), pages 287 \n304, April 2005. [23] X. Leroy. The Objective Caml system. http://caml. inria.fr/pub/docs/manual-ocaml/index.html. \n[24] S. Liang. Java Native Interface: Programmer s Guide and Reference. Addison-WesleyLongman Publishing \nCo., Inc., 1999. [25] J. Matthews and R. B. Findler. Operational semantics for multi-language programs. \nIn 34th ACM Symposium on Principles of Programming Languages (POPL), pages 3 10, 2007. [26] J. Meyer, \nD. Reynaud, and I. Kharon. Jasmin. http: //jasmin.sourceforge.net/, 2004. [27]G. Morrisett,D.Walker,K.Crary,andN.Glew.FromSystem \nFto typed assembly language. In25thACM Symposium on Principles of Programming Languages (POPL),pages \n85 97, 1998. [28] G. C. Necula. Proof-carrying code. In 24thACM Symposium on Principles of Programming \nLanguages (POPL), pages 106 119, 1997. [29] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. CIL: \nIntermediate language and tools for analysis and transformation ofCprograms. In International Conference \non Compiler Construction (CC), pages 213 228, 2002. [30] M. Norrish. FormalisingCin HOL. PhD thesis, \nUniversity of Cambridge, 1998. [31] I. Pechtchanski andV. Sarkar. Dynamic optimistic interpro\u00adcedural \nanalysis:Aframework and an application. In ACM Conference on Object-Oriented Programming, Systems, Lan\u00adguages, \nand Applications (OOPSLA), pages 195 210, 2001. [32] I. Pechtchanski and V. Sarkar. Immutability speci.cation \nand its applications. In Proceedings of the 2002 jointACM-ISCOPE conference onJavaGrande, pages 202 211, \n2002. [33] F. Qian and L. J. Hendren. Towards dynamic interprocedural analysis in JVMs. In Virtual Machine \nResearch and Technology Symposium, pages 139 150, 2004. [34] Splint. http://www.splint.org/. [35] G. \nTan, A. W. Appel, S. Chakradhar, A. Raghunathan, S. Ravi, and D. Wang. Safe Java Native Interface. In \nProceedings of IEEE International Symposium on Secure Software Engineering, pages 97 106, 2006. [36] \nV. Trifonov and Z. Shao. Safe and principled language interoperation. In 8th European Symposium on Programming \n(ESOP), pages 128 146, 1999. A. Typing rulesfor the extended-JVML instructions We use the following judgment \nin Freund and Mitchell [13] to specify the typing rules of our new JVML instructions: G, F, S, i f P \n: M The judgment means that instruction i of P is well-typed given G, F , S, and M. Each component in \nthe judgment is explained below: G:Aglobal environment; the representation ofa JVMLf program.  F :A \nmap from addresses to variable types, which map localvariablesto types such that Fi[d] is the type of \nlocal variable d at address i.  S:Amap from addresses to stack types.We useSi as the type of the operand \nstack at address i of the program.  P :AJVMLf method, where P [i] represents the JVMLf instruction at \nlocation i.  M: A method reference, which contains the method s argument types and return type, among \nother things.  With the judgment, the typing rules for our new JVML instructions are speci.ed below \n(in the style of Freund and Mitchell): G, F, S, i f P : M P [i] = choose t G f t \u00b7 Si <: Si+1 G f Fi \n<: Fi+1 i + 1 . dom(P ) G, F, S, i f P : M P [i] = mutate Si = t \u00b7 \u00df t . Simple-Ref . Array G f \u00df <: \nSi+1 G f Fi <: Fi+1 i + 1 . dom(P ) G, F, S, i f P : M P [i] = top G f Si <: Si+1 G f Fi <: Fi+1 i \n+ 1 . dom(P ) B. Properties of the speci.cation extractor   B.1 Compilation completeness THEOREM. \nFor anyCfunctionfn, there exists a sequence 1 1 I of extended-JVML instructions suchthat f fn I. The \nproof of the theorem is mainly based on the following lemma. LEMMA 3. For all s, F, and tret, there exists \nI1, such that F,tret f s I1. The proof is by induction over the syntax of s. It uses Lemma4below. LEMMA \n4. (a) compileOrChoose(F, d, t ) is a total function. (b) jvmE.ects(F,d) is a total function.   B.2 \nWell-typed compilation Tostateandprovethe well-typed compilation theorem,afew concepts are necessary. \nFirst, the JVML model in our paper uses abstract labels, while the model of Freund and Mitchell uses \nconcrete addresses and offsets.To bridge thegap, we introduce a judgment st f I1. P. The judgment assumes \na start address st, and converts I1to P , which is a function from concrete addresses to extended-JVML \ninstructions. The conversion can be speci.ed in two phases: the .rst phase collects the abstract labels \nde.ned in I1and calculates their concrete addresses; the second phase replaces the labels in the jump \ninstructions of I1with offsets, based on the information collected in the .rst phase. The formal speci.cation \nof the conversion is straightforward and we omit its detail. Next, to prove the well-typed compilation \ntheorem, we need to express the invariants associated with a sequence I1of instructions in judgments \nsuch as F f e I,t ). The (1 model by Freund and Mitchell provides rules for checking complete JVML methods. \nHowever, the sequence I1corre\u00adsponds to only a fragment of a JVML method. Therefore, we need a concept, \nwhich de.nes well-typed instruction se\u00adquences, without knowing the whole method (so called com\u00adpositional \nreasoning). DEFINITON 3. We write G, F, S, i ff P to mean that in\u00adstruction i of fragment P is well typed \nunder G, F and S. We put the letter f in the judgment to indicate that it checks a method fragment P \n, not a complete method. The rules for G, F, S, i ff P closely follow the corresponding rules for G, \nF, S, i f P : M, except that certain require\u00adments are removed.Forexample, the case for choose t is as \nfollows: G, F, S, i ff P P [i] = choose t G f t \u00b7 Si <: Si+1 G f Fi <: Fi+1 Comparing to the previous \nrule, the difference is that the requirement i +1 . dom(P ) is removed P is only a fragment of a JVML \nmethod, the next address, i +1, may not be in the domain of P . The requirement i +1 . dom(P ) in other \nrules is similarly dropped.11 DEFINITON 4. A method fragment P is well typed under environment G, type \ninformation F and S, written as G, F, S ff P, if G, F, S, i ff P , for all i . dom(P ). Before we state \nthe main theorem, we .rst introduce a few de.nitions. DEFINITON 5. Given a C function fn, we write F(fn) \nto denote the compilation environment constructed from the formal parameters and local variables of fn. \nIt is de.ned in the same way as how F is constructed in the rule for f fn I1inFigure 5. DEFINITON 6. \nGivena compilation environment F,we con\u00adstruct a type information F as follows: F (F)i[d]= t, if F(x)=(d, \nt) for some x DEFINITON 7. Let Gemp denote the empty global environ\u00adment. 11For the return instructions, \nwe also remove the requirement that the type of the return value has to match the return type declared; \nwe can prove this easily for our speci.cation extractor as a separate lemma. The JVML instructions generated \nby our speci.cation ex\u00adtractor do not use program-speci.c information. The empty environment is suf.cient \nto type check them. Now we are ready to state the main theorem: THEOREM. (Well-typed compilation) If \nf fn I1, and st f I1. P , then there exists a type information S, such that Gemp,F (F(fn)),S ff P. The \nproof of the theorem needs a few auxiliary lemmas for expressing the invariants of the instruction sequence \nI1producedbythe judgmentsinthe speci.cationextractor.For example, in F f e (1I is supposed I,t), the \nsequence 1to compute a value of type t and put it on the top of the stack. Furthermore, everything already \non the stack before the execution of I1are not touched by I1.We next state this lemma. DEFINITON 8. Weuse \nthe notation(So\u00df) to stand foratype information that adds the stack type \u00df to the end of every stacktype \nin S. It is de.ned as (S o \u00df)i = Si \u00df, where Si \u00df is the concatenation of Si and \u00df. LEMMA 5. If F f \ne I,t ) and st f 1 (1I . P , then there exists S suchthat a) Sst is the empty stacktype, b) Sst+|P | \n= t, where |P | denotes the size of P , c) for all stacktype \u00df, we have Gemp,F (F),S o \u00df ff P In words, \nthe lemma expresses that the P will eventually compute a value of type t at the top of the stack, and \nit will not change any value already on the stack before P .A similar lemma can be stated for F f japi \n(1 I,t). LEMMA 6. If F,tret f s I1, and st f I1. P , then there exists S suchthat a) Sst is the empty \nstacktype, b) Sst+|P | is the empty stacktype, c) for all stacktype \u00df, we have Gemp,F (F),S o \u00df ff P \n Asimilar lemma can be stated forF f japi (1 I, ?). C. Compilation examples (a) AN EXAMPLE CFUNCTION. \nint main() { int i,sum=0; int *p=&#38;i; for (i=0; i<10;i++)sum=sum+*p; return sum; } (b) EXTENDED-JVML \nSPECIFICATION, IN JASMIN SYNTAX. .method main()I .limit locals 3 .limit stack 999 ; Jasmin uses ; to \nstart comments ; Phi = {i : (1, int), sum : (2, int)} ; for sum = 0 iconst_0 istore_2 ; for i = 0 iconst_0 \nistore_1 loopbegin-0: ; for if (i < 10) ... iload_1 ldc 10 if_icmpge iffalse-4 iconst_1 goto endif-5 \n iffalse-4: iconst_0 endif-5: ifeq iffalse-2 goto endif-3 iffalse-2: goto loopend-1 endif-3: ; for \nsum = sum + (*p) choose int istore_2 ; for i = i + 1 iload_1 iconst_1 iadd istore_1 goto loopbegin-0 \n loopend-1: ; for return sum iload_2 ireturn .end method Figure 12. Acompilation example. class IntArray \n{ /* declare a native method */ private native int sumArray(int arr[]); public static void main(String \nargs[]) { IntArray p = new IntArray(); int arr[] = new int [10]; for(inti =0; i< 10;i++) arr[i]= i; /* \ncall the native method */ int sum = p.sumArray(arr); System.out.println(\"sum = \" + sum); } static { \n/* load the DLL library that implements the native method */ System.loadLibrary(\"IntArray\"); } } #include \n<jni.h> #include \"IntArray.h\" JNIEXPORT jint JNICALL Java_IntArray_sumArray (JNIEnv *env, jobject self, \njintArray arr) /* env is an interface pointer through whicha JNI API function can be called; self is \nthe reference to the object on whichthe method is invoked; arr is the reference to the array. */ { int \nlen = (*env)->GetArrayLength(env, arr); inti,sum= 0; jint *body = (*env)->GetIntArrayElements(env, arr, \n0); test if body is null for (i=0; i<len; i++) { sum += body[i]; } (*env)->ReleaseIntArrayElements(env,arr,body,0); \nreturn sum; } Figure13. AJNIexample.Javacode passesCcodeanarray of integers andCcode returns the sum \nof the array. On the topis theJava code; on the bottomis theCcode. .method Java_IntArray_sumArray(LIntArray;[I)I \n.limit locals 9 .limit stack 999 ; Phi = {obj : (1, IntArray), arr : (2, int []), ; len : (3, int), tmp \n: (4, int), ; i : (5, int), sum: (6, int), ; body: (7, int []), tmp___0 : (8, int [])} ; for tmp = ; \n(*(((*env))->GetArrayLength))(...); aload_2 arraylength istore 4 ; for len = tmp; loopbegin-4: iload \n4 ; for if (i < len) ... istore_3 iload 5 ; for sum = 0; iload_3 iconst_0 if_icmpge iffalse-8 istore \n6 iconst_1 ; for tmp___0 = goto endif-9 ; (*(((*env))->GetIntArrayElements))(...); iffalse-8: choose \nint iconst_0 ifeq iffalse-0 endif-9: aload_2 ifeq iffalse-6 goto endif-1 goto endif-7 iffalse-0: iffalse-6: \naconst_null goto loopend-5 endif-1: endif-7: astore 8 ; for sum = sum + (*(body + i)); ; for body = tmp___0; \nchoose int aload 8 istore 6 astore 7 ; for i = i + 1; iload 5 ; for if (body == 0) ... iconst_1 aload \n7 iadd ifnonnull iffalse-2 istore 5 iconst_0 goto loopbegin-4 ireturn loopend-5: goto endif-3 ; for return \nsum iffalse-2: iload 6 endif-3: ireturn ; for i = 0; iconst_0 nop istore 5 .end method Figure 14. Theextended-JVML \nspeci.cation for theCfunctionin Figure13 \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Java bug finders perform static analysis to find implementation mistakes that can lead to exploits and failures; Java compilers perform static analysis for optimization.allIf Java programs contain foreign function calls to C libraries, however, static analysis is forced to make either optimistic or pessimistic assumptions about the foreign function calls, since models of the C libraries are typically not available.</p> <p>We propose ILEA (stands for Inter-LanguagE Analysis), which is a framework that enables existing Java analyses to understand the behavior of C code. Our framework includes: (1) a novel specification language, which extends the Java Virtual Machine Language (JVML) with a few primitives that approximate the effects that the C code might have; (2) an automatic specification extractor, which builds models of the C code. Comparing to other possible specification languages, our language is expressive, yet facilitates construction of automatic specification extractors. Furthermore, because the specification language is based on the JVML, existing Java analyses can be easily migrated to utilize specifications in the language. We also demonstrate the utility of the specifications generated, by modifying an existing non-null analysis to identify null-related bugs in Java applications that contain C libraries. Our preliminary experiments identified dozens of null-related bugs.</p>", "authors": [{"name": "Gang Tan", "author_profile_id": "81309504867", "affiliation": "Boston College, Chestnut Hill, MA", "person_id": "PP39113320", "email_address": "", "orcid_id": ""}, {"name": "Greg Morrisett", "author_profile_id": "81339518683", "affiliation": "Harvard University, Cambridge, MA", "person_id": "PP39103268", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297031", "year": "2007", "article_id": "1297031", "conference": "OOPSLA", "title": "Ilea: inter-language analysis across java and c", "url": "http://dl.acm.org/citation.cfm?id=1297031"}