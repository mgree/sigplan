{"article_publication_date": "10-21-2007", "fulltext": "\n Can Programming be Liberated from the Two-Level Style? Multi-Level Programming with DeepJava Thomas \nK\u00fchne Darmstadt University of Technology kuehne informatik.tu-darmstadt.de Abstract Since the introduction \nof object-oriented programming few programming languages have attempted to provide program\u00admers with \nmore than objects and classes, i.e., more than two levels. Those that did, almost exclusively aimed at \nde\u00adscribing language properties i.e., their metaclasses exert linguistic control on language concepts \nand mechanisms often in order to make the language extensible. In terms of supporting logical domain \nclassi.cation levels, however, they are still limited to two levels. In this paper we conservatively \nextend the object-oriented programming paradigm to feature an unbounded number of domain classi.cation \nlevels. We can therefore avoid the introduction of accidental complexity into programs caused by accommodating \nmultiple domain levels within only two programming levels. We present a corresponding language design \nfeaturing deep instantiation and demonstrate its features with a running example. Finally, we outline \nthe implementation of our compiler prototype and discuss the potentials of further developing our language \ndesign. Categories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features; \nD.3.2 [Programming Languages]: Language Classi.cations Ex\u00adtensible languages General Terms Languages, \nDesign Keywords domain metatypes, ontological metamodeling, deep characterization 1. Introduction Among \nthe factors responsible for the success of object\u00adoriented programming languages is certainly their ability \nto extend the number of types available to programmers. In Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00e9al, Qu\u00e9bec, \nCanada. Copyright c &#38;#169; 2007 ACM 978-1-59593-786-5/07/0010. . . $5.00 Daniel Schreiber Darmstadt \nUniversity of Technology shreiber tk.informatik.tu-darmstadt.de the days of FORTRAN, types such as 'ComplexNumber,' \n'Fration'or 'Book'were either directly supported or had to be emulated with the help of supported types. \nThere was no direct support for handling the creation and management of multiple instances of a type \nand in combination with the lacking support for data abstraction this caused program structures that \nhardly re.ected the corresponding domain types. In contrast, object-oriented languages allow the use \nof such types, as if they had been built-in into the language. One way to analyze the reason for this \nadvantage of object-oriented languages is to interpret user de.nable types as a feature of an extensible \nlanguage. The natural conse\u00adquence then is to look into other ways of making a language extensible. However, \neven though many attempts have been made to create languages and systems with programmer con\u00adtrol over \ntheir concepts and semantics [29], none of them managed to attract the majority of programmers. We argue \nthat object-oriented languages are not success\u00adful because they feature a form of extensibility, but \nbecause they provide means for accurately re.ecting the problem do\u00admain. They can thus be understood \nas allowing programmers to achieve a direct mapping [30] from problem domain to program structure. However, \ngiven that object-oriented pro\u00adgramming languages support only two levels (classes and objects) for re.ecting \nthe logical domain classi.cation lev\u00adels, obviously the direct mapping quality cannot be main\u00adtained \nif the problem domain involves more than two classi\u00ad.cation levels. In this paper, we use a running example \nthat features three domain classi.cation levels in order to demonstrate how workaround techniques that \naccommodate multiple domain levels within two programming levels introduce accidental complexity into \nprograms (section 2). After rec\u00adognizing the need for deep characterization and explaining our corresponding \ndeep instantiation mechanism (section 3), we then show how multi-level support and deep instantia\u00adtion \ncan be integrated into a programming language and ap\u00adply its features to our example (section 4). Subsequently, \nwe brie.y describe our prototype compiler (section 5)and con\u00adclude with a discussion of related work \n(section 6)and the potentials of further developing our language design (sec\u00adtion 7). 2. Multi-Level \nProgramming In this section we introduce the concept of domain classi.\u00adcation levels and demonstrate \nthe accidental complexity in\u00adtroduced by mapping multiple domain levels into two pro\u00adgramming levels. \n2.1 Ontological Metamodeling In order to understand the difference between ontological linguistic classifier \nclassifier metaclasses as used DVD Object in re.ective languages (targeting .exibility and \u00abinstanceOf\u00bb \n\u00abinstanceOf\u00bb extensibility [13]) and metaclasses used for represents mirroring a multi-level 2001 domain \nmodel in a pro\u00adgram structure, it is Figure 1. Ontological vs Lin\u00adimportant to make an guistic Classi.cation \nexplicit distinction be\u00adtween linguistic classi.cation versus ontological classi.ca\u00adtion [23]. Fig. 1 \nuses the UML [34] notation for objects and classes to show the relationships between a real product (the \nDVD 2001: A Space Odyssey ), the object representing it (object '2001') and their respective classi.ers. \nLooking at '2001' from a language perspective results in its classi.cation as an 'Objet',since '2001'constitutes \nthe usage of the UML concept 'Objet'1. If one wants to under\u00adstand what the type of domain ProductType \nmetatypes '2001'is in terms of the do\u00ad taxRate : Integer main where it occurs, one needs to examine the \ndo\u00ad \u00abinstanceOf\u00bb main element it represents domain (here the DVD 2001: A types Space Odyssey ) and then \nDVD determine the latter s do-taxRate = 19 price : Float main type. In our example, the domain type turns \nout \u00abinstanceOf\u00bb to be 'DVD'. The fact that domain in an object-oriented pro\u00ad instances gram object '2001'would \n2001 have class 'DVD're.ects price = 19.95 that the instance of re\u00adlationship between objects Figure \n2. Three Domain and their classes is of on-Classi.cation Levels tological nature. In other words, the \nprogramming levels mirror the domain classi.\u00adcation levels. In a re.ective language, 'DVD'would be further \nclas\u00adsi.ed as 'Class', i.e., the classi.cation would change from ontological (between objects and classes) \nto linguistic (be\u00ad 1 In recent versions Object has been replaced by Instance Speci.cation . Here, we \nare sticking to Object for brevity and clarity. tween classes and metaclasses) (see also section 6). \nIn our approach, we continue to use ontological classi.cation. Fig. 2 shows 'Produt- Typ e ' as the domain \ntype of 2001 'DVD ' assuming that an on\u00ad line store offers products of various types, such as 'Book', \n'CD', 'DVD',etc.Note that 'ProdutType'is not a gen\u00ad (a) Generalization eralization of 'DVD ',i.e., not \n2001 the latter s supertype, but its type. Fig. 3 illustrates the difference between a super\u00ad type (here \n'Produt')and a type (here 'ProdutType') of 'DVD ' using a 3D Venn (b) Classification diagram notation \nin which the third dimension is used Figure 3. Super vs to denote instantiation. Fig- Meta ures 3(a) \n&#38; 3(b) graphically depict that the set theoretic interpretations of instantiation and specialization \nare the elementhood (.) and the subset (.) relations respectively, showing types and their subtypes as \nsets and their subsets. It is easy to distinguish between the two cases, where a concept X is either \nthe type or supertype of a given concept T , by using the following litmus test: Take an instance I (here \n'2001')of T (here 'DVD') and check whether it can be regarded as an (indirect) instance of X. If yes \n(as is the case with 'Produt'), then X is T s supertype. If not (as is the case with 'ProdutType'), then \nX is T s type. In this case, using absolute terminology, X maythenberegardedas a metatype (relative to \nI). While one can easily come up with examples involving further levels2 giving rise to meta-metatypes \nand so forth, three levels are already suf.cient to demonstrate the dif.\u00adculties entailed by the necessity \nto accommodate multiple domain levels within only two programming levels. 2.2 Workarounds A number of \ndesign patterns such as the Item Description pattern [12] or the Type Object pattern [20] testifytothe \nrecurring need for representing structures like that of Fig. 2, involving multiple domain levels, with \nonly two program\u00adming levels. As in our online store example, there is often the need to have a dynamic \ntype level, i.e., be able to introduce new types such as 'HDDVD', 'Blu-ray', etc. at runtime. As a consequence, \nthese types cannot be mapped to classes, but need to be represented at the object level. Fig. 4 shows \nthe generic structure of the Item Description pattern in which 'adesription'plays the role of a type \nfor 'anitem'at run\u00adtime. 2 For instance, element '2001'could be regarded as the type for all copies of \nthis movie that may differ in packaging, condition when sold used, etc. Description .described by * Item \n type attributes instance attributes  \u00abinstanceOf\u00bb \u00abinstanceOf\u00bb Figure 4. Item Description Pattern \nNote that the 'typevalues'in Fig. 4 can be thought of as being shared by all item instances, thus avoiding \ntheir repli\u00adcation (see Fig. 5 for an example). Even if replication would be tolerable in terms of memory \nef.ciency, the information kept in 'typevalues'(e.g., on .ight routes) should be avail\u00adable even if no \ninstances (e.g., actual .ights) exist at a par\u00adticular point in time [24]. Since many object-oriented \nlanguages feature class at\u00adtributes (e.g., so-called static variables (sic) in JAVA), one may adequately \nrepresent the structure of Fig. 2 without re\u00adsorting to the Item Description pattern, provided that there \nis no requirement to introduce new types at runtime. How\u00adever, if the number of domain classi.cation \nlevels exceeds three, one has to use the Item Description pattern a num\u00adberoftimes [20] to obtain the \nrequired classi.cation depth, even if all type structures are completely static. Together with the Property \nPattern the Type Object Pattern [20] supports the creation of Adaptive Object-Model / User De.ned Product \nframeworks , i.e., the run\u00adtime creation of types with a dynamic speci.cation of their attributes. In \nsuch scenarios, the Type Object pattern is ap\u00adplied twice in a type square [37]. The Dynamic Template \nPattern [27] addresses the potential need for inheritance be\u00adtween represented types. 2.3 Accidental \nComplexity Given a two-level limitation, the above described design pat\u00adterns provide welcome guidance \nas to how one may work around the limitation. However, ideally one should not be forced to know the patterns \nand live with their implemen\u00adtation overheads. Fig. 5 depicts the application of the Item Description \npattern to our example3. More explicitly than Fig. 4, it shows that two domain levels are squeezed into \none programming level, causing considerably overhead: the programmer has to deal with two forms of instantia\u00adtion, \ni.e., the built-in language instantiation and the in\u00adstance of 'isOfType'/'isOfType'relationships between \nlanguage types and language instances respectively.  the 'isOfType'between domain instances and domain \ntypes must be emulated by the programmer. There is no  3 German taxation features two tax rates, depending \non the product type. Figure 5. Squeezing Three Levels into Two language support for making sure that \ndomain instances typecheck against their domain types. inheritance between types has to be emulated. \n late binding of methods calls has to be emulated.  the programmer has to deal with pattern artifacts \nwhich do not represent any element in the domain. While 'Prod\u00adut', in principle, could be a useful generalization \nin the domain, it may not be required at all. In Fig. 5,it is mandatory and its primary purpose is to \nbe a class for objects that represent domain instances, since the latter s domain types are just objects \nthemselves which cannot instantiate or control other objects.  The above list clearly enumerates what \nhas been coined acci\u00addental complexity by Brooks [8]. It is complexity that is not induced by the complexity \nof the problem domain, but arti\u00ad.cially introduced by limitations of the solution paradigm. The solution \nshown in Fig. 5 is a good example for a de\u00adsign that does not maintain a direct mapping (one of Meyer \ns modularity criteria [30]) to the problem domain that induced it (see Fig. 2). Many of the built-in \nconcepts of object\u00adoriented programming languages have to be emulated to cre\u00adate a solution that is less \nef.cient, more error-prone, and most importantly, less easy to understand and maintain [4]. The preceding \ndiscussion should have made it clear that language support for an unbounded number of programming levels \nin order to be able to mirror any number of domain classi.cation levels would be very desirable. Fortunately, \none can expect programmers with pro.ciency in the use of the object-oriented paradigm to easily adapt \nto a correspond\u00ading language. After all, one can always look at an n-level classi.cation hierarchy with \na (sliding) two-level window, treating the upper level as classes and the lower level as ob\u00adjects. With \nsuch a relative perspective, the middle level of Fig. 2 contains objects, created and controlled by the \nclasses above it. The fact that said elements are classes and meta\u00adclasses respectively in an absolute \nsense, can be safely ig\u00adnored in understanding their relative relationships. However, there is one issue \nthat distinguishes an n-level classi.cation hierarchy from a simple stacking of two-level building blocks, \nwhich concerns the notion of instantiation.  3. Deep Instantiation In a two-level classi.cation hierarchy \nthe type level only describes the instance level directly below it. As soon as a third level is added, \nthe question arises whether elements in the top level may in.uence elements in the bottom level, requiring \ncontrol extending over two level boundaries, as opposed to just one. Indeed, our online store example \nalready motivates the desire of being able to control elements across more than one level boundary. Consider \nFig. 2 and imagine the introduction of a new type, such as 'Book'. The new type is guaranteed to have \na 'taxRate'property but whether or not it declares a 'prie'attribute is left to the discretion of the \nprogrammer or code introducing the type. Yet, online store code dealing with objects that represent products \nin a generic manner should be guaranteed to always .nd a 'prie'property. We refer to any mechanism allowing \nthe presence of the 'prie'property to be speci.ed from two (or more) lev\u00adels above as achieving deep \ncharacterization. In contrast, traditional object-oriented classi.cation/instantation seman\u00adtics only \nachieves shallow characterization. Deep charac\u00adterization is required whenever one level should not only \ngovern the well-formedness (i.e., allowed relationships be\u00adtween and required presence of properties \nwithin elements) of the immediate level below, but also make sure that the latter prescribes some well-formedness \nrules for the level below it (and possibly further on) as well. One well-known application for deep characterization \nare so-called process metamodels, used in the de.nition of software develop\u00adment methodologies [10]. \nThe designer of a process meta\u00admodel (at level 2) wishes to constrain the creation of process models \n(level 1), but in addition also needs to make sure that process enactments (level 0) obey certain rules. \nFor in\u00adstance, the process metamodel may want to enforce that task enactments are guaranteed to have \na 'duration'property. Gonzalez-Perez and Henderson-Sellers achieve deep char\u00adacterization by employing \npowertypes [10]. In this section, we are discussing an alternative mechanism, called deep in\u00adstantiation4, \nwhich was originally developed for addressing issues in the UML infrastructure [3]. 4 We compare deep \ninstantiation to powertypes in section 6. 3.1 Clabjects Understanding how, using deep instantiation, \none may in.u\u00adence elements beyond one level boundary is easiest if one .rst introduces the notion of \na clabject, an element that is both class and object at the same time [2]. Consider the ele\u00adments in \nthe middle level of Figures 2 &#38; 6. They are objects (with corresponding 'taxRate'properties) with \nrespect to the level above them and classes (with corresponding 'prie'at\u00adtributes) with respect to the \nlevel below them. In fact, ev\u00adery element in a classi.cation hierarchy has both an instance facet (w.r.t. \nits object role) and a type facet (w.r.t. its class role), with the exception of the elements at the \nbottommost and topmost levels. Hence, it makes sense to abandon the distinction between objects, classes, \nmetaclasses, etc. and simply regard them as clabjects which only differ in the level they occupy. The \nsame uni.cation can be applied to (object) properties and (class) attributes to yield the notion of a \n.eld. In the following we will continue to use terms like type , class , subclassing , attribute , etc., \nbut note that in a multi-level environment populated with clabjects the above terms refer to roles and \nrelationships that may occur at any level. The term class , for instance, thus should be read as the \ntype facet of a clabject without any determination of the absolute level it may reside on. 3.2 Potency \nWhether a .eld corresponds to a traditional property or at\u00adtribute is governed by its associated potency \nvalue. A .eld with a potency value of 0 indicates an object property which has no in.uence on potential \ninstances of its owning clabject (see the 'taxRate'property of the L1 elements in Fig. 6). A .eld with \na potency value of 1 indicates an attribute, which speci.es the presence of a corresponding object property \nfor all instances of its owning clabject (see the 'taxRate'at\u00adtribute of 'ProdutType'in Fig. 6). L2 \n L1 L0 Figure 6. Deep Instantiation Deep instantiation conservatively extends traditional shal\u00adlow instantiation \nby letting potency values range over inte\u00adger values {0,...,n} where ncorresponds to the maximum characterization \ndepth required. Fig. 6 shows the same sce\u00adnario as Fig. 5, however, this time making use of three pro\u00adgramming \nlevels and a potency value of 2 for .eld 'prie'at L2, in order to guarantee the presence of a 'prie'property \nfor objects representing products at L0. Note that not only .elds have potency values but clabjects as \nwell. As a result, a programmer can control the instan\u00adtiation depth for a given clabject and, for instance, \nchoose apotency valueof 0 in order to specify an abstract class (i.e., a clabject at L1), whose.elds \nmay havepotency val\u00adues > 0. At what level a clabject resides can be speci.ed explicitly but this is \noptional since we are assuming a dis\u00adcipline according to which only instance of relationships can cross \nlevel boundaries and must not cross more than one level boundary. With this assumption, classi.cation \nis a level-respecting relationship which implies that no ambigu\u00adity w.r.t. level membership may arise \n[23]. 3.3 Instantiation Semantics Given the two uni.ed concepts clabject and .eld it becomes very easy \nto informally de.ne the semantics of instantiation which intuitively simply amounts to creating a copy \nof the element (that is required to have level and potency values > 0), considering only .elds with potency \nvalues > 0,and decreasing all level and potency values by one. We do not present a formal semantics here \nsince its verbosity does not match the simple intuition behind deep instantiation.  4. Programming \nLanguage Integration In this section we show how an unbounded number of pro\u00adgramming levels and deep \ninstantiation can be supported by extending JAVA to DEEPJAVA.DEEPJAVA is a conservative superset of JAVA, \ni.e., every correct JAVA program is also a correct DEEPJAVA program. 4.1 Clabjects and Potency Since \nDEEPJAVA naturally supports class properties by de.ning them through metaclass attributes, there is no \nneed for a special concept like static variables (JAVA) or class variables (SMALLTALK (see also section \n6)). Listing 1 shows how metaclass 'ProdutType'from Fig. 6 is speci.ed in DEEPJAVA.Notethatweuse pretty \nprinting for potency values. Using a standard text editor, po\u00adtency values are entered and appear as \nin ProdutType-2 . Compared to Fig. 6, we have slightly changed metaclass 'ProdutType'to use a 'netPrie'and \nlet a 'prie'method compute the retail price by referring to the corresponding tax rate for a particular \nproduct. Method 'prie2'hence demon\u00adstrates how product instances may access the tax rate of their types. \nWhen reading the code for method 'prie2'one must realize that its potency value is 2, i.e., it becomes \nan ordinary public class ProductType2 extends ProductCategory2 { public ProductType( String categoryName, \nint categoryCount, int taxRate) { super(categoryName, categoryCount); taxRate(taxRate ); } int taxRate \n; public void taxRate( int t) { taxRate = t ; } public int taxRate () { return taxRate ; } private .oat \nnetPrice 2 ; public void price ( .oat p)2 {netPrice = p; } public .oat price () 2 { return netPrice \n* (1 + type . taxRate / 100f ); } } Listing 1. Metaclass De.nition method in instances of 'ProdutType',suchas \n'DVD'5.One must therefore understand its execution from the perspective of products, e.g., instances \nof 'DVD'. It is then obvious that, in the body of 'prie2',weneedto navigateto the 'type'of a product \nin order to obtain its 'taxRate'. Note that in our code example 'ProdutType'has a super clabject 'ProdutCategory', \nwhich we are going to use in the following (see Fig. 8 for a complete overview over all static and some \ndynamic online store elements).  4.2 Dynamic Class Creation Our online store distinguishes between various \nproduct cate\u00adgories, one of them being software items. Listing 2 shows in line 1 how to create the new \nclass 'Softtareltem'with initial values for its category name and the number of sold items. The same \n'ProdutCategory'constructor was already used in line 7 of listing 1. DEEPJAVA class properties, such \nas 'taxRate',corre\u00adspond to SMALLTALK class instance variables [17], i.e., each instance of a class has \nits own set of class properties. In the context of our online store example a useful application for \nthem is to store the number of sold items in product types (such as 'DVD', 'Book', etc.) respectively \nand aggregate these individual subcategory counts in respective supertypes (e.g., 'Softtareltem'), and \nso forth. Listing 3 shows how method 'soldOne'(from 'ProdutType') not only updates the count for subcategories \n(product types, such as 'DVD') but also for categories (such as 'Softtareltem'). 5 Guaranteeing that \n'DVD'instances understand the message 'prie'. 1 ProductCategory{\"Software Items\" , 333} SoftwareItem \nextends Product0 ; // create SoftwareItem 2 3 DigitalMedium{DVD_Player, \"DVDs\",222,19} DVD extends SoftwareItem \n{ // create DVD 4 \"public String toString () {return name() + \\\" (\\\" + type.categoryName() + \\\")\\\" + \n5 (promoProduct() == null ? \\\"\\\" : \\\" -> \\\"+promoProduct());}\" 6 }; Listing 2. Dynamic Type Creation \npublic void soldOne() { categorySoldCount++; superType (). categorySoldCount++; } Listing 3. Making Use \nof Unshared Class Properties Note that attribute 'ategorySoldCount'is de.ned in 'ProdutCategory'so that \nall categories (such as 'Softtare\u00adltem') have a counter of items sold. However, only product types (such \nas 'DVD') have instances that can be sold, hence, method 'soldOne'is de.ned in 'ProdutType'. By using \nthe option to specify a superclass for the new class by stating extends Product0 , in line 1 of listing \n2,we make the freshly created class a subclass of the preexisting class 'Produt'. The latter simply de.nes \na name attribute and corresponding access methods. Intriguingly, one can already tell by Product0 in \nline 1 that 'Produt'is abstract (has potency value 0), since DEEPJAVA optionally allows the declaration \nof potency values in use positions (as opposed to de.ning positions) of clabject identifers. Instead \nof using 'Produt'as a superclass, we could have also de.ned 'name'with potency value 2 at 'Pro\u00addutCategory' \nachieving the same effect for 'Softtare\u00adltem'instances but we speci.cally introduced 'Produt'to demonstrate \nDEEPJAVA s ability to combine dynamic clab\u00adjects with statically existing superclabjects. If in a type \ncreation (such as the one in line 1) the inter\u00adsection between the superclabject features and the features \nde.ned through the clabject type by virtue of deep instan\u00adtiation is not empty, the superclass de.nitions \ntake prece\u00addence, thus allowing programmers to override generic fea\u00adture de.nitions for speci.c cases. \nIn analogy to subclassing, it is left to the discretion of the programmer to provide only compatible \nin the sense of subtyping [26] rede.nitions. Lines 3 6 of listing 2 create a new class 'DVD'as a subclass \nof 'Softtareltem'and Listing 4 shows how this new class can be used to create 'DVD'instances. 7 DVD \naso = new DVD(); 8 aso.price(19.95f / (1 + aso.type().taxRate() / 100f)); 9 aso.name(\"2001: A Space Odyssey\"); \n 10 aso.promoProduct(haChi_779); Listing 4. Using a Dynamic Type  4.3 Dynamic Feature Creation Lines \n4 5 of listing 2 demonstrate DEEPJAVA s ability to equip dynamically created types with any number of \nnew attributes or methods de.ned in strings (which need not be based on string constants). This language \nfeature al\u00adlows the dynamic introduction of new clabjects with fea\u00adtures that were not anticipated at \nthe time their types and supertypes were de.ned. Obviously, this level of .exibility does not come with \ntypesafety. In our DEEPJAVA imple\u00admentation (see section 5) we check the validity (syntax and well-formed \naccess to features) at runtime and this may re\u00adsult in an exception (e.g., 'NoSuhMethodExeption')being \nthrown. Furthermore, if the new features do not override ex\u00adisting features then access to them cannot \nbe typesafe, since there is no static de.nition that may guarantee their pres\u00adence. The 'DVD'example \nof listing 2 rede.nes a statically known method which can be used in a typesafe manner, but assuming \nwe had additionally provided features regarding the director of DVD movies in lines 4 5 of listing 2 \nthen listing 5 illustrates how one can make use of one of them. Note the use of a '#'instead of a dot \nbefore the method name (supplied as a string value) in order to allow access to a statically unknown \nfeature and to signal the potential failure of such an attempt. 11 try { 12 System.out.println(\"Director \nof \" +aso.name() + 13 \"is \" +aso#(\"director\")()); 14 } catch (Exception e) { e.printStackTrace(); } \nListing 5. Invocation of a Statically Unknown Method  4.4 Typeparameters In line 3 of listing 2 we use \nthe type 'DigitalMedium'(see listing 6) which subclasses 'Medium', which in turn sub\u00adclasses 'ProdutType'(see \nFig. 8). Note that the constructor for digital media features an additional argument compared to that \nof product types/categories. By passing the clabject 'DVD Player'as a parameter to the constructor that \ncreates 'DVD'in line 3,we demonstrate DEEPJAVA s ability to not only use types as values but also use \nthese values in type positions. In listing 6 we can see that said .rst parameter of 'Dig\u00aditalMedium' \ns constructor has type 'HartdtareType'(an\u00adother subclass of 'ProdutType'). Theideais to beable public \nclass DigitalMedium2 extends Medium0 { public DigitalMedium(HardwareType HT, String categoryName, int \ncategoryCount, int taxRate) { super(categoryName, categoryCount, taxRate ); CrossPromoType = HT; } .nal \nHardwareType CrossPromoType; CrossPromoType recProd2; public void promoProduct(CrossPromoType rp)2 { \nrecProd = rp ; } public CrossPromoType promoProduct()2 { return recProd; } } Listing 6. Genericity through \nTypeparameters to link digital media types (such as 'DVD') to hardware item types (such as 'DVD Player') \nfor cross promotion pur\u00adposes. This is why 'DVD Player'is passed to the construc\u00adtor that creates 'DVD'. \nThe type 'CD'wouldlinktotype 'CD Player', etc. Note, however, that the ultimate motiva\u00adtion of the online \nstore for doing this is to link up digital media instances to hardware instances. In line 10 of list\u00ading \n4 the 'DVD'instance '2001'is linked to a correspond\u00ading 'DVD Player'instance (referenced by 'haChi 779'). \nThis call to 'promoProdut'only accepts arguments of type 'DVD Player'since the argument type 'CrossPromoType' \nhas been instantiated to 'DVDPlayer'when class 'DVD' was created. This is the reason for declaring 'CrossPromo\u00adType'to \nbe .nal in listing 6, i.e., make it immutable after it has received its initial value by the constructor. \nOtherwise, instances of 'DigitalMedium'(such as 'DVD') would have volatile type facets, in other words, \nclients could not assume stable feature types. In essence, the parameterization of 'DVD'to only accept \ncross promotion items of type 'Hardtareltem'corresponds to supplying a type argument to a generic class. \nIn other words, DEEPJAVA s ability to use types as values and use these values in type positions, creates \nan alternativ approach to genericity. With types (at all levels and all potencies) as .rst-class entities \nin place, there is no need to add another genericity concept to JAVA. In fact, the approach followed \nby DEEPJAVA leads to more powerful ways of using type parameterization than afforded by JAVA-genericity \nincluding wildcards.  4.5 Static Typing A comprehensive discussion of the type system required for the \nopportunities opened up by DEEPJAVA is out of scope for this paper. However, Sections 6 &#38; 7 elaborate \non the nature of the required type system to some extent. Our compiler prototype (see section 5) currently \nimplements a pragmatic mixture between rejecting a large class of type incorrect programs and admitting \nsome which may or may not produce runtime errors. Any type-related runtime error is dealt with by throwing \na corresponding exception, though. As a result, the currently supported version of DEEPJAVA is not unsafe \nin the sense that a type-related error may go unnoticed or corrupt program execution. We also chose to \nallow some features (such as the ability to call statically unknown methods) in order to provide the \nassociated .exibility in favor of an approach that attempts to discover all type-related errors at compile \ntime. Note that JAVA itself follows a similar philosophy, e.g., by allowing downcasts which may fail. \nIn spite of all the dynamics introduced to types by DEEP-JAVA, thanks to deep instantiation and the possibility \nfor dy\u00adnamic types to refer to statically known superclasses, it is possibly to statically typecheck \ncode as generic and .exible as the one in listing 7. The following sections explain list\u00ading 7 and discuss \na compatibility issue arising in the pres\u00adence of multi-level class hierarchies. 4.5.1 Abstract Type \nDeclarations The heading of this section is to be read as abstract type\u00addeclarations , since we are introducing \na way to declare a variable type in DEEPJAVA that enables very generic code. Line 15 of listing 7 declares \nan array whose element s types are only known to be an instance of 'ProdutType'.Line 21 of listing 7 \nuses the same declaration in which is to be read as value of for a single variable. These declara\u00adtions \nare abstract in the sense that the concrete type of the referenced elements need not be known. A similar \nargument could be made for using a supertype (such as 'Produt') of all the types one wishes to capture. \nHowever, note that instances of 'ProdutType'may be part of a number of unrelated inheritance hierarchies. \nIn contrast to the supertype declaration using 'Produt', the abstract type declarations in listing 7 \ndo not require these inheritance hierarchies to have a common root. An abstract DEEPJAVA type declaration \nis hence more generic, i.e., admits more types, than traditional declarations using supertypes. Listing \n7 iterates6 through a number of product type in\u00adstances and prints them (implicitly using their 'toString' \nmethod) and their prices to the standard output. Note that this will cause the dynamically rede.ned 'toString'method \n(see lines 4 5 of listing 2) to be invoked in the case of 'aso' 6 We cannot use JAVA s for each syntax \nsince our compiler currently only accepts Java 1.4 syntax. 15 @ProductType products[] = {mobyDick, aso, \n16 haChi_779}; 17 18 System.out.println(\"In stock:\"); 19 20 for (int i=0; i<products.length; i++) { 21 \n@ProductType p = products[i]; 22 System.out.println(p + \"for \" + p.price()); 23 } Listing 7. Using Abstract \nType Declarations which will then include a reference to the cross promoted 'haChi779'player. By replacing \n' ProdutType'with 'ProdutCategory' and populating the array with 'Softtareltem', 'Hardtare\u00adltem', 'DVD', \n'DVD Player', etc., very similar code could be used to .exibly provide information about the number of \nsold items in various (sub-)categories.  4.5.2 Metaclass Compatibility In a multi-level class hierarchy \nwhere intra-level subclassing may occur at more than one level and such generalization hi\u00aderarchies may \nbe connected by inter-level instance of rela\u00adtionships, two Upward Compatibility and Downward Com\u00adpatibility \nrulesmust be obeyedinorder to avoidruntime er\u00adrors [6]. In the following we rephrase these rules and \nexplain how they are implemented in DEEPJAVA. Upward Compatibility: If a clabject Cof type T is subclassed \nby another clabject C' (with type T'), i.e, C' <Cthen T' must offer at least the features that are offered \nby T. This rule is necessary to ensure that all methods of Cinherited by C' (whose method bodies may \nnavigate to Tand use its features) are guaranteed to also work in C' (in which the same type-navigation \nleads to T'). Note that the upward compatibility rule is trivially ful\u00ad.lled if a class and its subclass \nhave the same type. In par\u00adticular, this is the case when they do not use any speci.c do\u00admain type, but \njust a generic DEEPJAVA type such as 'lass1 ', ..., 'lassn ', which is available for every level n. Downward \nCompatibility: If a clabject T has an in\u00adstance I(i.e., is not abstract) and is subclassed by an\u00ad ' other \nclabject T',i.e., T' <T, then an instance Iof T' must offer at least the features that T expects from \nI. This rule is necessary to ensure that all meth\u00adods of T(which may create T-instances in a generic \nfashion and then call their methods) are guaranteed to also work in T' (whose instances must then be \nable to perform the same method calls). With the usual de.nition C<C(i.e., a class quali.es as its own \nsubclass), one can address the above compatibility issues, simply by demanding C' <C =. type(C')< type(C), \ni.e., subclassing between two classes implies sub\u00adclassing between their types (. upward compatibility) \nand type(C')<type(C)=. C' <Csubclassing between two classes implies subclassing between their respective \nin\u00adstances (. downward compatibility). Of course, the latter rule only applies for C/C' with level values \n>0.In com\u00adbination, these two rules enforce parallel subclassing hierar\u00adchies, i.e., the approach followed \nin Smalltalk [17](see also section 6).  5. Prototype Implementation The following sections brie.y describe \nour approach to cre\u00adating a prototype compiler for DEEPJAVA. 5.1 Compiler DEEPJAVA syntax, typechecking \nrules, and semantics are de\u00ad.ned by using the Polyglot compiler front end which makes it very easy to \nde.ne language extensions for JAVA [32]. It provides a JAVA 1.4 grammar and an extensible LALR parser \ngenerator. In contrast to other parser generators (e.g., JavaCC), Polyglot also supports the adaptation \nof typechecking the DEEPJAVA type system is a true exten\u00adsion of the JAVA type system and code generation. \nCompiling a DEEPJAVA program is a two-phase process. First, DEEPJAVA-sources are typechecked and transformed \ninto JAVA-sources which implement DEEPJAVA semantics. Second, the generated JAVA-code is compiled to \nJAVA byte\u00adcode by the regular javacompiler. Our decision to design DEEPJAVA as a conservative su\u00adperset \nof JAVA implies that we could not always realize our .rst choice regarding additional syntax, because \nwe needed to avoid shift/reduce con.icts for the overall grammar that the Polyglot parser could not handle. \nFor instance, potency values for methods have to be speci.ed after the parameter list, instead of after \nthe method name, and we would have preferred to use round or square parentheses for constructor parameter \nlists. Yet, maintaining the compatibility with the standard JAVA grammar and being able to draw on the \nPoly\u00adglot framework made it easy to tolerate these minor syntac\u00adtical de.ciencies. Our Polyglot front \nend generates JAVA code that imple\u00adments DEEPJAVA semantics, but it does not support the dy\u00adnamic creation \nof classes and their features. Even though JAVA provides a class loader which can dynamically load classes \nfor execution, it is per se not possible to de.ne classes at runtime. However, the class loader may be \nused to incorporate bytecode that has been dynamically generated at runtime. This is the main idea behind \nthe Javassist class li\u00adbrary [11] which enables the de.nition and manipulation of JAVA classes at runtime \nwithout requiring the programmer to deal with bytecode directly. We therefore use Javassist as a runtime \nsupport for the output of the Polyglot compiler in order to enable the creation of classes and their \nfeatures. DJ Java Ru ntim e ProductType\u00b2 taxRate : Integer netPrice : Float\u00b2 price() : Float\u00b2 soldOne() \nProduct name : String \u00abgenerates\u00bb \u00abgenerates\u00bb \u00abrepresents\u00bbProduct name : String ProductType taxRate : \nInteger soldOne() netPrice : Float price() : Float \u00abbased on\u00bb type facet definition java.lang.Class \u00abinstanceOf\u00bb \n\u00abrepresents\u00bb instance facet definition ProductType$Instance_c created dynamically with Javassist price() \n: Float toString() : String DVD netPrice : Float name : String Product DVD \u00abrepresents\u00bb ProductType DVD \ntaxRate = 19 aso : DVD netPrice = 19.95 name = 2001 type typeFacet \u00abinstanceOf\u00bb \u00abinstanceOf\u00bb Figure \n7. Compilation Approach 5.2 Compilation Approach Since the focus of this paper is on demonstrating the \nutility of DEEPJAVA, as opposed to detailing the inner mechanics of its prototype compiler, we only brie.y \nallude to the general compilation approach in the following. For every type facet induced by a DEEPJAVA \nclass de.\u00adnition, we generate a corresponding JAVA class. For exam\u00adple, 'ProdutType'from listing 1 induces \ntwo facet de.ni\u00adtions, one instance facet de.nition (featuring 'taxRate')and one type facet de.nition \n(featuring 'prie'). We consequently generate one JAVA class de.nition 'ProdutType'for the instance facet \nand another, 'ProdutType.lnstane 'for the type facet (see Fig. 7). Had 'ProdutType'declared fea\u00adtures \nwith potency values of 3, we would have obtained a third de.nition 'ProdutType.lnstane.lnstane',de.n\u00ading \nthe potency 3 features, and so forth. Each generated facet de.nition exclusively de.nes the in\u00adstance \nfacet of its instances. For example, 'ProdutType'de\u00ad.nes that its instances have 'taxRate'features. Each \nclabject that may instantiate further clabjects (e.g., 'DVD'in Fig. 7) is provided with a reference to \nthe type facet of its instances. This type facet, again describes the instance facet of its in\u00adstances, \nhere the fact that instances of 'ProdutType'in\u00adstances have 'prie'features. The DEEPJAVA compiler au\u00adtomatically \ngenerates respective 'typeFaet'attributes, 'set\u00adTypeFaet'methods, and'netlnstane'methods, in order to \nsupport the creation of clabjects behind the scenes. Note that dynamically created classes, such as 'DVD', \nare also associated with corresponding JAVA runtime ob\u00adjects (here the element 'DVD'with the grey background) \nthat represent classes. Such class objects (instances of 'java.lang.Class') are used for instance creation \nand can be accessed via the JAVA re.ection API. Hence, 'aso'is an in\u00adstance of 'DVD'but note that its \nDEEPJAVA type is 'DVD' so that type features such as 'taxRate'can be accessed. The leftmost 'DVD'element \nis dynamically composed from a number of sources, overriding of identical features taking place in the \nfollowing order: it implements its type facet de.nition interface. Fig. 7 shows the latter using the \nUML lollipop notation. As we can only implement an interface (single inheritance may be required for \nanother class, see below), the features to be implemented must be copied from the corresponding source. \nHence the 'basedon'relationship from 'DVD'to 'ProdutType.lnstane '. it inherits features from a static \nJAVA class 'Produt', due to the extends SoftwareItem line 3 of listing 2. We have excluded 'Softtareltem'from \nFig. 7 for brevity since it does not contribute any type facet features.  the 'toString O'method is \nadded last, due to lines 4 5 of listing 2.  Interfaces for type facet de.nitions are required for yet \nanother reason: Dynamically created DEEPJAVA classes (such as 'DVD') cannot be associated with any known \nspe\u00adci.c type. Variables referring to instances of such classes are therefore typed with the interface \nof the type facet def\u00adinition. In particular for abstract type declarations, such as ' ProdutType', said \ninterface is required since it may be implemented by a multitude of classes which need not have a common \nconcrete root superclass. The above described use of interfaces implies that DEEP-JAVA programs may not \ndirectly access attributes with po\u00adtency values = 2,since JAVA interfaces do not permit the declaration \nof attributes. However, we perceive this limita\u00adtion as a built-in feature to remind programmers of the \nloss in encapsulation implied by using public attributes instead of access methods to private attributes. \n 6. Related Work Work on programming languages abounds with attempts to equip programmers with meta-level \ndescriptions (and possi\u00adbly further classi.cation levels). The meta-object protocol [21] for CLOS is \nprobably the prototypical example for the approach to use meta-level de\u00adscriptions in order to adjust \nthe language to better suit the needs of its users. In contrast to DEEPJAVA s classi.cation levels, however, \nthe CLOS meta level interface is not in\u00adtended to provide a direct mapping from domain classi.ca\u00adtion \nlevels to programming levels, but to give programmers control over basic programming mechanisms, such \nas slot access, method dispatch, and multiple inheritance. This ap\u00adproach can therefore be used to support \nprogrammer-de.ned additions such as asynchronous communication, exceptions, pre/post conditions, etc. \nThis intention is not speci.c to CLOS but characteristic of a whole range of meta-level de\u00adscription \napproaches: One of the key ideas is to provide at the metalevel generic metacomponents describing standard \nOO lan\u00adguage features and their decomposition into basic facets [13]. Some of these approaches also aim \nat describing class prop\u00aderties, but from a linguistic perspective, addressing proper\u00adties such as being \nabstract, being .nal, supporting multiple inheritance, etc. DEEPJAVA class properties, in contrast, are \npurely ontologically motivated, i.e. derive themselves from the domain (see, e.g., our 'taxRate'feature). \nThe most recent addition to the linguistic-control camp is Aspect-Oriented-Programming [22] whose aspect \nde.ni\u00adtions can be understood as second order predicates ranging over programs. AOP applications typically \ndo not address domain-related concepts but system-oriented ones, such as the famous logging aspect. There \nis also work on so-called early aspects , addressing cross-cutting concerns at the re\u00adquirements level, \nbut in any event, aspects cannot help to adequately accomodate an n-level domain classi.cation. SMALLTALK \n[17] features metaclasses which are onto\u00adlogically motivated, i.e., represent class level properties \nin\u00adduced by the domain, but supports them in a very restricted way only. Metaclasses are singletons (have \nonly one in\u00adstance), and classes have exactly one anonymous metaclass which can only be reached by sending \na 'lass'message to a class. As a result, SMALLTALK metaclasses enable program\u00admers to deal with classes \nin the same way as with objects and introduce the ability to de.ne class level properties (analog to \nthe static features of JAVA classes), but do not offer any further advantages. It is, for instance, not \npossible for two classes to have the same metaclass or build hierarchies with a classi.cation depth > \n2,since SMALLTALK metaclasses just add an instance facet to the class level and there is no way to de.ne \nmeta-metaclasses. The OBJVLISP re.ective architecture [14] introduces the analog of the concept of a \nclabject, but again with\u00adout an ontological motivation, but to create a more uni\u00adform SMALLTALK classi.cation \nhierarchy with the inten\u00adtion to control inheritance, internal representation of ob\u00adjects, caching techniques, \netc. The same linguistic con\u00adtrol motivation is characteristic of other attempts to extend SMALLTALK,suchas \nCLASSTALK [25]. NEOCLASSTALK [6] introduces an approach that ensures upward and downward compatibility \n(see section 4.5.1) without causing all the properties of a metaclass to be in\u00adherited by all its (transitive) \nsubclasses. This is important in the context of NEOCLASSTALK since metaclasses are in\u00adtended to introduce \nclass properties, such as being abstract or disallowing subclassing. This is why NEOCLASSTALK puts an \nemphasis on per class properties and supports in\u00addependent property composition . In our DEEPJAVA design \nwe do not require such an approach since it is for our on\u00adtologically induced clabjects desirable that \n(ontological) clabject properties are transitively inherited. BETA [28] also supports relative types, \ni.e, accessing type values through attributes, and also uses a genericity mech\u00adanism that differs from \nparametric polymorphism as used in JAVA 1.5. However, unlike DEEPJAVA,BETA s formal generic type parameters \n(virtual classes)are not constrained by atype(e.g., 'HardtareType') but by an upper bound (e.g., 'Hardtareltem') \nthat may be further bound in rede.nitions until constrained to a single type value in a .nal binding. \nIn analogy to the discussion on DEEPJAVA abstract typ declara\u00adtions (see section 4.5.1), type variables \nconstrained by a type are more generic then those controlled by a supertype (upper bound) because they \nmay admit types from different inheri\u00adtance hierarchies. We have not yet fully explored all poten\u00adtial \nfurther differences between the different approaches, but believe that the simplicity of DEEPJAVA s approach \na uni\u00adform classi.cation hierarchy were everything is a value and genericity naturally drops out as a \nbyproduct is convincing even without being more powerful. In section 3, we have already mentioned powertypes \nas an alternative to achieving deep characterization. Appar\u00adently invented by Cardelli [9] and introduced \nto the model\u00ading community by Odell [33], the powertype concept works by establishing an instance of \nrelationship between a metatype M and all the subtypes C1,...,Cn,ofa super\u00adtype S. While Odell only used \npowertypes to motivate the need for (and explain a way to) describe class properties, a powertype M can \nbe used to prescribe the properties of in\u00adstances of the C1,...,Cn, by forcing their classes to inherit \nthe to be guaranteed properties from the supertype S. Deep instantiation achieves the same effect more \ncon\u00adcisely, since powertypes distribute the description of the in\u00adstance facet and the common type facet \nof the C1,...,Cn to M and S respectively. Using deep instantiation, one only needs to declare the S features \nat M and increase their po\u00adtency values by one. No matter how deep the characteriza\u00adtion depth is, deep \ninstantiation allows the concise descrip\u00adtion at a single concept. Powertypes, in contrast, require a \nstaged application of multiple powertypes and supertypes, adding up to complex whole. Furthermore, powertypes \nrequire a superclass S (e.g., 'Produt') independently of its utility in re.ecting the do\u00admain structure. \nUsing deep instantiation, one has a choice of either introducing S or not. Due to DEEPJAVA s abstract \ntype declarations, S is not even necessary as a variable type for generic code, since one may use (more \n.exibly) ' M'. However, if the introduction of S appears to be bene.\u00adcial for other reasons then we can \nachieve the semantics of powertypes with DEEPJAVA by using 'extends'relationships with apotency valueof \n1.A standard 'extends'relationship between two classes has a potency value of 0 because it links two \nclasses with each other without being transferred to the class instances (which in JAVA wouldamount toinheritance \nbetween objects). Line 2 of Listing 8 shows how we have previously created a dynamic class with a superclass \nreference to a statically known class ('Produt'). 1 // instead of 2 ProductCategory SoftwareItem extends \nProduct0; 3 4 // with 5 class ProductCategory2 extends1 Product0; 6 7 // we only need 8 ProductCategory \nSoftwareItem = new ProductCategory(); Listing 8. Powertypes with Deep Instantiation If we extend the \nde.nition of 'ProdutCategory'as shown in line 5 of listing 8, we are guaranteed that every 'Produt\u00adCategory'instance \n(such as 'Softtareltem'or (indirectly) 'DVD') will subclass 'Produt'. Hence, we may then create 'Softtareltem'without \nmanually linking it to the 'Produt' superclass as shown in line 8 of listing 8. Unfortunately, due to \nthe desire to stay compatible with the plain JAVA syntax, we cannot abbreviate this line to 'ProdutType{}Softtare\u00adltem;'. \n'Softtareltem'may still be assigned a superclass upon creation as in line 2 of listing 8 but DEEPJAVA \ns type system then demands the speci.ed type to be a subtype of 'Prod\u00adut', otherwise we would introduce \na form of multiple in\u00adheritance. In summary, we can naturally achieve powertype semantics with deep instantiation \nbut powertypes cannot at\u00adtain the conciseness of deep instantiation. Materialization is a relationship \nbetween two concepts which can also achieve deep characterization and has been introduced for modeling \ndatabases [18]. Fig. 1 from [18]and in particular the account on materialization given by Pirotte et \nal. [35], reveals that materialization can be explained as using the same principles as powertypes.Interms \nof our example, 'Produt'*- (materializes) 'ProdutType'holds, and both concepts are used to control the \ntype and instance facets of instances respectively (see Fig. 3 in [35]). ConceptBase [19] is a knowledge \nrepresentation system based on Telos [31] which supports an arbitrary number of ontological classi.cation \nlevels. Due to its focus on knowl\u00adedge representation, as opposed to programming, and the fact that one \nmodels knowledge in terms of propositions, it apparently, as of today, did not in.uence the design of \npro\u00adgramming languages. There are approaches, e.g., METABORG [7]and META-ASPECTJ[38], that support the \nstatic checking of strings containing program code, for instance the one shown at lines 4 5 of listing \n2. In general, this feature helps to reject improper string contents at compile time and thus avoid runtime \nerrors. However, note that in order to support a fully dynamic creation of types, DEEPJAVA allows any \ndynamic string content in the de.nition of a dynamic type. The string value shown at lines 4 5 of listing \n2 could have been typed in by a user at runtime. Static checking could still be applied to string constants, \nsuch as the one in listing 2, though.  7. Future Work The main purpose of this paper is to motivate \nmulti-level programming and to present the basis of a supporting pro\u00adgramming language. To some extent \ndeliberately but to some extent also out of necessity we did not attempt to present a complete language \ndesign. While our working prototype compiler for DEEPJAVA allows the parsing, typechecking, and execution \nof exciting multi-level programs, such as our running example, it does not yet address a number of issues. \nThe most interesting issues concern DEEPJAVA s type sys\u00adtem and extensions thereof. In section 4.4 we \nhave demonstrated how DEEPJAVA can support generic classes without requiring additional con\u00adcepts such \nas JAVA generics or BETA s virtual classes. By only allowing '.nal'type parameters, we give the program\u00admer \nand type system a chance to exploit static knowledge about type parameters, since although they are assigned \ndynamically once they are immutable. Although we have not .nalized our work on an appropriate type system \nthat is permissive enough to allow interesting programs and strong enough to reject as many type-related \nerrors at runtime as possible, we are strongly in.uenced by the approach of the GBETA language [15]. \nThe latter demonstrates how static typechecking is possible in the presence of types as values, which \ncan be accessed as pattern members, and virtual types whose type is only known by an upper bound. GBETA \nhence allows a number of intriguing applications, such as family polymorphism [16]. Just to hint at how \ntypes as dynamic as those of GBETA or DEEPJAVA are still amenable to a static type discipline, consider \nthe following example. The type of 'aso.promoProdut O'is unknown at com\u00adpile time, since its owning class \n'DVD'and the associated 'CrossPromotionType'(in this case 'DVD Player')are not known before their creation \nat runtime. However, the re\u00adsult of 'aso.promoProdut O'can still be used in a type\u00adsafe manner: Assuming \na further method of class 'DVD', 'playOn CrossPromotionTypeO', the following code is stat\u00adically safe: \n'aso.playOnaso.promoProdut OO'or alterna\u00adtively, 'aso.playOn netaso.CrossPromotionTypeOO'. We are currently \nplanning to add dependent types to DEEPJAVA which would not only provide a more than satis\u00adfactory solution \nfor fully typing generic classes, but would also solve the important problem of covariant rede.nitions. \nWhen a class rede.nes a superclass method, it must not re\u00adde.ne the method arguments to be more speci.c, \notherwise either runtime errors may occur or polymorphism has to be forbidden [1]. This is a problem \nsince polymorphism is the key to generic program structures, while programmers of\u00adten .nd a need to strengthen \nthe argument types of methods upon rede.nition (e.g., ideally the 'e.uals'method would constrain its \nargument type to be the receiver type, the lat\u00adter obviously becoming more speci.c in a subclass). Many \nsolutions have been proposed to this problem but the only one that really adequately pins down the source \nof the prob\u00adlem and addresses it accordingly, uses a form of dependent types [36]. We therefore expect \nto kill two birds with one stone by .tting a type system based on dependent types onto DEEPJAVA.  8. \nConclusion Most of today s programs have a high level of inherent com\u00adplexity. Any accidental complexity \nthat is additionally in\u00adtroduced because the solution technology cannot accommo\u00addate an adequate representation \nof the problem is therefore doubly unwelcome. In this paper, we argued that a number of systems need \nto adequately re.ect multiple levels of do\u00admain classi.cation and that this is in con.ict with the current \ntwo-level limitation of the object-oriented paradigm. While workaround techniques exist, documenting \nthe need to ad\u00address this issue, they add a lot of accidental complexity to programs by requiring the \nprogrammer to reinvent the wheel in terms of emulating built-in mechanisms of the program\u00adming language. \nThis is why the title of this paper paraphrases the ti\u00adtle of John W. Backus s 1977 ACM Turing Award \nLecture Can Programming Be Liberated from the von Neumann Style? [5] in wich Backus sought for ways of \nescaping an imperative programming style based on single assignment semantics, because he judged this \nsolution technology to only inadequately address the challenges of programming. Although a large body \nof intriguing work successfully ex\u00adtended the original two-level design of object-oriented pro\u00adgramming \nlanguages to three or more levels, the focus hith\u00aderto has been on exerting linguistic control on classes. \nThis approach is useful for creating extensible languages and sys\u00adtems, but does not address the mismatch \nbetween the num\u00adber of domain classi.cation levels and the number of on\u00adtological programming levels. \nOur DEEPJAVA language de\u00adsign, in contrast, does not constitute an extensible language. The capability \nto let the number of supported ontological levels grow as desired is a .xed, built-in feature of the \nlan\u00adguage. Through conservatively extending the two levels of programming and the associated shallow \ninstantiation mech\u00adanism of the object-oriented paradigm to multiple levels with an associated deep instantiation \nmechanism, we have achieved several advantages. The DEEPJAVA language de\u00adsign enables a direct mapping \nof domain classi.cation levels to programming levels.  allows the dynamic creation of classes and their \nfeatures.  integrates its dynamic features with static typing.  supports deep instantiation as a concise \nmechanism for deep characterization. offers abstract type declarations, thus achieving a level of abstraction \nbeyond powertypes and virtual classes.  features a natural approach to genericity as a byproduct of \nits uniform ontological classi.cation hierarchy.  is a perfect target for incorporating dependent types \nand their ability to solve the covariance problem.  We are well aware of the fact that the current state \nof DEEP-JAVA s language design cannot be considered .nal. How\u00adever, we hope that we have managed to impart \nour enthu\u00adsiasm for its already existing advantages and its potential for further development on to the \nreader.  Figure 8. DEEPJAVA Online Store Snapshot  References [1] Mart\u00edn Abadi and Luca Cardelli. On \nsubtyping and matching. In W. Olthoff, editor, Proceedings ECOOP 95,LNCS952, pages 145 167, Aarhus, Denmark, \nAugust 1995. Springer. [2] Colin Atkinson and Thomas K\u00fchne. Meta-level independent modeling. In International \nWorkshop Model Engineering (in Conjunction with ECOOP 2000). Springer Verlag, Cannes, France, June 2000. \n[3] Colin Atkinson and Thomas K\u00fchne. The essence of multilevel metamodeling. In Martin Gogolla and Cris \nKobryn, editors, Proceedings of the 4th International Conference on the UML 2000, Toronto, Canada, LNCS \n2185, pages 19 33. Springer Verlag, October 2001. [4] Colin Atkinson and Thomas K\u00fchne. Reducing accidental \ncomplexity in domain models. Journal on Software and Systems Modeling, to appear 2008, DOI: 10.1007/s10270\u00ad007-0061-0. \n[5] John W. Backus. Can programming be liberated from the von Neumann style? A functional style and its \nalgebra of programs. Communications of the ACM, 21(8):613 641, August 1978. [6] Noury M. N. Bouraqadi-Sa\u00e2dani, \nThomas Ledoux, and Fred Rivard. Safe metaclass programming. In Proceedings of the 13th ACM SIGPLAN conference \non Object-oriented programming, systems, languages, and applications, pages 84 96, New York, NY, USA, \n1998. ACM Press. [7] Martin Bravenboer, Ren\u00e9 de Groot, and Eelco Visser. MetaBorg in action: Examples \nof domain-speci.c language embedding and assimilation using Stratego/XT. In R. L\u00e4m\u00admel and J. Saraiva, \neditors, Proceedings of GTTSE 05,LNCS 4143, pages 297 311. Springer, 2006. [8] Frederick P. Brooks. No \nsilver bullet: essence and accidents of software engineering. Computer, 20(4):10 19, 1987. [9] Luca Cardelli. \nStructural subtyping and the notion of power type. In Conference Record of the Fifteenth Annual ACM Symposium \non Principles of Programming Languages,pages 70 79, San Diego, California, 1988. [10] CesarGonzalez-Perez \nand Brian Henderson-Sellers. A powertype-based metamodelling framework. Software and Systems Modeling, \nV5(1):72 90, April 2006. [11] Shigeru Chiba. Load-time structural re.ection in Java. In Proceedings of \nthe 14th European Conference on Object-Oriented Programming, LNCS 1850, pages 313 336, 2000. [12] Peter \nCoad. Object-oriented patterns. Communications of the ACM, 35(9):152 159, September 1992. [13] P. Cointe. \nRe.ective languages and metalevel architectures. ACM Comput. Surv., 28(4es):151, 1996. [14] Pierre Cointe. \nMetaclasses are .rst class: The objvlisp model. SIGPLAN Notices, 22(12):156 162, 1987. [15] Erik Ernst. \ngbeta A Language with Virtual Attributes, Block Structure, and Propagating, Dynamic Inheritance.PhD \nthesis, DEVISE, Department of Computer Science, University of Aarhus, Aarhus, Denmark, June 1999. [16] \nErik Ernst. Family polymorphism. In J\u00f8rgen Lindskov Knudsen, editor, Proceedings of ECOOP 2001, LNCS \n2072, pages 303 326, Heidelberg, Germany, 2001. Springer-Verlag. [17] Adele Goldberg and David Robson. \nSmalltalk-80: The Language and its Implementation. Addison-Wesley, Reading, MA, 1983. [18] Robert C. \nGoldstein and Veda C. Storey. Materialization. IEEE Transactions on Knowledge &#38; Data Engineering, \n6(5):835 842, 1994. [19] Matthias Jarke, Rainer Gallersd\u00f6rfer, Manfred A. Jeusfeld, Martin Staudt, and \nStefan Eherer. ConceptBase a deductive object base for meta data management. Journal of Intelligent Information \nSystems, 4(2):167 192, 1995. [20] Ralph Johnson and Bobby Woolf. Type object. In Robert C. Martin, Dirk \nRiehle, and Frank Buschmann, editors, Pattern Languages of Program Design 3, pages 47 65. Addison-Wesley, \n1997. [21] Gregor Kiczales, Jim des Rivi\u00e8res, and Daniel G. Bobrow. The Art of the Metaobject Protocol. \nMIT Press, 1991. [22] Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Videira \nLopes, Jean-Marc Loingtier, and John Irwin. Aspect-oriented programming. In Proceedings of ECOOP 97, \nFinland, pages 222 242, Berlin, June 1997. Springer Verlag, LNCS 1241. [23] Thomas K\u00fchne. Matters of \n(meta-) modeling. Journal on Software and Systems Modeling, 5(4):369 385, 2006. [24] Craig Larman. Applying \nUML and Patterns: An Introduction to Object-Oriented Analysis and Design and the Uni.ed Process. Prentice \nHall, second edition edition, 2002. [25] Thomas Ledoux and Pierre Cointe. Explicit metaclasses as a tool \nfor improving the design of class libraries. In Proceedings of ISOTAS, LNCS 1049, pages 38 55. Springer \nVerlag, March 1996. [26] Barbara H. Liskov and Jeannette M. Wing. A behavioral notion of subtyping. ACM \nTransactions on Programming Languages and Systems, 16(6):1811 1841, 1994. [27] Fernando Daniel Lyardet. \nThe dynamic template pattern. In Proceedings of the Conference on Pattern Languages of Design, 1997. \n[28] Ole L. Madsen, Birger M\u00f6ller-Pedersen, and Kristen Ny\u00adgaard. Object-Oriented Programming in the \nBETA Program\u00adming Language. Addison-Wesley, June 1993. [29] Pattie Maes and D. Nardi, editors. Meta-Level \nArchitectures and Re.ection. Elsevier Science Inc., New York, USA, 1988. [30] Bertrand Meyer. Object-Oriented \nSoftware Construction. Prentice Hall, ISBN 0-13-629155-4, 2nd edition, 1997. [31] John Mylopoulos, Alexander \nBorgida, Matthias Jarke, and Manolis Koubarakis. Telos: Representing knowledge about information systems. \nInformation Systems, 8(4):325 362, 1990. [32] Nathaniel Nystrom, Michael R. Clarkson, and Andrew C. Myers. \nPolyglot: An extensible compiler framework for Java. In Proceedings of the 12th International Conference \non Compiler Construction, LNCS 2622, pages 138 152. Springer, April 2003. [33] Jim Odell. Power types. \nJournal of Object-Oriented Programming, 7(2):8 12, May 1994. [34] OMG. Uni.ed Modeling Language Superstructure \nSpec\u00adi.cation, Version 2.1.1, OMG document formal/07-02-05, February 2007. [35] Alain Pirotte, Esteban \nZim\u00e1nyi, David Massart, and Tatiana Yakusheva. Materialization: A powerful and ubiquitous abstraction \npattern. In Proceedings of the 20th International Conference on Very Large Data Bases (VLDB 94), pages \n630 641. Morgan Kaufman, 1994. [36] David L. Shang. Covariant deep subtyping reconsidered. ACM SIGPLAN \nNotices, 30(5):21 28, May 1995. [37] Joseph W. Yoder and Ralph E. Johnson. The adaptive object\u00admodel \narchitectural style. In Proceedings of the 3rd IEEE/I-FIP Conference on Software Architecture: System \nDesign, Development and Maintenance, pages 3 27, Deventer, The Netherlands, The Netherlands, 2002. Kluwer, \nB.V. [38] David Zook, Shan Shan Huang, and Yannis Smaragdakis. Generating AspectJ programs with Meta-AspectJ. \nIn Gabor Karsai and Eelco Visser, editors, Proceedings of GPCE 04, LNCS 3286, pages 1 18. Springer, 2004. \n \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Since the introduction of object-oriented programming few programming languages have attempted to provide programmers with more than objects and classes, i.e., more than two levels. Those that did, almost exclusively aimed at describing language properties-i.e., their metaclasses exert linguistic control on language concepts and mechanisms-often in order to make the language extensible. In terms of supporting logical domain classification levels, however, they are still limited to two levels.</p> <p>In this paper we conservatively extend the object-oriented programming paradigm to feature an unbounded number of domain classification levels. We can therefore avoid the introduction of accidental complexity into programs caused by accommodating multiple domain levels within only two programming levels. We present a corresponding language design featuring ``deep instantiation'' and demonstrate its features with a running example. Finally, we outline the implementation of our compiler prototype and discuss the potentials of further developing our language design.</p>", "authors": [{"name": "Thomas Kuehne", "author_profile_id": "81339510667", "affiliation": "Darmstadt University of Technology, Darmstadt, Germany", "person_id": "P905217", "email_address": "", "orcid_id": ""}, {"name": "Daniel Schreiber", "author_profile_id": "81319501040", "affiliation": "Darmstadt University of Technology, Darmstadt, Germany", "person_id": "PP18009955", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297044", "year": "2007", "article_id": "1297044", "conference": "OOPSLA", "title": "Can programming be liberated from the two-level style: multi-level programming with deepjava", "url": "http://dl.acm.org/citation.cfm?id=1297044"}