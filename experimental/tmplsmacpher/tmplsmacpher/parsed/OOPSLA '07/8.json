{"article_publication_date": "10-21-2007", "fulltext": "\n Component NextGen: A Sound and Expressive Component Framework for Java * James Sasitorn Rice University \n camus@rice.edu Abstract Developing a general component system for a statically typed, object-oriented \nlanguage is a challenging design problem for two reasons. First, mutually recursive refer\u00adences across \ncomponents are common in object-oriented programs an issue that has proven troublesome in the context \nof component systems for functional and proce\u00addural languages. Second, inheritance across component boundaries \ncan cause accidental method overrides. Our recent research shows that a component framework can be constructed \nfor a nominally typed object-oriented language supporting .rst-class1 generic types simply by adding \nap\u00adpropriate annotations, syntactic sugar, and component-level type-checking. The fundamental semantic \nbuilding blocks for constructing, type-checking and manipulating compo\u00adnents are provided by the underlying \n.rst-class generic type system.To demonstrate thesimplicity and utilityof this ap\u00adproach we have designed \nand implemented an extension of Java called Component NEXTGEN (CGEN). CGEN, which is based on the Sun \nJava 5.0 javac compiler, is backwards compatible with existing Java binary code and runs on currentJavaVirtual \nMachines. The primary contributionofthis paperisa technical anal\u00adysisof the subtle design issuesinvolvedinbuilding \na com\u00adponent framework foranominally typed object-oriented lan\u00adguage supporting .rst-class generics. \nIn contrast to compo\u00adnent systems for structurally typed languages, mutual recur\u00adsion among components \nis accommodated in the type system * This research has been partially supportedby the National ScienceFoun\u00ad \ndation, theTexas AdvancedTechnology Program, and Sun Microsystems. 1Alanguage supporting .rst-class generic \ntypes allows generic types to be used in anycontextwhere conventional types can appear. This terminol\u00adogy \nwas established in [1] Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. OOPSLA 2007 October 21-25, Montr \u00b4 eal, Canada Copyright c . 2007ACM 978-1-59593-786-5/07/0010...$5.00 \nRobert Cartwright Rice University cork@rice.edu and semantics without incorporating anyspecial machinery. \nOur analysis includesa presentationof CoreCGEN (CCG), a small, core language modeling the CGEN framework. \nIt is based onFeatherweight GJ and incorporates some ideas fromMIXGEN.CCGaddsthe essentialfeaturesto \nsupport components,but nothing more. Our discussion includes the type rulesandsemanticsforCCG,aswellasaproofoftype \nsafety. Categories and Subject Descriptors D.1.5 [Program\u00adming Techniques]: Object-oriented Programming; \nD.3.3 [Programming Languages]: Language Constructs and Features Classes and objects; Polymorphism; Modules, \npackages; Components General Terms Design, Language Keywords .rst-class generics, Java implementation, \ncus\u00adtom class loader, modules, components, signatures 1. Introduction Java has transformed mainstream \nsoftware development by supporting clean object-oriented design, comprehensive static type checking, \nsafe program execution, and an un\u00adprecedented degree of portability. Despite these signi.cant achievements, \nthe Java language has been handicapped as a vehicle for writing large applications during its brief history \nby two major shortcomings:(i)the lack of a generic type system (classes and methods parameterized by \ntype) and (ii)the absence of a component system for decomposing applications into independent units with \nstatically checked interfaces. The .rst shortcoming has been partially ad\u00addressed by the Java standardization \nprocess (JSR-14 [17] incorporated in Java 5.0), and more comprehensively by the programming research \ncommunity (GJ [8], PolyJ[22], NEXTGEN [9],LM[33,32])butthe issueofhowto support a general purpose component \nsystem in Java has received relatively little attention. Components are independent units of compiled \ncode that can be linked to form complete programs. They have no independent state, and all of the references \nthat cross unit boundaries must be explicitly identi.ed in a unit s signa\u00adture and linked together when \nthe units are joined to form programs[12, 16, 30]. Two features of the Javaplatform are often cited as \nmech\u00adanisms for supporting components: the Java package system and the JavaBeans framework. But neither \nof these facili\u00adties quali.es as a component system suitable for decompos\u00ading application programs into \nindependent units of compiled code. Java packages are simply separate name spaces; theytyp\u00adically containexplicit \nreferencesto namesin other packages (akin to hard-coded .le names scattered in shell scripts), vi\u00adolating \nthe principle that all external references must be ex\u00adplicitly identi.ed in a component signature. The \nJavaBeans framework is a wiring standard includ\u00ading an introspection mechanism for building applications \nin speci.c domains. This framework is targeted primarily at building graphical user interfaces in client \nprograms. Like all wiring standards , it formulates components as objects (rather than classes) and relies \non an introspective mechanism (re.ection) to support .exible linking with other components compromising \nthe effectiveness of static type checking and preventing the use of linguistic mechanisms like inheritance \nacross component boundaries. Developing a general component system for a statically typed, object-oriented \nlanguage like Java is a challenging problem for two reasons. First, mutually recursive refer\u00adences across \ncomponents are common in object-oriented programs an issue that has proven troublesome in the context \nof component systems for functional and procedural languages. Second, inheritance across component bound\u00adaries \ncan produce unexpected results. The nameofa method introducedina classmay collide withthe nameofa public \nor protected method in an imported superclass [31, 30], breaking the behavior of the inherited superclass. \nComponent NEXTGEN (CGEN) avoids accidental method capture by supporting hygienic components based on \nhygienic mixins [12, 13, 1] that eliminate acci\u00addental method capture by systematically renamingmethods. \nCGEN is an extension of the NEXTGEN language, a gen\u00aderalization of Java 5.0 that ef.ciently supports \n.rst-class generic types[4, 27]. By leveraging .rst-class generic types in NEXTGEN, the construction \nof a hygienic component system for CGEN is reduced to adding the appropriate annotations (signatures), \nsyntactic sugar (modules), and the corresponding component-leveltype checking. In NEXTGEN, generic types \nare .rst-class values that can appear in almost any context where conventional types can appear. NEXTGEN \nsupports type casting and instanceof operations of parametric type, class constants of naked parametric \ntype(e.g., T.class), and new opera\u00adtions of naked parametric class and array types, e.g., new T(), and \nnew T[]. A prior extension of NEXTGEN called MIXGEN[1] probed the limits of .rst-class genericity by \nincorporating hygienic mixins in the NEXTGEN implementation architec\u00adture.Amixinisa class de.nition whereatype \nparameter T serves as the super class: class C<T implements I> extends T { ... } The hygienic semantics \nfor mixins prevents accidental method capture when a mixin instantiation C<A> overrides a method of the \nsuperclass A that is not a member of the interface I bounding A. The CGEN component language is a natural \nextension of the NEXTGEN generic type system that supports the pa\u00adrameterization of packages by type \n(creating components) and adds new annotations (package signatures) to the type system. The translation \nof these new constructs into NEXT-GEN code is a local syntactic expansion, implying that the new constructs \nare merely syntactic sugar modulo the ex\u00adtra type-checking required to ensure that the sugared syn\u00adtax \nexpands into well-typed Java code.2 CGEN does not re\u00adquire a secondary module language or additional \ntranslation steps between compilationorexecution.CGENis backwards compatible with existing libraries \nand executes on current JVMs. The prototype implementation of CGEN, derived from the Java 5.0 javac compiler, \nproduces code comparable in ef.ciency and size to NEXTGEN which is not surprising sinceCGEN usesa similar \nimplementation architecture. While a prior publication on our work [28] focused on providing a pragmatic \noverview of CGEN, the primary con\u00adtribution of this paper is a technical analysis of the design issues \ninvolved in building a component framework for a nominally typed object-oriented language supporting \n.rst\u00adclass generics, like the NEXTGEN formulation of Generic Java. The remainder of this paper is organized \nas follows. Section 2 reviews the conceptual foundations of our work and motivates the design of CGEN. \nSection 3 provides an overview of CGEN. Section 4 discusses the technical complications presentin CG \nEN. Section 5.1 discusses Core CGEN (CCG), a subset of CGEN that encapsulates the core elementsofCGEN. \nFinally, Section6discusses related work on component systems for Java and similar languages. AppendixAprovidesa \nmoreextensive discussionofCCG including an operational semantics, type inference system, and an outline \nof type soundness. 2. Background and Motivation Before we discuss how components are de.ned in CGEN, \nwe need to surveythe technical and conceptual foundations for our work. 2.1 Nominal Typing Mainstream \nobject-oriented languages, namely Java, C#, and C++, rely on the nominal typing rather than the struc\u00adtural \ntyping of objects, which has been the focus of most of 2Our actual implementation optimizes the naivetranslation \nbased purely on syntactic sugar. the technical research on type systems. In object-oriented languages \nwith nominal typing, a class A is a subtype of a class B iff A explicitly inherits from B.3 The programmer \nexplicitly determines the structure of the type hierarchy. In languages with structural typing, a class \nA is a subtype of a class B iff(i)A includes all of the member names in B and(ii)the typeof each memberinA \nisa subtypeofthe cor\u00adresponding member in B. There is no relationship between subtyping and code inheritance \nbecause subtyping between classes depends only on the signatures of the members of types not on their \ninheritance relationships or on subtyp\u00ading relationshipsexplicitly declaredby the programmer.For a more \ndetailed comparison of the structural and nominal typing of objects see [1]. The distinction between \nstructural and nominal typing means that we cannot directly apply technical results derived for structural \ntype systems to Java or putative extensions of Java likeCGEN.  2.2 Independent Components Softwaredevelopersgenerally \nrecognizethevalueofbuild\u00ading software from reusable components as much as is practi\u00adcable. But the proper \nde.nition of components is controver\u00adsial; it has been extensively debated in the literature. Based onourexperienceassoftwaredevelopers,we.ndthe \nde.ni\u00adtion in Szyperski s widely-cited book on the subject [30] to be the most compelling. According \nto Szyperski, a component is a unit of com\u00adpiled code that is: independent,  composableby third parties, \nand  devoid of independent state.  For a component to be an independent unit of compiled code, it must \nbe completely separate from the environment in which it is de.ned and compiled precluding any explicit \nreferences to other components. Thus, a component com\u00adpletely encapsulates its features and can only \nbe deployed in its entirety. For a component to be composable by third parties, not only must it be self-contained, \nbut it must also have well\u00adde.ned, explicit speci.cations of its requirements (depen\u00addencies on components \nto be imported and their contracts) and features (provided interfaces and their contracts). If a component \nhas no independent state (such as an ob\u00adject allocation address), it can be used in any context satis\u00adfying \nits requirements. In any valid context (bindings of its dependencies), we are guaranteed that the component \nwill alwayshave the same behavior.If components had indepen\u00addent state, therewouldbeno guarantee thattwo \ninstallations of the same component in the same context will have the 3We are using the term inheritance \nmore broadly than inheriting code. In our terminology, a Java class inherits from all of its interfaces \nas well as its superclass. same behavior.Infact, multiple copiesofa component could be installed within \na system and interfere with one another. 2.3 Java Packages In the Java programming model, packages are \nthe primary construct used by programmers to organize a large-scale Java application into manageable \nunits of development. Packages provide distinct name spaces to organize col\u00adlections of classes and interfaces. \nA class is included in a package by adding a package declaration at the top of the .le and placing the \n.le in the directory associatedwith the package.Apackaged public class can be used outside the packageby \neither:(i)using a fully-quali.ed reference to a class, or(ii)using animport statement4 coupled withanon\u00adquali.ed \nreference. In compiled class .les, these two forms of usage are equivalent because the compiler translates \nnon\u00adquali.ed references into their corresponding fully-quali.ed names and discards allofthe import statements. \nFigure1and2showsanoutlineofthe abstract syntaxand recursive decent parser5 for the Jam language, a simple \nfunctional language assigned as a series of programming exercises in the undergraduate course at Rice \nUniversity on programming languages. The Parser resides in the package jam.parser and uses classes from \njam.ast. Figure3 shows the outline of an interpreter that references jam.parser.Parser and classes from \njam.ast. From a software engineering perspective, the fully\u00adquali.ed references to jam.ast.Exception \nin Figure 2 and jam.parser.Parser in Figure3pose long-term code management problems. Each fully-quali.ed \nidenti.er is a hard-coded, absolute reference to an external class. To change the name of an imported \nclass or a package, the programmer must perform a global search and replace of all the references to \nthe class or package, which are scattered throughout the program. At the macroscopic level, these references \ncreate a tan\u00adgled web of hidden contextual dependencies across pack\u00adages. As a result, packages cannot \nbe developed in isolation. All of a package s dependencies (imported classes) must be presentfor boththe \ncompilationandexecutionofthe pack\u00adage.Amodi.cationto classesinapackage typically requires recompilationof \nall codethat depends on it.6 These problems become more apparent when we con\u00adsider alternative component \nimplementations, e.g.,abottom\u00ad 4Not to be confused with the imports to a CGEN module. Java import statements \nprovide automatic expansion of non-quali.ed names to fully\u00adquali.ed names by matching the non-quali.ed \nnames against the members of the imported classes and interfaces. 5Due to space constraints, most of \nthe code for this example has been elided. The complete code for this example (and others) is available \nat http://japan.cs.rice.edu/nextgen/examples/. 6Evenchangestoaclassthat preservetheexisting interface \ncanstillforce recompilation.Forexample,ifthe bindingofa static .nal constant .eldis changed, all of the \nclasses that refer to that .eld must be recompiled because thevalueofthe.eldmaybe inlinedinthe compiledcodeforthe \nclassesthat refer to it. package jam.ast; interface JamVal { ... } interface AST { ... } interface IBinOp \nimplements AST { ... } class BinOpPlus implements IBinOp { public static final BinOpPlus ONLY; } ... \nclass Exception { String getMessage(); } Figure 1. Outline of Jam syntax package jam.parser; import jam.ast.*; \nclass Parser { Parser() { ... } AST parse(String url) throws ParseException { ... } } class ParseException \nimplements jam.ast.Exception { String msg; ParseException(String msg) { ... } } Figure 2. Outline of \nJam parser import jam.ast.*; import jam.parser.*; class Interpreter { public Interpreter() { } public \nJamVal interp(String url) { Parser p = new Parser(); try { jam.ast.AST tree = p.parse(url); ... } catch \n(ParseException e) { ... } } } Figure 3. Outline of Jam interpreter up parser jam.botparser.Parser. In \nprinciple, we should be able to switch to this new parser by changing the import statementin Figure3to \nimport jam.botparser.*. How\u00adever, there is no guarantee this alternative parser provides the same interfaces, \nmuch less a similar set of classes, until we recompile the Interpreter. This violates our goal of components \nbeing independently compiled units of code.  2.4 Object Patterns We could avoid recompilation by de.ning \na common inter\u00adfaceIParser and then passing an IParser to the construc\u00adtor of the Interpreter, as shown \nin Figure 4 and 5. In essence, this approach is an idiom for manually representing components as objects. \nOn a limited basis, this idiom can enable a Java class to accept minor changes in its imports without \nmodi.cations to its source code. But as a scheme package jam; import jam.ast.*; interface IParser { \nAST parse(String url) throws ParseException { ... } } Figure 4. Jam IParser interface import jam.ast.*; \nimport jam.parser.*; class Interpreter { IParser p; public Interpreter(IParser p) { this.p = p;} public \nJamVal interp(String url) { try { jam.ast.AST tree = p.parse(url); ... } catch (ParseException e) { \n... } } } Figure 5. Jam Interpreter using IParser for systematically eliminatingexplicit dependencies,itis \nun\u00adworkable. Since with this approach, components are objects, component linking only occurs during program \nexecution whena class s imports (represented as objects) are passed as arguments to methods in the class \ns client interface. In real\u00adistic applications, a class may import dozens of classes, pro\u00adducing method \nsignatures with dozens of parameters, which mustbe modi.ed whena component s dependencystructure changes. \nEven our pedagogic Interpreter class imports 75 classes. Furthermore, there is no mechanism in Java to \npreventthe introductionof hidden dependencies(explicitex\u00adternal class references)inacomponent class whichmayonly \nsurface when a client uses a new component con.guration. Similarly,since this idiom represents components \nas objects, these components include independent state; it is easy to cre\u00adate multiple copies of the \nsame component.7 2.5 JavaBeans To provide more effective encapsulation of code units, the Java software \ncommunity has developed the concept of JavaBeans. JavaBeans is an API that de.nes a wiring standard for \nassembling software components in Java. A Java bean is simply a regular Java class adhering to certain \ninterface and coding conventions. For example, all beans must include a public 0-ary constructor and \nsupport persistence (serialization) so that the state of any bean can be saved and later reloaded. The \nclasses Parser and Interpreter referred in Figures2and3 can be converted into JavaBeans simply by making \neach class implement 7The singleton pattern could be used to ensure a single instance for com\u00adponents \nwithout imports. However, more complex bookkeeping would be needed for modules with imports. the interface \njava.io.Serializable. An actual bean is representedby an instanceofaJava bean class. While Java beans \ncan be deployed independently of other beans, they are not independent units of compiled code. A Java \nbean references other classes and types using the Java package system just like any other class. Moreover, \nbeans have independent state since they are conventional Java objects. 3. Architecture of CGEN CGEN is \na .rst-class formulation of Generic Java derived from NEXTGEN, a backward compatible extension of Java \n5.0 supporting run-time generic types. The thesis underlying the design of CGEN is that Java components \nhave a natural formulationas collectionsof generic classes witha common setoftype parameters.Allexternal \nreferences withina com\u00adponent class can be made manifest by expressing them as type parameters to the \nclass that are instantiated when the component is linked. Hence, component linking can be re\u00adduced to \nthe (type) application of generic classes to class arguments. Of course, an actual component system must \nin\u00adclude some new syntactic machinery for: de.ning components and their imported component pa\u00adrameters \n(dependencies);  declaring the functionality (expressed at the level of member type declarations) imported \nand exported by components;  linking components together; and  checking that types of linked components \nmatch.  Fortunately, a .rst-class generic type system for classes (in\u00adcludinghygienic mixins) provides \nthe critical parts for as\u00adsembling this machinery. In CGEN, we parameterize com\u00adponentsbyother components(collectionsof \nclasses) instead of individual classes,but in the underlying compiled code, we can reduce component parameterization \nto class parame\u00adterization. In CGEN, components are called modules rather than components because the \nname Component is extensively used in the Java GUI libraries. CGEN modules generalize Java packages.A \nmodule isabundleof classes witha name quali.er (pre.x) just like a package, but with a critically important \ndifference. A module uses signatures to specify the functionality of the modules that it imports and \nthe func\u00adtionality that it exports to other modules. More succinctly, signatures provide the crucial \nmachinery to support separate compilationof modulesinCG EN. In CGEN, modules and signatures have second-class \nsta\u00adtus; theycannot be instantiated at runtime, used as arguments to methods, or used in any object-passing \nprotocol. Signa\u00adtures are annotations which are used exclusively during the compilation process. Modules \nexist at runtime only in the restricted sense that the members of the module are conven\u00adtional Javaclasses \nand interfaces that are dynamically loaded at runtime. This restriction on modules and signatures sim\u00adpli.es \nthe semantics and implementation of CGEN, while providing suf.cient expressiveness to support a rich \ncompo\u00adnent system. Besides modules and signatures, CG EN introduces one other constructtoNEXTGEN,the \nnotionof binding an iden\u00adti.ertoamodule instantiation.The bind construct is used to build an executable \nmodule de.nition with no dependencies (imports). In addition, it provides concise names for module instantiations \nand a simple mechanism for linking mutually recursive modules. 3.1 Signatures Asignature is a template \nspecifying the classes (and inter\u00adfaces) in a module and their members in prototype form. This template \nconstrains the shape of a matching module. The syntax of a signature de.nition has the form: signature \nS<V implements E,..., V implements E> [extends E, ..., E]; sigMember* where Sis a fully-quali.ed name \nfor the signature (just like a package declaration in conventional Java); each V is an identi.er denoting \na module parameter (signature import); each E is a signature instantiation; and each sigMember is either \nan interface or class prototype, a bind statement, or an import statement. The E in each implements clause \nbounds the preceding parameter. The list of Es following the extends clause speci.es a set of signatures \nfrom which S inherits, just as Java interfaces inherit from other interfaces. Import statements are used \nto access legacypackages, e.g., classes in java.io. Asignature instantiation de.nes a ground (fully instanti\u00adated) \nsignature by linking the import parameters of a signa\u00adture with appropriate modules.Asignature instantiation \nhas exactly the same syntactic form as a generic type instantia\u00adtion: sName<mExpr, ..., mExpr> where \nsName is a fully-quali.ed signature name and each mExpr is eithera module instantiation or animported \nmod\u00adule parameter (which is bound to a module instantiation). The non-parametric signature S<> is abbreviated \nsimply as S. Amodule instantiation has the same syntactic form as a signature instantiation: mName<mExpr, \n..., mExpr> where mName is a fully-quali.ed module name and each mExpr is eithera module instantiation \nor animported mod\u00adule parameter (which is bound to a module instantiation). The non-parametric module \nM<> is abbreviated simply as M. Note, parameters for signature and moduleinstantiations are strictly \n.rst order (ground); hence a module or signature parameter can never be applied to arguments. The intuitive \nmeaning of a module instantiation is liter\u00adally the set of classes in the instantiated module. It is \nequiv\u00ad signature SSyntax; interface JamVal { ... } interface AST { ... } interface IBinOp implements \nAST { ... } class BinOpPlus implements IBinOp { public static final BinOpPlus ONLY; } ... class Exception \n{ String getMessage(); } Figure 6. Signature for Jam syntax signature SParser<A implements SSyntax>; \nclass Parser { Parser(); A.AST parse(String url) throws ParseException; } class ParseException extends \nA.Exception { String msg; ParseException(String msg); } Figure 7. Signature for Jam parser alent to a \npackage in ordinary Java. Hence, there is no such thingas multiple instances(or copies)ofa particular \nmodule instantiation. Interface prototypeslooklike ordinaryJava interfacesex\u00adcept that theymay include \nreferences to imported modules (module parameters). Members of imported modules can be extractedusingthefamiliarJavadot( \n. ) notionfor member selection. Class prototypes look like ordinary Java classes, except that theymay \nreference module parameters and only provide method signatures not actual implementations. In contrast \nto interface prototypes, class prototypes can include constructor prototypes, dynamic and static .elds, \ndynamic and static method prototypes, and even inner interface and class prototypesas members.Allofthe \nmembersofasigna\u00adture have public visibility. The visibility of the members of class prototypes can either \nbe public or protected. public visibility is the default. Figures 6 and 7 show the module signatures \nSSyntax and SParser used for a component-based parser for the Jam language. The signature SParser imports \na module A implementing the signature SSyntax.  3.2 Modules Amodule is a distinct name space that contains \na collection of classes and interfaces and stipulates the signatures imple\u00admented by the module. More \nprecisely, a module de.nition has the form: module M<V implements E, ..., V implements E> implements \nS, ..., S; moduleMember* module JamParser<A implements SSyntax> implements SParser<A>; public class \nParser extends Object { Parser() { ... } A.AST parse(String url) throws ParseException { ... } String[] \ngetLog() { ... } } public class ParseException extends A.Exception { String msg; ParseException(String \nmsg) { this.msg = msg; } } Figure 8. JamParser Module De.nition where Mis a fully-quali.ed name for \nthe module (just like a package declaration in conventional Java); each V is an identi.er serving as \na module parameter (module import); each Eis a signature instantiation bounding the correspond\u00ading parameter; \neach S is a signature instantiation bounding the module; and each moduleMember is either a class or in\u00adterface \nde.nition, an import statement, or a bind statement. Figure8 showsa module JamParser that implements \nthe signature SParser. The subtyping relation between modules and signatures is nominal: a module M implements \na signature S only if M explicitly declares that it implements S. Hence, CGEN modules are nominally subtyped \njust like Java classes. 3.2.1 Module Type Checking As discussed earlier, a signature declares the visible \nshape (functionality) of a module. In Java terminology, a module implements a signature just as a Java \nclass implements an interface. More precisely, a module M implements a signa\u00adture S if and only if M \ncontains a matching class or inter\u00adfaceC for each class or interface prototype C in S.Aclass C matches \na class prototype C iff C has exactly the same name as C and has members matching the prototype mem\u00adbers \ndeclared in C.8 For every member m of the class pro\u00adtoype C, the matching class C must contain a member \nm with the same name as m, the same type signature, and the same attributes(public/protected, static/dynamic, \nand final/mutable).9 Since a class prototype may be a member of a class prototype, the matching process \nis recursive. The modules and its classes maycontain extra members. CGENallows the parent type of class \nC declared in mod\u00adule M to be a subtype of the declared parent type of the class prototype C in S. This \nrelaxation of the matching relation for modules against signatures gives developers more freedom when \nrevising a module that implements a given signature. The implications of this design decision are discussed \nfur\u00adther in Section 4.2. The contents of a module are type-checked following Java 5.0 type checking rules \nwhere module imports (the Vs 8In this context and several others, we use the term class to refer to either \na Java class or interface 9Several of these issues are moot for interfaces. bind SSyntax JSyntax = JamSyntax; \nbind SParser<JSyntax> JParser = JamParser<JSyntax>; public class Interpreter { public Interpeter() { \n} public JSyntax.JamVal interp(String url) { JParser.Parser parser = new JParser.Parser(url); try { parser.parse(...); \n} catch (JParser.ParseException e) { ... } } } Figure 9. Module Instantiation in the syntax rule for \nmodules), are treated like imported packages with types synonymous with their bounding signa\u00adtures and \nclass and interface prototypes within signatures are treated exactly like ordinary class and interface \nde.nitions within packages.Then the class and interface de.nitions in the module mustbe checkedagainstthe \nboundsprovidedby theexport signatures using the structuralmatching described earlier.  3.3 Bindings \nAn executable program module is a module de.nition with no dependencies (imports). Program modules typically \nlink other modules together and usually include program speci.c code not intended for reuse. To facilitate \nthe construction of program modules, CGEN includes a construct bind that bindsan identi.ertoa(linked) \nmoduleinstantiation.Amod\u00adule binding has the form: bind sigExpr name = mExpr; where sigExpr is a fully-quali.ed \nsignature instantiation, name is an identi.er, and mExpr is either an imported mod\u00adule parameter (which \nis bound to a module) or a module instantiation. The sigExpr can be used to associate a weaker signature \nwith name than the export signature of mExpr. In this way, the programmer can expose only the requisite \npart ofa module witha largerexport signature. Figure9showsa client that links and uses the module JamParser. \nModule bindings are convenient because they provide short names for module instantiations which might \nother\u00adwise be unwieldy. They also play an essential role in the construction of program modules with \nrecursive links, e.g. module A imports module B and vice-versa. 4. Language Design Issues In theevolutionofCGEN, \nthe principal technical complica\u00adtions we encountered were:(i)accidental overriding caused by inheritance \nacross component boundaries, and(ii)cyclic class hierarchies causedby recursive or mutually-dependent \nmodules. Throughout the development of CG EN, we have endeav\u00adored to adhere the safe-instantiation principle \n[3]. Our adaptation of this principle is the following: module JamDebugParser<A implements SSyntax, \nB implements SParser<A>> implements SParser<A>; public class Log { ... } public class Parser extends \nB.Parser { Parser() { ... } A.AST parse(String url) { ... } Log getLog() { ... } } public class ParseException \nextends B.ParseException { String msg; ParseException(String msg) { this.msg = msg; } } Figure 10. Inheritance \nAcross Component Boundaries Instantiating a parametric construct with types that meet the declared constraints \non the parameters should not cause an error. But as our design progressed, we discovered that we had \nto relax this rule to provide the level of expressiveness that we wanted in a component system given \nour experience as softwaredevelopers.Wehadto balancethe bene.tsofearly error detection against the the \nequally important goal of pro\u00adviding a component framework that supports wide latitude in refactoring \ncomponent implementations while retaining compatibility with the former signatures (API s). In the following \nsubsections, we explore the the two ma\u00adjor design complications that we encountered in developing CGEN \nand re.ect on the tradeoffs among the various design possibilities. 4.1 Accidental Overriding While the \nuse of imports (module parameters) in CGEN super.cially resembles the use of import statements in Java \npackages, they are semantically very different. In contrast to packages, references to imported modules \nare not re\u00adsolved and bound when a module is compiled. Furthermore, type checking during compilation \nin CGEN is performed against the public members provided by the relevant signa\u00adtures. Consequently, subtle \ncomplications can arise when components are linked (instantiated) that are not an issue in conventional \nJava. Inheritance across component boundaries de.nes a mixin class that can produce unexpected behavior. \nConsider the following module de.nition: module M<I1 implements S1> implements S; class C extends I1.D \n{ ... } The module import I1 is statically constrained by the bound S1. If the class C declared in M \nextends class D pro\u00advidedin theimport I1, there can be unintended interference between the two classes \nfor anymember m not declared in the import bound S1.D.Forexample, consider the de.nition of module JamDebugParser \nin Figure 10, that provides a Parser witha more sophisticated loggingfacility.Inthein\u00adstantiated module: \nbind SParser<JamSyntax> JParser2 = JamDebugParser<JamSyntax,JamParser<JamSyntax>> the de.nition of getLog() \nin JamDebugParser.Parser accidentally overrides the method de.ned in its super class JamParser.Parser, \nthus breaking its super class. This accidental overriding can be detected only during module linking \nwhen a module instantiation M1 is linked against S1. Languages supporting separate compilation, such \nas Java and C#, cannot detect all such accidental overrides during compilation because the argument classes \n(provided by imported modules) and mixin classes (de.ned in modules) can be compiled in isolation from \none another, and their only common interface, the type bounds on the argument classes (speci.ed in signatures), \ndoes not mention what methods must be excluded to avoid accidental method overriding. The issue of accidental \noverriding of methods by mixin instantiations has been extensively studied in the context of Generic \nJava in [1]. In this work, accidental overriding in .rst-class Generic Java is systematically avoided \nby using a hygienic semantics toavoid accidental name collisions, con\u00adsisting of a method renaming and \nforwarding scheme that the class loader applies to every class as it is loaded by the JVM. Since CGEN \nmixins, which cross component bound\u00adaries, are more restrictive than class-level mixins,CGENcan employ \nexactly the same hygiene solution to this accidental overriding issue.Every mixin constructioninaCGEN \nmod\u00adule is translated to a mixin class instantiation that is imple\u00admented using the techniques described \nfor MIXGEN in [1]. In essence, thiswork shows that mixinhygieneisa clean, comprehensive solution to the \naccidental overriding prob\u00adlem. It supports sound local type checking that is consistent with the incremental \nclass compilation and loading model in Java conforming with the safe-instantiation principle. CGEN supports \nexactly the same notion of safe instan\u00adtiation with regard to accidental overrides as MIXGEN be\u00adcause \nit uses static signatures to bound module parameters and type-check their usage within modules.  4.2 \nCyclic Class Hierarchies Generic Java forces class hierarchies to form a DAG (di\u00adrect acyclic graph) \nunder the subtyping relation. All generic types are erased to their corresponding base types and these \nbase types are then used to con.rm this hierarchy. In the presence of modules we must enforce the same \nconstraint. However, the local analysis of the type hierarchy performed during the compilation of an \nindividual module is less precise. The collection of classes is not completely known during the compilation \nof an individual module. Complete cycle detection in the class hierarchy must be deferred until the evaluation \nof bind declarations (module linking) in the third-party client. The nominal typing of CGEN provides \ntransparent support for recursion in signatures and modules. A sig\u00adnature S<A> can refer to itself by \nsimply referencing its type-instantiated identi.er. signature S<A implements S<A>>; In CGEN, the presence \nof second-class modules and sig\u00adnatures enables a single recursive module or a collection of mutually \nrecursive(or dependent) modulesto createacyclic hierarchy. The following examples show some of the poten\u00adtial \ncomplications that can arise. Example 1. Aclass prototype extending an imported class in a recur\u00adsive \nmodule can extend itself. signature S<A implements S<A>>; class C extends A.C {}; Inthisexample,the moduleimport \nA is recursively bound to the type of the enclosing module instantiation S<A>.A module supporting S<A> \nsuch as: module M<A implements S<A>> implements S<A>; class C extends A.C { ... }; can be instantiated \nusing the following bind: bind S<X> X = M<X>; While the use of the variable X in both the lefthand side \nof its signature bound and the right hand side declaring its module instantiation may seem peculiar, \nthis pattern de.nes a module recursively just like a recursive de.nition of a function. The class C in \nthe module X has X.C (itself) as its superclass, creating an illegal cyclic class hierarchy. The cycle \nin this example can be detected solely by analyzing the de.nition of signature S< ... >. The sig\u00adnature \nde.nition states that given module instantiation A implementing (subtyping) S<A>, then S<A>.C extends \n(properly subtypes) A.C. But the assumption A implements (subtypes) S<A> implies that A.C implements \n(subtypes) S<A>.C. Hence A.C equals S<A>.C by the anti-symmetry of subtyping.Yet S<A>.C extends (properly \nsubtypes) A.C so the two types cannot be equal. So the signature de.nition in Example1is illegal preventing \nM<...> and X from being de.ned inCG EN. Example 2. Wecan revise Example1 to generateavalid de.nition \nfor S<...> by deferring the subtyping on S<A>.C until we declare M<...> as discussed in Section 3.2.1. \nIn this way, a cyclic class hierarchy can be concealed by its signature. The signature in Example1 can \nbe perturbed as follows: signature S<A implements S<A>>; class C {} which conceals the cyclic hierarchyde.ned \nby the module M<A>: module M<A implements S<A>> implements S<A>; class C extends A.C { ... } As before, \nwe can instantiate M using the following bind: bind S<X> X = M<X>; to create an illegal cycle. In this \nexample, the signature S<...> is valid because class S<A>.C extends Object. The class A.C implements \n(subtypes) S<A>.C byassumption,but S<A>.C does not necessarily subtype A.C. In processing Example 2, \nthe CGEN compiler accepts the de.nition of the signature S<...> and the de.nition of M<...>,but it rejects \nthe bind operation de.ning X using essentially the same analysis used to reject S<...> in Ex\u00adample 1. \nExample 3. In this example, we demonstrate that the sig\u00adnature and module de.ned in Example2 can be augmented \nby another module and a different bind to form a valid pro\u00adgram. This example consists of the following \nprogram text: signature S<A implements S<A>>; class C {} module M<A implements S<A>> implements S<A>; \nclass C extends A.C { ... } module N<A implements S<A>> implements S<A>; class C { ... } bind S<Y> Y \n= N<Y>; bind S<Y> X = M<Y>; The module instantiation Y = N<Y> implements S<Y> without creating a cycle. \nThen Y can be passed as an argument module M without creating a cycle. The preceding three examples were \nobviously chosen for simplicity. In general, the subclassing hierarchyintroduced by .exible signature \nmatching can be arbitrarily deep. Sim\u00adilarly, cycles in the type hierarchy can involve an arbitrarily \nlong chain of signatures or modules In the compilation of an individual module, CGEN can enforce the \nDAG constraint on the type hierarchies deter\u00admined by the available code. In Example 1, the type hierar\u00adchyfor \nthe signature de.nition S<...> creates a cycle, en\u00adablingtheCGENcompilerto detectthe errorintheexample \nimmediately. In Example 2, the cycle in the type hierarchy does not appear untilthe bind operation de.nes \nthe module instantiation X. In Example 3, the bind operation from Ex\u00adample2is dropped and replacedbya \nsecond module def\u00adinition and two subsequent bind operations. This change creates a valid CGEN program \nwith no cycles in the type hierarchy. These three examples clearly demonstrate that cycles in the type \nhierarchy can sometimes be detected by analyzing signaturesbut in general case they cannot be detected \nuntil modules are instantiated in bind statements. Note that this process does not fully comply with \nthe safe instantiation principle identi.ed in [3]. The type arguments in a bind statement can satisfy \ntheir bounds (as in Example 2) yet the generated program may still be illegal because the bind statements \ncreate a cycle in the type hierarchy. As an alternative, CGEN could prohibit modules from declaring \nclasses with a more speci.c parent type than that explicitly declared in its export signature. This restriction \nwould reduce detecting cyclic type hierarchies to check\u00ading that prototypes in signatures form a DAG \na process that can be done statically when the importing module is compiled since all relevant signatures \nare available during its compilation. While this restriction would make CGEN conform to the letter of \nthe safe-instantiation principle, we believeitwould impose unacceptable restrictionson module developers. \nOur relaxed constraints provide developers with far more .exibility in code development and refactoring \nwhile still supportingthe detectionofcyclictype hierarchies during compilation. It simply postpones detection \nof some cyclic type hierarchies until module instantiation because thecycleis createdby theparticular \ninstantiation. 5. Core CGEN In order to identify and resolve the subtle technical issues in the CGEN \ntype system, we have distilled the component framework into a small, core language called Core CGEN, \nCCG for short. Indeed, several complications described in Section4 were uncovered duringa formal analysisof \nCom\u00adponentNEXTGEN. The design of Core CGEN is based on Featherweight GJ (FGJ)[14] and incorporates ideas \nfrom Core MixGen [1]. In the remainder of this paper, we will refer to these two languages asFGJ, andCMG, \nrespectively.CCG excludes signatures for the sake of simplicity; degenerate modules are used in place \nof signatures. This simpli.cation follows the precedent established in Featherweight Java, FGJ, and CMG \nwhich exclude interfaces and rely on degenerate classes in their stead. CCG augments FGJ with the essential \ninfrastructure to supportCGEN-style components: module de.nitions. These provide the crucial framework \ntobundle classes as components.  bind de.nitions. These provide the ability to link (in\u00adstantiate) modules \nwith their dependencies.For simplic\u00adity, CCG programs de.ne a single set of bind declara\u00adtions.  Multiple \nconstructors in class de.nitions. In FGJ each class de.nes a default constructor that takes an initial \nvalue for each .eld as an argument. In CCG, we relax this restriction andpermit multiple constructors \nwith ar\u00adbitrary signatures. This allows(i)classes to satisfy the constraintsrequiredbymultiple bounding \nsignatures, and (ii)different module implementations to provide differ\u00adent collections of .elds.  The \nAppendix outlines the syntax, type system, small\u00adstep semantics, and proof of type soundness for CCG; \nthe details of the proof are available in a technical report [29]. The semantics and proof are similar \nto those for MixGen in [2], except for the following: All class types in CCG are pre.xed by their enclosing \nmodule instantiation. This convention is analogous to using fully-quali.ed class names including a package \npre.x in Java.  CCGmust check that class hierarchiesformaDAGwhen modules are linked together with respect \nto the declared bind declarations.  The small-step semantics for CCG carries a runtime bound environment, \nmapping type variables to their bounds, to support bind declarations.  5.1 Lessons Learned from Core \nCGEN We did not understand the tradeoff between .exibility in matching modules against signatures and \ndeferred detection of cycles in the type hierarchyuntil we worked through the semanticsofCCGandtheproofoftype \nsoundness.In con\u00adstructing the proof, we realized that cycles could be created by the particular structure \nof the module instantiations in a block of bind statements. ThedevelopmentofCCGalso provided us witha \nmodel for building the CGEN type-checker. We built a prototype CGEN type checker before developingCCG,but \nit did not handle recursive modules properly. We also learned thatextending Java generics and compo\u00adnents \nto support passing abstracted (higher-order) modules is a major technical challenge. It is not clear \nhow to gen\u00aderalize our formalsemantics and soundness proof to handle this extension. The class table \nCT that we trivially construct (see the Appendix) forCCG is not necessarily .nite when abstracted modules \ncan be passed as arguments. 6. Related Work Several past and ongoing research projects at other institu\u00adtions \nhave focused on developing some notion of a compo\u00adnent or module system forJava,but noneofthem are based \non .rst-class generics and dynamic loading to link compo\u00adnents. JAVAMOD [6] is a statically typed extension \nto Java that supports mixin modules. Mixin modules are a generaliza\u00adtion of mixin classes as introduced \nin [7]. These mixins are not hygienic,but instead rely on anexplicithiding operator. In contrast to CGEN \nwhere modules are nominally typed against reusable signatures specifying module imports and exports, \nmodulesinJAVAMODeach de.ne an interface con\u00adtaininga listof importedandexported classes. Module link\u00ading, \ncalled merging, requires a exact structural match be\u00adtween the import and export interfaces of the relevant \nmod\u00adules. Inconsistencies between interfaces can be mitigated 10 by hiding and renaming operations,but \nthe useof structural matching of signatures doesn tmeldseamlessly in the nom\u00adinally typing of Java or \nother statically typed object-oriented languages. SMARTJAVAMOD [5] is a re.nement of JAVAMOD that relies \non type inference, instead of statically typed inter\u00adfaces, to determine the principal typing of a module. \nThe type inference process infers type constraints for free type parameters in the module. Uninstantiated \nmodules are com\u00adpiled into polymorphic bytecode similar to NEXTGEN tem\u00adplates. Inferred type constraints \nare checked when modules are combined. Accidentaloverriding canbe detectedin this process and .agged \nas an error. In essence,SMARTJAVA-MOD relies on free variables and type inference to simulate .rst-class \ngenerics at the cost of hiding the parameters of a module (the free variables) and their type bounds \n(which are inferred).We don t see suchafacility as consistent with the spirit of explicit static typing \nin Java. While the use of untyped free variables in modules supports .exible usage (except in the presence \nof accidental overriding), it prevents module developers from verifying export and import speci\u00ad.cations \nwhen modules are developed independently of one another. Jiazzi [16] is a component de.nition and linking \nlan\u00adguage for Java. Jiazzi uses a stub generator and a static linker that allow components to be written \nin the unex\u00adtendedJava language. Jiazzi s linkingfacilities use the open class pattern a combination \nof mixins and upside-down mixins to support the modular addition of new features to a set of variant \nclasses.For each linked component, Jiazzi generates a .xed-package, a form of .xed-point represent\u00ading \nthe linked classes. As a result, the semantics of Jiazzi components even though they are written in ordinary \nJava is more complex than their familiar Java syntax suggests. Usingaseparate linking language like Jiazzi \nsigni.cantly complicates the development of component code. Before a component .le can be compiled, the \ncomponent s signature must be declared in a Jiazzi .sig .le, which is translated by the Jiazzi stub generator \nto produce the stub class .les required to support the compilation of the component .le by the standard \njavac compiler. The linking of compiled components is speci.ed by a Jiazzi .unit .le which is fed to \nthe Jiazzi linker along with the .sig .les and class .les for the compiled components. Scala [23, 24] \nis a multi-paradigm programming lan\u00adguage implemented on top of the Java Virtual Machine. Scala has a \nmore concise syntax than Java and supports a similar nominal type system including a richer form of interfaces \nthat includes executable code (but no .elds). 10 Since each module declares its own interfaces, the requirement \nfor an exact structural matching placesa heavyburden on component linkers to ensure the interfaces match. \nScala modules are singleton classes that do not specify a static signature, which prevents them from \ncreating indepen\u00addent state. And Scala does not support .rst-class generics, preventing modules from \nbeing parameterized by type.11 Consequently, Scala components rely on hard-coded refer\u00adences to other \nmodules and classes, making it more dif.cult to develop modules independently of one another. Fortress \n[19] is a new programming language developed by Sun Microsystems Research targeting high performance \ncomputing (HPC), incorporating bothfunctional and object\u00adoriented programming methodologies. Components \nand APIs in Fortress are designed in much the same spirit as modules and signatures in CG EN. The principal \ndifference is thatFortress relies on static linking instead of .rst-class genericity to instantiate program \ncomponents. Instead of importing a list of modules, Fortress components identify an unordered set of \nAPIs (signatures) that they import. As a result, components cannot link against multiple imports that \nprovide the same API. In contrast to the pure dynamic linking of bind declarations in the CG EN, Fortress \nmain\u00adtains a persistent database of components and requires static linking of components.Fortress uses \nan interactive shell to compile and link components. The CGEN component framework has also been in\u00ad.uenced \nby the design of module systems for functional languages, most notably ML. The fundamental difference \nbetween ML modules (in all the various formulations) and CGENmodulesisthatMLmodulesrelyon structuraltyping, \nwhile CGEN relies on nominal typing. This distinction is important because it means that CGEN seamlessly \nsupports mutual recursion among modules, a common practice in software engineering. Supporting mutual \nrecursion among modules has proven to be a challenging technicalproblems in the context of structural \nsubtyping [26, 10, 11]. Neither of the two widely used dialects of ML Standard ML [21] and OCaml [15] \nsupports recursive modules. One issue that has arisen in putative recursive extensions to theMLmodule \nsystemis the double vision problem[11], where a single type can be referenced using distinct names with \ndiffering visible types. In this scenario, the type checker can reject valid programs because the different \ntypes can\u00adnot be matched together. The same situation cannot arise in CGEN or Java generics because the \nnominal type system provides unique (canonical) names for all types. Moreover, imported class typesinCGEN \ncan reference classes that are explicitly declared in the same context by using mutually dependent signatures/modules \nas discussed in Section 4.2. Apotential solution to the ML recursive module problem is the module system \nproposed in [25], which is based on the same module architecture for PLTScheme discussed in [12]. In \nkeeping with the ML programming model, it relies on 11With erasure-based generics, the meaningofa classis \nindependentof its type instantiation (which has no impact on the executable code). Hence, a component \ncannotbe linked with its importsby type application. static, structural typing. The current design does \nnot include signatures and therefore cannot re-use import and export speci.cations of units. Recently, \ntwo Java JSR s concerning components have been submitted the Java CommunityProcess, namely JSR\u00ad277 and \nJSR-294. Java Speci.cation Request 277: Java Module System[18] addresses the extra-linguistic concerns \nof module deployment, including versioning and distri\u00adbution. It is orthogonal to CGEN and could be integrated \nwith our design. The public information on Java Speci.\u00adcation Request 294: Improved Modularity Support \nin the Java Programming Language[20] appears closer in focus to CGEN, but the available public speci.cations \nare too fragmentary for us to compare it in detail with CG EN other than to say it is less ambitious \nand appears only to support information hiding akin to CGEN signatures; it does not support component \nassembly or replacement as discussed by Szyperski. References [1] E. Allen,J.Bannet, andR. Cartwright. \nFirst-class genericity for Java. In OOPSLA, 2003. [2] E. Allen, J. Bannet, and R. Cartwright. Mixins \nin Generic Java are sound. Technical report, Rice University, 2003. [3] E. Allen and R. Cartwright. Safe \ninstantiation in Generic Java. In PPPJ 04, pages 61 66, 2004. Available at http://www.cs.rice.edu/CS/PLT/Publications. \n[4] E. Allen, R. Cartwright, and B. Stoler. Ef.cient implemen\u00adtation of run-time generic types for Java. \nIn IFIP WG2.1 Working Conference on Generic Programming, 2002. [5] D. Ancona, G. Lagorio, and E. Zucca. \nSmart modules for Java-like languages. In 7th Intl.Workshop onFormal Techniques forJava-likePrograms, \n2005. [6] D. Ancona and E. Zucca. True modules for java classes. In ECOOP, 2001. [7] G. Bracha. The Programming \nLanguage Jigsaw: Mixins, Modularity, and Multiple Inheritance. PhD thesis, University of Utah, 1992. \n[8]G.Bracha,M.Odersky,D. Stoutamire,andP.Wadler.Making the future safe for the past: Adding genericity \nto the Java programming language. In OOPSLA, 1998. [9] R. Cartwright and G. L. Steele, Jr. Compatible \ngenericity with run-time types for the Java programming language. In OOPSLA, 1998. [10]K.Crary,R.Harper,andS.Puri.Whatisa \nrecursivemodule? In PLDI, pages 50 63, NewYork, NY, USA, 1999.ACM Press. [11] D. Dreyer. Understanding \nand Evolving the ML Module System. PhD thesis, Carnegie Mellon University,2005. [12] M. Flatt and M.Felleisen. \nUnits: Cool modules for HOT languages. In SIGPLAN, pages 236 248, 1998. Syntax and SemanticsofJava, pages \n241 269, 1999. [14] A.Igarashi,B. Pierce, andP.Wadler. FeatherweightJava:A minimal core calculus for \nJava and GJ. In OOPSLA, 1999. [15] X. Leroy. The Objective Caml system: Documentation and user s manual., \n2004. http://caml.inria.fr/pub/ docs/manual-ocaml/. [16] S. McDirmid, M. Flatt, and W. Hsieh. Jiazzi: \nNew age components for oldfashionedJava. In OOPSLA, 2001. [17] S. Microsystems. JSR 14: Addinggeneric \ntypes to the Java Programming Language, 2001. [18] S. Microsystems. JSR 277: Java Module System, 2005. \n[19] S. Microsystems. TheFortress language speci.cation, Sept 2006. [20] S. Microsystems. JSR 294: Improved \nModularity Support in the Java Programming Language, 2006. [21] R. Milner, M.Tofte, and D. Macqueen. \nThe De.nition of StandardML. MIT Press, Cambridge, MA, USA,1997. [22] A. Myers, J. Bank, and B. Liskov. \nParameterized types for Java. In POPL, 1997. [23] M. Odersky. Programming in Scala, 2006. Draft. [24] \nM. Oderskyand M. Zenger. Scalable component abstractions. In OOPSLA, pages41 57,NewYork,NY, USA, 2005.ACM \nPress. [25] S. Owens and M. Flatt. From structures and functors to modules and units. In ICFP, volume \n41, pages 87 98, New York,NY, USA, 2006.ACM Press. [26] C.V. Russo. Recursive structures for standard \nML. In ICFP, pages 50 61,NewYork,NY, USA,2001.ACM Press. [27] J. Sasitorn and R. Cartwright. Ef.cient \n.rst-class generics on stock Java virtual machines. In SAC, 2006. [28] J. Sasitorn and R. Cartwright. \nDeriving compnents from genericity. In SAC, 2007. [29] J. Sasitorn and R. Cartwright. The soundness of \nCompo\u00adnent NextGen. Technical report, Rice University, 2007. http://www.cs.rice.edu/~javaplt/papers/. \n[30] C. Szyperski. Component Software. Addison-Wesley, 1998. [31] C. A. Szyperski. Import is not inheritance: \nWhy we need both: modules and classes. In O. L. Madsen, editor, ECOOP, volume 615, pages 19 32, Berlin, \nHeidelberg, NewYork, Tokyo, 1992. Springer-Verlag. [32] M. Viroli. Parametric polymorphism in Java: an \nef.cient implementation for parametric methods. In SAC, 2001. [33]M.ViroliandA. Natali. Parametric polymorphisminJava: \nan approach to translation based on re.ective features. ACM SIGPLAN Notices, 35(10):146 165, 2000. A. \nCore CGEN This Appendix outlines a semantics, type system, and proof  of type soundness for CCG; the \ndetails of the proof are available in a technical report[29]. [13] M. Flatt, S. Krishnamurthi, and M. \nFelleisen. Aprogram\u00admer s reduction semantics for classes and mixins. In Formal  Syntax: MD : := module \nD<X. N> . N{CL} CL : := class C<X . N> . N {T f; K M} K : := C(T x) {super(e);this.f = e.;} M : := <X \n. N> T m(T x) {return e;} e : := x | e.f | e.m<T>(e) | new N(e) | (N)e T : := X | N T : := X | N N : \n:= T.C<T> N : := D<T> BD : := bind NX = N; Table 1. CCGSyntax   A.1 Syntax The abstract syntaxofCCG, \nshowninTable1, consistsof module declarations(MD), class declarations(CL), construc\u00adtors declarations(K), \nmethod declarations(M), expressions (e), types(T), and bind declarations(BD). For the sake of brevity, \nextends is abbreviatedby .. Throughout all formal rules of the language, the following meta-variables \nare used over the following domains: d, e range over expressions.  K ranges over constructors.  m, \nM range over methods.  N, O, P range over fully-quali.ed class types  N, O, Prange over module types \n X, Y, Z range over naked class type variables.  X, Y, Zrange over naked module type variables.  R, \nS, T, U, V range over class types.  R, S, T, U, Vrange over module types.  x ranges over method parameter \nnames.  f ranges over .eld names.  C, D range over class names.  C, Drange over module names Following \nthe notation of FGJ, a meta-variable with a horizontal bar above it represents a (possibly empty) sequence \nof elements in the domain of that variable, and mayinclude an arbitrary separator character.Forexample, \nT denotes a sequence of types T0, ...Tn. As in CMG, we abuse this notationin different contexts.Forexample, \nT f; denotes T0 f0;...Tn fn;. Similiarly, the expression X . N represents X0 . N0, ...Xn . Nn. In CCG, \nsequences of classes, type variables, method names, and .eld names are required to contain no duplicates. \n Thesetoftypevariablesineach module includesan implicit variable thisMod which cannot appear as a type \nparameter anywhere in the module. The set of variables in each class includes an implicit variable this \nwhich cannot appear as a class name, .eld, or method parameter anywhere in the class. Type variable bounds \nmay reference other type parame\u00adters declaredin the same scope;in otherwords theymaybe mutually recursive.Every \nmodule de.nition declaresa super module using .. Every class de.nition declares a super class using .. \nCCG requires explicit polymorphism on all parametric method invocations.  A.2 Valid Programs A CCG program \nconsists of a .xed module table, a .xed bind table and an expression, denoted (MT, BT, e).Amod\u00adule table \nMT is a mapping from module names Dto module declarations MD. A bind table BT is a mapping from type \nvariables Xto bind declarations BD. Avalid module table MT must satisfy the following con\u00adstraints:(i)for \neveryD in MT, MT(D)= module D...,(ii), Mod ./dom(MT),(iii)every module appearing in MT is in dom(MT), \nand(iv)the subtyping relation <: induced by MT is antisymmetric and forms a tree rooted at Mod. The root \nmodule Mod is modeled without a corresponding mod\u00adule de.nitionin the moduletable and contains no classes. \nA valid bind table BT must satisfy the following con\u00adstraints:(i)for everyX in BT, BT(X)= bind N0 X = \nN; and(ii)every typevariableXappearing in BT is in dom(BT). Given the set BT of binds bind N0 X = N, \nthe initial bound environment, mapping module typevariablesto their upper bounds is de.ned as .BT = X. \nN. The boundenvironment . is discussed below in Section A.4. Program execution consists of evaluating \ne in the context of MT and the initial bound environment .BT for BT.  A.3 Valid Module Binds To determine \nif a set of binds BT can be safely linked to produce an acyclic set of classes12, an implicit class table \nCT, de.ning a mapping from fully-quali.ed class names to de.nitions, is generated by evaluating MT in \nthe presence of BT.For each bind declaration bind N0 X = D<T>; in BT where MT(D)= module D<Y. N> . N{CL} \nand each class C<X . N> . N {...}. CL: CT(D<T>.C)=[Y .. bound.BT (T)] class D<Y>.C<X . N> . N {...}. \nThe substitution above replaces module type parameters with their bind-ed instantiations so that the \nparent type of a class in an instantiated module can be looked up in CT. The domain of CT is .nite; It \nsimply consists of the set of 12 Since mixin classes in MIXGEN syntactically encoded their parent in\u00adstantiations, \nformalizing properties on acyclic type hierarchies is relatively easy.CCG, just likeFGJ, does not usea \nsyntactic encoding. . . S <: T . . T <: U . . T <: T[SCRe.ex] [SCTrans] . . S <: U . . S<: T . . T<: \nU . . T<: T[SMRe.ex] [SMTrans] . . S<: U . . X <: .(X)[SCBound] . . X<: .(X)[SMBound] bound.(T)= D<T> \nMT(D)= module D<Y. N> . N{CL} class C<X . N> . N {...}. CL [SClass] . . T.C<S> <:[Y .. T][X .. S]N MT \n(D)= module D<Y. N> . N{...} [SModule] . . D<T> <:[Y .. T]N bound.(X) = .(X) bound.(V.C<T>)= bound.(V).C<T> \nbound.(N)= N Table 2. Subtyping andType Bounds classesde.nedin the module instantiationsin the right \nhand sides of bind declarations.13 Avalid class table must satisfy the following constriants: (i)every \nclass name appearing in CT is in dom(CT) and (ii)the set of class de.nitions must form a tree rooted \nat 14 Object. The class Object is modeled as a top-level construct, located outside any module. Object \ncontains no .elds or methods and it acts as if it contains a special, zero-ary con\u00adstructor. A.4 Type \nChecking The typing rules for expressions, method declarations, con\u00adstructor declarations, class declarations, \nand module declara\u00adtionsareshowninTable2.ThetypingrulesinCCGincludes two environments: Abound environment. \nmapping type variables to their upper bounds.Syntactically,thisis writtenas X . N . X. N. The boundofa \ntypevariableisalwaysa non-variable. The bound of a non-variable module type N is N, and a non-variable \nclass type V.C<T> is the class type C<T> pre.xedby the boundof the enclosing module V.  Atype environmentG \nmapping programvariablesto their static types. Syntactically, these mappings have the form  x : T CCG \ncontains two disjoint sets of types: module types and class types. Class types are always quali.ed with \ntheir enclosing module instantiation. Class type variables are 13 Modules do not contain anymodule type \napplications because they can only reference imported modules which are fully-quali.ed. 14 The special \nclass object is not in CT, because Object is akeyword. bound by class types and module type variables \nare bound by module types. Figure2shows the rules for the subtyping relation <: . Subtyping inCCG is \nre.exive and transitive. Classes and modules are subtypes of the instantiations of their respective parent \ntypes.  A.5 Well-formed Types and Declarations The rulesfor well-formed constructs appearinTable3. Class \nand module instantiations are well-formed in the environ\u00adment . if allinstantiations of type parameters \nare subtypes of their bounds in ..Type variables are well-formed if they are present in .. A method m \nis well-formed with respect to its enclos\u00ading module D and class C if its constituent types are well\u00adformed; \nthe type of the body in G isasubtypeofthe declared return type; and m is a valid override of anymethod \nof the same name in the static type of parent class for C. An over\u00adriding method de.nition is valid if \nit preserves the signature in the parent. This notionisformalizedin section A.6. CCGallows multiple constructors \nin a class. As in FGJ, there is no null value in the language, so all constructors are required to assign \nvalues to all .elds. In order to avoid pathologies such as the assignment of a .eld to the (yet to be \ninitialized) value of another .eld, all expressions in a constructor are typed in an environment binding \nonly the constructor parameters (not the enclosing class .elds, this, or thisMod). A class de.nition \nCL is well-formed in the context of the enclosing module if the constituent elements are well\u00adformed; \nnone of the .elds known statically to occur in an\u00adcestors are shadowed15.; andevery constructor hasa \ndistinct signature. Module de.nitions are well-formed if their constituent elements are well-formed; \neach member class has a distinct name; and the module provides valid class overrides for all classes \nde.ned in its super module. This notion is formalized in section A.6. Bind declarations are well-formed \nif the instantiated types are well-formed and subtypes of their formal types with respect to .. A program \nis well-formed if all module de.nitions are well-formed, the induced module table is well-formed, the \nset of binds is well-formed, and the trailing expression can be typed with empty type environment(G)and \nbound envi\u00adronment .BT .  A.6 Class and Module Auxiliary Functions The auxiliary functions de.ning .eld \nname and value lookup, method typing, method lookup, valid method over\u00adrides, constructor inclusion, \nand method inclusion appear in Table 5. The auxiliary functions de.ning valid class overrides appear \nin Table 6. These functions are passed a 15 This restrictionis not necessaryin principle,butit signi.cantly \nsimpli.es the proof of type safety. bound environment . to determine the module bounds of type parameters. \nThe mapping .elds returns only the .elds directly de.ned inaclass de.nition. The mapping .eldVals is \nused to retrieve the .eld values for a given object. A static type is passed to .eldVals to disambiguate \n.eld names in the presence of accidental shadowing. Methodtypes are resolvedby searching upward the class \ninheritance chain (which may cross modules via imports) starting from the provided static receiver type. \nThe type of a method includes the enclosing module and class instanti\u00adation in which the method occurs, \nas well as the parameter types and return types. The included module and class names are used to annotate \nreceiver expressions in the typing rules for methodinvocation.Asexplained laterinSectionA.7,the annotated \ntype of the receiver of an application of method m is reduced to a more speci.c type when the more speci.c \ntype includes m (with a compatible method signature) in the static type of its parent. Once the annotated \ntype of a re\u00adceiver is reduced to the most speci.c type possible, lookup of m starts at the reduced annotatedtype. \nFor a given module D, a class de.nition CL de.nes a valid class override if CL provides a super set of \nthe .elds, constructors, andmethods providedby the classof the same name, if it exists, in the static \ntype of the super module for D. A.7 Expression Typing The rulesforexpression typing aregiveninTable4.Naked \ntypevariablesmay occurin casts,but are prohibitedin new operations. The expression typing rules annotate \nthe receiver expres\u00adsion for .eld lookups and method invocations with a static type. In the case of a \n.eld lookup, this static type is used to disambiguate the .eld reference in the presence of acci\u00addental \nshadowing. Although classes are statically prevented from shadowing the known .elds of their ancestors, \na mixin instantiationmay accidentally shadowa.eld containedinits parent. In the case of method invocations, \nthe receiver is an\u00adnotated with a static type to allow for a downward search of a method de.nition at \nrun-time, as explained in section A.6. Noticethatthereceiverexpressionofamethodinvocation is annotated \nnot with its precise static type,but instead with the closest supertype of the static type in which the \ncalled methodisexplicitly de.ned.Themethodfoundinthatsuper\u00adtype is the only method of that name that \nis statically guar\u00adanteed to exist. During computation, the annotated type is reduced whenever possible, \nmodeling the downward search semanticsofhygienic mixin methodoverriding. Like receiverexpressions,theargumentsina \nnew expres\u00adsion are annotated with static types. These annotation are used at run-time to determine which \nconstructor is referred to by the new operation. This is because the semantics re\u00adquire an exact match. \nThere could be cases where multiple . . Object ok[WFObject] . . Mod ok[WFMod] X . dom(.) . . X ok [WFVar] \nX . dom(.) . . Xok [WFMVar] bound.(T) = D<T> . . D<T> ok MT (D) = module D<Y. N> . N{CL}class C<X . N> \n. N {...} . CL . . S ok . . S <: [Y .. T][X .. S]N . . T.C<S> ok [WFClass] MT (D) = module D<Y. N> . \nN{CL}. . Tok . . T<: [Y.. T]N . . D<T> ok [WFModule] MT(D)= module D<Y. N> . N{CL} class C<X . R> . \nN {Tf;K M}. CL .= Y. N+ thisMod . D<Y> + X . RN = V.D<S> bound.(V)= C<Z> x n this = \u00d8 . . override(C<Z>.D<S>, \n<X. . R.>V. m(T. x)) .1 =.+ X. . R. G= x : T. + this: D<Y>.C<X> .1 . R. ok .1 . R. <: Object .1 . V. \nok .1 . T. ok .1;G . e . U .1 . U <: V. [TMethod] <X. . R.>V. m(T. x) {return e;} ok in D<Y. N>.C<X \n. R> MT(D)= module D<Y. N> . N{CL} class C<X . R> . N {Tf;K M}. CL N = V.D<S> bound.(V)= C<Z> .= Y. N+ \nthisMod . D<Y> + X . R G= x : Vx n this = \u00d8 . . V ok .; G . e. . U. . C<Z>.D<S> includes init(U.) .; \nG . e . U . . U <: T [TConstructor] C(V x){super(e.);this.f = e;} ok in D<Y. N>.C<X . R> MT (D)= module \nD<Y. N> . N{CL}K ok in D<Y. N>.C<X . R> M ok in D<Y. N>.C<X . R> .= Y. N+ thisMod . D<Y> + X . R . . \nR ok . . R <: Object . . N ok . . T ok X n thisMod = \u00d8 f n this = \u00d8 . . D<Y>.C<X> <: V and . . .elds(V)= \nT. f. implies f n f. = \u00d8 Ki = C(T x) {...} and Kj = C(T x.) {...} implies i = j [TClass] class C<X \n. R> . N {Tf;K M} ok in D<Y. N> CL ok in D<Y. N> N<: Mod Yn thisMod = \u00d8 .= Y. N . . Nok . . Nok . . classOverride(N, \nCL) CLi = class C<X . T> . N {...} and CLj = class C<X. . T.> . N. {...} .0 . Nok .0 . N<: N0 implies \ni = j [TBind] [TModule] bind N0 X = N; ok module D<Y. N> . N{CL} ok Table 3. Well-formed Declarations \nconstructors match the required signature of a new expres\u00adsion. In order to allow fora subject-reduction \ntheoremover the CCG small-step semantics, it is necessary to provide sepa\u00adrate typing rules for annotated \n.eld lookup and method in\u00advocation expressions. Notice that it is not possible to simply ignore annotations \nduring typing since accidental shadowing and overriding would cause the method and .eld types de\u00adtermined \nby the typing rules to change during computation. Just as type annotations play a crucial rule in preserving \nin\u00adformation in the computation rules, theyplay an analogous role in typing expressions during computation. \nInFGJ, stupid casts (the castingofanexpressiontoan incompatibletype) were identi.edasapossible result \nduring subject reduction. In CCG, it is not possible to statically detect stupid casts in modules because \nclass types cannot be completely resolved until module linkingat run-time.For the sake of brevity, all \ncasts are accepted during typing. To avoid the complications of matching multiple con\u00adstructorsofan \nobject,CCGrequiresanexact match between the parameter types of a constructor and the static types of \nthe provided arguments. Casts can be inserted to coerce argument types. A.8 Computation The rulesfor \nComputation are contained in Figure 7. Com\u00adputation is speci.ed by a small-step semantics. The static \ntype of a receiver is used to resolve method applications and .eld lookups, static types mustbepreserved \nduring compu\u00adtation as annotations on receiver expressions. In contrast to FGJand CMG, the small-step \nsemantics for CGEN carry a .; G . x . G(x)[TVar] .; G . e . S . . T ok [TUCast] .; G . (T)e . T bound.(V) \n= D<Z> . . D<Z>.C<T> ok .; G . e . R . . R <: S . . S ok bound.(V) = D<Z> .; G . e . S . D<Z>.C<T> includes \ninit(S) . D<Z>.C<T> includes init(S) [TNew] .; G . new V.C<T>(e :: S) . D<Z>.C<T> [TAnnNew] .; G . new \nV.C<T>(e) . D<Z>.C<T> annotate [e :: S] . . .elds(N) = T f . . N ok .; G . e . T . . T <: N N = V.C<U> \n.; G . e . T . . T <: N bound.(V) = D<Z> . . .elds(N) = T f . . P <: N and fi . (. . .elds(P)) implies \nP = N .; G . [e :: N].fi . Ti [TAnnField] [TField] .; G . e.fi . Ti annotate [e :: D<Z>.C<U>] . . T ok \n.; G . e0 . T0 .; G . e . R . . mtype(m, O) = P.<X . N> S m(U x) . . T ok .; G . e0 . T0 .; G . e . R \n. . T <: [X .. T]N . . R <: [X .. T]U bound.(T0) = D<Z>.C<S> . . mtype(m, D<Z>.C<S>) = P.<X . N> S m(U \nx) .; G . [e0 . O].m<T>(e) . [X .. T]S [TAnnInv] . . T <: [X .. T]N . . R <: [X .. T]U [TInv] .; G . \ne0.m<T>(e) . [X .. T]S annotate [e0 . P] Table 4. ExpressionTyping bound environment . during computation \nrepresenting the available bind declarations. When evaluating the application of a method, the ap\u00adpropriate \nmethod body is found according to the mapping mbody. The application is then reduced to the body of the \nmethod, substituting all parameters withtheir instantiations, and this with the receiver. Because it \nis important that a method application is not reduced until the most speci.c matching type annotation \nof the receiver is found, two separate forms are used for type annotations. The original type annotation \nmarks the receiver with an annotation of the form . T. This form of annotation iskept until no further \nreduction of the static type is possible. At this point, the form of the annotation is switched to :: \nT . Because the computation rules dictate that methods can be applied only on receivers whose annotations \nare of the latter form, we are ensured that no further reduction is possible when a method is applied. \nThe symbol . is used to designate contexts where either form of annotation is applicable.  A.9 Type \nSoundness A full proof of CCG type soundness is available in an ac\u00adcompanying technical report. The notion \nof subject reduc\u00adtion is formalized in the following theorem: THEOREM 1 (Subject Reduction). If . . e \n. T and . . e . e. then . . e. . S where . . S <: T. We also state a progress theorem, which relies on \nthe following de.nitions: DEFINITION 1 (Value). A well-typed expression e is a value iff e is of the \nform new T.C<T>(e) where bound.(T)= D<V> and all e are values. DEFINITION 2 (Bad Cast). A well-typed \nexpression e is a bad cast iff e is of the form (T)e. where . . e. . S and . .. S <: T. Notice that bad \ncasts include both stupid casts (in the parlance of FGJ) and invalid upcasts. * Now let . be the transitive \nclosure of the reduction relation .. Then we can statea progress theorem forCCG as follows: THEOREM 2 \n(Progress). For program (MT, BT, e) s.t. *. .BT . e . R, if .BT . e . e. then either e. is a value, \ne. . e.. contains a bad cast, or there exists e.. s.t. .BT . e. THEOREM 3 (Type Soundness). For program \n(MT, BT, e) s.t. .BT . e . T, evaluation of (MT, BT, e) yields one of the following results: * 1. .BT \n. e . v where v is a value of type S and .BT . S <: T. * 2. .BT . e . e. where e. contains a bad cast, \n 3. Evaluation never terminates, i.e., forevery e. s.t. .BT .  * .. e . e. there exists e.. s.t. .BT \n. e. . e.  Table 5. Class Auxiliary Functions D<Y.>.C<T.> includes init(T) . D<Y.>.C<T.> provides C(T \nx) {...} D<Y.>.C<T.> includes <Y . T.>R. m(U. x) . D<Y.>.C<T.> provides <Y . T.>R. m(U. x) {return e;} \nMT (D)= module D<Y. N> . N{CL} and class C<X . S> . U {Tf;K M}. CL implies (S. , U.)=[Y .. Y.][X .. X.](S, \nU) and [Y.. Y.][X .. X.]T f; . T. f.; and D<Y.>.C<X.> provides [Y .. Y.][X .. X.](K, M) . . classOverride(D<Y.>, \nclass C<X. . S.> . U. {T. f.;K. M.}) Table 6. Module Auxiliary Functions . . mbody(m<V>, N)=(x, e0) [RInv] \n . . [new V.C<S>(e :: P) :: N].m<V>(d) . [x .. d][this .. new V.C<S>(e :: P)]e0 . . e . N . . N <: V.C<U> \nbound.(V)= D<T> MT(D)= module D<Y. N> . N{CL} class C<X . S> . T {...}. CL . . mtype(m, D<Z>.C<U>)= mtype(m, \n[Y.. Z][X .. U]T) [RInvSub] . . [e . [Y .. Z][X .. U]T].m<V>(d) . [e . D<Z>.C<U>].m<V>(d) . . e . N \n. . N <: V.C<U> bound.(V)= D<T> MT(D)= module D<Y. N> . N{CL} class C<X . S> . T {...}. CL . . mtype(m, \nD<Z>.C<U>) is unde.ned or . . mtype(m, D<Z>.C<U>) . = mtype(m, [Y .. Z][X .. U]T) [RInvStop] . . [e \n. [Y .. Z][X .. U]T].m<V>(d) . [e :: [Y.. Z][X .. U]T].m<V>(d) . . .elds(R)= Tf . . N <: T . . .eldVals(new \nN(e), R) = e. [RCast] [RField] . . (T)new N(e :: S) . new N(e :: S) . . [new N(e) :: R].fi . e . i . \n. ei . ei [RCNewArg] . . new T(..., ei :: S, ...) . new T(..., ei . :: S, ...) . . e . e [RCInvRecv] \n . . [e . N].m<V>(d) . [e. . N].m<V>(d) . . ei . ei [RCInvArg] . . [e . N].m<V>(...ei...) . [e . N].m<V>(...ei \n. ...) . . e . e . . . e . e . [RCCast] [RCField] . . ((S)e) . ((S)e.) . . [e :: R].f . [e. :: R].f \nTable 7. Computation \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Developing a general component system for a statically typed, object-oriented language is a challenging design problem for two reasons. First, mutually recursive references across components are common in object-oriented programs-an issue that has proven troublesome in the context of component systems for functional and procedural languages. Second, inheritance across component boundaries can cause accidental method overrides. Our recent research shows that a component framework can be constructed for a nominally typed object-oriented language supporting first-class generic types simply by adding appropriate annotations, syntactic sugar, and component-level type-checking. The fundamental semantic building blocks for constructing, type-checking and manipulating components are provided by the underlying <i>first-class</i> generic type system. To demonstrate the simplicity and utility of this approach we have designed and implemented an extension of Java called Component NEXTGEN (CGEN). CGEN, which is based on the Sun Java 5.0 <b>javac</b> compiler, is backwards compatible with existing Java binary code and runs on current Java Virtual Machines.</p> <p>The primary contribution of this paper is a technical analysis of the subtle design issues involved in building a component framework for a nominally typed object-oriented language supporting first-class generics. In contrast to component systems for structurally typed languages, mutual recursion among components is accommodated in the type system and semantics without incorporating any special machinery. Our analysis includes a presentation of Core CGEN (CCG), a small, core language modeling the CGEN framework. It is based on Featherweight GJ and incorporates some ideas from MIXGEN. CCG adds the essential features to support components, but nothing more. Our discussion includes the type rules and semantics for CCG, as well as a proof of type safety.</p>", "authors": [{"name": "James Sasitorn", "author_profile_id": "81314494433", "affiliation": "Rice University, Houston, TX", "person_id": "P792428", "email_address": "", "orcid_id": ""}, {"name": "Robert Cartwright", "author_profile_id": "81406592800", "affiliation": "Rice University, Houston, TX", "person_id": "P71474", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297039", "year": "2007", "article_id": "1297039", "conference": "OOPSLA", "title": "Component nextgen: a sound and expressive component framework for java", "url": "http://dl.acm.org/citation.cfm?id=1297039"}