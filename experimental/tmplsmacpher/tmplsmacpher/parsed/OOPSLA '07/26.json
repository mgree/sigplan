{"article_publication_date": "10-21-2007", "fulltext": "\n Lost In Translation: Formalizing Proposed Extensions to CP Gavin M. Bierman Erik Meijer Mads Torgersen \nMicrosoft Research Cambridge, UK Microsoft Corporation, USA Microsoft Corporation, USA gmb@microsoft.com \nemeijer@microsoft.com madst@microsoft.com Abstract Current real-world software applications typically \ninvolve heavy use of relational and XML data and their query languages. Unfortunately object-oriented \nlanguages and database query languages are based on different semantic foundations and optimization strategies. \nThe resulting ROX (Relations, Objects, XML) impedancemismatch makes life very dif.cult for developers. \nMicrosoft Corporation is developing extensions to the .NET framework to facilitate easier processing \nof non-object\u00adorienteddata models.Partofthisproject(knownas LINQ ) includes various extensions to the \n.NET languages to lever\u00adage this support. In this paper we consider proposalsforC.3.0, the next ver\u00adsionof \ntheC. programming language.Wegiveboth an infor\u00admal introduction to the new language features, and a precise \nformal accountbyde.ningatranslation fromC.3.0 toC.2.0. This translation also demonstrates how these language \nex\u00adtensions do not require anychanges to the underlying CLR. Categories and Subject Descriptors D.3.1[Programming \nLanguages]:Formal De.nitions andTheory General Terms Languages, Theory 1. Introduction Many programmers \nstruggle with the problem of access\u00ading and integrating data that is not natively de.ned using an object-oriented \nprogramming language (most commonly this means XML and relational data). This impedance mis\u00admatch between \nthe data models typically results in fragile code that is subject to only very weak compile-time type \nchecking. Whilst this is an old problem [11, 20] it has been recently revisited in the context of commercial \nobject-oriented lan- Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. OOPSLA 07, October 21 25, 2007, Montr \u00b4ebec, Canada. eal, Qu\u00b4Copyright c &#38;#169; 2007ACM 978-1-59593-786-5/07/0010...$5.00. \n guages.Forexample,XJisanextensionofJava1.4to sup\u00adport .rst-class XML [13], andC. is anextension toC.1.1 \nto support both XML and relational data [7]. (As is com\u00admon, these recent industrial proposals have been \npreceded by decadesof academicwork.Wegive some detailsof this prior work in \u00a77.) Microsoft Corporation \nhas recentlyannouncedextensions to the .NET framework as well as to the .NET languages to sup\u00adport the \nintegration of non-object data.1 This project, called LINQ(Language INtegrated Query), proposes avery \ngen\u00aderal approach tothe impedance mismatch problem; de.ning a general pattern of operators to query data \nas well as pro\u00adviding fourimplementationsof this pattern LINQoverob\u00adjects for querying in-memory collections \nof objects, LINQ over XML for querying in-memory XML data, LINQ over SQL for simple relational data and \nLINQ over Entities for querying data from the ADO.NET Entity Data Model [9]. Ontopof this pattern, bothC. \nandVisual Basic will provide special queryexpression syntax,andVisual Basicwill,inad\u00addition, add .rst \nclass support for XML in the form of XML literals for constructingXML documents and so-called axis members \nfor traversing XML documents. Importantly, none of theseextensionswill requireanychangetothe underlying \nvirtual machine (CLR). In this paper we focus on the current proposal for the next version (3.0)ofMicrosoft \nsC. programming language [14]. The new features to appear, whilst interesting in their own right, are \nessentiallyprovidedtofacilitatea convenient style of LINQ programming. These features are not particularly \ntied toC.. The nextversionofVisual Basic (9.0)willhave similarextensions. Indeed,theycouldbe addedtoanyclass\u00adbased \nobject-oriented language. We believe that a formal, mathematical approach is essen\u00adtial to set a .rm \nfoundation for researchers, implementors and usersof programming languages.ForC.3.0 this is espe\u00adcially \npertinent: all the new language features are essentially syntacticsugar(ofasophisticated nature).Our \nformalization ofC.3.0 makes this observation precise: we de.ne a formal translationofa fragmentofC.3.0 \nintoC.2.0.In otherwords, our translationprovidesasemanticsofthenewlanguagefea\u00adtures in terms of pre-existing \nlanguage features. The exis\u00ad 1http://msdn.microsoft.com/netframework/future/linq tance of such a translation \nshows whythe underlying CLR need not be changed. This paper makes a number of contributions: We de.nean \nimperative, core fragmentofC 3.0 called FC3. This fragment whilst reasonably small, contains all the \nessential featuresofC including all of the new lan\u00adguage features that will appearinC 3.0.  We formalize \nthe compilation of query expressions into standard query operators.  We de.nean imperative, core fragmentofC \n2.0 called FC2 (other fragments are much weaker, e.g. [17]).  We formally specify a type-directed translation \nofFC3 to FC2. This translationbuilds onthe techniquesof bidirec\u00adtional type checking .rst used for local \ntype inference in SystemF[25].Asfarasweareawarethisisthe .rstsuch application of this technique.  We \nprove two essential safety properties of this transla\u00adtion: type-preservation and conservativity.  \nThe rest of the paper is organized as follows. In \u00a72wegivean informal introductiontothenew language featuresinC \n3.0. In \u00a73we de.neformallya core fragmentofC 3.0, that we dub FC3. In \u00a74we show how FC3 query expressions \ncan be compiled out into method calls. In \u00a75 we de.ne formally a translation fromC 3.0 toC 2.0. In \u00a75.1 \nwe .rst de.ne a target language for our translation:a corefragmentofC 2.0 that we call FC2.We usea technique \nfrom bidirectional type checking to de.ne translations from FC3 to FC2 in \u00a75.2 and \u00a75.3. In \u00a75.4 we discuss \nthe extensions to type inference in C 3.0. In\u00a76we consider some important safetyproperties of our translation.We \nreview some relatedworkin \u00a77, before concluding in \u00a78. 2. An introduction to C. 3.0 In this section we \npresent thekeyideas behind the new lan\u00adguageextensionsinC3.0,andprovidea numberofexam\u00adples to illustrate \nthese ideas. This section should serve as a programmer s introduction toC 3.0.Weassume the reader isfamiliar \nwithC /Java-like languages. Our runningexample usesavariantof the CIAWorldfact\u00adbook Database2 that contains \na wealth of geographic infor\u00admation about the world s countries. But for the purposes of our example \nlet us assume that we store with each country just its area and population.We represent this schema inC \nusing the following class declaration. public class Country{ public string Name; public double Area; \npublic int Population; } 2https://www.cia.gov/library/publications/the-world-factbook The following \nstatement uses a number of the new features inC3.0to de.nea small subsetofthe countries database that \nwe will use as our running example. var Countries = new [] { new Country{ Name = \"Palau\", Area = 458, \nPopulation = 16952}, new Country{ Name = \"Monaco\", Area = 1.95, Population = 31719}, new Country{ Name \n= \"Belize\", Area = 22960, Population = 219296}, new Country{ Name = \"Madagascar\", Area = 587040, Population \n= 13670507} }; Given this array, we can query and then output an array containing all those countries \nwith a population less than 210,000 people, in descending order of their area, as follows. var temp = \nfrom c in Countries where c.Population < 210000 orderby c.Area descending select c.Name; foreach (var \nt in temp) Console.WriteLine(t); Let us review this code in detail to understand why it was so simple \nto write. First the de.nition of Countries was simpli.ed through the use of the functional-style, object \ninitialization syntax, e.g. new Country{ Name=\"Monaco\", Area=1.95, Population=31719}  The declaration \nof Countries also illustrates an implicitly typed local declaration. In other words the var keyword enables \nus to drop the type of the declaration. However, this does not imply that we have dropped the static \ntyping disciplineofC;infact,the compiler synthesizesatypefor us (in this case it is Country[]). Likewise \nthe declaration also uses an implicitly typed array creation. We have not supplied the element type for \nthe array,but rely on theC 3.0 compiler to synthesize it for us (in this case it will be Country). The \nlocal variable temp is initialized using a SQL-style queryexpression to generate the required subset \nof countries. The resemblancetoSQLis intentionalto allowC program\u00admersfamiliarwithSQLtoeasily transitiontousingthe \ncom\u00adpact queryexpressionsto .lterandprocess data.Again,the declaration is implicitly typed; in this case \nthe compiler will infer the type IEnumerable<string>. AllthelanguageextensionsinC 3.0 areessentially \nsophisti\u00adcated coatings of syntactic sugar that are compiled away us\u00adingvarious type-directed translations \ninto plainC 2.0.The queryexpressionaboveis actually compiledtothe following method calls: var temp = \nCountries .Where((c) => c.Population < 210000) .OrderByDescending((c) => c.Area) .Select((c) => c.Name); \n This translation also highlights another new languageexten\u00adsion: .-expressions. These are lightweight \nsyntax for del\u00adegates; for example, the .-expression (int x) => x+1 is just a simpler way of writing \nthe anonymous method expression delegate(int x){ return x+1; }. A key difference, as highlighted in the \nprevious code, is that .\u00adexpressions need not suppplytypes for their arguments. The methods Where, OrderByDescending \nand Select are three of a number of so-called standard query operators that are new to the LINQ framework. \nThey are in essence new methods understood by objects that implement the IEnumerable<T> interface. Tofacilitate \nthisextensionofIEnumerable<T>,C 3.0 pro\u00advides a general means to extend existing types and con\u00adstructed \ntypes with additional methods. These additional methods are known as extension methods. They are es\u00adsentially \nstatic methods that can be invoked using instance method syntax. Extension methods are declaredby specify\u00ading \nthe (new) modi.er this on the .rst parameter of the methods. Extension methods can only be declared in \nnon\u00adgeneric, non-nested static classes.Forexample, we could de\u00ad.neanewmethod PlayAnthem to our pre-existing \nCountry class as follows: namespace Foo { public static class Extension { public static void PlayAnthem(this \nCountry c, Volume vol){...} } } Thusifwebringthis namespaceintoscopewitha using Foo; directive, we can \ninvoke the extension method as if it were an instance method on Country objects, as follows. var Blze \n= new Country{ Name = \"Belize\", Area = 22960, Population = 219296}; Blze.PlayAnthem(Volume.Loud); Again, \nthis language feature is actually sugar. Given a method invocation of the form e.m(f), the compiler .rst \nchecks to see if there is an instance method m supported by the receiver object e. If not, then the compiler \nattempts toprocessitasanextension methodinvocationby translat\u00ading it to the static method invocation \nm(e,f). (The name m is resolved .rst using the closest enclosing namespace, and then successively outwards \nthrough nested namespaces, until reaching the containing compilation unit.) When writing query expressions \nit is common to want to return more than one item per element,for example to re\u00adturn both the name and \narea of countries with a population greater than 32,000.To allow thisC 3.0 introduces the new notion \nof an anonymous type. var temp2 = from c in Countries where c.Population > 32000 select new { MyName=c.Name, \nMyArea=c.Area };  An anonymous type is a nameless class type that inherits directly from object. An \nanonymous object initializer is of the form new{f1 =e1; ...fn =en} and essentially creates an object \nof an unknown (to the programmer) type, with .elds f1,...,fn which are initialized to e1,...,en. The \nname of an anonymoustypeis automaticallygeneratedbytheC3.0 compiler and cannot be referenced in a program. \nWithin the same assembly, two anonymous initializers that specify a sequence of properties with the same \nnames and types are guaranteed to produce instances of the same inter\u00adnal type.Forexample: var city1 \n= new {City=\"London\", GDPperCapita=31400}; var city2 = new {City=\"Paris\", GDPperCapita=30100}; if (city1 \n== city2) Console.WriteLine(\"Same city!\"); The comparison on the last line is permitted because c1 and \nc2 are of the same anonymous type. We have seen that.-expressions can be assigned to delegate types.HowevertheextensibilityfeaturesoftheLINQ \nframe\u00adwork mean that it is often convenient to allow code to be emitted as data. The LINQ framework provides \na new type Expression<T>,andC 3.0 allowsa.-expression to also be implicitly convertedtoanexpression tree.Forexample: \nFunc<int,int> f = (x)=>x+1; //Code Expression<Func<int,int>> e=(y)=>y+1; //Data Console.WriteLine(f(42)); \n//Prints 43 Console.WriteLine(e.Body.NodeType); //Prints Add Expression trees are ef.cient in-memory \nrepresentations of the .-expressions and support a number of useful manipula\u00adtion methods (such as Body \nand NodeType used above). The LINQ over SQL implementation uses these to translate ex\u00adpression treestoSQL \nstatementsthatcanbeexecutedonthe database engine. (This form of meta-programming can have other interesting \nuses; see [27] fora related systembuilt on the same API.) To summarize, the new language extensions appearing \nin C 3.0 include: Implicitly typed local variables, which permit the type of local variables to be inferred \nfrom the expressions used to initialize them.  Extension methods, which make it possible to extend ex\u00adisting \ntypes and constructed types with additional meth\u00adods.  .-expressions, an evolution of anonymous methods \nthat provides improved type inference and conversions to both delegate types and expression trees.  \nObject and collection initializers, which ease construc\u00adtion and initialization of complex object instances \nand collections. In addition, there is support for implicitly typed arrays, a form of array creation \nand initialization that infers the element type of the array from an array initializer.  Anonymous types, \nwhich are tuple types automatically inferred and created from objectinitializers.  Query expressions, \nwhich provide a language integrated syntax for queries that is similar to relational and hierar\u00adchical \nquery languages such as SQL, XQuery, and (list) comprehensions in Haskell and Python.  Expression trees,which \npermit.-expressionstobe repre\u00adsented as data (expression trees) instead of as code (del\u00adegates).  3. \nFC3: A core fragment of C 3.0 In the rest of this paper we study formally the essence of C 3.0.We adopta \nformal, mathematical approach and de\u00ad.nea core calculus FC3, similarto core subsetsofJava such as FJ \n[16], MJ [8] and ClassicJava [12]. Whilst small, our core calculus supports all the essential object-oriented \nfea\u00adtures (classes, overloading, inheritance, side-effects) as well as all the new features to appear \ninC 3.0, and yet still re\u00admains amenable to formal reasoning. In addition, FC3 is a completelyvalid subsetofC \n3.0,in thateveryvalid FC3 pro\u00adgramis literally anexecutableC 3.0 program. In this section we de.ne formally \nthe syntax for FC3 pro\u00adgrams. In \u00a74, subsequent sections we show how query ex\u00adpressions are compiled \ninto methodinvocations and then in \u00a75 we show how FC3 programs are compiled into FC2 (a featherweight \nfragmentofC 2.0). A FC3 program consists of a sequence of zero or more of what we dub extension class \ndeclarations (an extension class contains only extension methods) followed by one or more standard class \ndeclarations. Given an FC3 program we assume that there is a unique designated method within the standard \nclass declarations that serves as the entry point (the main method). We have simpli.ed matters in comparison \ntoC 3.0 in that we do not support nesting of extension classes (nor, hence, the resolution of nested \nnamespaces whilst compiling ex\u00adtension method invocation). Thus we assume that there is a single, implicit \nnamespace (called Extensions, say) sur\u00adrounding the extension classes and also that immediately before \nthe standard class declarations there is an implicit using Extensions; statement that imports all these \nex\u00adtension methods. For regularity, we do not allow exten\u00adsion method declarations anywhere other than \nin extension classes. FC.3 programs: p ::= ecd cd Program ecd ::= Extension class declaration public \nstatic class S {emd} emd ::= Extension method declaration public static fm<X>(this t x, t x){s} cd ::= \nClass declaration public class C<X>:C<t\u00af>{fd md cmd} fd ::= public tf; Field declaration md ::= Method \ndeclaration public virtual fm<X>(tx){s} public override fm<X>(tx){s}  cmd ::= Constructor method declaration \npublic C<X>(tx):this(e){s} public C<X>(tx):base(e){s}  An extension class declaration is simply a static \nclass decla\u00adration that consists of a sequence of extension method dec\u00adlarations. As explained in \u00a72,anextension \nmethodisa static method where the .rst parameter has a this annotation. A standard class declaration \nconsists of zero or more .eld declarations, zero or more method declarations, and one or more constructor \nmethod declarations. Methods must be de.ned either virtual or override and, for simplicity, we require \nall methods be public.For conciseness, we do not model static methods (other than extension methods) \nand non-virtual instance methods, and we do not consider other modi.ers such as private and sealed. However, \nwe do support generic class declarations and generic method declarations that were included in C 2.0 \n[17]. Constructor methods are somewhat orthogonal to the concerns of this paper.For simplicity, they \nare treated essentially as normal methods with the distinguished name .ctor. Adistinctive featureofthenew \nfeaturesinC3.0isthatthey do not requireanyfurtherextensionstothetype grammarof C . Thisisin contrast \nto, say, the approachtakenbyC. [7] wherea numberofnew types were addedtoC . Hencethe grammar for FC3 \ntypes is identical to an equivalent fragment ofC 2.0, andis as follows. Types: f ::= Return type t Type \nvoid Void type t ::= Type . Value type . Reference type Type parameter . ::= ValueType bool Boolean int \nInteger . ::= ReferenceType C<t\u00af> Class type D<t > Delegate type t[] Array type In C the type void can \nonly appear as a return type for method and delegate declarations. The two main categories of FC3 types \nare thenvalue types and reference types.Value types include the base types; for simplicity we shall consider \njust two: bool and int.We do not include nullable types in our core fragment, although they are simple \nto add. FC3 reference types include arrays, class types and delegate types.To simplify the presentation, \nwe only consider single dimension arrays, and we write D to range over delegate types and C to rangeover \nclass types.FollowingGJ[16] we permit the shorthand C for C<>.For simplicity wedo not model constraints \non generic parameters. As is usual with small calculi, we assume a number of pre\u00adde.ned classes. In addition \nto the object class, we assume the classes IEnumerable<T>3 and Expression<T> which play an important \nrole in LINQ. For succinctness, we do not support user-de.ned delegate declarations in FC3. For the purposes \nof this paper, it is suf.cientto simply assumeanumberofprede.ned delegates Func thatwouldbe de.nedinC \nas follows: delegate R Func<R>(); delegate R Func<T1,R>(T1 arg); delegate R Func<T1,T2,R>(T1 arg1, T2 \narg2); ... FC3 expressions are split into three categories: ordinary ex\u00adpressions, statement expressions, \nand query expressions. Statement expressions are expressions that can be used as statements. Query expressions \nare the new comprehension 3Rather than complicating FCwith the complexities of interfaces, we 3 simply \ntreat IEnumerable as if it were a class. syntax for LINQ queries. In \u00a74we detail how theyare trans\u00adlated \ninto standard query operators. Expressions: e ::= Expression b Boolean i Integer e . e Built-in operator \nx Variable null Null (t)e Cast e.f Field access delegate (t x){s} Anonymous method expression (x) => \ne Implicit .-expression (t x) => e Explicit .-expression se Statement expression qe Query expression \nse ::= Statement expression e(e) Delegate invocation e.m(e) Implicit method invocation e.m<t >(e) Explicit \nmethod invocation new C<\u00aft>(e) Object creation new C<\u00aft> {f = ie} Object initialization new C<\u00aft> {nae} \nCollection initialization new {f = e} Anonymous object creation new [ ]{e} Implicit array creation new \nt [ ]{e} Explicit array creation x = e Variable assignment ie ::= Object initializer expression e Expression \n{f = ie} Object initializer {nae} Collection initializer For simplicity, we assume only two classes \nof literals: booleansandintegers.Weassumeanumberofbuilt-inprim\u00aditive operators, such as ==, || and &#38;&#38;. \nIn the grammar we write e . e, where . denotes an instance of one of these op\u00aderators.We do not consider \nthese operators further as their meaning is clear. We assume that x ranges over variable names, f rangesover \n.eld names and m rangesover method names(both virtualandextension).Weassumethatthesetof variables includes \nthe special variable this, which cannot be used as a parameter of a method declaration. FollowingFJ[16]weadoptanoverloaded \nbar notation;for example, tf isa shorthand forapossibly empty sequence t1 f1, ... ,tn fn. Anonymous methodexpressions(AMEs) \nwere introducedin C 2.0, and provide a means to de.ne a nameless method. They are unusual in that they \nare expressions that cannot synthesize a type this notion willbe de.ned later in \u00a75 but theycan (and \nmust) be converted to a compatible dele\u00adgate type. The body of an AME is treated like the body of a method, \ni.e. any return statements must respect the return type of the delegate type. FC3 supports the new, lightweight \n.-expressions that will appear in C 3.0. We consider only those with expression bodies (those whose bodies \nare statement blocks are treated essentially as AMEs),but wedo allow the formal parameter list to be \neither explicitly or implicitly typed. As mentioned earlier, FC3 statement expressions are those expressions \nthat can be used as a statement. This includes two forms of invocation expressions: applying a delegate \nto arguments and method invocation where we can either supply the type arguments orhave them inferred \n[6]. FC3 supports all the new forms of statement expressions that will appear inC 3.0. This includes \nthe new functional style of object and collection initializations. (In the latter, we write nae to range \nover any expression except for vari\u00adable assignment expressions. This restriction ensures that object \nand collection initialization expressions are syntacti\u00adcally distinct.) In addition, FC3 supports implicitly \ntyped ar\u00adray creation (where the array element type can be dropped), and anonymous object creation. FC3 \nsupports the two new forms of statements that will ap\u00adpearinC 3.0. Theseare implicitly typed declarations \n(sig\u00adni.edby thekeyword var)and the implicitly typed form of foreach statements. The grammar for FC3 \nstatements is as follows. Statements: s ::= Statement ; Skip se; Expression statement if (e) s else s \nConditional statement tx = e; Explicit declaration var x = e; Implicit declaration e.f = e Field assignment \nreturn e; Return statement return; Empty return foreach(tx in e) s Explicit foreach foreach(var x in \ne) s Implicit foreach {s} Block Finally, FC3 contains all the forms of query expressions that will appear \nin C 3.0.4 These are given by the following grammar. Query Expressions: qe ::= from x in e qb Query expression \nqb ::= Query body qc select e Select qc group e by e Group qc ::= Query clause from x in e From clause \n4Strictly speaking we have excluded into clauses and explicitly typed rangevariables,but they are purely \nshorthand and canbe easily removed. let x = e Let clause where e Where clause join x in e on e equals \ne Join clause join x in e on e equals e into x Join-into clause orderby e od Order clause od ::= Order \ndirection ascending Ascending descending Descending An FC3 query expression then consists of a from clause, \nfollowed by a number of supplementary query clauses, and ends with either a select clause or a group-by \nclause. As mentioned earlier,C 3.0 queryexpressions are simply con\u00advenient syntactic sugar for the use \nof the LINQ standard query operators. In the following section, we de.ne the translation of an FC3 query \nexpression into method calls. InC 3.0, order clauses are not requiredtohave order direc\u00adtion annotations; \nif one is not supplied, it is assumed to be ascending.For simplicity, FC3 requires order directions on \nall order clauses. In what follows we assume that FC3 programs are well\u00adformed, e.g. nocyclic class hierarchies, \ncorrect method body construction, etc. These conditions can be easily formalized but we suppress the \ndetails for lack of space. 4. Compilation of query expressions Query expressions are provided to enable \nprogrammers to succinctly write data processing expressions in a SQL-style syntax. However, they are \njust syntactic sugar. The C 3.0 compiler compiles them into standard query operators be\u00adfore typechecking \nthe program. This provides programmers with great .exibility: any object canbe queried usingaquery expression \nprovided thatits type supports the query opera\u00adtors that appear in the compilation of the query expression. \n(We detail this patterninAppendixA.) The compilation exploits the regular structure of query ex\u00adpressions. \nWe demonstrate this with some examples that query a collection of customers de.ned as follows. public \nclass Customer { public string Name; public string City; public int Age; public int Credit; }; First, \nconsider the simplest of examples: var names = from c in Customers select c.Name; This simply compiles \ninto an instance of the Select query operator on the Customers object, as follows. var names = Customers.Select((c)=>c.Name); \n The compilation works by incrementally compiling the query clauses that follow the initial from clause \nin a sim\u00adilar way, until we get to the terminating select or group-by\u00adclause.Forexample, consider the \nfollowingexample query expression that returns the names of all customers in de\u00adscending order of their \nage that are in Redmond and have a credit limit of more than $10,000. var names = from c in Customers \nwhere c.City == \"Redmond\" where c.Credit > 10000 orderby c.Age descending select c.Name; The compilation \nprocess startsby considering the .rst query clause where c.City=\"Redmond\" yielding the interim ex\u00adpression: \nvar names = from c in Customers .Where((c) => c.City == \"Redmond\") where c.Credit > 10000 orderby c.Age \ndescending select c.Name; Asimilar step yields the interim expression: var names = from c in Customers \n.Where((c) => c.City == \"Redmond\") .Where((c) => c.Credit > 10000) orderby c.Age descending select c.Name; \nWe now compile the orderby query clause to yield the in\u00adterim expression: var names = from c in Customers \n.Where((c) => c.City == \"Redmond\") .Where((c) => c.Credit > 10000) .OrderByDescending((c) => c.Age) select \nc.Name; We now have a query of the simple form that we considered at the start of this section. The query \nis compiled to the following .nal form. var names = Customers .Where((c) => c.City == \"Redmond\") .Where((c) \n=> c.Credit > 10000) .OrderByDescending((c) => c.Age) .Select((c) => c.Name); We specify formally the \ncompilation of FC3 query expres\u00adsions in Figure 1.5 5. Translation of FC3 to FC2 This section contains \nthe main technical contribution of the paper: the formal details of a translation from FC3 to FC2. This \ntranslation, whilst demonstrating that the new features inC 3.0do not requireanyCLRextensions,is actuallyquite \nsubtle. It is for this reason that we believe that our formal approach is an appropriate one to take. \nOur translation is expressed in the form of a bidirectional type system [25]. The original use of bidirectional \ntype sys\u00adtems was to recover various omitted type annotations from context.Webuildonthis approachand,in \nadditiontovarious instances of similar local type inference, we also translate the new language features \nsupported by C 3.0 to simplify the LINQ style of programming. More concretely, bidirectional type systems \ndistinguish the two distinct phases of type checking and type synthesis. (There is also a phase oftype \ninference that is used to gen\u00aderate type arguments for generic method invocations.)Type checkingis the \nprocessof determining whetheragiven term canbe assignedaparticulargiven type.Type synthesis, on the other \nhand,isthe processof automaticallydetermininga type given a term. Synthesis mode is used when we do not \nknow anything about the expected type of an expression; for example, the receiver subexpression in an \ninvocation. The checking mode is used when the surrounding context deter\u00adminesthetypeoftheexpressions,andweonlyneedto \ncheck whether theexpression canbe assigned thegiven type. These two phases, whilst distinct, are actually \ninterde.ned. One particuarly pleasant aspect of de.ning a bidirectional system is that it is very straightforward \nto read off an imple\u00admentation from the de.nitions of these two relations. As an example, consider the \nproblem of translating a dec\u00adlaration. If it is explicitly typed, that is it is of the form: tx = e;, \nwe clearly use type checking to see if the expres\u00adsion can be assigned the type t. However, if it is \nan implic\u00aditly typed declaration of the form: var y = f;, we need to synthesize a type, t ' say, for \nthe expression f. Then the im\u00adplicitly typed declaration can be translated to an explicitly typed declaration \nt' y = .... The rest of this section is organized as follows. In \u00a75.1 we discuss brie.y our target language, \nFC2, which is a feather\u00adweight fragment ofC 2.0.We describe the checking, syn\u00adthesis and inference phases \nof our translation in \u00a75.2, \u00a75.3 and \u00a75.4, respectively. 5The compiler may well perform some simple optimizations \nduring the compilation of query expressions, in particular replacing generated in\u00adstances of the subexpression \ne.select((x)=>x) with e.     from x in e1 def = |e1|.Select(x=>|e2|) select e2from x in e def = \n|e|.GroupBy(x=>k) group x by k from x1 in e1 group e2 by k def = |e|.GroupBy(x=>k,x=>|e2|) . . .  |e1|.SelectMany(x2=>|e2|,(x1,x2)=>|e3|) \nif q = select e3 from x1 in e1 def  from z in e.SelectMany(x1=>e2,(x1,x2)=>new{x1,x2}) q[x1 := z.x1,x2 \n:= z.x2] if q = select e3, and where z is fresh from x2 in e2 = ... q  where z is fresh from x1 in \ne1 from z in e1.Select(x1=>new{x1,x2=e2}) q[x1 := z.x1,x2 := z.x2] def let x2= e2 = q from x1 in e1 \n  from x1 in e1.Where(x1=>e2) q def where e2 = q . . . . .. |e1|.Join(x2=>|e2|,x1=>k1,x2=>k2,(x1,x2)=>|e3|) \nif q = select e3 from z in e1.Join(e2, x1=>k1, x2=>k2, (x1,x2)=>new{x1,x2}) q[x1 := z.x1,x2 := z.x2] \n if q = select e3, and where z is fresh |e1|.GroupJoin(x2=>|e2|,x1=>k1,x2=>k2,(x1,x3)=>|e3|) if q = \nselect e3 from x1 in e1 join x2 in e2 def = on k1 equals k2 q from x1 in e1 join x2 in e2 . . . . ... \n. . . if q = select e3, and where z is fresh from z in e1.GroupJoin(e2, def on k1 equals k2 x1=>k1, \nx2=>k2, (x1,x3)=>new{x1,x3}) = .. . . . into x3 q q[x1 := z.x1,x3 := z.x3]  where from x in e orderby \nk1 od1, from x in e.|od1|o|od2|t(x=>k2). def = OrderBy def (x=>k1). |ascending|o k2 od2, = OrderByDescending \ndef = ... |descending|o def |ascending|t |descending|t \u00b7\u00b7\u00b7 kn odn ThenBy |t = |odnq (x=>kn) def = ThenByDescending \nq Figure 1. Translation of query expressions 5.1 FC2: The target language fragment of C 2.0 The target \nlanguage for our translation is a corresponding featherweight fragment of C 2.0, which we call FC2. Its \nsyntax is essentially just a subset of the FC3 syntax given in \u00a73. Hence an FC2 program is just a sequence \nof one or more class declarations. The syntax for FC2 types is iden\u00adtical to that for FC3. The grammar \nfor FC2 expressions is identical except that .-expressions and query expressions are removed. For convenience \nin the translation we add a new form of expression to FC2:a block expression, written ({s})t . This can \nbe thought of as shorthand for the invoca\u00adtionexpression d() where the delegate d has been de.ned as \ndelegate(){s} and the return statements contained in s can be implicitly converted to t;but we treat \nit here as if it were a new language form. FC2 statement expressions are the same as for FC3 except that \nFC2 does not support object initialization, anonymous object creations and implicit array creation these \nare new features in C 3.0. As our translation performs local type inference for implicitly typed method \ninvocations, FC2 does not have anyform for implicit method invocation. Prely to simplify the presentation \nof the translation, the syntax for explicit method invocations is also different. In FC2 method invocations \nare of the form e.M(e), where M is a method descriptor and is de.ned as follows. Method Descriptor: M \n::= C<XC ><tC >::m<Xm><tm> : (tp) . f The method descriptor is used to fully identify a speci.c method \nthatis being calledataspeci.c instantiation (bothof the class within whichit is de.ned, and of the method \nitself). These method descriptors are used inside the compiler to resolve overloading,6 and appear explicitly \nin MSIL, the bytecode language for the CLR (albeit with type parameters replaced by integers denoting \ntheir position) [28]. Consider the following class declaration. class myC<T> { public void myM<S>(T arg1, \nList<S> arg2){} } To invoke the methodmyM with a type argument string on an instance of (static) type \nmyC<int>, the following method descriptor would be used. myC<T><int>::myM<S><string> : (T, List<S>) . \nvoid Subtyping (also known as implicit conversion) for FC2 is standard. Interestingly, exactly the same \nrules are used for subtyping for FC3and are as follows. 6TheC overloading rules [14, \u00a720.9.4] involve \nthe formal parameter types both before and after instantiation, so the method descriptors store the formal \nparameter types pre-instantiation along with the instantiations. Subtyping: t1 <: t2 t2 <: t3 [ST-Re.] \n[ST-Trans] t1 <: t1 t1 <: t3 .1 <: .2 [ST-Obj] [ST-ArrayCovar] t<: object .1[] <: .2[] class C1<X> : \nC2<t2> [ST-Sub] C1<t1> <: C2<t2>[X := t1] Rules [ST-Re.] and [ST-Trans] ensure that the subtyping relation \nis re.exive and transitive. Like Java,C arrays are covariant, which is captured in the [ST-ArrayCovar] \nrule; although covariance is only supported for reference types. The rule [ST-Obj] ensures that object \nis the root of the type hierarchy. The FC2 type system is de.ned as a bidirectional type sys\u00adtem [25]. \nThekey concept of bidirectional type systems is that we provide judgement forms for bothtype checking \nand type synthesis. The type checking relation for expressions comes in two .avours: one for implicit \nconversions and one for explicit conversions (which arises in cast expressions [14, \u00a76.2]). The .rst \njudgement form is written G f e .i t and is read informally that in context G, the FC2 expression e can \nbe implicitly converted to type t . The second judgement form is written G f e .x t . and is read informally \nthat in context G, the FC2 expression e can be explicitly converted to type t . Acontext, G,isafunction \nfromvariablestotypes. Thetype synthesisjudgementformforexpressionsis written G f e .s t and is read informally \nthat in context G, the FC2 expression e synthesizes the type t. To help familiarize the reader with bidirectional \ntype sys\u00adtems, we give the rules for type checking and type synthesis of expressions in Figure 2. The \nrest of the rules (type syn\u00adthesis of statement expressions and type checking of state\u00adments) are given \nin Appendix B. The checking relations are built on top of the synthesis relation,sowe considerthat relation.rst.Mostoftheserules \nare routine. The rule [S2-Cast] can be read as follows: a cast expression (t1)e1 synthesizes a type t1 \nprovided that e1 can be explicitly converted to type t1. Rule [S2-FieldAccess] makes use of an auxiliary \nfunction ftype, which is a map from a type and a .eld name to a type. Thus ftype(t, f) returns the type \nof .eld f in type t. The implicit conversion checking relation requires two spe\u00adcial cases to deal with \nthe null constant and AMEs these are expressions which can not synthesize a type. The [IC2-Null] rule \nasserts that the null constant can be implic\u00aditly converted to anyreference type. Rule [IC2-AME] makes \nuse of another auxiliary function dtype,whichisamapfrom G f e1 .i t1 dtype(D)(t )= t0 . f G,x: t0 f \ns . f G f e .s t1 t1 <: t2 [IC2-Null] [IC2-AME] [IC2-Synth] G f null .i . G f delegate(t0 x){s} .i D<t \n> G f e .i t2 G f e1 .x t1 G f e .i t G f e .s t1 t1 <:x t2 [XC2-ImpConv] [XC2-Synth] G f e .x t G f \ne .x t2 G f e1 .s t1 G f e1 .x t1 [S2-Bool] [S2-Int] [S2-Var] [S2-Cast] G f b .s bool G f i .s int \nG,x : t f x .s t G f (t1)e1 .s t1 G f e1 .s t1 ftype(t1,f)= t2 [S2-FieldAccess] G f e1.f .s t2 Figure \n2. Type checking and synthesis forFC2 expressions delegatenames to their associated type.We write delegate \ntypes as function types in the System F sense; in general they are written .X.(t ) . f.For example, the \nfollowing delegate declaration: List<Y> delegate Map<X,Y>(Func<X,Y> f, List<X> xs); wouldbe represented \nas thetype .X, Y.(Func<X, Y >, List<X>) . List<Y > In the rule we use type application for conciseness; \nwe write dtype(D)(t )= t1 . f1 to mean .rst use dtype to determine the type of the delegate D, say .X.(t0) \n. f0 and then substitute the types t for X resulting in the type t1 . f1. The rule [IC2-AME] also re.ectsthe \nrestriction in C , that AMEs can only be implicitly converted to (valid) delegate types;eventhe followingcodefailsto \ntypecheck. object idFun = delegate (int x){ return x; }; The rule [IC2-Synth] can be read as follows: \nan expression e can be implicitly converted to t2 if it synthesizes a type t1 such that there is an implicit \nconversion from t1 to t2. The explicit conversion checking relation includes the im\u00adplicit conversion \nchecking relation; this corresponds to the allowing of redundant cast expressions in C . The rule [XC2-ImpConv] \ncaptures this inclusion. The rule [XC2-Synth] can be read as follows: an expression e can be explicitly \nconverted to t2 if it synthesizes a type t1 such that there is an explicit conversion from t1 to t2 (written \nt1 <:x t2).For our core calculus, this relation can be de.ned quite simply as follows. In the full language, \nthings are more complicated as, for example,C supports user-de.nedexplicit conversions [14, \u00a76.2.5]. \n 5.2 Checking translation The .rst translation we de.ne is the so-called checking translation, or c-translation \nfor short. This is de.ned over both expressions and statements. Analogous to type check\u00ading of FC2 expressions, \nthere are two c-translations of FC3 expressions: one for implicit conversions and one for explicit conversions. \nThe .rst judgement form is written G f e1 .i te11, and can be informally read as in con\u00adtext G, the FC3 \nexpression e1 can be implicitly converted to the type t yielding a FC2 expression e11. The rules for \nforming valid such judgements are given in Figure 3. As expected, there are a number of cases for dealing \nwith ex\u00adpressions that can not synthesize a type (the null constant, AMEs and the various forms of .-expressions). \nThere aretwoversionsof rules for .-expressions depending on whetherthey arebeing implicitlyconvertedtoadelegate \ntype (in which case they are translated to AMEs, i.e. code), or to the Expression type(inwhich casetheyaretranslated \ninto data). In the latter case, the translation function, written \u00ab -\u00bb, takes the .-expression as well \nas the context and produces an object that represents that .-expression (essen\u00adtiallyits abstractsyntaxtree).Wedonotgive \ndetailsofthis translation for lack of space. The secondjudgement form is written G f e1 .x te11, and \ncan be informally read as in context G, the FC3 expres\u00adsion e1 can be explicitly converted to the type \nt yielding a FC2 expression e11. This translation is de.ned in terms of the translation for implicit \nconversions. The rules for form\u00ad def x t1 <:t2 = t2 <: t1 ingvalid such judgementsare alsogivenin Figure3. \nG f e1 .i t e11 dtype(D)(t)= t0 . f G,x : t0 f s1 . f s11 [IC-Null] [IC-AME] G f null .i . null G f \ndelegate(t0 x){s1} .i D<t> delegate(t0 x){s11} dtype(D)(t )= t0 . t1 G,x0 : t0 f e1 .i t1 e11 [IC-ImpLamDel] \n G f (x0) => e1 .i D<t > delegate(t0 x){ return e11;} dtype(D)(t)= t0 . t1 G,x0 : t0 f e1 .i t1 e11 \n[IC-ExpLamDel] G f (t0 x0) => e1 .i D<t > delegate(t0 x){ return e11;} dtype(D)(t )= t0 . t1 [IC-ImpLamExpr] \n G f (x0) => e1 .i Expression<D<t >> \u00abG f (x0) => e1 : t0 . t1 \u00bb dtype(D)(t)= t0 . t1 [IC-ExpLamExpr] \n G f (t0 x0) => e1 .i Expression<D<t>> \u00abG f (t0 x0) => e1 : t0 . t1 \u00bb G f e1 .s t0 e11 t0 <: t1 [IC-Synth] \n G f e1 .i t1 e11 G f e1 .x t e11 G f e1 .sx G f e1 .i t1 e11 t0 e11 t0 <: t1 [XC-ImpConv] [XC-Synth] \nG f e1 .x t1 e11 G f e1 .x t1 e11 Figure 3. c-Translation of FC3 expressions The c-translation of FC3 \nstatements is given in Figure 4. These rules are pretty routine. The rules [C-EForeach1] and [C-EForeach2] \ntogether form a simpli.cation of the actual rules used inC 2.0 we do not consider the complications of \nsupporting foreach statements over objects that support the so-called collection pattern [14, \u00a78.8.4]. \nIn the rule [C-EForeach2] it is assumed that the synthesized type t2 is not an array type. The rules \nfor declarations, [C-IDecSeq] and [C-EDecSeq] highlight the difference between c-and s-translations. \nWe use an s-translation to synthesize the type for an implicitly typed declaration, and we usea c-translation \nfor anexplicitly typed declaration.  5.3 Synthesis translation The second translation we de.ne is the \nso-called synthesis relation, or s-translation for short. This is de.ned over just expressions; there \nare no rules for statements. Judgements are written G f e1 .s t1 e11, and can be informally read as in \ncontext G, the FC3 expression e1 synthesizes the type t1 yieldinga FC2 expressione11. The rules for forming \nvalid judgements aregivenin Figure5. The rules dealing with method invocation are the most complicated \nand so we shall explain them in detail. They make use of an auxiliary function mtype that is a map from \na type and a method name to a method group. Thus mtype(t, m) returns a method group that represents all \nthe candidate methods called m that are accessible from type t, i.e. it is a set of method signatures \nof the form C<XC ><tC >::m<Xm> : (tp) . f.Amethodsignatureis essentially a method descriptor without \nthe type arguments for the method (these have not been inferred or collected yet). The rule [S-ExpMethInv] \nde.nes the s-translation of an ex\u00adplicit method invocation e1.m<t1>(e2). First, we synthe\u00adsize a type \nfor e1 and use the auxiliary function mtype to build a method group MG. The next stage is to determine \nwhich of the methods in MG are actually applicable.For in\u00advocationexpressions,thisisquite straightforward:the \nappli\u00adcable methods are those whose number of formal parameters matches the number of actual arguments \nand whose number of generic type parameters matches the number of supplied type arguments.Weadd the type \nargument list <t1> to all the applicable methods from MG to form the applicable method group, AMG, which \nis hence a set of method descriptors. Next we need to resolve this set using overloading resolu\u00adtion \n[14, \u00a77.4.2]. Space prevents us from formalizing over\u00adloading resolution here, although it is relatively \nstraightfor\u00adward. Rather, we simply assume a function bestMD that, when given an applicable method group, \nreturns the best method descriptor(ifitexists).Assuming that thereisa best method descriptor, we c-translate \nthe actual arguments e2. G f s1 . fs11 G f se1 .s f1 se11 [C-Skip] [C-ExpStatement] G f ; . f ; G f \nse1; . f se11; G f e1 .i bool e11 G f s1 . fs11 G f s2 . fs21 [C-Cond] G f if (e1) s1 else s2 . f if \n(e11) s11 else s21 G f e1 .s t1 e11 ftype(t1,f)= t2 G f e2 .i t2 e21 [C-FAss] G f e1.f =e2; . fe11.f=e21 \nG f e1 .i t0 e11 [C-Return] [C-ReturnExp] G f return; . void return; G f return e1; . t0 return e11; \nG f e1 .s t2[] e11 x . dom(G) t1 <: t2 or t2 <: t1 G,x: t2 f s1 . fs11 [C-EForeach1] G f foreach (t1 \nx1 in e1) s1 . f foreach (t1 x1 in e11) s11 G f e1 .s t2 e11 t2 <: IEnumerable<t3> x . dom(G) t1 <: t3 \nor t3 <: t1 G,x : t3 f s1 . fs11 [C-EForeach2] G f foreach (t1 x1 in e1) s1 . f foreach (t1 x1 in e11) \ns11 G f e1 .s t2[] e11 x . dom(G) G,x : t2 f s1 . fs11 [C-IForeach1] G f foreach (var x1 in e1) s1 . \nf foreach (t2 x1 in e11) s11 G f e1 .s t2 e11 t2 <: IEnumerable<t3> x . dom(G) G,x : t3 f s1 . fs11 \n[C-IForeach2] G f foreach (var x1 in e1) s1 . f foreach (t3 x1 in e11) s11 G f s1 . fs11 G f e1 .s \nt1 e11 x . dom(G) G f var x = e1; s1 . f G, x : t1 f s1 . f t1 x = e11; s11 s11 [C-IDecSeq] G f e1 .i \nt1 e11 x . dom(G) G f t1 x = e1; s1 . f G, x : t1 f s1 . f t1 x = e11; s11 s11 [C-EDecSeq] Figure 4. \nc-Translation of FC3 statements The synthesized type of the method invocation is then the return type \nof the best method. The rule [S-ImpMethInv] de.nes the s-translation of an im\u00adplicit method invocation, \ni.e. where the type argument list is not supplied. In this case, we need to use type inference [14, \u00a720.6.4] \nto infer the type argumentlist. This process is dis\u00adcussed more fully in \u00a75.4 (including the breaking \nchanges that will be made in C 3.0) but for now we simply state the form of the type inference judgement. \nThis is written G; X f (e) ~ (t ) .. ., which can be informally read as in context G, the argument list \n(e) matches the formal pa\u00adrameter type list (t) with free type parameters X and infers the substitution \n.. A substitution is a function from type parameters to types. Thus in the rule [S-ImpMethInv] we perform \ntype inference for each method in the method group; the applicable method set then contains every method \nfor which type inference succeeds, along with the inferred type argument list. The rest of the rule is \nsimilar to [S-ExpMethInv]. Rule [S-ExpEMethInv] de.nes the s-translation of an ex\u00adtension method invocation \nof the form e1.m<t1>(e2). First we synthesize a type for e1 and check that there is no method m for that \ntype. (Hence, extension methods have strictly lower precedence than regular instance meth\u00adods.)We then \nuse an auxiliary function emtype to get the method group containing the candidate extension meth\u00adods. \nRecall from \u00a72 that extension methods are de.ned in non-generic, static classes. Moreover, the .rst parameter \nis used to pass in the original receiver object. We employ some shorthand and write elements of the method \ngroup as S::m<Xm><t1> : (tr,tp) . f. This denotes an exten\u00adsion method m de.ned in static class S with \ntype parame\u00adters Xm where the this formal parameter is of type tr, the other parameters are of type tp \nand the return type is f. The G f e1 .s f1 e11 [S-Bool] [S-Int] [S-Var] G f b .s bool b G f i .s int \ni G,x: t f x .s tx G f e1 .x t1 e11 G f e1 .s t1 e11 ftype(t1,f)= t2 [S-Cast] [S-FieldAccess] G f (t1)e1 \n.s t1 (t1)e11 G f e1.f .s t2 e11.f G f e1 .s D<t > e11 dtype(D)(t)= t0 . f G f e2 .i t0 e21 [S-DelInv] \n G f e1(e2) .s fe11(e21) def G f e1 .s te11 MG = mtype(t, m) def AMG = {C<XC ><tC >::m<Xm><ti> : (tp) \n. f | C<XC ><tC >::m<Xm> : (tp) . f . MG, G; Xm f e2 ~ tp[XC := tC ] '. ., . = [Xm . ti]} def M = C<XC \n><tC >::m<Xm><ti> : (tp) . f = bestMD(AMG) G f e2 .i tp[XC := tC ,Xm := ti] e21 [S-ImpMethInv] G f e1.m(e2) \n.s f[XC := tC ,Xm := ti] e11.M(e21) def G f e1 .s te11 MG = mtype(t,m) def AMG = {C<XC ><tC >::m<Xm><t1> \n: (tp) . f | C<XC ><tC >::m<Xm> : (tp) . f . MG, |Xm| = |t1|, |tp| = |e2|} def M = C<XC ><tC >::m<Xm><t1> \n: (tp) . f = bestMD(AMG) G f e2 .i tp[XC := tC ,Xm := t1] e21 [S-ExpMethInv] G f e1.m<t1>(e2) .s f[XC \n:= tC ,Xm := t1] e11.M (e21) def G f e1 .s te11 mtype(t, m)= \u00d8 MG = emtype(t, m) def AMG = {S::m<Xm><ti> \n: (tr,tp) . f | S::m<Xm> : (tr,tp) . f .. MG, G; Xm f (e1,e2) ~ (tr,tp) '. ., . = [Xm . ti]} def M \n= S::m<Xm><ti> : (tr,tp) . f = bestMD(AMG) G f (e1,e2) .i (tr,tp)[Xm := ti] (e11,e21) [S-ImpEMethInv] \n G f e1.m(e2) .s f[Xm := ti] S.M (e11,e21) G f e1 .s def te11 mtype(t, m)= \u00d8 MG = emtype(t,m) def AMG \n= {S::m<Xm><t1> : (tr,tp) . f | S::m<Xm> : (tr,tp) . f .. MG, |Xm| = |t1|, |tp| = |e2|} def M = S::m<Xm><t1> \n: (tr,tp) . f = bestMD(AMG) G f (e1,e2) .i (tr,tp)[Xm := t1] (e11,e21) [S-ExpEMethInv] G f e1.m<t1>(e2) \n.s f[Xm := t1] S.M (e11,e21) def MG = mtype(C<t >, .ctor) def AMG = {C<XC ><tC >::.ctor : (tp) | C<XC \n><tC >::.ctor : (tp) . MG, |tp| = |e1|} def C<XC ><tC >::.ctor : (tp) = bestMD(AMG) G f e1 .i tp[XC \n:= tC ] e11 [S-ObjCreation] G f new C<t >(e1) .s C<t> new C<t >(e11) .elds(C<t >)= {f : t1} G f ie1 \n.i t1 ie11 [S-ObjInit] G f new C<t>{f = ie1} .s C<t > ({C<t > x = new C<t>(); x.f = ie11; return x;})C<t> \nC<t > <: IEnumerable<t1> G f nae1 .i t1 nae11 [S-ColnInit] G f new C<t >{nae1} .s C<t > ({C<t > x= \nnew C<t >(); x.add(nae11); return x;})C<t> G f e1 .s t1 e11 anontype({f : t1}) += C [S-AnonObjCreation] \n G f new {f = e1} .s C new C(e11) CT = {ti | G f ei .s ti ei1, 1 = i = n} tb = best(CT )G f e1 .i tb \ne12 \u00b7\u00b7\u00b7 G f en .i tb en2 [S-ImpArray] G f new[ ]{e1, ... ,en} .s tb[] new tb[ ]{e12, ... ,en2} G f e1 \n.i te11 G,x1 : t1 f e1 .i t1 e11 [S-ExpArray] [S-VarAssign] G f new t[ ]{e1} .s t[] new t[ ]{e11} G,x1 \n: t1 f x1 = e1 .s t1 x1 = e11 Figure 5. s-Translation of expressions processofbuilding the applicable \nmethod group andover\u00adloading resolution is the same as in rule [S-ExpMethInv]. Rule [S-ImpEMethInv] de.nes \nthe s-translation of an ex\u00adtension method invocation where the type argument list has been omitted. Thisworks \nsimilarly astheexplicit method in\u00advocation case, except that we use type inference to generate the type \nargument list for the applicable method group. The s-translation of object creation expressions is de.ned \nin rule [S-ObjCreation]. As mentioned in \u00a73, we treat con\u00adstructors as methods with the special internal \nname .ctor. So, the rule is similar to that for explicit method invocation expressions. The [S-ObjInit] \nruleshowshowthenewC 3.0 objectinitial\u00adization expression is just compiled into a block expression that \n.rst intializes the object and then assigns to the .elds imperatively. The rule makes useofa c-translation \non intial\u00adization expressions which is de.ned as follows. c-translation of initializer expressions: G \nf new t{f = ie} .i te [C-ObjIE] G f {f = ie} .i te G f new t {nae} .i te [C-ColnIE] G f {nae} .i te The \nrule [S-ColnInit] similarly translates a collection initial\u00adization expression into a block expression \nthat .rst creates the object, and then uses the add method to systematically add the (translated) elements \nto the collection. This rule uses a small simpli.cation for succinctness: we write as an as\u00adsumption \nC<t> <: IEnumerable<t1>, by which we mean there exists a (single) type t1 such that the subtyping judge\u00adment \nis true. The rule [S-AnonObjCreation] de.nes the s-translation of an anonymous object creation expression. \nAs has been dis\u00adcussed earlier, anonymous objects are represented by pri\u00advately named classes. Moreover, \ntwo anonymous object ini\u00adtializers with matching .eld names and synthesized types will produce objectsofthe \nsame internal class.Forexample, the following code is type correct. var point1 = new { x=32, y=32 }; \nvar point2 = new { x=0, y=-1 }; if (point1 == point2) Console.WriteLine(\"Equal\"); Our rulemakes useofa \nglobal auxiliaryside-effecting func\u00adtion, anontype,whichisamapfromasetof .eld-typepairs to the private \nclass name that will represent instances of these objects. This function either generates a fresh class \nname for a set of .eld-type pairs that has not been seen be\u00adfore, or returns the pre-existing private \nclass name.We use the += notation to highlight this caching behaviour. The rule [S-ImpArray] .rst attempts \nto synthesize types for all the elementexpressions and collects these types intoa set (recall that not \nall expressions can synthesize a type). It then uses an auxiliary function best which is a (partial) \nfunction that maps a set of types, to the single, unique type from the inputsetto whichtherestoftheinputsetcanbeconvertedto \n(if sucha typeexists).If this best type doesexist,itis used in the translation to an explicitarray initialization, \nprovided that all the element expressions can be converted to this best type. This models the following \nbehaviourinC 3.0. var ex1 = new []{\"hello\", new object()}; // Creates an object array var ex2 = new []{new \nButton(), null}; // Creates a Button array var ex3 = new []{new Button(), \"hello\"}; // Fails -no best \ntype var ex4 = new []{null,null}; // Fails -no best type It is important to notice that there are no \nrules for the null constant, anonymous method expressions, or .-expressions. These are expressions that \ncan not have types synthesized for them. This re.ects some important restrictionsinC 3.0. For example, \nnone of the following declarations are type correct (as no type can be synthesized): var a1 = delegate(int \nx){ return x+1; }; var b1 = (int y) => y+1; var c1=(z) => new object(); var d1 = null;  whereas the \nfollowing are all type correct: Func<int,int> a2 = delegate(int x){ return x+1; }; var b2 = (Func<int,int>)((int \nx) => x+1); var c2 = (Func<int,object>)((z) => new object()); var d2 = (Button)null;  5.4 Type inference \nC 2.0 supports generic methods that can appear in classes which may themselves be generic or non-generic. \nConsider the following codeinC 2.0 [14, \u00a720.6.4]. public class Chooser { static Random rand = new Random(); \n public static T Choose<T>(T first, T second) { return (rand.Next(2) == 0) ? first : second; } } InC \na genericmethodinvocation canexplicitly specifya type argument list, or it can omit the type argument \nlist and rely on a process known as type inference to determine the type arguments automatically. Hence, \ngiven the code above it is possible to make the following invocations of the Choose method: int i = Chooser.Choose(5, \n213); // Calls Choose<int> string s = Chooser.Choose(\"foo\", \"bar\"); // Calls Choose<string> Whilst extremely \nuseful, there are a number of restrictions inthe supportoftype inferenceinC 2.0.The .rst restriction \nis known as completeness , and it ensures that a substitu\u00adtion must be found for every type parameter. \nConsider the following method declaration and code fragment: static void myfoo1<T>(int arg1){} myfoo1(42); \n// FAILS myfoo1<object>(42); // Ok The .rst call fails as nothing can be inferred for the type parameter \nT;and thus inference is incomplete. The second succeeds as a type argument is provided for T. The second \nrestriction inC 2.0 is known as consistency , and it ensures that if multiple substitutions have been \nin\u00adferredforatype parameter,these substitutionsmustbe iden\u00adtical. Consider the following method declaration \nand code fragment: static void myfoo2<T>(T arg1, T arg2){} myfoo2(\"hello\",new object()); // FAILS in \nC# 2.0 myfoo2<object>(\"hello\",new object()); // Ok The .rst method invocationfails as the typeinference \npro\u00adcess will generate two substitutions: {T .. string} and {T .. object}. As these substitutions are \nnot identical, then type inference fails. The second invocation succeeds, which demonstrates that an \ninference could have been made. The third restriction in C 2.0 is that arguments that are anonymous method \nexpressions do not participate in the type inference process. Consider the following method dec\u00adlaration \nand code fragment: static void myfoo3<T,U>(Func<T,U> arg1, U arg2){} myfoo3(delegate(int x){return x;}, \n42); // FAILS This code fails because nothing is inferred from the .rst argument as it is an AME, and \nwe only infer from the second argument the substitution {U .. int}. Hence, we have not infered anything \nfor the type parameter T,and type inference is incomplete. Space prevents us from a deeper analysis of \ntype inference (some further discussions can be found elsewhere [6]) but we shall make two important \nobservations that have an im\u00adpact on the work reported here. First, we observe that not allowing AMEs \nto participate in type inference would have catastrophic consequences for the LINQ style of program\u00adming. \nIn \u00a74 we detailed how query expressions are com\u00adpiled into standard query operator calls before typecheck\u00ading. \nMost of these make heavy use of .-expressions. As .\u00adexpressions are just syntactic sugar for AMEs, this \nwould mean that most queries would compile to method invoca\u00adtionsthatwouldfailtype inference!Inconclusion,to \nsupport the LINQ style of programming it is necessary to extend the rather limited formof type inferenceinC \n2.0 forC 3.0.For example,C 3.0 infers the type argument list <int,int> for the invocation myfoo3((int \nx) => x, 42). In addition, the consistency restriction in the C 2.0 type inference process has been \nrelaxed. If a set of possible types has been inferred for a type parameter, then C 3.0 simply requires \nthat there is a unique best type from this set to which all the other members of the set can be con\u00adverted \nto. This best type (if it exists) is then the inferred type. Hence the followingexpression typechecksinC \n3.0, inferring the type argument object for the expression myfoo2(\"hello\",new object()). It is important \nto note that the enhancement to the type infer\u00adenceprocess thatwill appearinC 3.0 representsa breaking \nchange to the language.Consider the followingoverloaded method declarations and code fragment: static \nvoid breaking<T>(Func<int,T> arg1, int arg2){} static void breaking<T>(Func<int,int> arg1, T arg2){} \nbreaking(delegate(int x){ return x; }, 42); InC 2.0, this invocation is resolved to the second method, \nas the .rstfails type inference.However,inC 3.0 thisinvo\u00adcation is ambiguous as the .rst method now passes \ntype in\u00adference (inferring the substitution {T .. int})and neither methodis considered betterthanthe \notherintheoverloading resolution phase. Asecond observation is that there is an awkward interaction between \ntype inference andoverloading resolution; consider the followingoverloaded method declarations and code \nfrag\u00adment: static void mybar<T>(int a, T b){} static void mybar<T>(int a, int b){} mybar(42,42); // \nPicks method 1 mybar<int>(42,42); // Picks method 2  In the .rst invocation, type inference succeeds \nfor the .rst overload of mybar,but is incomplete for the second. Hence, the compiler infers the type \nargument int and selects the .rst overload. If, as in the second invocation, the program\u00admer supplies \nthe inferred type argument explicitly the com\u00adpiler will actually select the second overload of mybar!This \nis because both methods are applicable, and the tie-breaking rules foroverloading determine thatthe second \nmethod has a better type signature. This impacts on our translation of FC3 as we need to deal with the \nchanges to type inference and yet wish the transla\u00adtion to preserve the semantics! There are a number \nof possi\u00adble solutionsbutthe most compactistoextend FC2 with ex\u00adplicit method descriptors. Whilst this \nmeans that FC2 is not a strict subsetofC2.0(muchlikeFGJisnota strict subset of GJ [16]), it is actually \nquite straightforwardto translate a FC2 program into an equivalentvalidC 2.0 program. 6. Properties In \nthis section we brie.y mention some properties of our translations of FC3 to FC2. We do not give any \ndetails of the proofs; they are all quite routine and will appear in a forthcoming technical report. \nOur main technical result is that the translation of FC3 into FC2 is type-preserving. In other words, \nif there is a transla\u00adtion then the resulting FC2 fragment is well-typed. THEOREM 1 (Preservationof typing). \n1. If G f e1 .i t1 e11 then G f e11 .i t1 2. If G f e1 .x t1 e11 then G f e11 .x t1 3. If G f s1 . \nfs11 then G f s11 . f 4. If G f e1 .s f1 e11 then G f e11 .s f1  Proof. By simultaneous induction over \nthe translation rela\u00adtions. Moreover, if we extend FC3 with block expressions and method descriptor invocations, \nthen we are able to show that our translations are essentially the identity function on well\u00adtyped FC2 \nprograms. THEOREM 2 (Conservativity). 1. If G f e1 .i t1 then G f e1 .i t1 e1 2. If G f e1 .x t1 then \nG f e1 .x t1 e1 3. If G f s1 . f then G f s1 . fs1 4. If G f e1 .s f1 then G f e1 .s f1 e1  Proof. \nBy simultaneous induction over the typing relations. 7. Related work There has been several decades of \nresearch on integrating databases and programming languages. Atkinson and Bune\u00adman [3]gave an in.uential \nsurveyin the late 1980s andPa\u00adton et al. [24]gave an updated surveyroughlya decade later. Given the space \nconstraints we cannot provide a thorough surveyofall thiswork,but hopefullyprovide enoughtogive some \nhistorical context forLINQ/C 3.0. Cook and Ibrahim [10] categorizesolutions to the impedance mismatch \nproblem according to their interface style: either orthogonal persistance or explicit query execution. \nLINQ is .rmly in the latter category. Orthogonalpersistanceallowsruntime objectstopersistbe\u00adyondasingle \nprogramexecution.Typically objects persist as long as they can be referenced by some persistant root \nob\u00adject. The beauty of such systems is that persistant data is pro\u00adgrammed transparently it is treated \nlike normal transient data.Thismakescode succinctbutplacesahugeburdenon the language runtime. Examples \nof persistant languages in\u00adclude Napier88 [23], OPJ [21], PJama [4], and Thor [19]. Languages providing \nexplicit query execution allow queries to be written in some specialized query language; the main advantage \nbeing that programmers can interactdirectly with the database engine. One simple way to provide a query \nlanguage is to use a preprocessor. SQLJ [26], for example, allows SQL commands to be embedded directly \nin Java code using the pre.x #sql. SQLJ compilation consists of two stages; .rst to pre-process the embedded \nSQL, and second the pure Java compilation. An alternative, and dominant, approach is to provide a stan\u00addardized \nAPI through which a programming language can accessadatabase engine.For .NET this mightbe ADO.NET andforJavathismightbe \nJDBC. Unfortunately, theseAPIs typically offer only weak compile-time guarantees as most database commands \nare passed as strings. Anumber of proposals have been made for better language\u00addatabase query integration \n(see, e.g. [1, 2, 22, 18, 15, 5]). In spiteoftheobviousadvantagesof these languages,it appears that their \nacceptance has been hampered by the fact that they are different from more mainstream application lan\u00adguages, \nsuchasJavaandC .Forexample, HaskellDB[18] proposesextensionstothelazy functional language,Haskell; andTL \n[22]isahybridfunctional/imperative language with advancedtypeand module systems.LINQbuildsonmuchof this \nprevious research experience and transfers it to a mod\u00adern, commercial virtual machine, programming language \nand IDE(Visual Studio) setting, as well as providing a so\u00adphisticatedbuilt-in object-relational mapping \ntool. 8. Conclusions The ROX impedence mismatch problem is a recurring headache for today s developers. \nRather than use a collec\u00adtion of ad-hoc tools and pre-processors, the next version of Visual Studio (code-named \nOrcas ) will contain extensions to the .NET framework to support the integration of non\u00adobject data. \nThe LINQ framework provides a very general pattern of operators to query data and provides four imple\u00admentations \nof this pattern: one for in-memory objects, one for in-memory XML data, one for external relational data, \nand one for external data that adheres to the ADO.NET En\u00adtity Data Model. In additional, both VB.NET \nand C will be extended to provide a convenient form of LINQ programming. In this paper we have studied \nformally the new features to appear in C . We have shown how the new query expressions of C 3.0 can be \ncompiledinto method calls and how the rest of the new C 3.0 language features can be translated into \nC 2.0. Our translation uses techniques from bidirectional type checking, and has been proven sound. Acknowledgements \nWe are gratefultoboththeC andVB teams for their hard work and support. We thank Andrew Kennedy, Eric \nLippert and Claudio Russo for various dis\u00adcussions about our formalization, and also to the anonymous \nreviewers who suggested a number of improvements. References [1] A. Albano,G. Ghelli, andR. Orsini.Types \nfor databases:the Galileo experience. In Proceedings of DBPL, 1989. [2] A. Albano,G. Ghelli, andR. Orsini. \nFibonacci:Aprogram\u00adming language for object databases. JournalofVery Large Data Bases, 4(3):403 444, \n1995. [3] M.P. Atkinson andP. Buneman. Types and persistence in database programming languages. ACM Computing \nSurveys, 19(2):105 170, 1987. [4] M.P. Atkinson, L. Daynes, M.J. Jordan, T. Printezis, and S. Spence. \nAn orthogonally persistent Java. SIGMOD Record, 25(4):68 75, 1996. [5]V. Benzaken,G. Castagna, andA. \nFrisch. CDuce:An XML\u00adcentric general-purpose language. In Proceedings of ICFP, 2003. [6] G.M. Bierman.FormalizingandextendingC \ntype inference. In Proceedings of FOOL, 2007. [7] G.M. Bierman, E. Meijer, andW. Schulte. The essence \nof data accessinC.. In Proceedings of ECOOP, 2005. [8] G.M. Bierman, M.J. Parkinson, and A.M. Pitts. \nMJ: An imperative core calculus for Java and Java with effects. Technical Report 563, University of Cambridge, \n2003. [9] J.A. Blakeley, D. Campbell, S. Muralidhar, and A. Nori. The ADO.NET entity framework: Making \nthe conceptual level real. SIGMOD Record, 35(4):32 39, 2006. [10] W.R. Cook and A.H. Ibrahim. Programming \nlanguages and databases: What s the problem? Unpublishedpaper, 2005. [11] G. Copeland and D. Maier. Making \nSmalltalk a database system. In ProceedingsofACM SIGMOD, 1984. [12] M. Flatt, S.Krishnamurthi, and M. \nFelleisen. Classes and mixins. In Proceedings of POPL, 1998. [13] M. Harren, M. Raghavachari, O. Shmueli, \nM.G. Burke, R. Bordawekar, I. Pechtchanski, andV. Sarkar. XJ:Facil\u00aditatingXML processing in Java. In \nProceedings of WWW, 2005. [14] A. Hejlsberg,S.Wiltamuth, andP. Golde. TheC Program\u00adming Language. Addison-Wesley, \nsecond edition, 2006. [15] H. Hosoya and B.C. Pierce. XDuce:Atyped XML processing language. In Proceedings \nofWebDB, 2000. [16]A.Igarashi,B.C. Pierce,andP.Wadler. FeatherweightJava: A minimalcore calculus forJava \nand GJ. ACMTOPLAS, 23(3):396 450, 2001. [17] A.KennedyandD. Syme.TransposingFtoC . Concurrency and Computation, \n16(7), 2004. [18] D. Leijen and E. Meijer. Domain Speci.c Embedded Compilers. In Proceedings of Conference \non Domain-Speci.c Languages, 1999. [19] B. Liskov, A. Adya, M. Castro, S. Ghemawat, R. Gruber, U. Maheshwari, \nA.C. Myers, M. Day, and L. Shrira. Safe and ef.cient sharing of persistant objects in Thor. In Proceedings \nof SIGMOD, 1996. [20] D. Maier. Representing database programs as objects. In Proceedings of DBPL, 1987. \n[21] A. Marquez, S. Blackburn, G. Mercer, and J.N. Zigman. Implementing orthogonally persistent Java. \nIn Proceedings of POS, 2000. [22]F. Matthes,S.M\u00a8u\u00dfig, and J.W Schmidt. Persistent polymor\u00adphic programming \ninTycoon: An introduction. Technical report, University of Glasgow, 1994. [23] R. Morrison, A.L. Brown, \nR.C.H. Connor, and A. Dearle. The Napier88 reference manual.Technical report, University of Glasgow, \n1989. [24] N.Paton, R. Cooper, H.Williams, andP.Trinder. Database programming languages. Prentice Hall, \n1996. [25] B.C. Pierce and D.N. Turner. Local type inference. In Proceedings of POPL, 1998. [26] J.Price. \nJavaprogramming with Oracle SQLJ. O Reilly, 2001. [27] D. Syme. Leveraging .NET meta-programming components \nfrom F#: Integrated queries and interoperable heterogeneous execution. In Proceedings of MLWorkshop, \n2006. [28] D.Yu,A.Kennedy, andD. Syme.Formalizationof generics for the .NET common language runtime. \nIn Proceedings of POPL, 2004. A. The query expression pattern In \u00a74we showedhowC 3.0 queryexpressions \nare compiled into a sequence of method invocations. Moreover, this com\u00adpilation occurs before typechecking. \nAs we pointed out, this means that any type that supports a pattern of methods can support queryexpressions.Infact,thereis \nconsiderable.ex\u00adibility in how a type can support this query expression pat\u00adtern: methods can be implemented \nas instance methods or extensions methods, and the methods can request delegates or expressions as .-expressions \nare convertible to both. The recommended query expression pattern for an arbitrary generic type C<T> \nis quite large. The subset that is required forthe translationofC 3.0 queryexpressionsisgiveninFig\u00adure \n6. (Note, it is possible to implement the pattern for non\u00adgeneric types as well.) The remaining methods \nof the pattern (which are not shown here) can only be called directly as methods fromC ,but other languagesmay \nchooseto target these with query expression syntax. The standardquery operators are an implementation \nof the query expression pattern for any type that implements the IEnumerable<T> interface. This implementation \nwill be included in the base class library. B. Featherweight C 2.0: further details In \u00a75.1 weintroduced \nour target language, FC2, which is in\u00adtendedtobea core featherweight fragementofC 2.0.We recall here \nthat FC2, unlike FC3, is not a precise subset of C 2.0, in that the method invocations use method descrip\u00adtors, \nand we also introduced a new syntactic form of block expressions. The latter is just for convenience, \nand could eas\u00adilybe removed (albeitatthe costofa moreugly translation). class C { public C<T> Cast<T>(); \n} class C<T> { public C<T> Where(Func<T,bool> predicate); public C<U> Select<U>(Func<T,U> selector); \nThe formerwas usedto circumventa problem arising from an interaction between overloading resolution and \ntype in\u00adference (this was explained in more detail in \u00a75.4). Again, this could be compiled away to leave \nstandard method invo\u00adcationsbutat theexpenseofclarity. In \u00a75.1 wegave the typechecking and typesynthesis \nrules for expressions. In Figure 7 we give the rest of the rules, namely type synthesis of statement \nexpressions, and type checking of statements. Given the translations of \u00a75, these rules are pretty straight\u00adforward. \nThe two new rules are worth noting. The rule [S2-MethInv],simply uses the types contained in the method \ndescriptor to synthesize the type of the invocation. The rule [S2-BlockExp] can be read as follows: the \nblock expression ({s})t synthesizes the type t provided that the statements s type check at type t (i.e. \nany expressions that are contained in return statements can be implicitly converted to type t). public \nC<U> SelectMany<U,V>(Func<T,C<U>> selector, Func<T,C<U>,V> resultSelector); public C<V> Join<U,K,V>(C<U> \ninner, Func<T,K> outerKeySelector, Func<U,K> innerKeySelector, Func<T,U,V> resultSelector); public C<V> \nGroupJoin<U,K,V>(C<U> inner, Func<T,K> outerKeySelector, Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector); \npublic O<T> OrderBy<K>(Func<T,K> keySelector); public O<T> OrderByDescending<K>(Func<T,K> keySelector); \npublic C<G<K,T>> GroupBy<K>(Func<T,K> keySelector); public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector, \n Func<T,E> elementSelector); } class O<T> : C<T> { public O<T> ThenBy<K>(Func<T,K> keySelector); public \nO<T> ThenByDescending<K>(Func<T,K> keySelector); } class G<K,T> : C<T> { public K Key { get; } } Figure \n6. The LINQ queryexpressionpattern G f se1 .s f1 G f e1 .s D<t> M = C<XC ><tC >::m<Xm><t1> : (tp) . \nf dtype(D)(t)= t0 . f G f e2 .i t0 G f e1 .i C<tC > G f e2 .i tp[XC := tC ,Xm := t1] [S2-DelInv] [S2-MethInv] \nG f e1(e2) .s f G f e1.M(e2) .s f[XC := tC ,Xm := t1] def MG = mtype(C<t>, .ctor) def AMG = {C<XC ><tC \n>::.ctor : (tp) | C<XC ><tC >::.ctor : (tp) . MG, |tp| = |e1|} def C<XC ><tC >::.ctor : (tp) = bestMD(AMG) \nG f e1 .i tp[XC := tC ] [S2-ObjCreation] G f new C<t >(e1) .s C<t> G f e1 .i t G, x1 : t1 f e1 .i t1 \nG f s . t [S2-ExpArray] [S2-VarAssign] [S2-BlockExp] G f new t[ ]{e1} .s t[ ] G, x1 : t1 f x1 = e1 .s \nt1 G f ({s})t .s t G f s1 . f1 G f se1 .s f1 G f e1 .i bool G f s1 . f G f s2 . f [C-Skip] [C2-ExpStatement] \n[C2-Cond] G f ; . f G f se1; . f G f if (e1) s1 else s2 . f G f e1 .s t1 ftype(t1,f)= t2 G f e2 .i \nt2 G f e1 .i t0 [C2-Return] [C2-FAss] [C2-ReturnExp] G f return; . void G f e1.f=e2; . f G f return \ne1; . t0 G f e1 .s t2[] x . dom(G) G f e1 .s t2 t2 <: IEnumerable<t3> t1 <: t2 or t2 <: t1 G,x : t2 f \ns1 . fx . dom(G) t1 <: t3 or t3 <: t1 G,x : t3 f s1 . f [C2-EForeach1] [C2-EForeach2] G f foreach (t1 \nx1 in e1) s1 . f G f foreach (t1 x1 in e1) s1 . f G f s1 . f1 G f e1 .i t1 x . dom(G) G,x: t1 f s1 . \nf [C2-EDecSeq] G f t1 x = e1; s1 . f Figure 7. Remaining type synthesis and type checking rules for \nFC2 \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Current real-world software applications typically involve heavy use of relational and XML data and their query languages. Unfortunately object-oriented languages and database query languages are based on different semantic foundations and optimization strategies. The resulting ''ROX (Relations, Objects, XML) impedance mismatc'' makes life very difficult for developers.</p> <p>Microsoft Corporation is developing extensions to the .NET framework to facilitate easier processing of non-object-oriented data models. Part of this project (known as \"LINQ\") includes various extensions to the .NET languages to leverage this support.</p> <p>In this paper we consider proposals for C<sup>#</sup> 3.0, the next version of the C<sup>#</sup> programming language. We give both an informal introduction to the new language features, and a precise formal account by defining a translation from C<sup>#</sup> 3.0 to C<sup>#</sup> 2.0. This translation also demonstrates how these language extensions do not require any changes to the underlying CLR.</p>", "authors": [{"name": "Gavin M. Bierman", "author_profile_id": "81100249578", "affiliation": "Microsoft Research, Cambridge, United Kingdom", "person_id": "PP39092802", "email_address": "", "orcid_id": ""}, {"name": "Erik Meijer", "author_profile_id": "81100295095", "affiliation": "Microsoft Corporation, Redmond, WA", "person_id": "P78826", "email_address": "", "orcid_id": ""}, {"name": "Mads Torgersen", "author_profile_id": "81100093407", "affiliation": "Microsoft Corporation, Redmond, WA", "person_id": "PP39113745", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297063", "year": "2007", "article_id": "1297063", "conference": "OOPSLA", "title": "Lost in translation: formalizing proposed extensions to c#", "url": "http://dl.acm.org/citation.cfm?id=1297063"}