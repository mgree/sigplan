{"article_publication_date": "10-21-2007", "fulltext": "\n Dependent Classes Vaidas Gasiunas Mira Mezini Klaus Ostermann Technische Universit\u00a8at Darmstadt, Germany \n {gasiunas,mezini,ostermann}@informatik.tu-darmstadt.de Abstract Virtual classes allow nested classes \nto be re.ned in sub\u00adclasses. In this way nested classes can be seen as dependent abstractions of the \nobjects of the enclosing classes. Express\u00ading dependency via nesting, however, has two limitations: Abstractions \nthat depend on more than one object cannot be modeled and a class must know all classes that depend on \nits objects. This paper presents dependent classes, a gener\u00adalization of virtual classes that expresses \nsimilar semantics by parameterization rather than by nesting. This increases expressivity of class variations \nas well as the .exibility of their modularization. Besides, dependent classes comple\u00adment multimethods \nin scenarios where multi-dispatched ab\u00adstractions rather than multi-dispatched methods are needed. They \ncan also be used to express more precise signatures of multimethods and even extend their dispatch semantics. \nWe present a formal semantics of dependent classes and a machine-checked type soundness proof in Isabelle/HOL \n[29], the .rst of this kind for a language with virtual classes and path-dependent types. Categories \nand Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features Classes and objects, \npolymorphism, inheritance; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Langu\u00adages \nOperational semantics General Terms Languages, Theory Keywords dependent classes, virtual classes, dynamic \ndis\u00adpatch, multiple dispatch, multimethods, variability 1. Introduction A virtual class is an attribute \nof an object. Analogous to vir\u00adtual methods in traditional object-oriented languages, virtual classes \nare de.ned within their enclosing object s class, can Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4eal, Qu\u00b4ebec, Canada. Copyright \nc &#38;#169; 2007 ACM 978-1-59593-786-5/07/0010. . . $5.00 be overridden and extended in subclasses, \nand are accessed relative to the enclosing object, using late binding. As a re\u00adsult, the actual de.nition \nof a virtual class referred to by a term obj.VC is not fully known at compile time. VC is some class \naccessible as the attribute with same name of the object obj;some of VC s features may be statically \nknown through the static type of obj, others may vary dynamically depending on the dynamic type of obj. \nVirtual classes and related mechanisms have proved use\u00adful in various situations: To de.ne families of \ncollaborating objects [10, 24], to develop large-scale extensible compo\u00adnents [30, 1, 33, 31], to address \nthe expression problem \u00adthe possibility to extend both the set of data structures and the set of operations \n[12, 11], and to modularize features that involve multiple classes [26, 1]. The downside is, however, \nthat virtual classes must be nested within other classes. Nesting requires to cluster to\u00adgether all classes \nthat depend on instances of a particular class, which may unnecessarily introduce coupling between them. \nIt also limits extensibility: When new classes need to be modeled as depending on the instances of an \nexisting class, one must modify that class and its subclasses. Further, nesting limits expression of \nvariability since the interface and the implementation of a virtual class can only depend on its single \nenclosing object. There are, however, various application scenarios, where classes that depend on arbitrarily \nmany objects are needed; in this paper, we consider one such scenario in more detail: Modeling aggregate \nobjects, the type and implementation of which depend on the types of their constituent parts. Our running \nexample is that of shapes (e.g., lines, boxes, circles, etc.), as well as various aggregations thereof \n(e.g., intersection or union) that are shapes again. The shapes live in different kinds of spaces (e.g., \n2D, 3D, etc.) and have different properties (e.g., solid, bounded, convex, etc.). The operations available \non a shape and their implemen\u00adtations depend on its properties and the space it lives in. The interface \nand implementation of aggregated shapes may also depend on their constituent parts, e.g., the union of \na solid shape with any shape is a solid shape, while the union of two bounded shapes is a bounded shape. \nHence, aggregated shapes must be modeled as objects that depend on more than one object, a feature that \nvirtual classes do not support. Fur\u00adthermore, nesting all kinds of shapes within space classes would \nintroduce unnecessary dependencies and restrict the extensibility of the system. To address these problems, \nwe propose a generalization of virtual classes, which we call dependent classes.A de\u00adpendent class is \na class whose structure depends on arbi\u00adtrarily many objects; this dependency is expressed explic\u00aditly \nover class parameters, rather than by nesting. In a sense, dependent classes can be seen as an combination \nof virtual classes with multi-dispatch [9, 3, 34, 6]. The notion of path\u00addependent types, as employed \nby most proposals for static type systems for virtual classes to keep track of the depen\u00addencies between \na type and the family or enclosing ob\u00adject, is generalized as well, such that types can depend on an \narbitrary number of objects described by paths. The contributions of this paper are: Dependent classes \nare motivated and the design of a language with dependent classes is discussed.  The vcn calculus a \nformal de.nition of the static and dynamic semantics of such a language is de.ned to\u00adgether with a machine-checked \nsoundness proof in Is\u00adabelle/HOL [29]. Since soundness proofs for languages with path-dependent types \nare usually either quite sketchy or quite complex1, it is hard to make sure that the proof is free of \nbugs. Indeed, we have discovered various bugs and unnecessary well-formedness conditions that we probably \nwould not have discovered with a hand-written proof. We hope that our Isabelle formalization and proof \ncan be reused and adapted by others working on variants of virtual classes. As further validation, we \nhave also im\u00adplemented an interpreter for vcn. The formalization, the proof, and the interpreter can \nbe downloaded at [15].  New results in the meta-theory of path-dependent types are presented. A completeness \ntheorem is formulated and proved which shows that the type system is optimal in a certain sense. Also, \nsurprisingly weak conditions under which the type system is decidable are identi.ed.  Apart from supporting \ndependency on multiple objects, the advantage of the proposed calculus over previous for\u00admalizations \nof virtual classes is a better balance between simplicity and decidability on one side and expressive \npower on the other side.  Dependent classes and the type system for them also contribute to languages \nwith multimethods. First, due to their enhanced subtype relation, they provide a more expressive dispatch \nsemantics. Second, they can be used to describe more precise signatures of multimethods.  The remainder \nof this paper is organized as follows. Sec. 2 presents and motivates dependent classes and ex\u00ad 1 For \nexample, the soundness proof of vc [12] is 12 double-column pages long; the print-out of the vcn proof \nis about 70 pages. plains their relation to virtual classes and to multimethods. A calculus that formalizes \nthe static and dynamic semantics of dependent classes is presented in Sec. 3. Properties of the calculus \n-soundness, decidability and completeness -are discussed in Sec. 4. Sec. 5 discusses possible variations \non the dispatch semantics. Related work is discussed in Sec. 6 and Sec. 7 concludes the paper. 2. Dependent \nClasses in a Nutshell This section presents a Java-like language with dependent classes by the example \nof modeling families of shapes. In Sec. 2.1, basic constructs for de.ning and re.ning depen\u00addent classes \nas well as type declarations using dependent classes are featured by considering only simple geometri\u00adcal \nobjects, e.g., points and vectors, that only need depen\u00addent classes with a single parameter. In Sec. \n2.2, aggregated shapes, e.g., unions and intersections of shapes, are consid\u00adered, featuring the need \nfor depending on multiple param\u00adeters and on the corresponding semantics. Sec. 2.3 and 2.4 discuss the \nrelation of dependent classes to virtual classes and multimethods, respectively. 2.1 De.ning and Re.ning \nDependent Classes When we talk about points and lines, we usually have some speci.c space in mind a \nplane or a three-dimensional space, Euclidean or non-Euclidean. The properties and the implementation \nof points and vectors depend on the kind of space to which they belong. For instance, points in a two\u00addimensional \nspace have only two coordinates while points in a 3D space also have a third coordinate. Further, when \nworking with points and lines, we would like to make sure that some restrictions are obeyed with respect \nto the enclosing space. For example, one can add a vector to a point and the result of this operation \nis again a point. For such an operation we would like to ensure that (a) the vector we add is from the \nsame space as the point being added to, and (b) the result is also a point in the same space. To see \nhow the requirements just outlined are modeled with dependent classes, consider the implementation of \nthe example in a Java-like language with dependent classes in Fig. 1. The variation of spaces is modeled \nby a simple inher\u00aditance hierarchy (lines 1 -7). Dependent abstractions such as points and vectors are \nmodeled by dependent classes Point (lines 9, 15, 19) and Vector (line 12) that take an instance of Space \nas a parameter. This parameterization has two implications. First, s is a .eld of Point, which can be \nused to retrieve the space the point belongs to; this .eld is immutable and its value is passed as a \nconstructor parameter. A more interesting implication is that Point is declared as a relative class, \nthe de.nition of which depends on its parameter s.There are several declarations of Point (lines 9, 15, \nand 19) -one for each kind of space. 1 abstract class Space { ... 2 abstract Point (s: this ) getOrigin \n(); 3 } 4 class 2DSpace extends Space { ... 5 Point(s: this ) getOrigin () { return new 2DPoint(this,0, \n0); } 6 } 7 class 3DSpace extends Space { ... } 8 9 abstract class Point(Space s) { ... 10 abstract \nPoint(s:s) add(Vector(s:s) v); 11 } 12 abstract class Vector(Space s) { ... 13 abstract Vector(s:s) \nscale(double d); 14 } 15 abstract class Point(2DSpace s) { 16 abstract double getX (); 17 abstract double \ngetY (); 18 } 19 abstract class Point(3DSpace s) { 20 abstract double getX (); 21 abstract double getY \n(); 22 abstract double getZ (); 23 }24 25 class 2DPoint(2DSpace s, double x, double y) extends Point \n{ 26 ... 27 double getX() { return x; } 28 double getY() { return y; } 29 Point(s:s) add(Vector(s:s) \nv) { 30 return new 2DPoint(s, x + v.getX(), y + v.getY()); 31 }32 } Figure 1. Points and vectors as \ndependent classes of a space More speci.c declarations implicitly inherit from the more general declarations, \nwhich means that the declarations of Point for 2DSpace (line 15) and 3DSpace (line 19) implic\u00aditly inherit \nfrom the declaration of Point for Space (line 9). Some operations on points and vectors are available \nfor any kind of space. For example, lines 10 and 13 declare generic methods to add a vector to a point \nand to multiply a vector by a scalar value. In addition, points in a plane or in a 3D space also have \ncoordinates and respective operations for accessing them. Besides implicit inheritance relations, explicit \nsubclasses of dependent classes can also be declared. For example, Point is an abstract class which can \nbe implemented in dif\u00adferent ways. 2DPoint is a sample implementation of a point in a plane using Cartesian \ncoordinates. Thus, we declare 2DPoint as a subclass of Point, and constrain its s parameter to 2DSpace, \nwhich means that 2DPoint is available only in planes, but not in other spaces. 2DPoint has additional \nparam\u00adeters, x and y, which are .elds that are initialized via con\u00adstructor parameters. It is required \nthat a subclass has all the constructor parameters of its superclasses, whereby the pa\u00adrameters are matched \nby name. Fields x and y are not used for dispatch in our example, we use them just as normal .elds for \nstoring state, but in principle they could also be used for dispatch. 1 Vector(s: v1.s) normal(Vector(s: \n3DSpace) v1, 2 Vector(s: v1.s) v2) { ... } Figure 2. Signature of normal method Similar to virtual classes, \ndependent classes can be used to describe types that depend on objects. Dependent types are never compatible \nif they depend on different objects [12]. That is, every instance of a Space class has its own universe \nof types and objects, and the type system can make sure that different universes will never be mixed, \neven if both Space instances are instances of the same variant of Space. To type generic methods such \nas add and scale correctly, we should be able to express that they operate on objects from the same space \n in terms of family polymorphism [10], we would like to express that these operations oper\u00adate on objects \nof the same family. Similar to languages with virtual classes, such typing is expressed in our approach \nby means of path-dependent types. The type Vector(s: s) in line 10, which is a short form for Vector(s: \nthis.s),is an exam\u00adple of a path-dependent type. It expresses that the object is a Vector whose .eld \ns is of type this.s. The type this.s is an example of a path type; these are types that have a single \ninstance, namely the object pointed to by the path expression. Hence, the declaration that some object \no is of type this.s means that o is equal to the object referred to by the expression this.s.Since this \nrefers to the receiver point object in the context of a call to the method Point.add(...),the type declaration \nVector(s: this.s) expresses that the parameter must be a vector that belongs to the same space as the \nreceiver point. For further examples of types in the language consider the method normal in Fig. 2; it \ntakes two vectors in a 3D space as parameters and returns a vector that is perpendicular to both of them. \nThe type declaration for the .rst parameter, Vector(s: 3DSpace), states that the .rst parameter can be \na vector of any 3DSpace. The type of the second parameter and the return type is Vector(s:v1.s); it is \nmore precise and states that these vectors must be from the same space as the .rst vector. 2.2 Dependency \non Multiple Parameters In general, dependent classes can be de.ned with an arbi\u00adtrary number of parameters, \nthereby enabling to model ab\u00adstractions that depend on several other abstractions. To illus\u00adtrate dependent \nclasses with multiple parameters and their bene.ts, consider an extension of our example. Imagine that \nwe develop a library of shapes, a fragment of which is shown in Fig. 3. There is a general Shape abstraction \nand a set of concrete shapes, some of them (e.g., Box) available for any space, others (e.g., Circle) \nspeci.c to some concrete space. The set of operations available on shapes and their implementations may \ndepend on the type of the space to which shapes belong; 1 abstract class Shape(Space s) { 2 abstract \nbool pointInside (Point(s: s) pt); 3 } 4 5 abstract class Bounded(Space s) extends Shape { 6 abstract \nBox(s: s) getBoundBox(); 7 } 8 9 abstract class Solid(Space s) extends Shape {10 abstract bool pointOnEdge(Point(s: \ns) pt ); 11 abstract double getContent (); 12 }13 14 class Box(Space s, Point(s:s) pt1, Point(s:s) pt2) \n15 extends Bounded, Solid { ... 16 bool pointInside (Point(s: s) pt) { 17 return pt1.lessEqual(pt) &#38;&#38;pt.lessEqual(pt2); \n 18 } 19 Box(s:s) getBoundBox() { return this ; } 20 } 21 22 class Box(2DSpace s, Point(s:s) pt1, Point(s:s) \npt2) { ... 23 double getContent () { 24 return (pt2 .getX() - pt1.getX()) * 25 (pt2.getY() - pt1.getY \n()); 26 } 27 } 28 29 class Box(3DSpace s, Point(s:s) pt1, Point(s:s) pt2) { ... 30 double getContent \n() { 31 return ... * (pt2 .getZ() - pt1.getZ ()); 32 } 33 } 34 35 class Circle(2DSpace s, Point(s:s) \nc, double r) 36 extends Bounded { ... } Figure 3. Shapes and their properties their signatures and implementations \nwill involve points and vectors of the space, so it is bene.cial to de.ne the shapes as dependent classes \nof Space and its subclasses. Shapes can have different properties: One can differen\u00adtiate between bounded \nand in.nite shapes, solid and mani\u00adfold shapes, closed and open shapes, etc. The properties of a shape \nmay determine the operations available on it: for example, we can compute the bounding box of a bounded \nshape, we can compute the content2 of a solid shape, or we can test whether a point is on its boundary. \nWe can model these variations by abstract subclasses of Shape,such as Bounded and Solid in Fig. 3. Concrete \nshapes then inherit from a subset of such abstract classes, depending on the properties that they have, \nand implement their operations. For example, a Box is both Solid and Bounded. More sophisticated shapes \ncan be built from primi\u00adtive shapes using various composition operations, such as union, intersection, \ndifference and inversion. Such compos\u00adite shapes can be described as objects that aggregate other shapes. \nFor an example, consider the class Union at line 1 of 2 Content is a generalized concept for volume or \narea depending on space dimensions. 1 class Union(Space s, Shape(s:s) s1, Shape(s:s) s2) 2 extends Shape \n{ ... 3 bool pointInside (Point(s:s) pt) { 4 return s1. pointInside (pt) || s2. pointInside (pt ); 5 \n} 6 } 7 8 class Union(Space s, Bounded(s:s) s1, Bounded(s:s) s2) 9 extends Bounded { ... 10 Box(s:s) \nboundBox() {11 return joinBounds(s1.getBoundBox(), s2.getBoundBox()); 12 }13 }14 15 class Union(Space \ns, Solid(s:s) s1, Shape(s:s) s2) 16 extends Solid { ... 17 double getContent () { return s1.getContent \n(); } 18 } 19 20 class Union(Space s, Shape(s:s) s1, Solid(s:s) s2) 21 extends Solid { ... 22 double \ngetContent () { return s2.getContent (); } 23 } 24 25 class Union(Space s, Solid(s:s) s1, Solid(s:s) \ns2) { ... 26 double getContent () { /* some approximation */ } 27 }28 29 class Union(2DSpace s, Box(s:s) \ns1, Box(s:s) s2) { 30 double getContent () { ... } 31 } 32 33 class Union(Space s, Solid(s:s) s1, s1 \ns2) { 34 double getContent () { return s1.getContent (); } 35 } 36 37 class Intersection (Space s, Shape(s:s) \ns1, Shape(s:s) s2) 38 extends Shape { ... } 39 40 class Difference(Space s, Shape(s:s) s1, Shape(s:s) \ns2) 41 extends Shape { ... } Figure 4. Composite shapes Fig. 4, which describes the union of two shapes.3 \nA union of two shapes is again a shape, so we declare Union as a subclass of Shape. Union is a dependent \ntype of Space,and using path-dependent types we declare that only the union of shapes from the same space \nis possible. The interface and subtype relations of a composite shape may vary depending on the type \nof the shapes it composes. For example, the union of two bounded shapes is again a bounded shape, while \nthe union of a solid shape with any shape is again a solid shape. In order to model such subtype relations, \nthe de.nition of Union has to vary with respect to two parameters. The declaration at line 8 of Fig. \n4 re.nes Union for the case when its parameters are both Bounded and states that this re.nement of Union \nhas a more speci.c superclass than the general de.nition, namely Bounded.To specify that the union of \ntwo shapes, of which at least one is 3 A union of two shapes is a shape consisting of the points of the \nboth shapes. 1 void test (Box(s: 2DSpace) b, Circle (s: b.s) c) { 2 Union(s: b.s, s1: b, s2: c) u = new \nUnion(b.s, b, c); 3 Box(s:b.s) b2 = u.boundBox(); 4 bool inside = u. pointInside (new 2DPoint(b.s )); \n5 double cont = u.getContent (); 6 } Figure 5. Test case for the union shape solid, is again solid, \ntwo declarations are given: One, where s1 is Solid and s2 is Shape (line 15), and another, where s1 is \nShape and s2 is Solid (line 20). In this way, the inheritance relations of Union depend on the types \nof the two parameters. Not only the interface, but also the implementation of a class may vary depending \non multiple parameters of it. Different operations of Union can be implemented at different levels of \nabstraction. For the pointInside method, an operation inherited from Shape, a generic implementation \nindependent of the parameter types is given in Line 3: Testing whether a point is inside a union is reduced \nto testing whether the point is inside one of its components (line 3). Other operations can be implemented \ndifferently for different parameter types of the class. For example, the content of a union of two shapes, \nonly one of which is solid, is equal to the content of the solid component (lines 17 and 22). If both \nshapes are solid, we can only provide an inef.cient approximate algorithm (lines 26), while a relatively \nef.cient algorithm can be given to compute the content of the union of two boxes (line 30) in a 2DSpace. \nPath types can also be used for re.ning dependent classes. For example, line 33 gives a re.nement of \nUnion for the case when a solid shape is combined with itself. This is expressed by specifying s1 as \nthe type of s2, which means that s2 must point to the same object as s1. For this special case, we can \nprovide very a ef.cient implementation of getContent method: It simply forwards the method call to s1. \nA concrete instance of a dependent class inherits all dec\u00adlarations that match the given parameter types. \nA class dec\u00adlaration matches when the dynamic types of the given pa\u00adrameters are subtypes of the types \nexpected by the declara\u00adtion. For example, in Fig. 5, line 2, we construct a union of a two-dimensional \nbox (solid rectangle) b and a circle c.The path-dependent type declarations make sure that the box and \nthe circle share the same space. A box is solid and bounded, while a circle is bounded, but not solid. \nFor this particular combination of the dynamic types of the parameters to the constructor of Union only \nthe declarations of Union at lines 1, 8, and 15 in Fig. 4 match. The types of .elds pt1 and pt2 in the \nBox types are not speci.ed, which means that the most general types of these .elds from the declarations \nof Box is assumed. In the example, the static type of u is Union(s: b.s, s1: b, s2: c), which is in fact \nthe most precise type available for the object that we assign to u. This type says that the object is \na Union of shapes b and c, and its space is same as the space of b. Given this type declaration, the \ntype checker can infer that u is an instance of all matching declarations of Union as well as their direct \nand indirect superclasses: Bounded, Solid and Shape. Any operation declared within any matching class \ndeclaration is available for u. Hence, the type checker will consider all calls on u in the method test \nas safe. If less information is available statically, the opera\u00adtional behavior will still remain the \nsame -we support true subtype polymorphism with late binding. For exam\u00adple, if the static type of the \nparameters b and c above would be Shape(s: Space) and Shape(s: b.s), respectively, the opera\u00adtional behavior \nof the methods would remain the same as the one in Fig. 5 (e.g., the same implementation of pointInside \nis executed), except that the calls to boundBox and getContent would be rejected by the type checker. \n 2.3 Dependent Classes and Virtual Classes Virtual classes can be encoded with dependend classes, just \nas single-dispatched methods can be encoded in a multi\u00addispatch language: Dependent classes with exactly \none pa\u00adrameter correspond to traditional virtual classes. A depen\u00addent class with only one parameter \ncan hence be encoded as virtual class by nesting it inside the declaration of the class it depends on.4 \nFor our example, this means that de.nitions of Point, Vector, Shape, and so on, must be nested within \nde.\u00adnitions of Space, 2DSpace and 3DSpace. However, such an encoding has a severe drawback, be\u00adcause \nnesting has a negative impact on software properties such as coupling and extensibility. Nesting requires \nto clus\u00adter all classes that depend on a particular class, thus introduc\u00ading redundant dependencies. \nFor example, Point and Vector must be implemented within the same class together with much more speci.c \nclasses, e.g., Shape and its concrete sub\u00adclasses. Furthermore, nesting limits extensibility: With each \nnew type of shape or some other class that depends on Space, the latter and its subclasses must be modi.ed. \nDependent classes do not have these problems, because they are de.ned outside the declarations of classes \nthey depend on. Because of the nested structure, virtual classes are con\u00adceptually seen as an inherent \npart of the enclosing class. Such a view limits the applicability of virtual classes, be\u00adcause there \nare situations, where a class de.nition may de\u00adpend on another class without being an integral part of \nit. For example, if we consider the Adapter design pattern [14], the implementation of an adapter may \ndepend on the type of its adaptee object. To express this dependency with virtual classes, we would have \nto de.ne adapters as nested virtual classes of adaptees. This obviously does not make sense: Adaptees \nwould know about their adapters, which contra\u00addicts the main design goal of the Adapter pattern. Hence, \nvirtual classes cannot be used for expressing dependencies of adapters on adaptees, if necessary. 4 There \nare variations in the semantics of different formalisms and lan\u00adguages supporting virtual classes, thus \nthe encoding possibilities are also different. More on this in Sec. 6. Since dependent classes can be \nde.ned outside the classes they depend on, they do not need to be considered as their logical part. This \nshift of view opens up new application areas for dependent classes in addition to situations where virtual \nclasses are useful [10, 24, 30, 31, 1, 33, 11, 26]. An adapter e.g., can be easily de.ned as a dependent \nclass of its adaptee, enabling polymorphic selection and dependent typing of the adapter. The adapter-adaptee \nrelation is also addressed by ex\u00adpanders [35], where an adapter is de.ned as an expander of its adaptee. \nIn some sense, expanders could be seen as dependent classes of the objects that they expand. How\u00adever, \nexpanders share the identity of the objects they ex\u00adpand, while dependent classes construct new objects, \nwhich can have a many-to-one relationship with their parameter ob\u00adjects. That is, by using dependent \nclasses one can create mul\u00adtiple adapter instances of the same type for the same adaptee. For illustration, \nconsider the situation where there are multi\u00adple views on some data model and adapters are used to adapt \nmodel classes to the abstractions of the view. If such adapters are stateful, an adapter object is needed \nfor each pair of a view and a data model object. Nesting also limits the possibilities to express variation. \nEvery class can only be nested inside one class; hence, varia\u00adtions can be expressed along one dimension \nonly. Dependent classes can vary along several dimensions simultaneously. For instance, we have demonstrated \nthat the interface and the implementation of Union depends on the dynamic type of two shapes.5 This cannot \nbe easily encoded in a model of virtual classes with strict hierarchical nesting. For an example of an \napplication, where dependency from types in different inheritance hierarchies is needed, consider again \nthe example of using adapters to adapt model classes to view abstractions. As long as there is a single \nview de.nition, single dependency of an adapter on its adaptee is suf.cient. However, one can envisage \nan inheritance hierar\u00adchy of views, expressing variations on how model elements are displayed. In this \ncase, the functionality of the adapters may also depend on the type of the view in addition to the type \nof the model element being adapted. Our experience with using CaesarJ to model such scenar\u00adios [1] shows \nthat it is indeed cumbersome to express de\u00adpendencies along two variation axes with virtual classes \none has to resort to some sort of conditional logic for com\u00adpensating limited dispatch power.6 In contrast, \nadapters that depend both on target and adaptee are naturally expressed by dependent classes with two \nparameters: one for the view and another for the adaptee (the data model object, in our case). 5 Union \ncould also be re.ned for different kinds of space. 6 In [1], we used a mechanism called dynamic wrapper \nselection to address this problem.  2.4 Dependent Classes and Multimethods Since dependent classes and \nmultimethods share similar se\u00admantics for dispatching functionality, the question arises as how they \ninteract in terms of language design. We believe that dependent classes generalize multimethods in two \nways. Application scenarios that typically use multimethods can bene.t from dependent classes in situations \nwhen op\u00aderations dispatched by multiple parameters need to be rei\u00ad.ed. Our running example could be seen \nas an application of dependent classes to reify union and intersection of Shapes, which would typically \nbe implemented as multi-methods. There can be different reasons for reifying operations: To postpone \ncomputation (Command design pattern[14]), to cache computation results, or to provide mutable attributes \nthat in.uence the computation. Our rei.cation of union was mostly driven by a design decision: In our \nscenario, a union of two shapes is not so much a computation, but rather an abstraction with its own \ninterface (e.g., we can compute its content, bounding box, etc.). One could envisage rei.cations of other \noperations. For example, consider a draw operation de.ned on Shape,which takes the output medium as a \nparameter (e.g. a screen, a PDF or some drawing format); we could reify it by constructing a ShapeDrawer \nclass that depends on two parameters the shape and the output medium. Such a class could have addi\u00adtional \ndisplay attributes as well, e.g., the color or line style that depend on some external input. The rei.cation \nof the draw operation would allow to enrich the drawing function\u00adality with additional behavior, e.g., \nthe capability to cache in\u00adtermediate computation results that are necessary for shape display (e.g., \na triangulation of a 3D object), and/or to ob\u00adserve changes in its shape to update the display. There \nis a second way in which dependent classes gener\u00adalize multi-methods. Standard multi-methods [6] use \nplain types, as illustrated in Fig. 6. Multi-methods using depen\u00addent rather than plain classes for type \ndeclarations are more powerful with respect to both static and dynamic semantics. 1 abstract Shape union(Shape \ns1, Shape s2); 2 Shape union(Box s1, Box s2) { ... }3 Shape union(Box s1, Circle s2) { ... } Figure 6. \nShape union as a standard multi-method First, dependent classes extend the type system and would allow \nfor more precise signatures of multi-methods. For example, in the signature of the union multi-method, \nthey could be used to require that only a union of shapes from the same space can be computed. The same \nconstraint cannot be statically stated and enforced in a language with multi\u00admethods and plain types. \nFurthermore, in such a language, one cannot express dependencies of the result type of a multi-method \non the types of its parameters. Such an explicit dependency declaration would allow the type checker \nto know e.g., that a union of a Box and a Circle is a solid and Figure 7. Types by which getContent \nis dispatched bounded shape, and thus it is safe to call on it methods that are available for both Solid \nand Bounded types (cf.Fig.5). Second, dependent classes also increase the expressive power of dispatch. \nThe dispatch of a multi-method selects the implementation of the method that is the most-speci.c among \nthose that match. Since selection and matching is done by comparing parameter types by the subtype relation, \nan extension of the subtype relation also extends the expres\u00adsive power of dispatch. For illustration, \nconsider the de.nitions of getContent in Fig. 3 and Fig. 4. They are available for a variety of types \nthat are depicted in Fig. 7 together with their subtype rela\u00adtions. The subtype relation of dependent \nclasses takes into account not only explicit inheritance relations (e.g., Box ex\u00adtends Solid); it also \nrecursively compares the types of the .elds and takes into account path types. In this respect, dis\u00adpatch \nbased on dependent classes can be seen as a variant of predicate dispatch [13] with predicates that express \n.eld types and identities between objects denoted by paths.  3. Semantics In this section, we present \na formal calculus that precisely describes the dynamic and static semantics of dependent classes. This \ncalculus is called vcn to indicate that it gen\u00aderalizes previous formalizations of virtual classes [12]. \nThe style and notation is similar to the one of Featherweight Java [17]. A bar above a metavariable denotes \na list: f stands for f1,...,fk for some natural number k =0.If k =0then the list is empty, denoted by \nE. Following common convention, tf represents a list of pairs t1 f1 \u00b7\u00b7\u00b7tk fk. List notation is also used \nto denote repeated application to all members of a list; for example, G f e : t denotes the conjunction \nof all G f ei : ti for each list index i. To keep the notation lightweight we assume a globally available \nprogram P.   3.1 Syntax The syntax of vcn is de.ned on the left-hand side of Fig. 8. We have made \na few design decisions to keep the calculus simple in order to focus just on the core semantics of de\u00adpendent \nclasses, and to ease the soundness proofs. For the informal explanation of the concepts and the examples \nin Sec. 2 we used an informal language that is close to the syntax of Java to make the examples more \naccessible to a broader public. Besides we used various language features that are not interesting from \na semantics perspective, but are useful for practical programming. For example, various pre\u00adde.ned types, \nsuch as int, double, String, and operations on them are not available in the formal calculus. In the \nfollow\u00ading, we explain the formal syntax and its differences from the informal language. A program P \nin vcn consists of multiple class declara\u00adtions. A class declaration, D, starts with a class name (note \nthat the class keyword is skipped), followed by a list of .eld declarations and the return type of the \nclass construc\u00adtor. The list of declared .elds also speci.es the list of con\u00adstructor parameters. A class \ncan have an arbitrary number of super-classes speci.ed in its extends clause. The body of a class declaration \ncontains its constructor expression, which is called when the class is instantiated. There is no special \nsyntactical category to encode meth\u00adods. As usual in formal accounts of virtual classes [32, 12], we \nuse the syntax of class declarations to encode both classes and methods. A method declaration is encoded \nin vcn by a class declaration: Method parameters are encoded as constructor parameters, the return type \nas the constructor return type and the implementation as the constructor ex\u00adpression. For normal classes, \ni.e., those that do not encode methods, we assume the expression this to be the default con\u00adstructor \nbody, i.e., the constructor simply returns the con\u00adstructed object. The default return type is the empty \npath E the path pointing to this. Method calls are encoded as con\u00adstructor calls. Multimethods can hence \nbe encoded by using class declarations as methods. In the calculus all declarations are at the top level, \nwhich means that it is not possible to nest methods within class dec\u00adlarations. However, the nested style \ncan be easily translated to the parametric style. The implicit this parameter of nested methods is replaced \nby an additional explicitly declared pa\u00adrameter. An example of such translation will be given at the \nend of the subsection. A path, referred to by p or q, is a sequence of .elds; it refers to the object \nthat is reached by navigating over the .elds in the sequence starting from this. As a special case, the \nempty path Erefers to this. A type, referred to by tor u, can be a class type C(f :t), apath p,or a value \nv.The class type C(f :t)represents all objects of C and its subclasses, whose .elds fi have values compatible \nwith the respective types ti. The only instance of   Syntax: P ::= D D ::= C(f : t): t extends C {e}p, \nq ::= f t, u ::= p |C(f : t) |v e ::= this |e.f |new C(f = e) |v v ::= C(f = v) C - class names f - .eld \nnames Context: G ::= C(f : t) |\u00d8 Computation: C(...fi = vi ...).fi '.vi (RED-FIELD) ... {e}.Select(C(f \n= v)) new C(f = v) '.[C(f = v)/this] e (RED-NEW) Congruence: e'.e' e.f '.e'.f (REDC-FIELD) e'.e' new \nC(...f = e...) '.new C(...f = e'...) (REDC-NEW) Select Declaration: \u00d8 fD .Match(C(f : v)) D .Select(C(f \n= v)) (SELECT) Figure 8. Syntax and operational semantics a path type is the object referenced by the \npath. A value type, v, has the value v as its only member. Types that contain paths are called relative \ntypes,as they are de.ned only relative to some object (referred to by this). On the contrary, absolute \ntypes are combinations of class and value types. For instance, Vector(s: v1.s) is a relative type, whereas \nVector(s: 3DSpace) is an absolute type. Most type relations of the calculus are de.ned relative to a \ntyping context G, which is either empty (\u00d8)or de.nes the type of this. Relative types make sense only \nin a non\u00adempty context, while an empty context can be used with absolute types. During static type checking \n(program well\u00adformedness), the context will always be non-empty, whereas during runtime checking (typing \nintermediate expressions during evaluation) the expression this does not occur (it is replaced by a value) \nand the context will always be empty. The calculus requires that in a class type the types of all .elds \nthat are available in this class are speci.ed (this re\u00adquirement is enforced in the well-formedness rules). \nIn the informal language we allow to omit some of the .eld type annotations. In this case, the .eld types \nfrom the declaration of the class are assumed. In case of multiple class declara\u00adtions, we assume the \ntypes of the most general declaration of the class as the default type of that .eld. An alternative so\u00adlution \nwould be to mark one of the class declarations which contains the default .eld types explicitly with \nsome default keyword. Like Featherweight Java [17], vcn supports only func\u00adtional style object-oriented \nprogramming. Classes have only immutable .elds that are at the same time their constructor parameters. \nThe body of a constructor is hence an expres\u00adsion, rather than a list of statements. An expression e \ncan be this, a .eld access, a class con\u00adstructor call, or a value v.We use the new keyword to mark constructor \ncalls and distinguish them from values. In the formal syntax, constructor calls take parameters by name, \nrather than by position. This makes it easier (in fact: trivial) to de.ne the mapping from constructor \nparameters to .eld names, which would otherwise be cumbersome in the pres\u00adence of multiple inheritance. \n1 2 Shape(s: Space) extends E : E { this } 3 pointInside (sh: Shape(s:Space ), pt : Point (s :sh. s )) \n4 5 : Bool { False } 6 Union(s: Space, s1: Shape(s: s ), s2: Shape(s: s )) extends Shape 7 8 : E { this \n} 9 pointInside ( 10 sh: Union(s:Space,s1:Shape(s:sh . s ), s2:Shape(s:sh . s )), 11 12 pt : Point (s \n:sh. s )) : Bool {new or(a = new pointInside (sh=sh.s1, pt=pt ), 13 b= new pointInside (sh=sh.s2, pt=pt \n)) 14 } Figure 9. Example in the formal syntax Avalue v is a class name together with values for its \n.elds. Values can be used both as expressions and as types, but they are not part of the written syntax: \nThey occur as expressions only in intermediate programs during rewriting and as types of intermediate \nprograms containing values (we use a small-step operational semantics). In the informal language we speci.ed \ncertain classes and methods as abstract. The informal meaning for a class being abstract is that it cannot \nbe instantiated, while an abstract method has no implementation, but it can be called. How\u00adever, formalization \nof abstract dependent classes is post\u00adponed for future work. Nevertheless, we decided to use abstract \nannotations in the informal language, because they signi.cantly increase the understandability of the \nexam\u00adples. When converting the examples to the calculus, abstract methods must be encoded as concrete \nmethods with a default implementation. For illustrating the encoding of the informal language in the \ncalculus, consider the example in Fig. 9. It shows how the Shape declaration from Fig. 3 and the .rst \ndeclaration of Union from Fig. 4 could be encoded in the formal syn\u00adtax. The implementations of the pointInside \nmethod are taken out from the class declarations and declared on the top level. Their implicit this parameter \nis encoded by an explicit sh pa\u00adrameter with an appropriate type. The declarations of Union and Shape \nare extended with the default constructor and the default return type. The declaration of Shape also \nreceives an extends clause with an empty list of parents. The abstract pointInside method of Shape is \nreplaced by a method with a default implementation. The method calls in the implemen\u00adtation of pointInside \nfor Union are replaced by corresponding constructor calls.  3.2 Operational Semantics The operational \nsemantics in small-step style is given on the right-hand side of Fig. 8. There are only two computation \nrules: .eld access (RED-FIELD) and constructor call (RED-NEW). The other two reduction rules are just \ncongruence rules. Field access applied to a value, C(...fi = vi ...),is resolved by looking up the value \nof the .eld. The reduction of a constructor call uses the Select relation to select a declaration of \nclass C for the given parameter values v . The Select relation is responsible for selecting one of the \ndeclarations that match the given parameter values. The set of matching declarations is de.ned by the \nMatch relation, which will be discussed in Sec. 3.5. Intuitively, a declaration matches a given set of \nparameter values to a constructor call, if the types of these parameter values are more speci.c than \nthe corresponding .eld types of the declaration. Once a matching declaration is selected, the evaluation \nproceeds with the expression of the selected class declara\u00adtion e, whereby this in eis replaced by the \nvalue of the con\u00adstructed object. The de.nition of Select determines the dispatch strategy. The non-deterministic \nstrategy [5] in Fig. 8 (any matching declaration can be selected) is the most general de.nition that \nis suf.cient to prove soundness of the calculus. We have proved that any de.nition for Select, that ful.lls \nthe follow\u00ading condition is sound: Whenever a well-formed type has any matching declarations, then the \nselection for this type succeeds and selects one of the matching declarations. Dif\u00adferent choices in \nthe design space of the dispatch mechanism will be discussed in Sec. 5. 3.3 Path Normalization and Type \nEquivalence To determine whether two dependent types are equivalent, it is necessary to de.ne an equivalence \nrelation on those kinds of expressions that types may depend on. Type systems that allow types to depend \non arbitrary, possibly non-terminating, expressions are often undecidable. Types in vcn may only depend \non path expressions, and for the latter a decidable equivalence relation can be de.ned, as shown in Fig. \n10. Two paths are equivalent (rule c-PATH)ifthey have the same normal form; the de.nitions for type equivalence \n(rules c-VALUE, c-CLASS,and c-PATH) just propagate path equivalence to the type level. Intuitively, a \npath is in a normal form, if neither the path itself, nor any part of it, are declared as aliases of \nother paths. Accordingly, path normalization (rules .-FIELD1, .-FIELD2) can be seen as the process of \neliminating alias paths. To normalize a path, declarations of .eld types from the context are used: For \neach path that is valid in the con\u00adtext, we can determine a type which is declared as its bound in the \ncontext (see path bound rules in Fig. 10). The bound of a normalized path is always a class type, because \nonly class types are allowed in typing contexts. For illustration, consider the context Union(s: Space, \ns1: Shape(s:s), s2: Shape(s:s)). The class type Shape(s:s) is de\u00adclared in it as the bound of the path \ns1; by navigating further in the context, we determine that the bound of s1.s is the path s (see rule \n.-FIELD), which means that s1.s is declared as an alias of s and can hence be normalized to s. An excerpt \nof the derivation of this path normalization is shown below: ... ... ... Gf s1 s1 Gf s1 . Sha pe(s:s) \nGf s . Space Gf E E Gf s1.s . s Gf s s (.-F) ( -F1) G=Union(s: Space, s1: Shape(s:s), s2: Shape(s:s)) \nf s1.s s ( -F2) We have proved the following theorem which character\u00adizes the meaning of path equivalence: \nTwo paths are equiv\u00adalent if and only if they are indistinguishable by the opera\u00adtional semantics in \nall extensions of the program. The only if direction is required for type soundness; the if direc\u00adtion \nis a completeness property which states that the path normalization is optimal, i.e., any bigger path \nequivalence relation would be unsound. We give a formal statement of the completeness property in Sec. \n4.2.  3.4 Type Translation Fig. 11 de.nes the translation of a type trelative to another type u. Intuitively, \nthe translation of a type trelative to ucan be thought of as reinterpreting t by assuming u as the type \nof this; technically, it is achieved by replacing the occur\u00adrences of E(the path pointing to this)by \nu. Type translation is needed to adapt types from a non-local context to the local context. For instance, \nthe declared types of constructor pa\u00adrameters need to be translated to the context of a constructor call. \nTwo kinds of translations are de.ned in Fig. 11: strong translation denoted by [t], and weak translation \ndenoted u by Itl. Whereas strong translation only allows to replace u Ewith a path ([\u00b7]-PATH)ora value([\u00b7]-VALUE), \nweak trans\u00adlation additionally allows to replace Ewith a class type (I\u00b7l\u00ad Path Bound: C(f : t) f E . \nC(f : t) (.-THIS) G f p p ' G f p ' . C(f : t) G f p.fi . ti (.-FIELD) Path Normalization: G f E E G \nf p.f . C(f : t) G f p p ' G f p.f p ' .f ( G f p.f . p ' G f p ' p '' G f p.f p '' ( ( -THIS) -FIELD1) \n-FIELD2) Type Equivalence: G f p p '' G f p ' p '' G f p c p ' (c-PATH) .i. ti c t ' i G f C(f : t) c \nC(f : t ') (c-CLASS) G f v c v (c-VALUE) Figure 10. Path-and Type Equivalence  Strong Type Translation: \n[p ']p = p.p ' ([\u00b7]-PATH) .i. [ti]t = t ' i [C(f : t)]t = C(f : t ') ([\u00b7]-CLASS) [v]t = v ([\u00b7]-VALUE) \n[E]v = v ([\u00b7]-VALUETHIS) [p]ti = t ' [fi.p]C(f:t) = t ' ([\u00b7]-CLASSFIELD) [p]vi = t ' [fi.p]C(f=v) = t \n' ([\u00b7]-VALUEFIELD) Weak Type Translation: [t ']t = t '' It ' lt = t '' (I\u00b7l-WEAKEN) .i. Itilt = t ' i \nIC(f : t)lt = C(f : t ' ) (I\u00b7l-CLASS) Iplti = t ' Ifi.plC(f:t) = t ' (I\u00b7l-CLASSFIELD) IElC(f:t) = C(f \n: t) (I\u00b7l-CLASSTHIS) Figure 11. Type translation  CLASSTHIS). If both [t]and Itl are de.ned for some \nuu types u and t then [t]= Itl holds. uu Strong translation is used in situations where replacing the \nassumed type of this by a subtype must not change the result, such as the expected type of a constructor \nparameter the constructor call must still be valid when the type to be instantiated is a subtype of what \nis statically known. Weak translation is used where this strong guarantee is not needed, such as for \na .eld access.  3.5 Subtyping Subtyping rules are shown in Fig. 12. Subtyping has deliber\u00adately been \nde.ned in an algorithmic style in order to demon\u00adstrate decidability. In particular, there is no subsumption \nor transitivity rule; rather, transitivity follows as a lemma. Two equivalent types are subtypes of each \nother (<:-EQUIV). This is the only rule that accepts a path or a value as a supertype: The value itself \nis the only subtype of a value type and a subtype of a path must be an equivalent path. The comparison \nof a value type with a class type (<:-VALUECLASS) is de.ned in terms of comparing two class types by \nreplacing the value with the most speci.c class type that is compatible with it. The comparison of a \npath p with a class type (<:-PATHCLASS) is the most sophisticated subtyping de.nition. The comparison \nis reduced to a class type comparison. For this purpose, the most speci.c class type that is a supertype \nof p must be constructed. A class type for p could be com\u00adputed as the bound of the normalized p. However, \nthis type is too weak to type-check many interesting programs. For illustrating the issue, consider the \nfollowing example: 1 2 parallel (v1: Vector (s : Space ), v2: Vector (s : v1.s )) : Bool {...} 3 test \n(v: Vector (s : Space)) : Bool { parallel (v, v ); } The function parallel tests if two vectors are parallel. \nIt expects two vectors from the same space as parameters. The function test calls parallel to check \nif a vector is parallel to itself. If we use the path bound as discussed above, this Subtyping: Match \nDeclarations: G ftct ' G ft<: t ' (<:-EQUIV) D .P C(f : t ')= Sig(D) .i..t '' .[t ' i]C(f:t) = t '' . \nG ft '' OK . G fti <: t '' .i..j.f ' j = fi . G ft ' j <: ti C .Parents(G,C ' ,f ' : t ' ,\u00d8) G fC '(f \n' : t ') OK G fC '(f ' : t ') <: C(f : t) (<:-CLASS) G fD .Match(C(f : t)) (MATCH) Auxiliary De.nitions: \nSig(C(f : t): uextends C{e})= C(f : t) (SIG) G fp p ' G fp ' .C '(f ' : t ') G fC '(f ' : t ') OK G fC \n'(f ' : p ' .f ') <: C(f : t) G fp<: C(f : t) (<:-PATHCLASS) G fC '(f ' : v ') <: C(f : t) G fC '(f ' \n= v ') <: C(f : t) (<:-VALUECLASS) C(f : t) ....P .i,j.i = j .fi = fj Fields(C)= f (FIELDS) f ' = Fields(C) \nf ' .f .i,j.(fi = f ' j ) .(ti = t ' j ) MakeType(C,f : t)= C(f ' : t ') (MAKETYPE) Parents: Parents(G,C,f \n: t,S)= {C}.( C/.S/\\S Parents(G,C ' ,f : t,S.{C})) where S ' '' i '' (PARENTS-DEF) Figure 12. Subtyping \n = {C |G f...extends C call would not pass the type checker: The actual type of the second argument \npassed to parallel is v, while its formal type, translated to the current context, is Vector(s: v.s). \nThe bound of v in the context of the call is Vector(s: Space) (as speci.ed in the declaration of test), \nwhich is not a subtype of the formal type Vector(s: v.s). For this reason, the type of .elds of C '(f \n' : t ') are further specialized. We know that each .eld f ' actually has the type '' p ' .f '. Hence, \nby substituting each t for p.f ', a more speci.c ii class type is constructed, which is still a supertype \nof p. The resulting type is .nally compared with C(f : t ).In the example, Vector(s:Space) (the bound \nof v) is specialized to Vector(s: v.s). Let us now focus on the rule for comparing class types (<:-CLASS) \nin Fig. 12. For a class type C '(f ' : t ') to be a subtype of class type C(f : t ) , it must be well-formed \nin G (to be de.ned later), the types of the corresponding .elds must be more speci.c, and C must be a \nparent of C '(f ' : t '). The function Parents(G,C,f : t,S ) determines all par\u00adents of class C relative \nto .eld types f : t in the context G. The function MakeType constructs a valid type from a class C and \n.eld types f : tby selecting only those .elds that are declared for class C. The idea of the algorithm \nimplemented by the function Parents(G,C,f : t,S ) is to collect super\u00adclasses from all the declarations \nof C that match the given .eld types, and then recursively collect the parents of these superclasses. \nFurther, a class C is also considered a parent of itself. For example, the parents of Union for .eld \ntypes  ....Match(MakeType(C,f : t))} [s: 2DSpace, s1: Shape(s:s), s2: Solid(s:s)] are Solid, Shape,and \nUnion. The last parameter of the Parents function is an accu\u00admulator that remembers the classes already \nvisited by the algorithm. By checking that no class is visited twice, ter\u00admination is ensured even in \nthe presence of cyclic inheri\u00adtance relations. Since parents of a class are relative to the types of \nits .elds, it can happen that for some type t holds ' G f C(f : t) <: C '(f : t), for another type t \nwe have '' G fC '(f : t ') <: C(f : t ') and for yet another type t both relations may hold simultaneously. \nThe relation Match de.nes the set of class declarations that match a class type C(f : t ). It isusedtodetermine \nwhich declarations contribute to a given class type. Intu\u00aditively, a declaration Dmatches a class type, \nif the type is of the same class as the declaration and the type is compatible with the type of this \nassumed by the declaration. A declara\u00adtion assumes that the type of this is at least as speci.c as the \nsignature of the declaration (see Fig. 12 for the de.nition of Sig). For a type C(f : t ) to be compatible \nwith the signature ' C(f : t '), the types t must be more speci.c than the types t . However, the types \nt are de.ned relative to G, while ' the declared types t are valid only in the context of the declaration. \nThus, to compare these types, the declared types need to be translated to types relative to G. For a \ndeclaration D to match C(f : t ), which is relative to G, the latter should be suitable as the type of \nthis in the context of the ' declaration. Hence, we can use C(f : t ) to translate t to types relative \nto G; the translated types, t '', should be super\u00adtypes of the corresponding types from t. '' Strong \ntranslation guarantees that the translated types t are equivalent to t '. To illustrate why strong translation \nis needed for matching, consider matching type u, which de\u00adscribes a Union of two arbitrary shapes, against \nD-the most general declaration of Union, which expects two shapes from the same space: u=Union(s:Space, \ns1: Shape(s:Space), s2: Shape(s:Space)) D=Union(s:Space, s1: Shape(s:s), s2: Shape(s:s)) The declaration \nDshould not match u, because its sig\u00adnature is more speci.c than u; it requires that this.s1.s = this.s2.s \n= this.s, which cannot be ensured by assuming this to be u. Dis not included into the set of matching \ndecla\u00adrations of u, because strong translation [Shape(s:s)]fails. u If weak translation were used instead, \nDwould incorrectly match, because IShape(s:s)l = Shape(s:Space). u We conclude this sub-section by a \nshort consideration of the dependency of the operational semantics on the type sys\u00adtem. Since Match is \nalso used in the operational seman\u00adtics (Select rule in Fig. 8), the question raises how much the operational \nsemantics depends on the type system. The answer is that only a small subset of the typing rules is ac\u00adtually \nneeded in the operational semantics. This is because the type to match in Fig. 8 is always a value type \n(a value used as type). Translation of any type relative to a value al\u00adways produces an absolute type \nthat does not contain paths. This means that for the operational semantics we just need to compare values \nwith absolute types and never have to deal with paths.  3.6 Expression Typing and Well-Formedness Fig. \n13 speci.es type assignment for expressions. The type of this is the empty path E (TYPE-THIS). As usual \nfor a small-step semantics, we also need a typing rule for values. The type of a value is the corresponding \nvalue type (TYPE-VALUE). Since values occur only during execution, this rule is only used for runtime \ntype checking, i.e., for the preserva\u00adtion theorem (Sec. 4.1). Typing of a .eld access expression (TYPE-FIELD)is \nper\u00adformed by .rst computing the type tof the pre.x eand then translating the type frelative to t. Weak \ntranslation produces the most speci.c type that captures all possible objects when navigating from any \nobject of type tover .eld f. For a constructor call expression (TYPE-NEW), the types of the actual parameters \nare computed. If there is any class '' declaration that matches these types, the return type t , which \nis identical for all declarations of a class (as stated by the WF-PROG rule), is translated to the appropriate \ncon\u00adtext (assuming the type of the constructed object as the type of this) and returned as the type of \nthe expression. Again, weak translation is used, because it is safe to assign a more general type to \nan expression, if the precise type cannot be described. The rules for well-formed types check (a) whether \nall paths exist in the given context (WF-PATH) by using path normalization and bounding, and (b) whether \nall classes exist (WF-CLASS) with matching .eld names.7 A class declaration is well-formed (WF-DECL), \nif all type declarations are well-formed in the context of the dec\u00adlaration. The constructor expression \nmust be well-typed and its type must be a subtype of the declared return type. The set of .elds in the \nclass declarations must include all .elds of direct superclasses. Further, it is required that values \nare not used in the types of .elds. This ensures the property that the bound of a normalized path is \nalways a class type. Finally, two conditions are imposed on a program P in order for it to be well-formed \n(rule WF-PROG): (a) all declarations must be well-formed, and (b) all declarations of the same class \nmust have the same sets of .elds and identical return types. 4. Properties of vcn In this section, meta-theoretical \nproperties of vcn will be dis\u00ad cussed: The soundness, the decidability, and expressiveness of the type \nsystem.  4.1 Soundness We have used the standard method to prove the soundness of the calculus by a \nprogress and a preservation theorem [36]. The progress theorem states that every well-typed expression \nin a well-typed program is either a value or can be further reduced. The preservation theorem ensures \nthat if well-typed ' expression eis reduced to e ', then the type of e is a subtype of the type of e. \nTHEOREM 1 (Progress). If P OK and \u00d8 f e : tthen ' .v.e= v or .e ' .e'. e THEOREM 2 (Preservation). If \nP OK and \u00d8 f e: t and ' e'. e ''' ' then .t.\u00d8 f e : t . \u00d8 f t<: t The proofs of both theorems have been \nveri.ed by the Isabelle/HOL proof assistant and are available for download at [15]. To understand why \nthese theorems hold, we present a few key lemmas from the proof. Lemma 1 justi.es the soundness of substituting \nthis by the newly constructed object in (RED-NEW) (Fig. 8). It states that the type t ' of the expression \nafter the substitution is a subtype of the type of the expression before the substitution. The substitution \nof this in echanges the assumed type of this in e, thus the old type of ehas to be translated relative \nto the v -the new type of this.The assumption \u00d8 f v<:[u]should be read as: vis appropriate v as value \nof this in the context where the type of this is u. 7 The auxiliary function Fields is de.ned in Fig. \n12. Expression Typing: G f EOK G f this : E (TYPE-THIS) G f e: t Iflt = t ' G f t ' OK G f e.f : t ' \n(TYPE-FIELD) G f e: t G f C(f : t) OK G f C(f : t '): t '' .... Match(C(f : t)) It '' lC(f:t) = t ''' \nG f t ''' OK G f new C(f = e): t ''' (TYPE-NEW) G f v OK G f v : v (TYPE-VALUE) Well-Formed Types: Well-Formed \nDeclaration: G f p p ' G= C(f : t) G f p ' . t G f tOK G f C(f : t) OK G f tOK G f pOK (WF-PATH) tdoes \nnot contain values G f e: t ' G f t ' <: t Fields(C)= f .i.G f ti OK G f C(f : t) OK (WF-CLASS) .i,f \n' . Fields(Ci)= f ' . f ' . f C(f,t): textends C {e} OK (WF-DECL) G f C(f : v) OK G f C(f = v) OK (WF-VALUE) \nWell-Formed Program: .D . P. D OK . . .D,D ' . P : D = C(f : t): t... . D ' = C(f ' : t '): t ' ... . \nf = f ' . t= t ' . . P OK (WF-PROG) Figure 13. Typing  LEMMA 1 (Substitution). If u f e : t and \u00d8 f \nv<:[u] v and \u00d8 f v OK ' '' then .t.\u00d8 f e[v/this]: t . \u00d8 f t<:[t] v Lemmas 2 and 3 state that matching \ndeclarations and sub\u00adtyping relations are preserved at runtime. Lemma 2 states that if a declaration \nD matches a type t, then the match will be preserved at runtime for any possible value v of this (t is \ntranslated to a corresponding runtime type by translat\u00ading it relative to the value of this). Analogously, \nlemma 3 states that subtype relations are preserved at runtime. Fur\u00adther, lemma 4 states that subtypes \nproduce more matching declarations. LEMMA 2 (Preservation of Matching). If uf D . Match(t) and \u00d8 f v<:[u]and \n\u00d8 f v OK ,then \u00d8 f D . v Match([t]) v LEMMA 3 (Preservation of Subtyping). If \u00d8 f v<:[u] v ' and \u00d8 f \nv OK and uf t<: t,then \u00d8 f [t ']<:[t] vv LEMMA 4 (Monotonicity of Matching). If G f D . Match(t) ' and \nG f t<: t,then G f D . Match(t ') Preservation of matching and preservation of subtyping hold due to \nthe properties of strong translation. The de.\u00adnition of matching (rule MATCH in Fig. 12) computes the \n' strong translation [t ] for each .eld type with respect iC(f:t) to the assumed type of this, C(f : \nt ). Replacing the as\u00adsumed type of this by a subtype must not invalidate match\u00ading relations. This is \nthe case due to an invariance property of strong translation: Only equivalent types will be produced \nwhen the context type is strengthened; hence, the subtype check in (MATCH) cannot fail. ' LEMMA 5 (Invariance \nof Strong Translation). If [t]= t u ' ''' and G f t OK and G f u<: u,then .t. [t]/ = u '' ''' t . G f \nt c t Weak translation has only a weaker property as stated in lemma 6. This property is, however, suf.cient \nfor soundness because weak translation is only used for .eld access and return types of constructors, \nwhere a loss in precision does not in.uence soundness. ' LEMMA 6 (Covariance of Weak Translation). If \nItl = t u ' ''' and G f t OK and G f u<: u,then .t. Itl / = u '' ''' t . G f t<: t  4.2 Completeness \nIn order for the type system to be sound, path normaliza\u00adtion must have the property that equivalent \npaths are indis\u00adtinguishable in the operational semantics. This can be ex\u00adpressed formally as follows: \nLEMMA 7 (Soundness of Path Normalization). If P OK and t f t OK and t f p c p ', then for all v with \n\u00d8 f v OK and \u00d8 f v<:[t](think: v is a value of v ' this that is allowed by t) and v.p '.* v1 and v.p \n'.* v2, we have v1 = v2. However, even a very trivial path equivalence relation '' such as G f p c p \n:. p = p would have this property. In order to demonstrate the expressiveness of path normaliza\u00adtion, \nwe have proven a completeness property,8 which says that the implication also holds in the reverse direction \nif we also consider possible extensions of the program -a .xed program may be too limited to distinguish \ntwo paths. For this reason, we added the program that we are talking about in the formulas in the following \nlemma: LEMMA 8 (Completeness of Path Normalization). If P OK ' and P, t f t OK ,then P, t f p c p if \nand only if for all '' extensions P = P, P '' of P such that P OK and all v with '' ' P, \u00d8 f v OK and \nP, \u00d8 f v<:[t]and P f v.p '.* v1 v '' and P f v.p '.* v2, we have v1 = v2. In other words, if two paths \nare operationally indistin\u00adguishable, then they will be equivalent in the type system. Since type equivalence \nis just path equivalence propagated to the type level (see c-CLASS), the result applies to types as well. \n 4.3 Decidability The de.nitions of most relations are syntax directed, i.e., at least one of the relation \narguments in premises is a struc\u00adtural part of the relation arguments in the conclusion, while the other \narguments remain unchanged. This applies to type equivalence, to strong and weak translation, and to \nexpres\u00adsion typing. Decidability is less obvious for path normaliza\u00adtion, for path bounding, and for \nsubtyping. Hence, we will illustrate how these relations can be turned into terminating algorithms. Figure \n14 describes an algorithm for path normalization and bounding, which is equivalent to the rules in Fig. \n10, i.e., if G f pp ',then normalize(G, \u00d8,p)= p ';if normalization is not possible, the algorithm generates \nan error (either raised explicitly or due to pattern matching failure). It is easy to see that derivations \nof path normalization are unique. Therefore, if during normalization of p we encounter p again, then \nnormalization of p is not possible and an error is raised. We use the second parameter . to keep track \nof 8 The proof is available at [15]. the paths, the normalization of which can cause such cycles, and \nthrow an error if we are about to normalize a path, which is already in .. The only place that can cause \na cycle is the path normalization in the premises of rule -FIELD2; all other premises normalize structurally \nsmaller paths. The algorithm always terminates, because . must grow with each recursive call on a path \nthat is not structurally smaller. On the other hand, . cannot grow inde.nitely, because it includes only \npaths computed by path bounding. It is easy to see that every possible path bound is a declared type \nin the context. Hence, the set of all path bounds in a .xed context is .nite and the algorithm is guaranteed \nto terminate. The subtyping de.nitions can directly be implemented by a recursive algorithm. Its termination \ncan be proved by a measurement function that assigns a natural number to each pair of types, such that \nthe measure of types, compared by a subtype relation in premises, is always smaller than the measure \nof the types, compared in the conclusion. Such a measure function is described in Fig. 15. It basically \nstates that the depth of the type on the right-hand side of the subtype relation must decrease in at \nmost two inference steps, if we do not count the intermediate inference rules for Match.  5. Dispatch \nIn this section, possible dispatch strategies are discussed, each answering the question as which of \nthe class declara\u00adtions matching a constructor should be selected for execu\u00adtion in a different way. \nAll discussed strategies are special\u00adizations of the most general strategy de.ned by the function Select \nin Fig. 8. This means that our selection of a speci.c dispatch strategy does not compromise the soundness \nof the calculus, as long as it can guarantee that something will be selected from every valid matching \nset of declarations: PROPERTY 1. If P OK and \u00d8 f t OK and \u00d8 f D . Match(t) for some declaration D, then \nthere exists a dec\u00adlaration D such that D ' . Select(t) and \u00d8 f D ' . Match(t). A reasonable assumption \nto expect from any dispatch strategy is that it implements overriding: More speci.c dec\u00adlarations should \nhide more general ones. Declaration D ' is more speci.c than declaration D, if any value that matches \nD ' also matches D: DEFINITION 1. Declaration D ' is more speci.c than D,if for all v = C(f = v) with \n\u00d8 f v OK and \u00d8 f D ' . match(C(f : v)) it follows that \u00d8 f D . match(C(f : v)). De.nition 1 describes \nthe desired property of overriding, but it is not constructive, because it quanti.es over all pos\u00adsible \nvalues. A constructive way to compare two declara\u00adtions could be achieved by comparing their signatures \nby the normalize(G,.,E)=E . . error if p.f .., ' normalize(G,. .{p ' },p ') if t= p,normalize(G,.,p.f)=. \nnormalize(G,.,p).f if t= C(f : t), where t= bound(G,.,p.f) bound(C(f : t),.,E)= C(f : t) bound(G,.,p.f)= \nt, where C(...f : t...) = bound(G,.,normalize(G,p)) Figure 14. Path Normalization Algorithm { ' depth(p) \n=0 depth(v)=0 2 \u00d7depth(t)+1 if t is not a class type ' measure(t,t)= ' depth(C(f,t))=max(depth(t))+1 \n2 \u00d7depth(t) if t is a class type Figure 15. Measure function showing decidability of subtyping subtype \nrelation. The problem, however, is that the signa\u00adtures may involve paths and, thus, cannot be compared \nin the global (empty) context. The solution is to use the sig\u00adnature of the declarations to compare as \ncontexts, as in the constructive de.nition of the overrides relation below: '' DEFINITION 2. Declaration \nD overrides D (D \u00ab D), if Sig(D ') f Sig(D ') <:Sig(D) and not Sig(D) f Sig(D) <:Sig(D '). ' The overrides \nrelation has the property that D overrides ' D implies D is more speci.c than D. By using it, the def\u00adinition \nof Select can be re.ned so that it guarantees that the overridden declarations are hidden (SELECT-OVER \nin Fig. 16). Given a non-empty set of declarations, a declara\u00adtion can be found that is not overridden \nby any other decla\u00adration from the set. This is because the overriding relation is transitive and asymmetric. \nThus, for such a de.nition of Select, constructor calls in a well-formed program will al\u00adways succeed. \nThe rule SELECT-OVER is, however, not deterministic because there can be several declarations that do \nnot override each other. There are different methods for eliminating this non-determinism. Following \nthe tradition of multi-dispatch, these methods can be classi.ed into symmetric and asym\u00admetric ones. \nSymmetric dispatch requires that only the most speci.c declaration can be selected. A possible de.nition \nof sym\u00admetric dispatch is given by rule (SELECT-SYMM) in Fig. 16. It requires that from the set of the \nmatching declarations we can select one declaration that overrides all the others. The type checking \nrules of Fig. 13 are not suf.cient to guarantee that symmetric dispatch will always succeed. For example, \nthe declarations Union(s:Space, s1:Solid(s:s), s2:s1) and Union(s:2DSpace, s1:Box(s:s), s2:Box(s:s)) \nin Fig. 4 do not override each other and both could match the type Union(s:2DSpace, s1:Box(s:s), s2:s1). \nThe simplest constructive way to guarantee that symmet\u00adric dispatch always succeeds, is to require that \nthe overrid\u00ading relation de.nes a total order on all declarations of the same class. The problem is that \nsuch a requirement is very strict, i.e., it rejects programs that ful.ll property 1. We could try to \nborrow less restrictive solutions that are available for symmetric dispatch for methods [2, 4, 28]. It \nis, however, not straightforward, because the relations that are easy to compute in a simple type system, \nwhere types correspond to plain classes, may be dif.cult to compute or even unde\u00adcidable in a type system \nwith dependent types. For example, it is dif.cult to determine if two types are overlapping, i.e. if \nthey have a common (valid) value in the program. It is also dif.cult to check if a type is an upper bound \nof an in\u00adtersection of two other types (i.e. it is a supertype of all their common subtypes). De.nition \nof tolerant constructive well\u00adformedness rules that guarantee the property 1 for symmetric dispatch is \na topic for future research. The general principle of asymmetric dispatch is to de.ne an additional ordering \nrelation that supplements the order of ' the overriding relation. The ordering relation D<t D says ' \nthat Dprecedes D when they are incomparable by overrid\u00ading relation. In the general case, the ordering \nrelation may be not absolute, but relative to t -the type being matched. Rule SELECT-ASSYM in Fig. 16 \nde.nes the general prin\u00adciple of asymmetric dispatch: the matching declarations are .rst .ltered by the \noverriding relation, then from the decla\u00adrations that are not overridden, we select the one that is the \nsmallest by the additional ordering relation. The supplementary ordering relation can be de.ned in different \nways. The simplest way is to de.ne it explicitly by assigning order numbers to declarations in the program \nor by having precedence declarations similar to the precedence declarations of aspects in AspectJ [21]. \nThe order can also be determined implicitly, by considering the order of class declarations, the order \nof .eld declarations and the order of parent classes in the extends clause. For example, one could consider \nextending the mixin linearization algorithm of the vc [12] calculus for multiple .elds. In vcn, one could \nalso consider new variations on dis\u00adpatch that would not make sense for multimethods. For ex\u00adample, classes \nthat only contribute structure (such as new supertypes or .elds) but not behavior (only default construc\u00adtor) \ncould be excluded from the dispatch algorithm. In vcn , all declarations of a class must have the same \nset of .elds, but if we would add self-initializing .elds or mutable .elds that do not need to be initialized \nvia constructor parameters,     Select for overriding: Select for symmetric dispatch: \u00d8 f D . Match(C(f \n: v)) \u00d8 f D . Match(C(f : v)) .D ' . Match(C(f : v)). \u00acD ' \u00ab D .D ' . Match(C(f : v)).D ' = D . D \u00ab D \n' (SELECT-OVER) (SELECT-SYMM) D . Select(C(f = v)) D . Select(C(f = v)) Select for asymmetric dispatch: \nC(f :v) (SELECT-ASYMM) D . Select(C(f = v))     Figure 16. Variations of Dispatch then a class \ndeclaration could extend the object layout with\u00adout interfering with the dispatch mechanism.  6. Related \nWork The idea of virtual classes stems from BETA [23] and be\u00adcame more popular since Ernst s paper on \nfamily polymor\u00adphism [10]. Since then, much related work on virtual classes has been published [19, 25, \n1, 18, 30, 31, 12, 32, 8, 5]. The key difference between dependent classes and vcn on the one side and \nrelated work on virtual classes on the other side [19, 25, 1, 18, 30, 31, 12, 32, 8, 5] consists in the \ngener\u00adalization of the dependency on multiple parameters and the resulting implications for expressiveness \nand the type sys\u00adtem (such as types that depend on multiple objects rather than a single object). We \nare not aware of any other previous work in this direction. Hence, in the following, we concen\u00adtrate \non those properties of vcn that can be directly compared to other approaches via encoding of virtual \nclasses by depen\u00addent classes. In other words, for this comparison we consider only dependent classes \nwith a single parameter. Figure 17 gives a brief summary of the comparison. Virtual classes as envisioned \nin Beta are properties of enclosing objects (object families in Fig. 17). Some ap\u00adproaches, Concord, \n.FJ and J&#38;, propose a static version of virtual classes where nested classes are properties of enclos\u00ading \nclasses. The implications of this difference are discussed in detail in [12]. The classes-in-objects \napproaches, CaesarJ, vc, .Obj, FSalg,Tribe and vcn, differ from each other in their support for what \nwe call path wildcards, referring to the ability to replace a path or part of a path in a type by a class \nname. For example, by using the type Space.Point instead of s.Point we refer to points whose class belongs \nto any instance of Space. Both Tribe and vcn allow free mixing of paths and class names. These approaches \nare also the only ones supporting free access to enclosing objects in types, such as a type p1.s.Vector \nthat refers to the enclosing object of a Point object p1. A detailed discussion why this is useful can \nbe found in [5]. Cross-family inheritance (Fig. 17) refers to the ability to inherit from a class that \nis not part of the same family. This is relatively easy in static approaches, but becomes more com\u00adplicated \nwith true virtual classes because a virtual class can then have multiple enclosing objects. Tribe has \nspecial con\u00adstructs (adoption and over-the-top types) to allow inheritance from top-level classes -this \navoids the aforementioned com\u00adplications because top-level classes do not have an enclos\u00ading object. \nIn vcn, a class can inherit from any other class, including classes that belong to arbitrary foreign \nfamilies. It is even possible to encode inheritance from a dependent type by a superclass clause of the \nform extends path.C.This is illustrated in the following example, which encodes a hypo\u00adthetical version \nof traditional virtual classes with inheritance from dependent types (top) in vcn (bottom). In the encod\u00ading, \nE has an additional constructor parameter, but since it has a singleton type (a path), there is only \none possible value which can be passed. In fact, it would be easy to devise an extension of vcn, where \nconstructor arguments with single\u00adton type can be initialized automatically. 1 2 3 4 class C {class D \n{}}class E extends path .D { ... } 1 C 2 D(out: C) 3 E (..., out : path) extends D Decidability is not \nobvious when dealing with dependent type systems, and in fact some dependent type systems are undecidable. \nIt is not trivial to deal with heaps and muta\u00adble state in path-dependent type systems, hence many formal \nlanguages have been formulated as pure functional systems. Final bindings increase the expressiveness \nof the type sys\u00adtem with respect to encoding generics, but it is not easy to reconcile .nal bindings \nwith polymorphic constructors and parents (superclasses), hence none of the languages supports both. \nFinally, the languages differ in whether arbitrary ex\u00adpressions can be used as receiver or argument of \na construc\u00adtor call (e.g., for nesting constructor calls). Some languages allow only paths in these positions \nand rely on encodings of arbitrary expressions through local variables. It is not always obvious, however, \nwhether these encodings have the desired typing properties, hence we feel it is desirable to support \nfree expression composition directly. Concord[19] Caesar/J[25,1]5 .FJ[18] J&#38;[30,31] vc[12] .Obj[32] \nFSalg [8] Tribe[5] vcn Object Families no yes no no yes yes yes yes yes Path wildcards n/a yes n/a n/a \nno no no yes yes Free access to enclosing object n/a no n/a n/a no no no yes yes4 Cross-Family Inheritance \nno no no yes no no no yes1 yes Inheritance from dependent type no no no no no no no no yes Decidability \nyes yes yes yes yes no yes yes3 yes Mutable State no yes no yes2 yes no no no no Final Bindings no no \nno no no yes yes no no Polymorphic Parents and Constructors yes yes yes yes yes no no yes yes Free Constructor \nNesting yes yes yes no no no no no yes Figure 17. Comparison with the single-dispatch fragment of vcn \nParts of this table have been copied from [5]. 1) but only from top-level classes; 2) the formal language \nin [30] uses a heap but has no mutation; 3) decidability is not discussed in [5], but the authors have \nsubsequently developed a variant of Tribe with a decidability proof (personal communication); 4) since \nenclosing objects (which are not lexically enclosing in vcn) are stored in ordinary .elds; 5) there is \nno formal de.nition of Caesar/J, though  DEEP [16] is another language which can encode a vari\u00adant of \nvirtual classes, but it is very different from the other languages discussed above and hard to compare, \nsince it allows general dependent types (not just dependencies on paths), uses a prototype-based approach \nrather than classes, supports virtual classes only through relatively elaborate en\u00adcodings, and uses \nmany unconventional techniques such as unifying terms and types. As already discussed in Sec. 2, dependent \nclasses are complementary to multimethods [9, 3, 34, 6] and cannot be replaced by them. Even encoding \nof the operational seman\u00adtics of dependent classes by means of multi-dispatched fac\u00adtory methods is hard, \nbecause a factory method would need to be de.ned for each possible combination of the decla\u00adrations of \na dependent class. Even more problematic is the modeling of the subclasses of dependent classes, because \na subclass implicitly inherits all variations of its superclass. Also, we believe that it is not possible \nto model the type system of vcn using any of the type systems that have been proposed for multi-dispatch. \nPredicate dispatch [13, 27] is a generalization of multi\u00addispatch. With predicate dispatch, a method \ncan have mul\u00adtiple declarations with different predicate expressions. A method declaration is applicable \nto the argument values of a method call when the predicate expression evaluates to true. The dispatch \nselects the most speci.c declaration of the method that is applicable for the given arguments. The predicate \nexpression of the most speci.c declaration must logically imply the predicate expressions of other declara\u00adtions. \nPredicate dispatch is more powerful than the dispatch that we presented for dependent classes. It would \nbe rather straightforward to generalize the operational semantics of vcn to use predicate dispatch but \nit is not obvious what the implications for the type system would be.  7. Conclusions and Future Work \nIn the paper, we presented the concept of dependent classes, a generalization of virtual classes. The \nde.nition of a depen\u00addent class is parameterized by and dispatched over multiple parameters. In addition \nto supporting multi-dispatch, the paramet\u00adric style also breaks the strict nesting structure of virtual \nclass declarations. This implies a new view, in which vir\u00adtual classes are not seen as an inherent part \nof the enclos\u00ading object, but rather as classes that simply depend on the types of other objects. As \na result, unnecessary coupling be\u00adtween classes and extensibility problems caused by nesting are avoided. \nBy their very idea dependent classes are related to multi\u00admethods in the sense that class de.nitions \ncan depend on multiple parameters in a similar way as method de.nitions do. The vcn calculus for dependent \nclasses presented in this paper not only encodes the multi-methods, but also extends their semantics \nby supporting dispatch over a more powerful subtype relation. This paper is the .rst one to present a \nmechanically ver\u00adi.ed soundness proof of a language with path-dependent types and virtual classes. We \nhope that the existence of this proof increases the trust and interest in virtual classes and makes it \neasy for other researchers to investigate new vari\u00adants of virtual classes by adapting our proof. There \nare several areas of future work. We will for\u00admalize abstract dependent classes and will investigate \nthe issue of modular checking of dispatch completeness and uniqueness. In addition, we plan to investigate \nthe relation to dependently-typed lambda calculi, such as the calculus of constructions [7]. First experiments \nsuggest that it might indeed be possible to encode some typical theorem proving examples in vcn. Also, \nwe plan to investigate the relation be\u00adtween dependent classes and Haskell s multi-parameter type classes \n[20], in particular those variants with support for so-called overlapping instances, building upon the \nresults presented in [22]. Another interesting issue is interaction between dependent classes and generics. \nAnother area will be to further study the usefulness of de\u00adpendent classes in various application scenarios. \nFor exam\u00adple, dependent classes are interesting in the context of sup\u00adporting variability in software \nproduct lines, because they can be used to model classes that depend on multiple varia\u00adtion points. \n8. Acknowledgment This work is supported by European Commission grant IST\u00ad33710: Aspect-Oriented, and \nModel-Driven Product Line Engineering (AMPLE), 2006 -2009, and by the German Ministry of Education and \nResearch grant 01ISF20A (feasi-PLe project).  References [1] I. Aracic, V. Gasiunas, M. Mezini, and \nK. Ostermann. An overview of CaesarJ. Transactions on Aspect-Oriented Software Development, 3880:135 \n173, 2006. [2] G. Castagna, G. Ghelli, and G. Longo. A calculus for over\u00adloaded functions with subtyping. \nIn LFP 92: Proceedings of the 1992 ACM conference on LISP and functional program\u00adming, pages 182 192, \nNew York, NY, USA, 1992. ACM Press. [3] C. Chambers. Object-oriented multi-methods in Cecil. In Proceedings \nECOOP 92, LNCS 615, pages 33 56. Springer, 1992. [4] C. Chambers and G. T. Leavens. Typechecking and \nmodules for multi-methods. In Proceedings OOPSLA 94, pages 1 15, New York, NY, USA, 1994. ACM Press. \n[5] D. Clarke, S. Drossopoulou, J. Noble, and T. Wrigstad. Tribe: A Simple Virtual Class Calculus. In \nProceedings of AOSD 07, 2007. [6] C. Clifton, G. T. Leavens, C. Chambers, and T. Millstein. Multijava: \nmodular open classes and symmetric multiple dispatch for java. SIGPLAN Not., 35(10):130 145, 2000. [7] \nT. Coquand and G. Huet. The calculus of constructions. Inf. Comput., 76(2-3):95 120, 1988. [8] V. Cremet, \nF. Garillot, S. Lenglet, and M. Odersky. A core calculus for Scala type checking. In Proceedings MFCS, \nSpringer LNCS, Sept. 2006. [9] L. DeMichiel and R. Gabriel. The Common Lisp Object System: An overview. \nIn Proceedings ECOOP 87, pages 243 252, 1987. [10] E. Ernst. Family polymorphism. In Proceedings ECOOP \n01, pages 303 326, London, UK, 2001. Springer-Verlag. [11] E. Ernst. Higher-order hierarchies. In L. \nCardelli, editor, Proceedings ECOOP 03, LNCS 2743, pages 303 329. Springer-Verlag, 2003. [12] E. Ernst, \nK. Ostermann, and W. Cook. A virtual class calculus. In Proceedings POPL 06, pages 270 282. ACM Press, \n2006. [13] M. D. Ernst, C. Kaplan, and C. Chambers. Predicate dispatching: A uni.ed theory of dispatch. \nIn Proceedings ECOOP 98, volume 1445 of LNCS, pages 186 211. Springer, 1998. [14] E. Gamma, R. Helm, \nR. Johnson, and J. Vlissides. Design Patterns. Addison Wesley, 1995. [15] V. Gasiunas, M. Mezini, and \nK. Ostermann. Formal sound\u00adness proof of the vc n calculus, 2006. http://www.st.informatik.tu\u00addarmstadt.de/static/pages/projects/mvc/index.html. \n[16] D. Hutchins. Eliminating distinctions of class: using prototypes to model virtual classes. In Proceedings \nOOPSLA 06, pages 1 20. ACM Press, 2006. [17] A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: \nA minimal core calculus for Java and GJ. ACM Transactions on Programming Languages and Systems, 23(3):396 \n450, 1999. [18] A. Igarashi, C. Saito, and M. Viroli. Lightweight family poly\u00admorphism. In Programming \nLanguages and Systems, Third Asian Symposium (APLAS 05), pages 161 177. Springer LNCS 3780, 2005. [19] \nP. Jolly, S. Drossopoulou, C. Anderson, and K. Ostermann. Simple dependent types: Concord. In Workshop \non Formal Techniques for Java-like Programs at ECOOP 2004, 2004. [20] S. P. Jones, M. Jones, and E. Meijer. \nType classes: exploring the design space. In Procedings of the Haskell Workshop 1997, June 1997. [21] \nG. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. G. Griswold. An overview of AspectJ. \nIn Proceedings ECOOP 01, pages 327 353, London, UK, 2001. Springer-Verlag. [22] R. L\u00a8ammel and K. Ostermann. \nSoftware extension and integration with type classes. In GPCE 06. ACM Press, Oct. 2006. [23] O. L. Madsen \nand B. M\u00a8oller-Pedersen. Virtual classes: A powerful mechanism in object-oriented programming. In Proceedings \nOOPSLA 89, pages 397 406. ACM Press, 1989. [24] M. Mezini and K. Ostermann. Integrating independent com\u00adponents \nwith on-demand remodularization. In Proceedings OOPSLA 02, pages 52 67. ACM Press, 2002. [25] M. Mezini \nand K. Ostermann. Conquering aspects with Caesar. In Proceedings AOSD 03, pages 90 99. ACM Press, 2003. \n[26] M. Mezini and K. Ostermann. Variability management with feature-oriented programming and aspects. \nIn Proceedings SIGSOFT 04/FSE-12, pages 127 136. ACM Press, 2004. [27] T. Millstein. Practical predicate \ndispatch. In Proceedings OOPSLA 04, pages 345 364. ACM Press, 2004. [28] T. Millstein and C. Chambers. \nModular statically typed multimethods. In Proceedings ECOOP 99, volume 1628 of Lecture Notes in Computer \nScience, pages 279 303. Springer Verlag, 1999. [29] T. Nipkow, L. C. Paulson, and M. Wenzel. Isabelle/HOL \n A Proof Assistant for Higher-Order Logic, volume 2283 of LNCS. Springer, 2002. [30] N. Nystrom, S. Chong, \nand A. C. Myers. Scalable extensi\u00adbility via nested inheritance. SIGPLAN Not., 39(10):99 115, 2004. [31] \nN. Nystrom, X. Qi, and A. C. Myers. J&#38;: nested intersection for scalable software composition. In \nProceedings OOPSLA 06, pages 21 36. ACM Press, 2006. [32] M. Odersky, V. Cremet, C. R\u00a8ockl, and M. Zenger. \nA nominal theory of objects with dependent types. In Proceedings ECOOP 03. Springer LNCS, 2003. [33] \nM. Odersky and M. Zenger. Scalable component abstractions. In Proceedings OOPSLA 05, pages 41 57, New \nYork, NY, USA, 2005. ACM Press. [34] A. Shalit. The Dylan reference manual: the de.nitive guide to the \nnew object-oriented dynamic language. Addison Wesley, Redwood, CA, USA, 1996. [35] A. Warth, M. Stanojevic, \nand T. Millstein. Statically scoped object adaptation with expanders. In Proceedings OOPSLA 06, pages \n37 56. ACM Press, 2006. [36] A. K. Wright and M. Felleisen. A syntactic approach to type soundness. Information \nand Computation, 115(1):38 94, 1994. \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Virtual classes allow nested classes to be refined in subclasses. In this way nested classes can be seen as dependent abstractions of the objects of the enclosing classes. Expressing dependency via nesting, however, has two limitations: Abstractions that depend on more than one object cannot be modeled and a class must know all classes that depend on its objects. This paper presents <i>dependent classes</i>, a generalization of virtual classes that expresses similar semantics by parameterization rather than by nesting. This increases expressivity of class variations as well as the flexibility of their modularization. Besides, dependent classes complement multimethods in scenarios where multi-dispatched abstractions rather than multi-dispatched methods are needed. They can also be used to express more precise signatures of multimethods and even extend their dispatch semantics. We present a formal semantics of dependent classes and a machine-checked type soundness proof in Isabelle/HOL [29], the first of this kind for a language with virtual classes and path-dependent types.</p>", "authors": [{"name": "Vaidas Gasiunas", "author_profile_id": "81436593826", "affiliation": "Technische Universit&#228;t Darmstadt, Darmstadt, Germany", "person_id": "P905218", "email_address": "", "orcid_id": ""}, {"name": "Mira Mezini", "author_profile_id": "81100583946", "affiliation": "Technische Universit&#228;t Darmstadt, Darmstadt, Germany", "person_id": "P201627", "email_address": "", "orcid_id": ""}, {"name": "Klaus Ostermann", "author_profile_id": "81100028971", "affiliation": "Technische Universit&#228;t Darmstadt, Darmstadt, Germany", "person_id": "PP14022906", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297038", "year": "2007", "article_id": "1297038", "conference": "OOPSLA", "title": "Dependent classes", "url": "http://dl.acm.org/citation.cfm?id=1297038"}