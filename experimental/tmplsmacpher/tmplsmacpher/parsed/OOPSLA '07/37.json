{"article_publication_date": "10-21-2007", "fulltext": "\n Confessions of a Used Programming Language Salesman Getting the Masses Hooked on Haskell Erik Meijer \nMicrosoft SQL Server erik.meijer@microsoft.com When considering the past or the future, dear appren\u00adtice, \nbe mindful of the present. If, while considering the past, you become caught in the past, lost in the \npast, or enslaved by the past, then you have forgot\u00adten yourself in the present. If, while considering \nthe future, you become caught in the future, lost in the fu\u00adture, or enslaved by the future, then you \nhave forgot\u00adten yourself in the present. Conversely, when consid\u00adering the past, if you do not become \ncaught, lost, or enslaved by the past, then you have remained mind\u00adful of the present. And if, when considering \nthe future, you do not become caught, lost, or enslaved in the fu\u00adture, then you have remained mindful \nof the present. [31] Abstract For many years I had been fruitlessly trying to sell functional programming \nand Haskell to solve real world problems such as scripting and data-intensive three-tier distributed \nweb ap\u00adplications. The lack of widespread adoption of Haskell is a real pity. Functional programming \nconcepts are key to curing many of the headaches that plague the majority of program\u00admers, who today \nare forced to use imperative languages. If the mountain won t come to Mohammed, Mohammed must go to the \nmountain, and so I left academia to join industry. Instead of trying to convince imperative programmers \nto for\u00adget everything they already know and learn something com\u00adpletely new, I decided to infuse existing \nimperative object\u00adoriented programming languages with functional program\u00adming features. As a result, \nfunctional programming has .\u00adnally reached the masses, except that it is called Visual Basic 9 instead \nof Haskell 98. Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4eal, Qu\u00b4ebec, Canada. Copyright c &#38;#169; 2007 ACM 978-1-59593-786-5/07/0010. \n. . $5.00. Categories and Subject Descriptors D.3.2 [Programming Languages]: Applicative (functional) \nlanguages, Object\u00adoriented languages General Terms Languages, Theory, Human Factors 1. Introduction Nearly \nall (business) applications boil down to transform\u00ading data from one form to the other. For instance \nan order\u00adprocessing system written in an object-oriented language that creates XML billing statements \nfrom customer and or\u00adders information in a relational database. As a result, programmers constantly need \nto juggle three very disparate data models: Relations in the data tier + Objects in the business tier \n+ and XML in the presenta\u00adtion tier, i.e. the infamous ROX triangle [102]. Not only is each data model \nfundamentally different, but each comes strongly coupled with its own programming language. Relational \ndata with SQL queries, objects with imperative languages such as Java, C., or Visual Basic, and XML trees \nwith XPath, and XQuery or XSLT. The deep impedance mismatch between the three inhabitants of the ROX \ntriangle is the reason that many programmers in the real world are pulling their hair out on a daily \nbasis. Fortunately, in the .rst half of the previous century math\u00adematicians were working on esoteric \ntheories such as cate\u00adgory theory and lambda calculus. These mathematical theo\u00adries provide deep insight \ninto the algebraic nature of collec\u00adtions and operations on collections. By leveraging this the\u00adoretical \nbasis it is actually possible to unify the three data models and their corresponding programming languages \nin\u00adstead of considering them as three unrelated special cases. Conveniently, the same theories also form \nthe foundation of functional languages, in particular those of the pure and lazy kind such as Haskell. \nThis paper is a personal account of my journey to democ\u00adratize the three-tier distributed programming \nproblem using (lazy) functional programming concepts. It starts with my naive attempt to use Haskell \nas the language to write three\u00adtier distributed data intensive applications, then continues with my brief \n.irtation with designing a series of completely new languages from scratch including Mondrian, XM., and \nC., and ends when I accidentally discover the Change Func\u00adtion [37] and .nally succeed by incorporating \nfunctional programming and monads into the LINQ framework, C 3.0 and Visual Basic 9. 2. The Great Internet \nHype 1.0 In 1997 I was fortunate enough to spend a sabbatical at the Oregon Graduate Institute. This \nwas the zenith of the Internet bubble and we got inspired to apply Haskell, the world s .nest imperative \nlanguage [52], to solve the ROX problem using pure functional programming. This abruptly ended my banana \nman [73] period and instead of looking for practical applications of beautiful theory, I now started \nlooking for beautiful theory to solve practical problems [87]. 2.1 Interfacing Haskell to the Outside \nWorld One of the premises of Landin s seminal paper The Next 700 Programming Languages [59] is that most \nlanguages can be considered as a collection of primitive building blocks plus glue to compose smaller \nprograms into larger programs. Haskell s lazy evaluation and monads make it a very power\u00adful glue language \n[50, 49], but for a long time it was hard to access externally implemented libraries in Haskell, so there \nwas little to glue together. As a result, most Haskell pro\u00adgrams lived in a closed world (with notable \nexceptions such as [35]). The .rst thing we needed to tackle was making it dead simple to interface Haskell \nwith external, imperative, code. Interfacing Haskell to native C libraries requires at the lowest level \njust four things: 1. We need to put imported native pointers under the control of the Haskell garbage \ncollector. 2. Dually, we need to pin exported Haskell references such that they are not moved around \nby the Haskell garbage collector. 3. We need to wrap imported native function pointers (either statically \nor dynamically loaded) as Haskell closures. 4. Dually, we need to export Haskell closures (either stati\u00adcally \nde.ned or dynamically created) as native function pointers.  This basic functionality is available as \nthe standard Foreign Function Interface (FFI) for Haskell 98 [22]. Having a ba\u00adsic FFI mechanism theoretically \nenables interop between Haskell and other languages, but it requires the determina\u00adtion of a monk to \nactually make things work because of the large amount of low-level plumbing needed to marshall values \nacross language boundaries. This is were tooling is dearly needed. 2.1.1 GreenCard and HaskellDirect \nThe .rst attempt at making FFI easy to use was Greencard [86]. Programmers put special directives in \ntheir code, and the GreenCard preprocessor then generates all the low-level interfacing and marshalling \nboilerplate code based on these directives. H/Direct [97, 98] was an attempt to automatically generate \nFFI boilerplate code from a standalone IDL description for either an external library or a Haskell program. \nIDL is a quite powerful, but rather messy, underspeci.ed, and com\u00adplex type-system. However, in the late \nnineties we all be\u00adlieved that binary software components were the silver bul\u00adlet and so it made sense \nto use a (more or less) language\u00adindependent external description for components. 2.1.2 COM COM is a \nbinary-component standard that, at its core, shows a minimalist design that evokes the same feelings \nof deep beauty and elegance as category theory. The model just im\u00adposes a handful of axioms that components \nand compo\u00adnent consumers must observe. In particular COM does not impose a common type system. COM components \nare simply vtables of function pointers that implement a set of interfaces (identi.ed by GUIDS) and inherit \nfrom a base interface IUnknown. The IUnknown interface determines the identity of a component and de.nes \nthe .rst three en\u00adtries of each COM vtable: QueryInterface, AddRef and Release. The QueryInterface method \nallows navigat\u00ading between the set of interfaces implemented by the cur\u00adrent component, the AddRef and \nRelease methods allow the current component to participate in a reference-counting garbage collection \nprotocol. Alas, the infrastructure around COM (such as the registry, the ingenious but complex OLE protocols, \nand the ever\u00adchanging marketing names) as well as the lack of a program\u00adming language that intrinsically \nsupported COM, gave it a bad reputation. Nevertheless, even after more than 10 years, we still believe \nthat COM is a great component model. And we are not the only ones; on the Windows platform, COM is alive \nand kicking. On Linux, the cross-platform COM model (XPCOM) is the basis for many open source projects \nsuch as Mozilla. One interesting artifact that arose from interfacing Haskell [99] and SML [91] to COM \nis the notion of phantom types.A phantom type is a parametrized type whose type parameter is not used \nin its RHS. When we .rst discovered phantom types, many people would not believe that they were legal; \nnow they are the standard mechanism for advanced-type hacking in Haskell [45, 36, 43, 42]. We used phantom \ntypes in a variety of different ways. The most direct use is to represent typed pointers using a type \nsynonym Ptr a = Addr. The unused type parame\u00adter a allows us to distinguish between a pointer to an in\u00adteger \nPtr Int and say a pointer to a pointer to an integer Ptr (Ptr Int). We also heavily used phantom types \nto model interface inheritance [61]. 2.1.3 Automation and MS Of.ce COM Automation is a re.ective layer \nbuilt on top of COM that makes it easy for dynamic and scripting languages to access and create COM components. \nMany of Microsoft s applications, such as Word, Excel, Outlook, Powerpoint, and Visio, are all fully \nscriptable using Automation, and the pre-.NET Visual Basic dialects such as VBA and VB6 are programming-language \nabstractions over COM Automation. Because of the additional level of indirection introduced by Automation, \nit is extremely simple for any language to use and create COM components. The language infrastructure \njust has to provide a generic binding for the single COM in\u00adterface IDispatch. From there on programmers \ncan access any Automation component. Similarly, the language only needs to provide one generic factory \nmethod that wraps a collection of function pointers into an IDispatch interface. From there on programmers \ncan easily create new Automa\u00adtion components [63]. In our experience Haskell was an ideal language for \nCOM Automation, for instance within half a day we scripted Visio to create a visual front end for Hawk \n[60] and we created an elegant combinator language for scripting MS Agents [76]. So we naturally assumed \nthat if we exposed Automation in Haskell, the world would instantly fall for functional programming. \n 2.2 Server-side Scripting Using Haskell Since the Internet bubble was still expanding in the late 90 \ns, another problem we tackled was writing dynamic HTML pages in Haskell. Until then, most dynamic Web \npages were written in Perl using thin wrappers on top of the basic CGI protocol. The reason that Perl \nwas, and still is, popular for this task is that one can use regular expressions to parse query strings \ninto hashes of name-value pairs that represent the data posted by the Web page to the server, and use \nhere documents as simple text-based templates to generate dynamic HTML. 2.2.1 Perl for Swine The Perl \nFor Swine library [67] leverages algebraic data types and higher-order functions of Haskell to create \nan embedded domain-speci.c language of HTML-generating combinators, and a worker-wrapper-style abstraction \nof the actual CGI protocol. The user writes a simple worker func\u00adtion of type [(String, String)] -> IO \nHTML, which gets wrapped into an IO () action that parses the query string of the incoming HTTP request \ninto a list of name\u00advalue pairs passes it to the worker and wraps the result using the proper MIME type. \nIn addition to the basic CGI library, we also integrated the Hugs interpreter (mod_haskell) into the \nApache Web server. 2.2.2 Haskell Server Pages (HSP) While using combinators to generate HTML is very \npower\u00adful and concise, it is quite hard to generate complex HTML pages in a completely algorithmic way. \nProfessional Web sites consist of a combination of static content designed by professional artists sprinkled \nwith dynamically generated fragments written by programmers. Systems such as ASP and PHP facilitate this \nseparation of concerns by means of special static HTML pages with em\u00adbedded holes that contain code for \nthe dynamically gener\u00adated pieces of the page. The implementation of ASP and PHP is just a simple preprocessor \nthat turns each line of HTML into a Response.Write statement and leaves em\u00adbedded code as-is. This results \nin a non-compositional model where it is impossible to arbitrarily nest further HTML in\u00adside code, and \ncode inside that HTML, etc. Haskell Server Pages [83] takes the idea of HTML templates a step further \nby expanding HTML literals embedded in arbitrary Haskell expressions into calls to the Perl For Swine \nHTML-generating combinators to allow arbitrary nesting of concrete HTML syntax and code. In addition, \nHSP also introduced the notion of pattern matching against HTML. An HSP-derived pre-processor is available \nas part of the WASH system [101], and as the MSc thesis of Niklas Broberg [34]. The PLT Schemework in \nthe area of web (both client and server) programming is truly impressive [18]. 2.2.3 HaskellDB As mentioned \nearlier, almost all Web applications involve dealing with relational databases in form form or another. \nHaskellDB [62] is a domain-speci.c library for program\u00adming against relational data. Just as the HTML \ncombina\u00adtors, most domain-speci.c languages are implemented via shallow embedding [110]. That is, we \nde.ne a set of base combinators that embody the semantic algebra of the em\u00adbedded language, and glue \nthe primitive operations together into bigger denotations using the host language s abstraction mechanism. \nThe main innovation in HaskellDB is the idea of a domain\u00adspeci.c embedded compiler, or deep embedding. \nIn this case we de.ne a set of base combinators that embody the abstract syntax tree of the embedded \nlanguage and use the host lan\u00adguage s abstraction mechanism to build bigger abstract syn\u00adtax trees. In \na second step we evaluate these trees, or compile them into an external target language for execution. \nThe Query a monad in HaskellDB is a modi.ed state monad where the state contains an explicit representa\u00adtion \nof the query that is being executed. The function runQuery :: Query a -> IO [a] compiles the this representation \ninto SQL, submits it to a back-end database, and returns a collection of rows as the result. When execut\u00ading \nthe SQL, the database does not know, or have to know, that this SQL was generated by evaluating a Haskell \ncom\u00adprehension. HaskellDB has lingered for a long time, but recently it has been revisited and improved \n[6]. A similar approach is used by Lennart Augustsson to gen\u00aderate VBA programs to script Excel for .nancial \nmodeling, the hardware description language Lava [30] that generates VHDL or other external hardware \ndescription languages and the image generation library Pan [39].  2.3 Client-Side Scripting Using HaskellScript \nWith the browser wars in full swing, Microsoft wanted to support both JavaScript as well as VBScript \nin its Internet Explorer browser. Any script engine that implements the Ac\u00adtiveX Script Engine interfaces \ncan be embedded into a host application that implements the ActiveX Script Host inter\u00adfaces. Examples \nof hosts are Internet Explorer, Windows shell, and the IIS Web server. HaskellScript [76] is an implementation \nof the ActiveX Script Engine interfaces for Haskell. It uses a custom COM interface, IScript, layered \non top of the Hugs interpreter. In our experience Haskell was an excellent language for DHTML and shell \nscripting, but despite this, HaskellScript reached the astronomical popularity of dynamically typed scripting \nlanguages such as Python, Lua, and most recently Ruby.  2.4 Lambada Soon after we made our bet on H/Direct, \nCOM and COM Automation, binary component models fell out of fashion in favor of language-speci.c, meta-data \ndriven, models such as Java and .NET. Also, we speculated that one of reasons for the low adoption rate \nof our work might be the fact that the technology was Windows-speci.c. So, we tried to sell Haskell as \nthe ultimate component glue language a second time by interfacing Haskell to Java [72] via JNI [65]1. \n1 Sheng Liang, one of the designers of JNI, worked on monadic interpreters in a previous life [64]. Also \nthe Haskell-Java binding failed to gain any traction within the Haskell community, and we began exploring \nthe insane idea of creating new languages for the Web from scratch. 2.4.1 XM. With HSP we already veered \noutside the strict boundaries of pure embedded domain-speci.c languages and made baby steps towards adding \nnew syntax to Haskell. The HaskellDB experiment convinced me that the Haskell type-system is in\u00adcredibly \nexpressive, but not quite expressive enough to easily encode the idiosyncrasies of XML Schema and DTDs \n[100]. So it seemed obvious to design a stand-alone language, XM. [81], to .lter, query, pattern match, \nand transform XML doc\u00aduments. The language turned out to be an Edsel . XM. featured a complicated DTD-based \nstatic type infer\u00adence system that supported polymorphism and higher-order functions. As a result of \nthis complexity we did not even succeed to get the implementation beyond a very early proto\u00adtype stage. \nThat did not prevent us from looking at even more advanced type systems. Subsequent work on type-indexed \nrows [95] marked the lost weekend of my typoholic years. And it slowly started to dawn on me that you \ncan overdo static typing. Unfortunately, I had not yet hit bottom. 2.4.2 Internet Scripting Using Mondrian \nInspired by the conceptual minimalism of the De Stijl movement, Mondrian [70, 77, 51] was an attempt \nto re\u00adduce Haskell to its bare essence: higher-order functions, lazy evaluation, pattern matching, and \nmonads; and for the rest, piggybacking as much as possible on the underlying object\u00adoriented .NET framework. \nJust as modern art does not evoke strong positive feelings in most people, the Mondrian lan\u00adguage failed \nto seduce the functional language community at all, let alone the non-FP folks I was ultimately trying \nto win over. In many respects F [8] is the moral successor of Mon\u00addrian, except that it uses the strict \nand imperative functional language OCaml [1] as its basis. By dropping laziness in strict functional \nlanguages such as Scheme[54], SML[84], OCaml[1], Scala [19] and F , the purity and semantic beauty of \ntrue functional programming is lost. When programming in Haskell, laziness is one of those things that \nyou rely on all the time without noticing it; it is something you only realize once you miss it. 2.4.3 \nLazy versus Strict Strictness is an effect, and most strict functional languages usually include other \nside-effects such as exceptions, im\u00adperative updates, and continuations. Semantically, there\u00adfore there \nis no real difference between a strict, higher\u00adorder, functional language, and a strict, higher-order, \nobject\u00adoriented language. One might argue that OO languages are actually more powerful than strict functional \nlanguages since objects are closures that contain multiple functions (meth\u00adods) [103] while inheritance \nand virtual methods correspond to open data types and functions [66]. One of the most useful bene.ts \nof a pure language such as Haskell is that initial algebras and .nal co-algebras coincide [75, 44]. This \nmeans that Haskell data struc\u00adtures can be .nite, in.nite, or both. This means that in Haskell there \nis no problem to de.ne a recursive list such as nat = 0 : map (+1) nat. In strict languages, values of \nnormal data types or classes (initial algebras) are always .nite, and the previous recursive list de.nition \nwould not terminate. To de.ne potentially in.nite values you have to resort to co-algebras, or in layman \ns terms you have to im\u00adplement an explicit pull model. The prototypical example of a co-algebraic, or \npull-model, data type is the IEnumerator interfaces (in Java iterator) interface IEnumerator<T> { bool \nMoveNext(); T Current; } The IEnumerator interface is an imperative version of the unfoldr :: (a -> Maybe \n(b,a)) -> a -> [b] func\u00adtion in Haskell where the state component a is implicit and the result Maybe \n(b,a) is simulated by .rst calling MoveNext, which side-effects Current when it succeeds. Precisely because \nof laziness ( deferred execution ), the IEnumerator interface and its factory interface IEnumerable play \na key role in the LINQ framework described below. There are many examples of blending object-oriented \nand strict functional languages including C 3.0 and Visual Basic 9, F , Scala, Java 7 (for which there \nare no less than 4 proposals to add closures) [11, 2, 3, 16]. Reconciling lazy and strict functional \nlanguages, however, is still an open research problem [53, 93, 108], and will remain so for a long time. \nUntil that moment, pure lazy functional languages such as Haskell will remain a niche. The perceived \npain of adoption for purity is simply to high compared to that of strict functional/OO languages. 3. \nThe Change Function After failing to sell solving real world problems to the Haskell community, as well \nas failing to sell Haskell to the real world, I started to wonder whether pushing for pure functional \nlanguages was actually the right strategy. Maybe I thought, I should sell my soul to the most popular \npro\u00adgramming paradigm, objects, and to the company that has the biggest market share, Microsoft. In retrospect, \nwhat hap\u00adpened, is that I unknowingly discovered the Change Func\u00adtion [37]. The Change Function is a \nsimple theory that predicts the suc\u00adcess of new technologies. Producers of new technology are overly \noptimistic and think Build it and they will come . Their conviction is that their technology is superior \nto any\u00adthing that already exists. This is re.ected in claims such as Haskell programs are at least 10 \nshorter than the cor\u00adresponding C programs . Moreover, they believe their cur\u00adrently inadequate implementations \nwill radically improve over time. This is re.ected in claims such as Soon, real soon, the speed of Haskell \nprograms will approach that of highly optimized C code . In short, they predict the chance of success \nas a function of the following product: Supplier-Centric Adoption Model = F (10X better * Moore s Law) \nObviously, I had been trapped into the supplier-centric point of view myself. Normal users have a very \ndifferent take on new technology. They hate technology for technology s sake (probably the display on \nyour VCR is also still blinking). They just want to get their work done with the least amount of effort, \nand moreover, they have little desire to learn new things. Ac\u00adcording to Pip Coburn therefore, the chance \nactual chance of success for new technology is a function of the following ratio: Change Function = F \n(Perceived Crisis/Perceived Pain of Adoption) By focusing on .nding beautiful solutions for real problems, \nI had already nailed the numerator portion of the Change Function. From now on my goal in life would \nbe to also drive the denominator down to zero to maximize my chances of success. 4. Microsoft My main \nreason to join Microsoft as the company to infuse mainstream programming languages with monads and other \nfunctional programming features was that I believed the quickest road to success would be to work on \nadding support for exotic language features to the new Common Language Runtime [74]. 4.1 C. and The Dark \nXML Ages While I was working in the CLR team on relaxed delegates and lightweight code generation, XML \nkept gaining momen\u00adtum. The time was ripe to pitch to chairman Bill Gates him\u00adself the idea of making \nXML a .rst-class citizen in C . With much encouragement from Don Box (who convinced us to drop DTDs and \nadopt XSD instead), Wolfram Schulte and I submitted a Thinkweek paper [78] on this topic. As it turned \nout, BillG liked our proposal, and the XML team led by William Adams started a small incubation team \nto write a prototype data-centric C extension with support for relational tables and XML. The language \nwas originally called X , but along the way the # suf.x became verboten so we changed the codename to \nXen. When we joined efforts with the Polyphonic C group [24] in Cambridge, we .nally settled on C. [80, \n79, 27]. 4.1.1 The Sucking Black Hole of XSD To appreciate the dif.culties of XML, let s make a short \nexcursion to the world of XML schema [21], which must be one of the most complex artifacts invented by \nmankind. The complexity of XSD is especially baf.ing since the existing solution, DTDs, is already a \nperfectly .ne solution. The main problem of XSD is not that it gratuitously uses XML as its concrete \nsyntax, but the fact that it is completely over-engineered. The most confusing feature of XML is the \nnotion of complexType. The example below de.nes a schema for values of the form <Point><x>4711</x> <y>13</y></Point>: \n<complexType name=\"PointType\"> <sequence> <element name=\"x\" type=\"integer\"/> <element name=\"y\" type=\"integer\"/> \n</sequence> </complexType> <element name=\"Point\" type=\"PointType\"/> The idea of complexTypes is to describe \nthe shape of the content of elements, supposedly to aid reuse. No program\u00adming language we know of introduces \nthis kind of additional layer of types to describe the shape of the members of regu\u00adlar types; perhaps \ninterfaces come closest to this idea. While there are no values of type complexType, the fact that they \nare called type, however, leads many people to believe that in a shallow embedding of XML into objects, \ncomplexTypes and not elements should be mapped to classes. Under that wishful interpretation of mapping \ncomplexType to classes, the schema above would translate to the following class: Class PointType x As \nInteger y As Integer End Class This immediately begs the question what to do with the dec\u00adlaration <element \nname=\"Point\" .../>. That has to be mapped to a type as well because it represents Point docu\u00adments. Now \nsome elements are mapped to types, and some are mapped to .elds. This discrepancy causes an incoher\u00adence \nwith the semantics of XPath, where all path selections return collections of elements and attributes, \nbut never col\u00adlections of complex types. We could go on for pages talking about the subtleties of mapping \nXSD to objects [57, 56, 58], but we cut it short by observing that any attempt that does not uniformly \nmap elements to types is fundamentally .awed because XML values are node-labeled trees, while objects \nare edge-labeled graphs. 4.1.2 Type-System Extensions When you throw the challenge of de.ning an XML-centric \nlanguage at a researcher, their .rst reaction is to invent a better version of DTDs with lots of fancy \nstructural (regular expression) types and elaborate subtyping rules [48, 25, 47, 20]. In very much the \nsame spirit, in C. we attempted to extend the CLR type system with a large arsenal of structural types: \nT ::= N | T [] | T ( ... ,T , ... ) | T |T | T &#38;T | T -| T ! | T ? | T + | T * | struct { ... ,T \n[m], ... } These new structural types include function types T( ... ,T, ... ); union | and intersection \ntypes &#38;; an exotic family of stream types, -for exact types (dynamic type equals static type), ! \nfor non-null types (streams with exactly one element), ? for optional types (streams with either zero \nor one element), + for non-empty streams, and * for possibly empty streams; and optionally labeled records \nstruct { ... , [T] m , ... }. XML literals in C. are just serialized objects, and the com\u00adpiler translated \nsuch literals into constructor calls of the type denoted by the literal. For example, we can de.ne a \nschema for email messages written in XML syntax such as msg = <Email> <To>BillG</To> <From>Erik</From> \n<Body> <P>Visual Basic is also my favorite language</P> </Body> </Email> using the following type declaration \nclass Email { string To; string From; string? Subject; struct{ string P; }* Body } Just as Haskell Server \nPages, and XQuery, C. XML liter\u00adals can contain arbitrarily nested expression and statement holes. C. \nalso has type inference for local variables, and the inferred type for the msg variable is Email. 4.1.3 \nGeneralized Member Access The slogan of C. is The Power Is In The Dot! which refers to the fact that \nin C. we lift member access over all structural types. For example, given a collection bs of type Button*, \nwe can write bs.BackColor to return the individual colors of each button in the collection. The ex\u00adplicit \nnotation for lifting uses an anonymous block expres\u00adsion, bs.{ return it.BackColor; }, to map the func\u00adtion \nfunction(Button it){ return it.BackColor; } over the collection bs. 4.1.4 Query Comprehensions Besides \ngeneralized member access and explicit lifting, C. also supports XPath-style .lter expressions such as \nbuttons[ it.BackColor = Color.Red ], which like the previous example uses it to bind the implicit parameter \nof the .lter predicate and SQL-style SELECT FROM WHERE GROUPBY comprehensions. The compiler has built-in \nknow\u00adledge about queries over streams (list comprehensions) and about queries over remote databases (the \nquery monad). It was possible to overload the comprehension syntax for other types via compiler plug-ins. \n 4.1.5 Nullable types In the Whidbey version of the .NET Framework, nullable types were introduced in \nC 2.0 using the same ? syntax as C.. In C 2.0, conversions and binary operators over T? are lifted, but \nmember access is not. The T? type constructor is constrained to take a non-nullable value type T as its \nargu\u00adment, so nullable types cannot be nested. Unlike C., there is no implicit conversion from T? (interpreted \nas streams of at most one element) to T* c.q. IEnumerable<T> (that rep\u00adresent stream of zero or more \nelements). The biggest impact of C. on the real world has been to en\u00adsure that nullable types in the \nCLR are coherent; that is when a null value of type T? is boxed to object, it is mapped to the null pointer, \nand when a non-null value t of type T? is boxed to object, the value is .rst unwrapped and then boxed. \nWithout going through such a two step process, boxing the null value of a value type T would not be result \nin the null pointer, i.e., (object)null != null. Also .rst upcasting to nullable and then boxing would \nnot give the same result as boxing, that is, (object)(T?)t != (object)t. 5. Language Integrated Query \nAs the C. incubation was winding down, the C team started to spin up the design work for C 3.0, and several \nex-members of C. and ObjectSpaces teams went over to C to spread their intellectual DNA and conceive \nLINQ. The goal of Language Integrated Query (LINQ) is to unify programming against relational data, objects, \nand XML. In contrast to my earlier efforts, this time we managed to strike a nice balance between providing \ndomain-speci.c libraries and adding general purpose language extensions. Surpris\u00adingly, LINQ requires \nno extensions to the underlying CLR and all new C (and Visual Basic) features are de.ned as syn\u00adtactic \nsugar on top of C 2.0 [28]. Both the libraries and the language extensions are heavily inspired by functional \npro\u00adgramming, in particular the Haskell (list) prelude and mon\u00adads and monad comprehensions [107]. All \nof the various lan\u00adguage extensions such as lambda expressions, anonymous types, type inference, meta-programming, \netc. are valuable by themselves. The total is really more than just the sum of the parts. At the same \ntime, I rekindled up my interest in scripting and dynamic languages [71], sparked by the staggering complex\u00adity \nof the C. type-system. I became convinced that deep em\u00adbedding is the best way to deal with XML in a \nlanguage, with an optional and layered type-system on top, following the approach suggested by Gilad \nBracha [32]. In turn, this led me to the realization that Visual Basic was the ideal lan\u00adguage for the \nroad ahead because it is the only widespread language (yet) that allows static typing where possible \nand dynamic typing where necessary. So besides joining the C design team, I also joined the Visual Basic \ndesign team (see \u00a75.8.2 and \u00a76) and changed the title on my business card [5]. 5.1 Query Comprehensions \nCentral to LINQ is the introduction of query comprehensions into both Visual Basic and C . Query comprehensions \nare a generalization of Haskell s monad (or list) comprehensions to include support for SQL-style operations \nsuch as joins, grouping and aggregation, and sorting. In contrast to SQL where all query results must \nreturn .at tables, LINQ queries can return collections of arbitrary reults, including nested collections. \nThis compositionality makes queries much eas\u00adier to author and understand. For example, the following \nquery .lters and sorts a collec\u00adtion of programmers by Age and Name, groups them by their favorite Language \nand aggregates the size and names of each group. The into g clause introduces an iteration vari\u00adable \nthat ranges over the grouped partitions. Each such group has a Key (the language) and the collection \nof names of pro\u00adgrammers in the group. var q = from p in programmers where p.Age > 20 orderby p.Name \ndescending group p.Name by p.Language into g select new{ Language = g.Key, Size = g.Count(), Names = \ng } Just as in Haskell, comprehensions are convenient syntactic sugar on top of a speci.c design pattern. \nIn Haskell the pattern for monad comprehensions is de.ned via the Monad and MonadPlus type classes and \nusing concatMap for list comprehensions (which is the >>= for the list monad). LINQ de.nes a speci.c \nset of standard sequence operators for this purpose (see \u00a75.2). A possible translation of the above query \ninto these standard sequence operators could look like: var q = programmers .Where(p => p.Age > 20) .OrderByDescending(p \n=> p.Age) .GroupBy(p => p.Language, p.Name) .Select(g => new{ Language = g.Key, Size = g.Count(), Names \n= g}); With the proposal [106] to extend Haskell s list comprehen\u00adsions with grouping and sorting, the \ncircle of in.uence be\u00adtween Haskell and LINQ has been closed. Other recent lan\u00adguages that support comprehensions \nare Fortress [10] and Scala [19]. In Visual Basic, comprehensions are designed to minimize the need for \ndropping down to the underlying primitive op\u00aderators and lambda expressions. Comprehensions are fully \ncompositional, and act as a pipeline that transforms collec\u00adtions of tuples into collections of tuples \n(similar to the tuple\u00adbased translation of XQuery [92]). The following query joins all books from Amazon \nand Barnes&#38;Noble by ISBN number and selects the price at each store as well as the title of the book, \nand .nally .lters out all books that cost more than a hundred dollars. Note the use of punting (which \nwas removed from Haskell 98), where the compiler infers the record labels from the expression, in the \nSelect clause: Dim BookCompare = From A In Amazon, B In BarnesAndNoble Where A.ISBN = B.ISBN Select A.Title, \nPriceA = A.Price, BPrice = B.Price Where Max(APrice, BPrice) < 100 In the (mechanical and unreadable) \nde-sugared code that the compiler generates, the From clause of the query constructs the cartesian product \nof the two source collections using a nested Select(Many), the Where clause then lifts the iter\u00adation \nvariables A and B over the compiler-generated argu\u00adment _It_, the Select projects the pair of A and B \ninto a triple Title, APrice, and BPrice, and .nally the last Where clause again lifts these iteration \nvariables over the compiler-generated argument _It_: Dim BookCompare = Amazon.SelectMany(Function(A) \nBarnesAndNoble.Select(Function(B) New With { .A = A, .B = B})). Where(Function(_It_) _It_.A.ISBN = _It_.B.ISBN). \nSelect(Function(_It_) New With { .Title = _It_.A.Title, .PriceA = _It_.A.Price, .BPrice = _It_.B.Price}). \nWhere(Function(_It_) Max(_It_.APrice, _It_.BPrice)<100) 5.2 Standard Query Operators The higher-kinded \nshape of a generic type M<T> that sup\u00adports the standard query operator pattern contains amongst others \nthe well-know higher-order monadic and list process\u00ading functions such as filter, renamed to Where; map, \nre\u00adnamed to Select; and of course >>= (bind), renamed to SelectMany: class M<T> { M<T> Where(Func<T, \nbool> p); M<S> Select<S>(Func<T,S> f); M<T> SelectMany<S>(Func<T,M<S>> f); ... } Other standard query \noperators include OrderBy, GroupBy, Join, GroupJoin, Aggregate (Haskell s foldr), etc. When Java and \nthe CLR introduced generics, they unfortu\u00adnately did not allow for parameterizing over type construc\u00adtors \nas opposed to abstracting over just types. The conse\u00adquence of this oversight is that is impossible to \nenforce the standard query-operator pattern using the CLR or Java type system. Because of the purely \nsyntactic way comprehensions are translated into the underlying sequence operators (as we will see in \nthe next section), it is also possible to imple\u00adment the pattern using non-generic types, for instance \nus\u00ading a Where method with signature T Where(this Q src, Func<R,S> p). In this case, the type dependency \nbetween the element type of the source and the argument type of the predicate is lost, which means we \ncannot de.ne typing rules at the level of query comprehensions themselves. The upside of this .exibility \nis that we get more freedom to implement the standard query pattern. For example, the various methods \ncould also be de.ned as extension methods (which we rely on for the implementation of the pattern over \nIEnumerable<T>, see \u00a75.3) and most importantly, the methods can take expressions trees (see \u00a75.7) instead \nof just delegates. It is quite surprising that Haskell is one of the very few languages that allows higher-kinded \ntype variables. If, on the term level, parametrizing over functions is useful, doing the same on the \nlevel of types sounds like an obvious thing to do. As far as we know Scala is the only other language \nbesides Haskell that also support higher-kinded types [85] 5.3 Extension Methods In both Visual Basic \nand C , methods are non-virtual by default. An instance method is really nothing more than a static method \nwith an implicit receiver (called Me in Visual Basic, and this in C ). In particular, calling an instance \nmethod does not involve any dynamic dispatching and the call is resolved completely statically. Extension \nmethods lift the restriction that instance methods need to be de.ned in the receiver s class. In C 3.0 \nand Visual Basic 9, any static method can be marked as an extension method, and hence can be invoked \nusing instance call syntax e.f(...,a...) instead of using the normal static call syntax that mentions \nthe class C in which the method is de.ned C.f(e,...,a,...). The major advantage of extension methods \nover regular instance methods is that we can add extension methods to a receiver type after the fact, \nand moreover, we can add new methods to any type, including interfaces such as IEnumerable<T> and constructed \ntypes such as string[]. This latter capability is key to de.ning the standard query operators over any \ntype. For instance, using C syntax, the de.nition of the standard query operator selectMany on IEnumerable<T> \n(the bind operator >>= of the list monad in Haskell) is de.ned as follows: static IEnumerable<S> selectMany<T,S> \n( this IEnumerable<T> src, Func<T, IEnumerable<S>> f) { foreach(var t in src) foreach(var s in f(t)) \nyield return s; } Extension methods are a pure compile-time mechanism. The runtime type of the receiver \nis not actually extended with additional methods. In particular, re.ection does not know anything about \nextension methods and hence late binding over extension methods is not possible. In many ways this makes \nextension methods similar to the method call op\u00aderator receiver # method = method receiver that we introduced \nin Haskell when we started using COM compo\u00adnents, and which has popped up as the [> operator in F . \n5.4 Object Initializers Introducing query comprehensions in the language forces us into a much more expression-oriented \nstyle than the usual statement-oriented style that people are used to in impera\u00adtive languages. To facilitate \nthis, both C and Visual Basic introduce object initializers, which correspond closely to la\u00adbeled construction \nin Haskell. An object initializer such as (using C syntax): var p = new Person{First=\"John\", Last=\"Doe\"}; \ncreates a new instance of Person and then assigns values to the First and Last .elds or properties of \nthe just-created instance. Many types contain read-only members of mutable types; to initialize these \nwe just supply a list of values for each mem\u00adber to initialize it. If we want to create a new instance \nfor an embedded member, we recursively use an object initializer expression: Dim Pair = New Person With \n{ .Name = New Name With { ... }, .Address With { .City = \"Seattle\", ... } } 5.5 Anonymous Types In queries \nwe often want to combine several values by pro\u00adjecting out a subset of their members without having to \ndeclare and introduce a new nominal type. This is exactly the reason that functional languages and C. \nsupport tuples and/or labeled records. For Java, C , and Visual Basic pro\u00adgrammers that grew up with \nmonomorphic nominal types with arrays as the sole structural type, the concept of anony\u00admous types is \nstill revolutionary. In Visual Basic, we create an anonymous record with a Name and a City member by \nusing syntax similar to that of nominal object initializers: Dim Customer = New With {.Name = \"Bill\", \n.City = \"Seattle\"} Since extensible records and record subtyping are still open research problems, and \nbecause the underlying CLR runtime does not directly support structural types, neither C nor Visual Basic \nsupports (width or depth) record subtyping. In both languages, anonymous types are expressible (they \ncan be the result of an expression) but not denotable (you cannot write down their type), so they cannot \nappear as ar\u00adgument or result types of methods, or used as properties or .elds. Hence type inference \nis absolutely necessary for ex\u00adpressions that return anonymous types (see below). Within a single method, \nall structurally equivalent anonymous types are mapped to the same underlying compiler-generated nom\u00adinal \ntype. In C , equality on anonymous types is de.ned structurally, that is, the compiler generates implementations \nof Equals and GetHashCode based on the structure of the type. To ensure soundness, anonymous types in \nC are immutable. In Visual Basic, the .elds of anonymous types are mutable, except those that are marked \nwith the Key modi.er. The Equals and GetHashCode methods are de.ned in terms of Key .elds only [105]. \n 5.6 Type Inference In a purely nominal type system such as pre-generics Java or CLR, type inference \ndoes not add much value. When the only compound types are arrays, most expressions have simple monomorphic \ntypes, such as Hashtable, regard\u00adless of whether their real type, such as HashTable<int, List<string>>, \nis complex or not. With the advent of generics and anonymous types, values can be typed much more precisely, \nwhich makes explicit typing painful. In par\u00adticular it is painful to have to duplicate the type in both \nthe constructor and at the variable declaration: HashTable<int,List<string>> tedious = new HashTable<int,List<string>>(); \nThe problem is less pressing in Visual Basic (and C++) that already supports a concise syntax for combining \nlocal variable declarations and constructor calls Dim sweet As New HashTable(Of Int, List(Of String))() \nTypically, type inference algorithms look at all uses of a variable and infer a most general type via \nuni.cation or constraint-solving. While this guarantees that inferred types are in some sense the most \nprecise, it also leads to hard-to\u00adunderstand error messages, as every Haskell and SML user has experienced. \nType inference in the presence of overload\u00ading and subtyping is a hard problem, and has been a very active \nresearch area for many years [89]. The presence of the \u00a8 uber type Object makes inferred types based \non tak\u00ading least upper bounds degenerate to Object pretty quickly. However, using the same variable at \ntwo disparate types with Object as their closest supertype is most always an error. The situation even \ngets murkier due to (user-de.ned) im\u00adplicit conversions. Inferring types for function arguments in an \nobject-oriented language is also non-obvious. For example, what would be the inferred type for the parameter \nx of the lambda\u00adexpression x => x.Foo when there are multiple types (classes or interfaces) in scope \nthat have a Foo property, each of which can have a different return type. Haskell type classes arti.cially \navoid this problem by insisting that a method cannot be de.ned in different classes in scope. The 80/20 \nsolution is to infer types only from the initial\u00adizer expression of local variable declarations and never \nin\u00advent new types during inference. This is simple, simple to implement, and is conceptually closest \nto explicitly typed local declarations; the only difference is that the compiler will infer the type \nthat the programmer would provide oth\u00aderwise. The pragmatic choice we made is a classic exam\u00adple of worse \nis better [4]. However, programming lan\u00adguage researchers should keep pushing for the right thing [8, \n19, 26, 14, 10]. 5.7 Expression Trees One of the biggest hassles of deep embedding is creating representations \nof embedded programs with bound vari\u00adables. Because Haskell lacked quoting or any form of rei.\u00adcation \nof its internal parse trees, HaskellDB required sub\u00adtle hacks involving combinators that create abstract \nsyntax trees. This forced users to write unnatural looking expres\u00adsions such as X!name .==. constant(\"Joe\"). \nIn Lisp or Scheme we would simply use quote and quasi\u00adquote to turn code into data and escape back to \ncode. The problem with explicit quoting in Lisp is really the same as the HaskellDB mechanism: the API \nwriter has to decide to use data or code, and then the user has to decide to quote or not. Pushing the \nburden upon the consumer is what we call retarded innovation , although those skilled in the art of Scheme-macro \nhacking can probably work around the need for explicit quoting. One of the most exciting features of \nboth C 3.0 and Visual Basic 9 is the ability to create code as data by converting an inline function \nor lambda expression based on the expected static type of the context in which the lambda expression \nappears. Assume we are given the Visual Basic lambda expression Function(X)X>42. When the target type \nin which that lambda expression is used is an ordinary delegate type, such as Func(Of Integer, Boolean), \nthe compiler gen\u00aderates MSIL for a normal delegate of the required type. On the other hand, when the \ntarget type is of the special type Expression(Of Func(Of Integer, Boolean)) (or any other nested delegate \ntype), the compiler generates MSIL that when executed will create an intentional representation of the \nlambda expression that can be treated as an AST by the receiving API. The major advantage of this style \nof type-directed quoting via Expression<Func<..>> is that it is now (nearly) trans\u00adparent to the consumer \nof an API whether to quote or not. The user only has to remember to use lambda expressions as opposed \nto ordinary delegate syntax. 5.7.1 LINQ-to-SQL LINQ-to-SQL is a domain-speci.c library for accessing \nre\u00adlational data that makes heavy use of expression trees. It relies on the IQueryable interface that \nmirrors the stan\u00addard sequence operators de.ned on IEnumerable, but uses expression trees Expression \n(< Func< ...>> instead of delegates Func<...>. Just as HaskellDB, the LINQ-to-SQL infrastructure then \ncompiles these expression trees into SQL and creates objects from the result of running the query on \na remote database. LINQ-to-SQL also provides the usual object-relational mapping infrastructure such \nas a context that tracks object identity of rehydrated rows, and tracks changes to the object graph to \nsubmit changes back to the underlying database.  5.8 XML integration Ideally, XML should just be a wire-serialization \nformat, and therefore completely hidden from the programmer. However when developers are forced to deal \nwith raw XML, it should be as convenient and simple as possible to create, manip\u00adulate, and query XML. \nFor this reason, LINQ introduces LINQ-to-XML [68] to replace the standard W3C DOM. On top of LINQ-to-XML, \nVisual Basic 9 supports deep embed\u00adding of XML via XML literals, and special axis member syntax that \nabbreviate the most common access patterns to select attributes, and child and descendant elements. In \ncombination with query comprehensions, the XML sup\u00adport in Visual Basic largely eliminates the need for \nbig stan\u00addard special-purpose XML-manipulation languages such as XQuery. As always happens, XQuery started \nas a declara\u00adtive domain speci.c language, but is evolving into a full\u00ad.edged imperative programming \nlanguage anyhow [55]. Time will tell if users are willing to make the effort of abandoning existing OO \nlanguages and switch to XML and XQuery, or that they rather stick with what they already know extended \nwith what they need to get their job done. Note that XQuery and LINQ sharea common monad-based semantic \nfoundation [40, 69]. 5.8.1 LINQ-to-XML API The standard W3C DOM API is document-centric, which means \nthat elements and attributes can only exist in the con\u00adtext of a speci.c document; elements and attributes \nare not .rst-class values. Due to this document-centricity, construc\u00adtion of nodes becomes imperative. \nYou .rst create a node using a factory method on the target document and then ex\u00adplicitly add it as a \nchild of another existing node. The DOM model is inside-out: imperative construction does not .t very \nwell in the expression-oriented style required by LINQ. Accessing nodes using the DOM is inconsistent, \nwith many special cases. The GetAttribute and GetAttributeNode methods access a particular child attribute, \nbut the Item de\u00adfault property (indexer) accesses child elements. The special FirstChild and LastChild \nmethods exist for elements but not for attributes. In LINQ-to-XML elements and attributes are .rst-class \nval\u00adues that are constructed via normal constructor calls (func\u00adtional construction), independent of \nany particular docu\u00adment context. When an already parented node is added as a child of another parent \nnode, the child node is automatically cloned and reparented. All XPath axes, such as Parent, Descendants, \nElements, Attributes, and so on, are available as consistently named (extension) methods on nodes and \ncollections of nodes. The latter, closely re.ects member lifting of C.. 5.8.2 XML Literals While the \nLINQ-to-XML API is already a major improve\u00adment over the DOM, it is not yet simple enough. On top of \nLINQ-to-XML s functional construction, Visual Basic al\u00adlows XML literals that the compiler translates \ninto LINQ-to-XML constructor calls. For instance, the declaration below Dim CD = <CD Genre=\"rock\"> <Title>Stop!</Title> \n<Artist>Sam Brown</Artist> <Year>1988</Year> </CD> is compiled into effectively following LINQ-to-XML \ncalls (in reality the compiler unfolds the constructor calls and immediately generates the underlying \nimperative statements to add child nodes to the parent): Dim CD = New XElement(\"CD\", New XAttribute(\"Genre\",\"rock\"), \nNew XElement(\"Title\", \"Stop!\"), New XElement(\"Artist\", \"Sam Brown\"), New XElement(\"Year\", 1988)) XML \nliterals can contain expression holes (quasi-quotation [54]) at any position where the underlying API \nallows an argument of a type compatible with the expression plugged into the hole. For example, we can \ncreate an XML document with all rock CDs from the FreeDB database using the fol\u00adlowing simple query: \nDim Rock = <?xml version=\"1.0\" ?> <CDs><%= From CD In FreeDB Where CD.Genre = \"rock\" Select <CD> <Title><%=CD.Title%></Title> \n<Artist><%=CD.Artist%></Artist> <Year><%=CD.Year%></Year> </CD>%> </CDs> The document declaration <? \nxml version=\"1.0\" ?> causes the inferred type of the variable Rock to be XDocument. Unlike C. and previously \nmentioned research-oriented XML-centric programming languages, we do not assume any schema information \nin order to deal with XML doc\u00aduments. Instead Visual Basic optionally layers[32] XSD schema information \non top of the CLR type-system to guide Intellisense in the IDE. This type information has no, and cannot \nhave any, impact on the runtime behavior of the pro\u00adgram; the underlying LINQ-to-XML API is a completely \nschema-agnostic XML object model. 5.8.3 Namespaces We gladly got rid of XSD schema, but there is no \nway around XML namespaces. As James Clark remarks [17], namespaces are one of the most confusing aspects \nof XML. Perhaps the main bene.t of XML literals is the fact that users can copy and paste XML, including \nnamespaces, into a Visual Basic program and start modifying it from there, in the same way many of us \ndeal with make .les, and LATEX documents. There are two ways to declare a namespace pre.x: by using a \nglobal Imports <xmlns:prefix=URI> namespace decla\u00adration, or by a local xmlns:prefix=URI declaration \ninside an XML element. Imports <xmlns:X=\"http://www.freedb.org\"> Dim CD = <Y:CD Genre=\"rock\"> xmlns:Y=\"http://www.freedb.org\" \n<Y:Title>Live!</Y:Title> <X:Artist>Anouk</X:Artist> <Y:Year>1997</Y:Year> </Y:CD> Global namespace declarations \nscope over the whole pro\u00adgram, while local namespace declarations scope over their embedded elements \nand attributes, but not inside expression holes. 5.8.4 Axis Members To simplify querying XML, we have \nintroduced special syntax for the three most common XPath axis: Children, Descendants, and Attributes. \n The child axis cd.Children(\"Title\") is written using mnemonic syntax cd.<Title> designed speci.cally \nto emphasize XML element access as opposed to ordinary member access.  The descendant axis CDs.Descendants(\"Artist\") \nis similar, but uses three dots CDs...<Artist>, again to emphasize the difference with regular member \naccess.  The attribute axis cs.Attributes(\"Genre\") is abbre\u00adviated as cd.@Genre.  Element (and attribute) \nnames are expanded to their fully quali.ed names based on the closest namespace pre.x dec\u00adlaration in \nscope. Hence in the example above, the fully qual\u00adi.ed name of the element <Y:Year> looks as follows: \n<{http://www.freedb.org}Year> So in order to access that node, we must use the global pre.x declaration \nX for the same namespace URI, and write CD.<X:Year>. 6. The Great Internet Hype, Version 2.0 After a \n.ve-year hibernation, people have rediscovered DHTML and client-side scripting in combination with Web \nservices under the monikers Web 2.0 and AJAX. People of\u00adten snort at Visual Basic, either because they \nstill have an outdated idea of Basic in mind, or because they think that Visual Basic .NET is just C \nwith slightly more verbose syn\u00adtax. Nothing is further from the truth. Visual Basic is the ultimate language \nto democratize programming against the Cloud.    6.0.5 Transactions, Joins, and Morphisms The advent \nof multi-core processors will put highly paral\u00adlel machines on the desktops of normal people. Transactions \n[46] are perhaps the only way imperative programmers can deal with concurrency because transactions allow \nyou them continue to think as if your program runs in isolation. While shared-nothing, message passing, \nconcurrency as supported by Erlang [23] might be 10X better, they require program\u00admers to make a complete \nparadigm switch and hence accord\u00ading to the Change Function the chance of success is small (both obviously \nfor Erlang greater than zero). For more advanced scenarios that require complex synchro\u00adnization patterns, \nwe believe that C. style join patterns [24, 94] are most attractive. Declarative events allow users to \nde\u00adclare a disjunction of events that are handled by a particular event handler. For instance, the Handles \nclause below speci.es that the method __Click_Or_Focus will run when either the Button .Click, or the \nTextbox.Focus is received: Sub __Click_Or_Focus (S As Object, E As EventArgs) Handles Button.Click, TextBox.Focus \n... End Sub Declarative join patterns are a natural extension of this model where the When clause speci.es \nthe handler that has to be run when a conjunction of messages have been re\u00adceived. To the caller, messages \njust look like methods, ex\u00adcept that asynchronous message calls return immediately whereas synchronous \nmessage calls may block. The OnePlaceBuffer below speci.es that when both a Put and __Empty message are \nqueued, the __Put_And_Empty handler is .red, and when both the Take and __Contains messages are queued, \nthe __Take_And_Contains handler is .red. Class OnePlaceBuffer(Of T) Public Synchronous Put(t As T) Public \nSynchronous Take() As T Asynchronous __Empty() Asynchronous __Contains(t As T) Sub __Put_And_Empty(t \nAs T) When Put, _Empty Me.__Contains(t) End Sub Function __Take_And_Contains(t As T) As T When Take, \n__Contains Me.__Empty() Return t End Function Public Sub New() Me.__Empty() End Sub End Class This should \nbe easy to grasp for programmers that already have a basic understanding of event handling. It is also \ninteresting to see a resurging interest in morphisms and program transformations in the context of massively \nparallel computing [38]. The query syntax in Visual Basic 9 was designed speci.cally as an alternative \nto domain speci.c language such as Sawzall [90]. Aggregate comprehensions enable MapReduce-style queries \nto be expressed directly in Visual Basic. 6.1 Static Typing Where Possible, Dynamic Typing Where Needed \nThe arti.cial separation between the supporters of dynam\u00adically and statically typed languages is rather \nunfortunate [71]. In particular, dynamically typed languages miss a great chance to leverage static information \nabout programs that the compiler and tools can leverage. Not writing types does not imply no static types \n[12]. On the other hand, we should not forget that all statically typed languages need a few drops of \ndynamism (downcasts, re.ection, array bounds checking) to make things run smoothly. Every useful Haskell \nprogram somehow relies on unsafePerformIO. Visual Basic is unique in that it allows static typing where \npossible and dynamic typing where necessary. When the receiver of a member-access expression has static \ntype Object, member resolution is phase-shifted to runtime since at that point the dynamic type of the \nreceiver has become its static type. The type rule for the statically typed method invocation is standard. \nThe relation R m(S) As T . M encodes the member lookup and overload resolution for a method m to .nd \nthe code M to call when the receiver has static type R and the argument has static type S. G f e As R \n. E, G f a As S . A, R m(S) As T . M G f e.m(a) As T . M(E,A) In the late-bound case, when the receiver \nhas type Object and the previous rule does not apply, static method resolution failed. Instead of bailing \nout and reporting a type error, Visual Basic instead defers member lookup and overload resolution to \nrun-time by inserting the LateCall function, passing it the name of the method, the receiver, and the \nactual argument. G f e As R . Object, G f a As Object . A G f e.m(a) As Object . LateCall(\"m\",E,A) At \nruntime, when executing the LateCall, we determine the dynamic types of the receiver and the argument, \nand perform the delayed member lookup to .nd the code M that actually needs to be called: r.GetType() \n. R, a.GetType() . S, R m(S) As T . M LateCall(\"m\", r, a) . M(r,a) Late binding in Visual Basic implements \na form of multi\u00admethods since late calls are resolved based on the dynamic types of all their arguments. \nAnother aspect in which Visual Basic differs from statically typed languages such as C and Java, is that \nthe Visual Basic compiler inserts not just upcasts, but downcasts too, auto\u00admatically. We are using this \nability to relax the creation of delegates in such a way that it is allowed to create a dele\u00adgate of \ntype Func(Of A,R) from any function f that can be called with an actual argument of type A and assigned \nto a variable of type R. The compiler inserts a casting stub Function(X As A)CType(f(X), R) of the exact \ntype re\u00adquired by the delegate.  6.2 Possible Language Enhancements The intersection between dynamic \nand static languages has proven to be a fertile ground for language designers [41, 96, 104, 33] and we \nsee a lot of interesting opportunities to improve Visual Basic in this respect. 6.2.1 Dynamic Identi.ers \nInspecting the type rule for late binding, it is clear that there is no reason that the method name in \nlate-bound calls needs to be statically determined. Dynamic identi.ers allow calls of the form e.(m)(a) \nwhere m is any expression whose type is convertible to string. Note that dynamic identi.ers make it quite \neasy to de.ne a meta-circular interpreter for Visual Basic since |[e.m(a)]| = |[e]|.(\"m\")(|[a]|). This \nkind of inter\u00adpretation is extremely useful for data-driven test harnesses [82]. In a future version \nof Visual Basic, we also hope to allow the replacement of constants by variables in any place where the \nruntime infrastructure allows us to compute corre\u00adsponding entities at runtime. This would make Visual \nBasic as dynamic as possible within the limitations set by the un\u00adderlying CLR. 6.2.2 Explicit Relationships \nOne of the nice things about the relational model is that rela\u00adtionships between tables are external. \nThat is, children point to the parents (foreign key . primary key relationship) as opposed to from parents \npointing to children. As a result, it becomes possible to create explicit relationships [29] be\u00adtween \ntypes after the fact, without modifying the participat\u00ading types. This is important when we want to relate \ndata from different sources. For example relating descriptions of CDs from a web-services with a CD collection \nin ITunes on a lo\u00adcal machine. By adding support for explicit relationships in the language, we can navigate \nsuch relationship via the fam\u00adiliar dot-notation instead of having to perform complicated joins using \nmiddle tables. Another useful extension that aids dynamism and enables explicit relationships is dynamic \ninterfaces. This let you implement an interface on an existing type after the fact, much as in Haskell \nwere we can create an instance of a given type for a type class independent of the de.nition of that \ntype [109].  6.2.3 Contracts The static type systems of most contemporary programming languages are \nactually not that expressive at all. They only allow developers to specify the most super.cial aspects \nof the contract between caller and callee of their code. For in\u00adstance, the signature of the Slice method \nbelow speci.es that it takes an array and two integers as arguments, and re\u00adturns an array of integers \nas its result. But it does not convey any relevant information about the intended semantics of the method; \nthat given an array src, a start index i such that 0 =< i, an end index j such that i =< j =< src.Length, \nthe array elements within the indicated range are copied into a new array: T[] Slice(this T[] src, int \ni, int j){...} From a program-speci.cation point of view, most programs are extremely dynamically typed! \nWhat we really need is a dial that we can turn from no static typing on the one extreme, to traditional \nstatic typing in the middle, to full contracts and invariants [15, 9, 13] on the other extreme. While \nwe believe that pre-and post-conditions are ready for promotion from the research world to the real world, \nwe feel that object invariants are maybe not yet ready for prime time [88]. 7. Conclusions and Final \nMusings Since lambda expressions, meta-programming, monads, and comprehensions are abstract mathematical \nconcepts, it might seem remarkable that they show up in contemporary lan\u00adguages such as C 3.0, Visual \nBasic 9, and Java, as well as in more experimental hybrid functional/OO languages such as Fortress, Scala, \nFortress, and F . It is especially remarkable since, in the Haskell community, monads are still considered \nas one of the most advanced and dif.cult features to master. The explanation for this apparent contradiction \nis that the successful programming languages understand developer in\u00adertia and obey the Change Function. \nThey offer a solution to deep developer pain with a very low adoption threshold. The reason why most \nresearch languages die a quick death, and successful languages a slow one, is because they do not realize \nthat users are in charge. Instead they promise mira\u00adcles of improved productivity and automatic correctness; \nas well the fact that in the future their implementations will be fast enough thanks to better and more \nadvanced compiler optimizations [7]. Sometimes a niche language targets a se\u00advere enough crisis, one \nthat is larger than the perceived pain of adoption, and hence it gathers enough velocity to escape death. \nA good example of a language in this category is Er\u00adlang. Hopefully, Haskell will escape death as well. \nReaching out to real users is a necessary condition for suc\u00adcess, but by no means suf.cient. Successfully \ntransferring technology from research to the mainstream also requires that all research problems be solved \nupfront, leaving imple\u00admentation as just a matter of engineering. While the goal of research is to push \nthe envelope as hard as possible, the role of product development is to pick and choose from the research \nresults and simplify the contributions as much as possible, but not more. Research should not try to \nbe\u00adcome advanced development, that amounts to eating our own seed corn. Product development should not \nattempt to do re\u00adsearch, that diminishes the chances to ship anything. It necessarily takes a long time \nfor great research ideas to surface in the real world. The reason is simply that it takes time for the \ngood ideas to .oat up and mature, and for the bad ideas to sink down and wither away. Skimming the cream \nfrom the research results requires patience. It is very hard to plan and speed up innovation. There is \none aspect of the division between research and practice that I do not know how to solve. In practice \nmost development effort goes into the noise that researchers ab\u00adstract away in order to drill down to \nthe core of the problem. However, it is often in this noise that the hard implementa\u00adtion problems are \nhidden. For example, most programming language research papers de.ne a tiny subset [28] of the full programming \nlanguage. This enables the authors to de.ne and study the properties of the dynamic and static semantics \nof that language in a more controlled way. There is noth\u00ading wrong per se with observing programming \nlanguages inside a Petri dish. The irony is that such minimalistic sub\u00adsets gives rise to a nice and \nsimple formalization, whereas language implementers actually need help formalizing the rough edges of \nthe language, not the beautiful and clean subset. If something is easy to formalize, it is probably easy \nto implement. If something is hard to formalize, it is for sure really hard to implement. But that keeps \neverybody off the streets. Acknowledgments The list of people to thank would be extremely long, and even \nthen I would run the risk of forgetting someone. Instead of inadvertently stepping on someone s toes, \nlet me instead say that the only reason a dwarf like me can see this far is that I have been standing \non the shoulders of giants. All things are subject to change, and nothing can last forever. Look at your \nhand, young one, and ask your\u00adself, Whose hand is this? Can your hand correctly be called yours ? Or \nis it the hand of your mother, the hand of your father. Re.ect on the impermanent nature of your hand, \nthe hand that you once sucked in your mother s womb. [31] References [1] http://caml.inria.fr/ [2] http://docs.google.com/view \n?docid=ddhp95vd_6hg3qhc [3] http://docs.google.com/view ?docid=k73_1ggr36h [4] http://dreamsongs.com/worseisbetter.html \n[5] http://en.wikipedia.org/wiki/pimp_my_ride [6] http://haskelldb.sourceforge.net/ [7] http://research.microsoft.com/ \n~toddpro/papers/law.htm [8] http://research.microsoft.com /fsharp/about.aspx [9] http://research.microsoft.com \n/specsharp/ [10] http://research.sun.com/projects /plrg/fortress.pdf [11] http://www.artima.com/weblogs/viewpost.jsp \n?thread=182412 [12] http://www.cis.upenn.edu/ ~bcpierce/types/archives/1988/msg00042.html [13] http://www.cs.iastate.edu/ \n~leavens/jml/documentation.shtml [14] http://www.doc.ic.ac.uk/~scd/ [15] http://www.eiffel.com/ [16] \nhttp://www.javac.info /closures-v05.html [17] http://www.jclark.com/xml/xmlns.htm [18] http://www.plt-scheme.org \n/publications.html [19] http://www.scala-lang.org/ [20] http://www.w3.org/tr/xquery/ [21] http://www.w3.org/xml/schema \n[22] The Haskell 98 Foreign Function Interface 1.0, 2003. [23] Joe Armstrong. Programming Erlang: Software \nfor a Concurrent World. Pragmatic Bookshelf, 2007. [24] Nick Benton, Luca Cardelli, and C\u00b4edric Fournet. \nMod\u00adern Concurrency Abstractions for C. . ACM TOPLAS, 26(5):769 804, 2004. [25] V\u00b4eronique Benzaken, \nGiuseppe Castagna, and Alain Frisch. CDuce: an XML-Centric General-Purpose Language. In Proceedings ICFP, \n2003. [26] Gavin Bierman. Formalizing and Extending C. Type Inference. In Proceedings FOOL/WOOD, 2007. \n[27] Gavin Bierman, Erik Meijer, and Wolfram Schulte. The essence of Data Access in C.. In Proceedings \nECOOP, volume 3586 of LNCS, 2005. [28] Gavin Bierman, Erik Meijer, and Mads Torgersen. Lost in Translation: \nFormalizing Proposed Extensions to C. . In Proceedings OOPSLA, 2007. [29] Gavin Bierman and Alisdair \nWren. First-Class Relation\u00adships in an Object-Oriented Language. In Proceedings ECOOP, volume 3586 of \nLNCS, 2005. [30] Per Bjesse, Koen Claessen, Mary Sheeran, and Satnam Singh. Lava: hardware design in \nhaskell. SIGPLAN Notices, 34(1):174 184, 1999. [31] Matthew Bortolin. The Dharma of Star Wars. Wisdom \nPublishers Inc., Boston, 2005. [32] Gilad Bracha. Pluggable Type Systems. In Proceedings OOPSLA Workshop \nOn The Revival Of Dynamic Lan\u00adguages, 2004. [33] Gilad Bracha and David Griswold. Strongtalk: typechecking \nsmalltalk in a production environment. ACM SIGPLAN Notices, 28(10):215 230, 1993. [34] Niklas Broberg. \nHaskell Server pages Through Dynamic Loading. In Proceedings Haskell Workshop, 2005. [35] Magnus Carlsson \nand Thomas Hallgren. FUDGETS -A Graphical User interface in a Lazy Functional Language. In Proceedings \nFPCA, 1993. [36] James Cheney and Ralf Hinze. First-Class Phantom Types. Computer and Information Science \nTechnical Report TR2003-1901, Cornell University, 2003. [37] Pip Coburn. The Change Function: Why Some \nTechnologies Take Off and Others Crash and Burn. 2006. [38] Jeffrey Dean and Sanjay Ghemawat. MapReduce: \nSimpli\u00ad.ed Data Processing on Large Clusters. In Proceedings OSDI, 2004. [39] Conal Elliott, Sigbj\u00f8rn \nFinne, and Oege de Moor. Compiling embedded languages. Journal of Functional Programming, 13(2), 2003. \nUpdated version of paper by the same name that appeared in SAIG 00 proceedings. [40] Mary F. Fernandez, \nJ\u00b4ome Sim\u00b4er eon, and Philip Wadler. A semi-monad for semi-structured data. In Proceedings of the 8th \nInternational Conference on Database Theory, volume 1973 of LNCS, 2001. [41] Cormac Flanagan. Hybrid \ntype checking. In Proceedings POPL, 2006. [42] Matthew Fluet and Riccardo Pucella. Phantom types and \nsubtyping. Journal of Functional Programming, 16(6):751 791, 2006. [43] Matthew Fluet and Riccardo Pucella. \nPractical datatype specializations with phantom types and recursion schemes. Electronic Notes on Theoretical \nComputer Science, 148(2):211 237, 2006. [44] Peter Freyd. Recursive types reduced to inductive types. \nIn Proceedings LICS, 1990. [45] Jeremy Gibbons and Oege de Moor, editors. The Fun of Programming. Cornerstones \nin Computing. Palgrave, 2003. [46] Jim Gray and Andreas Reuter. Transaction Processing: Concepts and \nTechniques. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1992. [47] Matthew Harren, Mukund \nRaghavachari, Oded Shmueli, Michael G. Burke, Rajesh Bordawekar, Igor Pechtchanski, and Vivek Sarkar. \nXJ: Facilitating XML Processing in Java. In Proceedings WWW, 2005. [48] Haruo Hosoya, J\u00b4er ome Vouillon, \nand Benjamin C. Pierce. Regular expression types for XML. ACM TOPLAS, 27(1):46 90, 2005. [49] Paul Hudak. \nBuilding domain-speci.c embedded lan\u00adguages. ACM Computing Surveys, 28(4es):196, 1996. [50] J. Hughes. \nWhy Functional Programming Matters. Com\u00adputer Journal, 32(2):98 107, 1989. [51] Nigel Perry, Jason Smith \nand Erik Meijer. Mondrian for .NET. DDJ, 2002. [52] Simon Peyton Jones. Tackling the awkward squad: monadic \ninput/output, concurrency, exceptions, and foreign-language calls in haskell. In Marktoberdorf Summer \nSchool, 2000. [53] Simon Peyton Jones, Mark Shields, John Launchbury, and Andrew Tolmach. Bridging the \nGulf: a Common Intermediate Language for ML and Haskell. In Proceedings POPL, 1998. [54] Richard Kelsey, \nWilliam Clinger, and Jonathan Rees (Editors). Revised5 report on the algorithmic language Scheme. ACM \nSIGPLAN Notices, 33(9):26 76, 1998. [55] Donald Kossmann, Michael Carey, Don Chamberlin, Mary Fernandez, \nDaniela Florescu, Giorgio Ghelli, Jonathan Robie, and Jerome Simeon. Xqueryp: An XML application development \nlanguage. In Proceedings XML, 2006. [56] R. L\u00a8ammel and E. Meijer. Mappings make data processing go round \n An inter-paradigmatic mapping tutorial. In Generative and Transformation Techniques in Software Engineering, \nvolume 4143 of LNCS, 2005. [57] R. L\u00a8ammel and E. Meijer. Revealing the X/O impedance mismatch (Changing \nlead into gold). In Datatype-Generic Programming, volume 4719 of LNCS, 2007. [58] Ralf L\u00a8ammel and Dave \nRemy. Functional OO Programming with Triangular Circles. In Proceedings XML, 2006. [59] Peter J. Landin. \nThe next 700 programming languages. Communications of the ACM, 9(3):157 166, March 1966. [60] John Launchbury, \nJeffrey R. Lewis, and Byron Cook. On embedding a microarchitectural design language within haskell. In \nICFP 99: Proceedings of the fourth ACM SIGPLAN international conference on Functional program\u00adming, 1999. \n[61] Daan Leijen. Functional Components: COM Components in Haskell. Master s thesis, Department of Computer \nScience, University of Amsterdam, september 1998. [62] Daan Leijen and Erik Meijer. Domain speci.c embedded \ncompilers. In Proceedings DSL, 1999. Also appeared in ACM SIGPLAN Notices 35, 1, (Jan. 2000). [63] Daan \nLeijen, Erik Meijer, and James Hook. Haskell as an Automation Controller. In The 3rd International Summerschool \non Advanced Functional Programming, volume 1608 of LNCS, 1999. [64] Sheng Liang. Modular Monadic Semantics \nand Compila\u00adtion. 1997. [65] Sheng Liang. Java Native Interface: Programmer s Guide and Reference. Addison-Wesley, \n1999. [66] Andres L\u00a8oh and Ralf Hinze. Open data types and open functions. In Proceedings PPDP, 2006. \n[67] Erik Meijer. Server-Side Web Scripting in Haskell. Journal of Functional Programming, 10(1):1 18, \njanuary 2000. [68] Erik Meijer and Brian Beckman. XLINQ: XML Program\u00adming Refactored (The Return Of The \nMonoids). In Pro\u00adceedings XML, 2005. [69] Erik Meijer, Brian Beckman, and Gavin Bierman. Linq: reconciling \nobject, relations and XML in the .net frame\u00adwork. In Proceedings SIGMOD international conference on Management \nof data, 2006. [70] Erik Meijer and Koen Claessen. The Design and Imple\u00admentation of Mondrian. In Proceedings \nHaskell Workshop, 1997. [71] Erik Meijer and Peter Drayton. Static Typing Where Possible, Dynamic Typing \nWhen Needed: The End of the Cold War Between Programming Languages. In Proceedings OOPSLA Workshop On \nThe Revival Of Dynamic Languages, 2004. [72] Erik Meijer and Sigbjorn Finne. Lambada, Haskell as a Better \nJava. In Proceedings Haskell Workshop, 2000. [73] Erik Meijer, Maarten Fokkinga, and Ross Paterson. Func\u00adtional \nProgramming with Bananas, Lenses, Envelopes, and Barbed Wire. In Proceedings FPCA, volume 523 of LNCS, \n1991. [74] Erik Meijer and John Gough. Technical overview of the common language runtime, 2000. [75] \nErik Meijer and Graham Hutton. Bananas in space: extending fold and unfold to exponential types. In Proceedings \nFPCA, 1995. [76] Erik Meijer, Daan Leijen, and James Hook. Client-side Web Scripting with HaskellScript. \nIn Proceedings PADL, volume 1551 of LNCS, 1998. [77] Erik Meijer, Nigel Perry, and Arjan van Yzendoorn. \nScripting .NET Using Mondrian. In Proceedings ECOOP, volume 2072 of LNCS, 2001. [78] Erik Meijer and \nWolfram Schulte. XML Types for C. . BillG ThinkWeek Submission Winter 2001. [79] Erik Meijer, Wolfram \nSchulte, and Gavin Bierman. Pro\u00adgramming with Circles, Triangles and Rectangles. In Pro\u00adceedings XML, \n2003. [80] Erik Meijer, Wolfram Schulte, and Gavin Bierman. Uni\u00adfying Tables, Objects and Documents. \nIn Proceedings DP-COOL, volume 27 of John von Neumann Institute of Computing, 2005. [81] Erik Meijer \nand Mark Shields. XMLambda: A Functional Programming Language for Constructing and Manipulating XML Documents. \nUnpublished draft. [82] Erik Meijer, Amanda Silver, and Paul Vick. Overview Of Visual Basic 9.0. In Proceedings \nXML, 2005. [83] Erik Meijer and Danny van Velzen. Haskell Server Pages: Functional Programming and the \nBattle for the Middle Tier. In Proceedings Haskell Workshop, 2000. [84] Robin Milner, Mads Tofte, Robert \nHarper, and David MacQueen. The De.nition of Standard ML (Revised). The MIT Press, 1997. [85] Adriaan \nMoors, Frank Piessens, and Martin Odersky. To\u00adwards equal rights for higher-kinded types. In Proceedings \nMPOOL, 2007. [86] Thomas Nordin and Simon Peyton Jones. Green Card: a Foreign-language Interface for \nHaskell. In Proceedings Haskell Workshop, 1997. [87] Andy Oram and Greg Wilson, editors. Beautiful Code: \nLeading Programmers Explain How They Think. O Reilly, 2007. [88] Matthew Parkinson. Class invariants: \nThe end of the road? In Proceedings IWACO, 2007. [89] Benjamin C. Pierce. Types and Programming Languages. \nThe MIT Press, Cambridge, Massachusetts, 2002. [90] Rob Pike, Sean Dorward, Robert Griesemer, and Sean \nQuinlan. Interpreting the data: Parallel analysis with sawzall. Science of Computer Programming, 13(4):277 \n298, 2005. [91] Riccardo Pucella, Erik Meijer, and Dino Oliva. Aspects de la Programmation d Applications \nWin32 avec un Langage Fonctionnel. In Journ\u00b4ees Francophones des Langages Applicatifs, 1999. [92] Christopher \nRe, Jerome Simeon, and Mary Fernandez. A complete and ef.cient algebraic compiler for xquery. In Proceedings \nICDE, 2006. [93] Ben Rudiak-Gould, Alan Mycroft, and Simon Peyton Jones. Haskell is not not ml. In Proceedings \nESOP, 2006. [94] Claudio Russo. The joins concurrency library. In Proceedings PADL, volume 4354 of LNCS, \n2007. [95] Mark Shields and Erik Meijer. Type-Indexed Rows. In Proceedings POPL, 2001. [96] Jeremy Graham \nSiek and Walid Taha. Gradual typing for objects. In Proceedings ECOOP, 2007. [97] Erik Meijer Sigbjorn \nFinne, Daan Leijen and Simon Peyton Jones. H/Direct: A Binary Foreign Language Interface for Haskell. \nIn Proceedings ICFP, 1998. [98] Erik Meijer Sigbjorn Finne, Daan Leijen and Simon Peyton Jones. Calling \nHell from Heaven and Heaven from Hell. In Proceedings ICFP, 1999. [99] Erik Meijer Simon Peyton Jones \nand Daan Leijen. Scripting COM Components in Haskell. In Proceedings Software Reuse, 1998. [100] P. Thiemann. \nA Typed Representation for HTML and XML Documents in Haskell. Journal of Functional Programming, 12(5):435 \n468, July 2002. [101] Peter Thiemann. WASH Server Pages. In Proceedings FLOPS, 2006. [102] Dave Thomas. \nThe impedance imperative tuples+objects+infosets=too much stuff! Journal of Object Technology, 2(5):7 \n12, September-October 2003. [103] Dave Thomas. Message oriented programming. Journal of Object Technology, \n3(5):7 12, May-June 2004. [104] Sam Tobin-Hochstadt and Matthias Felleisen. Interlanguage migration: \nfrom scripts to programs. In Proceedings OOPSLA Dynamic Language Symposium, 2006. [105] Mandana Vaziri, \nFrank Tip, Stephen Fink, and Julian Dolby. Declarative object identity using relation types. In Proceedings \nECOOP, 2007. [106] Phil Wadler and Simon Peyton Jones. Comprehensive comprehensions: comprehensions with \norder by and group by , 2007. [107] Philip Wadler. Comprehending monads. In Proceedings LFP, 1990. [108] \nPhilip Wadler. Lazy vs strict. ACM Computing Surveys, 28(2):318 320, 1996. [109] Stefan Wehr, Ralf L\u00a8ammel, \nand Peter Thiemann. Javagi: Generalized interfaces for java. In Proceedings ECOOP, 2007. [110] Martin \nWildmoser and Tobias Nipkow. Certifying machine code safety: Shallow versus deep embedding. In Proceed\u00adings \nTPHOLs, volume 3223 of LNCS, 2004.   \n\t\t\t", "proc_id": "1297027", "abstract": "<p>For many years I had been fruitlessly trying to sell functional programming and Haskell to solve real world problems such as scripting and data-intensive three-tier distributed web applications. The lack of widespread adoption of Haskell is a real pity. Functional programming concepts are key to curing many of the headaches that plague the majority of programmers, who today are forced to use imperative languages. If the mountain won't come to Mohammed, Mohammed must go to the mountain, and so I left academia to join industry. Instead of trying to convince imperative programmers to forget everything they already know and learn something completely new, I decided to infuse existing imperative object-oriented programming languages with functional programming features. As a result, functional programming has finally reached the masses, except that it is called Visual Basic 9 instead of Haskell 98.</p>", "authors": [{"name": "Erik Meijer", "author_profile_id": "81100295095", "affiliation": "Microsoft SQL Server, Redmond, WA", "person_id": "P78826", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297078", "year": "2007", "article_id": "1297078", "conference": "OOPSLA", "title": "Confessions of a used programming language salesman", "url": "http://dl.acm.org/citation.cfm?id=1297078"}