{"article_publication_date": "10-21-2007", "fulltext": "\n AWESOME: An Aspect Co-Weaving System for Composing Multiple Aspect-Oriented Extensions . Sergei Kojarski \nCollege of Computer and Information Science Northeastern University 360 Huntington Ave., Boston, Massachusetts \n02115, USA kojarski@ccs.neu.edu Abstract Domain speci.c aspect-oriented language extensions of\u00adfer unique \ncapabilities to deal with a variety of crosscut\u00adting concerns. Ideally, one should be able to use several \nof these extensions together in a single program. Unfortu\u00adnately, each extension generally implements \nits own spe\u00adcialized weaver and the different weavers are incompatible. Even if the weavers were compatible, \ncombining them is a dif.cult problem to solve in general, because each extension de.nes its own language \nwith new semantics. In this paper we present a practical composition framework, named AWE-SOME, for constructing \na multi-extension weaver by plug\u00adging together independently developed aspect mechanisms. The framework \nhas a component-based and aspect-oriented architecture that facilitates the development and integration \nof aspect weavers. To be scalable, the framework provides a default resolution of feature interactions \nin the composition. To be general, the framework provides means for customiz\u00ading the composition behavior. \nFurthermore, to be practically useful, there is no framework-associated overhead on the runtime performance \nof compiled aspect programs. To illus\u00adtrate the AWESOME framework concretely, we demonstrate the construction \nof a weaver for a multi-extension AOP lan\u00adguage that combines COOL and AspectJ. However, the com\u00adposition \nmethod is not exclusive to COOL and AspectJ it can be applied to combine any comparable reactive aspect \nmechanisms. . This work was supported in part by NSF s Science of Design program under grants numbered \nCCF-0438971 and CCF-0609612. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. OOPSLA 07, October 21 25, 2007, Montr\u00b4eal, Qu\u00b4ebec, Canada. Copyright c . 2007 \nACM 978-1-59593-786-5/07/0010. . . $5.00 David H. Lorenz Dept. of Mathematics and Computer Science The \nOpen University of Israel 108 Ravutski St., P.O. Box 808, Raanana 43107, Israel lorenz@openu.ac.il \nCategories and Subject Descriptors D.1.5 [Programming Techniques]: Aspect-oriented Programming; D.2.12 \n[Soft\u00adware Engineering]: Interoperability; D.3.4 [Programming Languages]: Processors General Terms Design, \nLanguages Keywords AOP, aspect extension, aspect mechanism, as\u00adpect weaver, composition, DSL, framework, \npluggability. 1. Introduction Aspect-oriented programming (AOP) [21] is celebrating a decade of research \nand development and industry adop\u00adtion. New language features are continually being proposed. These features \nneed not only be implemented and evaluated, but also tested to work with existing AOP languages. Facil\u00aditating \nthe construction of new aspect extensions that incor\u00adporate new features and that can be composed with \nother extensions is thus important for making research advances accessible for experimentation and use \nin realistic settings. Supporting the composition and use of newly developed aspect extensions together \nwith established main stream ex\u00adtensions can leverage and broaden their respective impact. The ability \nto program in a multi-extension AOP language can also help compare features. It can eliminate tradeoffs \nas\u00adsociated with choosing an extension with the most appropri\u00adate features. Most importantly, it can \nhelp realize the vision of domain speci.c aspect languages (aspect DSLs). Unfortunately, despite the \navailability of extensible as\u00adpect weavers (e.g., [4, 5]) and extension composition frame\u00adworks (e.g., \n[37, 36, 22]), implementing industry-quality weavers that are composable remains a complex and costly \ntask. For example, abc [4, 5] is more extensible than ajc [17], but does not support composition with \nforeign extensions. Re.ex [37] and XAspects [36] support composition, but ignore foreign advising [28]: \nthey lack the customizability necessary for preventing aspects from misadvising foreign aspects. Pluggable \nAOP [22] resolves the .awed foreign ad\u00advising behavior found in Re.ex and XAspects. However,  Figure \n1. Pluggable weavers Pluggable AOP is impractical for combining real world AOP languages. It supports \nthe customization of individual extensions, but provides only limited customization of the composition \nsemantics. Also, Pluggable AOP composes ex\u00adtensions by constructing an interpreter, which is inef.cient, \nand thus deemed inappropriate for industrial use. Today, potentially useful aspect extensions are not \nread\u00adily available because either it is too dif.cult to implement them or they are implemented but cannot \nbe used together with AspectJ [20]. The unattended need for combining COOL [27] and AspectJ is a representative \nexample. Soft\u00adware engineering studies [32, 33, 40, 41] that compared COOL and AspectJ have concluded \nthat COOL code is eas\u00adier to understand and debug than Java or AspectJ code. Yet, COOL is not widely \nused; AspectJ programmers cannot em\u00adbed COOL code in their AspectJ programs. 1.1 The Composition Problem \nThere are two main impediments to overcome. The .rst is the composition speci.cation problem [24]: given \na set of n extensions, identify and resolve feature interactions in their composition. For example, COOL \nextends Java with a method synchronization mechanism; AspectJ extends Java with an advice binding mechanism. \nIn a composition of COOL and AspectJ, coordinators and aspects may interact in unexpected ways.1 These \ninteractions need to be identi.ed and resolved. The speci.cation problem is inherently complex and dif\u00ad.cult, \nand its resolution is outside the scope of this paper. It is complex because for a choice of n extensions \nthere are O(n2) pairwise interactions to specify.2 It is dif.cult be\u00adcause several reasonable resolutions \nexist for each interac\u00adtion [24]. The second impediment, which is the main focus of this paper, is the \ncomposition implementation problem: design a composition framework such that, given n aspect weavers \n(Figure 1) and a composition speci.cation (Figure 2), plug\u00adging them into the framework implements the \ncomposition under the speci.cation. The implementation challenge is to design a framework that has the \nfollowing characteristics: 1 A coordinator in COOL is the equivalent of an aspect in AspectJ. 2 In the \nworst-case, there might be O(2n) combinations to consider. Figure 2. Composition framework Minimum performance \noverhead. To be practically use\u00adful, the framework should construct weavers without in\u00ad.icting performance \ndegradation in the runtime of com\u00adpiled aspect programs. Maximum code reuse. The framework should provide \nli\u00adbraries and abstractions that support rapid development of individual weavers. Components that are \ncommon to all AspectJ-compatible weavers should be reused when\u00adever possible.3 New weavers should implement \nonly the necessary extension-speci.c operations. Avoiding unnec\u00adessary code repetitions in constructing \ndifferent weavers also improves their reliability. Auto-con.guration. The framework should support auto\u00admatic \ncomposition of multiple weavers into a multi\u00adweaver that exhibits a reasonable default behavior, thus \navoiding whenever possible the tedious task of resolving all the interactions explicitly. Manual override. \nAlthough the default multi-weaver be\u00adhavior is likely to be appropriate for most cases, a compo\u00adsition \nspeci.cation might require to resolve some of the feature interactions differently. The framework must \nal\u00adlow the language designer to override parts of the default con.guration in order to comply with the \nspeci.cation. 1.2 Contribution The main contribution of this paper is an Aspect co-WEaving System for \ncOmposing Multiple Extensions (AWESOME). The AWESOME framework is: Composable: enables third-party composition \nof aspect weavers into a multi-weaver with a reasonable default behavior.  Customizable: provides means \nfor customizing the be\u00adhavior of the constructed multi-weaver to cater for the composition speci.cation; \nand  Ef.cient: employs a compile-time weaving scheme.  In comparison to other frameworks (Table 1), \nAWESOME is the only one to provide a .exible customization mech\u00adanism. The compile-time weaving scheme \nused by AWE\u00ad 3 By AspectJ-compatible we refer to a reactive join point and advice aspect extension [23] \nthat can be reduced to AspectJ, e.g., COOL, AspectWerkz [6], CaesarJ [3]. Property / Framework Re.ex \nXAspects Pluggable AOP AWESOME Composition approach Re.ection Preprocessing Interpretation Compilation \nComposability - - + + Customizability -4 - - + Ef.ciency +5 + - + Real-world languages - + - + Speci.cation \n- - + + Evaluation - - + + Table 1. Comparison of aspect extension composition frameworks. SOME is more \npractical and ef.cient than the re.ection\u00adbased and dynamic weaving schema used by Re.ex and Pluggable \nAOP, respectively. The quality of the code woven in AWESOME is comparable to that produced by standard \naspect compilers. AWESOME is also the only composition framework to be demonstrated and tested on real-world \nlanguages. We demonstrate the construction of an AWESOME weaver for a multi-extension AOP language, named \nCOOLAJ, that com\u00adbines COOL and AspectJ. Although we are not the .rst to pursue a combination of COOL \nand AspectJ, we are the .rst to do so systematically by: (a) giving a speci.cation of COOLAJ; (b) constructing \na weaver for COOLAJ; and (c) evaluating the weaver by testing its behavior against the COOLAJ speci.cation. \nWe also compare the woven code to code produced by ajc [17] and other weaving algorithms. Another contribution \nis the analysis of the extension com\u00adposition problem; a set of requirements for an aspect exten\u00adsion \ncomposition framework; and a reasonable default reso\u00adlution of the feature interaction problem in a composition \nof aspect extensions. To concretely illustrate the composition problem and its solution, we include speci.c \nimplementa\u00adtion details for the composition of COOL and AspectJ into COOLAJ. While a speci.cation and \na weaver for COOLAJ is a novel and useful contribution in and of itself, the com\u00adposition approach is \nnot speci.c to COOL and AspectJ. It generalizes to a large category of (reactive) aspect mecha\u00adnisms \n[23]. Outline By way of background, we .rst explain how indi\u00advidual weavers work. In Section 2 we review \nthe working of the ajc weaver for AspectJ, and in Section 3 we describe the working of a weaver for COOL. \nThe objective of this overview is to provide the reader with a familiarity with the internal components \nof a weaver and to introduce the neces\u00adsary terminology. In Section 4 we analyze the foreign-and co-advising \ninteractions, and we formulate the requirements for the co-weaving system. A novel aspect-oriented archi\u00adtecture \nfor the framework is presented in Section 5. In Sec\u00ad 4 Re.ex provides support for resolving interactions \nbetween aspects, but not between aspect extensions. 5 The re.ection-based weaving scheme of Re.ex may \ndegrade the runtime performance of the woven program.  tion 6 we refactor the implementation of the \nAspectJ and the COOL weavers to re.ect this new AOP design. In Sec\u00adtion 7, as a case study, we informally \nspecify and describe the implementation of a multi-weaver for COOLAJ. In Sec\u00adtion 8 we evaluate our AWESOME \nsystem and demonstrate its pluggability, correctness, and ef.ciency. 2. An Aspect Compiler An aspect \ncompiler compiles aspect programs into an exe\u00adcutable. We begin by describing the high-level architecture \nof an aspect compiler. For concreteness, we describe the ajc compiler for AspectJ. In general, an aspect \ncompiler has a front-end and a back\u00adend. The front-end translates aspects to (annotated) classes in the \nbase language. For example, the front-end of ajc translates aspects written in AspectJ (.java and .aj \n.les) to annotated classes in Java.6 The translation process in ajc is mostly straightforward: an aspect \nis translated to a Java class with the same name; an advice declaration is transformed into a method \ndeclaration with the same body. The compiled advice method is also annotated with attributes that store \nits aspect-speci.c data (e.g., pointcut declarations). The annota\u00adtions distinguish aspect classes from \nother Java classes, and provide pointcut designators for advice methods. The back-end implements the \nsemantics of the aspect ex\u00adtension. The semantics de.ne the meaning of advice weav\u00ading in terms of computations. \nA computation in this context is a block of program execution, e.g., a method execution. It encapsulates \na sequence of operations that de.ne a behavior and a dynamic context that includes all arguments and \nother values accessible by the computation. An advice is a com\u00adputation transformer [17, 22, 30, 31, \n42]. It takes a compu\u00adtation and produces a transformed computation that runs the advice body before, \nafter, or instead of the original compu\u00adtation. While the extension s semantics de.ne weaving in terms \nof dynamic runtime abstractions, the weaver implements the semantics statically by transforming the base \nand aspect classes. The weaver transforms a computation by transform\u00ading its shadow, a body of code that \nde.nes a computation s 6 More precisely, the target classes are expressed in the Java Virtual Ma\u00adchine \n(JVM) bytecode language. Listing 1. A weaver public void weaveClass(ClassFile cf) {Shadow[] shadows = \nreify(cf); for(Shadow shadow:shadows) {Advice[] advs = order(shadow, match(shadow)); mix(shadow, advs); \n}} behavior. For example, the ajc weaver transforms Java byte\u00adcode. At the bytecode level, an advisable \nshadow maps to a continuous block of instructions with a well-de.ned begin and end. The weaver implements \nan abstract weaving process that comprises four subprocesses, namely reify, match, order, and mix (Listing \n1). These (sub)processes are found in all reactive aspect mechanisms [23] mechanisms that can be semantically \nmodeled as a closed-loop feedback con\u00adtrol system including COOL and AspectJ. The reify process takes \nas input a class .le and con\u00adstructs a weaver-speci.c representation of the class. For ex\u00adample, the \nAspectJ weaver represents a class as a set of com\u00adputation shadows. Its reify process examines the input \nJava class cf, and identi.es all the shadows that can possibly be advised. Each shadow references a list \nof instructions em\u00adbedded in one of cf s methods (the body of the shadow), and provides static and lexical \ndescriptions of these instructions (the static context of the shadow). The match process associates elements \nof the program representation (shadows) with pieces of advice. In AspectJ, the weaver selects the set \nof advice by matching the descrip\u00adtion of the shadow (the static context) against the static part of \nthe advice pointcuts. The order process sorts and orders all pieces of advice that match the same shadow \ninto a correct application order. The ajc weaver orders the pieces of advice according to the rules de.ned \nby the AspectJ language semantics. The mix process transforms an actual body of a shadow by introducing \ncode of advice (or calls to advice) that match this shadow. The AspectJ weaver transforms the shadow \ns instruction list by sequentially introducing calls to the advice methods before, after, or instead \nof the original code. The advice pieces are woven in by sequentially transforming the body of the shadow. \nAn advice then injects new code inside the body of the shadow, immediately before, immediately after, \nor instead of the original code. The transformation considers instructions that were woven earlier as \nif they were a part of the original shadow. This way the advice pieces wrap around each other in the \ntransformed shadow. The four processes provide a high-level description of the advice weaving semantics. \nA concrete weaver may also realize other kinds of transformations. For example, the ajc weaver implements \nintertype declarations and advice Listing 2. The AspectJ weaver public void AJWeaver(ClassFile cf) {applyIntroductions(cf); \nweaveClass(cf); } weaving in two separate steps (Listing 2). First, the weaver extends and transforms \nthe class cf by applying the in\u00adtertype declarations (the call to applyIntroductions in List\u00ading 2). \nOnce the declarations are applied, the weaver calls weaveClass, which implements the advice weaving behav\u00adior. \nThe additional transformations are normally static in na\u00adture, and do not interfere with the dynamic \nadvice weaving behavior. 3. A Compiler for COOL The architecture of a compiler for COOL is similar to \nthat of ajc. The front-end translates coordinators in COOL to classes in Java. The back-end instruments \nthe program with calls to methods of coordinator classes. We explain by ex\u00adample the basics of the COOL \nlanguage and the internal workings of its compiler. Consider the implementation of a bounded stack in \nJava (Listing 3). Stack de.nes two pub\u00adlic methods: push and pop. An attempt to pop objects off an empty \nstack or push objects onto a full stack throws an exception.7 COOL relieves the implementor of Stack \nfrom dealing with multi-threading. A separate Stack 8 coordinator (List\u00ading 4) imposes the synchronization \nlogic over push and pop in an aspect-oriented manner. The Stack methods are not synchronized. But in \nthe presence of the Stack coordinator, the stack object operates correctly even when multiple client \nthreads execute methods simultaneously. The synchronization policy is expressed in COOL us\u00ading declarations \n(mutex, selfex, condition), expressions (requires), and statements (on_exit, on_entry). The selfex declaration \n(line 402) speci.es that neither push nor pop may be executed by more than one thread at a time. The \nmutex declaration (line 403) prohibits push and pop from being executed concurrently. The requires expres\u00adsions \n(lines 406 and 412) further guard push and pop exe\u00adcutions. If the guard is false, a thread suspends, \neven if the mutex and selfex conditions are satis.ed. The execution resumes when the guard becomes true. \nfull and empty are condition boolean variables (line 405). The on_entry and on_exit blocks update the \naspect state immediately before and immediately after the execu\u00adtion of an advised method body, respectively. \nThey are used in this example to track the number of elements in the stack 7 java.lang.ArrayIndexOutOfBoundsException \n8 In COOL, the names of the coordinator and the coordinated class must be the same. Listing 3. A non-synchronized \nstack 301 public class Stack { 302 public Stack(int capacity) { 303 buf = new Object[capacity]; 304 } \n305 public void push(Object obj){ 306 buf[ind] = obj; 307 ind++; 308 } 309 public Object pop() { 310 \nObject top = buf[ind-1]; 311 buf[--ind] = null; 312 return top; 313 } 314 private Object[] buf; 315 \n private int ind =0; 316 } Listing 4. A coordinator in COOL 401 coordinator Stack { 402 selfex {push, \npop}; 403 mutex {push, pop}; 404 int len=0; 405 condition full=false,empty=true; 406 push: requires \n!full; 407 on_exit { 408 empty=false; 409 len++; 410 if(len==buf.length) full=true; 411 } 412 pop: requires \n!empty; 413 on_entry {len--;} 414 on_exit { 415 full=false; 416 if(len==0) empty=true; 417 } 418 } \n(lines 409 and 413) and to keep the condition variables full and empty current. Java expressions within \nCOOL statements have read and write access to the coordinator s .elds. In addition, expres\u00adsions may \ninspect instance variables of the coordinatee, e.g., access the buf .eld of the Stack object (line 410). \nNote that the coordinator s expressions may access not only public but also package-protected and even \nprivate .elds of the coordi\u00adnatee object.  3.1 Front-end Translation The COOL front-end translates \na coordinator in COOL to a coordinator class in Java. The name of the class is ob\u00adtained by appending \nCoord to the name of the aspect, e.g., StackCoord. Listing 5. A translated COOL coordinator class public \nclass StackCoord { 501  public synchronized void 502 lock_push(Stack target) { 503 while (!(!full) || \n504 isRunByOthers(pushState) || 505 isRunByOthers(popState)) 506 try { wait(); } 507 catch (InterruptedException \ne) {} 508 pushState.add(Thread.currentThread()); 509 } 510 public synchronized void 511 unlock_push(Stack \ntarget) { 512 pushState.remove( 513 Thread.currentThread()); 514 empty = false; 515 len++; 516 if (len \n== target._buf().length) 517 full = true; 518 notifyAll(); 519 } 520 public synchronized void 521 lock_pop(Stack \ntarget) {/.omitted./} 522 public synchronized void 523 unlock_pop(Stack target) {/.omitted./} 524 private \nsynchronized boolean 525 isRunByOthers(List methState) { 526 return (methState.size() > 0 &#38;&#38; \n527 !methState. 528 contains(Thread.currentThread())); 529 } 530 private boolean 531 empty = true, 532 \nfull= false; 533 private List 534 pushState = new Vector(), 535 popState = new Vector(); 536  private \nint len= 0; 537 } 538 StackCoord (Listing 5) implements the synchronization logic via special synchronized \nmethods and instance vari\u00adables. The class provides a pair of lock_ and unlock_ methods and an instance \nvariable for every method that is advised by the coordinator. Speci.cally, the synchroniza\u00adtion for the \nStack.push method is realized by lock_push and unlock_push. Similarly, the synchronization logic for \nStack.pop is realized by lock_pop and unlock_pop. At any point of the execution, the pushState (popState) \nin\u00adstance variable stores all threads that are currently executing the push (pop) method on the coordinated \nobject. The coor\u00addinator class also includes all .elds of its coordinator. The lock_ methods implement \nthe semantics for mutex, selfex, and requires, and run on_entry blocks. A while loop suspends the execution \nof the current thread if a guard condition is violated. Speci.cally, the while loop Listing 6. A synchronized \nbounded stack 601  public class Stack { 602 public Stack(int capacity) { 603 buf = new Object[capacity]; \n604 _coord = new StackCoord(); 605 } 606 public void push(Object obj) { 607 _coord.lock_push(this); 608 \n try{ 609 buf[ind] = obj; 610 ind++; 611 } finally {_coord.unlock_push(this);} 612 } 613 public Object \npop() {/.omitted./} 614 public Object[] _buf() {return buf;} 615 private Object[] buf; 616 private int \nind= 0; 617 private StackCoord _coord; 618 } in the lock_push method suspends the execution of the cur\u00adrent \nthread (by invoking wait on the coordinator object) so long as either one of the requires, selfex, or \nmutex con\u00additions is in violation. The requires condition is checked by the !(!full) expression (line \n504). selfex fails if push is run by another thread (line 505); and mutex fails if pop is run in parallel \n(line 506). If all the guard conditions are sat\u00adis.ed, the thread executes all the existing on_entry \nstate\u00adments, and locks the coordinated push method by adding its Thread object to the pushState list \n(line 509). The unlock_ methods unlock the coordinated method and run the on_exit statements. Speci.cally, \nunlock_push unlocks the coordinated push method by removing the cur\u00adrent Thread object from the pushState \nlist (line 513). It then executes the on_exit statement (lines 515 518) and noti.es the other threads \nwaiting on the lock that the coor\u00addinated method is free (line 519). Note that accesses to the coordinated \nobject .elds (instance variables) are translated into method calls on the coordinated object. Speci.cally, \nac\u00adcess to the buf .eld of the coordinated object is translated into a _buf() method call (line 517). \nThis is the way in which the coordinator class gains access to protected or pri\u00advate .elds of the coordinated \nclass. The method is generated in the coordinated class by the COOL weaver, and simply returns the value \nof the corresponding .eld.  3.2 Back-end Weaving The COOL weaver applies four kinds of transformations \nto a coordinated class, namely method transformation, construc\u00adtor transformation, .eld introduction, \nand method introduc\u00adtion. When applied to the non-synchronized Stack (List\u00ading 3), these transformations \nyield a synchronized stack (Listing 6). The weaver associates a coordinator with a co\u00adordinatee by introducing \na _coord .eld in the coordinated Listing 7. The COOL weaver public void COOLWeaver(ClassFile cf) {ClassFile \ncoordAspect = .ndAspect(cf); if (coordAspect!=null) { addCoordField(cf, coordAspect); transformConstructor(cf, \ncoordAspect); addGetterMethods(cf, coordAspect); weaveClass(cf); }} Method[] reify(ClassFile cf) {cf.getMethods();} \nMethod[] match(Method shadow) {ClassFile coordAspect = .ndAspect( shadow.getClass()); Method lock = .ndLock( \nshadow.getSignature(), coordAspect); Method unlock = .ndUnlock( shadow.getSignature(), coordAspect); \nif (lock==null) return new Method[0]; return new Method[]{lock, unlock};  } Method[] order(Method shadow, \nMethod[] advs) {return advs; } void mix(Method shadow, Method[] advs) { if (advs.length>0) {addCallBefore(shadow, \nadvs[0].getSignature()); addCallAfter(shadow, advs[1].getSignature()); }} 701 702 703 704 705 706 707 \n708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 \n class (line 617), and adding an initialization statement in the constructor (line 604). The weaver also \nintroduces public getter methods (_buf()) for protected and private .elds of the coordinated class that \nneed to be accessed by the coordi\u00adnator. The weaver transforms the coordinated methods by intro\u00adducing \ncalls to the coordinator s lock_ and unlock_ meth\u00adods before and after the original body. To ensure invocation \nof the unlock_ method, the weaver also introduces a try\u00adfinally block around the original body. In sum, \nthe COOL weaver realizes the COOLWeaver algorithm (Listing 7). Given a class .le cf to be trans\u00adformed, \nthe weaver searches for its coordinator (.ndAspect, line 702).9 If found, the weaver introduces a coordinator \n.eld (addCoordField, line 704), transforms the constructors to ini\u00adtialize that .eld (transformConstructor, \nline 705), and gen\u00aderates getter methods for protected and private cf .elds that are read by the coordinator \n(addGetterMethods, line 706). 9 In COOL, each class can be associated with at most one coordinator. Then, \nthe weaver synchronizes the methods of cf by im\u00adposing locking and unlocking advice before and after \ntheir bodies, respectively. Advice weaving in COOL follows the same four-process model as in AspectJ \n(call to weaveClass, line 707). In terms of this four-process model, a shadow in COOL is a method of \ncf, and the advice are the lock_ and unlock_ methods of the coordinator class. The reify process of the \nCOOL weaver represents an input class .le as a set of methods (the reify method, line 711). The match \nprocess uses the signature of a yet\u00adto-be-coordinated method to select a pair of lock_ and unlock_ advice \nmethods (the match method, lines 713 722). For every coordinated method, the weaver .nds the corresponding \nlock_ and unlock_ methods in the coor\u00addinator class (.ndLock, line 716; .ndUnlock, line 718). The order \nprocess of the weaver is empty (the order method, lines 724 726). Lastly, the mix process (mix, lines \n728 733) introduces a call to the lock_ method before the method body (addCallBefore, line 730), and \na call to unlock_ after the method body (addCallAfter, line 731). 4. Analysis and Design Now that we \nhave reviewed the working of a weaver, we move on to the main focus of this paper: the problem of com\u00adposing \naspect weavers. Our goal is to build a weaver compo\u00adsition framework for implementing a multi-extension \nAOP language. Given a set of aspect weavers and a composition speci.cation, the framework should construct \nan appropriate multi-weaver. In the previous sections we discussed the four\u00adprocess model of an abstract \nweaver. In this section we ex\u00adamine the composition speci.cation; and then we derive the design requirements \nfor the composition implementation. The speci.cation needs to resolve the feature interactions between \nthe composed extensions. There are two main kinds of interactions that the speci.cation should address, \nnamely foreign advising and co-advising [28]. We reason about the speci.cation by analyzing these interactions, \nusing the com\u00adposition of COOL and AspectJ as a running example. 4.1 Foreign Advising A multi-extension \nAOP language is an AOP language that combines multiple aspect extensions. We call a program in this language \na multi-extension program. In a multi\u00adextension program, an aspect can generally interact with foreign \naspects by advising join points in their execution. The foreign advising interaction determines how aspects \nin one extension advise foreign aspects in other extensions. Particularly, in a composition of COOL and \nAspectJ the for\u00adeign advising interaction controls the weaving of AspectJ advice into foreign COOL coordinators, \nand the weaving of COOL advice into foreign AspectJ aspects. For example, consider running a Logger aspect \nin AspectJ (Listing 8) together with our Stack coordinator in COOL (Listing 4). Logger logs all join \npoints in a program execution, includ- Listing 8. A logger aspect in AspectJ public aspect Logger { \npointcut scope(): !cflow(within(Logger)); before(): scope() { System.out.println(\"before \" + thisJoinPoint);} \n Object around(): scope() { System.out.println(\"around\" + thisJoinPoint); return proceed(); }  after(): \nscope() { System.out.println(\"after\" + thisJoinPoint); } } ing join points within executions of the Stack \ncoordinator. A resolution of the foreign advising interaction must deter\u00admine what join points Logger \nadvises within the Stack coordinator, and how. But neither the AspectJ nor the COOL speci.cation de.ne \nhow AspectJ aspects advise COOL coor\u00addinators. Foreign advising is not solvable by merely using a weaver \nfor COOL (AspectJ) to weave the foreign aspects (coordi\u00adnators), because the one language does not recognize \nthe syntax or semantics of the other. Even though the weavers for COOL and AspectJ may both use Java \nclasses as their intermediate representation, applying the COOL (AspectJ) weaver to the Java representation \nof foreign aspects (coordi\u00adnators) will not do the job either. This is because the classes embed synthetic \ncode that is generated during the transla\u00adtion to the intermediate representations, e.g., calls to wait \nand notifyAll in the coordinator class StackCoord (List\u00ading 5). This synthetic code is speci.c to a particular \nimple\u00admentation of the foreign compiler. The code cannot be traced back to the original source aspect, \nand exposing it to a for\u00adeign weaver may result in the latter advising it, thereby caus\u00ading unexpected \nbehavior in the program. In terms of the abstract weaving process, foreign advising is a problem of representing \nforeign aspects correctly, and is the responsibility of the reify process. For example, the in\u00adcorrect \nbehavior observed in translation-based composition frameworks (e.g., XAspects and Re.ex) is a result \nof the reify process of the framework s weaver failing to provide a correct representation of the foreign \naspect classes. Conse\u00adquently, the weaver erroneously includes shadows also for implementation-speci.c \noperations that are introduced by the front-end translator into the intermediate aspect classes 4.2 \nCo-advising In a multi-extension program, a join point can generally be advised by several aspects that \nare written in different extensions. We refer to this behavior as co-advising. The co-advising interaction \ncontrols the collaborative application of multi-extension advice at the same join point, which is unde.ned \nat the level of the individual extensions. In a composition of COOL and AspectJ, the co-advising interaction \ncoordinates the weaving of COOL and AspectJ advice into the same program element. For example, con\u00adsider \nagain running the Logger aspect in AspectJ (Listing 8) together with the Stack coordinator in COOL (Listing \n4) and the Stack class in Java (Listing 3). The Logger and the Stack coordinator collaboratively advise \nexecutions of the Stack methods. A resolution of the co-advising interaction of the composition must \ndetermine in what order the pieces of advice of the aspect and the coordinator execute. In terms of the \nabstract weaving process, co-advising is a problem of coordinating the match, order, and mix pro\u00adcesses \nof the composed weavers. This problem cannot be resolved just by a sequential application of the individual \nweavers. If weavers were scheduled to run one after the other sequencely, then (at the same join point) \nadvice that is ap\u00adplied later would always wraps around advice that is ap\u00adplied earlier. This would results \nin a very restrictive behavior that does not support the .exible ordering needed in general for co-advising. \nMoreover, a weaver may erroneously advise advice binding operations (e.g., calls to advice or coordina\u00adtor \nmethods) that were introduced into the shadow by previ\u00adously applied weavers.  4.3 Resolving Feature \nInteractions Our analysis clari.es why the feature interaction problem is so complex and dif.cult. First, \nin a composition of mul\u00adtiple extensions, the foreign advising interaction generally occurs between every \npair of composed extensions. Fur\u00adthermore, because the interaction involves features that are unique \nto the interacting parties, the behavior is speci.c to the composed extensions. For example, a foreign \nadvis\u00ading interaction between COOL and AspectJ involves terms, expressions, and constructs that are unique \nto COOL, e.g., requires, on_entry, and on_exit. Moreover, there is no single correct way to resolve these \ninteractions. For example, a foreign advising interaction be\u00adtween COOL coordinators and AspectJ aspects \nmay allow the aspects to only advise access to .elds of coordinated objects (that are made from within \nthe coordinators), e.g., access to the .eld buf of the Stack class from within the Stack coordinator \n(Listing 4, line 410). Alternatively, the interaction can be resolved by letting the aspects advise all \n.eld access operations within the requires, on_entry, and on_exit expressions of a coordinator. It can \nalso be resolved to allow the aspects to advise all .eld access plus (un)lock COOL computations (e.g., \nas advice-execution join points). Each of the three options can be advocated [24], and many more reasonable \noptions exist.  4.4 System Design Requirements Next, we use the terminology and abstractions from the \nanal\u00adysis to formulate three design requirements for the com\u00adposition implementation. The requirements \nare: decoupling, composability, and customizability. 4.4.1 Decoupling The composition framework should \ndecouple abstractions that are common to all AspectJ-compatible weavers from abstractions that are weaver-speci.c. \nThis reduces the re\u00adsponsibility of the individual weaver to implementing only the extension-speci.c \nweaving operations. By reusing the framework s abstractions as much as possible, the develop\u00adment of \nnew weavers is drastically simpli.ed. 4.4.2 Composability The framework should support the composition \nof multi\u00adple aspect weavers into a default multi-weaver that resolves interactions automatically in a \nwell-de.ned and reasonable way. This requirement targets the scalability problem that is inherent to \nthe feature interaction problem. It enables an ex\u00adtensible and scalable solution to the problem of composing \nweavers. We de.ne the default multi-weaver behavior according to the following principles: 1. Preserving \nbehavior of individual weavers: a default multi-weaver preserves the behavior of the individual composed \nweavers as observed when weaving their respective single-extension programs. For example, a multi-weaver \nfor a composition of COOL and AspectJ would weave pure AspectJ (COOL) programs in ex\u00adactly the same manner \nas a stand-alone AspectJ (COOL) weaver would have. 2. Default foreign advising. Syntactically, an aspect \nis a mixture of Java code and extension-speci.c terms. The default foreign advising behavior allows an \naspect to ad\u00advise a foreign aspect by advising Java statements within its source code, and only those \nstatements. For exam\u00adple,a COOL coordinator embeds Java expressions within requires, on_exit, and on_entry \nconstructs. In a default composition of COOL and AspectJ, AspectJ as\u00adpects advise COOL coordinators by \nadvising only their Java expressions. Under this behavior, the Logger as\u00adpect (Listing 8) advises all \n.eld access join points within requires, on_exit, and on_entry expressions of the Stack coordinator (Listing \n4). 3. Default co-advising. The co-advising behavior controls matching and ordering of multi-extension \nadvice at a join point. The default matching policy is to unify the individual matching results of the \ncomposed extensions. The selected multi-extension advice include all pieces of  advice that match the \njoin point under the semantics of their extensions. Each individual aspect weaver selects advice only \nfrom its own aspects, and does not interfere with the matching in foreign weavers. The default ordering \npolicy relies on the advice types be\u00ading similar in all AspectJ-compatible extensions. An as\u00adpect advises \na program by transforming computations at certain join points. We identify three types of transfor\u00admations: \nto add advice before a join point computation, to add the advice after the computation, and to introduce \nthe advice instead of (around) the computation. When the multi-weaver selects multi-extension advice \nat a join point, the default multi-extension ordering behavior is to run multi-extension before advice \n.rst, then multi\u00adextension around advice, and .nally the multi-extension after advice. For example, a \ndefault multi-weaver for a composition of COOL and AspectJ would order lock and unlock (COOL advice) \nto execute before and after As\u00adpectJ s around advice, respectively. The multi-weaver also preserves a \npartial order of same-extension advice within the selected multi-extension advice.  4.4.3 Customizability \nAlthough the default multi-weaver implements a reason\u00adable behavior, a composition speci.cation may de.ne \nspe\u00adcial foreign advising and co-advising behavior. For example, a foreign advising speci.cation for \na composition of COOL and AspectJ might choose to allow AspectJ aspects to ad\u00advise COOL s (un)lock computations \nas advice-execution join points. Hence, the framework must also allow the language designer to con.gure \nthe multi-weaver to comply with the composition-speci.c foreign advising and co-advising spec\u00adi.cations. \n5. Aspect-Oriented Architecture This section introduces a practical component-based and aspect-oriented \narchitecture that facilitates the development of aspect weavers, and supports the integration of indepen\u00addently \ndeveloped aspect weavers into a multi-weaver. We introduce the architecture in three steps. First, we \nexplain the design decisions for decoupling extension-speci.c from common components. We refer to the \nextension-speci.c components as the aspect mechanism, and to the common components as the platform. The \nplatform is implemented once; it provides facilities that, if reused, signi.cantly ease the development \nof new weavers. Second, we present the de\u00adsign principles and decisions that allow the multiple aspect \nmechanisms and the platform to be automatically composed into a default multi-weaver. Third, we present \na solution to the multi-weaver customizability problem. The architecture provides support for con.guring \nthe default multi-weaver to comply with a specialized composition speci.cation. Figure 3. A stand-alone \nweaver 5.1 Decoupling We use the four-process weaver model [23] to identify the extension-speci.c and \nthe common weaver components. The reify process of a weaver constructs shadows for the base language \nclasses and the extension aspects. As a part of its functionality, the process realizes a base represen\u00adtation \nfunction, i.e., a function that builds shadows for base program classes. Because the weaver is AspectJ-compatible, \nit can be realized using the base shadow domain and the base representation function of AspectJ.10 Thus, \nthe base shadow domain and the base representation function of AspectJ can be shared by all AspectJ-compatible \nweavers. If a weaver s extension does not allow an aspect to advise aspects (e.g., a coordinator in COOL \ncannot advise other co\u00adordinators), then the common base representation function realizes the weaver \ns reify process in full. However, in the more general case (e.g., in AspectJ, an aspect can advise itself, \nas well as other aspects), a weaver needs to realize an extension-speci.c representation function, i.e., \na function that builds shadows for aspects. The reify process of the weaver is thus a composition of \nthe common base represen\u00adtation function and the speci.c representation function for aspects. The match \nand order processes of a weaver are extension\u00adspeci.c. An individual weaver matches advice in its own \naspects; and orders only extension-speci.c advice. The mix process weaves the ordered pieces of advice \nby transforming the shadow. Since an advice de.nes a shadow transformer function, mix can be modeled \nas a common extension\u00adindependent process that iteratively applies the advice trans\u00adformers to the shadow. \nFigure 3 depicts the design of an AspectJ weaver as a composition of common and AspectJ-speci.c components. \n10 The base shadow domain of AspectJ includes all shadows except for advice-execution. <<abstract aspect>> \n * Mechanism  after() : init(Platform.new()) + match(Shadow): Advice[] + order(Shadow, Advice[]) : Advice[][] \n Figure 4. A default multi-weaver There are two main architectural parts: (a) a platform that provides \ncommon facilities; (b) a mechanism that imple\u00adments extension-speci.c behavior. The platform s behavior \nis realized by the Platform class. The mechanism is realized by an aspect that implements the Mechanism \ninterface. The dashed arc in the .gure denotes advising. 5.1.1 Platform The platform provides the base \nshadow domain. Its meth\u00adods reify, mix, and weaveClass implement the common weaver s operations: reify \nuses base shadows to repre\u00adsent base classes; mix weaves advice at each shadow; and weaveClass implements \nthe high-level weaving algorithm (Listing 1). 5.1.2 Mechanism Each mechanism is realized as an aspect \nthat implements the Mechanism interface by realizing the extension-speci.c matching and ordering processes \nvia the implementation of the methods match and order, respectively. If a mecha\u00adnism s extension allows \nan aspect to advise other aspects, then the mechanism realizes the extension-speci.c represen\u00adtation \nfunction as an around advice that re.nes executions of the platform s reify method. The methods and the \nadvice are implemented with the following conception: the mecha\u00adnism uses base shadows as a representation \ndomain for base classes; the advice uses base and extension-speci.c shadows as a representation domain \nfor aspects;11 and the advice de\u00adfers to the platform the representation of base classes.  5.2 Composability \nThe architecture supports the compositions of multiple aspect mechanisms into a multi-weaver. Figure \n4 illus\u00adtrates the extended architecture by showing a default multi\u00adweaver for a composition of COOL \nand AspectJ. In the extended architecture, the multi-weaver is realized by the platform. The platform \nmediates between the composed 11 Extension-speci.c shadows represent constructs, declarations, and ex\u00adpressions \nthat are speci.c to the extension, e.g., the advice-execution shadow in AspectJ. mechanisms, and manages \ntheir collaborative application. Furthermore, the Mechanism interface is replaced with the abstract Mechanism \naspect, which de.nes the abstract meth\u00adods match and order. In addition, the aspect advises the Platform \ns constructor to register the mechanisms with the platform.12 At an abstract level, the multi-weaver \nimplements the same high-level weaving process as a stand-alone weaver (Listing 1). The four subprocesses \nof the multi-weaver are built by integrating and unifying the corresponding pro\u00adcesses of the individual \nweavers. The reify process of the multi-weaver represents base classes, and aspects that are written \nin different extensions. The match and order pro\u00adcesses of the multi-weaver select and order multi-extension \nadvice, respectively. In the extended architecture, Platform provides the methods match and order to \nrealize these pro\u00adcesses. The mix process weaves the ordered multi-extension advice by transforming the \nshadow. We enable composability of aspect mechanisms by intro\u00adducing additional design principles: 5.2.1 \nMandatory Aspect Representation To enable a default foreign advising behavior, an aspect mechanism must \nrealize an extension-speci.c aspect repre\u00adsentation function, even if the function is not normally re\u00adquired \nfor its own stand-alone operation. This policy ensures that a multi-weaver builds shadows for all aspects \nin a multi\u00adextension program, thus letting an aspect observe and advise Java shadows in any foreign aspect. \nFor example, a stand\u00adalone weaver for COOL does not advise coordinators, and thus does not need to represent \nthem. A multi-weaver for a composition of COOL and AspectJ, in contrast, uses the COOL representation \nfunction for exposing the coordinators to AspectJ aspects. The aspects can then advise Java shad\u00adows \nwithin the coordinators. Intuitively, the aspect representation function provides the most .ne-grained \nrepresentation of an aspect that in\u00adcludes all base shadows for its Java fragments, and ded\u00ad 12 This \nbehavior could have been realized in an object-oriented manner, but AOP enables a more elegant design. \n Figure 5. A customized multi-weaver icated extension-speci.c shadows for all the extension\u00adspeci.c computations. \nFor example, a function for represent\u00ading coordinators must build shadows for all Java fragments within \na coordinator s code (e.g., Java expressions within a requires statement), and on entry, on exit, requires, \nlock, and unlock shadows for all the respective computations.  5.2.2 Parallel Matching of Multi-extension \nAdvice To enable a default multi-extension advice matching be\u00adhavior, the match method of the platform \nshould run the match methods of the composed mechanisms in parallel. The multi-extension advice selected \nat a shadow is then a list of extension-speci.c advice sets that are produced by the composed aspect \nmechanisms. 5.2.3 Uniform Advice Types To enable a default multi-extension advice ordering behav\u00adior, \nan aspect mechanism should partition advice into three ordered sets, namely before, around, and after. \nIn terms of the architecture, the order method of a mechanism returns a list of three advice arrays, \nthe .rst contains before advice, the second contains around advice, and the third contains after advice. \nThe platform s order method then runs the order methods of the composed mechanisms in parallel, and lin\u00adearizes \ntheir results into a single advice vector in accordance with the default multi-extension ordering policy. \nA composition of the aspect mechanisms with the plat\u00adform produces a multi-weaver with a default behavior. \nThe aspect representation principle enables a default foreign ad\u00advising behavior, and the other principles \nenable a default co-advising behavior. The multi-weaver uses as its common shadow domain the union of \nthe common base shadow do\u00admain and all the extension-speci.c shadow domains.13 It represents the multi-extension \naspects and the base classes as appropriate for the composed mechanisms. It has a well\u00adde.ned multi-extension \nadvice matching and weaving be\u00adhavior; and it uses the order method of the platform for ordering advice. \n  5.3 Customizability Of course, the default behavior of the multi-weaver may dif\u00adfer from the actually \ndesired one. The speci.cation may dic\u00adtate foreign advising and co-advising rules that involve sev\u00aderal \nextensions. For example, the speci.cation may require an aspect in AspectJ to advise executions of lock \nand unlock in COOL as advice-execution join points. Generally, the for\u00adeign advising rules alter the \nsemantics of the individual ex\u00adtension for advising foreign aspects. The co-advising rules specify a \ncollaborative behavior for multi-extension aspects that advise the same join point. These rules are composition\u00adspeci.c \nand thus cannot be de.ned on the level of an indi\u00advidual extension. To this end, the architecture provides \na Con.g aspect that customizes the behavior of the default multi-weaver (Fig\u00adure 5). The con.guration \naspect implements the composition\u00adspeci.c foreign advising behavior by extending and overrid\u00ading the \nmatch and order methods of the aspect mecha\u00adnisms. The aspect specializes the co-advising behavior by \nadvising the match and order methods of the platform. The architecture thus supports the construction \nof a multi-weaver with a customized behavior. The multi-weaver reify method recognizes and represents \nproperly aspects of all the composed extensions using a common shadow domain. The adapted match and order \nmethods of the individual mechanisms select and order extension-speci.c advice according to the foreign \nadvising speci.cation. The customized multi-weaver match and order methods select and order the multi-extension \nadvice in accordance with the co-advising speci.cation. In sum, the architecture (Figure 5) establishes \nthe funda\u00admental principles for designing composable aspect mecha\u00adnisms. In Section 6 we apply these \nprinciples to build a con\u00adcrete co-weaving system for composing multiple extensions (AWESOME). Using \nAWESOME, we then implement an as\u00adpect mechanism for COOL, another for AspectJ, and then combine the two \nto produce an AWESOME weaver for the AOP language COOLAJ, which is described in Section 7. 13 For simplicity, \nwe assume that the intersection of extension-speci.c shadow domains is empty [22]. 6. Implementation \nby Refactoring AspectJ As a proof of concept, we realized the weaving system and the mechanisms by refactoring \nthe ajc compiler and the COOL weaver. In the ajc code, shared and AspectJ-speci.c operations are intertwined. \nThrough refactoring we untan\u00adgled and separated these two kinds of operations, moving the ones in common \nto the Platform and modularizing the rest in the AspectJ mechanism.14 The weaver for COOL, on the other \nhand, uses methods to represent Java classes, and does not have a representation for coordinator classes. \nIn our sys\u00adtem, we use AspectJ shadows (with the exception of advice\u00adexecution shadows) as a base shadow \ndomain. The refactor\u00ading here involved the use of method-execution shadows for advice matching and weaving; \nand providing a shadow rep\u00adresentation for the coordinator classes. 6.1 Implementing a Platform The \nplatform is realized by the Platform class. A list of plugged aspect mechanisms is stored in the mechanisms \nin\u00adstance variable. weaveClass is a TEMPLATE METHOD [15] that implements the weaving process (Listing \n1) using reify, match, order, and mix. The reify method represents a Java class as a set of shadows. \nWe implemented it by factoring out all opera\u00adtions that represent aspects from the representation function \nreify of the original AspectJ weaver. The match method selects advice by calling its match counterparts \nin the indi\u00advidual mechanisms: public Advice[][] match(Shadow shadow) { Advice[][] result = new Advice[mechanisms.length][0]; \nfor (int i=0;i<mechanisms.length;i++) result[i] = mechanisms[i].match(shadow); return result; } The order \nmethod calls the order methods of the individ\u00adual mechanisms, and then linearizes the multi-extension \nad\u00advice: public Advice[] order(Shadow shadow, Advice[][] multiAdvs) { Advice[] bfAdv = new Advice[0]; \nAdvice[] ardAdv = new Advice[0]; Advice[] afAdv = new Advice[0]; for (int i=0;i<mechanisms.length;i++) \n{ Advice[][] mechAdvs = mechanisms[i].order(shadow, multiAdvs[i]); bfAdv = addAll(bfAdv, mechAdvs[0]); \nardAdv = addAll(ardAdv, mechAdvs[1]); afAdv = addAll(afAdv, mechAdvs[2]); } return addAll(ardAdv, addAll(bfAdv, \nafAdv)); } 14 We also moved the shadow transformation functionality in the Shadow.transform method to \nthe Advice class. where addAll is an auxiliary method that takes two argument arrays, and concatenates \nthem by appending the second one to the .rst one. The order method schedules around advice to be woven \n.rst, so that before and after advice wrap any around advice at the same shadow. Note that weaving order \nis not the same as execution order. Finally, the mix method sequentially applies advice trans\u00adformers \nto the shadow: void mix(Shadow shadow, Advice[] advs) {for(Advice a:advs) a.transform(shadow); } The \ntransform method integrates the advice instructions into the shadow. 6.2 An Abstract Aspect Mechanism \nWe implemented the mechanisms for AspectJ and COOL as aspects that extend the abstract SINGLETON [15] \naspect, named Mechanism: public abstract aspect Mechanism {after(Platform mw): initialization(Platform.new(..)) \n&#38;&#38; this(mw) {mw.mechanisms = addAll(mw.mechanisms, new Mechanism[]{this}); } public abstract \nAdvice[] match(Shadow shadow); public abstract Advice[][] order(Shadow shadow, Advice[] advs); } The \nafter advice ensures that aspect mechanism instances are created and plugged into the platform as soon \nas the platform is instantiated. The concrete mechanisms (AJMechanism and COOLMechanism) provide an implementation \nfor match and order and override the Platform.reify method by ad\u00advising it with around advice. 6.3 Implementing \nan AspectJ Mechanism The AJMechanism aspect advises the representation reify method of the platform. \nIf the argument class is an AspectJ aspect, then the advice provides a shadow representation for it; \notherwise, the advice proceeds: Shadow[] around(ClassFile cf): args(cf) &#38;&#38; execution(Shadow[] \nPlatform.reify(ClassFile)) { return isAJAspect(cf) ? reifyAspect(cf) : proceed(cf); } where isAJAspect \ndetermines whether or not the argu\u00adment class represents an aspect; and reifyAspect constructs shadow \nrepresentation of the aspect class. The aspect rep\u00adresentation includes AspectJ-speci.c advice-execution \nshad\u00adows. The before advice to the weaveClass method introduces to the multi-weaver an intertype declaration \nmechanism: before(ClassFile cf): args(cf) &#38;&#38; execution(void Platform.weaveClass(ClassFile)) { \napplyIntroductions(cf); } The match and the order methods are copied from the original code. We omit \nthem, as well as isAJAspect and reifyAspect, due to space considerations.  6.4 Implementing a COOL Mechanism \nThe refactoring of the COOL mechanism includes a change to the front-end for translating source COOL \ncoordinators into annotated Java classes. The annotations mark the lock_ and unlock_ methods of the coordinator \nclass and identify the requires, on_entry, and on_exit instruction blocks within these methods. The COOL \nmechanism introduces shadow types for lock, unlock, requires, on enter, and on exit computations. The \nlock and unlock shadows represent executions of the lock_ and unlock_ methods. The requires, on enter, \nand on exit shad\u00adows represent executions of the corresponding COOL ex\u00adpressions and statements. They \nmap to blocks of instructions within the lock_ and unlock_ methods. The bodies of the requires, on_entry \nand on_exit constructs are Java ex\u00adpressions and statements. The mechanism represents them using the \nbase shadow domain (.eld-get and .eld-set shad\u00adows). The COOLMechanism aspect advises the weaveClass \nand the reify methods of the platform. The after advice to the weaveClass method introduces into a coordinated \n(target) class a coordinator .eld and getter methods, and transforms the constructor of the class: after(ClassFile \ncf): args(cf) &#38;&#38; execution(void Platform.weaveClass(ClassFile)) { ClassFile coordAspect = .ndAspect(cf); \nif (coordAspect!=null) { addCoordField(cf, coordAspect); transformConstructor(cf, coordAspect); addGetterMethods(cf, \ncoordAspect); }} The advice around the reify method is similar to the corresponding advice in the AJMechanism \naspect: if the ar\u00adgument class is a COOL coordinator class, then the advice provides a shadow representation \nfor it; otherwise, the ad\u00advice proceeds. The COOL mechanism also provides an implementation for match \nand order. match selects lock and unlock pieces of advice by matching the coordinator classes against \nthe method-execution shadows. The order method schedules the lock advice to run before the unlock advice. \n7. Case Study: An AWESOME Weaver for COOLAJ Plugging the AJMechanism and the COOLMechanism as\u00adpects into \nthe composition Platform produces a multi-weaver with a default behavior. It lets aspects advise join \npoints within requires, on_entry, and on_exit expressions of coordinators. It lets coordinators synchronize \nmethods that are de.ned within aspects; and it allows coordinators and aspects to co-advise the same \nmethod. Although this de\u00adfault behavior is reasonable, a speci.c multi-extension com\u00adposition of AspectJ \nand COOL may require different se\u00admantics. In this section we specify such a multi-extension AOP language \nnamed COOLAJ. We implement a weaver for COOLAJ by customizing the default multi-weaver using the Con.g \naspect. 7.1 Informal Speci.cation for COOLAJ The speci.cation for COOLAJ is independent of the AWE-SOME \narchitecture. It is based only on the syntax and seman\u00adtics of the AspectJ and COOL languages; not on \ntheir imple\u00admentation. COOLAJ is speci.ed as a conservative composi\u00adtion of AspectJ and COOL, i.e., it \nfollows as much as pos\u00adsible the original semantics of AspectJ and COOL. Speci.\u00adcally, in COOLAJ an aspect \nis woven into classes and aspects according to the weaving semantics of AspectJ. Similarly, a coordinator \nis woven into classes according to the weaving semantics of COOL. The speci.cation for COOLAJ differs \nfrom the default behavior when it comes to dealing with for\u00adeign advising and co-advising: 7.1.1 Foreign \nAdvising In COOLAJ, aspects advise executions of coordinators through .eld-get and .eld-set join points \nthat are located within requires, on_entry, and on_exit expressions; and through advice-execution join \npoints that represent lock and unlock computations (i.e., executions of lock_ and unlock_ meth\u00adods of \nthe COOL coordinator classes). The foreign advising speci.cation poses several restric\u00adtions on advising \njoin points within a coordinator: In the COOLAJ speci.cation, an access (read or write) to a condition \n.eld can only be advised with before or after advice. This way aspects cannot override values of these \n.elds, but are still able to observe their access patterns. This restriction is important for protecting \nthe synchronization logic of a coordinator.  An execution of a lock or an unlock computation is ad\u00advisable \nby aspects as an advice-execution join point. How\u00adever, aspects are limited to advising these join points \nwith before and after advice only. This restriction ensures that the locking and unlocking operations \nimposed by co\u00adordinators are not overridden by aspects, and always ap\u00adply in the correct order.   The \nspeci.cation permits coordinators to advise methods that are declared within aspects in the same way \nas methods within classes. The speci.cation restricts coordinators (as\u00adpects) from advising any synthetic \ncode introduced by the foreign mechanism, e.g., coordinators do not advise advice methods in aspect classes, \nand aspects do not advise getter Listing 9. LogAdviceOnStack public aspect LogAdviceOnStack { pointcut \nscope(): !cflow(within(LogAdviceOnStack)); pointcut tgt(): execution(* Stack.*(..)); before(): scope() \n&#38;&#38; cflow(tgt()) &#38;&#38; !cflowbelow(tgt()) { System.out.println(thisJoinPoint); } } methods \nthat are introduced into the coordinated classes by the COOL mechanism.  7.1.2 Co-advising The COOLAJ \nco-advising speci.cation coordinates the col\u00adlaborative application of aspects and coordinators on the \nsame program method: The lock (unlock) advice of COOL is executed before (after) the before, around, \nand after advice of As\u00adpectJ.  From the perspective of AspectJ aspects, COOL advice executes in the \ncontrol .ow of the method execution join point it advises.  Example For illustration, consider the LogAdviceOnStack \naspect (Listing 9). Under the semantics of AspectJ, the as\u00adpect logs all advice (except for its own) \nwoven at Stack method-execution shadows. The cflow(tgt)&#38;&#38;!cflowbelow(tgt()) pointcut selects \nnot only tgt() join points, but also join points within aspects that advise the tgt() join points. In \nparticular, LogAdviceOnStack would advise join points within the Logger aspect (Listing 8), if the two \nare used to\u00adgether with the Stack class (Listing 3). If this aspect is run together with the Stack class \n(Listing 3) and the Stack co\u00adordinator (Listing 4) under the semantics of COOLAJ, then: (1) it logs executions \nof the coordinator; and (2) an ex\u00adecution of the LogAdviceOnStack advice that prints the method-execution \njoin point is synchronized by the coordina\u00adtor (along with the original method body).  7.2 Customization \nWe realized a multi-weaver for COOLAJ by providing a Con.g aspect with three pieces of advice: one implementing \nthe co-advising rules, and the other two realizing the foreign advising rules. 7.2.1 Customizing Co-advising \nThe AspectJ weaver realizes the semantics of the cflow pointcut designator by introducing special advice \nat pro\u00adgram shadows. Speci.cally, every shadow that matches an argument pointcut of a cflow pointcut \nis wrapped with a CFlowPush advice and a CFlowPop advice. The CFlowPush advice runs before any other \nadvice at a join point, and pushes the join point on the AspectJ s join point stack. CFlowPop runs after \nall the other advice and pops the join point off the stack. These advice thus mark the start and the \nend of a join point s control .ow. For example, the point\u00adcut of the LogAdviceOnStack s advice causes \nthe AspectJ weaver to weave the CFlowPush and CFlowPop pieces of advice at the Stack.push method-execution \nshadow. Con.g implements the co-advising rules of COOLAJ by advising the Platform.order method. The \nadvice orders COOL advice to be woven between the CFlowPush and CFlowPop advice, but around any other \nAspectJ advice: Advice[] around(): execution(Advice[] Platform.order(..)) { Advice[] advs = proceed(); \nadvs = mvAdv(advs, LockAdv.class, CFlowPush.class); return mvAdv(advs, UnlockAdv.class, CFlowPop.class); \n} private Advice[] mvAdv(Advice[] advs, Class fromAdv, Class toAdv) { int fromPos = elTypePos(advs, fromAdv); \nif (fromPos < 0) return advs; int toPos = elTypePos(advs, toAdv); if (toPos < 0) toPos = advs.length; \nif (fromPos < toPos) toPos--; return move(advs, fromPos, toPos); } where LockAdv and UnlockAdv classes \nrespectively imple\u00adment lock and unlock advice of COOL; elTypePos returns a .rst position of an object \nof a given class in the array; and the move method moves an element of an array from one po\u00adsition to \nanother. Speci.cally, move(advs, fromPos, toPos) moves an element at the position fromPos of the advs \narray to the position toPos, and shifts elements between fromPos (exclusively) and toPos (inclusively) \nto the left, if fromPos < toPos, or to the right, if fromPos > toPos. mvAdv is an auxiliary method that \nco-orders COOL and AspectJ advice. If the multi-extension advice array contains no COOL advice then Con.g \ndoes not affect it. Otherwise, if the ar\u00adray contains the cflow advice then Con.g orders LockAdv (UnlockAdv) \nto be woven immediately before CFlowPush (CFlowPop), so that at run time the LockAdv (UnlockAdv) ad\u00advice \nruns immediately after (before) the CFlowPush (CFlow-Pop) advice. If the array contains no cflow advice, \nthen COOL advice is scheduled to be woven the last, thus domi\u00adnating the AspectJ advice at run-time. \n 7.2.2 Normalizing Shadow Types To allow aspects to advise lock and unlock computations as advice-executions, \nCon.g normalizes lock and unlock shad\u00adows of COOL with advice-execution shadows of AspectJ Figure 6. \nAn AspectJ weaver Figure 7. ACOOL weaver Figure 8. An AWESOME weaver by advising calls to the match and \norder methods of the AJMechanism aspect: Advice[] around(Shadow shadow): args(shadow) &#38;&#38; (call(Advice[] \nAJMechanism.match(..)) ||call(Advice[][] AJMechanism.order(..))) {return proceed(isLockOrUnlock(shadow) \n? maskAsAExec(shadow) : shadow); } where isLockOrUnlock tests if shadow is a lock or unlock shadow, and \nmaskAsAExec masks the COOL shadow as an advice-execution shadow. As a result, AspectJ advises the lock \nand unlock shadows as if they were advice-execution shadows.  7.2.3 Restricting Advisability Con.g restricts \nthe advising of join points within COOL co\u00adordinators by advising the executions of the AJMechanism\u00ad.match \nmethod: Advice[] around(Shadow shadow): args(shadow) &#38;&#38; execution(Advice[] AJMechanism.match(..)) \n{ Advice[] advs = proceed(shadow); if (isCondFieldAccess(shadow) || isLockOrUnlock(shadow)) advs = removeElType(advs, \nAroundAdvice.class); return advs; } where isCondFieldAccess checks if the shadow represent access to \na condition .eld of a COOL coordinator, and removeElType removes all elements of a given type from the \narray. 8. Evaluation To evaluate our approach, we integrated our multi-weaver framework with the ajc \nAspectJ compiler. The main ajc class runs the front-end and eventually weaves bytecode classes by invoking \nthe weave method on the org.aspectj\u00ad.weaver.bcel.BcelClassWeaver class. We modi.ed this method to call \ninstead the Platform.weaveClass method for weaving. This permitted to plug a speci.c multi-weaver into \najc by putting a corresponding imple\u00admentation of the Platform class on the class path, and running the \nAspectJ compiler as usual. We evaluated the pluggability, correctness, and performance. 8.1 Third-party \nComposition First, we evaluated the pluggability feature of AWESOME by constructing three different weavers \nfrom the same building blocks. The building blocks are jar .les contain\u00ading compiled aspects and classes. \nplatform.jar is the stripped down platform containing the Platform class and the abstract Mechanism aspect. \nThe jars ajm.jar and coolm.jar contain the concrete independently developed aspects AJMechanism and COOLMechanism \nfor AspectJ and COOL, respectively. config.jar contains the Config aspect for customizing the composition \nof COOL and As\u00adpectJ. We veri.ed that it is possible, using the command line, to construct weavers for \nAspectJ, COOL, and COOLAJ from the four building blocks. We constructed a stand-alone AspectJ weaver, \nnamed ajw, by plugging just the AspectJ mecha\u00adnism into the platform. The command line is (Figure 6): \najc -inpath platform.jar;ajm.jar -outjar ajw.jar where ajc is the original (non-refactored) version \nof the As\u00adpectJ compiler. The inpath option directs ajc to weave classes within jar .les. The outjar \noption directs the com\u00adpiler to save the woven classes into a separate jar .le. To construct a stand-alone \nCOOL weaver, named coolw, we plugged only the COOL mechanism (Figure 7): ajc -inpath platform.jar;coolm.jar \n-outjar coolw.jar and to construct a multi-weaver, named awesomew, that combines AspectJ and COOL, we \nran (Figure 8): ajc -inpath platform.jar;ajm.jar;coolm.jar; config.jar -outjar awesomew.jar To compile \nand run a multi-extension aspect program, a .le with unwoven bytecode unwoven.jar (an unwoven program \nincluding aspect and base classes) was passed to the multi-weaver to produce a woven .le: java -cp <weaver>.jar;aspectjtools.jar \norg.aspectj.tools.ajc.Main -inpath unwoven.jar -outjar woven.jar where <weaver> was one of ajw, coolw, \nor awesomew; and woven.jar is the woven bytecode program that can be run on a JVM as a regular Java program. \n 8.2 Testing Second, we tested the three weavers to determine with high con.dence that indeed ajw implements \nthe semantics of As\u00adpectJ; coolw implements the semantics of COOL; and awe\u00adsomew realizes the speci.cation \nfor COOLAJ. We did this by observing the runtime behavior of test programs; by inspect\u00ading their woven \nbytecode; by analyzing join point traces; and, when possible, by comparing the results to programs compiled \nwith ajc or abc [5]. Because the framework is based on ajc, which is assumed correct, we focused our \ntests on a coverage of the newly introduced and refactored behav\u00adior. 8.2.1 Testing ajw The ajw weaver \ncan be evaluated by comparing ajw-woven to ajc-woven bytecode. In fact, the main difference between ajw \nand ajc is in the design and implementation of the reify process. In the implementation of ajw we disentan\u00adgled \nthe monolithic reify process of ajc into a common platform reify method and an AspectJ-speci.c advice \nof the AspectJ mechanism. The other processes were either left unchanged (e.g., match and order), or \nundergone a coarse\u00adgrained (and assumed behavior-preserving) transformations (e.g., mix). Thus, we hypothesize \nthat ajw is a behavior\u00adpreserving refactoring of ajc, if the reify processes of the two exhibit the same \nbehavior, i.e., given a Java class or an AspectJ aspect they build identical shadow representations. \nTo test the reify process and reason about its shadow representation, we generated an exhaustive join \npoint trace by weaving together three classes and aspects: Stack.java (Listing 3); LogAll.aj, and TouchAll.aj. \nThe LogAll aspect advises with before, around, and after advice all the join points in the program, except \nthose within the aspect itself (to prevent an in.nite loop),15 and logs the join points to a .le. TouchAll \nalso advises everything but itself,16 but just touches the join points with an empty advice. The woven \nbytecode is run by a main program that creates a Stack object and invokes push and pop in a single thread. \nThe execution produces an exhaustive trace of the join points within Stack and within TouchAll. This \ntrace provides a good insight into behavior of the reify process, because it covers almost all types \nof join points and includes join points within both Java classes and AspectJ aspects. We executed ajw-woven \nand ajc-woven bytecode us\u00ading the same test program and obtained identical join point traces. We therefore \nconclude that, at least on this bench\u00ad mark example, ajw behaves the same as ajc, and is likely to exhibit \nan ajc-equivalent behavior in general. 15 LogAll advises !cflow(within(LogAll)) join points 16 TouchAll \nadvises !cflow(within(TouchAll)) 8.2.2 Testing coolw We tested whether the runtime behavior of coolw-woven \nbytecode complies with the dynamic semantics of COOL [27] (i.e., if multiple threads are properly synchronized \non the woven target methods). We compiled together Stack.java (Listing 3) and Stack.cool (Listing 4), \nwhich employs all fea\u00adtures of COOL (i.e., selfex, mutex, requires, on_entry, on_exit, and access to \nprivate .eld of a coordinated class from a coordinator aspect). As part of our tests we inspected the \nStackCoord.java .le that was constructed by the COOL front-end from Stack.cool, and we inspected the \ncoolw-woven bytecode that was produced by weaving the StackCoord coordinator class into the Stack Java \nclass. We ran the woven program and observed its runtime be\u00adhavior. The test program created a Stack \ninstance with a very small capacity (size of 5), and invoked its methods con\u00adcurrently by .ve reader \nand .ve writer threads. A reader thread attempted to remove 5000 objects from the stack, while a writer \nthread attempted to add 5000 objects onto the stack. The test program completed successfully (i.e., ex\u00adecuted \nall the threads to completion without throwing an ex\u00adception), indicating, with a high probability, that \nthe behav\u00adior of the woven bytecode is correct. Additional inspection of traces veri.ed that the stack \nwas properly synchronized. We tested the front-end translator by comparing the gen\u00aderated StackCoord.java \nagainst the manual translation pre\u00adsented in Listing 5. StackCoord is said to pass the test, if we can \nconclude that its lock_ and unlock_ methods encode the same behavior as the corresponding lock_ and unlock_ \nmethods in Listing 5. We tested coolw by comparing the bytecode of the woven Stack class against the \nthe manually\u00adwoven class presented in Listing 6. All three tests succeeded. Our COOL implementation ex\u00adhibited \nthe correct dynamic and compilation semantics on the input program that comprised Stack.java and Stack.cool. \nWe consider the input program to be a representative COOL application since it uses all the features \nin COOL. We thus conclude with a high degree of con.dence that our COOL implementation would generally \nweave COOL programs correctly. 8.2.3 Testing awesomew We hypothesize that awesomew implements correctly \nthe semantics of COOLAJ. To test this hypothesis we veri.ed that: 1. Given a program with only aspects \nand classes as input, awesomew weaves the program according to the seman\u00adtics of AspectJ; 2. Given a \nprogram with only coordinators and classes as input, awesomew weaves the program according to the semantics \nof COOL; 3. Given a program with coordinators, aspects and classes as input, awesomew weaves the coordinators \ninto their  matching classes according to the semantics of COOL; weaves the aspects into classes and \nother aspects accord\u00ading to the semantics of AspectJ; weaves aspects into coor\u00addinators according to \nthe foreign advising speci.cation; and coordinates the weaving of multi-extension advice according to \nthe co-advising speci.cations of COOLAJ.17 The .rst two cases were validated using the same testing strategy \nas for ajw and coolw and by comparing the out\u00adput of awesomew to that of ajw and coolw. The details are \nomitted. To validate the foreign advising and co-advising be\u00adhavior in the third case, we compiled Stack.java, \nStack.cool, LogAll.aj, and TouchAll.aj, and we tested the woven bytecode. We veri.ed the weaving of aspects \ninto coordinators by inspecting the join point trace within the control .ow of the StackCoord class. \nawesomew correctly weaves aspects into coordinators, if the trace complies with the COOLAJ for\u00adeign advising \nspeci.cation, (which de.nes the shadow repre\u00adsentation of COOL coordinators; the normalization between \nCOOL and AspectJ shadow types; and mapping between As\u00adpectJ advice types and coordinator-located shadows). \nIn par\u00adticular, we veri.ed that the trace contains only expected join points, that it re.ects executions \nof lock_ and unlock_ methods as advice-execution join points, and that around ad\u00advice of TouchAll and \nLogAll are properly .ltered (e.g., not applied at advice-execution join points). We also tested the ordering \nof multi-extension advice on a program that contains Stack.java, Stack.cool, LogAd\u00adviceOnStack.aj (Listing \n9), and TouchAll.aj. The execu\u00adtion trace of a Stack method re.ected that: (1) execu\u00adtion of StackCoord \nis advised by LogAdviceOnStack; and (2) the .rst and the last advice-execution join points around a Stack \nmethod execution join point that are not in the control .ow of LogAdviceOnStack are executions of StackCoord, \nlock_ and unlock_ methods, respectively. The .rst result shows that StackCoord advice executes in the \ncontrol .ow of the join point it advises. The second re\u00adsult shows that StackCoord advice takes precedence \nover AspectJ advice at the same join point. awesomew passed all these tests. We veri.ed that awe\u00adsomew \nweaved our input programs according to the COOLAJ semantics. The input programs provide a good coverage \nof the COOLAJ speci.cation. Therefore, we conclude with high con.dence that awesomew performs a correct \nweaving of COOLAJ programs.  8.3 Performance Finally, we evaluated the runtime performance of the byte\u00adcode \nproduced by the framework weavers. This is intended to verify that the quality of woven bytecode is unaffected \nby the improved design of the weaver. Speci.cally, we validated the following hypotheses: 17 Coordinators \nnever weave other coordinators. 50 40 30 20 10 0 Average runtime in millisecondsfor 10,000 push and pop \noperations stack+log stack+coord+log Figure 9. AWESOME performance 1. The runtime performance of ajw-woven \nbytecode is the same as ajc-woven; 2. The runtime performance of coolw-woven bytecode is the same as \ncoolx-woven; 3. The runtime performance of awesomew-woven bytecode is the same as:  (a) ajc-woven, \nfor AspectJ programs; (b) coolx-woven, for source COOL programs; (c) ajcoolx-woven, for COOLAJ programs. \n  where coolx and ajcoolx are weaving algorithms for COOL and COOLAJ that are applied manually. We ran \na multi-threading COOL program that creates a Stack object and invokes its methods using ten writer\u00adreader \nthreads. A writer-reader thread performs 5000 pairs of push-pop operations. The test program reported \nthe average running time of a thread (in milliseconds) over series of 10 runs. We also ran a single-threaded \nAspectJ program that created a Stack object, and invoked its push and pop methods 5000 times each. We \nmeasured the average running time of executing the operations over a series of 10 runs. Figure 9 summarizes \nthe measured execution times. Pro\u00adgrams compiled with ajw and coolw are as ef.cient as those compiled \nwith ajc and coolx. Programs compiled with awesomew are within 4% ef.ciency compared to (op\u00adtimal) code \nwoven mechanically using the ajcoolx algo\u00adrithm and ajc as a back-end compiler. This indicates that the \nframework design overhead on the performance of the wo\u00adven bytecode is negligible, i.e., there is almost \nno overhead to supporting the plugin architecture. 9. Related Work The vision of domain speci.c aspect-oriented \nextensions dates back to early days of AOP (e.g., [8, 9]), but very few of the related works deal with \nmaking such extensions available concurrently. Those that do, leave much to be desired in terms of composability, \ncustomizability, and ef.ciency. Re.ex [37] and XAspects [36] do not support the level of composability \nor customizability that is necessary for re\u00adsolving foreign advising. These frameworks implement the \ncomposition by translating source aspects in foreign exten\u00adsions to aspects in a common target language. \nThe transla\u00adtion introduces and exposes in the target aspects synthetic join points that do not exist \nin the source. However, in Re\u00ad.ex and in XAspects, foreign aspects cannot distinguish the synthetic from \nthe genuine join points. Moreover, Re.ex and XAspects provide no mechanism (or composition rules) for \ncustomizing the foreign advising behavior, thus preventing the integrator from being able to correct \nthe faulty resolu\u00adtion of this feature interaction. As a result, aspect programs compiled in Re.ex-and \nXAspects-based multi-extension weavers may exhibit incorrect behavior [22, 24]. In contrast, AWESOME \nprovides automatically a default reasonable resolution of foreign advising, thus signi.cantly simplifying \nthe problem of resolving the interactions. The integrator may .ne-tune the default behavior, but does \nnot necessarily need to. In Re.ex there is ample support for con.guring co\u00adadvising at the aspect level. \nA programmer can resolve inter\u00adactions between aspects in a speci.c aspect program. AWE-SOME, on the \nother hand, supports customizability at the language level. A language designer can resolve the interac\u00adtions \nbetween aspect extensions, thus affecting the behavior of all multi-extension programs. Extending AWESOME \nwith aspect-level support for .ne-tuning co-advising is a topic for future work. Pluggable AOP [22] is \na third-party composition frame\u00adwork that supports the composition of dynamic aspect mech\u00adanisms into \nan AOP interpreter. In Pluggable AOP, an aspect mechanism is a transformer of an AOP interpreter. Among \nthe related frameworks, only Pluggable AOP addresses for\u00adeign advising by treating a foreign aspect mechanism \nas an open module [1] that can determine which join points within its aspects are advisable and which \nare hidden. However, there is no control in Pluggable AOP over how these join points are advised. Pluggable \nAOP is also restricted in its co-advising customizability. It allows the integrator to cus\u00adtomize the \nco-advising behavior only indirectly by ordering the aspect mechanisms. Moreover, Pluggable AOP is not \nde\u00adsigned for ef.ciency. It is impractical for use in industrial settings. In comparison, AWESOME supports \n.exible language\u00adlevel customizability of both the co-advising and the foreign advising interactions; \nand employs an ef.cient compile-time weaving scheme. AWESOME was demonstrated to successfully compose \nreal-world extensions. Pluggable AOP, in contrast, uses toy languages as a proof of the concept. To the \nbest of our knowledge, Re.ex has not been shown to work with AspectJ. We only found a plugin that implements \na limited subset of AspectJ. The plugin, however, does not advise As\u00adpectJ aspects correctly, emphasizing \nthe general limitation of the Re.ex framework to support foreign advising [24]. The composition of COOL \n[27] and AspectJ [20] presents an interesting case study with a representative complexity. The two are \nsuf.ciently different, thus demanding interest\u00ading design decisions to make them work together. Similar \nto AWESOME, XAspects too explored a composition of COOL and AspectJ. However, the XAspects weaver exhibits \nincor\u00adrect weaving behavior that may result in deadlock [22]. AWESOME is not limited to COOL and AspectJ. \nIt can be generally applied to combine any reactive aspect mecha\u00adnisms. To the best of our knowledge, \nall existing join point and advice aspect extensions fall into this category. Other more disparate aspect-oriented \nextensions are either non\u00adreactive aspect mechanisms, which are not composable, e.g., Hyper/J [34, 38], \nor they are not oblivious [7, 13, 14] and can be composed trivially, e.g., Demeter [25, 26]. Aspect\u00adoriented \nfeatures other than advising, such as introductions, are easier to compose because it is easier to detect \nand re\u00adsolve con.icts [16]. The problem of feature interactions in a multi-extension composition does \nnot rise in the context of a single-extension AOP language. Therefore, related works on single-extension \nweavers [3, 5, 19, 29, 30, 39, 42] do not address or solve this problem. 10. Conclusion This work studies \nthe composition implementation problem in constructing multi-extension weavers. We present a prac\u00adtical \nthird-party composition framework, named AWESOME, for composing multiple aspect extensions. The AWESOME \nframework was built systematically. It implements a speci\u00ad.ed set of composition requirements. It provides \na default resolution of feature interactions in the composition. It also provides means for customizing \nthe default resolution to comply with a given composition speci.cation. AWESOME was tested and evaluated \non real-world aspect languages. The runtime performance of compiled aspect programs is practically unaffected \nby the extensible design of the frame\u00adwork, making AWESOME also useful in practice. AWESOME is unique \nin its approach to composing aspect extensions by assembling an aspect compiler. In AWESOME, an aspect \nmechanism is a plugin to the compile-time aspect weaver. The AWESOME framework simpli.es the creation \nof new extensions, because writing a plugin is much simpler than writing a complete compiler. In order \nto evaluate our approach, we refactored the AspectJ ajc compiler and used it as a basis for our multi-weaver \nplatform. But the refactor\u00ading of open source compilers is not a part of the integration methodology. \nThe ajw, coolw, and awesomew weavers themselves are also a modest contribution of this work. These AspectJ, \nCOOL, and COOLAJ compilers do not just have a cool de\u00adsign, but also awesome performance. References \n[1] J. Aldrich. Open modules: Modular reasoning about advice. In Proceedings of the 19th European Conference \non Object-Oriented Programming (ECOOP 05), number 3586 in Lecture Notes in Computer Science, pages 144 \n168, Glasgow, UK, July 25-29 2005. Springer Verlag. [2] Proceedings of the 3rd International Conference \non Aspect-Oriented Software Development (AOSD 04), Mancaster, UK, Mar. 17-21 2004. ACM Press. [3] I. \nAracic, V. Gasiunas, M. Mezini, and K. Ostermann. An overview of CaesarJ. In Rashid and Aksit [35], pages \n135 173. [4] P. Avgustinov, A. S. Christensen, L. Hendren, S. Kuzins, J. Lhot\u00b4ak, O. Lhot\u00b4ak, O. de Moor, \nD. Sereni, G. Sittampalam, and J. Tibble. abc: an extensible AspectJ compiler. In Proceedings of the \n4th International Conference on Aspect-Oriented Software Development (AOSD 05), pages 87 98, Chicago, \nIllinois, USA, Mar. 14-18 2005. ACM Press. [5] P. Avgustinov, A. S. Christensen, L. J. Hendren, S. Kuzins, \nJ. Lhot\u00b4ak, O. de Moor, D. Sereni, G. Sittampalam, ak, O. Lhot\u00b4 and J. Tibble. abc: an extensible AspectJ \ncompiler. In Rashid and Aksit [35], pages 293 334. [6] J. Bon\u00b4er. What are the key issues for commercial \nAOP use: how does AspectWerkz address them? In AOSD 04 [2], pages 5 6. [7] C. Clifton and G. T. Leavens. \nObliviousness, modular reason\u00ading, and the behavioral subtyping analogy. In Proceedings of the AOSD 03 \nWorkshop on Software-engineering Properties of Languages for Aspect Technologies (SPLAT 03), Boston, \nMassachusetts, Mar. 18 2003. AOSD 03, ACM Press. [8] K. De Volder, J. Brichau, K. Mens, and T. D Hondt. \nLogic meta-programming, a framework for domain-speci.c aspect programming languages. Unpublished, 2001. \n[9] M. D Hondt and T. D Hondt. Is domain knowledge an as\u00adpect? In Proceedings of the ECOOP 99 International \nWork\u00adshop on Aspect-Oriented Programming, Lisbon, Portugal, June 1999. [10] Proceedings of the 17th European \nConference on Object-Oriented Programming (ECOOP 03), number 2743 in Lecture Notes in Computer Science, \nDarmstadt, Germany, July 21-25 2003. Springer Verlag. [11] Proceedings of the AOSD 05 Workshop on Foundations \nof Aspect-Oriented Languages (FAOL 05), Chicago, IL, USA, Mar. 14 2005. ACM Press. [12] R. E. Filman, \nT. Elrad, S. Clarke, and M. Aks\u00b8it, editors. Aspect-Oriented Software Development. Addison-Wesley, Boston, \n2005. [13] R. E. Filman and D. P. Friedman. Aspect-oriented pro\u00adgramming is quanti.cation and obliviousness. \nIn P. Tarr, L. Bergmans, M. Griss, and H. Ossher, editors, Proceedings of the OOPSLA 2000 Workshop on \nAdvanced Separation of Concerns. Department of Computer Science, University of Twente, The Netherlands, \n2000. [14] R. E. Filman and D. P. Friedman. Aspect-oriented program\u00adming is quanti.cation and obliviousness. \nIn Filman et al. [12], pages 21 35. [15] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: \nElements of Reusable Object-Oriented Software. Professional Computing. Addison-Wesley, 1995. [16] W. \nHavinga, I. Nagy, L. Bergmans, and M. Aks\u00b8it. Detecting and resolving ambiguities caused by inter-dependent \nintro\u00adductions. In Proceedings of the 5th International Conference on Aspect-Oriented Software Development \n(AOSD 06), pages 214 225, Bonn, Germany, Mar. 20-24 2006. ACM Press. [17] E. Hilsdale and J. Hugunin. \nAdvice weaving in AspectJ. In AOSD 04 [2], pages 26 35. [18] Proceedings of the 21st International Conference \non Software Engineering (ICSE 99), Los Angeles, California, May 1999. IEEE Computer Society. [19] R. \nJagadeesan, A. Jeffrey, and J. Riely. An untyped calculus for aspect oriented programs. In ECOOP 03 [10], \npages 54 73. [20] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm, and W. G. Griswold. An overview \nof AspectJ. In Proceed\u00adings of the 15th European Conference on Object-Oriented Programming (ECOOP 01), \nnumber 2072 in Lecture Notes in Computer Science, pages 327 353, Budapest, Hungary, June 18-22 2001. \nSpringer Verlag. [21] G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, C. Lopes, J.-M. Loingtier, and \nJ. Irwin. Aspect-oriented programming. In Proceedings of the 11th European Conference on Object-Oriented \nProgramming (ECOOP 97), number 1241 in Lec\u00adture Notes in Computer Science, pages 220 242, Jyv\u00a8askyl\u00a8a, \nFinland, June 9-13 1997. Springer Verlag. [22] S. Kojarski and D. H. Lorenz. Pluggable AOP: Designing \nas\u00adpect mechanisms for third-party composition. In Proceedings of the 20th Annual Conference on Object-Oriented \nProgram\u00adming Systems, Languages, and Applications (OOPSLA 05), pages 247 263, San Diego, CA, USA, Oct. \n16 20 2005. ACM Press. [23] S. Kojarski and D. H. Lorenz. Modeling aspect mechanisms: A top-down approach. \nIn Proceedings of the 28th Interna\u00adtional Conference on Software Engineering (ICSE 06), pages 212 221, \nShanghai, China, May 20-28 2006. ACM Press. [24] S. Kojarski and D. H. Lorenz. Identifying feature interactions \nin aspect-oriented frameworks. In Proceedings of the 29th International Conference on Software Engineering \n(ICSE 07), Minneapolis, MN, May 20-26 2007. IEEE Computer Society. [25] K. Lieberherr and D. H. Lorenz. \nCoupling Aspect-Oriented and Adaptive Programming. In Filman et al. [12], pages 145 164. [26] K. J. Lieberherr. \nAdaptive Object-Oriented Software: The Demeter Method with Propagation Patterns. PWS-Kent Publishing, \n1996. [27] C. V. Lopes. D: A Language Framework for Distributed Programming. PhD thesis, Northeastern \nUniversity, 1997. [28] D. H. Lorenz and S. Kojarski. Understanding aspect inter\u00adactions, co-advising \nand foreign advising. In Proceedings of ECOOP 07 Second International Workshop on Aspects, De\u00adpendencies \nand Interactions, pages 23 28, Berlin, Germany, July 30 2007. [29] H. Masuhara and G. Kiczales. Modeling \ncrosscutting in aspect-oriented mechanisms. In ECOOP 03 [10], pages 2 28. [30] H. Masuhara, G. Kiczales, \nand C. Dutchyn. Compilation semantics of aspect-oriented programs. In FAOL 05 [11], pages 17 26. [31] \nH. Masuhara, G. Kiczales, and C. Dutchyn. A compilation and optimization model for aspect-oriented programs. \nIn Compiler Construction, number 2622 in Lecture Notes in Computer Science, pages 46 60, 2003. [32] G. \nC. Murphy, R. J. Walker, and E. L. A. Baniassad. Evalu\u00adating emerging software development technologies: \nLessons learned from assessing aspect-oriented programming. IEEE Transactions on Software Engineering, \n25(4):438 455, 1999. [33] G. C. Murphy, R. J. Walker, E. L. A. Baniassad, M. P. Robillard, A. Lai, and \nM. A. Kersten. Does aspect-oriented programming work? Commun. ACM, 44(10):75 77, Oct. 2001. [34] H. Ossher \nand P. Tarr. Hyper/J: multi-dimensional separation of concerns for Java. In Proceedings of the 22nd International \nConference on Software Engineering (ICSE 00), pages 734 737, Limerick, Ireland, June 2000. ICSE 00, IEEE \nComputer Society. [35] A. Rashid and M. Aksit, editors. Transactions on Aspect-Oriented Software Development \nI, number 3880 in Lecture Notes in Computer Science. Springer Verlag, 2006. [36] M. Shonle, K. Lieberherr, \nand A. Shah. XAspects: An exten\u00adsible system for domain speci.c aspect languages. In Com\u00adpanion to the \n18th Annual Conference on Object-Oriented Programming Systems, Languages, and Applications, pages 28 \n37, Anaheim, California, 2003. ACM Press. \u00b4 [37] E. Tanter and J. Noy\u00b4 e. A versatile kernel for multi-language \nAOP. In Proceedings of the 4th International Conference on Generative Programming and Component Engineering \n(GPCE 05), number 3676 in Lecture Notes in Computer Science, pages 173 188, Tallin, Estonia, Sept. 29-Oct. \n1 2005. Springer Verlag. [38] P. L. Tarr, H. L. Ossher, W. H. Harrison, and S. M. Sutton, Jr. N degrees \nof separation: Multi-dimentional separation of concerns. In ICSE 99 [18], pages 107 119. [39] D. Walker, \nS. Zdancewic, and J. Ligatti. A theory of aspects. In Proceedings of the 7th ACM SIGPLAN International \nConference on Functional Programming, pages 127 139, Uppsala, Sweden, Aug. 2003. ACM Press. [40] R. J. \nWalker, E. L. A. Baniassad, and G. Murphy. Assessing aspect-oriented programming and design. In S. Demeyer \nand J. Bosch, editors, Object-Oriented Technology, ECOOP 98 Workshop Reader, number 1543 in Lecture Notes \nin Com\u00adputer Science, pages 433 434, Brussels, Belgium, July 1998. Proceedings of the ECOOP 98 Workshops, \nDemos, and Posters, Springer Verlag. [41] R. J. Walker, E. L. A. Baniassad, and G. C. Murphy. An initial \nassessment of aspect-oriented programming. In ICSE 99 [18], pages 120 130. [42] M. Wand, G. Kiczales, \nand C. Dutchyn. A semantics for advice and dynamic join points in aspect-oriented programming. ACM Trans. \nProg. Lang. Syst., 26(5):890 910, Sept. 2004.     \n\t\t\t", "proc_id": "1297027", "abstract": "<p>Domain specific aspect-oriented language extensions offer unique capabilities to deal with a variety of cross cutting concerns. Ideally, one should be able to use several of these extensions together in a single program. Unfortunately, each extension generally implements its own specialized weaver and the different weavers are incompatible. Even if the weavers were compatible, combining them is a difficult problem to solve in general, because each extension definesits own language with new semantics. In this paper we present a practical composition framework, named A&lt;scp&gt;wesome&lt;/scp&gt;, for constructing a multi-extension weaver by plugging together independently developed aspect mechanisms. The framework has a component-based and aspect-oriented architecture that facilitates the development and integration of aspect weavers. To be scalable, the framework provides a default resolution of feature interactions in the composition. To be general, the framework provides means for customizing the composition behavior. Furthermore, to be practically useful, there is no framework-associated overhead on the runtime performance of compiled aspect programs. To illustrate the A&lt;scp&gt;wesome&lt;/scp&gt; framework concretely, we demonstrate the construction of a weaver for a multi-extension AOP language that combines Cool and AspectJ. However, the composition method is not exclusive to Cool and AspectJ-it can be applied to combine any comparable reactive aspect mechanisms.</p>", "authors": [{"name": "Sergei Kojarski", "author_profile_id": "81100619905", "affiliation": "Northeastern University, Boston, MA", "person_id": "P643486", "email_address": "", "orcid_id": ""}, {"name": "David H. Lorenz", "author_profile_id": "81100540418", "affiliation": "The Open University of Israel, Raanana, Israel", "person_id": "PP14187733", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1297027.1297065", "year": "2007", "article_id": "1297065", "conference": "OOPSLA", "title": "Awesome: an aspect co-weaving system for composing multiple aspect-oriented extensions", "url": "http://dl.acm.org/citation.cfm?id=1297065"}