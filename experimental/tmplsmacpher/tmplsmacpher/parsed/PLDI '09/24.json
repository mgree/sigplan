{"article_publication_date": "06-15-2009", "fulltext": "\n Sharing Classes BetweenFamilies XinQi AndrewC.Myers Department of Computer Science Cornell University \n {qixin,andru}@cs.cornell.edu Abstract Class sharingisanew language mechanismforbuildingextensible software \nsystems. Recent work has separately explored two dif\u00adferent kindsofextensibility: .rst,family inheritance,in \nwhich an entirefamilyof related classes canbe inherited, and second, adap\u00adtation, in which existing objects \nare extended in place with new behavior and state. Class sharing integrates these two kinds of ex\u00adtensibility \nmechanisms. With little programmer effort, objects of onefamily can be used as members of another, while \npreserving relationships among objects. Therefore,afamilyof classes canbe adapted in place with new functionality \nspanning multiple classes. Object graphs can evolve from one family to another, adding or removing functionality \neven at run time. Several new mechanisms supportthis .exibility while ensuring type safety. Class sharing \nhas been implemented as an extension to Java, and its utility for evolving and extending software is \ndemon\u00adstrated with realistic systems. Categories and Subject Descriptors D.3.2[Language Classi.\u00adcations]: \nObject-oriented languages; D.3.3[Language Constructs andFeatures]: Classes and objects, frameworks, inheritance, \nmod\u00adules, packages General Terms Languages Keywords family inheritance, views, masked types 1. Introduction \nIt has long been observed that much of the dif.culty of building reliable software systems arises from \ntheir size and complexity [5]. Language mechanisms for modular and object-oriented program\u00adming have \nhelped make large systems easier tobuild and to rea\u00adson about. However, it remains challenging to extend, \nevolve, and update software systems. Incremental updates to software systems may require coordinated \nchanges to state and behavior that span multiple software components.We posit that newmechanisms are \nneeded to enable software to be reused and extended in a modular, scalable, safe way. Inheritancedoesprovidea \nmodularwaytoextendexistingcode withnewbehavior,whichhelpsexplainwhylargesoftware systems are often built \nusing object-oriented languages such as Java or C++. But ordinary inheritance has two serious limitations. \nFirst, Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n09, June 15 20, 2009, Dublin, Ireland. Copyright c . 2009ACM 978-1-60558-392-1/09/06... $5.00. interacting \nclasses can only be extended individually; inheritance does not support changes that span multiple classes. \nSecond, new functionality cannotbe addedto objectsofanexisting class without modifying the class de.nition \nwhich would not be modular. These limitations have been addressed separately by two lines of research. \nIn the .rst, the ability to extend classes as a group is provided by family inheritance mechanisms, which \nprovide inheri\u00adtance at the granularity of a family of related classes rather than on individual classes.Family \ninheritance mechanisms include virtual classes [24, 18, 10], mixin layers [41], variant path types [22], \nand nested inheritance [28, 30]. The second, separate line of research has explored language support \nfor adaptation. Adaptation mech\u00adanisms allow the modular addition of functionality to an existing class, \nwithout any change to the original class de.nition. Objects of the class are augmented with new operations \nor state. Mech\u00adanisms for adaptation include open classes [11], expanders [50], classboxes [3], and aspect \nbinders [26].Typically, adaptation oper\u00adates on individual classes; it does not support coordinated changes \nwhile preserving relationships among augmented objects. This paper integrates these two distinct approaches \nto extensi\u00adbility for the .rst time. The result is a powerful new capability: interacting objects from \na family of classes can be adapted with new functionality, while preserving the identities of objects \nand the relationships among them.Asingle operation can cause an entire data structure to be augmented \nin place with new behavior. Thekey new idea is class sharing: differentfamilies can have classes that \nare shared between thefamilies. An object that is an instance of the shared class in one family is also \nan instance of the corresponding classin anyfamily that shares the class. Objects can then be viewed \nfrom either family. Class sharing supports bidirectional adaptation: notonly can objectsofa basefamilybe \nadapted intoa derivedfamily,but thoseof the derivedfamily can be adapted to the basefamily. Class sharing \nhas been realized in a language J&#38;s (pronounced jet-ess ),anextensionoftheJava languagethatadds class \nsharing to the language J&#38; [30]. In J&#38;s, each object reference provides a view that dynamically \ndetermines thefamily and thus the behavior of the object when used through that reference. The view of \nan object also transitively affects the behavior of other objects reached via that object reference, \nbecause it determines which family to interpret those objects with respect to. An explicit view change \nproduces a reference with a new view, while preserving object identity. Class sharing enables new ways \nto extend software systems: Family adaptation.Newfunctionality spanning multiple classes canbe addedtoan \nentirefamily in-place, adapting objectswith new state and behavior.  Dynamic object evolution.  Thefamilyfrom \nwhichan objectisviewedis determineddy\u00adnamically by its reference, so collections of interacting objects \ncan be updated with new behavior at run time, without chang\u00ading the interface to existing clients. This \nallows running servers to be evolved with new state and behavior.  In-place translation. In-place translation \nis the transfer of data structures from one family to another without creating new objects for shared \nclasses and without side effects. We have used this approach tobuild compilers: an abstract syntax tree \nfrom one language can be translated to another language while updating only the nodes that require it. \nDespite all this expressive power, J&#38;s is type-safe programs never create run-time errors and type \nchecking is modular. Be\u00adcause the behavior of an object depends on thefamily from which itisbeingviewed, \ndesigningasoundtypesystemis challenging.To accomplish this, J&#38;s uses view-dependent types to ensure \nthat late\u00adbound type names belong to consistentfamilies, and uses masked types [35] to control access \nto .elds that are not shared between families.ThekeyfeaturesofJ&#38;s havebeen formalized in an object \ncalculus, and the type system has been proved sound. The details of the formalization and the proof are \navailable in a companion tech\u00adnical report [36]. The rest of the paper proceeds as follows. Section2describes \nhow class sharing works in the new language J&#38;s, and gives ex\u00adamplesofits use. Section3showshowto \nsafely support unshared state within shared classes. Section4sketches the formalizationof J&#38;s and \nthe soundness theorem. The implementation of J&#38;s is de\u00adscribedin Section5. Section6showsthatthe performanceofJ&#38;s \nis reasonableand describesitsusetobuildrealisticsystems. Section7 discusses relatedwork, and Section8concludes. \n2. Sharing classes The new class sharing mechanism in J&#38;s is a safe, modular mech\u00adanism that relaxes \nthe disjointness of class families. A family of classes may not only inherit anotherfamily (and hence \nall its nested classes),but may also share someof the classes from thefamilyit inherits from. This enables \nnew kinds of extensibility. 2.1 Family inheritance J&#38;s builds on the family inheritance mechanisms \nintroduced by Nystrom et al.: nested inheritance [28] and nested intersection [30]. Nested inheritance \nis inheritance at the granularity of a name\u00adspace (a package ora class), which de.nesafamilyin which \nre\u00adlated classes are grouped. Nested inheritance supports coordinated changes that span the entire family. \nWhen a namespace inherits from another (base) namespace, not only are .elds and methods inherited, but \nalso namespaces nested in the base namespace. In addition, the derived namespace can override, or further \nbind [25] inherited namespaces, changing nested class declarations. Nested inheritance does not provide \nadaptation, however. Nested classes in the inheriting namespace, even those not overridden(implicit classes), \nare different classes than those of the same name in the base namespace. Nested intersection supports \ncomposing families with general\u00adized intersection types [39, 12]. Given classes S and T, their in\u00adtersection \nS&#38;T inherits all members of Sand T. When two name\u00adspaces are intersected, their common nested namespaces \nare them\u00adselves intersected, i.e., (S&#38;T).C=(S.C)&#38;(T.C). Figure1showsanexample withtwofamiliesof \nclasses. Class AST containsafamilyof classesfor representingexpressions,and class TreeDisplay containsafamilyof \nclasses for graphically vi\u00adsualizing trees. Figure 2 shows the skeleton of code that imple\u00adments the \nfunctionality of displaying an expression as a tree without changingtheexistingfamilies. ASTDisplay inherits \nboth AST and TreeDisplay, and therefore inherits all nested classes from both of them. The GUI classes \nare implicit in ASTDisplay, class AST { class TreeDisplay { class Exp {...} class Node { class Value \nvoid display() {...} extends Exp {...} } class Binary class Composite extends Node { extends Exp Node \ngetChild(int i) {...} {Expl,r; } } ... class Leaf extends Node {...} } } Figure 1. Anexpressionfamily \nanda GUIfamily 1 class ASTDisplay extends AST &#38; TreeDisplay { 2 class Exp extends Node { void display() \n{ ... } } 3 class Value extends Exp &#38; Leaf { ... } 4 class Binary extends Exp &#38; Composite 5 { \nvoid display() { ... l.display(); ... } } 6 void show(Exp e) { e.display(); } 7 } Figure2. Mixing display \nintoexpressions, with nested inheritance and expression classes are further bound to inherit GUI classes \nin addition to their original superclasses, and to override GUI meth\u00adods with appropriate rendering code. \nAs the show method in Fig\u00adure2 demonstrates, expression classesin the newfamily support the added display \nmethod. Two mechanisms are essential for nested inheritance to work: late binding of type names and exact \ntypes. These mechanisms are also important for class sharing. Late binding of type names. Late binding \nof type names ensures relationships between classes are preservedin the derivedfamily. When the name \nof a class is inherited into a new name\u00adspace, the name is interpreted in the context of the new name\u00adspace.Forexample, \ninside thefamily ASTDisplay, the type Exp refers to Exp in ASTDisplay. Consider the .eld l, which is \nde\u00adclared in AST.Binary with type Exp, and then inherited by the class ASTDisplay.Binary. When inherited, \nits type is the Exp of ASTDisplay, not the original type. This late binding makes the call l.display() \non line5legal. Similarly, the superclass of ASTDisplay.Binary is ASTDisplay.Exp, not AST.Exp. Twomechanisms \nmakethe late binding of type names type-safe: dependent classes and pre.x types. The dependent class \np.class represents the run-time class of the object referred to by the .nal access path p.A .nal access \npath is either a .nal local variable, including this and .nal formal parameters, or a .eld access p.f, \nwhere p is a .nal access path and f is a .nal .eld. In general, the class represented by p.class is statically \nunknown,but .xed. A pre.x type P[T] represents the enclosing namespace of the class or interface T that \nis a subtype of the namespace P, i.e., the family at the level of P that contains T [28]. In Figure 2, \nif one writes AST[this.class], it refers to either AST or ASTDisplay, depending on the run-time class \nof the value stored in this. Type names that are not fully quali.ed are sugar for members of pre.x types \nthat depend on the current class this.class, and inan inheritingfamily,theywillbe reinterpreted.InFigure1,the \ntype Exp inside class AST is sugar for AST[this.class].Exp. Exact types. Both dependent classes and pre.x \ntypes of depen\u00addent classes are exact types [6]: all instances of these types must have the same run-time \nclass. Simple types may be exact too. If A is a class, the exact type A! represents values of the run-time \nclass A. Even if class B in\u00adherits from A, neither B nor B! is a subtype of A!. Exactness ap\u00adplies to \nthe entire type preceding ! , so supertypes of a sim\u00adple exact type can be obtained by shifting the exactness \noutward. For example, ASTDisplay.Exp! is not a subtype of AST.Exp!,  1 class ASTDisplay extends AST \n&#38; TreeDisplay { 2 class Exp extends ... shares AST.Exp { ... } 3 class Value extends ... shares AST.Value \n{ ... } 4 class Binary extends ... shares AST.Binary 5 { void display() { ... l.display(); ... } } 6 \nvoid show(AST!.Exp e) sharing AST!.Exp = Exp { 7 Exp temp = (view Exp)e; 8 temp.display(); 9 } 10 } \nFigure 3. Using class sharing to adapt Exp to TreeDisplay but it is a subtype of ASTDisplay!.Exp, which \nis a subtype of ASTDisplay.Exp. Exact types also restrict the subtyping relationships of nested types. \nFor example, ASTDisplay!.Binary is not a subtype of AST!.Binary, even though ASTDisplay.Binary is a subtype \nof AST.Binary. Therefore exact types can mark the boundary of a family: classes nested inASTDisplay! \nform onefamily and those nested in AST! form another. Non-dependent exact types provide a locally closed \nworld:at compile time, one can enumerateall classes that are subtypes of A!.C, without inspecting subclasses \nof A. Exact types are important for the modularity of J&#38;s (Section 2.5).  2.2 Sharing declarations \nJ&#38;s introduces shared classes with sharing declarations in the derivedfamily, such as the declaration \nshares A.C in this code: class A { class C ... } // the base family class B extends A { // the derived \nfamily class C extends D shares A.C { ... } } This sharing declaration establishesa sharingrelationship \nbetween classes A.C and B.C. Sharing declarations induce an equivalence relation on classes that is the \nre.exive, symmetric, and transitive closure of the declared sharing relationships. If two classes have \na sharing relationship, theyhave the same set of object instances. However,subclasses of the twoshared \nclasses are not automatically shared, unless the subclasses also have appropriate sharing decla\u00adrations. \nTherefore, the sharing relationship established in the above example can be represented as a relationship \nbetween two exact types, written A.C!. B.C!. J&#38;s requires that only anoverriding classina derivedfamily \n(e.g., B.C)may declare a sharing relationship with the overridden classina basefamily (e.g., A.C). This \nrestriction helpskeep shared classes similar to each other. Sharing vs. subtyping. The J&#38;s languagekeeps \nsubtyping largely separate from sharing. Adding a sharing relationship does not change the subtyping \nrelation. In the above example, B.C is a sub\u00adtype of A.C,andB!.C is notasubtypeof A!.C dueto theexactness, \nwhether there is a sharing declaration or not. The sharing relation\u00adship does not make A.C a subtype \nof B.C, nor does it create any subtyping relationship between A!.C and B!.C. Since sharing is not subtyping, \nit is in general not allowed to directly treat an objectof a shared class as an instance of the other \nclass in the sharing relationship; an explicit view change may be required (see Section 2.3 for more \ndetails). Family adaptation. Sharing solves the problem of object adapta\u00adtion [50],in whichthegoalisto \naugmentexisting objectswithnew behavior or state. Adaptation is different from inheritance, where only \nobjects of new classes have the new behaviors. J&#38;s is the .rst language to fully integratefamily \ninheritance with in-place adapta\u00adtion that preserves object identity. Moreover, because sharing is an \nequivalence relation on classes, J&#38;s supports bidirectional, transi\u00adtive adaptation. Adaptation canimprovetheexamplecodefrom \nFigures1and2. Although ASTDisplay in Figure2providesexpression classesex\u00adtended with the ability to display \nthemselves, this new function\u00adality is not available for instances of the original classes in AST. This \nis unfortunate, because instances of the original classes might be createdbyexisting library code or \ndeserialized froma .le.We can avoid this limitation by using class sharing as shown in Fig\u00adure 3. Here, \nshares clauses cause the twofamilies ASTDisplay and AST to share all the expression classes. Instances \nof AST ex\u00adpression classes are also instances of corresponding ASTDisplay expression classes. Because \nof sharing, expression objects from the AST family can possess GUI display operations, even if the implementer \nof AST was not aware of TreeDisplay or ASTDisplay; client code for example, a visualization toolkit, \nwhich expects TreeDisplay objects would obtain the ability to handle existing AST objects. Thuseveryexpression \nclassinthe ASTDisplay family becomes an adapter [19] for the corresponding class in AST;theASTDisplay \nfamily providesfamily adaptation for AST. Given a tree of expression objects from AST,family adaptation \nensures that the whole tree is safely adapted to ASTDisplay. The adaptation preserves the original tree \nstructure, and the relation\u00adships between objects in the tree. This contrasts with prior adap\u00adtation \nmechanisms that work on individual objects, which do not guarantee safety or the preservation of object \nrelationships. With prior mechanisms such as the adapter design pattern [19], one might forget to adapt \nthe left child of a Binary object, and the call l.display() on line5 wouldfail. In Figure 3, every expression \nclass has a sharing declaration, which could be tedious to write. J&#38;s provides the adapts clause \nas a shorthand for adding sharing declarations to all inherited member classes.For example, ASTDisplay \nmay be declared with the fol\u00adlowing class header, without anyindividual sharing declarations: class ASTDisplay \nextends ... adapts AST { ... }  2.3 Views and view changes Views. If two classes are shared, a single \nobject might be treated as an instance of either one. Each class is a distinct view of that object. A \nJ&#38;s object can have any number of views, all equally valid. This contrasts with an ordinary object-oriented \nlanguage like Java (or even J&#38;), where an object has exactly one view: its run\u00adtime class. In J&#38;s, \nan object reference is not just a heap location; it is essentially a pair ..,T. of a heap location . \nand a type T, where T istheview, representedasa non-dependentexacttype.Theview T determines the behavior \nof the object when accessed through that reference. For example, the method display in Figure 3 cannot \nbe di\u00adrectly called on an object created as an instance of the class AST.Binary, because the reference \nhas the view AST.Binary!. However, when the object obtains a new reference for exam\u00adple, by storing the \nobject in a local variable with the view ASTDisplay.Binary!, it also obtains a new behavior the method \ndisplay becomes available through the new reference. Moreover,methods that areavailable through the original \nreference might behave differently when theyare called through the new ref\u00aderence. See Section 2.4 for \nan example. View changes. J&#38;s has a view change operation (view T)e, which generatesa new reference \nwith the same heap locationbut a different view.On line7in Figure3, the method show contains a view change \nexpression (view Exp)e, the result of which is a reference that still points to the same object as e \nbut with a new view that is a subtype of Exp. (Recall from Section 2.1 that within ASTDisplay, Exp is \nsugar for ASTDisplay[this.class].Exp).  View changes support late binding. Although the expression (view \nT)e has a statically known type T, the actual run-time view of the result is a subtype of T that is shared \nwith the run-time view of the value of e. For example, in line 7 of Figure 3, if e evaluates to a value \nwith the view AST.Value!, then within the family ASTDisplay, the expression (view Exp)e produces a value \nwith the view ASTDisplay.Value!, which is a subtype of ASTDisplay!.Exp, and shared with AST.Value. A \nview change (view T)e looks syntactically like a type cast (T)e, and it does have the same static target \ntype T, but it is actuallyquitedifferent. First,atype castmightfailat runtime,but view changes that type-check \nalways succeed. Second, no matter whether it is an upcast or a downcast, an ordinary cast only works \nif the target type is a supertype of the run-time class of the object. However,aviewchangehasingeneralatargettypethatis \nneithera supertype nora subtypeof the current viewof the object,but from anotherfamily.Forexample, iffamilies \nA and B share the class C, together with all its subclasses within each family, the following code is \nlegal: A!.C a = new A.C(); B!.C b = (view B!.C)a; The initial view of the created object is A.C!. The \ntarget type B!.C in the view change is neither a supertype nor a subtype of A.C!. Of course, if the type \nin a view change is indeed a supertype of the current view of the instance, the view change is a no-op. \nThird,a type cast checks run-time typing information,but has no other effects at run time. By contrast, \na view change can affect the behavior of the object. View-dependent types. Nested inheritance uses the \ndependent class p.class to indicate thefamily that the object referencedby pbelongs to. J&#38;s generalizes \np.class to be view-dependent, since anobjectmaybea memberof multiplefamilies.Forexample,sup\u00adpose ASTDisplay \ncontained the following code: AST!.Binary a = new AST.Binary(); Binary b = (view Binary)a; At run time, \na.class would denote AST.Binary!, and b.class would denote ASTDisplay.Binary!. This example shows that \nin J&#38;s, the dependent classes associated with different aliases(a and b in this example) are not \nnecessarily equal; theyare interpreted as the views associated with the respective references. Pre.x \ntypes of dependent classes are also view-dependent, en\u00adsuring that late-bound type names belong to consistent \nfamilies. Consider the left child of class Binary, stored in the .eld l. The type of the .eld is Exp, \nsugar for AST[this.class].Exp, which depends on the view of the object that contains the .eld. Accessing \nthe left child with a.l returns an objectin thefamily AST, whereas accessing it with b.l returns the \nsame object,but witha viewin thefamily ASTDisplay.In eithercase, the left child object and the containing \nBinary object have views that are in the samefamily. This means that fora treeof objectsin onefamily, \na singleexplicit view change on the root object effectively moves the whole tree to anotherfamily, implicitly \ntriggering view changes on child objects as theyare accessed.  2.4 Dynamic object evolution via view \nchange View-based dynamic method dispatching. In J&#38;s, method calls are dispatched on the current \nview of the receiver object, rather than on the receiver itself as in Java. When two references to the \nsame receiver object have different views, the same method call may invoke different code. Therefore, \nwhen a J&#38;s class overrides a method inherited from its declared shared class, both versions of the \nmethod become available to the object, and the choice is made at run time, based on the view associated \nwith the reference. package service; package logService extends class SomeService { service; void handle(Packet \np) {...} class SomeService shares } service.SomeService {...} ... ... class Dispatcher { class Logger \n{...} SomeService s; class Dispatcher shares void dispatch(Packet p) { service.Dispatcher { switch (p.kind) \n{ Logger logger; case 0: s.handle(p); void dispatch(Packet p) { ... logger.log(...); ... } } } } } Figure \n4. Evolution of a network service package Method dispatching in J&#38;s differs from that of nonvirtual \nmeth\u00adods in C++ [44], and from the statically scoped adaptation in ex\u00adpanders [50]. For nonvirtual methods \nin C++, the static type of the receiver acts as a static view that selects the method to call. By contrast, \nthe viewchange operation in J&#38;s affects method dispatch\u00ading,but still allows late binding, since \nthe type T in a view change (view T)e is a supertype of the statically unknown run-time view. Expanders \ndispatch methods within the same family dynami\u00adcally, but unlike with class sharing, the choice between \noriginal codeandexpandercodeis static.Expander methodscanbeinvoked only when expanders are in scope, \nand therefore the behavior of existing code written before the expanders cannot change. Since expansion \nis not inheritance, expander methods can only overload original methods rather than overriding them. \nDynamic object evolution. View-based method dispatching en\u00adablesanewformof dynamicobjectevolution,in \nwhichexistingob\u00adjects are updated with different behavior without breaking running code. It is more powerful \nthan object adaptation, which generally only adds new behavior to existing objects, whereas evolution \ncan also make objects change behavior, even in a context that does not mention the updated classes. J&#38;s \nsupportsevolution at thefamily level,evolving interacting objects consistentlytothenewfamily. For example, \nFigure 4 shows a package service that imple\u00adments several network services, anda dispatcher that calls \ndifferent services based on the kind of the received packet. The server code has a static .eld storing \nthe dispatcher, and an event loop: static service.Dispatcher disp; ... while (true) { ... disp.dispatch(p); \n... } Suppose the system implemented in the service family has started running, and then an updated \npackage logService is de\u00adveloped that extends service with logging at various places (Fig\u00adure4only shows \nthe additional loggingin the dispatch method). The goal is to update the system with logging ability, \nwithout hav\u00ading to stop it from running. To evolve the system fromservice to logService, the view of \nthe dispatcher object stored in the static .eld disp needs to be changed. This could be done in initialization \ncode in the extended package, as follows: service!.Dispatcher d = (service!.Dispatcher)Server.disp; // \ncast Server.disp = (view Dispatcher)d; // view change After this view change, the dispatch method overridden \nin the extended package will be called. More importantly, although just a single explicit view change \nis applied to the dispatcher object, all the other objects transitively reachable from the dispatcher, \nsuch as through the .eld s of type SomeService, will also obtain new views when theyare accessed, resulting \nin using the versions of their methods that have logging enabled. Thus, a single explicit view change \ncauses a consistent evolutionofmanyobjectstothenewfamily.Thiskindofevolution is simpler to implement \nand likely to be more ef.cientthan going through all the objects and updating them individually.  2.5 \nSharing constraints Sharing relationships between types are not always preserved by derivedfamilies, \neitherby designorasthe resultof changed class hierarchyinthederivedfamily.Forexample,inafamily inherited \nfrom ASTDisplay, one might choose not to share any class, or to share classes from TreeDisplay, and in \neither case, the new family no longer shares classes with theAST family. Therefore,a view-change operation \nthatworksin the basefam\u00adily might not make sense in the derivedfamily. J&#38;s does not try to check \nall inherited method code for inapplicable view changes, but rather makes checking modular viasharing \nconstraints.AJ&#38;s method can have sharing constraints of the form sharing T1 = T2, which means that \nany value of type T1 can be viewed as of type T2,and viceversa;in otherwords,the sharing relationship \nT1 . T2 may be assumed in the method body.Aview change can only ap\u00adpear in a method with an enabling \nsharing constraint. Outside the scope of sharing constraints, the type checker (and programmer) need \nnot be concerned with sharing. Therefore, reasoning about class sharing is local. For example, in Figure \n3, the method show has a shar\u00ading constraint AST!.Exp = Exp (line 6), which allows the view change (view \nExp)e to be applied to the variable e of static type AST!.Exp. To know statically that the view change(view \nExp)e will suc\u00adceed, we must know that every subclass of AST!.Exp has a corre\u00adsponding shared subclass \nunder ASTDisplay!.Exp. J&#38;s requires that some pre.x of each type in the constraint is exact, and \neither non-dependent or only dependent on the path this;thus, we can check all the subclasses in a locally \nclosed world (Section 2.1), without a whole-program analysis. In this example, the exact pre\u00ad.xes in \nquestion are AST! and ASTDisplay[this.class]. The type checker veri.es that sharing constraints in the \nbase family still holdin the derivedfamily; basefamily methods whose sharing constraints do not hold \nmust be overridden. Although sharing constraints support modular type checking, theydo introducean annotationburdenforthe \nprogrammer.Ourex\u00adperience suggests that the annotationburdenis manageable. While it appears possibleto \nautomatically infer sharing constraints,byin\u00adspecting the type of the source expression and the target \ntype of every view change operation in the method body, we leave this to future work. 3. Protecting unshared \nstate 3.1 Unshared .elds In J&#38;s, shared classes do not necessarily share all their .elds. Unshared \n.elds are important for greater extensibility, but they pose challenges for the safety of the language. \nJ&#38;s uses masked types [35] and duplicate .elds to ensure safety in the presence of unshared .elds. \nFigure5illustrates the two kinds of unshared .elds. First, new object .elds may be introduced by shared \nclasses in the derived family. Because these .elds do not exist in the basefamily, they cannot be shared. \nIn Figure 5, classes A1.B and A2.B are shared, butA2.B introducesanew.eld f that does notexistin A1.B. \nWhen a view change from the base family to the derived family for example, from A1!.B to A2!.B is applied, \nthe new .eld (e.g., class A1 { class B {} class C {D g; } class D {} } class A2 extends A1 { class B \nshares A1.B { T f; // a new field } class C shares A1.C\\g { } // shared with a mask class E extends D \n{ } // a new subclass of D } Figure 5. Shared classes with unshared .elds the .eld f in Figure 5) would \nbe uninitialized, which may be unexpectedtothe codeinthe derivedfamily. J&#38;s uses masked types to \nprevent the possibly uninitialized new .eld from being read.A masked type, written T\\f, is the type T \nwithout read access to the .eld f.We say that the .eld f is masked in T\\f. The mask on a .eld can be \nremoved with an assignment to that .eld. Masked types introduce the subtyping relationship T= T\\f.For \nthe example in Figure 5, a view change from A1!.B to A2!.B must have a mask on the target type: A1!.B \nb1 = new A1.B(); A2!.B\\f b2 = (view A2!.B\\f)b1; Therefore, after this view change, the .eld f of b2 \ncannot be read before it is initialized. The second kind of unshared .eld is those with unshared types. \nIn Figure 5, the .eld g has type D, and it cannot be shared, because in the A2 family,g might store an \nobject of class E. When a view change is applied from the derivedfamily to the basefamily(for example, \nfrom A2!.C to A1!.C), an A2.E object stored in g would nothavea view compatible with the basefamily. \nTherefore, J&#38;s requires that .elds with unshared types are masked in the sharing declaration.Aduplicate \n.eld with the same name for the shared class is also generated automatically in the de\u00adrivedfamily.Forexample,in \nFigure5,itis asifthe class A2.C has its own implicit declaration of .eld g: class C shares A1.C\\g { D \ng; } An instance of A1.C and A2.C contains two copies of the .eld g, each appearing as a new .eld to \nthe other class. Which copyis accessed dependsonthe currentviewofthe instancethrough which the .eld g \nis accessed. Field duplication prevents objects of an unshared class from being accidentally accessed \nin otherfamilies. Therefore, interacting objects always have consistent views. When shared classes have \nduplicate .elds, it is up to the pro\u00adgrammerhowtokeepthe copiesin sync,oreven whethertokeep them in sync. \nThe programmer may choose to construct a corre\u00adspondingobjectinthetargetfamily,storingitinthe duplicate.eld, \nasintheexamplein Section3.2,orjusttoleavethe .eldmaskedin the targetfamily.  3.2 In-place translation \nwith unshared classes J&#38;s supports in-place translation of data structures betweenfami\u00adlies in which \nnot all the classes are shared (translation is trivial if all classes are shared). As the data structure \nis translated, some objects in the structure may remain the same, with only a view change, and other \nobjects, particularly those of unshared types, are explic\u00aditly translated. One use of this kind of translation \nis for compilers, where the data structure is an abstract syntax tree, and manyparts oftheASTdonotneedtochangeduringagiven \ncompilerpass.  package base; package pair extends base; abstract class Exp abstract class Exp { ... \n} { abstract base!.Exp translate class Var extends Exp { (Translator v); } String x; class Pair extends \nExp ... { Exp fst, snd; ...} } class Translator { class Abs extends Exp { base!.Abs reconstructAbs String \nx; (Abs old, String x, Exp e; base!.Exp exp) { ... } ... ... } } Figure 6. Lambda calculus and pair \ncompiler extension 1 package pair extends base; 2 abstract class Exp shares base.Exp { 3 abstract base!.Exp \ntranslate(Translator v); 4 } 5 class Var extends Exp shares base.Var { ... } 6 class Abs extends Exp \nshares base.Abs\\e { 7 base!.Exp translate(Translator v) { 8 base!.Exp exp = e.translate(v); 9 return \nv.reconstructAbs(this, x, exp); 10 } 11 } 12 class Pair extends Exp { 13 Exp fst, snd; 14 base!.Exp translate(Translator \nv) { 15 return new ...; // (.x..y.. f. fxy) .fst..snd. 16 } 17 } 18 class Translator { 19 base!.Abs reconstructAbs(Abs \nold, String x, 20 base!.Exp exp) 21 sharing Abs\\e = base!.Abs\\e { 22 if (old.x == x &#38;&#38; old.e \n== exp) { 23 base!.Abs\\e temp = (view base!.Abs\\e)old; 24 temp.e = exp; 25 return temp; 26 } 27 else \nreturn new base.Abs(x, exp); 28 } 29 ... 30 } Figure 7. In-place translation of the pair language Figure6showstheskeletonofa \nsimple compiler implemented with family inheritance but without class sharing, modeled on the Polyglot \nextensible compiler framework [29]. This example translates the .-calculus extended with pairs, into \nthe ordinary .\u00adcalculus. The package base de.nes the target language through class declarations for AST \nnodes of the .-calculus (e.g., Abs for . abstractions); the package pair extends the source language \nwith one additional AST node Pair. Classesinherited from base are further bound in pair with translate \nmethods that recursively translate an AST from pair to base. The class Translator pro\u00advides the methods \nAST classes use to (re)construct nodes in the tar\u00adgetfamilyusingtranslatedversionsoftheirchildnodes;the \nmethod reconstructAbs does this for . abstractions. However, without sharing, the translation from pair \nto base has to recreate the whole AST, even for trivial cases like Var, becausethe twofamilies base and \npair are completely disjoint despite their structural similarity. By contrast, Figure 7 shows the J&#38;s \ncode that does in-place translation. The base family remains the same as in Figure 6, and is omitted. \nClasses Var and Abs in pair are declared to share corresponding classes in base (lines 5 6). Pair is \nnot shared, because it does not exist in base. Consider the two shared classes pair.Abs and base.Abs. \nThe type of their .eld e, which is base[this.class].Exp, is inter\u00adpreted as pair!.Exp and base!.Exp in \nthe two families. The two interpreted .eld types are not shared, because a value of type pair!.Exp might \nhave run-time class pair.Pair, which has no corresponding shared class in the base family. Therefore \nthe two Abs classes each have their own copies of the .eld e, and the shar\u00ading declaration on line6hasa \nmask on e. Similarly, the sharing constraint on line 21 also has masks, and so does the view change operation \non line 23, where the Abs instance is reused if all its subexpressions have been translated in place. \nThe sharing constraint, together with the corresponding view change operation, has a mask on the .eld \ne, in case it points to an instance of an unshared subclass of Exp, such as Pair. The mask is removed \non line 24, after which the type of the variable temp becomes base!.Abs. As shown in the above example, \nJ&#38;s uses masked types to pre\u00advent objects of unshared types, such as Pair, from being leaked into \nan incompatiblefamily (here, base). Masked types do intro\u00adduce some annotationburden.However,class sharingisexpectedto \nbe usedin practice betweenfamilies that are similarto each other, where extensibility and reuse are needed \nand make sense. In that case, there should not be manymasks.  3.3 Translation from the base family to \nthe derived family Translations in different directions are not always of the same dif.culty. Section \n3.2 proposes a solution for in-place translation from the derivedfamily(pair)to the basefamily(base). \nThe complexity of the solution arises mostly because the objects of the Pair class must be translated \naway. However, as noted in [13], in\u00adplace translation in the other direction, that is, from base to pair, \nshould be almost trivial, by simply treating an AST in base as an AST in pair. To capture the asymmetry, \nJ&#38;s supports directional sharing re\u00adlationships between types that are possibly masked, represented \nas T1 . T2, which means that an object of static type T1 may be ap\u00adplied a view change with target type \nT2. In Figure 7, the J&#38;s com\u00adpiler may infer the sharing relationship base!.Exp . pair!.Exp, (the \nother direction pair!.Exp . base!.Exp does not hold, be\u00adcause of the class Pair), and allows a constant-time \nin-place trans\u00adlation from base to pair, by a view change from base!.Exp to pair!.Exp. Note that in this \ncase, the sharing declaration on line 6 in Figure 7 actually induces the following two directional sharing \nrelationships: base.Abs!. pair.Abs! pair.Abs!\\e . base.Abs!\\e rather than justabidirectional sharing \nrelationship base.Abs!\\e . pair.Abs!\\e. 4. Type safety Thekey aspects of the J&#38;s language are formalized \nin an object calculus. This calculus has some similarities with other formal se\u00admantics that support \nfamily inheritance, e.g., Jx [28], Tribe [10], and vc calculus [18], and especially the J&#38; calculus \n[30, 31]. The most notable differences come from adding sharing. The soundness of the calculus is proved \nusing subject reduction and progress [51]. Due to the space limit, this section only sketches the formaliza\u00adtion \nof the language and the proof. See the companion technical report [36] for details.  4.1 Preliminaries \nA J&#38;s program Pr is de.ned as a set of class declarations L and ..,P.!\\ f.. P.!\\ f.= PS\\ f an expression \ne, modeling the main method.Aclass declaration L contains a superclass declaration T1, a shared class \ndeclaration T2, view(..,P.!\\ f..,PS\\ f)= . . f.. . f. ..,P!\\ f..!P. nested classes L, .elds F, and methods \nM: implements the view change operation, and is de.ned as follows: . .. . . .. . P!= PS . . P.!\\ f.. \n. P!\\ f L::= class Cextends T1 shares T2 {LFM} The shared class declaration may include a set of masks \nf on unshared .elds. If the class is not shared with any other class, it is declared to share with itself. \nEvery method is declared with a (possibly empty) set of sharing constraints: M::= Tm(Tx) sharing T1 . \nT2 {e} The semantics uses directional sharing constraints and relation\u00adships, because view changes are \ndirectional. Inference of direc\u00adtional sharing relationships (see Section 3.3) is outside the scope of \nthis paper and is not formalized here. Expressions in J&#38;s are mostly standard, with the addition \nof the view change expression (view T)e: e ::= v | x | e. f | x. f = e | e0.m(e) | e1; e2 | new T | final \nTx = e1; e2 | (view T)e Values v (that is, references) in J&#38; are pairs ..,S. of a heap location . \nand a view, represented as a non-dependent type S. Every .eld is assumed to have an initializer, and \ntherefore object creations new T do not provideinitialvalues for .elds.With the help of masked types, \na distinguished null value is not needed, simplifying the calculus. 4.2 Operational semantics J&#38;s \nis modeled witha small-step operational semantics.Acon.g\u00aduration consistsofanexpression e,astacks,a heapH, \nandarefer\u00ad ence set R,andevaluation takes the forme,s,H,R-. e, s. ,H. ,R. . The stack s maps variables \nx to values v. The heap H is a func\u00adtion mapping tuples ..,P, f. of memory locations, fully quali.ed \nclass names, and .eld names to values v.The class Pis included in the domain to distinguish copies of \nduplicate .elds, which have the same name. The reference set R collects all the references r thathavebeen \ngeneratedduringevaluation,andisonlyusedbythe soundness proof. Mostevaluation rules are straightforward.Thetwonotable \nones are R-SET and R-VIEW for .eld assignments and view changes, respectively: s(x)= ..,P!\\ f.. s. = \ngrant(s,x. f) H. = H[..,fclass(P, f), f. := v] R. = R,..,P!\\( f.- f). (R-SET) x. f = v, s, H,R-. v, \ns. ,H. ,R. R. = R,view(v,S) (R-VIEW) (view S)v,s,H,R-. view(v, S),s, H,R. A .eld assignment x. f = v, \nwhere s(x)= ..,S., not only up\u00addates the heap,but also removes the mask on f, if any, in the type S. \nThe auxiliary function grant captures the mask removal, and fclass(P, f) .nds the shared class of Pthat \nintroduces the .eld f, or the current copyof f, if it is a duplicate .eld. A view change (view S)..,S.. \ngenerates a new value .., S... witha new view S.. compatible with S. The auxiliary function view  4.3 \nStatic semantics Type checking is performed in a typing context G, which is a set of variable type bindings \nx:T, path equivalence constraints p1 = p2, and directional sharing constraints T1 . T2.Path equivalence \nconstraints are used to assert equivalence of dependent types during evaluation, and unlike previous \ncalculi onfamily inheritance, paths with different views are not included, even if they are actually \naliases of the same location (see Section 2.3). Sharing constraints are declared by the current method \nbeing checked, and are used to type-check view change operations. Since assignments may remove masks, \nthe J&#38;s type system is .ow-sensitive.Typing judgmentsareoftheform G . e:T,G.,where G. represents \nthe updated typing environment after evaluating e. Aview changeexpression(view T)e type-checks, if the \ntype of the source expression e is shared with the target type T: G . e:T. ,G. G . T. . T (T-VIEW) G \n. (view T)e:T,G. The directional sharing judgment G . T1. T2 states thatavalue of type T1 can be transformed \nto T2 through a view change. A bidirectional sharing judgment G . T1 . T2 is sugar for a pair of directional \nsharing judgments. Figure8 shows all the derivation rules for sharing judgments. In SH-DECL, auxiliary \nfunction share(P.C) returns the declared shared type for class P.C, and fnames(.elds(P.C) - .elds(P.)) \ngives all the new .elds that are not contained in the shared super\u00adclass P., which are also masked in \nthe generated sharing relation\u00adship, in addition to .elds f that are masked in the sharing declara\u00adtion. \nSH-CLSstates that for two types to be shared, every subclass of the sourcetypemustshareaunique subclassofthetargettype,with \nappropriate masks. The uniqueness is necessary for the auxiliary view functiontosetthetype componentinthe \ngeneratedreference. Moreover,thetwotypesinSH-CLS havetobeboth nestedinsim\u00adpleexact types, and therefore \nwe can enumerate all their subclasses in the locally closed worlds. The type system clearly distinguishes \nsharing relationships be\u00adtween types from subtyping relationships. The subtyping judgment G . T1 = T2 \nmeans that a value of type T1 can be directly used as a value of T2. Subtyping rules are basically the \nsame as in the J&#38; calculus, with the addition of S-MASK andS-SUB-MASK: G . T1= T2 G . T= T\\ f (S-MASK) \n(S-SUB-MASK) G . T1\\ f= T2\\ f Subtyping rules in J&#38;s do not depend on anysharing judgment. In particular, \nG . T1 . T2 does not imply G . T1= T2. Decidability. The static type system of J&#38;s is decidable. \nFirst, most of the typing rules are syntax-directed, except for one that is based on subtyping. Anysubtyping \nrelationship can be derived using a given type at most once, and a .nite number of types can appear in \nthe derivation. The number of types that can appear in a derivation is .nite because nesting depth is \nbounded, and the static typing environment contains no path equivalence constraints. Second, the .ow-sensitive \nchecking of masks reaches a .xed point in .nite steps, because there are only a .nite number of .elds \nin a class to mask.  G . T1 . T2 G . T2 . T3 T1 . T2 . GG . T1 . T2 G . T . T (SH-REFL) (SH-TRANS) (SH-ENV) \n(SH-MASK) G . T1 . T3 G . T1 . T2 G . T1\\ f . T2\\ f share(P.C)= P.\\ f PS1 = P1. !.C1 PS2 = P2. !.C2 . \n. f.. . f fnames(.elds(P.C) - .elds(P.)) = f..P1. G . P1!= PS1 . (.!P2 . G . P2!= PS2. G . P1!\\ f.. \n. P2!\\ f.) (SH-DECL) (SH-CLS) G . P.C!\\ f\\ f.. P.!\\ f G . PS1\\ f . PS2\\ f. Figure 8. Rules for sharing \njudgments 4.4 Soundness The soundness theorem is standard: THEOREM 4.1. (Soundness) If ..L,e. ok, and \n0/ . e :T, and e,0/ ,0/,0/ .* e,s,H,R, then either e. = v and .s,H,R.. v:T, or .e,s. ,H. ,R. . e,s,H, \nR-. e,s. ,H. , R. . In the theorem, .s, H, R. represents the typing environment extracted from a run-time \ncon.guration. The proof is by showing subject reduction and progress, which are proved respectively by \ninduction on appropriate typing deriva\u00adtions and structural induction on expressions. 5. Implementation \nWehave implementeda prototype compilerofJ&#38;s in the Polyglot framework [29]. The compiler is an extension \nbased on the latest implementation of the Jx/J&#38; compiler [28, 30], which is itself an extension of \nthe Polyglot base Java compiler. The J&#38;s compiler extension has 5,200 lines of code, excluding blank \nlines and com\u00adments. J&#38;s also hasarun-time system that supports implicit classes and provides machinery \nfor viewchanges and run-time type inspec\u00adtion. The run-time system is written in Java, and has 1,500 \nlines of code, most of which implements a custom classloader, using the ASM bytecode manipulation framework \n[8]. J&#38;s is implemented as a translation to Java. The amount of code produced by the compiler is \nproportional to the size of the source code. The compiler generates class declarations only for explicit \nclasses.For implicit classes, the custom classloader lazily synthesizes classes representing them at \nrun time. 5.1 Type checking Because of masks, J&#38;s has a .ow-sensitive type system. Every method is \nchecked in twophases. The .rst phase is .ow-insensitive, ignoring masks, and generates typing information \nnecessary for building the control-.ow graph. The second phase is essentially an intraprocedural data-.ow \nanalysis, which computesa type binding, possibly with masks, for each local variable (including this)at \nevery program point. 5.2 Translating classes The translationis similartobut moreef.cientthantheJ&#38; \ntransla\u00adtion described in [30], primarily because of the custom classloader. First, masks are erased \nafter type checking. Then, every ex\u00adplicit J&#38;s class is translated into several Javaclasses and interfaces, \namong whichthe most important ones are the instance class and the class class. The instance class contains \nall the object .elds of the J&#38;s class. At run time, each object of a J&#38;s class is represented \nas an object of the instance class. The class class contains method implementations, static .elds, and \ntype information needed to im\u00adplement casts, instanceof, and pre.x types. The class class also includes \ngetter and setter methods for all object .elds, since un\u00adshared .elds may be duplicated, and therefore, \n.eld accesses are also view-dependent.Various interfaces are generated for simulat\u00ading multiple inheritance. \nAn implicit class also has an instance class and a class class, both synthesized by the custom classloader. \nThe instance class collects all object .elds from superclasses. The class class contains a dispatch method \nfor each inherited J&#38;s method. The dispatch method calls the appropriate method implementation in \nthe class class of some explicit J&#38;s class, identi.ed by the classloader. For each set of shared \nJ&#38;s classes, the classloader maintains a representative instance class that collects all the object \n.elds, in\u00adcluding the duplicate ones. At run time, objects of all these shared classes are created as \ninstancesofthe representative instance class. When a new shared class that contains more object .elds \nis loaded, the classloader updates the representative instance class to include the new .elds. All the \nexisting objects of the old representative instance class will be lazily converted to the most up-to-date \nrep\u00adresentative instance class. The conversion works because objects of instance classes are referenced \nindirectly, as described in Sec\u00adtion 5.3. 5.3 Supporting views and view changes A J&#38;s object can \nbe an instance of several shared classes, and every referencetothe object couldhaveadifferentview. Therefore, \nthe J&#38;s implementation adds a level of indirection. Each object is referenced indirectly through \na reference object, containing two .elds: one points to the instance class object; and the other points \nto aclass class object, which is the viewassociated with the reference. The view determines the behavior \nof the translated J&#38;s ob\u00adject. Method calls are dispatched on the view rather than on the object \nitself. Pre.x types are evaluated with the view. Casts and instanceofs check the view. Which copyof a \nduplicated .eld is accessed also depends on the view. Aview change operation(view T)e is translatedto \ngenerating a new reference object with the same instance class object, and a view compatible with T. \nThe implementation memoizes the result to the most recent view change operation on anyreference object, \nto avoid repeatedly generating the same reference object. A J&#38;s object might obtain a new view implicitly. \nMoving an object from one family to another would implicitly move all the other objects that are transitively \nreachable through shared .elds. Implicit view changes are carried out lazily, only at the time when objects \nare accessed through .elds. Reference objects add some overhead for accessing members ofan object.Withalower-level \ntarget language,a probablyfaster implementation is possible in which different object views are represented \nas different pointers into the same object, like the C++ implementation of multiple inheritance. Since \nmethods are dispatched on views, the object would contain pointers to several dispatch tables, one for \neach view. Method dispatch should then have performance similar to C++ virtual method calls.  5.4 Java \ncompatibility J&#38;s is mostly backward-compatible with Java. AnyJava code with no nested classes is \nalso legal J&#38;s code. J&#38;s programs may use existing Java code, including libraries that are compiled \nby a Java compiler. Of course, precompiled Java code does not enjoy the bene.t of class sharing. The \nJ&#38;s reference object forwards method calls to hashCode, equals, etc., and therefore J&#38;s objects \nmay be passed to Java code, for example, to be stored in a HashSet. There is one limitation in the current \nimplementation: a J&#38;s class cannot be shared if it inherits from anyJava superclass other than java.lang.Object, \nor if it implements most Java interfaces. This is the artifact of using reference objects to support \nviews; a lower\u00adlevel implementation should not have this limitation.  The J&#38;s language currentlyextendsJava1.4.It \ndoes not support generics, which seem to be an orthogonal feature. We leave the interaction between generics \nand class sharing to future work.  5.5 Concurrency Class sharing is compatible with multi-threaded code. \nThe J&#38;s compiler ensures that in the generated code, synchronized state\u00adments and methods are synchronized \non the wrapped instance class object, rather than on the reference object. The implementation of the \nreference object also relays method calls to wait, notify and notifyAll to the underlying instance class \nobject.Aview change operation usually just creates a new reference object that contains a reference to \nan existing instance class object, without affecting existing references, and therefore requires no synchronization. \nThe only operation that needs to be synchronized is the lazy conversion of an object to the most up-to-date \ninstance class. 6. Experience 6.1 Jolden benchmarks We tested the J&#38;s implementation with the jolden \nbenchmarks [9] to study the performance overhead for code that does not use the new extensibility features \nof J&#38;s. All ten benchmarks, with few changes, are tested with four language implementations: Java, \nJ&#38; as describedin[30],J&#38;witha classloader similartothat described in Section 5.2, and J&#38;s.Table1compares \nthe results. The testing hardware is a Lenovo Thinkpad T60 with Intel T2600 CPU and 2GB memory, and the \nsoftware environment consists of Microsoft Windows XP, Cygwin, and JVM 1.6.0 07. Table1showsthattheuseofa \ncustom classloadergreatlyim\u00adproves the performance, comparing the two implementations of J&#38;. Unsurprisingly, \nnested inheritance and class sharing do intro\u00adduce overhead. The J&#38;s times show a 37% slowdown versus \nthe classloader-based J&#38; implementation, and 94% versus the highly optimized Java HotSpot VM. The \noverhead seems reasonable, es\u00adpecially considering that the current implementation works as a source-to-source \ntranslation to Java, precluding many optimiza\u00adtions and implementation techniques. We expect that a more \nso\u00adphisticated implementation could remove much of the overhead. Running programs in J&#38;s have the \nlatent capability to be ex\u00adtended in many ways, so it is not surprising that there is some per\u00adformance \ncost. But it seems software designers are often willing to pay a cost for extensibility, because theyoften \nadd indirections and use design patterns that promoteextensibilitybuthaverun-time overhead.We believe \nthatJ&#38;s removes the need for manysuch ex\u00adplicitextensibility hooks, while making code simpler.For \nsystems where extensibility is more important than high performance [46], theexisting implementation \nmay alreadybefast enough. 6.2 Tree traversal The jolden benchmarks do not use the new features provided \nby J&#38;s.Tostudythe performanceofview changes,especiallyonlarge data structures,we wrotea small benchmarkin \nwhichtwofamilies share classes that implement binary trees.Acomplete binary treeof agivenheightis.rst \ncreatedinthebasefamily,andanexplicitview change is applied to the root of the tree.Adepth-.rst traversal \nis carried out to trigger all the lazy implicit view changes. The testing environment is the same as \nin Section 6.1. Figure 9. Lambda compiler structure. Translator and some AST nodes not shown. Table2summarizes \nthe results. In-place adaptation,even witha traversalthat triggersallthe implicitviewchanges,isfasterthanan \nexplicit translation that creates new objects in the derivedfamily, and the running time is also close \nto that of the initial creation of the tree. The fourth row showsthat once the implicit view changes \nare complete and the new reference objects have been memoized, traversals execute as fast as a traversal \nbefore the view changes. This benchmark doesa completetraversal. Since view changes are lazily triggered, \nthe relative performance of adaptation would look even better if not all nodes needed to be visited after \nadaptation. 6.3 Lambda compiler The J&#38;s implementation successfully compiles and executes the completed \nversion of the lambda compiler shown in Figure 6, which compiles .-calculus enhanced with sums and pairs \ndown to simple .-calculus. The structure of the lambda compiler is illustrated in Figure 9. Solid arrows \nrepresent class and family inheritance, and dashed arrows represent sharing declarations. The lambda \ncompiler has a base family with classes represent\u00ading AST nodes for simple .-calculus. There are two \nfamilies di\u00adrectly derived from the basefamily,extended with sums and pairs respectively. The sum family \nand thepair family each share AST classes from the base family, and each implement in-place trans\u00adlation \nto simple .-calculus, as shown in Figure 6. The last de\u00adrivedfamily sumpair composes the sum family and \nthepair fam\u00adily, leading to a compiler that supports both sums and pairs. The sumpair family sharesAbs \nand other AST classes from the simple .-calculus with the base family, and by transitivity, withsum and \npair. The code of sumpair just sets up the sharing relationships, without a single line of translation \ncode. The in-place translation code from sum and pair is composed to translate away sums and pairs. This \nprogram is about 250 lines long,but uses the features of J&#38;s ina sophisticatedway.Forexample,familieshave \nboth shared and unshared classes, masked types are used to ensure objects of new AST classes (pair and \nsum) are translated away, and the two translations are composed to translate pairs and sums at once. \nThe lambda compiler example is inspired by the Polyglot framework, and it encapsulates most of the interesting \nissues that arise in making Polyglot extensible. The results suggest Polyglot would be simpler in J&#38;s,but \nthis is left for future work.  6.4 CorONA Our second signi.cant example shows that the adaptation capa\u00adbility \nof J&#38;s can be used to seamlessly upgrade a running server and its existing state with entirely new \nfunctionality. We ported CorONA, an RSS feed aggregation system [37], to J&#38;s, and suc\u00ad  bh bisort \nem3d health mst perimeter power treeadd tsp voronoi Java 1.74 0.53 0.17 0.41 0.88 0.22 1.00 0.14 0.12 \n0.31 J&#38; [30] 13.91 1.77 0.48 8.45 4.43 2.82 2.43 2.20 0.37 7.19 J&#38; with classloader 2.02 0.71 \n0.22 0.71 1.06 0.39 1.14 0.21 0.16 0.59 J&#38;s 2.61 0.88 0.23 1.61 1.54 0.47 1.27 0.45 0.17 0.83 Table \n1. Results for the jolden benchmarks.Average timeover ten runs,in seconds. Tree height 16 18 20 Tree \ncreation 0.110 0.287 1.295 Traversal before view changes 0.008 0.027 0.105 View changes 0.125 0.367 1.303 \nTraversal after view changes 0.006 0.025 0.099 Explicit translation 0.145 0.622 1.669 Table 2. Comparing \nview changes withexplicit translation.Aver\u00adage time over ten runs, in seconds. cessfully used class sharing \nto update the system at run time with a new caching algorithm. CorONA is originally an extension of Beehive \n[38], which is itself anextensionofPastry [40] that providesa distributed hash table. BeehiveextendsPastry \nwith active replication, whereas PC-Pastry [38] extends Pastry with passive caching. We refactored the \nported CorONA, and composed it with PC-Pastry and Bee\u00adhive respectively, creating two applications (named \nPCCorONA and BeeCorONA) with different caching strategies. The system is tested by .rst running PCCorONAfor \na while, and then evolving the running system from passive cachingto active cachingby com\u00adpiling and \nloading a new package, BeeCorONA. Sharing declarations are added so that classes representing host nodes, \ndata objects, and network addresses are shared between CorONA and its two derived families. Classes for \nnetwork mes\u00adsages and cache management are not shared. The evolution code goes over all the host nodes, \nwhich are the top-level objects in the system, changing their views, and creating new caching managers. \nThe amount of code to implement evolution is relatively small (less than 40 lines of code, compared to \n8300 for the whole system, excluding comments and empty lines).Very little code is needed because we \nonly need to change the views of host nodes; all the other referenced objects will have their views changed \nimplicitly when they are accessed. In the host node class, .elds storing the caching managers are not \nshared, and masked types ensure that they are initializedintheevolved system.Witha slightlydifferent \ncon.guration, we can actually run the two variants of the system at the same time, using the same set \nof host node objects.View\u00addependent types ensure that network messages of correct versions are created \nand accepted for each of the systems. 7. Related work Adaptation. The Adapter design pattern[19]isa protocolforim\u00adplementing \nadaptation. However, this and other related patterns are tedious and error-prone to implement, rely on \nstatically unsafe type casts, and do not preserve object identity or provide bidirectional adaptation \nas J&#38;s does. Expanders [50] are a mechanism for adaptation. New .elds, methods, and superinterfaces \ncan be added into existing classes. Expanders are more expressive than open classes [11], which can only \nadd new methods. Method dispatch is statically scoped, so expanders do not change the behavior of existing \nclients. New state is added by wrapper classes; a map from objects to wrappers ensures uniqueness of \nwrapper instances. CaesarJ [26, 1] is an aspect-oriented language that supports adaptation with wrappers \ncalled aspect binders. Wrappers and ex\u00adpanders are similar. They both can extend wrapped classes with \nnew states, operations, and superinterfaces; no duplicate wrappers are created for objects; and dynamic \nwrapper selection is similar to expander overriding. Wrappers in CaesarJ are less transparent: a wrapper \nconstructor must be called to get a wrapper instance, whereas expander operations can be applied directly \nto objects. Multiple inheritance in CaesarJ makes wrapper selection ambigu\u00adous; J&#38;s disambiguates \nvia views. Both expanders and CaesarJ wrappers share limitations: it is impossibletooverride methodsinthe \noriginalfamily,and therefore there is no dynamic dispatching across families; object identity is not \npreserved; the use of expanders and wrappers is limited to adaptation, since the adapterfamily cannot \nbe used independently ofits originalfamily. Class sharinginJ&#38;s provides more .exibility. The FickleIII \n[14] language has a re-classi.cation operation for objects to change their classes. Re-classi.cations \nare similar to viewchanges in J&#38;s,but directlychangethebehaviorofallexisting references to the object; \ntherefore, effects are needed to track the change.A re-classi.cation might leave .elds uninitialized, \nwhile masked types in J&#38;s ensure that after a view change, .elds are initialized before use. FickleIII \ndoes not support classfamilies. Chai3 [42] allows traits to be dynamically substituted to change object \nbehaviors, similar to view changes in J&#38;s. However, Chai3 does not supportfamilies, and thefact that \ntraitsdo nothave .elds makes it harder to support manipulation of data structures. Some work on adaptation, \nincluding pluggable composite adapters [27], object teams [20], and delegation layers [34], also has \nsome notionoffamiliesof classes.However,familyextensibil\u00aditydoesnotapplytothe relationship betweenthefamilyofadapter \nclasses and thefamilyof adaptee classes. Therefore,these mech\u00adanisms either do not support method overriding \nand dynamic dis\u00adpatch between the adapter and adapteefamilies [27, 20], orhavea weaker notionoffamiliesin \nwhich programmershaveto manually wire inheritance relationships between the basefamily and the delegationfamily \n[34]. These mechanisms all use lifting and low\u00adering, introduced in [27], to convert between adapter \nand adaptee classes. Lifting and lowering are similar to view changes in J&#38;s, but are not symmetric \nand do not support late binding. Family inheritance. Several different mechanisms have been proposed \nto supportfamily inheritance, including virtual classes, nested inheritance,variantpath types, mixin \nlayers, etc.Inall these family inheritance mechanisms, families of classes are disjoint, whereas with \nclass sharing, differentfamilies can share classes and their instances. Virtual classes [25, 24, 16, \n18, 10] are inner classes that can be overridden just like methods. Path-dependent types are used to \nensure type safety. The soundness of virtual classes has been formally proved by Ernst et al. [18], and \nby Clarke et al. [10]. Nested inheritance [28] supports overriding of nested classes, which are similar \nto virtual classes. Nested intersection [30] adds and generalizes intersection types [39, 12] in the \ncontext of nested inheritance to provide the ability to compose extensions. Virtual classes support family \npolymorphism [17], wherefam\u00adilies are identi.ed by the enclosing instance. Nested inheritance supports \nwhat Clarke et al. [10] called class-based family poly\u00admorphism, where each dependent class de.nesafamilyof \nclasses nested within andalso enclosing it.With pre.x types, anyinstance ofaclassinthefamilycanbeusedto \nnamethefamily.  Variant path types [22] supportfamily inheritance without de\u00adpendent types, using exact \ntypes and relative path types (similar to this.class)for type safety. These exact types are very different \nfrom those in J&#38;s: ina J&#38;s exact type A.B!.C, exactness applies to the whole pre.x before !, \nthat is, A.B;in an exact typeA@B.C in [22], exactness applies to the simple type name right after @, \nthat is, B. Mixin layers [41] generalizes mixins [4]. Mixins are classes that can be instantiated with \ndifferent superclasses, and mixin layers are mixins that encapsulate other mixins. Mixin layers supportfamily \ninheritance: when a mixin layer is instantiated, all the inner mixins are instantiated correspondingly. \nVirtual types [47, 7, 48, 21] are type declarations that can be overridden. Virtual types are more limited \nthan virtual classes: they provide family polymorphism but not family inheritance. Scala [32, 33] supports \nfamily polymorphism and composition through virtual types, path-dependent types, and mixin composi\u00adtion. \nIt also supports parametric polymorphism. Scala does not have virtual classes and does not supportfamily \ninheritance. Scala has views that are implicitly-called conversion functions. Scala views do not provide \nadaptation: they create new instances in the target types. Sharing in functional languages. Wadler sviews \n[49] are an iso\u00admorphism between a new data type and an existing one, which is similar to a sharing declaration. \nOf course, there are obvious dif-ferences:Wadler s views are fora functional setting, and primarily relate \nabstract data types and types inductively de.nedwith pattern matching, whereas J&#38;s creates sharing \nrelationships only between overridden and overriding classes. The SML module system [23] has sharing \nconstraints, which require functor module parameters to agree on type components. SML sharing constraints \ndictate applicability of functors; J&#38;s shar\u00ading constraints dictate applicability of method bodies. \nSafe dynamic software updating. There is prior work on the problem of safely updating software without \ndowntime. Barr and Eisenbach [2] propose a framework to support dy\u00adnamic update of Java components that \nsatisfy the binary compat\u00adibility requirement [45], which also includes a custom classloader. Thegoalistoprovidea \ntool thatkeepsJava librariesupto date, rather than to improve the extensibility of the language. Duggan \n[15] describesa calculus that combinesWadler s views and SML sharing constraints to support hot-swapping \nmodules. J&#38;s differs because it does not copy values across different ver\u00adsions; instead, it generates \ndifferent views on the same object. Proteus [43] .nds proper timing for a given global update with static \nanalysis. Abstract and concrete types in Proteus bear some resemblance to inexact and exact types in \nJ&#38;s: abstractly typed variables allow values of different concrete types, and inexactly typed variables \nmay store objects with different exact views. 8. Conclusions This paper introduces class sharing, a .exible \nextensibility mecha\u00adnism that combines the advantages of bothfamily inheritance and adaptation. As several \nexamples show, class sharing adds new ca\u00adpabilities such asfamily adaptation, dynamic objectevolution, \nand in-place translation. These capabilities are supported by a variety of mechanisms. Dynamic views \ntyped with dependent classes stat\u00adically track the families of values; masked types ensure shared and \nunshared classes can be mixed safely. The language is proved sound, showing that the newextensibility \nprovidedbyclass sharing does not come at a price in type safety. Acknowledgments We thank the many people \nwho have offered helpful suggestions on this work or its presentation, including Steve Chong, Michael \nClarkson,DexterKozen,Wojtek Moczydlowski, Nate Nystrom,K. Vikram, Xin Zheng, and the anonymous reviewers. \nThis research was supported in part by ONR Grant N000140910652,byNSF Grants 0430161, 0541217, and 0627649, \nandby AirForce Research Laboratory under agreement#FA8750\u00ad08-2-0079. The U.S. Government is authorized \nto reproduce and distribute reprints for Government purposes, notwithstanding any copyright annotation \nthereon. The views and conclusions here are those of the authors and do not necessarily re.ect the policies \nor endorsements of AFRL, ONR, the Navy, NSF, or the U.S. Govern\u00adment. References [1] Ivica Aracic,Vaidas \nGasiunas, Mira Mezini, and Klaus Ostermann. Anoverviewof CaesarJ.InAwais Rashidand Mehmet Aksit, editors, \nLectureNotesin Computer Science:Transactionson Aspect-Oriented Software DevelopmentI, pages 135 173. \nSpringer-Verlag, 2006. [2] Miles Barr and Susan Eisenbach. Safe upgrading without restarting. In Proceedings \nof 19th International Conference on Software Maintenance (ICSM), pages 129 137, 2003. [3] Alexandre Bergel, \nSt\u00b4 ephane Ducasse, and Oscar Nierstrasz. Class\u00adbox/J: Controlling the scope of change in Java. In Proc. \n20thACM Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA), pages \n177 189, San Diego, CA, USA, October 2005. [4] Gilad BrachaandWilliam Cook. Mixin-based inheritance.In \nNorman Meyrowitz, editor, Proc. 5thACM Conference on Object-Oriented Programming Systems, Languages and \nApplications (OOPSLA), pages 303 311, Ottawa, Canada, 1990.ACM Press. [5] FrederickP. Brooks. The Mythical \nMan-Month: Essays on Software Engineering. Addison-Wesley, 1978. [6] Kim B. Bruce. Safe static type checking \nwith systems of mutually recursive classes andinheritance.Technical report,Williams College, 1997. http://cs.williams.edu/~kim/ftp/RecJava.ps.gz. \n[7] Kim B. Bruce, Martin Odersky, and Philip Wadler. A statically safe alternative to virtual types. \nIn European Conference on Object-Oriented Programming (ECOOP), pages 523 549, Brussels, Belgium, July \n1998. [8] Eric Bruneton, Romain Lenglet, and Thierry Coupaye. ASM: A code manipulation tool to implement \nadaptable systems, 2002. http://asm.objectweb.org/current/asm-eng.pdf. [9] B. Cahoon and K. S. McKinley. \nData .ow analysis for software prefetching linked data structures in Java. In International Conference \non Parallel Architectures and Compilation Techniques (PACT), September 2001. [10] Dave Clarke, Sophia \nDrossopoulou, James Noble, and Tobias Wrigstad. Tribe: A simple virtual class calculus. In AOSD 07: Proceedings \nof the 6th International Conference on Aspect-Oriented Software Development, pages 121 134, 2007. [11] \nCurtis Clifton, GaryT. Leavens, Craig Chambers, andTodd Millstein. MultiJava: Modular open classes and \nsymmetric multiple dispatch for Java. In Proc. 15th ACM Conference on Object-Oriented Programming Systems, \nLanguages and Applications (OOPSLA), pages 130 145, 2000. [12] Adriana B. Compagnoni and Benjamin C. \nPierce. Higher order intersection types and multiple inheritance. Mathematical Structures in Computer \nScience, 6(5):469 501, 1996. [13] Bruno C. d. S. Oliveira. Modular visitor components:A practical solution \nto theexpressionfamilies problem. In Proceedings of the European Conference on Object-Oriented Programming \n(ECOOP), July 2009. to appear. [14] Ferruccio Damiani, Sophia Drossopoulou, and Paola Giannini. Re.nedeffectsfor \nunanticipatedobject re-classi.cation: FickleIII.In ICTCS, pages 97 110, 2003.  [15] Dominic Duggan. \nType-based hot swapping of running modules. Acta Inf., 41(4):181 220, 2005. [16] Erik Ernst. gbeta A \nLanguage with Virtual Attributes, Block Structure, and Propagating, Dynamic Inheritance. PhD thesis, \nDepartment of Computer Science, University of Aarhus, Arhus, \u00b0Denmark, 1999. [17] Erik Ernst. Family \npolymorphism. In Proceedings of the 15th European Conference on Object-Oriented Programming (ECOOP), \nLNCS 2072, pages 303 326, 2001. [18] Erik Ernst, Klaus Ostermann, and William R. Cook. A virtual class \ncalculus. In Proc.ACM Symp. on Principles of Programming Languages (POPL) 06, pages 270 282, January \n2006. [19] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. DesignPatterns: Elements of \nReusable Object-Oriented Software. AddisonWesley, Reading, MA, 1994. [20] Stephan Herrmann. Object teams: \nImproving modularity for crosscutting collaborations. In Proc. Net Object Days, 2002. [21] Atsushi Igarashi \nand Benjamin Pierce. Foundations for virtual types. In Proceedings of the 13th European Conference on \nObject-Oriented Programming (ECOOP), pages 161 185, June 1999. [22] AtsushiIgarashiand MirkoViroli. Variantpath \ntypesfor scalable extensibility. In Proc. 22ndACM Conference on Object-Oriented Programming Systems, \nLanguages and Applications (OOPSLA), pages 113 132,NewYork,NY, USA, 2007.ACM. [23] David MacQueen. Modules \nfor Standard ML. In Proc. 1984ACM Symposium on Lisp and Functional Programming, pages 198 204, August \n1984. [24] O. Lehrmann Madsen and B. M\u00f8ller-Pedersen. Virtual classes:A powerful mechanism for object-oriented \nprogramming. In Proc. 4th ACM Conference on Object-Oriented Programming Systems, Languages and Applications \n(OOPSLA), pages 397 406, October 1989. [25] O. Lehrmann Madsen, B. M\u00f8ller-Pedersen, and K. Nygaard. Object \nOriented Programming in the BETA Programming Language. Addison-Wesley, June 1993. [26] M. Mezini and \nK. Ostermann. Conquering aspects with Caesar. In Proceedings of the 2nd International Conference on Aspect-Oriented \nSoftware Development (AOSD), pages 90 100, Boston, Massachusetts, March 2003. [27] Mira Mezini, Linda \nSeiter, and Karl Lieberherr. Component integra\u00adtion with pluggable composite adapters. Software Architectures \nand ComponentTechnology, 2000. [28] Nathaniel Nystrom, Stephen Chong, and Andrew C. Myers. Scalable extensibility \nvia nested inheritance. In Proceedings of the 19thACM Conference on Object-Oriented Programming Systems, \nLanguages and Applications (OOPSLA), pages 99 115, October 2004. [29] Nathaniel Nystrom, Michael R. Clarkson, \nand Andrew C. Myers. Polyglot:Anextensible compiler framework forJava. InG\u00a8orel Hedin, editor, Compiler \nConstruction, 12th International Conference, CC 2003, pages 138 152,Warsaw, Poland, April 2003. [30] \nNathaniel Nystrom, Xin Qi, and Andrew C. Myers. J&#38;: Nested intersection for scalable software composition. \nIn Proc. 21stACM Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA), \npages 21 36, October 2006. [31] Nathaniel Nystrom, Xin Qi, and Andrew C. Myers. Nested intersection for \nscalable software composition. Technical report, Computer Science Dept., Cornell University, September \n2006. http://www.cs.cornell.edu/nystrom/papers/jet-tr.pdf. [32] Martin Odersky, Philippe Altherr, Vincent \nCremet, Burak Emir, Sebastian Maneth, St \u00b4 ephane Micheloud, Nikolay Mihaylov, Michel Schinz,Erik Stenman,and \nMatthiasZenger.AnoverviewoftheScala programming language, June 2004. http://scala.epfl.ch/ docu/files/ScalaOverview.pdf. \n[33] Martin Oderskyand Matthias Zenger. Scalable component abstrac\u00ad tions. In Proc. 20thACM Conference \non Object-Oriented Program\u00adming Systems, Languages and Applications (OOPSLA), pages 41 57, San Diego, \nCA, USA, October 2005. [34] Klaus Ostermann. Dynamically composable collaborations with delegation layers. \nIn Proceedings of the 16th European Conference on Object-Oriented Programming (ECOOP),volume 2374 ofLecture \nNotes in Computer Science, pages 89 110, M\u00b4alaga, Spain, 2002. Springer-Verlag. [35] Xin Qi and Andrew \nC. Myers. Masked types for sound object initialization. In Proc.ACM Symp. on Principles of Programming \nLanguages (POPL) 09, pages 53 65, January 2009. [36] Xin Qi and Andrew C. Myers. Sharing classes betweenfamilies. \nTechnical report, Computer and Information Science, Cornell University, March 2009. http://hdl.handle.net/1813/12141. \n[37]Venugopalan Ramasubramanian, Ryan Peterson, and EminG\u00a8un Sirer. Corona:Ahigh performance publish-subscribe \nsystem for the World Wide Web. In Proceedings of Networked System Design and Implementation (NSDI), May \n2006. [38]Venugopalan Ramasubramanian and EminG\u00a8un Sirer. Beehive: O(1) lookup performance for power-law \nquery distributions in peer-to-peer overlays. In USENIX Symposium on Networked Systems Design and Implementation \n(NSDI), March 2004. [39] John C. Reynolds. Design of the programming language Forsythe. Technical Report \nCMU-CS-96-146, Carnegie Mellon University, June 1996. [40] AntonyRowstron and Peter Druschel. Pastry: \nScalable, distributed object location and routing for large-scale peer-to-peer systems. In IFIP/ACM International \nConference on Distributed Systems Platforms (Middleware), pages 329 350, November 2001. [41] Yannis Smaragdakis \nand Don Batory. Mixin layers: An object\u00adoriented implementation technique for re.nements and collaboration\u00adbased \ndesigns. ACM Transactions on Software Engineering and Methodology, 11(2):215 255, April 2002. [42] Charles \nSmith and Sophia Drossopoulou. Chai:Traits for Java-like languages. In Proceedings of the 19th European \nConference on Object-Oriented Programming (ECOOP), pages 453 478, 2005. [43] Gareth Stoyle, Michael Hicks, \nGavin Bierman, Peter Sewell, and Iulian Neamtiu. Mutatis mutandis: safe and predictable dynamic software \nupdating. In Proc. ACM Symp. on Principles of Programming Languages (POPL) 05, pages 183 194, 2005. [44] \nBjarne Stroustrup. The C++ Programming Language. Addison-Wesley, 1987. [45] Sun Microsystems. Java LanguageSpeci.cation,version \n1.0 beta edi\u00adtion, October 1995.Availableat ftp://ftp.javasoft.com/docs/ javaspec.ps.zip. [46] Tim Sweeney. \nThe next mainstream programming language: a game developer s perspective. In Proc.ACM Symp. on Principles \nof Programming Languages (POPL) 06, page 269, January 2006. [47] Kresten Krab Thorup. Genericity in Java \nwith virtual types. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP), \nnumber 1241 in Lecture Notes in Computer Science, pages 444 471. Springer-Verlag, 1997. [48] MadsTorgersen.Virtual \ntypes are statically safe. In 5thWorkshop on Foundations of Object-Oriented Languages (FOOL), January \n1998. [49] PhilipWadler. Views:Awayfor pattern matchingto cohabit with data abstraction. In Proc.ACM \nSymp. on PrinciplesofProgramming Languages (POPL) 87, pages 307 312, January 1987. [50] AlessandroWarth, \nMilan Stanojevi\u00b4c, andTodd Millstein. Statically scoped object adaptation with expanders. In Proc. 21st \nACM Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA), Portland, \nOR, October 2006. [51] Andrew K. Wright and Matthias Felleisen. Asyntactic approach to type soundness. \nInformation and Computation, 115(1):38 94, 1994.    \n\t\t\t", "proc_id": "1542476", "abstract": "<p>Class sharing is a new language mechanism for building extensible software systems. Recent work has separately explored two different kinds of extensibility: first, family inheritance, in which an entire family of related classes can be inherited, and second, adaptation, in which existing objects are extended in place with new behavior and state. Class sharing integrates these two kinds of extensibility mechanisms. With little programmer effort, objects of one family can be used as members of another, while preserving relationships among objects. Therefore, a family of classes can be adapted in place with new functionality spanning multiple classes. Object graphs can evolve from one family to another, adding or removing functionality even at run time.</p> <p>Several new mechanisms support this flexibility while ensuring type safety. Class sharing has been implemented as an extension to Java, and its utility for evolving and extending software is demonstrated with realistic systems.</p>", "authors": [{"name": "Xin Qi", "author_profile_id": "81322503996", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P1464297", "email_address": "", "orcid_id": ""}, {"name": "Andrew C. Myers", "author_profile_id": "81100011022", "affiliation": "Cornell University, Ithaca, NY, USA", "person_id": "P1464298", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542508", "year": "2009", "article_id": "1542508", "conference": "PLDI", "title": "Sharing classes between families", "url": "http://dl.acm.org/citation.cfm?id=1542508"}