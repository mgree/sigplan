{"article_publication_date": "06-15-2009", "fulltext": "\n Laminar: Practical Fine-Grained Decentralized Information Flow Control Indrajit Roy Donald E. Porter \nMichael D. Bond Kathryn S. McKinley Emmett Witchel Department of Computer Sciences The University of \nTexas at Austin {indrajit, porterde, mikebond, mckinley, witchel}@cs.utexas.edu Abstract Decentralized \ninformation .ow control (DIFC) is a promising model for writing programs with powerful, end-to-end security \nguarantees. Current DIFC systems that run on commodity hard\u00adware can be broadly categorized into two \ntypes: language-level and operating system-level DIFC. Language level solutions provide no guarantees \nagainst security violations on system resources, like .les and sockets. Operating system solutions can \nmediate accesses to system resources, but are inef.cient at monitoring the .ow of information through \n.ne-grained program data structures. This paper describes Laminar, the .rst system to implement de\u00adcentralized \ninformation .ow control using a single set of abstrac\u00adtions for OS resources and heap-allocated objects. \nProgrammers express security policies by labeling data with secrecy and integrity labels, and then access \nthe labeled data in lexically scoped secu\u00adrity regions. Laminar enforces the security policies speci.ed \nby the labels at runtime. Laminar is implemented using a modi.ed Java virtual machine and a new Linux \nsecurity module. This paper shows that security regions ease incremental deployment and limit dynamic \nsecurity checks, allowing us to retro.t DIFC policies on four application case studies. Replacing the \napplications ad-hoc security policies changes less than 10% of the code, and incurs per\u00adformance overheads \nfrom 1% to 56%. Whereas prior DIFC sys\u00adtems only support limited types of multithreaded programs, Lami\u00adnar \nsupports a more general class of multithreaded DIFC programs that can access heterogeneously labeled \ndata. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation; \nD.3.3 [Programming Lan\u00adguages]: Language Constructs and Features; D.4.6 [Operating Systems]: Security \nand Protection Information .ow controls General Terms Languages, Performance , Security Keywords Information \n.ow control, Java virtual machine, oper\u00adating systems, security region 1. Introduction As computer systems \nsupport more aspects of modern life, from .\u00adnance to health care, security becomes increasingly important. \nCur\u00adrent security policies and enforcement mechanisms are typically sprinkled throughout an application, \nmaking security policies dif\u00ad.cult to express, change, and audit. Operating system security ab\u00adstractions, \nsuch as .le permissions and user IDs, are too coarse to express many desirable policies, such as protecting \na user s .nan\u00adcial data from an untrusted browser plug-in. Furthermore, poor in\u00adtegration of programming \nlanguage (PL) constructs and operating Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 09, June 15 20, 2009, Dublin, Ireland. Copyright c . 2009 ACM 978-1-60558-392-1/09/06. \n. . $5.00 system (OS) security mechanisms complicates the expression and enforcement of security policies. \nFor example, a user s credit card number should not be broadcast on the network, whether the num\u00adber \noriginates in a .le or a data structure. Files and data structures are currently governed by completely \ndistinct security mechanisms, requiring developers to understand both mechanisms. This paper addresses \nthese issues by integrating PL and OS security abstrac\u00adtions, allowing application developers to express \nuniform security policies that are enforced at all layers of the software stack. The decentralized information \n.ow control (DIFC) security model [18] expresses policies based on how applications use data and more \nnaturally matches how developers and users think of se\u00adcurity policies than traditional security mechanisms. \nFor instance, traditional access control mechanisms are all-or-nothing; once an application has the right \nto read a .le, it can do anything with that .le s data. In contrast, DIFC enforces more powerful policies, \nsuch as permitting an application to read a .le, but disallowing the broadcast of the contents of that \n.le over an unsecured net\u00adwork channel. A DIFC implementation dynamically or statically enforces end-to-end \nuser speci.ed security policies by tracking information .ow throughout the system. The DIFC model provides \nsecurity by allowing users to asso\u00adciate secrecy and integrity labels with data and restricting the .ow \nof information according to these labels. Secrecy guarantees pre\u00advent sensitive information from escaping \nthe system, and integrity guarantees prevent external information from corrupting the sys\u00adtem. As an \nexample of the DIFC model, consider Alice and Bob who want to schedule a meeting while keeping their \ncalendars mostly secret. Alice and Bob each place a secrecy label on their calendar .le, and then only \na thread with those secrecy labels can read it. Once a thread has a secrecy label, it has been tainted \nby that label, and can no longer write to an unlabeled output, such as standard output or the network. \nIf the thread has the capability to declassify the information, it may remove the secrecy label and then \nwrite the data to an unlabeled output. In the calendar example, the program obtains both Alice and Bob \ns secrecy label to read both calendar .les, but then it cannot remove the labels. When the thread is \nready to output an acceptable meeting time, it must call a function that then declassi.es the result. \nThe declassi.cation function checks that its output contains no secret information. For example, the \noutput is simply a date and does not include Bob s upcoming visit to the doctor. DIFC provides two key \nadvantages clear rules for the legal propagation of data through a program, and the ability to localize \nsecurity policy decisions. In the calendar example, the secrecy la\u00adbels ensure that any program that \ncan read the data cannot leak the data, whether accidentally or intentionally. The label is tied to the \ndata, and it restricts who may access the data. The decision to de\u00adclassify is localized to a small piece \nof code that can be closely audited. The result is a system where security policies are easier to express, \nmaintain, and modify. DIFC can be supported at the language level [18, 19], in the operating system [12, \n26, 28], or in the architecture [25, 29]. Each approach has strengths and limita\u00adtions. Language-based \nDIFC systems rely on extensive type sys\u00adtem changes, wrap standard libraries, augment types throughout \nthe entire program, and modify the program structure. OS-based DIFC systems have trouble enforcing data \n.ow through program data structures because page mappings are an inef.cient mecha\u00adnism to control permissions \nfor most user-de.ned data structures. Architecture-based solutions track labels on data and CPUs in hard\u00adware \nand signal violations, but still require trusted software to man\u00adage the labels. We limit the scope of \nthis paper to DIFC implemen\u00adtations on commodity hardware. This paper introduces a new DIFC system, Laminar, \nthat pro\u00advides a common security abstraction and labeling scheme for pro\u00adgram objects and OS resources, \nsuch as .les and sockets. By com\u00adbining the strengths of PL and OS techniques, while minimizing their \nlimitations, developers express comprehensive security poli\u00adcies and then the Laminar virtual machine \n(VM) and OS enforce these policies. Laminar can be incrementally deployed developers need only modify \nthe security-sensitive portion of their programs. Trusted and untrusted threads, labeled and unlabeled \n.les, sockets, data structures, and so on, coexist in the system. In contrast, existing DIFC languages \nrequire pervasive program modi.cations to label data structures, variables, functions, and return types \n[17, 23]. Be\u00adcause they rely on whole-program static analysis for enforcement of DIFC rules, they also \nexclude features such as dynamic class loading and multithreading. Laminar introduces lexically scoped \nsecurity regions. Security regions limit the scope of non-trivial DIFC enforcement, which makes it easier \nto develop, deploy, and audit DIFC programs. Secu\u00adrity regions also reduce the overhead of dynamic security \nchecks. All operations on labeled data must occur within security regions. A typical security region \nmight read a labeled con.guration .le and parse it into a labeled data structure. Since all code that \nmanip\u00adulates the labeled con.guration data structures resides in a security region, it is easier to identify \nand audit. Code unrelated to the data structure needs no modi.cation. The contributions of this paper \nare: 1. The design of Laminar, the .rst system with uni.ed PL and OS mechanisms for enforcing DIFC. Laminar \nfeatures a novel di\u00advision of responsibilities among the programming model, VM, and OS. 2. The introduction \nof security regions, an intuitive primitive that eases deployment, security programming, implementation, \nand auditing. 3. An implementation of Laminar that makes modest additions to Jikes RVM [1] (a Java virtual \nmachine), and the Linux operating system. 4. Four case studies that retro.t security policies onto existing \ncode. These case studies require modi.cation of less than 10% of the total code base and incur overheads \nfrom Laminar rang\u00ading from 1% to 56%.  These advantages and initial results suggest that integrating \nPL and OS support incurs low overheads and allows the application developer to write .ne-grained security \npolicies that encompass program data structures as well as system resources.  2. Related work Previous \nDIFC systems have either used only PL abstractions or OS abstractions. Laminar instead enforces DIFC \nrules for Java programs using an extended JVM and OS. By unifying PL and OS abstractions for the .rst \ntime with a seamless labeling model, Laminar combines the strengths of previous approaches and further \nimproves the DIFC programming model. From IFC to DIFC. Information .ow control (IFC) stemmed from research \nin multi-level security for defense projects [9]. In the original military IFC systems [11], an administrator \nmust allocate all labels and approve all declassi.cation requests. Modern manda\u00adtory access control (MAC) \nsystems, like security-enhanced Linux (SELinux), also limit declassi.cation and require a static collec\u00adtion \nof labels and principals. Decentralized information .ow con\u00adtrol (DIFC) systems allow individual applications \nto allocate labels and declassify data for their labels, providing a richer model for implementing security \npolicies [18]. Language-based DIFC. Language-based DIFC systems [17,19, 23] augment the type system to \ninclude secrecy and integrity con\u00adstraints enforced by the bytecode generator. These systems label program \ndata structures and objects at a .ne granularity, but require programming an intrusive type system or \nan entirely new language. These language based systems trust the whole operating system and provide no \nguarantees against security violations on system resources, like .les and sockets. OS-based IFC. Asbestos \n[26] and HiStar [28] are new operating systems that provide DIFC properties. Flume [12] is a user-level \nreference monitor that provides DIFC guarantees without making extensive changes to the underlying operating \nsystem. OS DIFC systems provide little or no support for tracking in\u00adformation .ow through application \ndata structures with different labels. Flume tracks information .ow at the granularity of an entire address \nspace. HiStar can enforce information .ow at page gran\u00adularity and supports a form of multithreading \nby requiring each thread to have a page mapping compatible with its label. Using page table protections \nto track information .ow is expensive, both in execution time and space fragmentation, and complicates \nthe programming model by tightly coupling memory management with DIFC enforcement. Laminar supports a \nricher, more natural pro\u00adgramming model in which threads may have heterogeneous labels and access a variety \nof labeled data structures. For example, all of our application case studies use threads with different \nlabels. Laminar provides DIFC guarantees at the granularity of lexi\u00adcally scoped code blocks and data \nstructures with modest changes to the VM. It also adds a security module to a standard operat\u00ading system, \nas opposed to Asbestos and HiStar, which completely rewrite the OS. Most of Laminar s OS DIFC enforcement \noccurs in a security module whose architecture is already present within Linux (Linux security modules \n[27] (LSM)). The Laminar OS does not need Flume s endpoint abstraction to enforce security during operations \non .le descriptors (e.g., writes to a .le or pipe), as the kernel-level reference monitor can check the \ninformation .ow for each operation on a .le descriptor. Laminar adopts the label structure and the label/capability \ndis\u00adtinction derived from JIF and used by Flume. Capabilities in DIFC systems are formally de.ned in \nthe next section. They are distinct from the capabilities used in capability-based operating systems. \nCapability-based operating systems, like EROS [22], use point\u00aders with access control information to \ncombine system and lan\u00adguage mechanisms for stronger security. However, capability sys\u00adtems cannot enforce \nDIFC rules, and programs must be completely rewritten to work with the capability programing model. Table \n1 summarizes the taxonomy of design issues common to DIFC systems. Laminar combines the strengths of \nPL-and OS\u00adbased systems. Laminar handles implicit .ows and provides .ne\u00adgrained information .ow control \njust like PL systems but without resorting to whole-program static analysis. Like OS-based systems, Laminar \ncan enforce security policies on system resources. Lami\u00adnar makes it easier to deploy and use information \n.ow control sys\u00adtems by introducing the intuitive notion of lexically scoped code blocks called security \nregions. Integrating language and OS-based security. Hicks et al. ob\u00adserve that security-typed languages \ncan be used to ensure that OS security policies are not violated by trusted system applications, Issue \nPL solution [19, 23] OS solution [12, 26, 28] Laminar solution Main subsystems modi.ed Compiler and type \nsystem (1) Complete OS [26, 28] (2) User-level refer\u00adence monitor and kernel module [12] VM and kernel \nmodule Trusted computing base Compiler, VM, and OS OS VM and OS Securing individual appli\u00adcation data \nstructures Whole-program static analysis Either not supported or inef.cient because of page table mechanisms \nDynamic analysis and VM enforce\u00adment using read/write barriers Securing .les and OS re\u00adsources Not handled \n(1) Modify entire OS or (2) User-level reference monitor with kernel module support Kernel module Termination, \ntiming, prob\u00adabilistic channels Not handled HiStar [28] and Flume [12] handle termination channels by \nsuppressing termination noti.ca\u00adtion Not handled Implicit information .ow Static analysis Not applicable \ninformation .ow tracked at granularity of thread [28] or address space [12] Dynamic analysis using lexically \nscoped security regions Deployment issues Code must use new language or type system Excludes multithreaded \napplications whose threads have heterogeneous security needs Incrementally deployable Table 1. Issues \nfor DIFC systems. Laminar offers better functionality than the combination of PL and OS solutions. such \nas logrotate [10]. Their framework, called SIESTA, ex\u00adtends Jif to enforce SELinux [15] MAC policies \nat the language level. The aims of Laminar and SIESTA are orthogonal. SIESTA provides developers with \na mechanism to prove to the system that an application is trustworthy, whereas Laminar provides the devel\u00adoper \na uni.ed abstraction for specifying application security poli\u00adcies. Termination, timing and probabilistic \nchannels. Vachharajani et al. argue that implementing DIFC with dynamic checking is as correct as static \nchecking by showing that the program termina\u00adtion channels of static and dynamic DIFC systems leak an \narbitrary number of bits [25]. They prove that a correct dynamic DIFC sys\u00adtem will over-approximate information \n.ow, rejecting some pro\u00adgrams that do not contain actual information .ow violations. Lam\u00adinar is a dynamic \nDIFC system and its security regions explicitly over-approximate information .ow. DIFC systems attempt \nto eliminate covert channels, which may be used to leak information, but do not eliminate timing chan\u00adnels \n[13] or probabilistic channels [21]. Section 4.3.3 de.nes and discusses implicit information .ows.  \n3. DIFC model All DIFC systems need a mechanism to denote the sensitivity of information and the privileges \nof the participating users. This section describes the mechanisms used by Laminar and the DIFC rules \nthat determine safe information .ows. In DIFC systems, the security policy is de.ned in terms of principals \nthat read and write the data in the system. Examples of principals in DIFC systems are users [19], processes \n[12] and kernel threads [28]. Principals in Laminar are kernel threads. 3.1 DIFC abstractions Standard \nDIFC abstractions include tags, labels, and capabilities. Tags are short, arbitrary tokens drawn from \na large universe of possible values (T ) [12]. A tag has no inherent meaning. A set of tags is called \na label. In a DIFC system, any principal can create a new tag for se\u00adcrecy or integrity. For example, \na web application might create one secrecy tag for its user database and a separate secrecy tag for each \nuser s data. The secrecy tag on the user database will prevent au\u00adthentication information from leaking \nto the network. The tags on user data will prevent a malicious user from writing another user s secret \ndata to an untrusted network connection. Principals assign labels to data objects. Data objects include \nprogram data structures (e.g., individual objects, arrays, lists, hash tables) and system resources (e.g., \n.les and sockets). Previous OS\u00adbased systems limit principals to the granularity of a process or support \nthreads by enforcing DIFC rules at the granularity of a page. Our system is the .rst to expand principals \nto support threads as principals and enforce DIFC at object granularity. Each data object or principal \nx has two labels, Sx for secrecy and Ix for integrity. A tag t in the secrecy label Sx of a data object \ndenotes that it may contain information private to principals with tag t. Similarly, a tag t in Ix implies \nthat a data object may contain data endorsed by principals with integrity tag t. Data integrity is a \nguarantee that data exists in the same state as when it was endorsed by a principal. For example, if \nMicrosoft endorses a data .le, and the integrity of the .le is preserved, then a user can choose to trust \nthe .le s contents if she trusts Microsoft. A principal s labels restrict the interaction that the principal \ncan have with other principals and data objects. A partial ordering of labels imposed by the subset relation \nforms a lattice [7]. At the bottom of the lattice are unlabeled resources, which have the empty label \nfor security and integrity. An implicit empty label means that the program need not label every data \nstructure, nor does the OS need to label every .le in the .le system. Allowing implicit empty labels \nmakes Laminar easier to deploy incrementally. A principal may change the label of a data object or principal \nif and only if it has the appropriate capabilities, which generalize ownership of tags [18]. A principal \np has a capability set, Cp, that de.nes whether it has the privilege to add or remove a tag. For each \ntag t, let t+ and t- denote the capability to add and remove the tag t. The capability t+ allows a principal \nto classify data with secrecy tag t, while the t- capability allows it to declassify data. Classi.cation \nraises data to a higher secrecy level; declassi.cation lowers its secrecy level. Principals can add t \nto their secrecy label if they have the t+ capability. If the principal adds t, then we call it tainted \nwith the tag t. A principal taints itself when it wants to read secret data. To communicate with unlabeled \ndevices and .les, a tainted principal must use the t- capability to untaint itself and to declassify \nthe data it wants to write. Note that DIFC capabilities are not pointers with access control information, \nwhich is how they are commonly de.ned in capability-based operating systems [14, 22]. DIFC handles integrity \nsimilarly to secrecy. The t+ capability allows a principal to endorse data with integrity tag t, and \nthe t- capability allows it to drop the endorsement. A principal with integrity tag t is claiming to \nrepresent a certain level of integrity. For example, code and data signed by a software vendor could \nrun with that vendor s integrity tag. When the principal drops an integrity tag, for example, to read \nan unlabeled .le of lower integrity, the principal drops the endorsement of the tag. Note that the capability \nset Cp is de.ned on tags. A tag can be assigned to a secrecy or integrity label. In practice, a tag is \nrarely used for both purposes. Cp - is the set of tags which principal p may declassify (drop endorsements), \nand Cp + is the set of tags that p may classify (endorse). Principals and data objects have both a secrecy \nand integrity label; a data object with secrecy label s and integrity label i is written: {S(s),I(i)}. \nAn empty label set is written: {S(),I()}. The capability set of a principal that can add both s and i \nbut can drop only i is written: {C(s +,i+,i-)}. 3.2 Restricting information .ow Programs implement policies \nto control access and propagation of data by using labels to limit the interaction among principals and \ndata objects. Information .ow is de.ned in terms of data moving from a source x to a destination y, at \nleast one of which is a principal. For example, principal x writing to .le y or sending a message to \nprincipal y is an information .ow from x to y. If principal x reads from a .le y, then we say information \n.ows from source y to destination x. Laminar enforces the following information .ow rules for x to y: \nSecrecy rule. Bell and LaPadula [2] introduced the simple secu\u00adrity property and the *-property for secrecy. \nThese properties en\u00adforce that no principal may read data at a higher level (no read up) or write data \nto a lower level (no writedown). Expressed formally, information .ow from x to y preserves secrecy if: \nSx . Sy Note that x or y may make a .ow feasible by using their capabilities to explicitly drop or add \na label. For example, x may make a .ow feasible by removing a label L from Sx if it has the declassi.cation \ncapability for L, i.e. L . Cx -. Similarly, y may use its capabilities in Cy + to extend its secrecy \nlabel and receive information. Integrity rule. The integrity rule constrains who can alter infor\u00admation \n[3] and restricts reads from lower integrity (no read down) and writes to higher integrity (no write \nup). In our system, we en\u00adforce the following rule: Iy . Ix Intuitively, the integrity label of x should \nbe at least as strong as destination y. Just like the secrecy rule, x may make a .ow feasi\u00adble by endorsing \ninformation sent to a higher integrity destination, which is allowed if x has the appropriate capability \nin Cx +. Simi\u00adlarly, y may need to reduce its integrity level, using Cy -, to receive information from \na lower integrity source. Label changes. According to the previous two rules, a principal can enable \ninformation .ow by using its current capabilities to drop or add a label. Laminar requires that the principal \nmust explicitly change its current labels. Zeldovich et al. show that automatic, or implicit, label changes \ncan form a covert storage channel [28]. In Laminar, a principal p may change its label from L1 to L2 \nif it has the capability to add tags present in L2 but not in L1, and can drop the tags that are in L1 \nbut not in L2 . Formally, this is stated as: (L2 - L1) . Cp + and (L1 - L2 ) . Cp - 3.3 Calendar example \nAgain consider scheduling a meeting between Bob and Alice using a scheduling server that is not administered \nby either Alice or Bob. Alice s calendar .le has a secrecy tag, a, and Bob s calendar .le has a secrecy \ntag, b. Ensuring secrecy. Focusing on Alice, she gives a + to the scheduling server to let it read her \nsecret calendar .le, which has label {S(a)}. A thread in the server uses the a + capability to start \na security region with secrecy tag a that reads Alice s calendar .le. Once the server s thread has the \nlabel {S(a)}, it can no longer return to the empty label because it lacks the declassi.cation capa\u00adbility, \na - . As a result, the server thread can read Alice s secret .le, User Kernel LSM  Label Figure 1. \nDesign of Laminar. Unlabeled objects have an implicit empty label. Trusted components are shaded. but \nit can never write to an unlabeled device like the disk, network, or display. If the server thread creates \na new .le, it must have label {S(a)}, which is unreadable to its other threads. Before the server thread \ncan communicate information derived from Alice s secret .le to another thread, the other thread must \nadd the a tag, and also becomes unable to write to unlabeled channels. Ensuring integrity. The scheduling \nserver runs its plugins with an integrity tag, i, corresponding to the idea of having an au\u00adthority vouch \nfor the safety and correctness of plugins, just as addons.mozilla.org vouches for plugins by allowing \na se\u00adcure network connection. The server cannot execute or read a plu\u00adgin that has an integrity label \nlower than {I(i)}. The server is as\u00adsured that plugins and their input .les have not been written by \nany principal with an integrity label lower than {I(i)}. The DIFC in\u00adtegrity rule gives the server con.dence \nthat its code and data .les have not been tampered with. Sharing secrets with trusted partners. Alice \nand Bob collabo\u00adrate to schedule a meeting while both retaining .ne-grained con\u00adtrol over what information \nis exposed. Both send the server a code module in a .le that has integrity label {I(i)}. For example, \nthey might have access to such an integrity label because they are both employed by the company running \nthe scheduling server. Alice s module has access to both her a + and a - capabilities, so the server \ncalls her code which reads her secret calendar .le and selectively declassi.es parts of it, for instance, \nmaking her availability between 10:00am and 1:30pm on Mondays and Tuesdays publicly available (unlabeled). \nAlice controls which of her data .ows into the sched\u00aduler. Bob does the same, and the scheduler can communicate \nwith both of them their possible meeting times. Discussion. In this example, Alice speci.es a declassi.er \nas a small code module that can be loaded into a larger server applica\u00adtion, which can be completely \nignorant of DIFC and requires no modi.cations to work with Alice s DIFC-aware module. For pre\u00advious DIFC \nsystems, this example would be more cumbersome. OS-based DIFC systems would require the declassi.er to \nrun as a separate process. Language-based systems would require the entire application to be annotated \nfor DIFC enforcement. By integrating OS and language techniques, Laminar substantially improves the state \nof the art in DIFC.  4. Design This section describes how Laminar enforces DIFC in an enhanced VM and \nOS. Figure 1 illustrates the Laminar architecture. The VM enforces DIFC rules within the application \ns address space. The OS security module mediates accesses to system resources. Only the VM and the OS \nare trusted in our model. For example, Alice may write a program in Java using the Laminar API to label \nher data. Alice s program uses the same label namespace present in the .le system: it can read data from \na labeled .le into a data structure with the same label. She compiles the code using a standard, untrusted, \nbytecode generator such as javac. The Laminar just-in-time (JIT) compiler and VM execute the bytecode, \nand the Laminar OS executes the Laminar VM. Laminar ensures that any accesses or modi.cations to labeled \ndata follow the DIFC rules and occur in a security region, a lexically scoped region speci.ed by the \nprogram. Security regions make it easier to secure and audit only the portions of a program that need \nit, making it easier to deploy Laminar incrementally. They also decrease the cost of dynamic security \nchecks by the Laminar runtime. 4.1 Enforcement mechanism The Laminar OS extends a standard operating \nsystem with a Lami\u00adnar security module for information .ow control. The Laminar OS security module governs \ninformation .ows through all standard OS interfaces, including through devices, .les, pipes and sockets. \nThe OS regulates communication between threads of the same or differ\u00adent processes that access the labeled \nor unlabeled system resources or that use OS inter-process communication mechanisms, such as signals. \nOS enforcement applies to all applications, preventing un\u00adlabeled or non-Laminar applications from circumventing \nthe DIFC restrictions. The Laminar VM regulates information .ow between heap ob\u00adjects and between threads \nof the same process via these objects. These .ows are regulated by inserting dynamic DIFC checks in the \napplication code. Because the Laminar VM regulates these .ows within the address space, the OS allows \ndata structures and threads to have heterogeneous labels. All threads in multithreaded pro\u00adcesses without \na trusted VM must have the same labels and ca\u00adpabilities. 4.2 Programming model Laminar provides language \nextensions, a new security library, and new security-related system calls. The secure keyword is used \nto lexically scope a security region. Figure 2 depicts the library API, which includes tag creation, \ndeclassi.cation, and label queries. The Laminar OS exports security system calls to the trusted VM for \ncapability and label management, as shown in Figure 3. An untrusted application may directly use these \nsystem calls to manage its capabilities and labels. Threads are the only principals in Laminar, but the \nthread s la\u00adbels and capabilities are modi.ed when entering and exiting secu\u00adrity regions. In Laminar, \nlabeled data objects (.les, heap allocated objects etc.) can be accessed only inside security regions. \nHence, outside a security region threads always have empty labels. The VM and the OS do not allow code \noutside the security region to ac\u00adcess labeled data objects. During the execution of a security region, \nthe VM gives the thread the labels and capabilities of the secu\u00adrity region so that the OS can mediate \naccess to system resources according to the security region s labels. Security regions are not visible \nto the OS, so the thread itself must have the labels and ca\u00adpabilities. At the end of the security region, \nthe VM restores the thread s original capabilities and labels. 4.3 Security regions A security region \nis a lexically scoped code block that has parame\u00adters for a capability set, a secrecy label, and an integrity \nlabel. The labels dictate which data the program may touch inside the secu\u00adrity region. The capabilities \ndictate how a thread within a security Laminar Application Library API. Label getCurrentLabel(LabelType \nt) Return the current secrecy or integrity label of the security region. Tag createAndAddCapability() \n Create a new tag and add both capabilities to the current principal. void removeCapability(CapType c, \nTag name, boolean global) Drop the given capability from the current principal. Setting the global .ag \ndrops a capability permanently, whereas not setting it drops the capability for the scope of a security \nregion. Object copyAndLabel(Object o, Label l) Return a copy of the object o with new label l. Figure \n2. Laminar library API. LabelType denotes the secrecy or in\u00adtegrity label. CapType denotes the plus, \nminus or both capabilities for a given tag. The API also has wrapper functions(not shown) for the new \nsys\u00adtem calls introduced in Laminar OS. Laminar System Calls. tag t alloc tag(capList t &#38;caps) \nReturn a new tag, add the plus and minus capabilities to the calling principal, and write the new capabilities \ninto caps. int set task label(tag t l, int op, int type) Set the type (secrecy or integrity) label of \nthe current principal. int drop label tcb(pid t tid) Drop the current temporary labels of the thread \nwithout capability checks. Can be called only by threads with the special integrity tag. int drop capabilities(capList \nt *caps, int tmp) Drop the given capabilities from the current principal. Tmp is a .ag used to suspend \na capability for a security region or during a fork(). int write capability(capability t cap, int fd) \n Send a capability to another thread via a pipe. int create file labeled(char* name, mode t m, struct \nlabel *l) Create a labeled .le with the given labels. int mkdir labeled(char* name, mode t m, struct \nlabel *l) Create a labeled directory with the given labels. Figure 3. Laminar system calls. The tag \nt and capability t types represent a single tag or capability, respectively. The struct label type represents \na set of tags that compose a label, and the capList t type is a list of capabilities. region may add \nor remove labels. When we say a security region performs an action, we mean a kernel thread executing \nwithin the region performs the action. Only code within a security region can access labeled data. Se\u00adcurity \nregions demarcate the code regions that are security sensi\u00adtive, easing the programmer s burden when \nadding security policies to existing programs. The programmer is just required to wrap the pieces of \ncode that touch labeled data in a security region, such as a routine that reads a sensitive .le into \na data structure. Usually only a small portion of code and data in a program is security sensitive, so \nsecurity regions also simplify the task of auditing security-sensitive code. Requiring threads to access \nlabeled data within security regions limits the amount of work the VM and compiler must do to enforce \nDIFC, provided that a substantial portion of the execution time is spent operating on unlabeled data. \nEvery time the program reads or writes labeled objects or OS resources within a security region, the \nsystem must check the information .ow with respect to the current labels of the thread executing within \nthe region. For example, an assignment w = r inside a security region R is safe if and only if the information \n.ow from r to the thread inside R and from the thread to w is legal. Note that the Laminar library API \n(Figure 2) does not include a routine for adding labels to a thread. In order to add labels, a thread \nmust start a security region. Security regions provide several bene.ts. They make it easier for programmers \nto add security policies to existing programs. They also make it easier for programmers to audit security \ncode, and limit the effects of implicit information .ows (Section 4.3.3). Finally, they make the DIFC \nimplementation more ef.cient by reducing the amount of code that requires full DIFC checks.  4.3.1 Example \nFigure 4 depicts code where the calendar server reads a .le belong\u00ading to Alice, adds an event to the \ncommon calendar, and exports the common meeting schedule for Bob. As shown, the data structure cal has \nthe secrecy tags a and b. The thread entering the security region is initialized with the secrecy label \nS(a, b) and therefore it can read secret data guarded by these tags. Its integrity label i re\u00adstricts \nit from reading data that is not tagged with i. The thread has the capability C(a -) to declassify tag \na. The line L1 is a valid in\u00adformation .ow because the label of the thread executing at L1 is {S(a, b), \nI(i)}, which is more restrictive than f . (We adhere to the convention that a is the label of a). At \nline L2, the VM checks that the write to calendar c is legal. The write is legal because cal has the \nsame secrecy label as the thread in the security region at that point. At line L3, the common meeting \ntime is computed and stored in s2. Note that s2 has the same labels as the security region. At line L4, \na nested security region is started to declassify data. The copying and relabeling of s2, at L5, is legal \nbecause the thread has the a - capability. Notice that if line L5 were copyAndLabel(s2, S(), I(i)), it \nwould result in a VM exception because the thread does not have the b- capability. In this example, the \nOS checks the .le operations in line L1 and the VM checks the operations in line L2 L5. 4.3.2 Security \nregion initialization Laminar enforces certain rules when a thread enters a security region. Let SR, \nIR, and CR be the security, integrity, and capability sets of a security region, R. Similarly, let SP \n, IP , and CP be the sets associated with a kernel thread P , that enters and then leaves R. Laminar \nsupports arbitrary nesting of security regions. P could, therefore, already be inside a security region \nwhen it enters R. When the thread enters the security region, the following rules hold: SR . (Cp + . \nSP ) and IR . (Cp + . Ip) (1) CR . CP (2) The .rst rule states that the creating principal P must have \neither the add capability or the label itself for any tag it will have within a security region.The second \nrule states that the principal P can only retain a subset of its current capabilities when it enters \na security region. The above rules encapsulate the common sense understanding that a parent principal, \nP , has control over the labels and capabil\u00adities it passes to a security region, and that the system \nwill not let the principal create a security region with security properties that the principal itself \nlacks. The rules also state that security regions nest in the natural way based on the labels and capabilities \nof the thread entering the nested region. 4.3.3 Implicit information .ows A major bene.t of security \nregions is that they limit the amount of analysis necessary to restrict implicit information .ows. Im\u00adplicit \ninformation .ow leaks secret data through control .ow de\u00adcisions [8]. For example, the code in Figure \n5 shows an implicit .ow from the control variable H to the data variable L. By looking at the value of \nL, a thread can deduce the value of H. Since L is low secrecy and H is high secrecy, this implicit .ow \nis a violation of DIFC rules. The system must therefore detect and prohibit this .ow. Calendar cal; // \nhas labels {S(a,b), I(i)} Output ret; // has labels {S(b), I(i)} File f; // has labels {S(a), I(i)} secure \n({S(a,b), I(i), C(a-)}) { [L1] Schedule s1 = getScheduleFromFile(f); [L2] caladdSchedule(s1); [L3] \nSchedule s2 = cal.getCommonSchedule(); [L4] secure({S(b), I(i), C(a-)}){ [L5] ret.val = Laminar.copyAndLabel(s2, \nS(b), I(i)); [L6] } ... Figure 4. Example pseudocode to read and update a calendar. The thread + (not \nshown) has the required capabilities a,a-,b+ and i+ to initialize the security region. // H has labels \n{S(h), I()} // L has labels {S(), I()} // Invariant: y == 2x L = false; secure ({S(h), I(), C()}) { \nx++; if (H) L = true; y = 2 * x; ... } catch (...) { y = 2 * x; } Figure 5. Pseudocode that shows how \nimplicit .ows are handled with secure/catch. // H has labels {S(h), I()} // L has labels {S(), I()} L \n= false; secure ({S(h), I(), C()}) { if (H) while (true) {} } catch (...) {} Figure 6. Pseudocode that \nleaks data via a termination channel. Laminar has a special construct to limit implicit .ows each se\u00adcurity \nregion has a required catch block as shown in Figure 5. The catch block executes with the same labels \nas the security region, and the capability set at the time of the exception. For instance, if H is true \nand the program attempts assignment to L, then Lami\u00adnar raises an exception because the security region \ndoes not have the right to declassify H. The catch block gives the programmer a chance to restore program \ninvariants before exiting the security region. No .ow occurs between H and L because L is never as\u00adsigned, \nregardless of whether H is true or false, and control .ow continues after the secure/catch blocks. The \nVM suppresses all ex\u00adceptions inside a security region that are not explicitly caught, in\u00adcluding exceptions \nwithin a catch block. The VM continues execu\u00adtion after the security region. In addition to restricting \nexception control .ow, Laminar limits implicit .ows by restricting how a security region returns from \na region through non-exceptional control .ow. In particular, the VM enforces that security regions must \nexit via fall through. Security regions cannot use break, return, or continue to exit, except in the \ntrivial case where these expressions cause control .ow to continue from the statement immediately after \nthe security region ends. Laminar thus eliminates implicit .ows by hiding the control .ow of a security \nregion from code outside of the security region. In Figure 5, code outside of the security region cannot \ndistinguish an execution where H is true from one where it is false. In contrast, DIFC systems that rely \non static analysis prevent these .ows by detecting them during compilation [18]. Both Laminar and static \nanalysis DIFC systems assume that programs (or in Laminar s case, security regions) terminate. Fig\u00adure \n6 shows an example of an implicit .ow via a termination chan\u00adnel, that leaks secret information based \non whether the application terminates. If control returns from this security region, then unpriv\u00adileged \ncode can learn that H is false. Similarly, a colluding appli\u00adcation might learn that H is true if the \napplication must be explic\u00aditly killed. OS-based DIFC systems eliminate termination channels by ensuring \nthat no one with whom communication is prohibited is noti.ed of thread termination. In practice, termination \nchannels have been low bandwidth and dif.cult to exploit, but in a multi\u00adthreaded environment, exploitation \nmight be signi.cantly easier. For instance, if H is usually false, a low security thread may de\u00adduce \nthat fact with high probability. In cases where reestablishing a program invariant is dif.cult, a secure \ncatch block can simply kill the process, for example, by calling System.exit(). If high-secrecy data \nstructures become corrupted, programmers may want to terminate the program rather than require a declassi.er \nto notice the corruption. However, exit\u00ading the program in the catch block creates a termination channel. \nA more restrictive model would prevent this termination channel by ensuring that only a security region \nwith full declassi.cation capa\u00adbilities kills the process. 4.4 VM-OS interface Security regions are \nabstractions that are not visible to the OS. For the OS to enforce DIFC rules on system calls made in \na security region, the VM must set appropriate labels on the current kernel thread using the set task \nlabel system call. As an optimization, the VM omits setting the labels in the kernel thread if the security \nregion does not perform a system call. When the VM sets the labels on a thread, the OS checks to ensure \nthat the labels are legal given the thread s capabilities. Acquiring tags and capabilities. Principals \nin Laminar acquire capabilities in three ways: they allocate a new tag, they inherit them through fork(), \nor they perform inter-process communication. The system carefully mediates capability acquisition, lest \na princi\u00adpal incorrectly declassify or endorse data. A principal can allocate a new tag via the alloc \ntag system call. The OS security module that allocates tags is trusted and ensures that all tags are \nunique. The principal that allocates a tag becomes the owner of the new tag. The owner can give the plus \nand minus capabilities for the new tag to any other principal with whom it can legally communicate. By \ndefault, a thread that gains a capability within a security region retains the capability on exit from \nthe region. The thread must explicitly call drop \u00adcapability to prevent the capability from propagating \nto the calling context. Threads and security regions form a natural hierarchy of princi\u00adpals. When a \nkernel thread forks off a new thread, it can initialize the new thread with a subset of its capabilities. \nSimilarly, when a thread enters a security region, the thread retains only the subset of its capabilities \nspeci.ed by the region. In general, when a new prin\u00adcipal is created, its capabilities are a subset of \nits immediate parent, which the VM and OS enforce. The passing of all inter-thread and inter-process \ncapabilities is mediated by the kernel, speci.cally with the write capability kernel call. This system \ncall checks that the labels of the sender and receiver allow communication. Removing tags and capabilities. \nThe Laminar VM is responsi\u00adble for correctly setting thread labels and capabilities inside secu\u00adrity \nregions. When a thread enters a security region, the VM .rst makes sure that the thread has suf.cient \ncapabilities to enter the re\u00adgion. If it does, the VM sets the labels and capabilities of the thread \nto equal those speci.ed by the security region. Similarly, when the thread exits the security region, \nthe VM restores the labels and ca\u00adpabilities it had just before it entered the region. On exiting a nested \nsecurity region, the VM restores the labels and capabilities of the thread to those of the parent security \nregion. The Laminar language API provides a method, remove-Capability, that removes a thread s capability \nin the VM, which then calls the drop capability system call to notify the kernel. The removeCapability \nmethod takes an argument, global, that allows the user to specify whether the capability should be dropped \nonly for the scope of the security region or permanently (i.e., globally). Globally dropped capabilities \nare not restored to the parent when the thread exits a security region. The VM uses the set task label \nsystem call to change the label of a thread at the beginning and end of a security region. This func\u00adtion \nhas no user API; it is called solely by the VM at the entry and exit of security regions. Laminar does \nnot allow security regions to change their labels, because the VM relies on labels staying the same throughout \nlexically scoped regions to prevent leaks through local variables, as discussed in Section 5.1. To change \nlabels in the middle of a security region, a thread may begin a nested security region. Consider an example \nwhen a thread only has the a + capability and starts a security region with secrecy label {S(a)}. The \nLaminar VM will set the label of the thread as {S(a)} when the security region begins. When the security \nregion ends, the thread must drop the secrecy label, even if it does not have the a - capability. To \nallow the thread to drop {S(a)}, the VM contains a thread, that is trusted by the OS, which runs code \nwith a special integrity tag called tcb. Using the drop label tcb system call, this trusted thread may \ndrop all current labels for a thread without having the appropriate capabilities. A single, high-integrity \nthread in the VM limits exposure to bugs because the OS enforces that only the thread with the tcb tag \nmay drop labels within a single address space. The VM cannot drop the labels on other applications. Only \na small, auditable portion of the VM is trusted to run with this special label. Capability persistence \nand revocation. Capability persistence and revocation are always issues for capability-based systems, \nand Laminar does not innovate any solutions. However, its use of capa\u00adbilities is simple and stylized. \nThe OS stores the persistent capabil\u00adities for each user in a .le. On login, the OS gives the login shell \nall of the user s persistent capabilities, just as it gives the shell access to the controlling terminal. \nIf a user wishes to revoke access to a resource for which she has already shared a capability, she must \nal\u00adlocate a new capability and relabel the data. Because tags are drawn from a 64-bit address space, \ntag exhaustion is not a concern. 4.5 Labeling data Data objects are labeled as part of their allocation \nto avoid races between creation and labeling. The VM labels objects allocated within a security region \nwith the label of that region. The create \u00adlabeled and mkdir labeled kernel calls create labeled .les \nand directories. Other system resources use the label of their creat\u00ading thread. Like most other DIFC \nsystems, Laminar uses immutable labels. To change a label, the user must copy the data object. Dynamic \nrelabeling in a multithreaded environment requires additional syn\u00adchronization to ensure that a label \ncheck on a data-object and its subsequent use by principal A are atomic with respect to the relabel by \nprincipal B. Without atomicity, an information .ow rule may be violated. For example, A checks the label, \nB changes the label to be more secret, B writes secret data, and then A uses the data. Atomic relabeling \ncan prevent this unauthorized .ow from B to A. Instead, Laminar uses immutable labels to avoid extra \nsynchronization. 4.6 Compatibility challenges Although Laminar is designed to be incrementally deployed, \nsome implementation techniques are incompatible with any DIFC sys\u00adtem. For instance, a library might \nmemoize results without regard for labels. If a function memoized its result in a security region with \none label, a later call with a different label may attempt to return the memoized value. Because the \nmemoized result is secret, the at\u00adtempt to return it will be prevented by the system. Such code must \nbe modi.ed to work in any DIFC system. 4.7 Trusted computing base To implement Laminar, we added approximately \n2, 000 lines of code to Jikes RVM,1 a 1, 000 line Linux security module, and 500 lines of modi.cations \nto the Linux kernel. This relatively small amount of code means that Laminar can be easily audited. We \nrely on the standardization of the VM and the OS as the basis of Laminar s trust. In addition to trusting \nthe base VM, Laminar requires that the VM correctly inserts the appropriate read and write instrumentations \ncalled barriers for all accesses and optimizes them correctly. Read and write barrier insertion is localized \nand standard in many VMs. In Linux, Laminar assumes that the kernel has the proper hooks to call into \nLinux security modules (LSM). Because many projects rely on LSMs, the Linux code base is under constant \naudit to make sure all necessary calls are made.  5. Implementation This section describes our implementation \nof Laminar, which mod\u00adi.es Jikes RVM and the Linux operating system to provide DIFC. 5.1 JVM support \nWe implement Laminar s trusted VM in Jikes RVM 3.0.0,1 a high\u00adperformance Java-in-Java virtual machine \n[1]. Our implementa\u00adtion of Laminar is publicly available on the Jikes RVM Research Archive.2 As of August \n2008, Jikes RVM s performance compared well with commercial VMs: the same average performance as Sun \nHotSpot 1.5; and 15 20% worse than Sun HotSpot 1.6, JRockit, and J9 1.93.All subsequent uses of the term \nJVM refer to the Laminar-enhanced version of Jikes RVM. The JVM controls information .ow by ensuring \nthat all program access to labeled data occur in security regions. The JVM adds instrumentation called \nbarriersat every object read and write; these barriers check at run time that accesses conform to the \nDIFC rules in Section 3. Starting a security region. When a thread starts a security re\u00adgion, the JVM \nchecks whether it has the capabilities to initialize the security region with the speci.ed labels and \ncapabilities, as de\u00adscribed in Section 4.3.2. Thread capabilities are stored in the ker\u00adnel. The JVM \nthen caches a copy of the current capabilities of each thread to make the checks ef.cient inside the \nsecurity region. Restricting information .ow for locals and statics. The JVM enforces information .ow \ncontrol for accesses to three types of application data: locals, which reside on the stack and in registers; \nobjects, which reside in the heap; and statics, which reside in a global table. Because the lifetime \nof local variables is typically short, and tracking their labels would be expensive, our prototype restricts \nthe 1 http://www.jikesrvm.org 2 http://www.jikesrvm.org/Research+Archive 3 http://jikesrvm.anu.edu.au/ \ndacapo/ programming model. Laminar statically (during JIT compilation) enforces the following restrictions \non local variables: (1) a local variable written inside a security region may not later be read outside \nthat security region if the region has secrecy labels, and (2) a local variable already written outside \na security region may not be read inside the region if the region has integrity labels. Because a security \nregion s labels are dynamic, for simplicity our implementation requires both properties for every security \nregion. An important exception to these restrictions is that local variables that are references may \nbe dereferenced; however the references themselves may not be read or written (e.g., obj.f is allowed, \nbut if (obj == null) is not). These accesses to the referenced object is checked by read and write barriers, \nwhich are discussed below. The Laminar prototype implementation requires that a security region be in \nits own method to simplify static checking of these restrictions. Thus, the JVM only needs to ensure \nstatically that any method security region (1) does not return a value if the region has security labels, \n(2) takes only reference-type parameters, and (3) does not read or write the values of its parameters \n(dereferencing its parameters is allowed). However, our prototype implementation does not currently check \nthese rules but instead requires programs to adhere to them. A production implementation of Laminar could \ndecouple security regions from methods by enforcing local variable restrictions as part of bytecode veri.cation. \nThe JVM restricts information .ow to and from static variables. The Laminar prototype implementation \nprevents security regions with secrecy labels from writing static variables, and prevents re\u00adgions with \nintegrity labels from reading statics. Compiler-inserted barriers at each access inside a security region \nenforce these restric\u00adtions. A production implementation could support labeling statics with modest overhead \nbecause static accesses are relatively infre\u00adquent compared to .eld and array element accesses. The applica\u00adtions \nin Section 7 do not need labeled static variables. Supporting information .ow for objects. The JVM tracks \nin\u00adformation .ow for objects that live in the heap. At allocation time, objects may be assigned secrecy \nand integrity labels that are im\u00admutable. By default, objects allocated inside security regions are assigned \nthe labels of the region at the allocation point. The pro\u00adgram may specify alternate labels, as long \nas they conform to DIFC rules. To change an object s labels, our implementation provides an API call, \ncopyAndLabel, that clones an object with speci.ed la\u00adbels. The label change must conform to the label \nchange rule (Sec\u00adtion 3). The JVM allocates labeled objects into a separate labeled object space in the \nheap, allowing instrumentation to quickly check whether an object is labeled. We modify the allocator \nto add two words to each object s header, which point to secrecy and integrity labels. Our implementation \nencapsulates labels into immutable, opaque objects of type Labels that support operations such as is-SubsetOf() \nand union(). For ef.ciency, Labels objects may be shared by objects, security regions, and threads because \nthey are immutable; mutating operations such as union() return a new object, if needed. Internally, Labels \nuses a sorted array of 64-bit integers to hold tags. Because Labels is opaque, applica\u00adtions cannot observe \nthe individual values of the tags, so they can read and use labels without creating a covert channel. \nThe JVM s compiler inserts read and write barriers [6] (instru\u00admentation at every operation) into application \ncode to enforce DIFC rules. Inside security regions, the compiler inserts barriers at la\u00adbeledobject \nallocation (before the constructor call) to set the labels and check that they conform to DIFC rules. \nIt inserts barriers at ev\u00adery read from and write to an object .eld or array element. Inside security \nregions, barriers load the accessed objects secrecy and in\u00adtegrity Labels and check that they conform \nto the current secu\u00ad - // credentials = {S(s1 ,s2),I(),C(s1 ,s2 - )} - // credentialsNew = {S(),I(),C(s1 \n,s2 -)} // newLabel = {S(),I()} [L1] secure(credentials){ [L2] int m1 = student1.marks; [L3] int m2 \n= student2.marks; [L4] MyObject obj = new MyObject(m1+m2); [L5] secure(credentialsNew){ [L6] ret.val \n= Laminar.copyAndLabel(obj, newLabel); ... } Figure 7. Example code to read the marks of two students. \nThe student1 and student2 objects are labeled. The object credentials contains the secrecy, integrity, \nand capabilities sets with which the security region is initialized. rity region s labels and capabilities. \nOutside security regions, read and write barriers check that the accessed objects are unlabeled (or equivalently, \nhave the empty label). The compiler inserts barriers inside security regions at static accesses to verify \nthat static reads (writes) occur only in regions without integrity (secrecy) labels. The compiler inserts \ndifferent barriers at an access depending on whether the access occurs inside or outside a security region. \nChoosing the right barrier at compile time can be dif.cult because a method may be called by code inside \nof and outside of a security region. In our prototype implementation, when a method .rst ex\u00adecutes and \nthe compiler compiles it, the compiler checks whether the thread is in a security region and inserts \nbarriers accordingly. (Subsequent recompilation at higher optimization levels reuses this decision.) \nThis approach, which we call static barriers, fails if a method is called from both within and without \na security region. Thus, we also support a con.guration where the compiler adds dy\u00adnamicbarriers that \ncheck whether the current thread is in a security region or not, and then execute the correct barrier. \nA production im\u00adplementation would use cloning to compile two versions of meth\u00adods executed from both \ncontexts; the same approach is used in prior work on software transactional memory [20]. Static barriers \nadd the same overhead that cloning would achieve. Because object labels are immutable and security regions \ncannot change their labels, repeated barriers and checks on the same object are redundant. We implement \nan intraprocedural, .ow-sensitive data-.ow analysis that identi.es redundant barriers and removes them. \nA read (or write) barrier is redundant if the object has been read (written), or if the object was allocated, \nalong every incoming path. Although the optimization is intraprocedural, the compiler already inlines \nsmall and hot methods, increasing the scope of redundancy elimination. Example. The example illustrated \nin Figure 7 computes the sum of the marks obtained by two different students. The student1 and student2 \nobjects are labeled and have different secrecy val\u00adues associated with them. The object credentials contains \na set of labels and capabilities. If the capabilities and labels inside credentials do not conform to \nthe current thread s capabil\u00adities, then the program terminates at L1. Once the security re\u00adgion starts, \nthe thread s current labels become those present in credentials. Lines L2 and L3 are reads of labeled \nobjects that will result in an error if the .ow from student1.marks or student2.marks to the thread in \nthe security region is not allowed. In line L4, the JVM allocates object obj with the labels present \nin credentials. The programmer can write to the ref\u00aderence obj because it is used only inside the security \nregion. In line L6, the thread attempts to change the labels of the object in\u00adside a nested security \nregion. The JVM allows this change because the thread has the required capabilities. Note that the inner \nsecurity region has empty secrecy label. 5.2 OS support We have implemented support for DIFC in Linux \nversion 2.6.22.6 as a Linux Security Module (LSM) [27]. LSM provides hooks into the kernel to allow custom \nauthorization rules. We also added a set of system calls to manage labels and capabilities (Figure 2). \nSome LSM-based systems, such as SELinux [15], manage access control settings through a custom .lesystem \nsimilar to proc. This method is isomorphic to adding new system calls. The Laminar security module contains \nabout 1,000 lines of code, and about 500 lines of modi.cations to the kernel to support the new system \ncalls. Tags, labels, and capabilities. Tags are represented by 64-bit in\u00adtegers and allocated via the \nalloc tag() system call. Labels and capabilities are stored in the opaque security .eld of the appropriate \nLinux objects (task struct, inode, file, etc.). Secrecy and integrity labels for .les are persistently \nstored in the .le s extended attributes. Most of the standard local .lesystems for Linux support extended \nattributes, including ext2, ext3, xfs, and reiserfs. Files. Using LSM, Laminar intercepts inode and file \nac\u00adcesses, which are used to perform operations on unopened .les and .le handles (including sockets and \npipes), respectively. The Lam\u00adinar security hooks perform a straightforward check of the rules listed \nin Section 3.2. The label of an inode protects its contents and its metadata, except for the name and \nlabel, which are protected by the label of the parent directory. In a typical .lesystem tree, secrecy \nincreases from the root to the leaves. Creating labeled .les in a DIFC system is tricky because it involves \nwriting a new entry in a parent directory, which can disclose secret information. For example, we disallow \na principal with secrecy label {S(a)} from creating a .le with secrecy label {S(a)} in an unlabeled directory, \nbecause it can leak information through the .le name. Instead, the principal should pre-create the .le \nbefore tainting itself with the secrecy label. More formally, we allow a principal with non-empty labels \n{Sp,Ip} to create a labeled .le or directory with labels {Sf ,If } if: (1) Sp . Sf and If . Ip; (2) the \nprincipal has capabilities to acquire labels {Sp,Ip}; and (3) the principal can write to the parent directory \nwith its current label. This approach prevents information leaks during .le creation while maintaining \na usable interface. Applying integrity labels to a .lesystem tree is more complex than secrecy. The intuitive \nreason for integrity labels on directories is to prevent an attacker from tricking a program into opening \nthe wrong .le, for instance using symbolic links. The practical dif.\u00adculty with integrity for directories \nis that a task with integrity label IA cannot read any .les or directories without this label, poten\u00adtially \nincluding /. If system directories, such as /home, have the union of all integrity labels, then an administrator \ncannot add home directories for new users without being given the integrity labels of all existing users. \nFlume solves this problem by providing a .at namespace that applications can use to store data with integrity \nla\u00adbels. Applying integrity labels to a traditional Unix directory struc\u00adture brings out a fundamental \ndesign tension in DIFC OS s, be\u00adtween usability and minimizing trust in the administrator. Lami\u00adnar .nds \na middle ground by labeling system directories (e.g., /, /etc, /home) with a system administrator integrity \nlabel when the system is installed. A user may choose to trust the system ad\u00administrator s integrity \nlabel and read absolute paths to .les, or she may eschew trust in the system administrator by exclusively \nopen\u00ading relative paths. In the worst case, she creates her own chroot environment. Simple relative paths \nwere suf.cient for all of the case studies in this paper. Laminar s approach supports incremental de\u00adployability \nby allowing users to choose whether to trust the system administrator at the cost of extra work for stronger \nintegrity guar\u00adantees. Benchmark Linux Laminar % Overhead stat 0.92 0.94 2.0 fork 96.40 97.00 0.6 exec \n300.00 302.00 0.6 0k .le create 6.29 6.56 4.0 0k .le delete 2.54 2.68 6.0 mmap latency 6,877.00 7,035.00 \n2.0 prot fault 0.24 0.26 7.0 null I/O 0.13 0.17 31.0 Figure 8. Laminar VM overhead on programs without \nsecurity regions. Pipes. Laminar mediates inter-process communication (IPC) over pipes by labeling the \ninode associated with the pipe message buffer. A process may read or write to a pipe so long as its labels \nare compatible with the label of the pipe. Message delivery over a pipe in Laminar is unreliable. An \nerror code due to an incorrect label or a full pipe buffer can leak information, so messages that cannot \nbe delivered are silently dropped. Unreliable pipes are common in OS DIFC implementations [12, 26]. Reads \nfrom a pipe in Laminar must be nonblocking to prevent illegal information .ow. Standard pipes deliver \nan EOF to readers when a writer exits. When the exiting process does not have appro\u00adpriate write labels, \nsending an EOF violates DIFC rules. Thus, reads should be non-blocking and readers cannot depend on an \nexplicit EOF if the writer can change labels. In the common case where all applications in a pipeline \nhave the same label, traditional Unix pipe behavior can be approximated with a timeout. Using pipes in \nprograms with heterogeneous, dynamic labels may require modi.\u00adcation for a DIFC environment.  6. Laminar \noverhead This section reports the overhead of Laminar s subsystems. The performance loss on Java benchmarks \nwithout security regions is 6% or 17%, depending on whether the dynamic compiler compiles separate versions \nof methods called both from inside and outside security regions. The Laminar OS incurs an overhead of \nless than 8% on lmbench. All experiments, including those in the next section, were conducted on a machine \nwith a quad-core Intel Xeon 2.83 GHz processor. All experiments con.gure Jikes RVM to run on two cores. \nAll results are normalized to values obtained on unmodi.ed Linux 2.6.22 and Jikes RVM 3.0.0. 6.1 JVM \noverhead Figure 8 shows the overhead of our Laminar-enabled JVM for the DaCapo benchmarks [5] and a .xed-workload \nversion of SPEC\u00adjbb2000 called pseudojbb [24]. Each experiment executes two iterations of the benchmark: \nthe .rst includes compilation, and the second disables compilation and runs only the application. We \nre\u00adport the running time of the second iteration. Because compilation decisions are nondeterministic, \nrunning times vary, so we execute 10 trials of each experiment and take the median. The darker bar shows \nthe overhead of dynamic barriers, which check dynamically if they are in a security region. Dynamic barriers \nadd 17% overhead on average. The lighter bar is the overhead of using static barriers, 6% on average. \nAs discussed in Section 5.1, a mature implementation of Laminar would use method cloning and eliminate \nall dynamic barriers. Because method cloning has comparable overheads to static barriers, code outside \nof a security region is expected to have an average overhead of 6%. We also measure compilation time \nand .nd that, on average, static barriers double it, and dynamic barriers triple it. However, compilation \ntime is not our primary concern, especially for long\u00adrunning programs. For these benchmarks, compilation \ntime ac- Table 2. Execution time in microseconds of several lmbench OS mi\u00adcrobenchmarks, and overhead \nincurred by using Laminar. Lower is better. counts for just 8-12% of running time on average, making \nbarrier compilation s effect on run time comparable to barriers effect on application execution time. \nThe overhead is high in large part be\u00adcause we instruct the compiler to inline the barriers aggressively, \nwhich bloats the code and slows downstream optimizations. To lower compilation time without increasing \nrun time substantially, an implementation could choose to inline less aggressively. 6.2 OS overhead \nWe use the lmbench [16] suite of benchmarks to measure the overheads imposed on unlabeled applications \nwhen running on Laminar OS. A selection of the results is presented in Table 2. In general, the overhead \nof the Laminar OS modi.cations are less than 8%, which is similar to previously reported overheads for \nLinux security modules [27]. The only performance outlier is the null I/O benchmark, which has an overhead \nof 31%. This benchmark represents the worst case for Laminar in that the system call being measured does \nlittle work to amortize the cost of the label check. For the sake of comparison, Flume adds a factor \nof 4-35\u00d7 to the latency of system calls relative to unmodi.ed Linux [12].  7. Application case studies \nThis section describes four case study applications and how we retro.t them with DIFC security policies. \nTable 3 summarizes the details of the applications. Figure 9 shows the overhead of running the modi.ed \nversion with Laminar. The retro.tted applications implement more powerful security policies than their \nunmodi.ed counterparts, and all modi.cations are at most 10% of the source. The .gure breaks down the \noverhead of Laminar into four parts. Start/endSRis the overhead of application modi.cations to support \nDIFC, including the starting and ending of security regions and other security operations, such as copyAndLabel. \nThe Alloc barriers con.guration denotes the extra time for allocating labeled objects and assigning their \nlabel sets. Staticbarriersis the overhead from read and write barriers when the security context is known \nat compile time. Finally, Dynamicbarriersis the extra overhead from barriers that check context at run \ntime. We note that Gradesheet and Battleship run correctly with static barriers, but Calendar and FreeCS \nrequire dynamic barriers because some methods are called from both inside and outside security regions. \nMethod cloning would obviate the need for dynamic barriers (Section 5.1). In all our experiments, we \ndisabled the GUI, as well as other I/O and network-related operations so that the Laminar overheads are \nnot masked by them. Hence, the slowdown in deployed appli\u00adcations would be less than what is reported \nin our experiments. For comparison, Flume [12] adds 34 43% slowdown on the MoinMoin wiki application. \nFlume labels data at the granularity of an address space, and cannot enforce DIFC rules on heterogeneously \nlabeled objects in the same address space. 7.1 GradeSheet GradeSheet is a small program that manages \nthe grades of stu\u00addents [4]. It uses three types of principals: professors, TAs and stu\u00ad Application \nLOC Protected Data LOC Added % time in SRs GradeSheet Battleship Calendar FreeCS 900 1,700 6,200 22,000 \nStudent grades Ship locations Schedules Membership properties 92 (10%) 95 (6%) 290 (5%) 1,200 (6%) 6% \n54% 1% <1% Table 3. Details of the various applications, including lines of code, the data that needs \nto be secured, the lines of code that had to be added to secure the application using Laminar and the \nfraction of time spent in security regions. Figure 9. Overhead of executing applications retro.tted \nwith Laminar. Name Security Set GradeCell(i,j) S={si}, I={pj } + - Student(i) C={s ,s } ii Si=n ++ - \nTA(j) C={s ,p ,p } i=1 ijj Si=n,j=m + - + - Professor C={(s ,s ,p ,p )} i=1,j=1 iijj Table 4. The security \nsets associated with the principals and data objects in GradeSheet. S, I and C stand for security, integrity \nand capability sets. Student(i) and TA(j) refer to the ith student and jth teaching assistant, respectively. \ndents. The main data structure is a two-dimensional object array GradeCell. The (i, j)th object of GradeCell \nstores the infor\u00admation about student i and her marks in project j. A sample policy states that (1) the \nprofessor can read/write any cell, (2) the TA can read the marks of all students but only modify the \nones related to the project that she graded, and (3) students can only view their own marks, but for \nany project. Table 4 shows how this policy can be expressed by assigning labels and capabilities to the \ndata and the principals respectively. Speci.cally, we guard the (i, j)th entry in the GradeCell with \nthe secrecy tag si and the integrity tag pj . Each student i has the capability to add or remove si, \nso students can read their own marks in any project. Each TA j has the capability to add tags si and \nthe integrity tag for the project that she graded (pj ). This tag ensures that TAs can read the marks \nof all students, but the integrity constraint prevents them from modifying grades for projects that they \ndid not grade. Interestingly, Laminar found an information leak in the original policy. The policy allowed \na student to calculate and read the average marks in a project, which leaks information about the marks \nof other students. After integration with Laminar, only the professor is allowed to calculate the average \nand declassify it. Our experiments measure the time taken by the server to process queries from different \nusers. The Laminar-enabled version has a 7% slowdown compared to the unmodi.ed version. 7.2 Battleship \nBattleship is a common board game played between two players. Each player secretly places her ships on \nthe grid in her board. Play proceeds in rounds; in each round, a player shoots a location on the opponent \ns grid. The player who .rst sinks all the opponent s ships wins the game. We started with JavaBattle, \nwhich is a 1,700-line Battleship program available on SourceForge. Each player Pi allocates a tag pi \nand labels her board and the ships with it. The capability p - i is not given to anyone else, ensuring \nthat only the player can declassify the locations of her ships. In the original implementation, players \ndirectly inspect the coordinates of a shot to determine whether it hit or missed an opponent s boat. \nUnder Laminar, each player sends her guess to her opponent, who then updates his board inside a security \nregion. The opponent then declassi.es whether the guess was a hit or a miss and sends that information \nback to the .rst player. We had to add less than 100 lines of code to secure the program to run with \nLaminar. In our experiments, the game is played between computers on a 15\u00d715 grid without a GUI. Figure \n9 shows that the secured version adds 56% overhead with static barriers. The overhead is high because \nthe benchmark spends almost 54% of its time inside security regions. In a deployed Battleship, which \nwould display the intermediate state of the board to the players, the overhead would be signi.cantly \nless. In an experiment where we display the shot location after each move, the run time increases, and \nLaminar overhead drops to 1%. 7.3 Calendar Like in the examples from earlier in the paper, we modi.ed \nthe k5nCal4 multithreaded desktop calendar to label all data struc\u00adtures and .ics .les that store a user \ns calendar information with the user s secrecy tag.All functions that access this data are wrapped inside \nsecurity regions, including a scheduler that .nds available meeting times for multiple users. In the \noriginal program, a user could view the calendar of other users, a feature we disabled. Our experiments \nmeasure the time to schedule a meeting, which includes reading the labeled calendars of Bob and Alice, \n.nding a common meeting date, and then writing the date to another labeled .le that Alice can read. The \nscheduling code is executed in a thread that has the capability to read data for both Alice and Bob, \nbut can only declassify Bob s data. The output .le is protected by the label of Alice. Our experiment \nschedules 1,000 meetings. Figure 9 shows that the secured version of Calendar runs 14% slower than unmodi.ed \nCalendar. We note that for Calendar, idle time was high when running the DIFC version with two cores. \nWe have not yet diagnosed this issue. However, we found that the problem is speci.c to our Xeon machine, \nso we report results for Calendar on a Core 2 Quad 2.4 GHz processor running our modi.ed kernel. 7.4 \nFreeCS chat server FreeCS is an open-source chat server written in Java5. Multiple users connect to the \nserver and communicate with each other. FreeCS supports 47 commands, such as creating groups, inviting \nother users, and changing the theme of the chat room. The original security policy consists of an authorization \nframework that restricts what commands can be used by a user. All these policies are written in the form \nof if..then checks. These authorization checks are actually checks on the role of a user. For example, \na user who is in the role of a VIP and has superuser power on a group can ban another user in the group. \nWe improve the security code in FreeCS by labeling sensitive data structures and accessing them inside \nsecurity regions. We made most of our modi.cations in two classes Group and User. 4 http://k5ndesktopcal.sourceforge.net \n5 http://freecs.sourceforge.net With Laminar, we localized all security checks to these classes. The \nabstraction of a role maps naturally onto integrity labels. For example, we protect the banList data \nstructure with two tags, one that corresponds to the notion of VIP and the other for the group s superuser. \nNow, only users who have the add capability for these two tags can use the ban command. We also changed \nthe authentication module to ensure that users are given the right capabilities when they log in. Our \nexperiments measure the time to process requests from 4, 000 users, each invoking three different commands. \nLaminar s overhead is less than 1% (Figure 9). 7.5 Summary The four case studies reveal a pattern in \nthe way applications are written. First, most applications have only a few key data struc\u00adtures that \nneed to be secured, like the array of student grades in GradeSheet or the playing boards in Battleship. \nSecond, the inter\u00adface to access these data structures is quite narrow. For example, InternalServer in \nGradeSheet and DataFile in Calendar contain the functions used to access the important data. These ob\u00adservations \nsupport our hypothesis that only localized changes are needed to retro.t DIFC onto many types of applications. \nThird, most of the data structures require heterogeneous labeling the sin\u00adgle data structure GradeCell \nhas different labels corresponding to different students. Heterogeneous labeling is impractical in OS\u00adbased \nsystems [12, 26, 28], since they support a single label on the whole address space or require the programmer \nto map application data structures onto labeled pages. The Laminar VM easily solves this problem with \n.ne-grain tracking of labels on the data structure, for example, individual array elements and objects \nin GradeSheet.  8. Conclusion Laminar is the .rst DIFC system to unify PL and OS mechanisms for information \n.ow control. It provides a natural programming model to retro.t powerful and auditable security policies \nonto ex\u00adisting, complex, multithreaded programs.  Acknowledgments We thank Eddie Kohler, Maxwell Krohn, \nand Nickolai Zeldovich for their feedback on earlier drafts of this paper. We also thank the anonymous \nreferees for their constructive comments. References [1] B. Alpern, C. R. Attanasio, J. J. Barton, M. \nG. Burke, P. Cheng, J.-D. Choi, A. Cocchi, S. J. Fink, D. Grove, M. Hind, Susan Flynn Hummel, D. Lieber, \nV. Litvinov, M. Mergen, T. Ngo, J. R. Russell, V. Sarkar, M. J. Serrano, J. Shepherd, S. Smith, V. C. \nSreedhar, H. Srinivasan, and J. Whaley. The Jalape no virtual machine. IBMSystems Journal, 39(1):211 \n238, 2000. [2] D. E. Bell and L. J. LaPadula. Secure computer systems: Mathemati\u00adcal foundations. Technical \nReport MTR-2547, Vol. 1, MITRE Corp., Bedford, MA, 1973. [3] K. J. Biba. Integrity considerations for \nsecure computer systems. Technical Report ESD-TR-76-372, USAF Electronic Systems Division, Bedford, MA, \nApril 1977. \u00b4 [4] A. Birgisson, M. Dhawan, Ulfar Erlingsson, V. Ganapathy, and L. Iftode. Enforcing authorization \npolicies using transactional memory introspection. In CCS, 2008. [5] S. M. Blackburn, R. Garner, C. Hoffman, \nA. M. Khan, K. S. McKinley, R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. \nHosking, M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar, D. Stefanovi\u00b4 c, T. VanDrunen, D. von Dincklage, \nand B. Wiedermann. The DaCapo benchmarks: Java benchmarking development and analysis. In OOPSLA, pages \n169 190, 2006. [6] S. M. Blackburn and A. L. Hosking. Barriers: Friend or foe? In ACM InternationalSymposium \nonMemoryManagement, 2004. [7] D. E. Denning. A lattice model of secure information .ow. CACM, 19(5):236 \n243, May 1976. [8] D. E. Denning and P. J. Denning. Certi.cation of programs for secure information .ow. \nCACM, 20(7):504 513, July 1977. [9] Department of Defense. Department of Defense Trusted Computer System \nEvaluation Criteria, DOD 5200.28-STD (The Orange Book) edition, December 1985. [10] B. Hicks, S. Rueda, \nT. Jaeger, and P. McDaniel. From trusted to secure: Building and executing applications that enforce \nsystem security. In USENIX, 2007. [11] P. A. Karger, M. E. Zurko, D. W. Bonin, A. H. Mason, and C. E. \nKahn. A retrospective on the VAX VMM security kernel. IEEE Trans.Softw.Eng., 17(11), 1991. [12] M. Krohn, \nA. Yip, M. Brodsky, N. Cliffer, M. F. Kaashoek, E. Kohler, and R. Morris. Information .ow control for \nstandard OS abstractions. In SOSP, 2007. [13] B. W. Lampson. A note on the con.nement problem. Commun.ACM, \n16(10):613 615, 1973. [14] Henry M. Levy. Capability-BasedComputerSystems. Digital Press, Bedford, Massachusetts, \n1984. [15] P. Loscocco and S. Smalley. Integrating .exible support for security policies into the Linux \noperating system. In USENIX, 2001. [16] Larry McVoy and Carl Staelin. lmbench: Portable tools for performance \nanalysis. In Usenix, 1996. [17] A. C. Myers. JFlow: Practical mostly-static information .ow control. \nIn POPL, pages 228 241, New York, NY, USA, 1999. ACM Press. [18] A. C. Myers and B. Liskov. A decentralized \nmodel for information .ow control. In SOSP, pages 129 142, October 1997. [19] A. C. Myers, N. Nystrom, \nL. Zheng, and S. Zdancewic. Jif: Java information .ow. Software release. http://www.cs.cornell.edu/jif, \nJuly 2001. [20] Yang Ni, Adam Welc, Ali-Reza Adl-Tabatabai, Moshe Bach, Sion Berkowits, James Cownie, \nRobert Geva, Sergey Kozhukow, Ravi Narayanaswamy, Jeffrey Olivier, Serguei Preis, Bratin Saha, Ady Tal, \nand Xinmin Tian. Design and implementation of transactional constructs for C/C++. In OOPSLA, pages 195 \n212, 2008. [21] A. Sabelfeld and A. C. Myers. Language-based information-.ow security. IEEE Journal on \nSelected Areas in Communications, 21, 2003. [22] Jonathan S. Shapiro, Jonathan M. Smith, and David J. \nFarber. EROS: A fast capability system. In SOSP, 1999. [23] V. Simonet and I. Rocquencourt. Flow Caml \nin a nutshell. In Proceedingsof the .rstAPPSEM-II workshop, pages 152 165, 2003. [24] Standard Performance \nEvaluation Corporation. SPECjbb2000 Documentation, release 1.01 edition, 2001. [25] N. Vachharajani, \nM. J. Bridges, J. Chang, R. Rangan, G. Ottoni, J. A. Blome, G. A. Reis, M. Vachharajani, and D. I. August. \nRIFLE: An architectural framework for user-centric information-.ow security. In MICRO, 2004. [26] S. \nVandebogart, P. Efstathopoulos, E. Kohler, M. Krohn, C. Frey, D. Ziegler, F. Kaashoek, R. Morris, and \nD. Mazi`eres. Labels and event processes in the Asbestos operating system. ACM Trans. Comput.Syst., 25(4):11, \n2007. [27] C. Wright, C. Cowan, S. Smalley, J. Morris, and G. K. Hartman. Linux security modules: General \nsecurity support for the Linux kernel. In USENIXSecuritySymposium, 2002. [28] N. Zeldovich, S. Boyd-Wickizer, \nE. Kohler, and D. Mazi`eres. Making information .ow explicit in HiStar. In OSDI, 2006. [29] N. Zeldovich, \nH. Kannan, M. Dalton, and C. Kozyrakis. Hardware enforcement of application security policies using tagged \nmemory. In OSDI, 2008.  \n\t\t\t", "proc_id": "1542476", "abstract": "<p>Decentralized information flow control (DIFC) is a promising model for writing programs with powerful, end-to-end security guarantees. Current DIFC systems that run on commodity hardware can be broadly categorized into two types: language-level and operating system-level DIFC. Language level solutions provide no guarantees against security violations on system resources, like files and sockets. Operating system solutions can mediate accesses to system resources, but are inefficient at monitoring the flow of information through fine-grained program data structures.</p> <p>This paper describes Laminar, the first system to implement decentralized information flow control using a single set of abstractions for OS resources and heap-allocated objects. Programmers express security policies by labeling data with secrecy and integrity labels, and then access the labeled data in lexically scoped security regions. Laminar enforces the security policies specified by the labels at runtime. Laminar is implemented using a modified Java virtual machine and a new Linux security module. This paper shows that security regions ease incremental deployment and limit dynamic security checks, allowing us to retrofit DIFC policies on four application case studies. Replacing the applications' ad-hoc security policies changes less than 10% of the code, and incurs performance overheads from 1% to 56%. Whereas prior DIFC systems only support limited types of multithreaded programs, Laminar supports a more general class of multithreaded DIFC programs that can access heterogeneously labeled data.</p>", "authors": [{"name": "Indrajit Roy", "author_profile_id": "81332524691", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1464231", "email_address": "", "orcid_id": ""}, {"name": "Donald E. Porter", "author_profile_id": "81100437540", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1464232", "email_address": "", "orcid_id": ""}, {"name": "Michael D. Bond", "author_profile_id": "81100148693", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1464233", "email_address": "", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1464234", "email_address": "", "orcid_id": ""}, {"name": "Emmett Witchel", "author_profile_id": "81100230582", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1464235", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542484", "year": "2009", "article_id": "1542484", "conference": "PLDI", "title": "Laminar: practical fine-grained decentralized information flow control", "url": "http://dl.acm.org/citation.cfm?id=1542484"}