{"article_publication_date": "06-15-2009", "fulltext": "\n Staged Information Flow for JavaScript * Ravi Chugh Jeffrey A. Meister Ranjit Jhala Sorin Lerner University \nof California, San Diego {rchugh,jmeister,jhala,lerner}@cs.ucsd.edu Abstract Modern websites are powered \nby JavaScript, a .exible dynamic scripting language that executes in client browsers. A common paradigm \nin such websites is to include third-party JavaScript code in the form of libraries or advertisements. \nIf this code were ma\u00adlicious, it could read sensitive information from the page or write to the location \nbar, thus redirecting the user to a malicious page, from which the entire machine could be compromised. \nWe present an information-.ow based approach for inferring the effects that a piece of JavaScript has \non the website in order to ensure that key security properties are not violated. To handle dynamically \nloaded and generated JavaScript, we propose a framework for staging in\u00adformation .ow properties. Our \nframework propagates information .ow through the currently known code in order to compute a min\u00adimal \nset of syntactic residual checks that are performed on the re\u00admaining code when it is dynamically loaded. \nWe have implemented a prototype framework for staging information .ow. We describe our techniques for \nhandling some dif.cult features of JavaScript and evaluate our system s performance on a variety of large \nreal\u00adworld websites. Our experiments show that static information .ow is feasible and ef.cient for JavaScript, \nand that our technique al\u00adlows the enforcement of information-.ow policies with almost no run-time overhead. \nCategories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation Validation; \nF.3.2 [Seman\u00adtics of Programming Languages]: Semantics of Programming Lan\u00adguages Program analysis General \nTerms Languages, Reliability, Veri.cation Keywords Set Constraints, Flow Analysis, Web Applications, \nCon.dentiality, Integrity 1. Introduction JavaScript is a popular scripting language that is the foundation \nof Web 2.0 applications like Gmail and Facebook. The popularity of JavaScript stems from its extremely \ndynamic nature: libraries can be downloaded at run time from diverse sources across the web, * This work \nwas supported by NSF CAREER grants CCF-0644306, CCF\u00ad0644361, NSF PDOS grant CNS-0720802, NSF Collaborative \ngrant CCF\u00ad0702603. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 09, June 15 20, 2009, Dublin, Ireland. Copyright c &#38;#169; 2009 ACM 978-1-60558-392-1/09/06. \n. . $5.00 <script src=\"http://adnetwork.com/insert-ad.js\"> <textbox id=\"SearchBox\"> <button id=\"Search\" \nonclick=\"doSearch()\"> <script type=\"javascript\"> var doSearch = function() { var searchBox = document.nodes.SearchBox.value; \nvar searchStr = searchUrl + searchBox; document.location.set(searchStr); } </script> Figure 1. A snippet \nof JavaScript based on www.wsj.com. When the user clicks the Search button, the doSearch function appends \nthe contents of the SearchBox to a base URL string searchUrl, and redirects the page to the resulting \nURL. objects and code can be sent over the network as raw strings that are dynamically parsed and executed \nby the receiver, and all modern web browsers provide JavaScript APIs that allow scripts executing on \nthe page to dynamically access and modify the state associated with the page. Unfortunately, the .exibility \ncomes at a great price: JavaScript has few protection or information hiding mechanisms, and consequently, \nthe use of JavaScript has opened up new classes of security vulnerabilities such as cross-site scripting \nand code\u00adinjection attacks. We illustrate the main issues here with a simple and glar\u00ading attack found \nin a study of real-world vulnerabilities carried out at Google [27]. Figure 1 shows a code snippet adapted \nfrom www.wsj.com. On the .rst line, the web site inserts an ad by in\u00adcluding some JavaScript code from \nan ad agency. This JavaScript code runs and replaces itself on the web page with the actual ad (this \nis a very common way of placing ads on web pages, includ\u00ading Google s AdSense). Below the ad, the sample \npage contains a search form with a text box and a search button with an on-click event handler. The event \nhandler redirects to the search site stored in a global searchUrl variable (which can be reassigned), \nwith the contents of the search box appended as a URL parameter. In practice, .rst tier ad agencies often \ndelegate to second tier agencies, which often delegate to third tier agencies, and so on. In their study, \nGoogle found a case where ads from a reputable and non-malicious American ad agency, after several levels \nof in\u00addirection, eventually included JavaScript code from a malicious ad provider in Russia. In the wsj \nexample, such a malicious JavaScript snippet could simply write to searchUrl, redirecting the user to \nthe attacker s site the next time the search button is clicked. This malicious site could then exploit \na vulnerability in the browser to compromise the client s machine. Thus, the attacker can divert the \nuser to the malicious site, without directly changing the docu\u00adment s location. The Google study reports \nthat almost all web at\u00adtacks which take over a user s computer follow this pattern: use JavaScript to \nchange the location bar to redirect to a malicious site that then exploits a vulnerability in the browser. \n Although a browser s vulnerability is the last nail in the cof.n, the root cause of the problem is \nthat the code that is included for inserting the ad should not be able to change the location bar, and \nthe designers of the wsj page certainly never intended to give the ad code this privilege. Thus, in order \nto make Web 2.0 applications secure, the fundamental challenge is to devise a mechanism that can specify \nand enforce the designer s intentions about the effects that a piece of JavaScript code can have. In \nthis paper, we propose to formalize these effects using infor\u00admation .ow. Information .ow can capture \nthe fact that a particular value in the program affects another value in the program. In the above example \nwith the location bar, the integrity policy that we would want to enforce is that no value from within \nany ad should .ow to the location bar, or into any child frame s location bar. Sim\u00adilarly, using information \n.ow, we could specify useful con.den\u00adtiality properties like the sensitive cookie value of the current \npage should not .ow to any ad, or information .lled in textboxes on the current page should not .ow to \nany third-party widgets (such as counters inserted on the page). Although information .ow has been explored \nin many settings, the dynamic nature of JavaScript poses a new challenge: because JavaScript commonly \nevaluates complex code strings that are built at run time or read from the network, the entire code is \nnot avail\u00adable until the JavaScript program is already running. As a result, techniques for statically \nchecking information .ow are not directly applicable. One solution to this challenge would be to check \ninfor\u00admation .ow dynamically, but unfortunately this approach has some signi.cant drawbacks. In addition \nto adding a possibly large run time overhead, it would also prevent developers from catching pol\u00adicy \nerrors early on in the development process. To address the dynamic nature of JavaScript, we propose in \nthis paper a framework for staging integrity and con.dentiality infor\u00admation .ow properties. Staging \nconsists of statically computing as much of the information .ow as possible based on the known code, \nand leaving the remainder of the computation until more code be\u00adcomes available. Since the residual checking \nmust be performed within the browser, and must be performed every time new code is dynamically loaded, \nwe must ensure that the residual checks can be performed ef.ciently. In our staging framework, the heavyweight \n.ow analysis is car\u00adried out just once on the server and its results are distilled into suc\u00adcinct residual \nchecks, that enjoy two properties. First, they soundly describe the properties that are left to be checked \non the remain\u00ading code once it becomes known; if each piece of loaded code passes the residual checks, \nthe top level .ow policy is guaranteed to hold. Second, they obviate the need for .ow analysis within \nthe browser; they are syntactically enforceable and can be ef.ciently discharged when the dynamically \nloaded code is parsed inside the browser. Thus, by performing the bulk of the analysis statically, staging \nallows the enforcement of information .ow policies for dy\u00adnamic web applications with almost no run-time \noverhead. To sum up, we make the following contributions in this paper. We present a framework for staging \nintegrity and con.dentiality information .ow properties in JavaScript programs. Section 2 gives an overview \nof our framework using an illustrative exam\u00adple, and Section 3 describes the framework in more detail. \n We present an instantiation of the framework using set inclu\u00adsion constraints. Section 4 describes \nhow we use set constraints to capture direct and indirect .ows through dif.cult-to-analyze features of \nJavaScript like dynamically created objects, .elds, .rst-class functions, and prototypes. Our constraint-based \n.ow  <script type=\"javascript\"> var document.settings = { setBaseUrl = function(s) { this.baseUrl = \ns }, setVersion = function(i) { this.version = i } } var initSettings = function(s, i) { document.settings.setBaseUrl(s); \ndocument.settings.setVersion(i); } initSettings(\"mysite.com/login.php\", 1.0); var login = function() \n{ var pwd = document.nodes.PasswordTextBox.value; if (readCookie(\"doCheck\") &#38;&#38; pwd.length < 8) \n{ document.alert(\"Password is too short!\"); } else { var user = document.nodes.UsernameTextBox.value; \nvar params = \"u=\" + user + \"&#38;p=\" + pwd; post(document.settings.baseUrl, params); } } </script> <text \nid=\"UsernameTextBox\"> <text id=\"PasswordTextBox\"> <button id=\"ButtonLogin\" onclick=\"login()\"> <div id=\"AdNode\"> \n<script src=\"adserver.com/display.js\"> </div> Figure 2. mysite.com with username and password textboxes \nto allow logging in. The global function initSettings is intended to be called once to initialize settings \nused by the page. The page also loads a third-party script, which will be evaled when the string is received \nfrom the network. var z1 = \"evil.com\"; var z2 = 1.0; initSettings(z1,z2); Figure 3. A bad network string \ndisplay.js, returned by the malicious or compromised adserver.com, which calls initSettings to overwrite \nthe page s settings. When the user clicks the login button, her username and password are sent to evil.com \ninstead of mysite.com. analysis of JavaScript code is a contribution by itself, indepen\u00addent of the staging \nframework. We evaluate our analysis techniques and our staging framework on a variety of real-world web \nsites. In particular, in Section 5 we demonstrate the feasibility of staged information .ow by showing \nthat: (1) our approach scales to the Alexa top 100 [1] web sites, (2) the residual checks are orders \nof magnitude faster than checking the entire program and fast enough to run inside the client browser, \nand (3) our analysis is precise enough to correctly identify .ows with a small false positive rate. 2. \nOverview We start with an example that motivates our approach of staged information .ow for JavaScript. \nConsider the web page shown in Figure 2. In our approach, we separate a web page into two parts. The \n.rst part, which we call the context, is known and in our example consists of the entire web page except \nfor the last three lines. The second part, which we call the hole, is loaded dynamically and is unknown. \nIn our example, the hole is the last  var displayAd; var appName = document.navigator.appName; var appVersion \n= document.navigator.appVersion; if (appName == \"IE\" &#38;&#38; appVersion < 7) { displayAd = function() \n{ ... }; } else displayAd = function() { ... }; } document.nodes.AdNode.innerHTML = displayAd(); Figure \n4. A good network string display.js, which creates advertisement text depending on the browser detected \nfrom the document.navigator .elds, and then displays it in the AdNode div that the page created for the \nad. three lines of the web page and consists of dynamically loaded third-party code from adserver.com. \nThe Context. The context contains some JavaScript code within <script>...</script> tags. This script \nde.nes a global ob\u00adject called settings that contains .elds baseUrl and version, and associated setter \nmethods setBaseUrl and setVersion. The function initSettings calls the setter methods to initialize the \n.elds of the settings object. The function login reads the pass\u00adword from the appropriate .eld of the \ndocument and the docu\u00adment s cookie, creates a string comprised of the user s name and password, and \ncalls post to send this string to the server whose URL is stored in settings.baseUrl. The login function \nis called asynchronously, on the reception of the event corresponding to the user clicking the ButtonLogin \nbutton. At the point when a user clicks on the ButtonLogin button, the settings object is already initialized \nwith mysite.com, the intended destination of the user\u00adname and password. The Hole. Suppose that adserver.com \nis either malicious or compromised, and sends the JavaScript code shown in Figure 3. This code calls \ninitSettings with values that cause the baseUrl .eld to point to the attacker s address. Thus, if the \nuser presses the button after this dynamically added code is evaled, the user s name and password will \nget posted to evil.com instead of mysite.com. 2.1 Safety via Information Flow Unfortunately, existing \nmechanisms are insuf.cient to prevent this kind of attack. First, dynamic techniques like stack-based \naccess control are insuf.cient in the face of asynchrony and global state. After the malicious code has \nset the global settings.baseUrl, it is no longer on the stack when the click event occurs, and hence \nthere is nothing on the callstack to suggest that an at\u00adtack has occurred. Second, JavaScript lacks most \nlanguage-based, coarse-grained, information-hiding mechanisms such as private .elds and abstract datatypes. \nThis is a large part of JavaScript s appeal for Web 2.0 programming by eschewing such mecha\u00adnisms, JavaScript \nmakes it easier to rapidly construct applications by gluing together trusted and untrusted libraries. \nThus, to reconcile safety with .exibility, we need a .ne-grained enforcement mecha\u00adnism that allows untrusted \ncode access to certain parts of the web\u00adpage, but ensures that critical elements cannot be affected. \nFlow Policies. In our approach, the author of the context provides a .ow policy which is a set of pairs \nof policy elements. A policy element is a program variable or a hole. Each pair in the policy represents \n.ow that is disallowed. For our example, the attack above is possible because the code from the untrusted \nhole is able to interfere with a trusted part of the system, namely the URL to which the messages are \nsent. To shield the application from such attacks, the page s author could provide a policy that prohibits \nany variable declared within the hole from affecting the .rst parameter of the function post. Formally, \nwe prevent untrusted eval sites from navigating the page via an integrity policy speci.ed as a pair ( \n, document.location) which states that variables declared within the code loaded at any eval site must \nnot .ow into (i.e., affect) the value of document.location. Dually, we can prevent secure information \nfrom being read by untrusted holes via a con.dentiality policy spec\u00adi.ed as a pair (document.cookie, \n) which states that the value of document.cookie must not .ow into any variable within the code loaded \nat any eval site. Given an information .ow policy and a complete program, there are standard techniques \n(e.g., using type systems [23] or data.ow analysis [21]), for checking that the program satis.es the \npolicy. Unfortunately, these techniques cannot be applied in our setting because of the extremely dynamic \nnature of JavaScript. At any time, additional code can be downloaded or dynamically generated using eval, \nwhich executes an arbitrary string as code. One option is to resort to fully dynamic enforcement of the \n.ow policies. A second option is to re-analyze the entire application every time a new piece of code \nis loaded or evaled. However, both of these options incur a signi.cant runtime overhead, which may make \ncertain applications unusable.  2.2 Staged Information Flow Instead, our approach is to stage the analysis \nby pre-analyzing the code from the context using the given policy, in order to compute a residual policy, \nwhich captures the requirements that the hole must satisfy in order for the entire program to satisfy \nthe .ow policy. If the hole is .lled with dynamically loaded code that contains more holes, then the \nstaging framework recursively checks the residual policy on the inner holes, and so on. Stage 1: Computing \nResidual Policy. Let us see how, for the example from Figure 2, the context s code can be used to re\u00ad \nduce the .ow policy that no variable from the hole should .ow into the .rst parameter of post, into a \nresidual policy that must be satis.ed by the code loaded from adserver.com. To do so we use a static \nconstraint-based analysis to compute the set of values that can .ow into all known variables that are \nin the same scope as the hole and that can affect the .rst parameter of post. These include document.settings.baseUrl, \nthe s param\u00adeter of document.settings.setBaseUrl, and the s parameter of initSettings. Thus, the residual \npolicy states that no variable declared in the hole should .ow into any of the above variables (in addition \nto the .rst formal of post). Stage 2: Checking Residual Policy. Once the code is loaded from adserver.com \nwe can rapidly check it against the residual policy. The code from Figure 3 violates the residual policy \nas z1, declared in the hole, is passed in as the .rst parameter for initSettings. Dually, if the code \nsatis.es the residual policy (i.e., if variables declared in the hole do not .ow into variables known \nto affect the .rst parameter of post), then we are guaranteed that the original information policy holds \nover the complete system. For example, suppose that the code that gets loaded for the hole is that shown \nin Figure 4. In this case, the hole does not violate the residual policy as it only reads .elds of the \ndocument.navigator object, and hence, we are guaranteed that the page is safe with respect to the given \npolicy. Thus, the residual policy allows us to quickly check the hole when it is dynamically .lled with \ncode, without the check being slowed by tracking .ows that occur within the context. Our staged information \n.ow framework can be used to split the analysis burden across client and server. Along with the develop\u00adment \nof a JavaScript application, the developer will specify the set of information .ow policies that should \nbe enforced on the page. During the testing cycle, various con.gurations and controlled li\u00adbraries can \nbe tested against the policy. The remaining residual checks can then be sent to the client along with \nthe page, and a modi.ed browser can perform the remaining stages of the analy\u00adsis, halting execution \nif the policy is ever violated. We assume that the residual policies are not tampered with either when \ntransmitted over the network or within the client browser.  In this setting, residual checks are performed \nby the client browser, which means that their ef.ciency directly affects the browsing experience. Consequently, \nto make residual checks as fast and simple as possible, we have designed our staging framework so that \nall residual checks are entirely syntactic, eliminating the need to do full-scale information .ow on \nthe client side.  2.3 Challenges of Analyzing JavaScript JavaScript poses several challenges in addition \nto dynamic code loading and generation. Functions. First, functions are objects, and hence .rst-class \nvalues that can be bound to other variables and passed around as param\u00adeters. For example, all the functions \nand methods in Figure 2 are created as anonymous function objects that are bound to the vari\u00adables whose \nnames are subsequently used to invoke the functions. Further, JavaScript programs make heavy use of .rst-class \nfunc\u00adtions for several reasons, including to attach listeners to events, and to allow different versions \nof the same function to be de.ned based on run time properties, as shown in the case of the displayAd \nfunction in Figure 4. Thus, any analysis for JavaScript must be able to handle function values which \nrules out the use of the standard summary-based interprocedural analyses that are used for .rst-order \nlanguages. Fields. Second, most variables refer to objects that contain .elds. Unlike statically typed \nlanguages like Java, it is dif.cult to deter\u00admine which .elds an object has because there are no classes, \nand .elds can be dynamically added to objects. In essence, objects cor\u00adrespond to dictionaries and .elds \nare simply used as names to look up in the dictionary. For instance, in our example, in order to be suf\u00ad.ciently \nprecise, the analysis must be able to distinguish between the different .elds of the document object. \nThus, any analysis for JavaScript must be .eld-sensitive, and not lump together values .owing into different \n.elds of an object. However, the sensitivity must be achieved ef.ciently as each object can have many \n.elds, thereby making a na\u00a8ive analysis impossible to scale. Prototypes. Third, JavaScript eschews classes \nin favor of a form of inheritance called prototyping. In essence, each function Foo can be used as a \nconstructor to create objects: the expression new Foo(...) creates an object and calls the function Foo \nto initialize the object. This way of constructing objects also creates an implicit inheritance chain \nthrough the use of a special .eld called proto. In particular, each function Foo has a corresponding \nprototype object that is implicitly constructed and stored in the .eld Foo.proto recall that functions \nare objects and can therefore have .elds.1 When a new object o is constructed with the expression new \nFoo(...), the new object implicitly inherits all the attributes of the proto .eld of Foo (that is, the \nnew object essentially inherits from Foo.proto). This means that on each .eld read o.f, if f is not a \n.eld of o, then the prototype of the function that created o (in this case, Foo s prototype) is used \nto lookup .eld f. Since Foo s prototype is itself an object, it may also have been created using a function \nthat had a prototype .eld. Thus, JavaScript transitively follows the chain of 1 We use proto throughout \nas shorthand for prototype, which is the actual .eld name used in JavaScript. Also, each prototype object \nhas a constructor .eld that holds the function value itself. Although we model this in our implementation, \nwe omit the details for clarity of exposition. e ::= Expressions: | c constant | x variable | x.f .eld-read \n| e1 op e2 bin-op |{..., f :e, . . .}i object literal | this this | funi(thisi, pi){ s } fun-def | f(e) \nfun-call | y.f(e) method-call | newi f(e) constructor-call s ::= Statements: | skip skip | var x var-def \n| x := e assign | x.f := e .eld-assign | s1;s2 sequence | ifi x then s1 else s2 branch | whilei x do \ns while | return e return | evali(x) eval 2(X\u00d7 ).( \u00d7X) P ::= Policies 2X \u00d7 2X RP ::= Res. Policies Figure \n5. Syntax proto .elds until the .eld being looked up is resolved, or until the root of the chain is reached \nwithout .nding the .eld. Because the proto .eld can be read and written at any time, just like any other \n.eld, a JavaScript analysis must carefully track the prototype objects corresponding to each constructor \nfunction, and must track for each object, the attributes that the object implicitly inherits via the \nprototype chain. 3. Framework We now describe our framework by formalizing the language, the notions \nof .ow and residual policies, and .nally describing how we stage the information .ow analysis. 3.1 Core \nJavaScript Figure 5 summarizes the syntax of Core JavaScript, which captures the essence of JavaScript. \nExpressions of Core JavaScript include: basic constants c which include integers, 0, 1,..., strings, \netc.; variable reads x; .eld reads x.f, where f is a .eld name; binary operations e1 op e2, where op \nincludes primitive operations like addition, string concatena\u00adtion etc.; function declarations, where \neach function is labeled by a unique identi.er i, and has two formal parameters thisi and pi; function, \nmethod, and constructor calls, where exactly one param\u00adeter is passed to the callee; objects, which are \na sequence of .eld\u00adexpression bindings; and the this expression. Statements of Core JavaScript include: \nvariable declarations, vari\u00adable and .eld assignments, statement sequencing, branching and while-loops, \nand return statements. To model dynamic code load\u00ading, we include an eval statement. A statement is open \nif it con\u00adtains an eval site, and closed otherwise. Conventions. We assume, without loss of generality, \nthat the pro\u00adgram satis.es certain syntactically enforceable conventions. First, we assume that all functions \nare declared anonymously, and that each declaration has a unique label i. Further, each function has \nexactly two parameters. The .rst parameter thisi corresponds to the object that will be referred to as \nthis inside the body of the function. We use thisi to model JavaScript s semantics for this. The second \nparameter pi corresponds to the argument passed to the function. When a function is called directly as \nf(e), the this vari\u00adable is set to the global object, and the value that e evaluates to is passed in \nas the second parameter. When a function is called indi\u00adrectly as a method call x.f(e), the object x \nis passed in as the .rst parameter, and the value that e evaluates to is passed as the second parameter. \nSecond, we assume that each eval statement is uniquely labeled. Further, we assume that each branch and \nloop is uniquely labeled we will use these labels to compute indirect .ows, which are the .ows that \noccur from the branch value to locations being assigned in the branch. Third, we assume that each variable \nis de\u00adclared, and that all variables are renamed so that local variables in different scopes have unique \nnames. Fourth, rather than explicitly modeling the webpage (i.e., encoding the DOM), we assume that there \nis an object document in the global namespace that can be accessed and manipulated via the appropriate \n.elds and methods.  Dynamic Semantics. The dynamic semantics of Core JavaScript are standard we refer \nthe reader to [31, 36, 6, 17] for a detailed formalization via small-step operational semantics.  3.2 \nInformation Flow Policies Our information .ow policies are expressed as sets of pairs, where each pair \nrepresents a must-not-.ow requirement. In its most gen\u00aderal form, such policies would include pairs where \neach element is either a variable or the label of an eval site. Although our unstaged information .ow \nanalysis will handle such general .ow policies, these policies make residual checks dif.cult to perform \nsyntacti\u00adcally, and require sending a large amount of state across stages. Consider for example a policy \nstating that a variable x should not .ow to another variable y, and a context containing a single as\u00adsignment \nb=a. If the hole executes a=x and b=y, then the .ow policy is violated. Since the hole can add .ow between \nany variables a and b that it chooses, in the most general case the .rst stage must send to the second \nstage all possible .ows of variables in the context. This would require sending a large amount of data \nto the second stage, and would also require performing a full .ow analysis in the client browser. Thus, \nto make our policies more amenable to syntactic residual checks, we restrict ourselves to con.dentiality \nand integrity poli\u00adcies: con.dentiality policies state that sensitive information should not be leaked, \nwhereas integrity policies state that the attacker can\u00adnot compromise sensitive information. As a result, \nthese policies include pairs where one element of the pair is a variable and the other is a hole, which \nwould not allow the problematic policy (x, y) to be expressed. Even with this restriction, policies that \ngrant one hole access to a sensitive variable but not another pose problems for staging. In particular, \nconsider the case where the client receives a hole that is allowed to access the sensitive variable. \nThis hole may induce .ow that must be taken into account in the residual checks for the remaining holes \nthat cannot access the variable. To update the residual policy would again require a complex computation \non the client. As a result, instead of allowing must-not-.ow pairs to be speci.c to particular holes, \nwe require that if the policy restricts access to one hole, it restricts access to all holes. Policies. \nFormally, we de.ne a must-not-.ow policy as a pair of the form (x, ), which states the con.dentiality \npolicy that the value of the variable x must not .ow to any variable within a hole, or ( , x), which \nstates the integrity policy that values from variables within a hole must not .ow into x.A policy P is \na set of must-not-.ow policies. A residual policy RP is a pair of two sets of variables or .elds MNR \nand MNW called the a must not read set and must not SIF(P, s)= RP . Stage(P, s) c . Initialize(s) do \n(s, c) . Execute(c) while (c = EXIT and Check(RP,s)= ERR) if c = EXIT then return SAFE else return ERR \nFigure 6. Staged Information Flow Framework write set respectively. Intuitively, the code loaded at any \nhole must not read (resp. write) any variable or .eld in MNR (resp. MNW ). Even though policies are restricted \nto variables, notice that we can stipulate a policy like (x.f, ) (resp. ( , y.g)) by (a) creating a ' \nnew variable x' (resp. y'), (b) adding a new assignment x:= x.f '' (resp. y.g := y') and, (c) specifying \na policy (x, ) (resp. ( , y)). Similarly, to prevent .ows from constants we assume that dynami\u00adcally \nloaded code is rewritten so that all constants that appear in the hole are bound to new variables declared \nwithin the hole. Flows. Informally, we say that a variable x .ows into y if the value of y can be affected \nby the value of x, either directly, via a sequence of assignments, or indirectly, due to conditional \ndependences. To formalize when a .ow policy P is violated by a program s we rewrite the program to Rewrite(P, \ns), which is an instrumented version of s that: (1) has auxiliary taint .elds that track .ows, and (2) \ncalls a special Core JavaScript function flowDetected() as soon as a .ow is detected during execution \nfrom x to a hole, for some (x, ) . P or from a hole to x, for some ( , x) . P . Figure 7 formalizes the \nmost important cases of the rewriting function Rewrite. Notice that the rewriting function is recursively \ninvoked every time an eval is executed. Flow Policy Satisfaction. We say that a program s violates a \npolicy P if there is an execution of Rewrite(P, s) along which the function flowDetected() is called. \nOtherwise, we say that s satis.es the policy P .  3.3 Staged Policy Veri.cation Procedure SIF. Figure \n6 formalizes our Staged Information Flow framework as a procedure SIF that takes as input a policy P \nand an open Core JavaScript program s and returns either SAFE indicating that the policy P was satis.ed \nor ERR indicating that the policy was violated. At a high level, our framework stages information .ow \nchecking as follows. First, the framework calls Stage with the top-level policy P and the context s, \ni.e., the known part of the program, to compute the .ows that occur in the context. Stage uses the computed \n.ows and the (top-level) policy to pre-compute and return a residual policy RP that is a projection of \nthe (top\u00adlevel) policy to the eval sites. Second, the framework initializes the variable c with a snapshot \nof the entire initial state of the executing program. Third, the framework enters a loop where it invokes \nExecute on the snapshot c to run the program until it reaches the next eval site, or terminates. In the \nformer case, Execute returns a pair (s, c) where s is the code to be loaded at the next site, and c is \nthe current snapshot of the program. In the latter case, Execute returns a triple where c is simply EXIT, \nindicating the program has terminated. The loop is repeated until the program terminates or Check determines \nthat the loaded code s violates the residual policy RP. After breaking out of the loop, we check if we \nexited because the program terminated or, because of some call to Check, returned ERR. In the former \ncase SIF returns SAFE, and in the latter ERR. Procedures Stage and Check. The framework is parameterized \nby two procedures Stage and Check. Stage takes as input a policy P and a statement s corresponding to \na context, and returns a residual policy RP corresponding to the projection of P to the eval sites in \ns. Check takes as input a residual policy RP and a statement s corresponding to code loaded in at a hole, \nand returns ERR or SAFE.  Soundness. For two programs s, s ' and hole label i, let s[i . s ' ] be the \nclosed program obtained by replacing the eval site i in s with s ' and all other eval sites with skip. \nTo ensure soundness, the procedures Stage and Check must meet the following requirements which state \nthat the procedures must overapproximate the .ows that occur in concrete executions. .P, s, i, s ' . \nif s[i . s ' ] violates P then Check(Stage(P, s),s ' )= ERR .P, s, i, s ' . if Check(Stage(P, s),s ' \n)= SAFE then Stage(P, s)= Stage(P, s[i . s ' ]) We can show that if Check and Stage meet the above cri\u00adteria, \nthen for all policies P and programs s, if P is vio\u00adlated by s then SIF(P, s) returns ERR. A sketch of \nthe proof is as follows: assume that P is violated at some point dur\u00ading the execution of s, and suppose \nthat at the point of fail\u00adure, sites i1 through ik in s had been loaded with s1 through sk. Thus, we \nknow that s[i1 . s1, \u00b7\u00b7\u00b7 ,ik . sk] violates the policy, and then by the .rst property above, we know \nthat Check(Stage(P, s[i1 . s1, \u00b7\u00b7\u00b7 ,ik-1 . sk-1]),sk)= ERR. Then, using k - 2 applications of the second \nproperty above, we can show that Stage(P, s[i1 . s1, \u00b7\u00b7\u00b7 ,ik-1 . sk-1]) = Stage(P, s), and therefore \nCheck(Stage(P, s),sk)= ERR, which means that SIF(P, s) would return ERR when it performs the resid\u00adual \ncheck on sk. The second condition above enables our framework to compute the .ows and residual policies \nonce, without having to recompute them each time that a hole is .lled. In essence, the conditions on \nStage and Check ensure that the dynamically loaded code does not induce any new .ows for the variables \ndescribed in the top-level policy P . If any new .ows would be induced by the hole, then Check would \nreturn ERR and execution would be halted. 4. Static Instantiation We now describe how we have instantiated \nour framework by presenting our implementations of Stage and Check. Stage takes a policy P and program \ns and returns the residual policy for the eval sites in s. Check takes a residual policy RP comprising \na must-not\u00adread and must-not-write set, and a statement corresponding to code to be loaded at a hole, \nand veri.es that the statement satis.es the residual policy, by verifying that the statement does not \nread (resp. write) the variables or .elds listed in the must not read (resp. must not write) sets. Next, \nwe describe our .ow-insensitive, .eld-sensitive, set\u00adconstraint based instantiation of the procedure \nStage. First, we present the different elements constituting the constraints, con\u00adstants, constructors, \nand terms. Second, we describe our syntax\u00addirected constraint generation procedure. Third, we discuss \nsome optimizations required to analyze JavaScript with suf.cient preci\u00adsion. Fourth, we show how Stage \ncombines policies and constraints to compute residual policies. Set Constraints. A term is either a constraint \nvariable X,a con\u00adstant, or a constructed term C(t1,...,tn), where C is a constructor of arity n and t1,...,tn \nare terms. A set constraint is a constraint of the form t1 . t2, where t1 and t2 are terms. A satisfying \nsolu\u00adtion for a .nite set of constraints maps each constraint variable to a set of constants and constructed \nterms, such that all of the inclusion constraints are satis.ed. For details, we refer the reader to [20]. \nFor SRC(P, z) = DST(P, z) = if (z, ) . P or if .a s.t. a . z.taint and z is a hole var [((a, ) . P and \nz is a hole var ) or then [z] else [] (( , z) . P and a is a hole var )] then flowDetected() Rewrite(P, \nc)= {data : c, taint :I}Rewrite(P, var x)= var x Rewrite(P, return x)= return x Rewrite(P, x)= {data \n: x.data, taint :I + x.taint + SRC(P, x)} Rewrite(P, x.f)= {data : x.data.f.data, taint :I + x.data.f.taint} \nRewrite(P, x op y)= {data : x.data op y.data, taint :I + x.taint + y.taint} Rewrite(P, fun (this , p \n){ s })= {data : fun(this, x, I)Rewrite(P, s), taint :I} Rewrite(P, {f1 :x1,...})= {data : {f1 : {data \n:x1.data, taint :I + x1.taint},...}, taint :I} Rewrite(P, x := e)= var tmp := Rewrite(P, e); x.data := \ntmp.data; x.taint := tmp.taint; DST(P, x) Rewrite(P, x.f := e)= var tmp := Rewrite(P, e); x.data.f.data \n:= tmp.data; x.data.f.taint := tmp.taint Rewrite(P, x := f(z)) = var tmp := f.data; x := tmp(this, z, \nI + f.taint); DST(P, x) Rewrite(P, x := y.f(z)) = x := y.data.f.data(y, z, I + y.data.f.taint); DST(P, \nx) Rewrite(P, s1;s2)= Rewrite(P, s1);Rewrite(P, s2) Rewrite(P, ifi x then s1 else s2)= var tmp := I; \nI := I + x.taint; ifi x.data then Rewrite(P, s1) else Rewrite(P, s2); I := tmp Rewrite(P, whilex s do \n)= var tmp := I; I := I + x.taint; whilex.data Rewrite(P, s) do ; I := tmp Rewrite(P, x := evali(y)) \nvar tmp := evali(Rewrite(P, y.data)); x.data := tmp.data; x.taint := I + tmp.taint + y.taint Figure 7. \nDynamic Information Flow Rewriting. We assume com\u00adplex expressions are bound to fresh temporary variables. \nThe global variable I, initially the empty set, stores the set of indirect taints. two unary constructors \nC, D, we write the constraint t1 .C,D t2 as an abbreviation for the pair of constraints t1 . C(X), D(X) \n. t2, where X is a fresh constraint variable that is distinct from all other variables.  Statements \nGen(k, XI , skip)= \u00d8 Gen(k, XI , var x)= {cx .Xx }.{Ind(cx ) .Xx } Gen(k, XI , x := e)= Gen(k, XI ,e) \n. {Xe .Xx } . {XI .Xx } Gen(k, XI , x.f := e)= Gen(k, XI ,e) . {Xx . Real(Fldf (Xe, O))} . {Xx . Real(Fldf \n(XI , O))} Gen(k, XI ,s1;s2)= Gen(k, XI ,s1) . Gen(k, XI ,s2) Gen(k, XI , ifi x then s1 else s2)= Gen(k, \nXi,s1) . Gen(k, Xi,s2) . {XI .Xi} . {Xx .Ind,Ind Xi} Gen(k, XI , whilei x do s )= Gen(k, Xi,s) . {XI \n.Xi} . {Xx .Ind,Ind Xi} Gen(k, XI , return e)= Gen(k, XI ,e) . {Xe .Xretk } . {XI .Xretk } Gen(k, XI \n, evali(e)) = \u00d8 Expressions Gen(k, XI , c as e)= {c .Xe}.{Ind(c) .Xe} Gen(k, XI , x)= \u00d8 Gen(k, XI , x.f \nas e)= {Xx . Real(Fldf (\u00d8, Xe))} . {Xx . Pro(Fldf (\u00d8, Xe))} Gen(k, XI ,e1 op e2 as e)= Gen(k, XI ,e1) \n. Gen(k, XI ,e2) . {Xe1 .Xe} . {Xe2 .Xe} Gen(k, XI , {..., fj : ej ,...}i as e)= (.j Gen(k, XI ,ej )) \n. {Xi .Xe}. (.j {Xej .Xi.fj }) . (.j {XI .Xi.fj }) . (.j {Real(Fldfj (Xi.fj , Xi.fj )) .Xi}) Gen(k, XI \n, this as e)= {thisk .Xe} Gen(k, XI , funi(thisi, pi){ s } as e)= Gen(i, Xindi ,s) . {XI .Xindi } . {Xi \n.Xe}. {Fun(Xconsi , Xthisi , Xpi , Xindi , Xreti ) .Xi}. (.j {Real(Fldfj (Xprotoi.fj , Xprotoi.fj )) \n.Xprotoi }) . {Real(Fldproto (Xprotoi , Xprotoi )) .Xi}. {Xconsi . Real(Fldproto (Xprotoi , O))} Gen(k, \nXI , f(e ' ) as e)= Gen(k, XI ,e ' ) . {Xf . Fun(\u00d8, Xog , Xe\" , XI , Xe)} Gen(k, XI , x.f(e ' ) as e)= \nGen(k, XI ,e ' ) . {Xx . Real(Fldf (\u00d8, Fun(\u00d8, Xx , Xe\" , XI , Xe)))}. {Xx . Pro(Fldf (\u00d8, Fun(\u00d8, Xx , \nXe\" , XI , Xe)))} Gen(k, XI , newi f(e ' ) as e)= Gen(k, XI ,e ' ) . {Xi .Xe}. (.j {Real(Fldfj (Xi.fj \n, Xi.fj )) .Xi}) . {Xf . Fun(Xi, Xi, Xe\" , XI , O)}. {Xi.proto .Real,Pro Xi} . {Xi.proto .Pro,Pro Xi} \nFigure 8. Constraint generation 4.1 Constraint Elements We set up a system of constraints over variables \nXe for each sub\u00adexpression e of the program. The constraints use several kinds of constructors to model \nvarious aspects of JavaScript code. The .rst two constructors are standard ways of encoding functions \nand .elds using set constraints [12]. The last three are novel mechanisms re\u00ad quired to capture information \n.ow and the semantics of JavaScript: they are used to distinguish between .elds that are directly con\u00adtained \nin an object, .elds that are reachable by transitively follow\u00ading a prototype chain, values that directly \nreach a particular point, and values that indirectly reach a particular point. 1. Function Constructor. \nJavaScript programs have .rst class functions in that functions can be created and passed around like \nany other value. We model the .ow of function values via a con\u00adstructor Fun() of arity 5. The .rst argument \ncorresponds to the objects constructed by the function object, a special feature of JavaScript that we \nwill describe in the sequel. This argument is treated as contravariant. The second argument corresponds \nto the function s implicit parameter this. As the argument corresponds to an input of the function, it \nis treated as contravariant. The third argument corresponds to the explicit formal parameter of the func\u00adtion. \nAs this argument also corresponds to an input of the function, it is treated as contravariant. The fourth \nargument corresponds to an implicit parameter that holds the values corresponding to indi\u00adrect .ows into \nthe points where the function is invoked. This pa\u00adrameter is used as the initial set of indirect .ows \ninto the body of the function, and as it corresponds to an input, the argument is also treated is contravariant. \nThe .fth argument corresponds to the re\u00adturn value, and hence the argument is covariant. 2. Field Constructors. \nJavaScript programs make heavy use of .elds and any precise analysis must track .ows in a .eld-sensitive \nmanner. The classical way to model .elds is to view them as a pair of functions: a setter that updates \nthe contents of the .eld, and a getter the returns the contents of the .eld. Following this intuition, \nwe encode a .eld f via a a constructor Fldf () of arity 2. The .rst parameter corresponds to the set \nof values written into the .eld, i.e., the inputs to the setter, and hence, is treated as contravariant. \nThe second parameter corresponds to the set of values read from the .eld, i.e., the outputs of the getter, \nand hence, is treated as covariant. When initializing an object s .elds, we use the same set variable \nin both places so that all arguments that .ows into the .rst argument .ow out of the second argument. \nWhen writing a .eld, we pad the second argument with the set variable O, which collects everything that \n.ows from the .eld by covariance. When reading a .eld, we pad the .rst argument with the set variable \n\u00d8, so that nothing .ows into the .eld by contravariance. 3. Real and Prototype Flow Constructors. In \norder to determine what a .eld read returns in the presence of prototyping, we must track, for each object, \nthe values for all .elds that can be read directly from the object or transitively via following its \nprototype chain. To distinguish between the .elds of an object and the .elds reachable via the prototype \nchain of an object, we use a special constructor Real() of arity 1 to wrap the .elds that an object directly \ncontains, and a special constructor Pro() of arity 1 to wrap the .elds that are transitively reachable \nby following the object s prototype chain.  In general, if c can be reached by following the prototype \nchain of an expression e, then our constraints will ensure that Pro(c) .ows into Xe. For example, x.f \ncan return the constant c if the object has a .eld f that has the value c, or if an object in its prototype \nchain has a .eld f that has the value c. In the former case, our constraints ensure that the term Real(Fldf \n(c, c)) .ows into Xx . In the latter case, our constraints ensure that the term Pro(Fldf (c, c)) .ows \ninto Xx .  4. Indirect Flow Constructor. When tracking information .ow, we must track both direct value \n.ows, as well as indirect .ows that arise when assignments take place under particular branch conditions. \nHowever, due to the presence of higher-order functions and dynamic dispatch, we must take care to separate \ndirect .ows (which affect which functions get executed at a different program points), from indirect \n.ows (which have no effect on the execution). To achieve this separation, we use a covariant constructor \nInd() of arity 1 to wrap constants and convert them into ground terms that participate in indirect .ows. \nIn general, if a constant c directly .ows into an expression e, then the constraints ensure that the \nterm c .ows into Xe. If the constant c indirectly .ows into an expression e, however, then our constraints \nensure that Ind(c) .ows into Xe. For example, if c indirectly .ows into the expression x.f, then our \nconstraints will ensure that the term Real(Fldf (Ind(c), Ind(c))) .ows into Xx .  4.2 Constraint Generation \nFigure 8 shows the constraint generation procedure Gen. The pro\u00adcedure takes as input a label k corresponding \nto the identi.er of the function currently being analyzed, a constraint variable XI repre\u00adsenting the \nindirect .ows into the program location being analyzed, and either e or s, respectively the expression \nor statement being analyzed, and it returns as output a set of inclusion constraints. Gen traverses the \nAST of the program and generates constraints between variables of the form Xe for each subexpression \ne, that capture the set of values that .ow directly or indirectly into e. We maintain the invariants \nthat: (1) only values wrapped with the Ind() constructor .ow into the indirect .ow variables XI , (2) \nfor every value that directly .ows into e, there is a corresponding term that .ows into Xe, and, (3) \nfor every value that is reachable from e after transitively following the prototype chain rooted at e, \nthere is a cor\u00adresponding term wrapped under Pro() that .ows to Xe. Next, we discuss how constraints \nare generated for a representative subset of expressions and statements. Assignments. For each assignment \nx := e, we generate constraints on the subexpression e, and then constraints that capture the direct \n.ow from e into x as well as the indirect .ow from the current loca\u00adtion s indirect .ow variable into \nx. Notice that a return statement is treated as an assignment to the return variable of the function \nto which the statement belongs. Branches. Each branch statement and loop is labeled with a unique label \ni that can be generated with a syntactic pass over the source. For each branch or loop labeled i, we \ncreate a new indirect .ow variable Xi. We .ow the values in XI and the indirect values from the expression \nused in the branch condition into Xi, and then use Xi as the indirect .ow variable when generating the \nconstraints for the statements that depend on the branch. To preserve the invariant that indirect .ows \nare wrapped under the Ind() constructor (and hence, not used to affect computation), we .lter .ows to \nwrapped terms, using Xx .Ind,Ind Xi. Object Literals. We use the set variable Xi.f to track the contents \nof .eld f of object i. For every .eld fj , we .ow the initial value ej into the .eld with the constraint \nXej .Xi.fj , and the current indirect taint into the .eld with the constraint XI .Xi.fj . Finally, we \nadd the constraint Real(Fldfj (Xi.fj , Xi.fj )) .Xi to treat fj as a .eld that object i directly contains, \nwhere Xi.fj is used as both the setter and getter for the .eld. Fields. For each .eld x.f read in (resp. \nwritten in) an expres\u00adsion e, we create the appropriate .ow constraint between Xx and Fldf (\u00d8, Xe) (resp. \nFldf (Xe, O)), which by virtue of the construc\u00adtor matching and variance, has the effect of .owing the \nvalues from (resp. into) the f .eld of x into (resp. from) Xe. We must account for prototype chains when \nreading and writing to .elds. For .eld reads from x.f, the result can .ow from either the object x (if \nit has a .eld f), or from some object in its prototype chain with a .elds f. To model these semantics, \nthe values returned from reads are the values from objects that directly .ow into x (i.e., Real()-wrapped \nterms that .ow into Xx ) as well as objects that .ow into x after following the prototype chain (i.e., \nPro()-wrapped terms that .ow into Xx ). For .elds writes to x.f, only the actual object itself may be \nupdated (as opposed to some object along the prototype chain). To model these semantics, we only carry \nout the assignment on those objects that directly reach x, i.e., are wrapped under Real(). Function De.nitions. \nEach anonymous function declaration is la\u00adbeled with a unique label i. For each function i, we create \na term Fun(Xconsi , Xthisi , Xpi , Xindi , Xreti ) corresponding to the func\u00adtion s value, and create \nthe appropriate constraints from the con\u00adstraint variables representing the inputs Xthisi , Xpi , and \nXindi into the body of the function, and from the return statement of the function to Xreti . The contravariant \nargument consi in the .rst po\u00adsition of the function term corresponds to the objects constructed by the \nfunction. The last three constraints deal with prototypes. First, we create a fresh prototype object, \nnamely Xprotoi , and set up its .elds in the same way we do for object literals. Second, we add the constraint \nReal(Fldproto (Xprotoi , Xprotoi )) .Xi that stores the prototype object in the proto .eld of the function \nobject. Third, we add the constraint Xconsi . Real(Fldproto (Xprotoi , O)), which has the effect of writing \nthe prototype object into the proto .eld of any objects that .ow to consi. Function Calls. For each function \ncall, we generate a constraint that uses constructor matching to pull out the set of actual functions \nreaching the callsite, and uses variance to .ow the actuals (both explicit, and implicit due to indirect \n.ow) into the formals, and the return out to the callsite respectively [11]. The values .owed in for \nthe cons and this parameter differ depending on the the three kinds of function calls. For direct calls \nof the form f(e ' ), we use \u00d8 for the constructed object and the .ow variable corresponding to the global \nobject og for the this parameter.  For method calls of the form x.f(e ' ), we use constructor match\u00ading \nin a manner similar to .eld-reads, to pull out the appropriate functions that .ow to the callsite, and \nwe use the receiver object x as the this parameter.  For constructor calls of the form newi f(e ' ), \nwhich create a fresh object and call f with this bound to the fresh object, we introduce a new variable \nXi that represents the objects cre\u00adated at the callsite and set up its .elds as we do for object lit\u00aderals. \nNext, we use constructor matching to pull out the func\u00adtions that .ow to the callsite, and (via contravariance), \n.ow Xi into the constructed object parameter and this parameters of the callees. Finally, the last two \nconstraints .atten the con\u00adstructed object s prototype chain. Intuitively, the constraints add all .elds \nof an object s prototype chain into the object directly, while at the same time keeping track of which \n.elds actually belong to the object and which do not. To achieve this, we take each object that .ows \ninto the prototype .eld of the constructed object (Xi.proto ) either directly (i.e., wrapped under Real()) \nor via prototype-chains (i.e., wrapped under Pro()), and rewrap those objects under Pro() and .ow them \ninto the constructed object Xi.   4.3 Analyzing Real JavaScript Multi-parameter Functions. Functions \nin JavaScript can be in\u00advoked with any number of arguments, regardless of how many pa\u00adrameters the function \nis de.ned to accept; missing arguments are set to unde.ned and additional arguments are ignored.2 To \nmodel this in the implementation, we de.ne a common set constructor Funn() that, in addition to cons, \nthis, return, and taint parame\u00adters, takes n arguments, where n is the maximum number of ar\u00adguments across \nall function de.nitions and applications in the pro\u00adgram. When a de.nition or call in the program uses \nfewer than n arguments, we pad the remaining arguments with fresh constraint variables. We omit these \ndetails from the presentation since they are straightforward.  Iterative Field-Sensitivity. Due to the \n.exibility of JavaScript objects, we must assume that every object can have a binding for every possible \nstatic .eld. However, this na\u00a8ive approach does not scale, as the product of object count and .eld count \nis often very large. Instead, we perform an iterative .eld-sensitive analysis that tracks .elds on a \nper-object basis as needed. For each object, we begin by tracking only the .elds that we are certain \nwill exist based on the object de.nition. After solving the set constraints under these assumptions, \nwe check whether any objects .ow into accesses of .elds that were not being tracked. We add constructed \nterms for missing .elds as appropriate, and incrementally solve for the constraints again. Current Limitations. \nTracking reads and writes of dynamic .elds, i.e., array or dictionary lookups, is signi.cantly harder \nthan track\u00ading statically known .eld names. Modeling these accesses with a FldT set constructor, where \nT represents unknown .elds, makes the analysis unscalable, due to large numbers of accesses through integer \n.elds (for array objects) and complex string expressions that compute precise names of HTML elements \non the page. For the purposes of our analysis, we make the dynamically checkable as\u00adsumption that dynamically \ncreated .eld names, i.e., dynamically created array or hash table indices, do not clash with statically \nknown .eld names. Our current implementation also does not support several other features of JavaScript, \nbut these can be directly captured within our constraint-based SIF framework. These include the with \nstate\u00adment, which allows its body to be evaluated with a given object s .elds temporarily brought into \nscope, and call and apply forms that allow the programmer to explicitly set the this parameter of a function \ncall, which can be used to implement closure-based inher\u00aditance.  4.4 Residual Policy Generation We \nnow describe how we use our constraint-based .ow analysis to compute residual policies for holes. Recall \nthat the residual policy comprises a set of must-not read MNR and must-not write MNW variables and .elds. \nThus, at a high level, for con.dentiality (resp. integrity) policies, our goal is to .nd variables to \nwhich (resp. from which) the sensitive information may .ow, and then prohibit the client from reading \n(resp. writing) those variables. However, it turns out that several subtleties arise due to the com\u00adbination \nof higher-order functions, aliasing and the requirement that residual policy checking be ef.cient. We \nillustrate these issues using examples that motivate our algorithm for generating residual policies. \nFor the following examples, suppose we wish to enforce the con.dentiality policy stating that the document \ns cookie should not .ow into a hole. Functions. Intuitively, the residual policy needs to prevent the \nhole from reading any variable in the context that is tainted by the cookie. However, the residual policy \nmust also prevent the hole from writing certain variables. To illustrate, consider the following context: \n2 Whenever a function is called in JavaScript, the list of actuals provided is bound to a special variable \ncalled arguments available within the body. We model this behavior in our implementation. f = function(x) \n{ ... } f(document.cookie); That is, the context contains a function f that is called with the cookie \nas a parameter. Next, suppose that a hole is .lled with: f = function(x) { post(x); } That is, the hole \nrede.nes the function f with another function that broadcasts the argument x. If this code is dynamically \nloaded, it can overwrite the original trusted function f, and a policy violation will occur if the new \nfunction is called from the context. If we could re-analyze the entire source of the context and the \nhole at the client, then we would deduce that the call in the context .ows the cookie into the formal \nx of the new function de.ned in the hole. However, performing client-side .ow analysis on the entire \ncode each time a hole is loaded would make residual policy checking prohibitively inef.cient. Instead, \nwe observe that when a function s arguments receive con.dential values, we can guarantee con.dentiality \nby ensuring the function itself is not overwritten by the hole. Thus, even for con.dentiality policies, \ncertain variables, namely those holding function values whose arguments have been tainted, should not \nbe written by the hole. Dually, for integrity policies, the residual policy must also include both must-not-read \nand must-not-write sets. Aliasing. Consider a context that contains the following code snip\u00adpet, where \ntmp is not aliased to document: z = tmp.cookie; Hence, in the context, the value that .ows into z is \nnot sensitive. Next, suppose that a hole is .lled with tmp = document; ... post(z); That is, the hole \naliases tmp and document and as a result, the as\u00adsignment in the context can .ow the con.dential cookie \ninto the variable z, thereby leaking the con.dential information. Again, al\u00adthough re-analyzing the entire \nsource on the client would detect this leak, it would be prohibitively expensive. One option is to treat \nthe object x as con.dential if x.f is con.dential. Thus, we could treat document as con.dential since \ndocument.cookie is con.dential and prohibit any hole from reading document. However, this is far too \nrestrictive as it is perfectly safe and common for the hole to read document and its non-tainted .elds. \nInstead, when gener\u00adating a residual policy, we conservatively assume that once .eld f of some object \ncontains con.dential information, then all .elds named f contain con.dential information, no matter what \nobject they belong to. For our example, since document.cookie is con\u00ad.dential, we assume that tmp.cookie \nis con.dential, and hence z is con.dential, and so in the residual policy, we prevent the hole from reading \nz. Similarly, in this example, we would also prevent the hole from directly reading any .eld called cookie. \nThus, we can make the residual policy checking robust and ef.cient, even in the presence of aliasing, \nby unifying the taint information of each .eld f across all the objects that contain f, and preventing \nthe hole from accessing f. We now describe our constraint-based algorithm that analyzes a context in \norder to compute the MNR and MNW sets correspond\u00ading to the residual policy. For clarity of exposition, \nwe omit the indirect, real, and prototype wrappers, and we only describe how residual policies are generated \nfor con.dentiality policies it is straightforward to extend the method to integrity policies. Taint \nPropagation. To compute the MNR and MNW sets, we use two new covariant unary constructors NR() and NW(), \nwhich correspond to not-read and not-write taints. We seed the analysis by adding constraints that .ow \nthese new taint constructors into the variables of the con.dentiality policy. In particular:  for each \n(x, ) in the policy, NR(cx ) .Xx where cx is a special constant associated with x. We use unary con\u00adstructors \nwith these special constants as arguments so that we can we can later de.ne .lter (i.e., .A,B ) constraints. \nIn addition to the basic .ow constraints from Figure 8, which propagate these taint seeds throughout \nthe context code, we add new constraints to account for the subtleties described above. In particular, \nto han\u00addle higher-order functions, we contravariantly (resp. covariantly) propagate the taints from the \nfunction arguments (resp. return val\u00ad ues) to function de.nitions: for each fun-def labeled i, Xpi .NR,NW \nXi Xpi .NW,NR Xi Xreti .NR,NR Xi Xreti .NW,NW Xi where Xi, Xpi , and Xreti are the constraint variables \nrepresenting the .ows into the function labeled i, its formal parameter, and its return value respectively. \nFinally, to handle aliasing, we unify the taints across all objects containing a .eld f by creating a \nspecial variable Xf and generating the following constraints: for each object labeled i, Xi.f .NR,NR \nXf Xf .NR,NR Xi.f Xi.f .NW,NW Xf Xf .NW,NW Xi.f Residual Policy Generation. To compute the residual policy, \nwe solve the entire set of constraints, that is, the basic .ow constraints augmented with the constraints \nabove. Intuitively, if a NR() (resp. NW()) constructor .ows into the constraint variable Xx corre\u00adsponding \nto the program variable x, then the variable is added to the MNR (resp. MNW ) set of the residual policy. \nLet S be the constraint solution. We write S f t . X if the solution S maps the constraint variable X \nto a set containing the term t. The must\u00adnot-read and must-not-write sets of the residual policy are \nde.ned: . MNR = { x | S f NR(\u00b7) . Xx }. (Not-Read-Variables) { f | S f NR(\u00b7) . Xf } (Not-Read-Fields) \n. MNW = { x | S f NW(\u00b7) . Xx }. (Not-Write-Variables) { f | S f NW(\u00b7) . Xf } (Not-Write-Fields) That \nis, a variable or .eld must not be read (resp. written) if the not\u00adread taint (resp. not-write taint) \nconstructor .ows to the constraint variable corresponding to the variable or .eld. Residual Policy Checking. \nTo verify that a hole satis.es a residual policy, we perform a syntactic check that none of the variables \nor .elds in MNR (resp. MNW ) are read (resp. written) in the hole. 5. Evaluation In this section, we \ndescribe experiments (Section 5.1) that validate three hypotheses about our approach: our information \n.ow analysis using set constraints scales to real world JavaScript (Section 5.2); our staged information \n.ow approach creates residual checks that are much smaller and faster than the full analysis, making \nthem practical for running on the client side (Section 5.3); and our in\u00ad formation .ow analysis is precise \nenough to track useful properties (Section 5.4). 5.1 Experiments We have implemented a static, constraint-based \ninstantiation of the SIF framework for JavaScript. Our analysis is currently a stan\u00addalone tool, not \nyet integrated within a browser. As a result, we do not have automatic support for staging when a script \nis loaded dynamically. Instead, for the purposes of evaluation, we have im\u00adplemented a Firefox browser \nextension that intercepts all dynamic code loading calls, and inlines the new code in the surrounding \ncontext. The subsequent static analysis proceeds as if the dynamic content had been there originally. \nOnce our analysis engine is com\u00adbined with the browser, a dynamically loaded script will instead trigger \nthe staged analysis. We use the JSure parser [3] as a front-end to parse JavaScript source into OCaml \nabstract syntax trees, over which we generate constraints. We use the Banshee [20] constraint solver \nto build and solve constraints. The Firefox extension is written in approximately 500 lines of JavaScript, \nthe Banshee bindings in 400 lines of C and OCaml, and the staged information .ow tool in about 6,000 \nlines of OCaml. Benchmarks, policies and holes. We used our Firefox extension to collect the closed-program \nsource for all the web sites from the Alexa top 100 list [1]. Alexa is a company that tracks web page \ntraf.c, and generates the lists of the most popular 100 web sites by country and by language. We ran \nour staging engine on all 100 sites in the top 100 English pages. We checked two policies on each web \nsite: (1) a con.dentiality policy stating that the cookie value should not .ow into the hole, and (2) \nan integrity policy stating that no values from the hole should .ow into the location bar. These policies \nare general enough that they apply to any web site, making it easier to systematically run on all the \nAlexa web sites. For each web site, we systematically identi.ed holes as any scripts originating from \na different domain than the site s. Each closed-program we collected is a snapshot of whatever JavaScript \nexecuted on that particular run; subsequent visits to the same page would likely contain different dynamic \ncode to populate the hole. For each benchmark, we .rst ran our information .ow analysis on the entire \nprogram. We then generated the residual policy for the holes that we identi.ed, and performed the residual \nchecks on the code in the hole. This simulated the situation where holes are not available at the .rst \nstage, but are made available at the second stage. Summary of results. Of the 100 sites in the Alexa \nlist, 97 had JavaScript, 64 had holes in them, and of the ones with holes in them, we were able to parse \n63. Our full unstaged analysis suc\u00adcessfully completed on all 63, and our staged analysis successfully \ncompleted on 62 of these. The one benchmark that our staged anal\u00adysis failed on (by running out of memory \nwhile generating the residual policy) is the largest benchmark in the Alexa top 100, namely wsj with \n43,698 lines of JavaScript (which is twice as large as the next largest benchmark).  5.2 Performance \nof Unstaged Analysis Figure 9 plots lines of code vs. running time of the unstaged full analysis for \nthe cookie con.dentiality policy; the plot for the integrity policy follows similar trends. Our data \nshows that, for benchmarks up to 13,000 lines of code (which accounts for about 80% of the benchmarks) \nthe running time does not grow very fast, and stays under twelve seconds. Nevertheless, these times are \ntoo slow to run on the client side each time that a new hole is .lled. Beyond 13,000 lines of code, even \nthough the running time grows much faster, our unstaged full analysis still scales to the largest of \nJavaScript programs in the Alexa top 100 (76.0 seconds for 43,698 lines of JavaScript). Most of the benchmarks \nthat take over a minute Figure 9. Analysis time (seconds) of unstaged analysis for cookie policy vs. \nlines of code.  to analyze make heavy use of prototypes. This observation points to an area of possible \nperformance tuning for future work.  5.3 Performance and Bene.ts of Staging Figure 10 shows some of \nthe results from the 62 benchmarks on which our staged analysis ran. The last line of the table, however, \naverages over all benchmarks. The columns in the table are as follows: Site and rank gives the name of \nthe web site and its rank in the top 100 list; Total LOC gives the number of lines of code on the web \nsite, including the hole, as formatted by our own JavaScript pretty-printer; Hole LOC gives the number \nof lines of code in the hole; Full gives the time it took to run our unstaged information .ow analysis \non the entire JavaScript program; GenRes gives the time it took our analysis to generate the residual \nchecks for the holes that we identi.ed; ChkRes gives the time it took to perform the residual checks \non the code from the holes; FF states whether or not the unstaged information .ow analysis found any \n.ow for the given policy (. indicates .ow, \u00d7 indicates no-.ow); RF states whether or not the residual \nchecks found any .ow for the given policy. All times are in seconds. In general, the time for computing \nresidual policies is on the same order of magnitude as the time for running the unstaged full analysis. \nEven though the residual policy generation uses more kinds of constraints, it does not always take longer \nto solve, because only the context is being analyzed, which is smaller than the entire code that the \nunstaged analysis ran on. Our data shows that all residual checks run under one second, and most run \nunder one tenth of a second. The residual checks are performed in a single pass along with parsing, so \nin fact most of the time for performing residual checks lies in the parsing, which must be done anyway. \nOur current implementation uses a parser generator that is not optimized for speed, which leaves room \nfor performance improvements. As a result, residual checks would add only minimal overhead to run in \na client browser, especially if we further tune the perfor\u00admance of our checker. Our data also shows \nthat residual checks are about two orders of magnitude faster than the full analysis, which on average \nruns in 9.9 seconds, and thus would be too slow to run in a client browser. These observations together \npoint to the bene.t of staging: the full analysis would be too slow to run on the client browser, but \nif the developer could run the .rst stage of the analy\u00adsis, then the remaining checks are fast enough \nto be run in the client browser.  5.4 Precision In order to assess the precision of our unstaged analysis, \nwe ran\u00addomly sampled 17 of the benchmarks for the cookie-.ow policy, of which 5 reported that the cookie \ndoes not .ow into a hole. A manual inspection of these examples reveals that this is indeed the case. \nBy looking at the code of the remaining 12 benchmarks, we determined that 8 of them contained holes that \nread, and even mod\u00adi.ed, the cookie. Many of these sites included scripts from popular ad services, such \nas GoogleSyndication and QuantServe, and data tracking services, like GoogleAnalytics. These services \nmake use of cookies as a persistent storage for statistics across multiple page visits. The reported \n.ow on the remaining 4 benchmarks were false positives in our unstaged analysis, which were all caused \nby the lack of context-sensitivity. For example, if the cookie and an un\u00adrelated string both .ow into \nthe same function, and this function .ows its argument to its return value, then both strings will .ow \nto the returning call sites, smearing the actual .ows. Techniques for extending set constraint-based \nprogram analysis with context sen\u00adsitivity would help in this situation. We evaluate the precision of \nour staged analysis by comparing its results ( RF column in Figure 10) with the unstaged version ( FF \ncolumn). In general, the answer to whether the policy is violated should be the same in both unstaged \nand staged modes, and this is indeed the case for most of our benchmarks. However, there are several \nbenchmarks on which this is not the case. For con.dentiality policies, there are 4 benchmarks for which \nthe unstaged analysis .nds no .ow, but the staged one reports .ow. For integrity, there are 8 such benchmarks. \nIn each of these cases, the residual analysis reports a spurious .ow because of how we conservatively \ntaint .elds when generating residual policies. As expected, there are no cases in which the unstaged \nanalysis reports .ow but the staged analysis reports no .ow. 6. Related Work Static Information Flow. \nThere is a rich literature on modeling se\u00adcurity properties using information .ow [15]. Many of these \nideas are manifested as static language-based techniques for ensuring that the values of high security \nvalues do not .ow into low secu\u00adrity outputs. These include type systems [33, 25], Hoare-logics [5], \nand safety (model) checking [30]. Dually, there are techniques for checking that low-security (i.e., \ntainted) values do not .ow to safety critical operations. These include the use of type quali.ers [28] \nand data.ow analysis [21]. Unfortunately, these techniques work on closed programs (or require summaries \nor stubs for missing code), and further, often rely on underlying structure like types, and hence cannot \nbe applied directly to JavaScript. Dynamic Information Flow. Several dynamic techniques for in\u00adformation \n.ow control have been proposed at the language, operat\u00ading system and architecture levels. The type system \nof [23] allows the speci.cation and dynamic enforcement of richer .ow and ac\u00adcess control policies including \nthe dynamic creation of principals and declassi.cation of high-security information. These ideas can\u00adnot \nyet be applied in our setting as they require a closed system, written in a statically typed language \n(Java), and further, annota\u00adtions must be provided to specify and verify the policies. There are several \nprojects that use dynamic tainting, either via binary rewrit\u00ading [24], at the architecture level [29, \n32], or using virtual machines [8]. We leave the implementation of a dynamic instantiation of our framework, \npossibly for enforcing the residual policy checks, as an avenue for future work. However, we conjecture \nthat dynamically tracking .ows is likely to incur a signi.cant run time overhead, and hence, is not a \nlikely candidate for client-side deployment. Sev\u00aderal recent projects [9, 37] propose expressive OS mechanisms \nfor information .ow control. Here the goal is to provide abstractions that allow application developers \nto specify policies about where data generated by the process should be allowed to .ow. These ap\u00adproaches \nare too coarse-grained to be applicable to our setting.  Site and rank Total LOC Hole LOC Flow from \ncookie to hole? Flow from hole to location bar? Full GenRes ChkRes FF RF Full GenRes ChkRes FF RF 3. \nmyspace 22,469 3,484 77.4 27.4 0.52 . . 105.3 37.2 0.52 \u00d7 \u00d7 4. youtube 7,187 779 3.7 4.4 0.20 \u00d7 \u00d7 3.6 \n4.8 0.18 \u00d7 . 10. aol 4,714 255 2.1 2.9 0.06 . . 2.1 3.4 0.06 \u00d7 \u00d7 13. go 904 60 0.5 0.9 0.03 \u00d7 \u00d7 0.5 0.9 \n0.03 \u00d7 \u00d7 15. cnn 15,445 3,472 71.4 18.0 0.52 . . 83.1 30.4 0.54 \u00d7 . 16. espn.go 7,155 28 4.0 7.0 0.03 \n\u00d7 \u00d7 4.0 8.2 0.03 \u00d7 \u00d7 18. flickr 747 713 0.3 0.1 0.12 \u00d7 \u00d7 0.3 0.2 0.12 \u00d7 \u00d7 24. imdb 556 13 0.3 0.5 0.02 \n\u00d7 \u00d7 0.3 0.6 0.02 \u00d7 \u00d7 28. weather 20,104 232 76.8 106.5 0.12 . . 72.5 200.6 0.09 . . 35. foxnews 13,589 \n70 14.7 30.7 0.10 . . 15.0 50.6 0.04 \u00d7 \u00d7 42. doubleclick 3,259 1,203 1.5 1.2 0.21 . . 1.4 1.4 0.21 \u00d7 \n\u00d7 43. bbc.co.uk 8,639 41 3.9 7.5 0.03 . . 3.9 8.6 0.02 \u00d7 \u00d7 44. walmart 13,174 101 7.0 22.0 0.09 . . 7.2 \n55.5 0.07 . . 46. rr 2,545 70 1.1 1.8 0.05 . . 1.1 3.3 0.03 \u00d7 \u00d7 47. target 10,532 61 4.0 7.0 0.04 . . \n4.0 8.1 0.04 \u00d7 \u00d7 48. netflix 9,879 27 4.4 8.4 0.03 \u00d7 \u00d7 4.5 9.8 0.02 \u00d7 \u00d7 49. nfl 10,485 170 8.4 16.8 0.03 \n\u00d7 \u00d7 8.4 21.2 0.03 \u00d7 \u00d7 57. hulu 14,476 545 25.9 42.1 0.11 . . 28.2 131.4 0.12 \u00d7 \u00d7 58. verizon.net 3,456 \n167 1.5 2.1 0.05 . . 1.5 2.4 0.04 \u00d7 \u00d7 62. disney.go 3,383 6 1.9 3.3 0.03 \u00d7 \u00d7 1.9 3.8 0.02 \u00d7 \u00d7 63. bestbuy \n10,975 3,916 8.2 10.6 0.76 . . 8.7 290.0 0.80 \u00d7 . 64. msn.foxsports 6,838 490 4.2 7.0 0.14 . . 4.2 16.1 \n0.18 \u00d7 . 67. cnet 10,598 242 7.2 22.6 0.17 . . 7.3 29.2 0.06 \u00d7 \u00d7 71. linkedin 7,964 1,816 3.9 3.4 0.32 \n\u00d7 \u00d7 3.9 3.6 0.29 . . 75. gamespot 13,041 1,491 11.8 23.6 0.32 . . 11.5 30.6 0.28 \u00d7 \u00d7 77. veoh 9,742 86 \n6.5 13.1 0.07 \u00d7 . 6.6 32.6 0.04 \u00d7 \u00d7 79. latimes 8,225 55 6.8 9.9 0.04 . . 6.8 11.7 0.03 \u00d7 . 80. nbc 7,644 \n74 5.8 8.5 0.04 \u00d7 \u00d7 5.8 10.4 0.04 \u00d7 \u00d7 87. reuters 4,049 258 1.7 2.4 0.06 . . 1.7 2.6 0.06 \u00d7 \u00d7 88. imeem \n12,050 194 4.6 7.9 0.04 \u00d7 \u00d7 4.6 8.7 0.04 \u00d7 \u00d7 89. gamefaqs 365 77 0.2 0.3 0.03 \u00d7 \u00d7 0.2 0.3 0.03 \u00d7 \u00d7 90. \ntinypic 6,658 64 3.9 6.0 0.03 \u00d7 \u00d7 4.0 6.6 0.03 \u00d7 \u00d7 92. abcnews.go 14,330 246 9.9 18.0 0.07 \u00d7 . 9.8 21.4 \n0.08 \u00d7 . 99. dailymotion 11,709 379 10.9 19.3 0.08 \u00d7 . 10.8 30.4 0.08 \u00d7 \u00d7 100. people 6,152 261 3.4 4.8 \n0.07 . . 3.4 6.8 0.06 \u00d7 \u00d7 Average 7,979 597 9.9 14.0 0.13 10.7 28.4 0.12 Figure 10. Sample results from \nAlexa web sites with holes. Average numbers are for all benchmarks (including those not in the table), \nand times reported are in seconds.  Analyzing JavaScript. Several authors have studied the prob\u00adlem \nof analyzing JavaScript. Some of the idiosyncratic features of JavaScript are described in [31], which \nalso presents a type system for statically checking JavaScript programs. Further, [6] describes an algorithm \nfor inferring types for JavaScript programs. However, it is unclear whether JavaScript programs in the \nwild satisfy the typing disciplines described in these works. Neither approach deals with dynamically \ngenerated code, and hence cannot directly be ap\u00adplied to our setting. The interaction of JavaScript and \nweb browsers is studied in [36], which presents a formal semantics of the inter\u00ad action, and uses it \nto describe a general framework for dynamically verifying arbitrary safety properties inside the browser. \nGatekeeper [22] is a static analysis framework for JavaScript that focuses on performing analysis in \na single stage (e.g., on the server). In con\u00adtrast, our primary focus is on developing residual checks \nthat spec\u00adify how dynamically loaded code should behave in order for the system to satisfy high-level \n.ow policies. Web and Browser Security. Several recent projects have consid\u00adered the problem of securing \nweb applications via browser and lan\u00adguage mechanisms. Many vulnerabilities arise from not appropri\u00adately \nsanitizing user generated content on the server side. Several server-side tools apply static analysis \nto determine whether user generated content has been properly vetted [19, 35, 34]. To en\u00ad sure safety \non the client side, one simple and elegant approach is to only allow previously known and authorized \nscripts to run on a web page [18]. Unfortunately, this makes it harder to use dynam\u00ad ically generated \nthird-party content, and hence is not applicable in our setting. Finally, there have been several proposals \nfor re\u00addesigning the ecosystem within which web-applications are built and deployed [4, 2, 7]. In essence \nthese approaches advocate that web-applications be built in higher-level languages like C., Java and \nJIF respectively, thereby availing of the protection mechanisms available in those languages. It remains \nto be seen whether web\u00adapplication developers are willing to trade the .exibility and rapid\u00adprototyping \nstrengths of JavaScript for the security bene.ts offered by strongly typed languages. Set Constraint-based \nProgram Analysis. Set constraints provide an expressive framework within which many kinds of program \nanalyses including points-to analyses [14, 16], type quali.er in\u00ad ference [13], race detection [26], \nand uncaught exceptions [10]. Our contribution is to show that this expressive framework is espe\u00adcially \nsuited to capturing the complexities of JavaScript including .elds and higher-order functions, and that \nafter using optimizations like the optimistic .eld analysis the resulting analysis scales to the JavaScript \nthat powers most popular websites.  References [1] English: Alexa top 100 sites, November 2008. http://www.alexa. \ncom/. [2] Google web toolkit, November 2008. http://code.google.com/ webtoolkit/. [3] Jsure, November \n2008. http://www.jsure.org/. [4] Volta, November 2008. http://live.labs.com/volta. [5] T. Amtoft and \nA. Banerjee. Information .ow analysis in logical form. In SAS, pages 100 115, 2004. [6] C. Anderson, \nP. Giannini, and S. Drossopoulou. Towards type inference for javascript. In ECOOP, pages 428 452, 2005. \n[7] S. Chong, J. Liu, A. C. Myers, X. Qi, K. Vikram, L. Zheng, and X. Zheng. Secure web application via \nautomatic partitioning. In SOSP, pages 31 44, 2007. [8] J. Chow, B. Pfaff, T. Gar.nkel, K. Christopher, \nand M. Rosenblum. Understanding data lifetime via whole system simulation. In USENIX Security Symposium, \npages 321 336, 2004. [9] P. Efstathopoulos, M. Krohn, S. VanDeBogart, C. Frey, D. Ziegler, E. Kohler, \nD. Mazi` eres, F. Kaashoek, and R. Morris. Labels and event processes in the asbestos operating system. \nIn SOSP. ACM, 2005. [10] M. F\u00a8ahndrich and A. Aiken. Program analysis using mixed term and set constraints. \nIn SAS, pages 114 126, 1997. [11] M. F\u00a8ahndrich, J. S. Foster, A. Aiken, and J. Cu. Tracking down exceptions \nin standard ml programs. Technical report, EECS Department, UC Berkeley, 1998. [12] C. Flanagan and M. \nFelleisen. Componential set-based analysis. ACM Trans. Program. Lang. Syst., 21(2):370 416, 1999. [13] \nJ. S. Foster, M. F\u00a8ahndrich, and A. Aiken. A theory of type quali.ers. In PLDI. ACM, 1999. [14] J. S. \nFoster, M. F\u00a8 Polymorphic versus ahndrich, and A. Aiken. monomorphic .ow-insensitive points-to analysis \nfor c. In SAS, 2000. [15] J. A. Goguen and J. Meseguer. Security policies and security models. In IEEE \nSymposium on Security and Privacy, pages 11 20, 1982. [16] B. Hardekopf and C. Lin. The ant and the grasshopper: \nfast and accurate pointer analysis for millions of lines of code. In PLDI, 2007. [17] D. Herman and C. \nFlanagan. Status report: specifying javascript with ml. In ML, pages 47 52, 2007. [18] T. Jim, N. Swamy, \nand M. Hicks. Defeating script injection attacks with browser-enforced embedded policies. In WWW, 2007. \n[19] N. Jovanovic, C. Kr\u00a8ugel, and E. Kirda. Pixy: A static analysis tool for detecting web application \nvulnerabilities (short paper). In IEEE Symposium on Security and Privacy, 2006. [20] J. Kodumal and A. \nAiken. Banshee: A scalable constraint-based analysis toolkit. In SAS, pages 218 234, 2005. [21] M. S. \nLam, M. Martin, V. B. Livshits, and J. Whaley. Securing web applications with static and dynamic information \n.ow tracking. In PEPM, pages 3 12, 2008. [22] B. Livshits and S. Guarnieri. Gatekeeper: Mostly static \nenforcement of security and reliability policies for javascript code. Technical Report MSR-TR-2009-16, \nMicrosoft Research, Feb. 2009. [23] A. C. Myers. Programming with explicit security policies. In ESOP, \npages 1 4, 2005. [24] J. Newsome and D. X. Song. Dynamic taint analysis for automatic de\u00adtection, analysis, \nand signature generation of exploits on commodity software. In NDSS, 2005. [25] F. Pottier and V. Simonet. \nInformation .ow inference for ml. In POPL, pages 319 330, 2002. [26] P. Pratikakis, J. S. Foster, and \nM. Hicks. Locksmith: context-sensitive correlation analysis for race detection. In PLDI. ACM, 2006. [27] \nN. Provos, D. McNamee, P. Mavrommatis, K. Wang, and N. Modadugu. The ghost in the browser analysis of \nweb-based malware. In HotBots, 2007. [28] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. Detecting \nformat string vulnerabilities with type quali.ers. In USENIX Security, 2001. [29] G. E. Suh, J. W. Lee, \nD. Zhang, and S. Devadas. Secure program execution via dynamic information .ow tracking. In ASPLOS, 2004. \n[30] T. Terauchi and A. Aiken. Secure information .ow as a safety problem. In SAS, pages 352 367, 2005. \n[31] P. Thiemann. Towards a type system for analyzing javascript programs. In ESOP, pages 408 422, 2005. \n[32] N. Vachharajani, M. J. Bridges, J. Chang, R. Rangan, G. Ottoni, J. A. Blome, G. Reis, M. Vachharajani, \nand D. I. August. Ri.e: An architectural framework for user-centric information-.ow security. In MICRO, \n2004. [33] D. Volpano and G. Smith. Verifying secrets and relative secrecy. In POPL, 2000. [34] G. Wassermann \nand Z. Su. Static detection of cross-site scripting vulnerabilities. In ICSE, pages 171 180, 2008. [35] \nY. Xie and A. Aiken. Scalable error detection using boolean satis.ability. In POPL, pages 351 363, 2005. \n[36] D. Yu, A. Chander, N. Islam, and I. Serikov. Javascript instrumenta\u00adtion for browser security. In \nPOPL, pages 237 249, 2007. [37] N. Zeldovich, S. Boyd-Wickizer, and D. Mazi`eres. Securing distributed \nsystems with information .ow control. In NSDI, 2008.    \n\t\t\t", "proc_id": "1542476", "abstract": "<p>Modern websites are powered by JavaScript, a flexible dynamic scripting language that executes in client browsers. A common paradigm in such websites is to include third-party JavaScript code in the form of libraries or advertisements. If this code were malicious, it could read sensitive information from the page or write to the location bar, thus redirecting the user to a malicious page, from which the entire machine could be compromised. We present an information-flow based approach for inferring the effects that a piece of JavaScript has on the website in order to ensure that key security properties are not violated. To handle dynamically loaded and generated JavaScript, we propose a framework for staging information flow properties. Our framework propagates information flow through the currently known code in order to compute a minimal set of syntactic residual checks that are performed on the remaining code when it is dynamically loaded. We have implemented a prototype framework for staging information flow. We describe our techniques for handling some difficult features of JavaScript and evaluate our system's performance on a variety of large real-world websites. Our experiments show that static information flow is feasible and efficient for JavaScript, and that our technique allows the enforcement of information-flow policies with almost no run-time overhead.</p>", "authors": [{"name": "Ravi Chugh", "author_profile_id": "81435596644", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1464227", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey A. Meister", "author_profile_id": "81435611864", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1464228", "email_address": "", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1464229", "email_address": "", "orcid_id": ""}, {"name": "Sorin Lerner", "author_profile_id": "81100399150", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1464230", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542483", "year": "2009", "article_id": "1542483", "conference": "PLDI", "title": "Staged information flow for javascript", "url": "http://dl.acm.org/citation.cfm?id=1542483"}