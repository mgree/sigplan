{"article_publication_date": "06-15-2009", "fulltext": "\n A Decision Procedure for Subset Constraints over Regular Languages * Pieter Hooimeijer and Westley \nWeimer University of Virginia {pieter, weimer}@cs.virginia.edu Abstract Reasoning about string variables, \nin particular program inputs, is an important aspect of many program analyses and testing frame\u00adworks. \nProgram inputs invariably arrive as strings, and are often manipulated using high-level string operations \nsuch as equality checks, regular expression matching, and string concatenation. It is dif.cult to reason \nabout these operations because they are not well-integrated into current constraint solvers. We present \na decision procedure that solves systems of equa\u00adtions over regular language variables. Given such a \nsystem of con\u00adstraints, our algorithm .nds satisfying assignments for the variables in the system. We \nde.ne this problem formally and render a mech\u00adanized correctness proof of the core of the algorithm. \nWe evaluate its scalability and practical utility by applying it to the problem of automatically .nding \ninputs that cause SQL injection vulnerabili\u00adties. Categories and Subject Descriptors D.2.4 [Software \nEngineer\u00ading]: Software/Program Veri.cation Validation; D.2.4 [Software Engineering]: Software/Program \nVeri.cation Model checking; F.3.1 [Logics and Meanings]: Specifying and Verifying and Rea\u00adsoning about \nPrograms Mechanical veri.cation General Terms Algorithms, Languages, Theory, Veri.cation 1. Introduction \nA large class of programs uses string variables to produce struc\u00adtured output, such as XML, SQL, or code \n[42]. Bugs in these pro\u00adgrams can often be characterized by the subversion of that intended structure \n[41]. Two compelling examples of this type of bug are SQL injection and cross-site scripting vulnerabilities. \nThese vul\u00adnerabilities are common; together they accounted for 35.5% of re\u00adported vulnerabilities in \n2006 [21]. Reasoning about these bugs (e.g., for static detection) often involves the explicit modeling \nof possible runtime string values [32, 43, 44, 47]. * This research was supported in part by National \nScience Foundation Grants CNS 0627523 and CNS 0716478 and Air Force Of.ce of Scienti.c Research grant \nBAA 06-028, as well as gifts from Microsoft Research. The information presented here does not necessarily \nre.ect the position or the policy of the government and no of.cial endorsement should be inferred. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 09, June 15 \n20, 2009, Dublin, Ireland. Copyright c . 2009 ACM 978-1-60558-392-1/09/06. . . $5.00 We present a novel \ndecision procedure for solving equations that involve sets of strings. We refer to the satisfaction problem \nfor these equations as the Regular Matching Assignments (RMA) prob\u00adlem. Our decision procedure computes \nsatisfying assignments for systems of equations that include regular language variables, con\u00adcatenation, \nand language inclusion constraints. It can be used as a constraint solver to push back constraints across \nstring opera\u00adtions. Many string variable operations, in particular equality checks and and regular expression \nmatches, can be translated directly to an RMA instance. The use of decision procedures is pervasive for \nmany classes of program analysis and automatic testing; the common practice of querying an external decision \nprocedure to reason about pointer aliases [34, 39] is a standard example. A decision procedure typi\u00adcally \ndeals with a particular theory, such as linear arithmetic, un\u00adinterpreted functions, or bitwise operations. \nThere are well-known frameworks for combining decisions procedures (e.g., [36]). Decision procedures \nare often associated with constraint solvers. Formally, the constraint satisfaction problem returns a \nsatisfying assignment while a decision problem returns a boolean; in practice many decision procedures \nreturn witnesses as well. The satis.abil\u00adity modulo theories problem is a generalization of SAT [33, \n48] that includes theories as well as literals and .rst-order logic [13, 40]. Recent work in this area \nhas focused on adding theories, such as support for reasoning about bit vectors [13]. We similarly offer \na procedure that allows for high-level reasoning about a theory of sets of strings. We foresee several \nimmediate applications of our algorithm: Directed randomized testing. A number of recent projects use \nsimultaneous concrete and symbolic execution to automate test\u00ading [16, 17, 18, 30, 38]. This is commonly \nreferred to as con\u00adcolic testing or whitebox fuzzing. These techniques rely heav\u00adily on constraint solvers \nto help reverse engineer inputs that lead to a given symbolic execution state and exercise a desired \nprogram path. Dealing with strings at a high level could signif\u00adicantly improve the precision of the \nconstraint solving step in these frameworks.  Indicative testcase and path slice generation. Bug reports, \nin particular those that are automatically generated, often go un\u00adaddressed for longer if the report \ndoes not include an indicative testcase [22, 46]. Program analyses that detect bugs can often be extended \nto generate indicative testcases [4]. Additionally, a program slice that elides irrelevant statements \nmay further help a developer to understand a bug report [23].  In this paper, we show how our decision \nprocedure can be used to extend the output of an existing bug .nder [43] for SQL injection vulnerabilities. \nWe use the output of that tool to generate actual Figure 1. SQL code injection vulnerability example \nadapted from Utopia News Pro. The $ POST mapping holds untrusted user\u00adsubmitted data.  1 $ n e w s i \nd = $ _ P O S T [ p o s t e d _ n e w s i d ] ; 2 i f ( ! p r e g _ m a t c h ( / [ \\ d ]+ $ / , \n$ n e w s i d ) ) { 3 u n p _ m s g B o x ( I n v a l i d a r t i c l e n e w s I D . ); 4 e x i t \n; 5 } 6 $ n e w s i d = \" n i d _ \" . $ n e w s i d ; 7 $ i d n e w s = q u e r y ( \" S E L E C T * F \nR O M n e w s \" . 8 \" W H E R E n e w s i d = $ n e w s i d \" ) ; HTTP GET and POST parameters that \nwould exploit the reported vulnerability. The main contributions of this paper are:  A formal decision \nprocedure for regular language variables subject to concatenation and subset constraints.  A mechanized \nproof of the correctness of the core of that deci\u00adsion procedure.  A concrete example that demonstrates \nhow our analysis can be used directly to address a program analysis problem: .nding inputs for SQL code \ninjection vulnerabilities. We include ex\u00adperimental evidence on 30,000 lines of code with 17 con.rmed \nvulnerabilities to demonstrate the utility of our procedure.  The structure of this paper is as follows. \nIn Section 2 we pro\u00advide example code that exhibits an SQL injection vulnerability, and show how our \ndecision procedure might be applied. Section 3 formally presents our decision procedure, building up \nfrom the Concatenation-Intersection problem (Section 3.2) to general sys\u00adtems of subset constraints (Section \n3.4). Section 4 reports experi\u00admental results, and Section 5 brie.y surveys closely-related work. 2. \nMotivating Example In this section, we present a code fragment adapted from an exist\u00ading application \nwritten in PHP. This code exhibits an SQL injec\u00adtion vulnerability, and demonstrates the need for analyses \nthat are able to reason about the run-time values of string variables. More concretely, the code leads \ndirectly to a series of equations that our decision procedure can solve. The solutions are regular languages \ndescribing a set of inputs that exploit the SQL injection vulnera\u00adbility; the inputs can be used to construct \ntestcases and understand the defect. While our decision procedure is more widely applicable (e.g., to \ncross-site scripting or XML generation [21, 42]), we will use SQL injection as a running example. Figure \n1 shows a code fragment adapted from Utopia News Pro, a news management web service written in PHP. The \n$ POST array holds values that are submitted by the user as part of an HTTP request. A number of static \nanalyses will (correctly) detect a potential vulnerability on line 7. The check on line 2 is designed \nto limit $newsid to numbers: [\\d]+ is a regular expression for a non-empty sequence of consecutive digits. \nThe preg match function uses the delimiters $ and ^ to match the end and the beginning of the string \nrespectively. However, the check on line 2 is missing the ^ marker. Thus it is possible that the query \nsent on line 7 might be, for example, \"SELECT * from news WHERE newsid= nid OR 1=1 ; DROP news -\u00ad9 \". \nThat particular query returns all entries in the news table to the attacker, and then deletes the table \n(the --begins a comment in SQL). Although the vulnerability is real, it may not be obvious to developers \nhow an untrusted user can trigger it. For example, set\u00adting posted newsid to \" OR 1=1 ; DROP news --\" \nfails to trigger it, instead causing the program to exit on line 4. S ::= E . C subset constraint E ::= \nE . E language concatenation || C V C V ::= ::= c1| . . . |cn v1| . . . |vm constants variables Figure \n2. Grammar for subset constraints over regular languages. The right-hand side (some element of C) is \na single constant. The constants c1 ...cn and variables v1 ...vm each represent a regular language. The \ngoal is to .nd satisfying assignments for the variables. Conventional development relies heavily on regression \ntesting and reproducible defect reports; a testcase demonstrating the vul\u00adnerability makes it more likely \nthat the defect will be .xed [22, 46]. We therefore wish to form a testcase that exhibits the problem \nby generating values for input variables, such as: posted_newsid = OR 1=1 ; DROP news --9 posted_userid \n= a To .nd this set of input values, we consider the constraints imposed by the code: The input set \nmust pass the (incomplete) safety check on line 2.  The input set must result in an exploit of interest \non line 7.  This problem can be phrased as a constraint system over the string variables. In addition \nto the input set, our algorithm could reasonably be extended to produce a slice of the program with respect \nto the values that end up in the subverted query. In this case, the slice includes only lines 1 and 2, \nhelping the developer locate potential causes of the error [4]. The particular actions taken by the generated \nexploit (e.g., whether all entries are returned or a table is dropped or modi.ed) are a secondary concern. \nInstead, we want to allow analyses to detect the problem and generate a test case that includes string \ninput values and a viable execution path through the program that triggers the vulnerability. Finally, \nnote that if the program in Figure 1 were .xed to use proper .ltering, our algorithm would indicate that \nlanguage of vulnerable strings for posted_userid is empty (i.e., that there is no bug). With this running \nexample in mind, we will now formally de.ne the problem of interest and give our algorithm for solving \nit. 3. Constraint Solving Over Regular Languages In the following sections, we present our decision procedure \nfor subset and concatenation constraints over regular languages. In Section 3.1, we provide a formal \nproblem de.nition. The Regular Matching Assignments (RMA) problem de.nes the language con\u00adstraints of \ninterest, and also what constitutes a satisfying assign\u00adment for such a system of equations. Next, in \nSection 3.2, we de.ne the Concatenation-Intersection (CI) problem, which we show to be a subclass of \nRMA. We provide an algorithm for solving instances of CI, and prove it correct in Section 3.3. In Section \n3.4, .nally, we extend the CI algorithm to general instances of RMA. 3.1 The Regular Matching Assignments \nProblem In this section we de.ne the Regular Matching Assignments (RMA) problem. The goal is to .nd satisfying \nassignments for certain sys\u00adtems of equations over regular languages. These systems consist of some number \nof constant languages and some number of lan\u00adguage variables, combined using subset constraints and language \nconcatenation.  More concretely, the example introduced in Section 2 can be expressed as the following \nset of constraints: v1 . c1 c2 . v1 . c3 where c1 corresponds to the input .ltering on line 2, c2 corresponds \nto the string constant nid on line 6, and c3 corresponds to unde\u00adsired SQL queries. If we solve this \nsystem, then variable v1 is the set of user inputs that demonstrate the vulnerability. If this set is \nempty, then the code is not vulnerable. If v1 is nonempty, then we can use it to understand the problem \nand to generate testcases. Figure 2 provides the general form of the subset constraints of interest. \nFormally, let an RMA problem instance I = {s1,...,sp}be a set of constraints over a shared set of variables \n{v1,...,vm}. Each element si . I is a subset constraint of the form ei . ci, with ei derivable from E \nin Figure 2 and ci derivable from C. We write A =[v1 . x1,...,vm . xm] for an assignment of regular languages \n{x1,...,xm} to variables {v1,...,vm}; let A[vi]= xi. Finally, let L(r) denote the language of regular \nexpression r. If d is a variable-free expression derivable from E in Figure 2, then let [ d ] denote \nthe regular language obtained by evaluating d. If d. is an expression with variables {v1,...,vm}, then \nlet [ d. ] A be the regular language obtained by .rst substituting all occur\u00adrences of {v1,...,vm} in \nd. with their corresponding assignments in A. We say that an assignment A satis.es I if and only if: \n1. Satisfying: 1 = i = p . [ ei ] A . [ ci ] ; and 2. Maximal: for each variable vi, the corresponding \nlanguage A[vi] cannot be extended without violating (1).  Given a problem instance I, the RMA problem \nrequires either (1) a satisfying assignment; or (2) a message that no satisfying assignment exists. In \nsome cases we may, additionally, be interested in all unique satisfying assignments; in Section 3.2 we \nshow that the number of assignments is .nite. 3.1.1 Examples Consider the following example over the \nalphabet symbols x, y. v1 . L((xx)+ y) v1 . L(x * y) The correct satisfying assignment for this set of \nequations is [v1 . L((xx)+ y)]. The .rst condition, Satisfying, ensures that A assigns regular languages \nto language variables in a way that respects the input system of equations. In the example, the potential \nsolution A =[v1 . L(xy)] fails to satisfy the condition because [ v1 ] A = L(xy) .. L((xx)+ y). The second \ncondition, Maximal, prevents solutions that do not capture enough information. In the example, the potential \nsolution [v1 .\u00d8] satis.es condition one but not two; it is not maximal because it can be extended to, \nfor example, [v1 . L(xxy)]. RMA instances may have more than one unique satisfying as\u00adsignment. For example, \nconsider the following system: v1 . L(x(yy)+) v2 . L((yy) * z) v1 . v2 . L(xyyz|xyyyyz) This set of constraints \nhas two disjunctive satisfying assignments: A1 =[v1 . L(xyy),v2 . L(z|yyz)] A2 =[v1 . L(x(yy|yyyy)),v2 \n. L(z)] Both A1 and A2 satisfy the satisfying and maximal properties. They are also inherently disjunctive, \nhowever; it is not possible to merge A1 and A2 without violating one or both properties. 1: concat intersect(c1,c2,c3)= \n2: Input: Machines M1, M2, M3 for c1, c2, c3; 3: each machine Mj = .Qj , S,dj ,sj ,fj . 4: Output: Set \nof assignments; each Ai =[v1 . xi. ,v2 . x .. i ] 5: // Construct intermediate automata 6: let l4 = c1 \n. c2 s.t. M4 = .Q1 . Q2, S,d4,s1,f2. 7: let l5 = l4 n c3 s.t. M5 = 8: .(Q1 . Q2) \u00d7 Q3, S,d5,s1s3,f2f3. \n9: // Enumerate solutions 10: let Qlhs = {f1q . | q . . Q3}. Q5 11: let Qrhs = {s2q . | q . . Q3}. Q5 \n12: foreach (qa,qb) . Qlhs \u00d7 Qrhs s.t. qb . d5(qa,.) do 13: let M1 . = induce from .nal(M5,q1) 14: let \nM2 . = induce from start(M5,q2) 15: output [v1 . M1. ,v2 . M2. ] 16: end for Figure 3. Constraint solving \nfor intersection across concatenation. The algorithm relies on basic operations over NFAs: concatena\u00adtion \nusing a single .-transition (line 3) and the cross-product con\u00adstruction for intersection (line 4). The \ntwo induce functions are de\u00adscribed in the text. 3.1.2 Extensions Our de.nition of RMA (and the algorithm \nwe provide to solve it) can be readily extended to support additional operations, such as union or substring \nindexing. For example, substring indexing might be used to restrict the language of a variable to strings \nof a speci\u00ad.ed length n (to model length checks in code). This could be im\u00adplemented using basic operations \non nondeterministic .nite state automata that are similar to the ones already implemented. Many other \nfeatures, however, would make the RMA problem undecid\u00adable in general (e.g., [27]). We instead focus \non a decidable theory with a provably correct core algorithm, and leave additional fea\u00adtures for future \nwork. In Section 4 we show that, without additional features, our decision procedure can be used to solve \na real-world problem.  3.2 The Concatenation-Intersection Problem Rather than solving the general RMA \nproblem directly, we will .rst consider a restricted form involving only the concatenation of two variables \nthat each have a subset constraint. In the next subsections we will present this restricted problem, \nand in Section 3.4 we will use our solution to it to build a full solution for the RMA problem. We de.ne \nthe Concatenation-Intersection (CI) problem as a subcase of the RMA problem, of the following form: v1 \n. c1 v2 . c2 v1 . v2 . c3 Because the form of these constraints is .xed, we de.ne a CI problem instance \nstrictly in terms of the constants c1, c2, and c3. Given three regular languages c1, c2, and c3, the \nCI problem requires the set S = {A1,...,An} of satisfying assignments, where each Ai is of the form [v1 \n. xi,v2 . xi ]. More explicitly, we require that S satisfy the following properties: 1. Regular: 1 = \ni = n . Ai[v1] and Ai[v2] are regular. 2. Satisfying: This corresponds directly to the Satisfying condi\u00adtion \nfor RMA:  1 = i = n .[ v1 ] Ai . [ c1 ] . [ v2 ] Ai . [ c2 ] . [ v1 . v2 ] Ai . [ c3 ]  [ c1 ] = L(nid \n)[ c2 ] = L(S * 0| ... |9) nid 0-9 . .... . .... . .... . .... . .... a5 . .... . .... a1 a2 a3 a4 b1 \nb2 S [ c3 ] = L(S * S * ) S . .... . .... dS 2 d1 [ l4 ] = [ c1 . c2 ] nid . 0-9 . .... .... a2 .... \na3 a4 .... a5 .... b1 .... b2a1 . . . .... . . . S [ l5 ] = [ l4 n c3 ] .... .... .... .... .... . \na1d1 . a2d1 . a3d1 . a4d1 . a5d1 n .. .. i .. .. d .. .. S S .. .... .... . b1d1 . b1d2 . b2d2 . .. .. \n. .. .. 0-9 .... .... Figure 4. The intermediate .nite state automata for the concat intersect algorithm \nwhen applied to the motivating exam\u00adple. c1 represents the string constant nid , c2 represents the (incor\u00adrect) \ninput .ltering on line 2, and c3 is the language of strings that contain a single quote. 3. All Solutions: \nIn addition, we want S to be nontrivial, since the Satisfying condition can be trivially satis.ed by \nS = \u00d8: .w . [ (c1 . c2) n c3 ] , .1 = i = n s.t. w . [ v1 . v2 ] Ai Figure 3 provides high-level pseudocode \nfor .nding S. The algorithm uses operations on nondeterministic .nite state automata, and we write Mi \nfor the machine corresponding to each input language ci or intermediate language li. To .nd S, we use \nthe structure of the NFA M5 (line 7 8) that recognizes [ l5 ] = [ (c1 . c2) n c3 ] . Without loss of \ngenerality, we assume that each NFA Mi has a single start state si . Qi and a single .nal state fi . \nQi. Note that we do not assume implicit .-transitions from each state to itself. Figure 4 shows the CI \nalgorithm applied to the running example introduced in Section 2. The input languages c1 and c2 correspond \nto the concatenation $newsid = \"nid_\" . $newsid on line 6 of Figure 1, while the input c3 corresponds \nto the set of strings that contain at least one quote which is one common approximation for an unsafe \nSQL query [43, 44]. The machines for l4 and l5 in Figure 4 correspond to the ma\u00adchines constructed on \nlines 6 and 7 8 of Figure 3. The algorithm .rst constructs a machine for [ l4 ] = [ c1 . c2 ] using a \nsingle .-transition between f1 and s2. Next, we use the cross-product construction to create the machine \nthat corresponds to [ l5 ] = [ l4 n c3 ] . The set of states Q5 for this machine corresponds to tuples \nin the set (Q1 . Q2) \u00d7 Q3; we write qxqy . Q5 for the state that corresponds to qx . (Q1 . Q2) and qy \n. Q3. The transition function d5 is de.ned in the usual way. Having constructed M5, we use the structure \nof the machine to .nd NFAs that represent the satisfying assignments. Intuitively, we slice up the bigger \nmachine M5, which represents all solutions, into pairs of smaller machines, each of which represents \na single satisfying assignment. We are interested in those states qaqb . Q5 where qa corre\u00adsponds to \nthe .nal state of M1 (i.e., Qlhs on line 10) or to the start state of M2 (i.e., Qrhs on line 11). Because \nof the way M5 is con\u00adstructed, any transitions from Qlhs to Qrhs must be .-transitions that correspond \nto the original concatenation step on line 6 of Figure 3. For Figure 4, we have Qlhs = {a5d1} and Qrhs \n= {b1d1}. We process each such .-transition as follows: induce from .nal(M5,q1) (line 10) returns a \ncopy of M5 with q1 marked as the only .nal state.  induce from start(M5,q2) (line 11) returns a copy \nof M5 with q2 marked as the only start state.  We output each such solution pair. Note that, on line \n15, if either M1 . or M2 . describe the empty language, then we reject that assign\u00adment. The machine \nfor l5 in Figure 4 has exactly one .-transition of interest. Consequently, the solution set consists \nof a assignment A1 =[v1 . x1,v2 . x1 ]. x1 corresponds to the machine for l5 with state a5d1 set as the \nonly .nal state. [ x1 . ] = L(nid ), as desired. The more interesting result is x1 , which is the machine \nwith start state b1d1 and .nal state b2d2. The language of x1 captures exactly the strings that exploit \nthe faulty safety check on line 2 of Figure 1: all strings that contain a single quote and end with a \ndigit.  3.3 Correctness of the Concat-Intersect Algorithm Having presented our high-level algorithm \nfor solving the CI prob\u00adlem, we now sketch the structure of our proof of its correctness. We have formally \nmodeled strings, state machines, our algorithm, and the desired correctness properties in version 8.1 \nof the Coq formal proof management system [6, 12]; proofs in Coq can be mechani\u00adcally veri.ed. At the \nlow level, our proofs proceed by induction on the length of the strings that satisfy speci.c properties; \nwe provide more detail for each individual correctness property. We say q reaches q . on s if there is \na path from state q to state q . that consumes the string s. Formally: for all regular languages c1, \nc2, and c3, if S = CI(c1,c2,c3) then for all elements Ai . S, the following three conditions hold: 1. \nRegular: Ai[v1] and Ai[v2] are regular. This is a type preservation property: because the operations \ninduce from .nal and induce from start return NFAs, the cor\u00adresponding languages are by de.nition regular. \n 2. Satisfying: We prove this by showing that .q . Qlhs,w . S * ,s5 reaches q on string w . w . c1, and \n.q . . Qrhs,w . S * ,q . reaches f5 on w . w . c2. 3. All Solutions: We proceed by simultaneous induction \non the structure of the machines M3 and M4; we show that .w . Ai[v1],w . . Ai[v2],s5 reaches f5 on s \n. s . in machine M5 (by traversing the epsilon transition selected for Ai). Note that, since the number \nof .-transitions in M5 is .nite, the number of disjunctive solutions must also be .nite.  Our proof \nis available on-line1; we believe that the presence of a mechanically checkable proof of correctness \nmakes our algorithm attractive for use as a decision procedure or as part of a sound program analysis. \n 3.4 Solving General Systems of Subset Constraints We now return to the problem of .nding satisfying \nassignments for general regular language equations. At a high level, this requires 1 http://www.cs.virginia.edu/~ph4u/dprle/proof.php \n n = node(ci) n = node(vi) E . C E . V . ci : n, \u00d8 . vi : n, \u00d8 t is fresh . e0 : n0,G0 . e1 : n1,G1 \nG. = {ConcatEdgePair(n0,n1,t)} E . E . E . e0 . e1 : t, G0 . G1 . G. . e : n, G S . E . C . e . c : n, \nG .{SubsetEdge(node(c),n)} Figure 5. Dependency graph generation rules. We process a regu\u00adlar language \nconstraint by recursive descent of its derivation; each rule corresponds to a grammar production. The \nnode function re\u00adturns a vertex for each unique variable or constant. For systems of multiple constraints, \nwe take the union the dependency graphs. [ c1 ] = L(nid ) ..* .... . .... .... . .... [ c2 ] = L(S (0| \n... |9)) c1 v1 v2 c2 [ c3 ] = L(S*.S * ) . . .... . .... c3t0 Figure 6. Example dependency graph. This \ngraph corresponds to an instance of the Concatenation-Intersection problem de.ned in Section 3.2, using \nthe assignments for the running SQL injection example from Section 2. that we generalize the concat intersect \nalgorithm from Figure 3. We proceed as follows: 1. To impose an ordering on the operations of our algorithm, \nwe create a dependency graph based on the structure of the given equations. We describe the graph generation \nprocess in Section 3.4.1. 2. Section 3.4.2 provides a worklist algorithm that applies the concat intersect \nprocedure inductively, while accounting for repeated variable instances. That is, if a variable occurs \nmultiple times, a solution generated for it must be consistent with all of its uses.  3.4.1 Dependency \nGraph Generation Our approach to constraint solving is conceptually related to the equality DAG approach \nfound in cooperating decision proce\u00addures [36]. Each unique language variable or constant is associated \nwith a node in the DAG. We construct the edges of the DAG by recursively processing the regular language \nequation. We present the processing rules here; the algorithm in Section 3.4.2 assumes a dependency graph \nas its input. Given a regular language equation, we build the dependency graph by recursive descent of \nthe derivation under the grammar of Figure 2. Figure 5 describes the generation rules as a collecting \nsemantics. The rules are of the form: . e : n, G where e is the right-hand side of a derivation step, \nn is the current dependency graph vertex, and G is the dependency graph. The node function returns a \ndistinct vertex for each unique variable and constant. Each vertex represents a regular language; we \nwrite [ n ] for the language associated with vertex n. We model the graph G as a set of directed edges, \nof which there are two types: SubsetEdge(n0,n1) requires that [ n1 ] . [ n0 ] . In such an edge n0 is \na constant and n1 is a language variable. We write such edges as n0 .. n1 and refer to them as .-edges. \n ConcatEdgePair(na,nb,n0) constrains the language [ n0 ] to strings in [ na ] . [ nb ] . Each constraint \nhas two edges na .. l n0 and nb .. r n0 referred to as a .-edge pair.  The base case rules in Figure \n5 are those for E . C and E . V . All other rules extend the dependency graph through union. Note that \nthe rule for E . E . E uses a fresh vertex t to represent the intermediate result of the concatenation. \nFinally, the top-level rule (for S . E . C) adds a single .-edge from the right-hand side of the constraint \nc to the left-hand side. Figure 6 shows the dependency graph for the example of Sec\u00adtion 2. This graph \ncorresponds an instance of the CI problem de\u00ad.ned in Section 3.2, of the form: v1 . c1 v2 . c2 v1 . v2 \n. c3 Note that the edges in Figure 6 are strictly a description of the con\u00adstraint system; they are not \nmeant to indicate a strict dependence ordering. For example, changing [ c3 ] to be be L(nid .5) would \nrequire [ v2 ] to contain only the string .5, even through there is no forward path through the graph \nfrom c3 to v2.  3.4.2 Solving General Graphs We now provide a general algorithm for the RMA problem \nde.ned in Section 3.1. Given a system of regular language equations, our algorithm returns the full set \nof disjunctive satisfying assignments from language variables to regular languages. The essence of our \nalgorithm is the repeated application of a generalized (i.e., able to handle groups of nodes connected \nby concat edges) version of the concat intersect algorithm. The algorithm keeps a worklist of partially-processed \ndepen\u00addency graphs along with mappings from vertices to .nite state au\u00adtomata; the use of a worklist \nis necessary to handle disjunctive solu\u00adtions. The initial worklist consists of the dependency graph \nthat rep\u00adresents the regular language equation in full. The the initial node-to-NFA mapping returns S \n* for vertices that represent a variable, and [ ci ] for each constant ci. Figure 7 provides pseudocode \nfor the algorithm, which is recur\u00adsive. The algorithm consists of several high-level stages, which are \napplied iteratively: 1. On lines 3 8, we solve basic constraints. Many constraints can be resolved by \neliminating vertices that represent constants in topological order. For example, the system v1 . c1 v1 \n. c2 v2 . c1 v2 . c2 can be processed by simply setting A[v2]= A[v1]= [ c1 nc2 ] . This step does not \nrequire any calls to the concat intersect procedure described in Section 3.2. Also note that this step \nnever generates more than one set of solutions. The sort acyclic nodes invocation on line 3 .nds vertices \nthat qualify for this treatment, and sorts them topologically. The reduce function performs NFA intersections \n(to satisfy subset constraints) and concatenations (to satisfy concatenation con\u00adstraints), and removes \nnodes from the graph that have no further inbound constraints. 2. On lines 9 15, we apply the CI algorithm \ninductively to handle nodes of the graph that have both concatenation and subset  1: solve dependency \ngraph(queue Q, node set S)= 2: let .G, F . : graph \u00d7 (node . NFA)= take from Q 3: let N : node list = \nsort acyclic nodes(G) 4: for 0 = i< length(N) do 5: let n : node = N[i] 6: let .G.,F .. : graph \u00d7 (node \n. NFA)= reduce(n, G, F ) 7: F . F .; G . G. 8: end for 9: let C : node set = .nd free group(G) 10: if \n|C| > 0 then 11: let .G.,R. : graph \u00d7 (node . NFA) list = gci(C, G, F ) 12: G . G.; F . head(R) 13: foreach \nr . tail (R) do 14: add .G, r. to end of Q 15: end if 16: if .s . S. F [s]=.\u00d8.|G| =0 then 17: return \nF 18: else if .s . S. F [s]=.\u00d8.|G| > 0 then 19: return solve dependency graph(.q, F . :: Q, S) 20: else \nif .s . S s.t.F [s]= \u00d8.|Q| > 0 then 21: return solve dependency graph(Q, S) 22: else 23: return no assignments \nfound Figure 7. Constraint solving algorithm for general dependency graphs over string variables. The \nalgorithms uses a worklist of de\u00adpendency graphs and node-to-NFA mappings. The graph represents the work \nthat remains; successful termination occurs if all nodes are eliminated. constraints. We refer to connected \ngroups of those nodes as CI\u00ad groups; we de.ne such groups formally in Section 3.4.3. Each call to gci \n(for generalized concat-intersect) on line 11 eliminates a single CI-group from the dependency graph, \nyield\u00ad ing separate node-to-NFA mappings for each disjunctive solu\u00ad tion. These solutions are added to \nthe worklist on lines 13 14. 3. Lines 16 23 determine what to do next. We either (1) terminate successfully \n(line 17); (2) continue to solve the current graph (line 19); (3) attempt to solve a new graph from the \nworklist (line 21); or (4) terminate without having found a satisfying set of inputs (line 23).  3.4.3 \nSolving CI-Groups Integrally We de.ne a CI-group as any set of nodes in which every node in the set is \nconnected by a .-edge to another node in the set. The directions of the .-edges do not matter. In Figure \n9 the nodes {va,vb,vc,t1,t2} form a CI-group; we will use this example to illustrate how these groups \ncan be solved. The purpose of the generalized concat-intersect (gci) procedure referenced in Figure 7 \nis to .nd a solution (i.e., a mapping from variables to NFAs) for the nodes involved in a CI-group. Since \nan RMA problem may admit multiple disjunctive solutions (see Section 3.1.1), the output of gci is a set \nof such solutions. The gci algorithm solves a CI-group by repeatedly processing subset constraints and \nconcatenation constraints. In the concat intersect algorithm (Figure 3), the .nal solutions M1 . and \nM2 . were both sub-NFAs of a larger NFA. Similarly, the solution for one variable in a CI-group may be \na sub-NFA of the solution for another variable. A variable may appear as the operand in more than one \nconcatenation; in that case we must take care to .nd an assignment that satis.es all constraints simultaneously. \nThe correctness of the gci algorithm is based on two key invariants: operation ordering and shared solution \nrepresentation. 1: gci(node set C, graph G, node . NFA F )= 2: let ordered : node list = topo sort(C) \n3: let solution : node . ((node \u00d7 subNFA) set)= empty 4: foreach n : node . ordered do 5: handle inbound \nsubset constraints(n, G, F ) 6: if n has an outbound concat constraint to node m then 7: handle concat \nconstraint(n, m, G, F ) 8: foreach n . . C do 9: foreach (n .. , states) . solution[n .] do 10: if n \n.. = n then 11: update tracking(solution[n .],n) 12: end for 13: let S : state pair set = emtpy 14: foreach \nm . C s.t. solution[m] is empty do 15: S . S . all combinations(m, F [m]) 16: end for 17: return generate \nNFA mappings(solution, G, C, S) Figure 8. Generalized concat-intersect algorithm for .nding a set of \ndisjunctive solutions for a group of nodes connected by .-edges. Inbound subset constraints are processed \nbefore concatenation con\u00adstraints. The solution for a node n may be a sub-NFA S of an\u00adother node m s \nsolution; the solution mapping tracks this (i.e., (m, S) . solution[n]). The .rst invariant, operation \nordering, requires that inbound subset constraints be handled before concatenation constraints. The importance \nof this ordering can be seen in Figure 6. Ini\u00adtially, [ v1 ] = [ v2 ] = L(S * ). If we mistakenly process \nthe concat edge .rst, we obtain [ t0 ] = L(S * S * ). If we then pro\u00adcess the subset edges, we obtain \n[ v2 ] = [ c2 ] , which is not correct the correct solution, as described in Section 3.2, is [ v2 ] \n= L(S*.S * (0| ... |9)). To obtain the correct solution and push back subset constraints through concatenations, \nwe must process subset constraints .rst. The second invariant, shared solution representation, ensures \nthat updates to the NFA F [v] representing the solution for a vari\u00adable v are also re.ected in updates \nto the solutions to all variables v . that are sub-NFAs of F [v]. In Figure 6, an update to the NFA for \nt0 must also be re.ected in the NFAs for v1 and v2. Our gci implementation maintains a shared pointer-based \nrepresentation so that if the NFA for t0 is changed (e.g., is subjected to the product construction to \nhandle a subset constraint), then the NFAs for v1 and v2 are automatically updated. These two invariants \nallow us to handle nested concatenation operations naturally. Consider the following system: (v1 . v2) \n. v3 . c4 v1 . c1 v2 . c2 v3 . c3 with the parentheses added for clarity. In this case, the dependency \ngraph will be several concatenations tall. The .nal subset with [ c4 ] , notably, can affect any of the \nvariables v1, v2, and v3. If the constraints are processed in the right order, the NFAs for v1, v2 and \nv3 will all be represented as sub-NFAs of a single larger NFA. Figure 8 provides high-level pseudocode \nfor solving a single CI-group. The expected output is a set of node-to-NFA mappings (one mapping for \neach disjunctive solution). The algorithm works as follows: 1. The nodes are processed in topological \norder (line 2). 2. The solution representations for each node n are tracked in solution[n]. There will \nbe multiple solution entries for a given node if that node is the operand for more than one concatena\u00adtion. \nThe set solution[n] contains zero or more pairs of the form   (m, S), where m is another node and S \nis a sub-NFA selecting part or all of the NFA for the node m. Each such pair indicates that [ n ] should \nbe constrained by the NFA for node m .n, = limited to the states speci.ed by S. 3. Each node n starts \nwithout any constraints (solution[n] is empty, line 3). If .(m, S) . solution[n] then the solution for \nnode n is in.uenced by changes to the solution for node m and we say that m in.uences n. 4. Ifanode \nm has an inbound subset constraint c .. m, then any nodes in.uenced by m have their entry in solution \nup\u00addated to re.ect the new machine for [ m ] n [ c ] . This is handle inbound subset constraints on line \n5 and the updates on lines 8 11. 5. Ifanode m is concatenated into another node t (line 6), then any \nnodes in.uenced by m will have their entry in solution updated to map to a sub-NFA of t (this maintains \nthe shared solution representation invariant). The mapping for solution[m] is extended to include the \npair (t, S), so that m itself is now marked as in.uenced by t (with the appropriate subset of states \nS). This is handle concat constraint on line 7 and the updates on lines 8 11. 6. After all nodes have \nbeen processed (after line 12), there will be some number of non-in.uenced nodes that do not have any \noutbound .-edge pairs and are thus not in solution. For each such node n, the .nal solution is simply \nF [n]. Intuitively, these are the largest NFAs in the CI-group, since each concatenation and intersection \nincreases the size of the resulting NFA. 7. The solution for each in.uenced node m (line 14) will refer \nto one or more non-in.uenced nodes, each reference coupled with an appropriate subset of states to take \nfrom the larger machine. Because of the structure for the grammar in Figure 2, there is always one non-in.uenced \nnode; we use the NFAs of that node to generate the disjunctive solutions.  Recall that, in the concat \nintersect procedure of Figure 3, we generated disjunctive solutions by selecting .-transitions from the \nmachine M5. To generalize this, we must generate a dis\u00adjunctive solution for each combination of such \n.-transitions in the non-in.uenced nodes NFAs. The all combinations invo\u00adcation (Figure 8, line 15) generates \nthese combinations, and the call to generate NFA mappings (line 17) generates a new node-to-NFA mapping \nfor each such combination.  3.4.4 Example Execution Figure 10 shows the intermediate automata generated \nby the gci procedure when applied to the dependency graph of Figure 9. The dashed lines in the NFAs for \nt1 and t2 mark the epsilon transitions for the va . vb and vb . vc concatenations, respectively. After \nprocessing each of the nodes (i.e., on line 12 of Figure 8), the solution mapping is as follows: va .. \n{(t1, {a1d1,a2d2,...}) } vb .. {(t1, {b1d4,b1d6,...}); (t2, {b1g1,b2g2,...}) } vc .. {(t2, {c1g3,c1g4,...}) \n} t1 .. \u00d8 t2 .. \u00d8 Note that that the machines for t1 and t2 each have two .\u00adtransitions: t1 connects \nthe submachines for va to that of vb, while t2 connects submachines for vb on the left-hand side to the \nsub\u00admachines for vc an the right-hand side. This yields a total of 2 \u00d7 2 candidate solutions. Further, \nthe solution mapping shows us that vb Figure 9. A partially-processed dependency graph that exhibits \na CI-group (de.ned in the text). In this case, vb is affected by both c1 .. t1 and c2 .. t2, making the \ntwo concatenations mutually dependent. The correct solution set for this graph includes all possible \nassignments to va and vc for which there exists an assignment to vb that simultaneously satis.es the \nconstraints on t1 and t2. [ va ] = L(o(pp)+) .... va .... vb .... vc [ vb ] = L(p * (qq)+) [ vc ] = \nL(q * r) [ c1 ] = L(op 5 q * ) . . [ c2 ] = L(p * q 4 r) .... c1 . . . . .... t1 . . .... t2 . . .... \nc2 participates in both concatenations, so for each candidate solution we must ensure that [ vb ] satis.es \nboth constraints. This leaves two satisfying assignments: 2322 1. A1 =[va . L(op ),vb . L(pq ),vc . L(qr)] \n5 234 This solution used F [t1] = L(op q ) and F [t2] = L(pqr) 2. A2 =[va . L(op 4),vb . L(pq 2),vc . \nL(q 2 r)] This solution used F [t1] = L(op 5 q 2) and F [t2] = L(pq 4 r)   3.5 Runtime Complexity In \nthis section we have de.ned the Regular Matching Assignments problem and presented a decision procedure \nfor it. We now turn to the runtime complexity of the decision procedure. As before, we will .rst discuss \nthe concat intersect procedure presented in Sec\u00adtion 3.2, and then generalize to the full algorithm of \nSection 3.4.2. It should be noted that the precise complexity of combined NFA operations is the subject \nof ongoing research [37]. We use worst\u00adcase NFA state space complexity (i.e., the number of NFA states \nvisited during an operation) to represent the runtime complexity of our algorithm. This is a natural \nrepresentation for low-level NFA operations that require visiting all states in one or more operands, \nsuch as the cross-product construction. We express our analysis in terms of two variables: the number \nof disjoint solutions for a given system, and the total number of NFA states visited. In each case, we \ncompute a worst-case upper bound. We refer to the size |Mi| of an NFA Mi as the size of its state space; \nlet Q be an upper bound on the size of any input NFA. The concat intersect algorithm performs one concatenation \noperation (line 6) and then computes machine M5 using the cross\u00adproduct construction (lines 7 8). The \nsize of the concat machine is |M1| + |M2| = O(Q), so constructing the intersection requires visiting \n|M3|(|M1| + |M2|)= O(Q2) states. The number of so\u00adlutions in the intersection language is bounded by \n|M3|. This is because of the way Qlhs and Qrhs are de.ned in Figure 3; the proof sketch in Section 3.3 \nprovides more detail. This means that the total cost of enumerating all solutions ea\u00adgerly, in terms \nof NFA states visited, is |M3|\u00d7 (|M3|(|M1| + |M2|)) = O(Q3). We note that, in practice, we can generate \nthe .rst solution without having to enumerate the others; this is why we reason separately about machine \nsize and number of possible solutions. The argument thus far applies to dependency graphs of the form \nillustrated in Figure 6; we now extend it to general dependency graphs. We consider two cases: (1) one \nor both the .-operands c1 and c2 are the result of a previous call to the concat intersect  va vb vc \np q pp qq o r . .... . .... . .... . .... . .... . .... . .... . .... . .... a1 a3 a4 c1 c2 b1 b3 \n.b2 .a2 q c1 c2 q p ppppp qqqq o r . .... . .... . .... . .... . .... . .... . .... . .... . .... . \n.... . .... . .... . .... g1 g2 g3 g4 g5 g6 d1 d2 d3 d4 d5 d6 d7 t1 =(va . vb) n c1 . t2 =(vb . vc) \nn c2 . p .... .... .... .... . .. .. p .... .... q .. .. q .. .. . .. .. . a1d1 . a2d2 . a3d3 . a4d4 \n. b1d5 . b1g1 . b2g2 . b3g3 . . c1g3 . . b1d4 o .. .. p .. .. p .. .. p q q . . . . . c1g4 a2d4 b1d6 \nb2g4 p q q .. . .. .. .... .... . c2g6 p a3d5 b3g5 . . c1g5 . .. .. r .... .... p .. .... p .. .. q \n.. .. q .... .... . a4d6 . b1d6 . b1d7 . b2d7 . b3d7 . .. .. .... .... Figure 10. Intermediate automata \nfor solving Figure 9. The gci procedure (Figure 8) .nds disjunctive solutions that satisfy the constraints \non t1 and t2 separately. It then considers all combinations of these solutions and outputs the solution \ncombinations that have matching machines vb. procedure; and (2) the concatenation result t0 is subject \nto more than one subset constraint. In the .rst case, suppose v1 is the result of a separate concat\u00adintersect \nstep; its NFA has size O(Q2) and there are O(Q) possible assignments to v1. The machine for v1 . v2 then \nhas size O(Q2)+ O(Q)= O(Q2), yielding a total enumeration size of O(Q2) \u00d7 O(Q3)= O(Q5) |{z}|{z} solutions \nmachine size In the second case, we consider adding an additional subset con\u00adstraint to the concatenation \nnode t0 in the graph of Figure 6. Note that |M3| occurs both as a factor in the number of states visited \nand the number of potential solutions. We add one additional subset constraint to the concatenation (i.e., \nv1 . v2 . c4); we assume one additional edge c4 .. t0. The enumeration then requires visiting |M3||M4|\u00d7 \n(|M3||M4|(|M1| + |M2|)) = O(Q5) |{z}| {z } solutions machine size states. Informally, we note that a \nsingle concat intersect call requires visiting at most Q3 NFA states. The total cost of solving a general \nconstraint graph grows exponentially with the number of inductive calls to that procedure. For example, \na system: v1 . c1 v1 . v2 . c4 v2 . c2 v1 . v2 . v3 . c5 v3 . c3 requires two calls to concat intersect. \nTo enumerate the .rst so\u00adlution for the whole system we must visit a total of O(Q3) NFA states; enumerating \nall possible solutions requires visiting O(Q5) states. In Section 4, we show that the algorithm, in spite \nof its ex\u00adponential worst-case complexity, is ef.cient enough to be practical.  3.6 Regular-Language \nConstraint Solving Summary In this section we have de.ned the general Regular Matching As\u00adsignments problem \nfor equations of regular language variables and presented a decision procedure for it. We show how to \nconstruct a dependency graph and process parts of it in sequence to gen\u00aderate potentially-disjunctive \nsolutions. The heart of our algorithm is the inductive application of our solution to the Concatenation-Intersection \nproblem, which pushes back intersection constraint information through language concatenation. Having \npresented our algorithm and proved the correctness of its core, we now turn to an empirical evaluation \nof its ef.ciency and utility. 4. Experimental Results Recently, much attention has been devoted to static \ntechniques that detect and report potential SQL injection vulnerabilities (e.g., [24, 31, 47]). Attacks \nremain prevalent [8], however, and we believe that extending static analyses to include automatically \ngenerated test inputs would make it easier for programmers to address vul\u00adnerabilities. Without testcases, \ndefect reports often go unaddressed for longer periods of time [22, 46], and time is particularly relevant \nfor security vulnerabilities. To test the practical utility and scalability of our decision proce\u00addure, \nwe implemented a prototype that automatically generates vio\u00adlating inputs for given SQL injection vulnerabilities. \nThese vulner\u00adabilities allow undesirable user-supplied commands to be passed to the back-end database \nof a web application. Such attacks are quite common in practice: in 2006, SQL injection vulnerabilities \nmade up 14% of reported vulnerabilities and were thus the second most commonly-reported security threat \n[21]. We extend an existing analysis by Wassermann and Su [43], which detects SQL injection vulnerabilities \nbut does not automat\u00adically generate testcases. Since our decision procedure works on systems of regular \nlanguage equations, we constructed a simple prototype program analysis that uses symbolic execution to \nset up a system of string variable constraints based on paths that lead to the defect reported by Wassermann \nand Su. We then apply our al\u00adgorithm to solve for any variables that were part of an HTTP GET or POST \nrequest.  Name Version Files LOC Vulnerable eve 1.0 8 905 1 utopia 1.3.0 24 5,438 4 warp 1.2.1 44 24,365 \n12 Figure 11. Programs in the Wassermann and Su [43] data set with more than one direct defect. The \nvulnerable column lists the number of .les for which we generated user inputs leading to a potential \nvulnerability detected by the Wassermann and Su analysis; in our experiments we attempt to .nd inputs \nfor the .rst vulnerability in each such .le. We ran our experiments on seventeen defect reports from \nthree programs used by Wassermann and Su [43]. The programs are large-scale PHP web applications; Figure \n11 describes the data set in more detail. These programs were chosen because code injection defect reports \nwere available for them via an existing program analysis; building on such an analysis helps to demonstrate \nthe applicability of our decision procedure. More speci.cally, we ran our analysis on bug reports that \nwe were able to reproduce using Wassermann and Su s original tool and for which we could easily generate \nregular language constraints. Their analysis only .nds direct defects, a term used by Wassermann and \nSu to refer to defects based on standard input variables, in three of their .ve programs; we restrict \nattention to three programs here. The total program size is not directly indicative of our running time; \ninstead, our execution time is related to the complexity of the violating path and thus of the constraints \ngenerated along it. Con\u00adtrol .ow and primitive string functions along that path contribute to the complexity \nof and the number of constraints and thus the complexity of the .nal constraint solving. We conducted \nour experiments on a 2.5 GHz Core 2 Duo ma\u00adchine with a 6 megabyte L2 cache and 4 gigabytes of RAM. Fig\u00adure \n12 lists our results applying our decision procedure to produce user inputs (testcases) for 17 separate \nreported SQL injection de\u00adfects; each row corresponds to a PHP source .le within the listed application. \nIn 16 of the 17 cases, the analysis took less than one second. The secure testcase took multiple minutes \nbecause of the structure of the generated constraints and the size of the ma\u00adnipulated .nite state machines. \nIn our prototype large string con\u00adstants are explicitly represented and tracked through state machine \ntransformations. More ef.cient use of the intermediate NFAs (e.g., by applying NFA minimization techniques) \nmight improve perfor\u00admance in those cases. We have implemented our decision procedure as a stand-alone \nutility in the style of a theorem prover [13, 14] or SAT solver [33, 48]. The source code is publicly \navailable.2 Our decision procedure was able to solve all of the regular language constraints generated \nby our simple symbolic execution approach. The ease of construct\u00ading an analysis that could query our \ndecision procedure, the relative ef.ciency of .nding solutions, and the possibility of solving either \npart or all of the graph depending on the needs of the client analysis argue strongly that our analysis \ncould be used in practice. 5. Related Work Language Theory and String Analyses. There has been exten\u00adsive \ntheoretical work on language equations; Kunc provides an overview [28]. Work in this area has typically \nfocused on complex\u00adity bounds and decidability results. Bala [2] de.nes the Regular Language Matching \n(RLM) problem, a generalization of the Regu\u00adlar Matching Assignments (RMA) problem that allows both subset \nand superset constraints. Bala uses a construct called the R-pro.le 2 http://www.cs.virginia.edu/~ph4u/dprle/ \nVulnerability |FG| |C| TS eve edit 58 29 0.32 utopia login 295 16 0.052 pro.le 855 16 0.006 styles 597 \n156 0.65 comm 994 102 0.26 warp cxapp 620 10 0.054 ax help 610 4 0.010 usr reg 608 10 0.53 ax ed 630 \n10 0.063 cart shop 856 31 0.17 req redir 640 41 0.43 secure 648 81 577.0 a cont 606 10 0.057 usr prf \n740 66 0.22 xw mn 698 387 0.50 castvote 710 10 0.052 pay nfo 628 10 0.18 Figure 12. Experimental results. \nFor each of the SQL code injec\u00adtion vulnerabilities above, our tool was able to generate string val\u00adues \nfor input variables that led to the defect. |FG| represents the number of basic blocks in the code; |C| \nrepresent the number of constraints produced by the symbolic execution step; and TS repre\u00adsents the total \ntime spent solving constraints, in seconds. automaton to show that solving RLM requires exponential space. \nOur decision procedure supports a different set of operations (e.g., we do not allow Kleene . on variables). \nChristensen et al. .rst proposed a string analysis that soundly overapproximates string variables using \nregular languages [11]. Our implementation s constraint generator is based on an analysis by Wassermann \nand Su [43]. They extend Minamide s grammar\u00adbased analysis [32]. It statically models string values using \ncontext\u00adfree grammars, and detects potential database queries for which user input may change the intended \nsyntactic structure of the query. In its original form, neither Wassermann and Su nor Minamide s analysis \ncan generate example inputs. In recent work, Wassermann et al. show that many common string operations \ncan be reversed using .nite state transducers (FSTs) [45]. They use this method to generate inputs for \nSQL injection vulnerabilities in a concolic testing setup. Their algo\u00adrithm is incomplete, however, and \ncannot be used to soundly rule out infeasible program paths. Yu et al. solve string constraints [49] \nfor forward symbolic execution, using approximations ( widening automata ) for non-monotonic operations, \nsuch as string replace\u00adment, to guarantee termination. Their approach has recently been extended to handle \nsymbolic length constraints through the con\u00adstruction of length automata [50]. The techniques proposed \nby Wasserman et al. and Yu et al. are potentially compatible with our implementation, and we propose \ninvestigating this in future work. Bj\u00f8rner et al. present a decision procedure for several common string \noperations by reduction to existing SMT theories [7], .xing the string lengths in a separate step. They \nshow that the addition of a replace function makes the theory undecidable. In concurrent work, we show \nthat bounded context-free language constraints can be solved ef.ciently by direct conversion to SAT [25]. \nBoth ap\u00adproaches deal with individual string assignments. The algorithm presented here, in contrast, \ndeals with languages rather than indi\u00advidual strings, and does not require (or reason about) string length \nbounds. The Use of Decision Procedures. Decision procedures have long been a .xture of program analyses. \nTypically a decision procedure handles queries over a certain theory, such as linear arithmetic, un\u00adinterpreted \nfunctions, boolean satis.ability [33, 48], pointer equal\u00adity [34, 39], or bitwise operations and vectors \n[9, 15]. Nelson and Oppen presented a framework for allowing decision procedures to cooperate, forming \nan automated theorem prover to handle queries that span multiple theories and include .rst-order logic \nconnec\u00adtives [36]. In general, the satis.ability modulo theories problem is a decision problem for logical \nformulas with respect to combinations of background theories expressed in classical .rst-order logic \nwith equality. A number of SMT solvers, such as CVC [40] and Z3 [13], are available.  SLAM [5] and BLAST \n[20] are well-known examples of pro\u00adgram analyses that make heavy use of external decision procedures: \nboth are software model checkers that were originally written to call upon the Simplify theorem prover \n[14] to compute the ef\u00adfects of a concrete statement on an abstract model. This process, called predicate \nabstraction, is typically performed using decision procedures [29] and has led to new work in automated \ntheorem proving [3]. SLAM has also made use of an explicit alias anal\u00adysis decision procedure to improve \nperformance [1]. BLAST uses proof-generating decision procedures to certify the results of model checking \n[19], just as they are used by proof-carrying code to cer\u00adtify code safety [35]. Another recent example \nis the EXE project [10], which com\u00adbines symbolic execution and constraint solving [26] to generate user \ninputs that lead to defects. EXE has special handling for bit ar\u00adrays and scalar values, and our work \naddresses an orthogonal prob\u00adlem. While a decision procedure for vectors might be used to model strings, \nmerely reasoning about indexed accesses to strings of char\u00adacters would not allow a program analysis \nto handle the high-level regular-expression checks present in many string-using programs. Our decision \nprocedure .lls this semantic gap. Godefroid et al. [16] use the SAGE architecture to perform guided random \ninput generation (similar to previous work on ran\u00addom testcase generation by the same authors [17, 18]). \nIt uses a grammar speci.cation for valid program inputs rather than generat\u00ading arbitrary input strings. \nThis allows the analysis to reach beyond the program s input validation stages. Independent work by Ma\u00adjumdar \nand Xu [30] is similar to that of Godefroid et al.; CESE also uses symbolic execution to .nd inputs that \nare in the language of a grammar speci.cation. All of these projects could bene.t from our decision procedure \nfor strings and regular expressions when per\u00adforming symbolic execution, which requires decision procedures \nfor strongest-postcondition calculations as well as ruling out infea\u00adsible paths. 6. Conclusion Many \nprogram analyses and testing frameworks deal with string variables that are manipulated by high-level \noperations such as reg\u00adular expression matching and concatenation. These operations are dif.cult to reason \nabout because they are not well-supported by current decision procedures and constraint solvers. This \nis of par\u00adticular concern for analyses that use constraint solving techniques to generate, for instance, \nprogram inputs. We present a decision procedure that solves systems of equa\u00adtions over regular language \nvariables. We formally de.ne the Regu\u00adlar Matching Assignments problem and a subclass, the Concatenation-Intersection \nproblem. We then provide algorithms for both prob\u00adlems, together with a mechanized, machine-checkable \nproof for the core concat intersect procedure, which we use inductively to solve the more general RMA \nproblem. We also describe the theoretical space complexity of our algorithms. We evaluate the utility \nand ef.ciency of our decision procedure empirically by generating constraints for 17 previously-reported \nSQL-injection vulnerabilities. In all cases, we were able to .nd feasible user input languages; in 16 \nof the 17 we were able to do so in under one second. The relative ef.ciency of our algorithm and the \nease of adapting an existing analysis to use it suggest that our decision procedure is practical. We \nassert that the precise modeling of string variables will be of critical importance to the next generation \nof program analyses and testing frameworks, especially for web applications. We formally de.ned a relevant \nproblem and presented a decision procedure for it. The core of our decision procedure is mechanically \nveri.ed, the procedure addresses a relevant and useful problem, and our experimental results indicate \nthat even a prototype implementation can be practical and ef.cient. References [1] S. Adams, T. Ball, \nM. Das, S. Lerner, S. K. Rajamani, M. Seigle, and W. Weimer. Speeding up data.ow analysis using .ow-insensitive \npointer analysis. In Static Analysis Symposium, pages 230 246, 2002. [2] S. Bala. Regular language matching \nand other decidable cases of the satis.ability problem for constraints between regular open terms. In \nSTACS, pages 596 607, 2004. [3] T. Ball, B. Cook, S. K. Lahiri, and L. Zhang. Zapato: Automatic theorem \nproving for predicate abstraction re.nement. In Computer Aided Veri.cation, pages 457 461, 2004. [4] \nT. Ball, M. Naik, and S. K. Rajamani. From symptom to cause: localizing errors in counterexample traces. \nSIGPLAN Not., 38(1):97 105, 2003. [5] T. Ball and S. K. Rajamani. Automatically validating temporal safety \nproperties of interfaces. In SPIN Workshop on Model Checking of Software, pages 103 122, May 2001. [6] \nY. Bertot and P. Casteran. Interactive Theorem Proving and Program Development. SpringerVerlag, 2004. \n[7] N. Bj\u00f8rner, N. Tillmann, and A. Voronkov. Path feasibility analysis for string-manipulating programs. \nIn Tools and Algorithms for the Construction and Analysis of Systems, 2009. [8] British Broadcasting \nCorporation. UN s website breached by hackers. In http: // news. bbc. co. uk/ 2/ hi/ technology/ 6943385. \nstm , Aug. 2007. [9] R. E. Bryant, D. Kroening, J. Ouaknine, S. A. Seshia, O. Strichman, and B. Brady. \nDeciding bit-vector arithmetic with abstraction. In Tools and Algorithms for the Construction and Analysis \nof Systems, pages 358 372, 2007. [10] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler. \nEXE: automatically generating inputs of death. In Computer and Communications Security, pages 322 335, \n2006. [11] A. S. Christensen, A. M\u00f8ller, and M. I. Schwartzbach. Precise analysis of string expressions. \nIn International Symposium on Static Analysis, pages 1 18, 2003. [12] T. Coquand and G. P. Huet. The \ncalculus of constructions. Inf. Comput., 76(2/3):95 120, 1988. [13] L. M. de Moura and N. Bj\u00f8rner. Z3: \nAn ef.cient SMT solver. In Tools and Algorithms for the Construction and Analysis of Systems, pages 337 \n340, 2008. [14] D. Detlefs, G. Nelson, and J. B. Saxe. Simplify: a theorem prover for program checking. \nJ. ACM, 52(3):365 473, 2005. [15] V. Ganesh and D. L. Dill. A decision procedure for bit-vectors and \narrays. In Computer-Aided Veri.cation, pages 519 531, 2007. [16] P. Godefroid, A. Kie.zun, and M. Y. \nLevin. Grammar-based whitebox fuzzing. In Programming Language Design and Implementation, Tucson, AZ, \nUSA, June 9 11, 2008. [17] P. Godefroid, N. Klarlund, and K. Sen. DART: directed automated random testing. \nIn Programming Language Design and Implementa\u00adtion, pages 213 223, 2005.  [18] P. Godefroid, M. Levin, \nand D. Molnar. Automated whitebox fuzz testing. In Network Distributed Security Symposium (NDSS), 2008. \n[19] T. A. Henzinger, R. Jhala, R. Majumdar, G. C. Necula, G. Sutre, and W. Weimer. Temporal-safety proofs \nfor systems code. In Computer Aided Veri.cation, pages 526 538, 2002. [20] T. A. Henzinger, R. Jhala, \nR. Majumdar, and G. Sutre. Lazy abstraction. In Principles of Programming Languages, pages 58 70, 2002. \n[21] K. J. Higgins. Cross-site scripting: attackers new favorite .aw. Technical report, http://www.darkreading.com/document. \nasp?doc_id=103774&#38;WT.svl=news1_1, Sept. 2006. [22] P. Hooimeijer and W. Weimer. Modeling bug report \nquality. In International Conference on Automated Software Engineering, pages 73 82, 2007. [23] R. Jhala \nand R. Majumdar. Path slicing. In Programming Language Design and Implementation, pages 38 47, 2005. \n[24] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static analysis tool for detecting web application \nvulnerabilities (short paper). In Symposium on Security and Privacy, pages 258 263, 2006. [25] A. Kie.zun, \nV. Ganesh, P. J. Guo, P. Hooimeijer, and M. D. Ernst. HAMPI: A solver for string constraints. technical \nreport, Massachusetts Institute of Technology Computer Science and Arti.cial Intelligence Laboratory. \n[26] J. Kodumal and A. Aiken. Banshee: A scalable constraint-based analysis toolkit. In Static Analysis \nSymposium, pages 218 234, 2005. [27] M. Kunc. The power of commuting with .nite sets of words. Theory \nComput. Syst., 40(4):521 551, 2007. [28] M. Kunc. What do we know about language equations? In Developments \nin Language Theory, pages 23 27, 2007. [29] S. K. Lahiri, T. Ball, and B. Cook. Predicate abstraction \nvia symbolic decision procedures. Logical Methods in Computer Science, 3(2), 2007. [30] R. Majumdar and \nR.-G. Xu. Directed test generation using symbolic grammars. In Automated Software Engineering, pages \n134 143, 2007. [31] M. C. Martin, V. B. Livshits, and M. S. Lam. Finding application errors and security \n.aws using PQL: a program query language. In Object-Oriented Programming, Systems, Languages, and Applica\u00adtions, \npages 365 383, 2005. [32] Y. Minamide. Static approximation of dynamically generated web pages. In International \nConference on the World Wide Web, pages 432 441, 2005. [33] M. W. Moskewicz, C. F. Madigan, Y. Zhao, \nL. Zhang, and S. Malik. Chaff: engineering an ef.cient SAT solver. In Design Automation Conference, pages \n530 535, 2001. [34] M. Naik and A. Aiken. Conditional must not aliasing for static race detection. In \nPrinciples of Programming Languages, pages 327 338, 2007. [35] G. C. Necula. Proof-carrying code. In \nPrinciples of Programming Languages, pages 106 119, New York, NY, USA, 1997. ACM. [36] G. Nelson and \nD. C. Oppen. Simpli.cation by cooperating decision procedures. ACM Trans. Program. Lang. Syst., 1(2):245 \n257, 1979. [37] A. Salomaa, K. Salomaa, and S. Yu. State complexity of combined operations. Theor. Comput. \nSci., 383(2-3):140 152, 2007. [38] K. Sen. Race directed random testing of concurrent programs. In Programming \nLanguage Design and Implementation, pages 11 21, 2008. [39] B. Steensgaard. Points-to analysis in almost \nlinear time. In Principles of Programming Languages, pages 32 41, 1996. [40] A. Stump, C. W. Barrett, \nand D. L. Dill. Cvc: A cooperating validity checker. In Computer Aided Veri.cation, pages 500 504, 2002. \n[41] Z. Su and G. Wassermann. The essence of command injection attacks in web applications. In Principles \nof Programming Languages, pages 372 382, 2006. [42] P. Thiemann. Grammar-based analysis of string expressions. \nIn Workshop on Types in Languages Design and Implementation, pages 59 70, New York, NY, USA, 2005. ACM. \n[43] G. Wassermann and Z. Su. Sound and precise analysis of web applications for injection vulnerabilities. \nIn Programming Language Design and Implementation, pages 32 41, 2007. [44] G. Wassermann and Z. Su. Static \ndetection of cross-site scripting vulnerabilities. In International Conference on Software Engineering, \npages 171 180, 2008. [45] G. Wassermann, D. Yu, A. Chander, D. Dhurjati, H. Inamura, and Z. Su. Dynamic \ntest input generation for web applications. In International Symposium on Software testing and analysis, \npages 249 260, 2008. [46] W. Weimer. Patches as better bug reports. In Generative Programming and Component \nEngineering, pages 181 190, 2006. [47] Y. Xie and A. Aiken. Static detection of security vulnerabilities \nin scripting languages. In Usenix Security Symposium, pages 179 192, July 2006. [48] Y. Xie and A. Aiken. \nSaturn: A scalable framework for error detection using boolean satis.ability. ACM Trans. Program. Lang. \nSyst., 29(3):16, 2007. [49] F. Yu, T. Bultan, M. Cova, and O. H. Ibarra. Symbolic string veri.cation: \nAn automata-based approach. In SPIN 08: Proceedings of the 15th international workshop on Model Checking \nSoftware, pages 306 324, Berlin, Heidelberg, 2008. Springer-Verlag. [50] F. Yu, T. Bultan, and O. H. \nIbarra. Symbolic string veri.cation: Combining string analysis and size analysis. In Tools and Algorithms \nfor the Construction and Analysis of Systems, 2009.  \n\t\t\t", "proc_id": "1542476", "abstract": "<p>Reasoning about string variables, in particular program inputs, is an important aspect of many program analyses and testing frameworks. Program inputs invariably arrive as strings, and are often manipulated using high-level string operations such as equality checks, regular expression matching, and string concatenation. It is difficult to reason about these operations because they are not well-integrated into current constraint solvers.</p> <p>We present a decision procedure that solves systems of equations over regular language variables. Given such a system of constraints, our algorithm finds satisfying assignments for the variables in the system. We define this problem formally and render a mechanized correctness proof of the core of the algorithm. We evaluate its scalability and practical utility by applying it to the problem of automatically finding inputs that cause SQL injection vulnerabilities.</p>", "authors": [{"name": "Pieter Hooimeijer", "author_profile_id": "81375612581", "affiliation": "University of Virginia, Charlottesville, VA, USA", "person_id": "P1464274", "email_address": "", "orcid_id": ""}, {"name": "Westley Weimer", "author_profile_id": "81100631608", "affiliation": "University of Virginia, Charlottesville, VA, USA", "person_id": "P1464275", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542498", "year": "2009", "article_id": "1542498", "conference": "PLDI", "title": "A decision procedure for subset constraints over regular languages", "url": "http://dl.acm.org/citation.cfm?id=1542498"}