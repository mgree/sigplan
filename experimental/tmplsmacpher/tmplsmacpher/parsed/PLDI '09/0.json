{"article_publication_date": "06-15-2009", "fulltext": "\n Dynamic Software Updates: A VM-centric Approach Suriya Subramanian Michael Hicks Kathryn S. McKinley \nThe University of Texas at Austin University of Maryland, College Park The University of Texas at Austin \nsuriya@cs.utexas.edu mwh@cs.umd.edu mckinley@cs.utexas.edu Abstract Software evolves to .x bugs and \nadd features. Stopping and restart\u00ading programs to apply changes is inconvenient and often costly. Dynamic \nsoftware updating (DSU) addresses this problem by up\u00addating programs while they execute, but existing \nDSU systems for managed languages do not support many updates that occur in prac\u00adtice and are inef.cient. \nThis paper presents the design and imple\u00admentation of JVOLVE, a DSU-enhanced Java VM. Updated pro\u00adgrams \nmay add, delete, and replace .elds and methods anywhere within the class hierarchy. JVOLVE implements \nthese updates by adding to and coordinating VM classloading, just-in-time compila\u00adtion, scheduling, return \nbarriers, on-stack replacement, and garbage collection. JVOLVE is safe: its use of bytecode veri.cation \nand VM thread synchronization ensures that an update will always produce type-correct executions. JVOLVE \nis .exible: it can support 20 of 22 updates to three open-source programs Jetty web server, JavaE\u00admailServer, \nand CrossFTP server based on actual releases occur\u00adring over 1 to 2 years. JVOLVE is ef.cient: performance \nexperi\u00adments show that JVOLVE incurs no overhead during steady-state execution. These results demonstrate \nthat this work is a signi.cant step towards practical support for dynamic updates in virtual ma\u00adchines \nfor managed languages. Categories and Subject Descriptors D.3.4 [Programming Lan\u00adguages]: Processors \nGeneral Terms Languages, Experimentation, Reliability Keywords dynamic software updating, virtual machine \ntechnol\u00adogy, garbage collection 1. Introduction Software is imperfect. To .x bugs and adapt software \nto user demands, developers must modify deployed systems. However, halting a software system to apply \nupdates creates new problems: safety concerns for mission-critical and transportation systems; substantial \nrevenue losses for businesses [38, 34]; maintenance costs [44]; and at the least, inconvenience for users. \nThese problems may translate into serious security risks if patches are not applied promptly [2, 3]. \nDynamic software updating (DSU) is a general-purpose mech\u00adanism that solves these problems by updating \nprograms while they run without a special software architecture or redundant hard- Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 09, June 15 20, 2009, \nDublin, Ireland. Copyright c &#38;#169; 2009 ACM 978-1-60558-392-1/09/06. . . $5.00 ware [19]. A practical \nDSU system must be safe, .exible, and ef.cient. Safe updates insure the program is as correct as deploying \nit from scratch. The update model would ideally be .exible enough to support all software changes, but \nDSU is still useful if the sys\u00adtem supports most software updates. Since updates should be rare events, \nan ef.cient DSU system would ideally impose no runtime overhead during steady-state program execution. \nResearchers have made signi.cant strides toward making DSU practical for systems written in C or C++, \nsupporting server fea\u00adture upgrades [32, 13, 24], security patches [2], and operating sys\u00adtems upgrades \n[39, 5, 6, 25, 12, 3]. Enterprise systems and embed\u00added systems including safety-critical applications \nare increas\u00adingly written in managed languages, such as Java, Ruby, and C#. Unfortunately, work on DSU \nfor managed languages lags behind work for C and C++. For example, while the HotSpot JVM [27] and some \n.NET languages [14] support on-the-.y method body up\u00addates, this support is too in.exible for all but \nthe simplest updates limiting changes to method bodies would support less than half of the updates to \nour three Java benchmark programs. Academic ap\u00adproaches [37, 26, 35, 8] offer more .exibility, but have \nnot been proven on realistic applications. Furthermore, they employ method and object indirection to \nmake applications DSU capable, imposing substantial space and time overheads on steady-state execution. \nThis paper presents the design of JVOLVE, a DSU system for Java, which we implement in Jikes RVM, a Java \nVirtual Machine. JVOLVE s combination of .exibility, safety, and ef.ciency is a clear advance over prior \napproaches. The paper s key contribution is to show how to extend and integrate existing VM services \nto support DSU that is .exible enough to support a large class of updates, guarantees type-safety, and \nimposes no space or time overheads on steady-state execution. JVOLVE DSU supports many common updates. \nUsers can add, delete, and change existing classes. Changes may add or remove .elds and methods, replace \nexisting ones, and change type signa\u00adtures. Changes may occur at any level of the class hierarchy. To \nini\u00adtialize new .elds and update existing ones, JVOLVE applies class and object transformer functions, \nthe former for static .elds and the latter for object instance .elds. The system automatically gen\u00aderates \ndefault transformers, which initialize new and changed .elds to default values and retain values of unchanged \n.elds. If needed, programmers may customize the default transformers. JVOLVE relies on bytecode veri.cation \nto statically type-check updated classes. To avoid type errors due to the timing of an up\u00addate [40, 32, \n5], JVOLVE stops the executing threads at a DSU safe point and then applies the update. DSU safe points \nare a subset of VM safe points, where it is safe to perform garbage collection (GC) and thread scheduling. \nDSU safe points further restrict the methods that may be on each thread s stack, depending on the update. \nThese methods include (1) updated methods, (2) methods that refer to up\u00addated classes (since their machine \ncode may contain hard-coded offsets that the update changes), and (3) user-speci.ed methods as needed \nfor safety [21, 31]. JVOLVE installs return barriers [43] on these methods to inform the run-time system \nwhen a running method returns, to speed up reaching a safe point. JVOLVE also applies on-stack replacement \n(OSR) to recompile methods in the second category even as they run, as long as they do not contain in\u00adlined \nupdated methods. This approach does not guarantee JVOLVE will reach a DSU safe point, but in our multithreaded \nbenchmarks it does in nearly all cases. More sophisticated thread scheduling support could attain greater \n.exibility [30].  JVOLVE makes use of the garbage collector and JIT compiler to ef.ciently update the \ncode and data associated with changed classes. JVOLVE initiates a whole-heap GC to .nd existing ob\u00adject \ninstances of updated classes and initialize new versions using the provided object transformers. JVOLVE \ninvalidates existing com\u00adpiled code and installs new bytecode for all changed method imple\u00admentations. \nWhen the application resumes execution these methods are JIT-compiled when they are next invoked. The \nadaptive compi\u00adlation system naturally optimizes updated methods further if they execute frequently. \nJVOLVE imposes no overhead during steady-state execution. During an update, it imposes overheads in classloading \nand garbage collection. After an update, the adaptive compilation system will incrementally optimize \nthe updated code in its usual fashion. Even\u00adtually, the code is fully optimized and running with no additional \noverhead. The zero overhead in steady-state execution for a VM\u00adbased approach is in contrast to DSU techniques \nfor C and C++. These approaches must use a compiler or dynamic rewriter to insert levels of indirection \n[32, 35] or trampolines [12, 13, 2, 3], which add a constant overhead during normal execution. We assessed \nJVOLVE by applying updates corresponding to one to two years worth of releases of three open-source multithreaded \napplications: Jetty web server, JavaEmailServer (an SMTP and POP server), and CrossFTP server. We found \nthat JVOLVE can successfully apply 20 of the 22 updates the two updates it does not support change a \nmethod within an in.nite loop that is always on the stack. Microbenchmark results show that the pause \ntime due to an update depends on the size of the heap and fraction of transformed objects. Experiments \nwith Jetty show that applications updated by JVOLVE enjoy the same steady-state performance as if started \nfrom scratch. In summary, this paper s main contributions are (1) techniques to extend and integrate \nstandard virtual machine services for man\u00adaged languages to support .exible, safe, and ef.cient dynamic \nsoft\u00adware updating services, (2) the design, implementation, and eval\u00aduation of JVOLVE, a Java VM with \nsupport for dynamic software updating. JVOLVE is distinguished from prior work in its realism, .exibility, \ntechnical novelty, and high performance. We believe our demonstration is a signi.cant step towards supporting \n.exible, ef\u00ad.cient, and safe updates in managed code virtual machines. 2. Dynamic Updates in JVOLVE This \nsection overviews JVOLVE s approach, what changes it per\u00admits, and how the developer participates in \nthe process. 2.1 System Overview Figure 1 illustrates the dynamic update process. Assume that the VM \nis executing the current version of the program, whose code is depicted in the left top corner. Meanwhile, \ndevelopers prepare a new version and fully test it using standard proce\u00addures. A developer then invokes \nJVOLVE s Update Preparation Tool (UPT) on the old and new versions. The UPT generates an update speci.cation, \nwhich identi.es new and updated classes, and a JvolveTransformers.java .le that contains default object \nand class transformer methods. Transformer methods take an object or class of the old version and initialize \nthe corresponding object or class of the new version. Figure 1. Dynamic Software Updating with JVOLVE \nThe default transformers assign default values, such as zero and null, to new instance, reference, and \nstatic .elds, and copy val\u00adues for unchanged .elds. Developers may customize the default transformers \nas necessary. We present an example update and trans\u00adformer in Section 2.3. The user signals the running \nVM to apply the update, and the VM loads the new class .les and transformers and schedules the update. \nThe VM scheduler signals an interrupt, which stops all threads at VM safe points, where it is safe to \nperform thread scheduling and garbage collection. JVOLVE then checks if the VM is at a DSU safe point. \nDSU safe points require that no thread s activation stack contains a restricted method. Restricted methods \nare of three categories: (1) methods changed by the update, (2) methods whose bytecode is unchanged but \nwhose compiled repre\u00adsentation may change, and (3) methods speci.ed by the user. If re\u00adstricted methods \nare on stack, the VM installs return-barriers for (1) and (3), and performs on-stack-replacement for \n(2) to reach a DSU safe point. Section 3.2 describes this process in detail. Once all application threads \nhave synchronized at DSU safe points, JVOLVE applies the update. It .rst invalidates the compiled versions \nof all changed methods. These methods are recompiled as needed the adaptive JIT compiler will generate \ncode the next time the program invokes an invalidated method, and may optimize it further, if the program \nexecutes it frequently. The VM then invokes the class transformers. Finally, the VM initiates a full \ncopying garbage collection. It piggybacks on the garbage collector to detect all existing objects whose \nclasses change. It allocates objects that conform to the new type declarations, and performs object transformations \nto populate the new objects with valid state. At this point, the update is complete.  2.2 Programmer \nUpdate Model We have designed a .exible, yet simple update model that supports updates that we believe \nare important in practice. Programmers may change method bodies. Method body updates are the simplest \nand most commonly supported change [27, 14, 17, 20, 35, 39, 22], because DSU systems can preserve type \nsafety by simply invoking the new method the next time the program exe\u00adcutes the method. However, restricting \nupdates to method bodies prevents many common changes [29]. Section 4 shows that over half the releases \nof Jetty, JavaEmailServer, and CrossFTP change more than just the method bodies. Programmers may also \nchange class signatures in various ways. They may change method signatures, e.g., by changing the type \nor number of method arguments. They may add or delete instance and static .eld members and change the \ntypes or access modi.ers  public class User { public class User { private final String username, domain, \npassword; private final String username, domain, password; private String[] forwardAddresses; private \nEmailAddress[] forwardAddresses; public User(...) {...} public User(...) {...} public String[] getForwardedAddresses() \n{...} public EmailAddress[] getForwardedAddresses() {...} public void setForwardedAddresses(String[] \nf) {...} public void setForwardedAddresses(EmailAddress[] f) {...} } } public class ConfigurationManager \n{ public class ConfigurationManager { private User loadUser(...) { private User loadUser(...) { ... ... \nUser user = new User(...); User user = new User(...); String[] f = ...; EmailAddress[] f = ...; user.setForwardedAddresses(f); \nuser.setForwardedAddresses(f); return user; return user; } } } (a) Version 1.3.1 } (b) Version 1.3.2 \n Figure 2. Example changes to JavaEmailServer User and ConfigurationManager classes of existing members. \nThese changes may occur at any level of the class hierarchy. For example, programmers may delete a .eld \nfrom a parent class and this change will propagate correctly to the class s descendants. We rely on the \nbytecode compiler to ensure that the resulting program is type-safe, e.g., there are no more accesses \nto the deleted .eld in the program. JVOLVE does not support permu\u00adtations of the class hierarchy, e.g., \nreversing a super-class relation\u00adship. While this change may be desirable in principle, in practice, \nit requires sophisticated transformers that enforce update ordering constraints. None of the program \nversions we examined make this type of change. Example. Consider the following update from JavaEmailServer, \na simple SMTP and POP e-mail server. Figure 2 illustrates a pair of classes that change between versions \n1.3.1 and 1.3.2. These changes are fully supported by JVOLVE. JavaEmailServer uses the class User to \nmaintain information about e-mail user ac\u00adcounts in the server. Moving from version 1.3.1 to 1.3.2, there \nare three differences. First, the method loadUser .xes some prob\u00adlems with the loading of forwarded addresses \nfrom a con.gu\u00adration .le (details not shown). This change is a simple method update. Second, the array \nof forwarded addresses in the new ver\u00adsion contains instances of a new class, EmailAddress, rather than \nString. This change modi.es the class signature of User since it modi.es the type of forwardedAddresses. \nFinally, the class s setForwardedAddresses method is also altered to take an array of EmailAddresses \ninstead of an array of Strings, and code from loadUser accommodates this change as well.  2.3 Class \nand Object Transformers For classes whose signatures have changed, an object transformer method initializes \na new version of the object based on the old version. For example, consider a class List with .eld next \nof type List and an update that adds a new int .eld x to List. The object transformer s job is to modify \neach object instance of type List to conform to its new class de.nition. Class transformers serve a similar \npurpose and update static .elds, rather than instance .elds. The UPT generates default class and object \ntransformers automatically, retaining unchanged .elds and initializing new or changed ones. The default \nobject transformer for our changed List copies the next .eld from an old object to a transformed object \nand initializes x to zero, i.e, transformed.next = old.next and transformed.x = 0. For our running example, \nthe UPT identi.es that the User and ConfigurationManager classes have changed, and produces default object \ntransformers. The programmer elects to modify the object transformer for the class User, as illustrated \nin Figure 3. public class v131_User { private final String username, domain, password; private String[] \nforwardAddresses; } public class JvolveTransformers { ... public static void jvolveClass(User unused) \n{} public static void jvolveObject(User to, v131_User from) { to.username = from.username; to.domain \n= from.domain; to.password = from.password; // default transformer would have: // to.forwardAddresses \n= null int len = from.forwardAddresses.length; to.forwardAddresses = new EmailAddress[len]; for(inti= \n0;i< len;i++){ String[] parts = from.forwardAddresses[i].split(\"@\", 2); to.forwardAddresses[i] = new \nEmailAddress(parts[0], parts[1]); }}} Figure 3. Example User object transformer Object and class transformer \nmethods are simply static meth\u00adods in the class JvolveTransformers. The class transformer method jvolveClass \ntakes an instance of the new class as a dummy argument; standard overloading in Java distinguishes the \njvolveClass methods for different classes. (In our exam\u00adple, jvolveClass does nothing.) The object transformer \nmethod jvolveObject takes two reference arguments: to, the uninitial\u00adized new version of the object, \nand from, the old version of the object. We prepend a version number to the names of old classes to distinguish \nthem from the new versions. Based on the UPT speci.\u00adcation, but before the VM loads the JvolveTransformers \nclass, the VM renames the old class in all its internal data structures. This renaming makes the class \nname space and the JvolveTransform\u00aders class type-correct. In our example, the VM renames the old version \nof User to class v131_User, which is the type of the from argument to the jvolveObject method in the \nnew User class. The v131_User class contains only .eld de.nitions from the original class; all methods \nhave been removed since the updated program may not call them, as discussed below. A typical transformer \ninitializes a new .eld to its default value (e.g., 0 for integers or null for references) and copies \nref\u00aderences to the old values. In the example, the .rst three lines simply copy the previous values of \nusername, domain, and password. A more interesting case is the .eld type change to forwardedAddresses. \nThe default transformer function would initialize the forwardedAddresses .eld to null because of the \ntype change. Here, the programmer has customized the function to instead allocate a new array of EmailAddresses \nand initialize them to the Strings from the old array.  Because the transformer class is separate from \nthe old and new object classes, the Java type system would normally forbid the transformer access to \ntheir private .elds. There is no obvious so\u00adlution to this problem that conforms to the Java type system. \nWe could de.ne object transformers as methods of the old changed classes, which would grant access to \nthe old .elds, but not the new ones. De.ning transformers as methods of the new changed class has the \nreverse problem. Also, the Java type system would disal\u00adlow writes to final .elds from within the transformer \nfunctions. To avoid these problems, we compile our separate transformation class with the JastAdd Java-to-bytecode \nextensible compiler [18] using a simple extension we wrote that ignores access modi.ers (e.g., private \nand protected) and allows methods to assign to final .elds. Bytecode that ignores these modi.ers would \nnot nor\u00admally verify, so we have to modify the VM to allow it in this special circumstance.1 The VM executes \nthese Java functions normally, because they are otherwise standard Java. Since the transforma\u00adtion class \nis only active and available during the update, the VM may delete it after transformation. Separating \ntransformers from updated classes avoids cluttered class .les at run-time, and makes DSU more transparent \nto developers. Supported in its full generality, a transformer method may ref\u00aderence any object reachable \nfrom the global (static) namespace of both the old and new classes, and read or write .elds or call methods \non the old version of an updated object and/or any ob\u00adjects reachable from it. JVOLVE presents a more \nlimited interface (similar to past work [37, 26]). In particular, the only access to the new class namespace \nis via the to pointer, whose .elds are unini\u00adtialized. The old class namespace is accessible, with two \ncaveats. First, .elds of old objects may be dereferenced, but only if the up\u00addate has not changed the \nobject s class, or if it has, after the ref\u00aderenced objects are transformed to conform to the new class \ndef\u00adinition. Second, no methods may be called on any object whose class was updated. In Figure 3 class \nv131_User is de.ned in terms of the .elds it contains; no methods are shown. As explained in Section \n3.4, these limitations stem from the goal of keeping our garbage collector-based traversal safe and relatively \nsimple. This interface is suf.cient to handle all of the updates we tested. An alternative programming \nmodel would be that transform\u00aders could dereference from object .elds and see the old objects, rather \nthan the transformed ones. Boyapati et al. [11] implement this model, as described in Section 5. Our \nexperience and that of others [5, 32, 30, 24] indicate that our model expresses many up\u00addates well. We \nleave to future work a detailed investigation of the semantics and expressiveness of both models. 3. \nJVOLVE DSU Implementation This section describes how we support DSU in JVOLVE by ex\u00adtending common virtual \nmachine services. JVOLVE is built on the Jikes RVM, a high-performance Java-in-Java Research VM [1, 42]. \nJVOLVE integrates and extends the Jikes RVM s dynamic class\u00adloader, JIT compiler, thread scheduler, copying \ngarbage collector (GC), and support for return barriers and on-stack replacement to implement DSU. 1Jikes \nRVM, on which JVOLVE is built, does not implement a bytecode veri.er. Aside from this exceptional case, \nJVOLVE classes are compiled normally and should pass veri.cation. After the user prepares and tests a \nprogram s modi.cations, the update process in JVOLVE proceeds in .ve steps. (1) Our UPT generates an \nupdate speci.cation. (2) The user signals JVOLVE. (3) JVOLVE stops running threads at a DSU safe point. \n(4) It loads the updated classes, the transformer functions, and installs the modi.ed methods and classes. \n(5) JVOLVE then applies object and class transformers following a modi.ed GC. 3.1 Preparing the update \nTo determine the changed and transitively-affected classes for a given release, we wrote a simple Update \nPreparation Tool (UPT)2 that examines differences between the old and new classes provided by the user. \nUPT groups changes into three categories, and lists them in the update speci.cation .le: Class updates: \nThese updates change the class signature by add\u00ading, removing, or changing the types of .elds and methods. \nMethod body updates: These updates change only the internal implementation of a method. Indirect method \nupdates: These are methods whose bytecode is unchanged, but the VM recompiles them because they refer \nto .elds and methods of updated classes. The compiled code uses hard-coded .eld offsets, and the update \nmay change these offsets. UPT generates default object and class transformer functions for all class \nupdates, which the programmer may optionally modify. Af\u00adter compiling the transformers with our custom \nJastAdd compiler (described in Section 2.3), the user initiates the update by signaling the JVOLVE VM \nand providing the new version of the application, the update speci.cation .le, and the transformers class \n.le.  3.2 DSU safe points JVOLVE requires the running system to reach a DSU safe point be\u00adfore it applies \nupdates. DSU safe points occur at VM safe points but further restrict the methods on the threads stacks. \nThese re\u00adstrictions provide sensible update semantics: no code from the new version executes before the \nupdate completes, and no code from the old version executes afterward. As mentioned in Section 2.1, we \ndivide restricted methods into three categories: (1) methods whose bytecode has changed, due to a class \nupdate or a method body up\u00addate; (2) methods whose bytecode has not changed but that access an updated \nclass; and (3) methods the user blacklists. This subsection next discusses why these restrictions improve \nthe safety and semantics of updates, and then describes the actions JVOLVE takes to reach a DSU safe \npoint. Semantics of DSU safe points. Our choice of restricted methods is similar to other DSU systems \n[37, 26, 2, 17, 27, 14, 13, 39]. To understand why category (1) methods are restricted, consider the \nupdate from Figure 2. Assume the thread is stopped at the beginning of the ConfigurationManager.loadUser \nmethod. If the update takes effect at this point, the new implementation of User.setForwardedAddresses \nwill take an object of type EmailAddress[] as its argument. However, if the old version of loadUser were \nto resume, it would still call setForwarded-Addresses with an array of Strings, resulting in a type error. \nPreventing an update until changed methods are no longer on the stack ensures type safety because when \nthe new version of the program resumes it will be self consistent. If a programmer changes the type signature \nof a method m, for the program to compile properly, the programmer must also change any methods that \ncall m. 2 UPT is built using jclasslib: http://www.ej-technologies.com/ products/jclasslib.  In our \nexample, the fact that setForwardedAddresses changed type necessitated changing the function loadUser \nto call it with the new type. With this safety condition, there is no possibility that the signature \nof method m could change and some old caller could call it the update must also include all updated callers \nof m. Category (2) methods are more subtle. Suppose some method getStatus calls method getForwardedAddresses \nfrom our ex\u00adample, but getStatus source code and bytecode has not changed from versions 1.3.1 to 1.3.2. \nNevertheless, getStatus s machine code, produced by the JIT compiler, may need to be recompiled. For \nexample, if the new compiled version of getForwarded-Addresses is at a different offset than before, \nthen the VM must re\u00adcompile getStatus to correctly refer to the new offset. An update may also change \n.eld offsets in modi.ed classes, which requires recompiling any class that accesses them as well. Ginseng \n[32] and POLUS [13], two DSU systems for C, likewise consider functions as changed if their source code \nis the same but they access data types whose (compiled) representation is different. Note that the VM \nwould not need to restrict category (2) methods if it used an interpreter that looked up offsets at each \naccess. Even if a method has not changed, a user may need to manually blacklist it. For example, suppose \na method handle calls meth\u00adods process and cleanup, and the method cleanup initializes a .eld that it \nuses. Now suppose we update this program to move the initialization statement into process, because process \nneeds to use the .eld as well. In both versions, the .eld is properly ini\u00adtialized when the program runs \nfrom scratch. However, suppose that JVOLVE applies the update and the thread running handle yields in \nbetween the calls to process and cleanup. In this case, handle s bytecode has not been changed (process \nand cleanup are method body changes, not class updates), so we could go ahead with the update. But if \nwe did, then the program would have called the old process method, which did not perform any initialization, \nand then would call the new cleanup method, which performs no initialization either, since it the new \nversion process does it, lead\u00ading to incorrect semantics. To avoid such version consistency prob\u00adlems \n[31] the programmer can include handle in the restricted set. Our benchmarks did not require manual restrictions. \nFinally, note that when the VM JIT compiler uses inlining we may need to increase the number of restricted \nmethods to include those into which restricted methods are inlined. In particular, if a category (1), \n(2), or (3) method m is inlined into method n, we should also restrict n (and recompile it, after the \nupdate) to pre\u00advent the old m from running after the update. Jikes RVM initially compiles a method with \nits base-compiler, which generates ma\u00adchine code but does not apply sophisticated optimizations. Based \non run-time pro.ling information, the VM may recompile the same method later using its opt-compiler, \nwhich performs standard op\u00adtimizations, including inlining. It performs inlining of small, fre\u00adquently \nused methods; cost-based inlining for larger methods; and may inline multiple levels down a hot call \nchain. As a consequence, JVOLVE restricts inlined callers of restricted methods. Reaching a DSU safe \npoint. To safely perform VM services such as thread scheduling, garbage collection, and JIT compilation, \nJikes RVM (like most production VMs) inserts yield points on all method entries, method exits, and loop \nback edges. If the VM wants to perform a garbage collection or schedule a higher priority thread, it \nsets a yield .ag, and the threads stop at the next VM safe point. JVOLVE piggybacks on this functionality. \nWhen JVOLVE is informed that an update is available, it sets the yield .ag. Once application threads \non all processors have reached VM safe points, JVOLVE checks the paused threads stacks. If no stack refers \nto a restricted method, JVOLVE applies the update. If any thread is running a restricted method, JVOLVE \ndefers the update and installs a return barrier [43] on the topmost restricted method of each thread. \nA generic return barrier replaces the regular method return branch back to the next instruction in the \ncalling method with a branch to bridge code, which performs some special action and then executes the \nreturn branch. We added this generic return barrier functionality to Jikes RVM, but this technology is \nstandard in other VMs. Our bridge code restarts the update process. Therefore, when a restricted method \nreturns, the thread will block and JVOLVE will restart the update process, which will either reach a \nDSU safe point, or the VM will insert more return barriers. If JVOLVE does not reach a safe point within \n15 seconds, it aborts the update (the length of timeout is arbitrary, and can be con.gured by the user). \nHowever, it turns out we can sometimes proceed with an update despite category (2) methods on-stack, \nas described next. Lifting category (2) restrictions. JVOLVE reduces the number of restricted methods \nin category (2) by leveraging VM support for on-stack replacement (OSR). Jikes RVM normally uses OSR \nto re\u00adplace a base-compiled version of an active method with an opti\u00admized version. We observe that for \ncategory (2) restricted methods, the situation is much the same: an unchanged, on-stack method re\u00adquires \nrecompilation, in our case to .x any changed offsets. If the stack only contains category (2) methods, \nJVOLVE .rst performs OSR, and then starts the update. As of this writing, we only sup\u00adport OSR for base-compiled \ncategory (2) methods, which do not contain any inlined calls, though we plan to support OSR on opt\u00adcompiled \nmethods as well. Jikes RVM s standard OSR functionality works as follows. Af\u00adter reaching a yield point, \nOSR recompiles the topmost method on a thread s stack. The VM then modi.es the thread s current PC to \nswitch to the equivalent location in the new implementation, and adjusts the stack to re.ect the recompiled \nversion. Jikes RVM ex\u00adamines the active stack frame and extracts the values of local vari\u00adables. It generates \na special prologue to the recompiled method that sets up a stack frame with these extracted values. The \nlast instruc\u00adtion in this prologue jumps to the new PC location. The VM then overwrites the return address \nof the yield point function to jump to the prologue. We extend Jikes RVM s OSR facilities to support \nmultiple stack activation records, and multiple stack frames on the same stack. This later addition makes \nit more likely to reach a DSU safe point when a string of category (2) methods precede a changed method \non the stack. Given this support, JVOLVE ignores base-compiled category (2) methods when testing for \na safe point. If any base\u00adcompiled category (2) methods are on stack at an otherwise DSU\u00adsafe point, \nJVOLVE uses OSR to replace them. The exact timing of OSR for DSU requires the VM to .rst load modi.ed \nclasses, as explained next.  3.3 Installing modi.ed classes Once the program reaches a safe point, JVOLVE \nbegins the update by loading and installing the changed classes, and updating relevant metadata in the \nexisting versions. Jikes RVM represents classes with several internal data struc\u00adtures. Each class has \nan RVMClass meta-object that describes the class. It points to other meta-objects that describe the class \ns method and .eld types and offsets in an object instance. The com\u00adpiler and garbage collector query \nthis metadata. Often the compiler can statically determine the type of the object reference. In this \ncase, it queries the meta-object and hard-codes constant offsets into the machine code to generate ef.cient \n.eld and method ac\u00adcess code. The garbage collector uses meta-objects to identify ob\u00adject reference .elds \nand trace the referent objects. RVMClass also stores a type information block (TIB) for each class, which \nmaps a method s offset to its actual implementation. Jikes RVM always compiles a method directly to machine \ncode when the method is .rst invoked. Each object instance contains a pointer to its TIB, to  Figure \n4. Running object transformers following GC support dynamic dispatch. When the program invokes a method \non an object, the generated code indexes the object s TIB at the correct offset and jumps to the machine \ncode. For a class with only method body updates, all of the class s metadata is the same in both the \nold and new versions. Therefore, JVOLVE invalidates the TIB entries for each replaced method, reads in \nthe new method body implementations, and modi.es the exist\u00ading class metadata to refer to the replacement \nmethods bytecode. The JIT will compile the updated method when the program next invokes it, after the \nupdate. For a class update, the class s number, type, and order of .elds or methods may have changed, \nwhich in turn impacts the class s metadata, including its TIB. JVOLVE modi.es existing class meta\u00addata \nas follows. First, it changes the old class s metadata to use a modi.ed class name, e.g., metadata for \nclass User is renamed to v131_User in our example update from Figure 2 and 3. Next, it in\u00adstalls the \nnew RVMClass and corresponding metadata for the new version. Then the VM updates several Jikes RVM data \nstructures (e.g., the Java Table of Contents for static methods and .elds) to indicate that the newly-loaded \nclass is now the up-to-date version. Note that all TIB entries for the newly-installed class are invalid, \nso all methods in the class will be compiled on demand. JVOLVE in\u00advalidates the TIB entries and other \ndata structures for the old class so that they can be garbage-collected. Once method and class updates \nare installed, if category (2) methods are active, the VM initiates OSR for these methods. Invalidating \nchanged methods will impose overhead on the exe\u00adcution just following the update when these methods are \n.rst base\u00adcompiled and then when they are progressively optimized at higher levels, if they execute frequently. \nWe could reduce this overhead somewhat by optimizing new versions directly to their prior level of optimization. \nUpdates to method bodies however invalidate execu\u00adtion pro.les and without branch and call frequencies, \ncode quality would degrade. Thus, we believe it is better to let the adaptive com\u00adpiler work as it was \nintended. In any case, since dynamic updates are relatively rare events, any added overhead due to recompilation \nwill be short-lived.  3.4 Applying Transformers We modify the Jikes RVM semi-space copying collector \n[9] to up\u00addate changed objects as part of a collection. The collector trans\u00adforms old objects of an updated \nclasses to conform to their new class signature and point to their new TIB. A semi-space copying collector \nnormally works by traversing the pointer graph in the old heap (called from-space) starting at the roots \nand performing a tran\u00adsitive closure over the object graph, copying all objects it encoun\u00adters to a new \nheap (called to-space). The roots include statics, stack\u00adallocated local variables, and references in \nregisters. The compiler generates a stack map at every VM safe point (a superset of DSU safe points). \nThe stack map enumerates all register and local vari\u00adables on the stack that reference heap objects. \nWhen the collector .rst encounters an object, it copies it to to-space and then over\u00adwrites its header \nwith a forwarding pointer to the new copy. If the collector encounters a forwarded object later via another \nreference, it uses the forwarding pointer to redirect the reference to the new object. Our modi.ed collector \nworks in much the same way, but differs in how it handles objects whose class signature has changed. \nIn this case, it allocates a copy of the old object and a new object of the new class, which may have \na different size compared to the old one. The collector initializes the new object to point to the TIB \nof the new type, and installs the forwarding pointer in from-space to this new version. Next, the collector \nstores a pair of pointers in its update log, one to the copy of the old object and one to the new object. \nThe collector continues scanning the old copy. After the collection completes, JVOLVE .rst executes trans\u00adformers \nfor all classes and then for all objects. JVOLVE goes through the update log and invokes the object transformer, \npass\u00ading the old and new object pair as arguments. Once it processes all pairs, the log is deleted, making \nthe duplicate old versions unreach\u00adable. Since they are unreachable, the next garbage collection will \nnaturally reclaim them. If we put them in a special space, we could reclaim them immediately. Example. \nFigure 4 illustrates a part of the heap at the end of the GC phase while applying the update from Figure \n3 (forwarding pointers not shown). On the left is a depiction of part of the heap prior to the update. \nIt shows a User object whose .elds point to various other elided objects. After the copying phase, all \nof the old reachable objects are duplicated in to-space. The transformation log points to the new version \nof User (which is initially empty) and the duplicate of the old version, both of which are in to-space. \nThe transformer function can safely copy .elds of the from object. The .gure shows that after running \nthe transformer function, the new version of the object points to the same username .eld as before, and \nit points to a new array which points to new EmailAddress objects. The EmailAddress constructor called \nwithin the trans\u00adformer function initialized these objects by referring to the old e\u00admail String values \nand assigning .elds to point to substrings of the given String. In our example, the jvolveObject function \nonly copies the contents of the old User object s .elds. More generally, our update model allows old \nobject .elds to be dereferenced in transformer functions so long as the .elds point to transformed objects. \nIf some object o is dereferenced while running p s transformer method, but o has not yet been transformed, \nwe must .nd o and pass it and its uninitialized new version to the jvolveObject method to initialize \nit. Since p points to the new version of o, we could scan the remainder of the update log to .nd the \nold version. To avoid this cost, we instead cache a pointer to the old version in the new version during \nthe collection. We take care that jvolveObject functions invoked recursively in this manner do not loop \nin.nitely, which would constitute one or more ill-de.ned transformer functions. We detect cycles with \na simple check, and abort the update. In our current implementation, the programmer uses a special VM \nfunction to force a .eld s referenced object to be transformed. We should be able to handle this case \nautomatically, through a read barrier or a simple analysis of the jvolveObject bytecode.  3.5 Discussion \nOur implementation of object transformers uses an extra copy of all updated objects and adds temporary \nmemory pressure. We could instead copy the old versions to a special block of memory and re\u00adclaim it \nwhen the collection completes. We could attempt to avoid extra copies altogether by invoking object transformer \nfunctions during collection. This approach is more complicated because our transformer model requires \nrecursively invoking the collector from the transformer if a dereferenced .eld has not yet been processed. \nWe also would need to use a GC-time read barrier to follow for\u00adwarding pointers before dereferencing \nan object in order to deter\u00admine whether an object has been transformed. We use a stop-the-world garbage \ncollection-based approach that requires the application to pause for the duration of a full heap GC. \nThis pause time could be mitigated by piggybacking on top of a concurrent collector. We could also consider \napplying object and class transformers lazily, as they are needed [37, 26, 11, 32, 13]. The main drawback \nhere is ef.ciency. The VM would need to insert code to check, at each dereference, whether the object \nis up-to\u00addate, imposing extra overhead on steady-state execution. Moreover, stateful actions by the program \nafter an update may invalidate assumptions made by object transformer functions. It is possible that \na hybrid solution could be adopted, similar to Chen et al. [13], which removes checking code once the \nsystem updates all objects. We leave exploration of these ideas to future work. Finally, our OSR support \nis currently limited to on-stack meth\u00adods whose bytecode has not changed. We plan to further extend OSR \nto support changed methods on the stack, similar to what is provided by UpStare, a DSU system for C [24]. \nFor changed meth\u00adods the user wishes to update while they run, she must additionally provide a mapping \nbetween the yield points in the old method to similar points in the new method. For example, a common \nchange is to modify the contents of an event handling loop. The user would map the yield point at the \nend of the old loop to the yield point at the end of the new loop. The user would also have to provide \nthe analogue of an object transformer for initializing the contents of the new method s stack frame, \ngiven the old stack frame contents. As with object transformers, this update model poses a question: \nshould the stack frame transformer be allowed to dereference ob\u00adjects in the old stack frame if they \ntoo have changed? We leave exploration of updating active methods to interesting future work. 4. Experience \nTo evaluate JVOLVE, we used it to update three open-source servers written in Java: the Jetty webserver3, \nJavaEmailServer,4 an SMTP 3 http://www.mortbay.org 4 http://www.ericdaugherty.com/java/mailserver/ Con.g. \nThroughput (MB/s) Latency (ms) Median Quartiles Median Quartiles Jikes RVM JVOLVE JVOLVE upd 122.437 \n121.308 121.242 121.44 123.32 121.12 121.41 121.09 121.29 0.442 0.349 0.345 0.394 0.496 0.341 0.351 0.341 \n0.349  Figure 5. Throughput and latency measurements of Jetty web\u00adserver v5.1.6 and POP e-mail server, \nand CrossFTP server.5 These programs be\u00adlong to a class that should bene.t from DSU because they typically \nrun continuously. DSU would enable deployments to incorporate bug .xes or add new features without having \nto halt currently\u00adrunning sessions. We explored updates corresponding to releases made over roughly one \nto two years of each program s lifetime. Of the 22 updates we considered, JVOLVE could support 20 of \nthem the two updates we could not apply changed classes with in.nitely\u00adrunning methods, and thus no safe \npoint could be reached. To our knowledge, no existing DSU system for Java could support all these updates; \nindeed, previous systems with simple support for updating method bodies would be able to handle only \n9 of the 22 updates. Although JVOLVE cannot support every update, it is the .rst DSU system for Java \nthat has been shown to support changes to realistic programs as they occur in practice over a long period \nof time. In the rest of this section, we .rst examine the performance impact of JVOLVE, and then look \nat updates to each of the three applications in detail. 4.1 Performance The main performance impact \nof JVOLVE is the cost of applying an update; once updated, the application eventually runs without fur\u00adther \noverhead. To con.rm this claim, we measured the throughput and latency of two Jetty versions while running \non stock Jikes RVM and on JVOLVE after dynamically updating to the next version. The performance of these \ncon.gurations is essentially identical. The cost of applying an update is the time to load any new classes, \ninvoke a full heap garbage collection, and to apply the transformation methods on objects belonging to \nupdated classes. Roughly, the time to suspend threads and check that the application is in a safe-point \nis less than a millisecond, and classloading time is usually less than 20ms. Therefore the update disruption \ntime is pri\u00admarily due to the GC and object transformers, and is proportional to the size of the heap \nand the fraction of objects being transformed. We wrote a simple microbenchmark to measure these overheads. \nThis experiment shows that object transformation is the dominant cost. We conducted all our experiments \non an Intel Core 2 Quad ma\u00adchine running at 2.4 GHz machine with 2 GB of RAM. The ma\u00ad 5 http://www.crossftp.com/ \n # objects Heap size 0% 10% Fraction of updated objects 20% 30% 40% 50% 60% 70% 80% 90% 100% Garbage \ncollection time (ms) 280000 160 MB 78.2 81.3 83.1 89.3 99.0 103.2 108.3 113.2 113.3 120.3 120.0 770000 \n320 MB 148.9 165.0 181.9 195.8 213.2 223.2 237.0 249.0 262.0 269.5 278.6 1760000 640 MB 313.3 347.7 382.9 \n416.0 449.8 478.9 506.8 534.0 558.8 583.7 601.5 3670000 1280 MB 615.4 694.6 763.0 833.6 900.1 965.9 1019.0 \n1076.4 1129.9 1181.2 1217.5 Running transformation functions (ms) 280000 160 MB 0.1 13.0 23.2 34.6 43.9 \n54.0 62.7 74.5 84.1 93.9 104.2 770000 320 MB 0.1 33.7 63.1 91.2 116.8 145.4 173.9 201.0 231.3 262.0 292.6 \n1760000 640 MB 0.1 77.9 143.9 207.7 269.5 333.7 397.6 464.0 534.6 604.5 674.9 3670000 1280 MB 0.1 160.8 \n299.2 429.4 560.2 693.8 827.3 975.0 1119.6 1263.7 1405.4 Total DSU pause time (ms) 280000 160 MB 82.8 \n99.0 109.5 128.0 147.6 161.2 174.5 192.8 202.5 218.8 228.1 770000 320 MB 153.6 202.9 249.0 291.4 334.5 \n372.6 414.8 455.4 498.1 535.3 576.8 1760000 640 MB 316.6 429.5 530.5 627.2 723.4 816.0 908.6 1002.6 1097.5 \n1191.5 1281.2 3670000 1280 MB 618.7 859.0 1065.9 1269.9 1466.1 1663.6 1850.8 2054.2 2253.1 2448.5 2627.9 \n Table 1. Microbenchmark results: JVOLVE update pause time (in ms) for various heap sizes chine ran Ubuntu \n7.10 on Linux kernel version 2.6.22. We imple\u00admented JVOLVE on top of Jikes RVM (SVN r15532). Jetty performance. \nTo see the effect of updating on application performance, we measured Jetty under various con.gurations \nus\u00ading httperf, a webserver benchmarking tool.6 We used httperf to issue roughly 800 new connection requests/second, \nwhich we ob\u00adserved to be Jetty s saturation rate. Each connection makes 5 se\u00adrial requests for a 40 Kbyte \n.le. Httperf reports average throughput and average per-request latency over a 60 second period. We ran \nthis experiment 21 times and report the median and quartiles of the throughput and latency reports. With \n21 runs, the range between the quartiles serves as a 98% condence interval [36]. In order to eliminate \nnetwork traf.c effects, we ran the server on two cores of a quad-core machine and the client on another \ncore. Figure 5 shows our results in tabular form and plotted graph\u00adically. The second and third columns \nof the table report the me\u00addian throughput and the range between the two quartiles. The third column \nand fourth column report the median latency and the inter\u00adquartile range. The .rst and seconds rows illustrate \nthe performance of Jetty version 5.1.6 running on stock Jikes RVM and JVOLVE, respectively. The third \nrow shows the performance on JVOLVE of Jetty 5.1.6 dynamically updated from version 5.1.5 prior to the \nstart of the experiment. The performance of the two JVOLVE con.gura\u00adtions is essentially identical: the \ntwo con.gurations corresponding inter-quartile ranges largely overlap. The performance of JVOLVE is also \nquite similar to the performance of stock Jikes RVM. There are many small differences between JVOLVE \nand the stock imple\u00admentation that change VM code size, code layout, and garbage collection behavior. \nThese differences may impact performance di\u00adrectly and they may indirectly affect other elements of the \nVM, such as the timing of garbage collections and JIT optimizations (such indirect effects make VMs notoriously \ndif.cult to bench\u00admark [10]). Microbenchmarks. The two dominant factors that determine JVOLVE update \ntime are the time to perform a GC, determined by the number of objects, and the time to run object transformers, \ndetermined by the fraction of objects being updated. To measure the cost of each, we devised a simple \nmicrobenchmark that cre\u00adates an array of objects and transforms a speci.ed fraction of these objects \nwhen a JVOLVE update is triggered. The microbenchmark has two simple classes, Change and NoChange. Both \ncontain three integer .elds, and three reference .elds that are always null. The 6 http://www.hpl.hp.com/research/linux/httperf \n Figure 6. Microbenchmark pause times with a heap size of 1280 MB containing 3.67 million objects update \nadds an integer .eld to Change. The user-provided object transformation function copies the existing \n.elds and initializes the new .eld to zero. We measure the cost of performing an update while varying \nthe total number of objects and the fraction of objects of each type. The number of objects is the maximum \nthat can .t in heap sizes 32, 64, 128 and 256 MB. Note that Jikes RVM s heap includes VM data structures \nas well. We measure the running time in a generous heap, .ve times the minimum required size, such that \nthe only collections are those DSU triggers. We report the median of 21 runs. Table 1 shows the elapsed \ntime while varying the number of total objects and the fraction of the objects that are updated. The \nvariance was insigni.cant, so we do not report it. The .rst group of rows reports garbage collection \ntime, the second group reports the time to transform all updated objects, and the .nal group reports \nthe total update time, which includes the sum of the GC and trans\u00adformation time, the time to load and \ninstall the updated classes, synchronize running threads, and .nd a DSU safe point. The .rst column of \nthe table shows the number of objects in the test, and the second column the heap size. Columns 3 though \n13 show pause times for varying fractions (from 0% to 100%) of updated objects.  Ver. # # changed Ver. \n# classes # changed classes classes methods .elds add del classes methods .elds added add del chg add \ndel add del chg add del 5.1.1 0 14 4 1 38/0 0 0 1.2.2 0 0 3 0 0 3/0 0 0 5.1.2 1 5 0 0 12/1 0 0 1.2.3 \n0 0 7 0 0 14/2 12 0 5.1.3* 3 15 19 2 59/0 10 1 1.2.4 0 0 2 0 0 4/0 0 0 5.1.4 0 6 0 4 9/6 0 2 1.3* 4 9 \n2 11 3 6/9 12 5 5.1.5 0 54 21 4 112/8 5 0 1.3.1 0 0 2 0 0 4/0 0 0 5.1.6 0 4 0 0 20/0 5 6 1.3.2 0 0 8 \n4 2 4/2 3 1 5.1.7 0 7 8 0 11/2 9 3 1.3.3 0 0 4 0 0 3/0 0 0 5.1.8 0 1 0 0 1/0 0 0 1.3.4 0 0 6 2 0 6/0 \n2 0 5.1.9 0 1 0 0 1/0 0 0 1.4 0 0 7 6 1 4/1 6 0 5.1.10 0 4 0 0 4/0 0 0 Table 2. Summary of updates to \nJetty To shed light on the results in the table, Figure 6 plots collection time, transformer time and \ntotal update time for the microbench\u00admark with 3.67 million objects in a 1280 MB heap. The .gure shows \nthat the costs of garbage collection and transformation in\u00adcrease as a function of the number of changed \nobjects. The slope of the GC time line illustrates the cost to deal with an increas\u00ading number of transformed \nobjects. This cost includes creating an additional copy of each transformed object; creating the update \nlog entry with a pointer to the old and new copy; and caching a pointer to the old copy from the new \ncopy. The slope of the Running trans\u00adformers line illustrates the added cost of iterating over the update \nlog and actually running the transformers. This extra processing to handle transforming objects increases \nthe total pause time with all objects updated by roughly four times compared to the pause time with no \nobject updated. The Running Transformers line is steeper than the GC time line, revealing that the cost \nof running transformers is higher than the extra copying cost incurred during GC. Transformations are \nmore expensive than standard copying GC. The GC uses memcopy, which is highly optimized, whereas our \ntransformer functions use re.ection to look up jvolveObject, and this function copies one .eld at a time. \nOne optimization would be to eliminate the log by copying the old and new objects to their own space \nand walking through and transforming each object. The cost of re.ection could be reduced by caching the \nlookup, but even then a na\u00a8ively compiled .eld-by-.eld copy is much slower than the collector s highly-optimized \ncopying loop.  4.2 Jetty webserver Jetty is a popular webserver written in Java. It supports static \nand dynamic content and can be embedded within other Java applica\u00adtions. Jikes RVM, and thus JVOLVE, \nis not able to run the most recent versions of Jetty (6.x). Therefore we considered 11 versions, consisting \nof 5.1.0 through 5.1.10 (the last version prior to version 6). Version 5.1.10 contains 317 classes and \nabout 45,000 lines of code. Table 2 shows a summary of the changes in each update. Each row tabulates \nthe changes relative to the prior version. For the column listing changed methods, the notation x/y indicates \nthat x + y methods were changed, where x changed in body only, and y changed their type signature as \nwell. For dynamic updating sys\u00adtems that only support changes to method bodies, only the .rst and last \nthree of the ten updates could be supported, since the rest either change method signatures and/or add \nor delete .elds. Reaching a safe point in Jetty. We successfully wrote dynamic updates to all versions \nof Jetty that we examined. For each version starting at 5.1.0, we ran Jetty under full load. After 30 \nseconds we tried to apply the update to the next version. We did this .ve times Table 3. Summary of updates \nto JavaEmailServer Ver. # classes add del classes # changed methods add del chg .elds add del 1.06 1.07 \n1.08 4 0 0 1 0 1 1 3 3 0 4 2 0 0 0 3/0 14/0 10/0 1 5 0 0 0 2 Table 4. Summary of updates to CrossFTP \nserver per version. Other than the update to 5.1.3, all versions immediately reached a safe point every \ntime, with no need of return barriers. We could not apply the update to version 5.1.3 (denoted with an \nasterisk in the table) because JVOLVE was never able to reach a safe point. The update modi.ed ThreadedServer.acceptSocket(), \na method that waits for a connection from the client, and this method is nearly always on stack. We installed \na return barrier that is triggered when acceptSocket returns, but this barrier is not suf.cient to perform \nthe update since the main methods of several threads were themselves modi.ed. For example, we also install \na return barrier on PoolThread.run(), but this barrier is never triggered because this method never becomes \ninactive. 4.3 JavaEmailServer For JavaEmailServer, we considered 10 versions 1.2.1 through 1.4 spanning \na duration of about two years. Version 1.4 consists of 20 classes and about 5000 lines of code. Table \n3 shows the sum\u00admary of changes for each new version. Approaches that only sup\u00adport updates to method \nbodies will be able to handle only four of these updates. We could successfully construct updates for \nall ver\u00adsions we examined, and we could successfully apply all of them except the update to version 1.3. \nThis update reworks the con.gu\u00adration framework of the server, among other things removing a GUI tool \nfor user administration and adding several new classes that im\u00adplement a .le-based con.guration system. \nAs a result, many of the classes are modi.ed to point to a new con.guration object. Among these classes \nare threads with in.nite processing loops (e.g., to ac\u00adcept POP and SMTP requests). Because these threads \nare always active, the safety condition can never be met and thus the update cannot be applied. The update \nfrom 1.3.1 to 1.3.2 indirectly changes the SMTPSen\u00adder.run() and Pop3Processor.run() methods. These methods \ncontain processing loops run by several threads. Though these methods are always running, JVOLVE applies \nOSR and the update succeeds. JVOLVE also uses OSR for the update from 1.3.2 to 1.3.3.  4.4 CrossFTP \nserver CrossFTP server is an easily con.gurable, security-enabled FTP server. CrossFTP allows simple \ncon.guration through a GUI and more advanced customization using con.guration .les. We did not use the \nGUI interface and therefore do not consider changes to that part of the program. We looked at 4 versions \n1.05 through 1.08, details shown in Table 4 spanning a duration of more than a year. Version 1.08 contains \nabout 18,000 lines of code spread across 161 classes. JVOLVE successfully applies all three updates to \nthis application. Note that since all updates either add or delete .elds, simple method body updating \nsupport on its own would be insuf.cient.  JVOLVE could only apply the update from version 1.07 to 1.08 \nwhen the server was relatively idle. The server runs a new RequestHandler thread to process each FTP \nsession, and the RequestHandler.run() method was changed by the update. JVOLVE installs a return barrier \non this method, but with many ac\u00adtive sessions, this method is essentially always on stack, preventing \nthe update. Future work could address this problem using scheduler support for coordinating updates among \nactive threads [30]. 5. Related Work We compare our VM-centric approach to DSU with related work on implementing \nDSU for managed languages, C, and C++. Edit and continue. Debuggers and IDEs have long provided edit \nand continue (E&#38;C) functionality that permits limited modi.ca\u00adtions to program state to avoid stopping \nand restarting during de\u00adbugging. For example, Sun s HotSwap VM [27, 15], .NET Visual Studio for C# and \nC++ [14], and library-based support [17] for .NET applications all provide E&#38;C. These systems restrict \nupdates to code changes within method bodies. While this restriction re\u00adduces safety concerns and obviates \nthe need for class and object transformers, the resulting systems are in.exible. They cannot per\u00adform \nmore than half of the updates discussed in Section 4. DSU for managed languages without VM support. To \navoid changing the VM to support DSU, researchers have developed special-purpose classloaders and/or \ncompiler support. The main drawbacks of these approaches are in.exibility and high overhead. For example, \nEisenbach and Barr [4] and Milazzo et al. [28] use custom classloaders for binary-compatible and component-level \nchanges respectively, but cannot perform class .eld additions. Orso et al. [35] use source-to-source \ntranslation for DSU by introducing a proxy object that indirectly accesses an object that may change. \nThis approach requires updated classes to export the same public interface, forbidding new public methods \nand .elds. Non VM-based approaches are in general limiting because they are not transparent they make \nvisible changes to the class hierarchy, and insert or rename classes. This approach makes it essentially \nimpossible to be robust in the face of code using re.ection or native methods. Moreover, the indirection \nimposes time and space overheads on steady-state execution. Our VM approach naturally supports re.ection \nand native methods (these are updated as well), and is more expressive, e.g., it supports signature changes. \nVM support for DSU in managed languages. The PROSE sys\u00adtem performs short-term, run-time patches to code \nfor logging, in\u00adtrospection, and performance adaptation, rather performing general updates [33]. An Eclipse \nplug-in performs run-time bytecode in\u00adstrumentation and a modi.ed JIT performs method code replace\u00adment, \nusing an API in the style of aspect-oriented programming. PROSE has the same update model as the E&#38;C \nsystems: it sup\u00adports updates to method bodies but not class or method signature changes that require \nchanges to object state. JDrums [37] and Dynamic Virtual Machine (DVM) [26] both implement DSU for Java \nwithin the VM, providing a programming interface similar to JVOLVE, but are lacking in two ways. First, \nnei\u00adther JDrums nor DVM have ever been demonstrated to support up\u00addates from real-world applications. \nSecond, their implementations impose overheads during steady-state execution. They both update lazily \nand use an extra level of indirection (the handle space). Indi\u00adrection conveniently supports object updates, \nbut adds extra over\u00adhead. For example, JDrums traps all object pointer dereferences to apply VM object \ntransformer function(s) when the object s class changes. Lazy updating has the advantage that it amortizes \npauses due to an update over subsequent execution. The main drawback is that its overhead persists during \nnormal execution, even though updates are relatively rare. DVM works only with the interpreter. Relative \nto this interpreter, which is already slow, the extra traps result in roughly 10% overhead. Compared \nto these two, JVOLVE performs updates eagerly by employing a full heap collection at update-time. This \nstop-the\u00adworld approach imposes a longer pause at update time, but elim\u00adinates overhead during steady-state \nexecution. Likewise, by invali\u00addating updated methods, JVOLVE s performance is slowed just after the \nupdate as these methods are being recompiled. However, com\u00adpared to running with an interpreter, steady-state \nexecution is much improved, since methods will be much better optimized. Boyapati et al. [11] support \ndynamic updates to classes kept in a persistent object store (POS). While the setting is different, their \nbasic update model, and in particular their notion of object trans\u00adformer function, is similar to ours. \nIn their system, programmers manually write an object transformer that they view as a method on the old \nversion of the updated class, i.e., the transformer method is type-safe with respect to the old class. \nIn JVOLVE, object trans\u00adformers may access the new versions of objects pointed to from the old class. \nInstead, Boyapati et al. s transformers may access the old versions. To implement this model, they rely \non encapsulation based on ownership types: if an object a of class A has an owned .eld pointing to an \nobject b of class B, then only a can point to (and access) b. Encapsulation thus ensures the system will \nalways transform a before b, which makes the transformation algorithm more ef.cient. They rely on the \nprogrammer to enforce encapsula\u00adtion, and describe how the compiler could automate language sup\u00adport \nfor encapsulation in a non-standard type system. JVOLVE takes the opposite tack of forcing old object \n.elds to point to up-to-date objects, and thus requires no special language support. Moreover, JVOLVE \ns model follows that of earlier work [5, 32, 30, 24] which has proven its effectiveness on a half-dozen \nrealistic applications across several years worth of releases. However, further research to understand \nthe costs and bene.ts of the two updating models would be useful. Boyapati et al. also differs from JVOLVE \nin that, like JDRUMS and DVM, updates are applied incrementally as objects are ac\u00adcessed following an \nupdate rather than all at once using a stop\u00adthe-world GC. This incremental cost is more natural in a \nPOS since indirection is already required to access external objects. The POS model also permits programmers \nto specify ACID transaction boundaries, which can help ensure that updates are applied con\u00adsistently \nand safely. In contrast, our work focuses on supporting dynamic upgrades in a high-performance VM for \nJava, and thus many of the issues we consider reaching a safe point via return barriers and OSR, and \ncoexisting with the JIT compiler are the unique contributions of our work. Dynamic Software Updating \nfor C/C++ There are several sub\u00adstantial systems for dynamically updating C and C++ programs that target \nserver applications [22, 2, 32, 13, 24, 30] and operating sys\u00adtems components [39, 5, 12, 23, 25]. Although \nsome of these sys\u00adtems are mature, the .exibility afforded by JVOLVE is comparable or superior. JVOLVE \ns timing restrictions and Java s type safety also provide comparable or superior safety; the fact that \nC and C++ pro\u00adgrams often circumvent the languages weak type systems greatly complicates efforts to ensure \nthat updates behave correctly. Some prior systems [30, 24, 13] have focused on means to reach DSU safe \npoints quickly, and we plan similar efforts as future work. In particular, we plan to extend our support \nfor OSR to apply to run\u00adning methods whose bytecode has changed, allowing the user to map an active method \ns PC and stack frame and those of its new version, similar to support provided by UpStare [24].  The \nlack of a VM is a disadvantage for C and C++ DSU. For example, because a VM-based JIT can compile and \nrecompile re\u00adplacement classes, it imposes no steady-state execution overhead. By contrast, C and C++ \nimplementations must use either statically\u00adinserted indirections [22, 32, 39, 5, 24] or dynamically-inserted \ntrampolines to redirect function calls [2, 12, 13, 3]. Both cases impose persistent overhead on normal \nexecution and inhibit opti\u00admization. Likewise, because these systems lack a garbage collec\u00adtor, they \neither do not update object instances at all [3], update them lazily [32, 13] or perform extra allocation \nand bookkeeping to locate the objects at update-time [5]. Finally, because these sys\u00adtems lack support \nfor on-stack replacement, they must pre-compile potentially long-running methods specially, so that they \ncan be up\u00addated while they run. These techniques impose time and space over\u00adheads on steady-state execution, \nand in some cases limit update .exibility. Other proposals Gilmore et al. [20] propose DSU support for \nmodules in ML programs using a similar, but more restrictive programming interface compared with JVOLVE. \nThey formalize an abstract machine for implementing updates using a copying garbage collector. Duggan \n[16] also proposes dynamic updates to ML programs, focusing on lazy updates to data type de.nitions. \nNeither approach was ever implemented. UpgradeJ [8] is an extension to the Java language design sup\u00adporting \nclass upgrades, in two .avors: revision upgrades, which may modify method bodies, and evolution upgrades, \nwhich may add new methods and .elds. Programmers control the effects of up\u00adgrades using version annotations, \nintroduced by Bierman et al. [7] in earlier work. For example, the programmer may write o = new Button[1=]() \nto force o to always use version 1 methods, while writing p = new Button[1+]() or p = new Button[1++]() \nallows p to be revised or evolved, respectively. UpgradeJ s update model is easier to implement than \nJVOLVE s because it need not change existing object instances. Of course, the downside is a loss of .exibility. \nMany of the updates to our benchmark applications change .eld contents and layout. UpgradeJ does not \nsupport these updates. On the other hand, evolution upgrades add power over simple method body updates, \nand consequently enable more real\u00adworld updates to be supported [41]. There is no implementation of UpgradeJ. \n6. Conclusions This paper presents JVOLVE, a Java virtual machine with support for dynamic software updating. \nJVOLVE is the most full-featured, best-performing implementation of DSU for Java published to date. We \ndemonstrate its .exibility and safety by successfully applying updates for one to two years worth of \nreleases for three programs: Jetty webserver, JavaEmailServer, and CrossFTP server. JVOLVE imposes no \noverhead during a program s steady-state execution. JVOLVE s DSU support builds naturally on top of existing \nVM ser\u00advices, including dynamic class loading, thread synchronization, re\u00adturn barriers, on-stack replacement, \nJIT compilation, and garbage collection. It is probably optimistic to believe that DSU will be able to \nsupport every update. Nevertheless, our results demonstrate that dynamic software updating support can \nbe naturally incorporated into modern VMs, and that doing so has the potential to signi.\u00adcantly improve \nsoftware availability by reducing downtime. Acknowledgments We thank Iulian Neamtiu and the anonymous \nreviewers for helpful comments on drafts of this paper. We thank the Jikes RVM commu\u00adnity, Mike Bond, \nDavid Grove, and Filip Pizlo for helpful advice, particularly toward understanding Jikes RVM. This work \nis sup\u00adported by NSF CNS-0346989, CCF-0811524, NSF CNS-0719966, NSF CCF-0429859, Intel, IBM, CISCO, and \nMicrosoft. Any opin\u00adions, .ndings and conclusions expressed herein are the authors and do not necessarily \nre.ect those of the sponsors. References [1] B. Alpern, D. Attanasio, J J. Barton, A. Cocchi, S. Flynn \nHummel, D. Lieber, M. Mergen, T. Ngo, J Shepherd, and S. Smith. Implement\u00ading Jalape no in Java. In Proc. \nOOPSLA, 1999. [2] Gautam Altekar, Ilya Bagrak, Paul Burstein, and Andrew Schultz. OPUS: Online patches \nand updates for security. In Proc. USENIX Security, 2005. [3] Jeff Arnold and Frans Kaashoek. Ksplice: \nAutomatic rebootless kernel updates. In Proc. EuroSys, 2009. [4] Miles Barr and Susan Eisenbach. Safe \nupgrading without restarting. In Proc. ICSM, 2003. [5] A. Baumann, J. Appavoo, D. Da Silva, J. Kerr, \nO. Krieger, and R. W. Wisniewski. Providing dynamic update in an operating system. In Proc. USENIX Annual \nTechnical Conference, 2005. [6] Andrew Baumann, Jonathan Appavoo, Robert W. Wisniewski, Dilma Da Silva, \net al. Reboots are for hardware: challenges and solutions to updating an operating system on the .y. \nIn Proc. USENIX Annual Technical Conference, 2007. [7] Gavin Bierman, Michael Hicks, Peter Sewell, and \nGareth Stoyle. For\u00admalizing dynamic software updating. In Proc. Second International Workshop on Unanticipated \nSoftware Evolution, 2003. [8] Gavin Bierman, Matthew Parkinson, and James Noble. UpgradeJ: Incremental \ntypechecking for class upgrades. In Proc. ECOOP, pages 235 259, 2008. [9] S. M. Blackburn, P. Cheng, \nand K. S. McKinley. Oil and water? High performance garbage collection in Java with MMTk. In Proc. ICSE, \n2004. [10] S. M. Blackburn, K. S. McKinley, R. Garner, C. Hoffman, A. M. Khan, R. Bentzur, A. Diwan, \nD. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, M. Jump, H. Lee, J. E. B. Moss, A. Phansalkar, \nD. Stefanovi\u00b4c, T. VanDrunen, D. von Dincklage, and B. Wiedermann. Wake up and smell the coffee: Evaluation \nmethodology for the 21st century. Communications of the ACM, 51(8):83 89, August 2008. [11] Chandrasekhar \nBoyapati, Barbara Liskov, Liuba Shrira, Chuang-Hue Moh, and Steven Richman. Lazy modular upgrades in \npersistent object stores. In Proc. OOPSLA, 2003. [12] Haibo Chen, Rong Chen, Fengzhe Zhang, Binyu Zang, \nand Pen-Chung Yew. Live updating operating systems using virtualization. In Proc. VEE, June 2006. [13] \nHaibo Chen, Jie Yu, Rong Chen, Binyu Zang, and Pen-Chung Yew. POLUS: A POwerful Live Updating System. \nIn Proc. ICSE, 2007. [14] Microsoft Corporation. Edit and continue. http://msdn2. microsoft.com/en-us/library/bcew296c.aspx, \n2008. [15] M. Dmitriev. Towards .exible and safe technology for runtime evolution of java language applications. \nIn Proc. Workshop on Engineering Complex Object-Oriented Systems for Evolution, 2001. [16] Dominic Duggan. \nType-based hot swapping of running modules. Acta Inf., 41(4-5):181 220, 2005. [17] Marc Eaddy and Steven \nFeiner. Multi-language edit-and-continue for the masses. Technical Report CUCS-015-05, Columbia University \nDepartment of Computer Science, April 2005. [18] Torbj\u00a8orn Ekman and G\u00a8orel Hedin. The Jastadd extensible \nJava compiler. In Proc. OOPSLA, 2007.  [19] Slashdot forum. Patch the kernel without reboots. http://tech. \nslashdot.org/article.pl?sid=08/04/24/1334234, April 2008. Consists of a lively technical debate about \nthe bene.ts and drawbacks of in-place dynamic updates vs. using redundant hardware. [20] Stephen Gilmore, \nDilsun Kirli, and Chris Walton. Dynamic ML without dynamic types. Technical Report ECS-LFCS-97-378, LFCS, \nUniversity of Edinburgh, 1997. [21] Deepak Gupta, Pankaj Jalote, and Gautam Barua. A formal framework \nfor on-line software version change. IEEE Trans. Softw. Eng., 22(2):120 131, 1996. [22] G. Hj\u00b4almt\u00b4ysson \nand R. Gray. Dynamic C++ classes, a lightweight mechanism to update code in a running program. In Proc. \nUSENIX Annual Technical Conference, 1998. [23] Yueh-Feng Lee and Ruei-Chuan Chang. Hotswapping linux \nkernel modules. J. Syst. Softw., 79(2):163 175, 2006. [24] Kristis Makris and Rida Bazzi. Multi-threaded \ndynamic software updates using stack reconstruction. In Proc. USENIX Annual Technical Conference, 2009. \n[25] Kristis Makris and Kyung Dong Ryu. Dynamic and adaptive updates of non-quiescent subsystems in commodity \noperating system kernels. In Proc. EuroSys, March 2007. [26] Scott Malabarba, Raju Pandey, Jeff Gragg, \nEarl Barr, and J. Fritz Barnes. Runtime support for type-safe dynamic Java classes. In Proc. ECOOP, 2000. \n[27] Sun Microsystems. Java Platform Debugger Architecture, 2004. This supports class replacement. See \nhttp://java.sun.com/javase/ 6/docs/technotes/guides/jpda/. [28] Marco Milazzo, Giuseppe Pappalardo, Emiliano \nTramontana, and Giuseppe Ursino. Handling run-time updates in distributed applications. In Proc. SAC, \n2005. [29] Iulian Neamtiu, Jeffrey S. Foster, and Michael Hicks. Understanding source code evolution \nusing abstract syntax tree matching. In Proc. International Workshop on Mining Software Repositories, \n2005. [30] Iulian Neamtiu and Michael Hicks. Safe and timely dynamic updates for multi-threaded programs. \nIn Proc. PLDI, 2009. [31] Iulian Neamtiu, Michael Hicks, Jeffrey S. Foster, and Polyvios Pratikakis. \nContextual effects for version-consistent dynamic software updating and safe concurrent programming. \nIn Proc. POPL, 2008. [32] Iulian Neamtiu, Michael Hicks, Gareth Stoyle, and Manuel Oriol. Practical dynamic \nsoftware updating for C. In Proc. PLDI, 2006. [33] Angela Nicoara, Gustavo Alonso, and Timothy Roscoe. \nControlled, systematic, and ef.cient code replacement for running Java programs. In Proc. Eurosys, 2008. \n[34] D. Oppenheimer, A. Brown, J. Beck, D. Hettena, J. Kuroda, N. Treuhaft, D. A. Patterson, and K. Yelick. \nRoc-1: Hardware support for recovery-oriented computing. IEEE Trans. Comput., 51(2):100 107, 2002. [35] \nAlessandro Orso, Anup Rao, and Mary Jean Harrold. A technique for dynamic updating of Java software. \nIn Proc. ICSM, 2002. [36] J. W. Pratt and J. D. Gibbons. Concepts of Nonparametric Theory. Springer-Verlag, \n1981. [37] Tobias Ritzau and Jesper Andersson. Dynamic deployment of Java applications. In Proc. Java \nfor Embedded Systems Workshop, 2000. [38] D. Scott. Assessing the Costs of Application Downtime. Gartner \nGroup, 1998. [39] C. Soules, J. Appavoo, K. Hui, D. Da Silva, G. Ganger, O. Krieger, M. Stumm, R. Wisniewski, \nM. Auslander, M. Ostrowski, B. Rosen\u00adburg, and J. Xenidis. System support for online recon.guration. \nIn Proc. USENIX Annual Technical Conference, June 2003. [40] Gareth Stoyle, Michael Hicks, Gavin Bierman, \nPeter Sewell, and Iulian Neamtiu. Mutatis Mutandis: Safe and .exible dynamic software updating (full \nversion). TOPLAS, 29(4):22, August 2007. [41] Ewan Tempero, Gavin Bierman, James Noble, and Matthew Parkinson. \nFrom Java to UpgradeJ: an empirical study. In Proc. International Workshop on Hot Topics in Software \nUpgrades (HotSWUp), 2008. [42] The Jikes RVM Core Team. VM performance comparisons, 2007. http://dacapo.anu.edu.au/regression/perf/head.html. \n[43] Taiichi Yuasa. Design and implementation of Kyoto Common Lisp. Journal of Information Processing, \n13(3):284 295, 1990. [44] Benjamin Zorn. Personal communication, based on experience with Microsoft Windows \ncustomers, August 2005.   \n\t\t\t", "proc_id": "1542476", "abstract": "<p>Software evolves to fix bugs and add features. Stopping and restarting programs to apply changes is inconvenient and often costly. Dynamic software updating (DSU) addresses this problem by updating programs while they execute, but existing DSU systems for managed languages do not support many updates that occur in practice and are inefficient. This paper presents the design and implementation of J<sc>volve</sc>, a DSU-enhanced Java VM. Updated programs may add, delete, and replace fields and methods anywhere within the class hierarchy. Jvolve implements these updates by adding to and coordinating VM classloading, just-in-time compilation, scheduling, return barriers, on-stack replacement, and garbage collection. J<sc>volve</sc>, is <i>safe</i>: its use of bytecode verification and VM thread synchronization ensures that an update will always produce type-correct executions. Jvolve is <i>flexible</i>: it can support 20 of 22 updates to three open-source programs--Jetty web server, JavaEmailServer, and CrossFTP server--based on actual releases occurring over 1 to 2 years. Jvolve is <i>efficient</i>: performance experiments show that incurs <i>no overhead</i> during steady-state execution. These results demonstrate that this work is a significant step towards practical support for dynamic updates in virtual machines for managed languages.</p>", "authors": [{"name": "Suriya Subramanian", "author_profile_id": "81435597339", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1464376", "email_address": "", "orcid_id": ""}, {"name": "Michael Hicks", "author_profile_id": "81100060959", "affiliation": "University of Maryland, College Park, MD, USA", "person_id": "P1464377", "email_address": "", "orcid_id": ""}, {"name": "Kathryn S. McKinley", "author_profile_id": "81100402805", "affiliation": "The University of Texas at Austin, Austin, TX, USA", "person_id": "P1464378", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542478", "year": "2009", "article_id": "1542478", "conference": "PLDI", "title": "Dynamic software updates: a VM-centric approach", "url": "http://dl.acm.org/citation.cfm?id=1542478"}