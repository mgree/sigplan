{"article_publication_date": "06-15-2009", "fulltext": "\n SoftBound: Highly Compatible and Complete Spatial Memory Safety for C Santosh Nagarakatte Jianzhou \nZhao Milo M. K. Martin Steve Zdancewic Computer and Information Sciences Department, University of Pennsylvania \n santoshn@cis.upenn.edu jianzhou@cis.upenn.edu milom@cis.upenn.edu stevez@cis.upenn.edu Abstract The \nseriousbugs and security vulnerabilitiesfacilitatedby C/C++ s lack of bounds checking are well known, \nyet C and C++ remain in widespread use. Unfortunately, C s arbitrary pointer arithmetic, con.ation of \npointers and arrays, and programmer-visible memory layout make retro.tting C/C++ with spatial safety \nguarantees ex\u00adtremely challenging. Existing approaches suffer from incomplete\u00adness, have high runtime \noverhead, or require non-trivial changes to the C source code. Thus far, these de.ciencies have prevented \nwidespread adoption of such techniques. This paper proposes SoftBound, a compile-time transformation \nfor enforcing spatial safety of C. Inspired by HardBound, a previ\u00adously proposed hardware-assisted approach, \nSoftBound similarly records base and bound information for every pointer as disjoint metadata. This decoupling \nenables SoftBound to provide spatial safety without requiring changes to C source code. Unlike Hard-Bound, \nSoftBound is a software-only approach and performs meta\u00addata manipulation only when loading or storing \npointer values. A formal proof shows that this is suf.cient to provide spatial safety even in the presence \nof arbitrary casts. SoftBound s full checking mode provides complete spatial violation detection with \n67% run\u00adtimeoverhead onaverage.To further reduceoverheads, SoftBound has a store-only checking mode that \nsuccessfully detects all the se\u00adcurity vulnerabilities in a test suite at the cost of only 22% runtime \noverhead on average. Categories and Subject Descriptors D.3.3.4[Programming Lan\u00adguages]: Processors; \nD.2.5 [Software Engineering]: Testing and Debugging GeneralTerms Languages, Performance, Security, Reliability \nKeywords spatial memory safety,bufferover.ows,C 1. Introduction The seriousbugs and security vulnerabilitiesfacilitatedby \nC/C++ s lack of bounds checking are well known. The lack of spatial mem\u00adory safety leads to bugs that \ncause dif.cult-to-diagnose crashes, silent memory corruption, and incorrect results. Worse yet, it is \nthe underlying root cause of a multitude of security vulnerabili\u00adties [14, 38, 44]. Even though modern \noperating systems and com\u00adpilers employpartial countermeasures(e.g., guarding the return ad- Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page.To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 09, June 15 20, 2009, \nDublin, Ireland. Copyright c &#38;#169; 2009ACM 978-1-60558-392-1/09/06... $5.00 dress on the stack, \naddress space randomization, non-executable stack), vulnerabilities persist.For oneexample,inNovember \n2008 Adobe released a security update that .xed several serious buffer over.ows [2]. Attackers have reportedly \nexploited these buffer\u00adover.ow vulnerabilities by using banner ads on websites to redi\u00adrect users to \na malicious PDF document crafted to take complete control of the victim s machine [1]. For another example, \nas of March 2009, millions of computers worldwide were infected with the Con.ckerworm, which spreads \nprimarily viaabuffer-over.ow vulnerability [39]. Safe languages, such as Java and C#, enforce memory \nsafety and thus completely prevent this entire class of bugs and security vulnerabilities [14]. Such \nlanguages have thankfully become main\u00adstream,howeverC and C++ are still widely used.C provideslow\u00adlevel \ncontrol of memory layout, proximity to the underlying hard\u00adware, requires minimal runtime support, and \nis the gold standard for performance.Today s operating systems, virtual machine mon\u00aditors, language runtimes, \nenterprise database management systems, embedded software, and web browsers are all generally written \nin C/C++. Furthermore, altogether such systems comprise millions of lines of C/C++ code, preventing the \ncomplete transition away from C/C++ anytime soon. As a recognition to the importance of this problem, \nmany pro\u00adposals have pursued techniques for retro.tting C (or close vari\u00adants) to provide complete or \nnear-complete spatial memory safety [4, 5, 10, 11, 17, 28, 29, 32, 35, 37, 41, 47, 48].1 Unfortunately, \nseveral aspects of C, such as its con.ation of arrays and singleton pointers, unchecked array indexing, \npointer arithmetic, pointers to the middle of objects, arbitrary casts, user-visible memory layout, and \nstructures with internal arrays all interact to greatly increase the dif.culty of retro.tting C with \nspatial memory safety guaran\u00adtees. As a result, prior proposals suffer from one or more practical dif.culties \nthat may prevent wide adoption, such as: high runtime overheads, incomplete detection of spatial violations, \nincompatible pointer representations (by changing memory layout), or requiring non-trivial changes to \nexisting C source code. Moreover, the pro\u00adposals with the lowest performance overheads generally employ \nwhole-program compiler analyses(e.g., [4, 17, 35]) which compli\u00adcates separate compilation and use of \ndynamically linked libraries. Section2 provides additional background on these proposals. Hardware-assisted \ntechniques have been proposed for mitigat\u00ading the runtime overheads and other limitations of these software\u00ad \n1Although temporal safety violations are alsoa source ofbugs(i.e., dan\u00adgling pointers) and vulnerabilities(i.e., \nuse-after-free vulnerabilities), Soft-Bound focuses exclusively on the spatial safety issues of C. Other \nprevi\u00adously proposed complementary techniques such as conservative garbage collection [9], reference-counted \nsmart pointers, probabilistic approxima\u00adtions of an in.nite-sized heap [6], temporal capabilities [5, \n47], or region\u00adbased memory management [19, 23, 25] may be employed to detect or pre\u00advent temporal violations. \n only schemes. One such proposal is HardBound [16], which de\u00adscribes extensive hardware support for \nbounded pointers, including automatically propagating pointer bounds information, ef.ciently checking \nevery memory access, and transparently recording pointer bounds metadata in a hardware-managed shadow \nspace. This hard\u00adware/software approach may provide low-overhead enforcement of spatial memory safety \nthat is complete and highly compatible with existingC code,but such hardware support is unlikely to beavail\u00adable \nanytime soon, if ever. This paper describes SoftBound, a software-only approach in\u00adspired by HardBound \ns disjoint metadata scheme for highly com\u00adpatible enforcement of spatial safety forCprograms. SoftBound \nis a compile-time transformation that inserts code for runtime prop\u00adagation and checking of pointer bounds. \nSoftBound enforces spa\u00adtial safety using the pointer-based approach, which associate base and bound metadata \nwith every pointer. Unlike prior pointer-based approaches that change pointer representations and thus \nobject lay\u00adouts [5, 28, 35], SoftBound records the base and bound metadata in a disjoint metadata facility \nthat is accessed via explicit table lookups on loads and stores of pointer values only. SoftBound performs \na simple intra-procedural transformation that instruments each function to propagate and check pointer \nmetadata. Functions with pointer arguments or pointer return values are extended with additional parameters \nfor base and bound metadata. This overall approach provides SoftBound with the following attributes: \n Source compatibility. SoftBound is highly compatible with ex\u00adisting C source code because its disjoint \nmetadata (1) avoids any program-visible memory layout changes, (2) allows arbi\u00adtrary casts by preventing \nthe coercion of metadata that could otherwise occur with in-line metadata. Our experiments with 23 benchmark \napplications and two network daemons (272K lines of code in total) show that SoftBound can be successfully \napplied to unmodi.edC programs.  Completeness. By default the SoftBound transformation guar\u00adantees spatial \nsafety. In essence, SoftBound provides the same spatial safety guarantees as CCured, and Section4includes \nthe sketch of a formal proof that SoftBound s core mechanisms en\u00adforce a well-formed memory property \nsimilar to that provided by CCured [35]. Our experiments show that SoftBound catches errors not caught \nby Valgrind s memcheck tool [42] or GCC s Mud.ap [21].  Separate compilation. SoftBound s simple intra-procedural \nanalysis, disjoint metadata, and function cloning provide transparent support for separate compilation, \nallowing library code to be recompiled with SoftBound and dynamically linked. This extends checking into \nlibrary code and can reduce the need for the library wrappers used by prior proposals.  SoftBound provides \ntwo modes of checking. For low-overhead debugging and security-critical software, SoftBound s full check\u00ading \nmode provides spatial safety at the cost of a 67% runtime over\u00adhead on average over a range of 23 benchmarks. \nIn contrast to heavyweight instrumentation used selectively during the develop\u00adment process [21, 27, \n36, 42], SoftBound s full checking overheads are low enough to use continuously throughout the software \ndevel\u00adopment process. For security-critical applications, such overheads are also likely acceptable. \nFor lower overhead protection against security vulnerabilities and the memory corruption caused by out-of-bounds \nwrites, Soft-Bound provides a store-only checking mode. In this mode, Soft-Bound propagates all metadata, \nbut inserts bounds checks only for memory writes. As observed previously [4, 48], store-only checking \nis suf.cient to stop just about any security vulnerability, because attacks typically require performing \nat least one out-of\u00adbounds write. Out-of-bound writes are particularly subversivebugs in that the memory \ncorruption causedby suchbugs often manifests much later and in a different part of the program code. \nOur ex\u00adperiments show store-only SoftBound reduces the average runtime overhead to just 22% while still \npreventing all the vulnerabilities in a security vulnerability suite. SoftBound s store-only checking \noverhead is low enough for many benchmarks (over half of the benchmarks evaluated have less than 15% \nruntime overhead) to be used in end-user production code. 2. Background The problem of detecting and \npreventing spatial violations in theC programming language is a well researched topic. Manytechniques \nwere initially proposed primarily as debugging aids [5, 29, 37],but have now been improved immensely \n[15, 17, 28, 35, 41, 47] nearly to the point of being ready for deployment in production systems. In \nthis section, we describe approaches most closely related to our scheme, comparing them with respect \nto completeness, perfor\u00admance and compatibility attributes. Because SoftBound is focused on detecting \nspatial violations, this section does not discuss ap\u00adproaches for preventing temporal safety violations \n(i.e., dangling pointers). Additional related work is discussed in Section 7. 2.1 Object-Based Approaches \nObject-based approaches [15, 17, 21, 29, 41] track all allocated regions of memory in a separate data \nstructure. This data struc\u00adture maps any location inside of an allocated region to the bounds information \nassociated with the corresponding object. Pointer ma\u00adnipulation operations are checked to ensure that \ntheyremain within the bounds of the same object. The distinguishing characteristic of this approach is \nthat bounds information is tracked per object and associated with the location of the object in memory, \nnot with each pointer to the object. Every pointer to the object therefore shares the same bounds information. \nThe object-based approach has at least two important advan\u00adtages. First, the memory layout of objects \nis unchanged, which improves source and binary compatibility. Second, all heap mem\u00adory allocations(i.e., \ncalls to malloc())update the object-lookup data structure, which allows every valid pointer to be mapped \nto an object, even if it was allocated by un-instrumented code. This be\u00adhavior allows object-based schemes \nto transparently interact with legacylibraries that have not been instrumented, therefore improv\u00ading \nthe overall compatibility of the system. However, the object-based approach has three disadvantages. \nFirst, out-of-bounds pointers require special care. Object-based schemes use special out-of-bounds proxy \nobjects [17, 29] when out-of-bound pointers occur. If an out-of-bound pointer is modi\u00ad.ed so that it \nis back in bounds, this proxy object is used to recreate a valid pointer to the original object. Second, \nthe object-lookup is a range lookup: a pointer to any\u00adwhere in the object must correctly map to the object \ns bounds in\u00adformation. This range lookup is often implemented as a splay tree, which canbea performance \nbottleneck, yielding runtimeoverheads of 5x or more [21, 29, 41]. Subsequent proposals have consider\u00adably \nmitigated this issue, reducing the overhead of the object-table by checking only strings [41] or using \nwhole-program analysis to perform automatic pool allocation to partition the splay trees and eliminate \nlookup and checking for manyscalar objects [15, 17]. The third signi.cant drawback of the object-based \napproach is that its implementations are generally incomplete theydo not de\u00adtect all spatial violations. \nFor example, arrays inside structures are notalways checked.To seewhy, considera contrivedexample:  \nstruct { char id[8]; int account_balance; } bank_account; char* ptr = &#38;(bank_account.id); strcpy(ptr, \n\"overflow...\"); In the above example code, pointers to bank_account and bank_account.id are indistinguishable \nas theypoint to the same location and thus are associated with the same object-based bounds information. \nHence the pointer &#38;(bank_account.id) inherits the bounds of the whole object. When ptr is passed \nto strcpy() an over.ow of bank_account.id can overwrite the rest of the struct, including the struct \ns account_balance .eld even if strcpy() is instrumented. The above example is admittedly contrived, and \nwe have not encountered any such sub-object over.ows in the benchmark code we have examined. However, \nthis example demonstrates that sub-object over.ows have the potential to result in seriousbugs or security \nvulnerabilities. Although object-based implementations have typically not tar\u00adgeted or addressed the \ndetection of such sub-object over.ows, some object-based proposals are more successful at preventing \ninternal over.ows. For example, SAFECode [17, 18], the most recent and most advanced instance of the \nobject-based approach, uses whole\u00adprogram static type analysis and type-homogeneous pool allocation to \nsigni.cantly improve coverage in such cases; it is capable of de\u00adtecting many,but not all, such sub-object \nviolations.  2.2 Pointer-Based Approaches An alternative approach is the pointer-based approach, which \ntracks base and bound information with each pointer. This is typi\u00adcally implemented using a fat pointer \nrepresentation that replaces some or all pointers with a multi-word pointer/base/bound. Such a fat pointer \nrecords the actual pointer value along with the addresses of the upper and lower bounds of the object \npointed by the pointer. As two distinct pointers can point to the same object and have different base \nand bound associated with them, this approach avoids the sub-object problem with object-based approaches \ndis\u00adcussed above. When a pointer is involved in arithmetic, the actual pointer portion of the fat pointer \nis incremented/decremented. On a dereference, the actual pointer is checked to see whether it is within \nthe base and bound associated with it. Proposals such as SafeC [5], CCured [35], Cyclone [28], MSCC [47], \nand others [16, 36, 37] use this pointer-based approach to provide spatial safety guarantees. The pointer-based \napproach is attractive in that it can be used to enforce complete spatial safety. However, propagating \nand checking bounds for all pointers can result in signi.cant runtime overheads. To reduce these overheads, \nCCured [35] used whole-program type inference to identify pointers that do not require bounds checking. \nCCured classi.es pointers into various kinds: SAFE, SEQ, and WILD. SAFE pointers have negligible performance \noverhead and are not involved in pointer arithmetic, array indexing or typecasts. SEQ pointers arefat \npointers that allow only pointer arithmetic and array indexing and are not involved in arbitrary typecasts. \nWILD pointers allow arbitrary casts, but require additional metadata and also anynon-pointer store through \na WILD pointer is required to update the additional metadata. This approach reduces the runtime overhead \nsigni.cantly, but CCured requires modi.cations to the source code to: (1)avoid introducing inef.cient \nWILD pointers and (2) handle the memory layout incompatibility introducedby CCured s useoffat pointers. \nThe most signi.cant disadvantage of the pointer-based ap\u00adproach is that fat pointers change memory layout \nin programmer\u00advisible ways. This introduces signi.cant source code compatibility issues in that the source \nmust be modi.ed[35]. The modi.ed mem-Table 1. Comparison of representative object-based (Jones&#38;Kel\u00adley) \nand pointer-based approaches (SafeC, CCured, MSCC) in con\u00adtrast to SoftBound with respect to attributes \nsuch as: source code modi.cation, completeness with respect to detecting sub.eld ac\u00adcess violations, \nmemory layout compatibility, support for arbitrary casts, and support for dynamically linked libraries. \nApproach No src code change Detects sub-object violations Memory layout compat. Arb. casts Dyn. link \nlib J&#38;K [29] Yes No Yes Yes Yes SafeC [5] Yes Yes No Yes No CCured Safe/Seq [35] No Yes No No No \nCCured Wild [35] Yes Yes No Yes No MSCC [47] Yes Yes/No Yes No Yes SoftBound Yes Yes Yes Yes Yes ory \nlayout also makes interfacing with library code challenging.To address this issue, attempts have been \nmade to split the metadata from the pointer [35, 47]. These approaches partially mitigate some of the \ncompatibility issues,but such techniques can increase overhead by introducing linked shadow structures \nthat mirror entire existing data structures. Furthermore, they do not handle arbitrary casts (another \ncompatibility issue) and MSCC s [47] optimized encoding loses the ability to detect sub-object over.ows. \n 2.3 Comparison of Various Approaches Object-based and pointer-based approaches have complementary strengths \nand weaknesses. Object-based approaches are highly compatible because they use a separate lookup tree \nfor tracking object metadata, and thus they do not change the memory layout. In fact, they have been \nsuccessfully applied to the entire Linux kernel [15]. However, object-based approaches cannot always \nenforce complete spatial safety because of sub-object over.ows. In contrast, pointer-based approaches \ntypically change the pointer representation and memory layout causing source code compat\u00adibility problems. \nHandling arbitrary casts is another important problem. For example, in CCured, arbitrary casts result \nin WILD pointers (which further complicate library compatibility) and may have signi.cant performance \nrami.cations. When whole-program analysis is applied to reduce the overhead of either scheme [17, 35], \nit can complicate the use of precompiled and dynamically loaded libraries. Table1 summarizes thevarious \nobject-based and pointer-based approaches in contrast with SoftBound. Object-based approaches such as \nJones &#38; Kelley [29] satisfy most of the attributes ex\u00adcept for the detection of all sub-object violations. \nCCured with only Safe/Seq pointers haslowoverhead andis completebut lacks source code compatibility. \nMSCC [47] uses split metadata and run\u00adtime type information,but it has dif.culties handling arbitrary \ncasts and it does not detect sub-object over.ows in the con.guration with the lowest runtime overhead. \nIn the next section, we describe the SoftBound approach, which satis.es all the attributes listed in \nthe Table 1 by combining the disjoint metadata of object-based schemes with the sub-object over.ow detection \nof pointer-based schemes. 3. The SoftBound Approach SoftBound is a compile-time transformation for inserting \nruntime bounds checks to enforce spatial safety of C programs. SoftBound is highly compatible with existing \nC source code because its dis\u00adjoint metadata representation avoids memory layout changes and allows arbitrary \ncasts. SoftBound associates base and bound meta\u00addata withevery pointer,but records that metadataina disjoint \nmeta\u00addata space that is accessed via explicit table lookups. This approach is conceptually a pointer-based \napproach,but SoftBound s disjoint metadata provides the memory layout compatibility of object-based approaches. \nThis section describes SoftBound s key ideas. Sec\u00adtion 4 formalizes SoftBound and sketches a proof of \nSoftBound s spatial memory safety guarantee.A full discussion of SoftBound s speci.c implementation choices \nand its handling of all of C s fea\u00adtures is deferred to Section 5.  3.1 Pointer Checking and Metadata \nPropagation The following description of SoftBound s transformation assumes the C code has been translated \ninto a generic intermediate form that contains only simple operations, uses explicit indexing and memory \naccess operations, and provides the abstraction of an un\u00adbounded number of non-memory intermediate values \nand tempo\u00adraries that will ultimately be mapped to registers. Pointer dereference check For every pointer \nvalue in the pro\u00adgram s intermediate representation, the SoftBound transformation creates a corresponding \nbase and bound intermediate value. When\u00adever a pointer is used to access memory(i.e., dereferenced), \nSoft-Bound inserts code (highlighted in grey) for checking the bounds to detect spatial memory violations: \ncheck(ptr, ptr_base, ptr_bound, sizeof(*ptr)); value = *ptr; // original load Where check() is de.ned \nas: void check(ptr, base, bound, size) { if ((ptr < base) || (ptr+size > bound)) { abort(); } } The \ndereference check explicitly includes the size of the memory access to ensure that the entire access \nis in bounds (and not just the .rst byte).Forexample,ifa pointertoa single characteris cast to be a pointer \nto an integer, dereferencing that pointer is a spatial violation. This dereference check is inserted \nfor all pointer deref\u00aderences, but such a check is not required when accessing scalar local or global \nvariables, or when spilling/restoring register values to/from the stack we assume that the C compiler \ngenerates such code correctly. Creating pointers New pointersinC are createdintwoways:(1) explicit memory \nallocation(i.e. malloc())and (2) taking the ad\u00address of a global or stack-allocated variable using the \n&#38; operator. At every malloc() call site, SoftBound inserts code to set the cor\u00adresponding base and \nbound. The base value is set to the pointer returned by malloc(). The bound value is set to either the \npointer plus the size of the allocation (if the pointer is non-NULL) or to NULL (if the pointer is NULL): \nptr = malloc(size); ptr_base = ptr; ptr_bound = ptr + size; if (ptr == NULL) ptr_bound = NULL; For \npointers to global or stack-allocated objects, the size of the object is known statically, so SoftBound \ninserts code to set the base to the pointer and bound to one byte past the end of the object: int array[100]; \n ptr = &#38;array; ptr_base = &#38;array[0]; ptr_bound = ptr_base + sizeof(array); Pointer arithmetic \nand pointer assignment When an expression contains pointer arithmetic(e.g., ptr+index), array indexing(e.g., \n&#38;(ptr[index])), or pointer assignment(e.g., newptr = ptr;), the resulting pointer inherits the base \nand bound of the original pointer: newptr = ptr + index; // or &#38;ptr[index] newptr_base = ptr_base; \n newptr_bound = ptr_bound; No checking is needed during pointer arithmetic because all point\u00aders are \nbounds checked when dereferenced. As is required by C semantics, creating an out-of-bound pointer is \nallowed. SoftBound will detect the spatial violation whenever such a pointer is derefer\u00adenced. Array \nindexing in C is equivalent to pointer arithmetic, so SoftBound applies this same transformation to array \nindexing. Structure .eld accesses Accesses to the .elds of a structure are covered by the above transformations \nby conversion to separate pointer arithmetic and dereference operations. Optional narrowing of pointer \nbounds The pointer-based ap\u00adproach adopted by SoftBound enables the ability to easily narrow the bounds \nof pointers, which in turn allows SoftBound to pre\u00advent internal object over.ows. Shrinking of bounds \ncan result in false violations for particularly pathological C idioms (discussed below), so SoftBound \nshrinks pointer bounds only when explicitly instructed by the programmer to do so(e.g., via a command-line \n.ag when invoking the compiler). When instructed to check for over.ows within an object, Soft-Bound shrinks \nthe bounds on a pointer when creating a pointer to a .eld of a struct (e.g., when passing a pointer to \nan element of a struct to a function). In such cases, SoftBound narrows the pointer s bounds to include \nonly the individual .eld rather than the entire object. struct { ... int num; ... } *n; ... p = &#38;(n->num); \n p_base = max(&#38;(n->num), n_base); p_bound = min(p_base + sizeof(n->num), n_bound); The above code \ncalculates the maximum base and minimum bound to ensure that such an operation will never expand the \nbounds of a pointer. Pointers to struct .elds that are internal arrays (the size of which are always \nknown statically) are handled similarly: struct { ... int arr[5]; ... } *n; ... p = &#38;(n->arr[2]); \n p_base = max(&#38;(n->arr), n_base); p_bound = min(p_base + sizeof(n->arr), n_bound); Although such \nnarrowing of bounds may results in false posi\u00adtives, we have not encountered anyfalse violations in anyof \nour 23 benchmarks (approximately 272K lines of code). Yet, some legal C programs may rely on certain \nidioms that cause false violations when narrowing bounds. For example, a program that attempts to operate \non three consecutive .elds of the same type(e.g., x, y, and z coordinates of a point) as a three-element \narray of coordinates by taking the address of x will cause a false violation. Another example of an idiom \nthat can cause false violations comes from the Linux kernel s implementation of generic containers such \nas linked lists. Linux uses the ANSI C offsetof() macro to create a container_of() macro, which is used \nwhen creating a pointer to an enclosing container struct based only on a pointer to an in\u00adternal struct \n[31]. Casts in SoftBound do not narrow bounds, so one idiom that will not causefalse violationsis castinga \npointerto a struct to a char* or void*.  Another case in which SoftBound does not narrow bounds is when \nwhen creating a pointer to an element of an array. Although tightening the bounds is such cases may often \nmatch the programmer s intent, C programs occasionally use array element pointers to denote a sub-interval \nof an array. For example, a program might use memset to zero only a portion of an array using memset(&#38;arr[4], \n0, size) or use the C++ sort function to sort a sub-array using sort(&#38;arr[4], &#38;arr[10]).  3.2 \nIn-Memory Pointer Metadata Encoding The above transformation only handled pointers as intermediate values(i.e., \nvalues that can be mapped to registers). Pointers must also be stored to and retrieved from memory. SoftBound \nuses a table data structure to map an address of a pointer in memory to the metadata for that pointer. \nSoftBound inserts a table lookup to retrieve the base and bounds from the disjoint metadata space at \nevery load of a pointer value: int** ptr; int* new_ptr; ... check(ptr, ptr_base, ptr_bound, sizeof(*ptr)); \n newptr = *ptr; // original load newptr_base = table_lookup(ptr)->base; newptr_bound = table_lookup(ptr)->bound; \n Correspondingly, SoftBound inserts a table update for every store of a pointer value: int** ptr; int* \nnew_ptr; ... check(ptr, ptr_base, ptr_bound, sizeof(*ptr)); (*ptr) = new_ptr; // original store table_lookup(ptr)->base \n= newptr_base; table_lookup(ptr)->bound = newptr_bound; Only load and stores of pointers are instrumented; \nloads and stores of non-pointer value are unaffected. Even though loads and stores of pointers are only \na fraction of all memory operations, fast table lookups and updates are key to reducing overall overheads. \nThe implementation section (Section 5) explores two implementations of the lookup table. 3.3 Metadata \nPropagation with Function Calls When pointers are passed as arguments or returned from functions, their \nbase and bound metadata must also travel with them. If all pointer arguments were passed and returned \non the stack(i.e., via memory and not registers), the above table-lookup approach for handling in-memory \nmetadata would suf.ce. However, the function calling conventions of most ISAs specify that function arguments \nare generally passed in registers. To address this issue, SoftBound uses procedure cloning [12] to transform \nevery function declaration and function call site to in\u00adclude additional arguments for base and bound. \nFor each pointer argument, base and bound arguments are added to the end of the list of the function \ns arguments. As part of this transformation, the function name is appended with a SoftBound-speci.c unique \niden\u00adti.er, specifying this function has been transformed by SoftBound. For example, the code: int func(char* \ns) { ... } int value = func(ptr); is transformed to: int sb_func(char* s, void* s_base, void* s_bound) \n{ ... } int value = sb_func(ptr, ptr_base, ptr_bound); Functions that return a pointer are changed to \nreturn a three\u00adelement structure by value that contains the pointer, its base, and its bound. The transformation \nat the call site is performed entirely based on the arguments being passed to the function. Thus, this \napproach works when the de.nition and call site are in different .les, which is necessary to support \ntraditional separate compilation and exter\u00adnal libraries. In fact, even if the function prototype is \nunspeci.ed and incomplete (which is surprisingly common in actual C code), as long as the arguments passed \nin theCcode are correct, the trans\u00adformation will work as expected. This general approach has the additional \nbene.t that the transformation is independent of the tar\u00adget ISA and the generated code obeys the system \ns standard call\u00ading conventions (albeit with additional parameters). Support of safe variable argument \nfunctions is discussed in Section 5.  3.4 Comparison with CCured s WILD Pointers In many respects, SoftBound \ns pointer representation is merely a more compatible and more ef.cient implementation of CCured s WILD \npointers. Like CCured s WILD pointers, SoftBound provides memory safety even in the context of arbitrary \ncasts. CCured s WILD pointers accomplish this by (1) including a base .eld with each pointer, (2) including \na size .eld at the beginning of each allocation, and (3) using tag bits at the end of each allocation \nto indicate which bytes in the allocation are pointers. These tag bits are written whenever storing to \nsuch an object (set to one when storing a valid pointer, set to zero otherwise) and read on every pointer \nload. As formally shown [35], this approach prevents corruption of the base pointer metadata stored inline \nwithin the objects, even if those objects are accessed via arbitrarily cast pointers. The key to this \nguarantee is that such stores will also set the tag to zero and that all pointer loads check this tag. \nWILD pointers have three key disadvantages. First, WILD pointers introduce source code compatibility \nissues because they change memory layout in programmer-visible ways. Second, WILD pointer s base pointer \nmust point to the start of an allocation, thus disallowing sub-object bounds information and failing \nto detect sub-object over.ows. Third, all stores to a WILD object must update the metadata bits, adding \nruntimeoverhead.For these reasons (and the fact that WILD pointers disrupt CCured s whole-program type \ninference), all performance results for CCured are presented for benchmarks in which the need for WILD \npointers was totally eliminated by program source modi.cations, program annotations, or insertion of \nunsafe trusted casts [35]. SoftBound s pointer representation improves upon WILD point\u00aders while maintaining \ntheir spatial safety properties. First, Soft\u00adBound s metadata is recorded in a disjoint metadata space, \navoid\u00ading the memory layout incompatibility of WILD pointers. Second, by using base/bound metadata that \nis totally decoupled from the pointer in memory, SoftBound avoids the object size header and tag bits, \nwhich in turn allows SoftBound to address the second de\u00ad.ciencyof WILD pointers by allowing arbitrary \nsub-object bound\u00ading to detect sub-object over.ows. Third, as SoftBound s metadata is disjoint, normal \nprogram memory operations cannot corrupt the metadata, eliminating both the tag bits and the need for \nevery store operation to update these tag bits. With these improvements over WILD pointers, SoftBound \npointer representation is highly com\u00adpatible, provides reasonable performance overheads, and provides \nspatial safety even in the presence of arbitrary casts. The next sec\u00adtion provides a formal proof that \nshows SoftBound s pointers pro\u00advide the same well-formed memory guarantees (and thus spatial safety guarantees) \nas CCured s WILD pointers.  4. Formal Proof of Spatial Safety This sectionsketchesa safety proof for \nthekeycomponentsof Soft\u00adBound s enforcement mechanisms, namely pointer metadata propa\u00adgation and assertion \nchecking. These claims have been mechanized usingtheCoqproof assistant[13].Alonger descriptionoftheproof \nand accompanying Coq source is publicly available [43]. Due to the size and complexity of the full SoftBound \nimplemen\u00adtation, we concentrate our efforts on a fragment of C that covers covers almost all of SoftBound \ns features, including the address-of operator &#38;, malloc, and named structure types, which permit \nre\u00adcursive data structures. The formalism does not model SoftBound s checking of function pointers or \ncapture its shrinking of bounds for detecting sub-object spatial violations. At a high level, the proof \nhas several steps. We .rst develop a non-standard operational semantics for (simpli.ed, straight-line, \nand single-threaded) C programs that tracks information about which memory addresses have been allocated. \nTo facilitate check\u00ading of spatial memory errors, our formalism axiomatizes properties of the C runtime \nwith primitives for accessing memory: read, write, and malloc. As SoftBound targets spatial errors only, \nthis formalism excludes free and other sources of temporal errors. Crucially, this semantics is partial \nit is unde.ned whenever a bad C program would cause a spatial-safety violation; for programs without \nspatial memory errors, this semantics agrees with C. Next, we augment the operational semantics so that \nit both prop\u00adagates the bounds metadata and performs bounds-check assertions, aborting the program upon \nassertion failure. This step abstractly models the results of SoftBound instrumentation of theCprogram. \nFinally, we de.ne a well-formedness predicate on syntax that captures invariants ensured by a combination \nof the C compiler (e.g., that local variables map to stack addresses) and SoftBound instrumentation. \nStandard preservation and progress results then establish that, starting from a well-formed initial program \nstate, the SoftBound instrumented version will either terminate with a value, exhaust memory, or abort \nit will never get stuck trying to access unallocated memory. This approach is similar to those used in \nboth CCured s [35] and Cyclone s [24] formal developments. The rest of this section explains this proof \nstrategy in more detail. 4.1 Syntax The grammarinFigure1givesthe fragmentofCusedinourproof. Commands \nconsist of straight-line sequence of assignments, where the left-hand-side(lhs)is either a variable, \na pointer dereference, or the .eldofa struct. Theright-hand-side(rhs)of an assignment can be an integer \nconstant, the result of an arithmetic operation, a lhs, the address of a lhs, the result of a cast, the \nsize of a pointer type, or the result of malloc. Atomic types are integers or pointers to pointer types, \nwhich include anonymous structure types, named structures and void in addition to atomic types. Here, \nn ranges over named structures, and id rangesoverC identi.ers.We assume that wehavea partial map from \nnames to anonymous structure types that represents typedefs in the source code.  4.2 Operational Semantics \nThe operational model is intended to represent programs after they have already been compiledtoafairlylowlevel \nintermediate repre\u00adsentation in which all code and data structures have been .attened and all operations \nare expressed in terms of atomic data types (ints and pointers). Our Coq proof de.nes a well-formedness \npredicate on syntax that picks out a subset of programs with these invari\u00adants, but we omit the details \nhere and simply assume that all syn\u00adtax mentioned in the rules below is well formed with respect to these \ninvariants. Note that, because the compiler transformations that yield code in this intermediate form \ndepend on source-program AtomicTypes a ::= int | p* PointerTypes p ::= a | s | n | void StructTypes s \n::= struct{ \u00b7\u00b7\u00b7 ;idi:ai; \u00b7\u00b7\u00b7 } LHS Expressions lhs ::= x | *lhs | lhs.id | lhs->id RHS Expressions rhs \n::= i | rhs+rhs | lhs | &#38;lhs | (a) rhs | sizeof( p) | malloc(rhs) Commands c ::= c ; c | lhs= rhs \nFigure 1. Syntax for the formal development. Name Speci.cation read Ml return some data at the address \nl, if accessible; none otherwise write Ml d update data to d at the address l, if accessible; none otherwise \nmalloc Mi allocate a memory block with the size i if the free memory space is available; fail otherwise \nTable 2. Memory operations. type information (to calculate struct .eld indices, for example) and SoftBound \ns instrumentation itself uses types, our non-standard se\u00admantics depends on source type information. \nThe operational semantics for thisC fragment also relies on an environment E, that has two components: \nA map, S, from vari\u00adable names to their addresses and atomic types (modeling a stack frame), and a partial \nmap, M, from addresses to values (modeling memory). A memory M is de.ned only for addresses that have \nbeen al\u00adlocated to the program by the C runtime. The C runtime provides three primitive operations for \naccessing memory: read, write, and malloc. Rather than committing to a particular implementation of these \nprimitives, our formalism axiomatizes properties that any rea\u00adsonable implementation should satisfy. \nMost of the axioms state simple properties like reading a location after storing to it returns the value \nthat was stored and storing to a location l does not af\u00adfect anyother location. The most notable axioms \ninvolve malloc; theyenforce properties like malloc returns a pointer to a region of memory that was previously \nunallocated and malloc doesn t alter the contents of already allocated locations. Both read and write \ncan fail if they try to access unallocated memory; malloc can fail if there is not enough space.Table2 \nsummarizes these operations. Given these operations, we de.ne a straightforward operational semantics \nfor this fragment ofCthat is unde.ned for programs that access unallocated memory locations. The standard \noperational se\u00admantics of C evaluates a left-hand-side of an assignment to an ad\u00address. The value at \nthat address is overwritten by the value that the corresponding right-hand-side evaluates to.To model \nSoftBound s behavior, we augment this operational semantics to keep track of metadata and potential memory \nerrors: Results r ::= v(b,e) | l | OK | Abort | OutOfMem A result r can be a value v(b,e) (the result \nof a right-hand-side) including the base(b) and bound(e) information along with the underlying data v. \nFor example, if v is the value of a pointer to an array array, b and e are the start and end addresses \nof array; if v is the value of an integer, its base and bound information are zero. A result r can also \nbe an address, l (the result of a left-hand-side), OK which is the the result of a successful command \nc, Abort when bounds checkfails, or OutOfMem when memory allocationfails. As mentioned above, to fully \ncapture the instrumentation per\u00adformed by SoftBound, it is also necessary for the operational se\u00admantics \nto propagate some type information. For example, before doing a dereference, SoftBound must do the bounds \ncheck accord\u00ading to pointers base and bound information and the size of their types. Similarly, when \ncasting integers to pointers SoftBound sets pointers base and bound information to zero.  These considerations \nlead to three large-step evaluation rules. Left-hand-sides evaluate to a result r (which must be an address \nl if successful) and its atomic type a. Such an evaluation has no ef\u00adfect on the environment, so we write \nthe rule as: (E, lhs) .lr:a. Evaluating a right-hand-side expression also yields a typed result, but \nit may also modify the environment E via memory alloca\u00adtion or assignment, causing it to become E ' : \n(E, rhs) .r (r:a, E ' ) (where r must be v(b,e) if successful). Commands simply evaluate to a result, \nwhich must be OK if successful, and .nal environment: (E, c) .c (r, E ' ), where assignment statements \ncan update the en\u00advironment. Space precludes showing the full set of operational rules (most of which \nare completely standard or obvious). Instead, we highlight a few cases that illustrate the salient features.For \ninstance, the fol\u00adlowing examples show how to evaluate a pointer dereference when the bounds check succeeds \n(left) andfails (right): (E, lhs) .ll:a* (E, lhs) .ll:a* read (E.M) l = some l ' read (E.M) l = some \nl ' (b,e)(b,e) l '.[b, e-sizeof(a)] l ' . [b, e-sizeof(a)] (E, *lhs) .ll ' :a (E, *lhs) .l Abort :a Here, \nlhs is .rst evaluated to l, which is the address of a pointer with type a*. If the address l is allocated, \nthe function read (E.M) l returns l ' the value of that pointer l ' and its metadata b and e. (b,e) Because \npointers can be out-of-bounds due to pointer arithmetic, before doing the dereference,these rules check \nwhether l ' is within the bounds, and yield the error Abort when the bounds checkfails. Note that it \nis a memory violation if read (E.M) l= none, in which case neither rule above applies. However, according \nto the type safety properties described below (Section 4.3), read will not fail at runtime. As another \nexample, the operational semantics performs bounds checking for access through a struct .eld using the \nfollowing rule: (E, lhs) .ll:s* read (E.M) l = some l ' (b,e) l '.[b, e-sizeof(s)] getField s id = some \n(offset, a) (E, lhs->id) .ll ' +offset :a Here, getField returns a .eld offset, which is less than or \nequal to sizeof(s), along with the atomic type a of the .eld id in struct type s. Other rules keep track \nof pointers values and their metadata when evaluating pointer arithmetic (left) and type casts (right): \n(E, ptr) .r (l(b,e) :p*, E ' ) ' (E , i) .r (n(b ' ,e ' ) :int, E '' )(E, rhs) .r (v(b,e) :a, E ' ) l \n' =l+n*sizeof( p) (b ' , e ' )=(a==int)?(0, 0) : (b, e) ' (E, ptr+i) .r (l ' :p*, E ' )(E, (a ' )rhs) \n.r (v(b '' ) :a , E ' ) (b,e) ,e As shown above, the metadata on the results of a pointer arithmetic \noperation is just the metadata associated with the original pointer. Casts also propagate the metadata \nunchanged, except in the case of casting an integer to a pointer, in which case the base and bound are \nboth set to zero. Subsequent bounds checks on the resulting point\u00aders will fail, ensuring that pointers \ncreated from integers cannot be dereferenced. This rule follows the SoftBound implementation, which associates \nmetadata only with pointers stored in memory; as a consequence, when casting an integer to a pointer, \nthe only sound choice is to zero-out the metadata. This approach is conservative, but in practiceCprograms \nrarely cast from pointers to integers and then back again, which is the case that might bene.t from more \naccurate metadata propagation. At runtime pointers can be temporarily out-of-bounds. The op\u00aderational \nsemantics will not yield an error in such cases until the program attempts a dereference through the \nillegal pointer. Once a bounds checkfails ora memory allocationfailure occurs, the rules propagate memory \nerrors to the top level, analogously to raising an exception: (E, c1) .c (OK, E ' ) ' ) ' '' ) (E, c1) \n.c (r, E (E , c2) .c (r, E r is Abort or OutOfMem r is Abort or OutOfMem (E, c1 ; c2) .c (r, E ' )(E, \nc1 ; c2) .c (r, E ' )  4.3 Safety The safety result relies on showing that certain well-formedness invariants \nare maintained by the SoftBound instrumented program. A well-formed environment .EE consists of a well-formed \nstack frame S, which ensures that all variables are allocated in a valid memory block and have well-formed \ntype information, and a well\u00adformed memory M.Amemory Mis well formed when the metadata associated with \neach allocated location is well formed: .l, d, b, e.(read Ml = some d(b,e)) .M .Dd(b,e)) .MM M .Dd(b,e) \n. (b = 0) .[(b= 0) . (.l .[b, e]. val Ml). (minAddr =b=e < maxAddr)] Here, val Ml is a predicate that \nholds when location l is allocated in memory M and minAddr and maxAddr bound the range of legal memory \naddresses where program data can reside. The judgment .MM guarantees that if any address is accessible, \nits value is in\u00adbounds according to its metadata.Acommand is well-formed with respect to a stack frame \nS, written S .cc, when c typechecks ac\u00adcording to standard C conventions assuming that each of the vari\u00adables \nmentioned in c has the atomic type assigned by S. With the above well-formedness conditions in place, \nLemma 4.1 shows that if a left-hand-side evaluates to an ad\u00address l without yielding anyspatial memory \nviolation, l must point to an allocated memory block that lies within the legal memory addresses range, \nand if a right-hand-side successfully evaluates to a value, its metadata represents a range of allocated \nmemory. LEMMA 4.1 (Successful Evaluation Ensures Safety). 1. If .E E, (E, lhs) .ll:a, then val E.Ml.minAddr \n= l.l+ sizeof(a) < maxAddr. 2. If .E E, (E, rhs) .r (vb,e :a, E ' ), thenE ' .M .Dv(b,e).  With Lemma \n4.1, the type safety theorems show that SoftBound can detect memory violations at runtime. THEOREM 4.1 \n(Preservation). If .E E, E.S .c c and (E, c) .c ' (r, E ' ), then .EE . ' THEOREM 4.2 (Progress). If \n.EE and E.S .c c, then . E . ' (E, c) .c (ok, E ' ) or . E ' . (E, c) .c (OutofMem, E ' ) or . E . (E, \nc) .c (Abort, E ' ). The proofs of these theorems are straightforward inductions on the structure of \nthe typing derivations, and the type safety proper\u00adties of lhs expressions and rhs expressions which \nalso follow by inductions on the structure of the typing derivations. These theo\u00adrems also imply the \nfollowing corollary: ' COROLLARY 4.1 If .E E, E.S .c c and . E . (E, c) .c (ok, E ' ), then the original \nC program will not cause any spatial memory violation.  5. Implementation The previous sections have \ndescribed SoftBound s basic approach and formal justi.cation. This section describes the speci.c imple\u00admentation \nof SoftBound s metadata facility and speci.cally how SoftBound handlesvarious aspectsofC (globalvariables, \nseparate compilation, memcpy(), function pointers, arbitrary casts, and vari\u00adable argument functions). \n5.1 Metadata Facility Implementation SoftBound s metadata facility completely decouples the metadata \nfrom the pointers in memory. At its simplest, SoftBound must map an address to the base and bound metadata \nfor the pointer at that address(i.e., the lookup is based on the location being loaded or stored, not \nthe value of the pointer that is loaded or stored). This mapping can be implemented in several ways, \nincluding lookup trees or tables; SoftBound uses table lookup. As the metadata accesses can be a signi.cant \nsource of run\u00adtime and memory overhead, we explore two implementations of the metadata facility: a hash \ntable and a tag-less shadowspace. Each organization comes with its own set of trade-offs with respect \nto memory and performance overheads. Hash table The conceptually most straightforward implementa\u00adtion \nof the metadata facility is a simple hash table. Each entry in the table has three entries: tag, base, \nand bound. Assuming 64-bit pointers, each entry is 24 bytes. To reduce runtime overhead, this implementation \nuses a simple hash function: the double-word ad\u00address modulo the number of entries in the table. By keeping \nthe number of entries in the table a power of two, this calculation is a simple shift-and-mask operation. \nCollisions are handled using open hashing. Collisions are minimized by sizing the table large enough \nto keep average utilization low. In the common case of no collisions, the lookup is approximately nine \nx86 instructions: shift, mask, multiply, add, three loads, tag compare, and branch. Shadow space The \nshadow space implementation reduces the overhead of the hash table by allocating a large enough table \nin the virtual address space such that collisions are guaranteed not to occur. With this guarantee, the \ntag .eld and checking is elimi\u00adnated, reducing both worst-case memory overhead and instruction count. \nA shadow space lookup is approximately .ve x86 instruc\u00adtions: shift, mask, add, and two loads. To ensure \nno collisions occur, the stack and heap are each lim\u00adited to the top and bottom eighth of the virtual \naddress space, respectively. The system reserves a large region of memory in the middle of the virtual \naddress space for the shadow space. In essence, this approach reduces the size of the virtual address \nspace by two bits. The SoftBound prototype uses mmap() to create a zero\u00adinitialized region in virtual \nmemory, and the operating system then allocatesphysical pages for this region on demand(i.e., when each \npage is .rst accessed).  5.2 Implementation Considerations Handling arbitraryCprograms requires addressing \nseveral issues. Global variables For global arrays, the base and bound are compile-time constants. Thus, \nSoftBound sets these bounds without requiring writing the metadata to memory. However, for pointer values \nthat are in the global space and are initialized to non-zero values, SoftBound adds code to explicitly \ninitialize the in-memory base and bounds for these variables. This can be implemented using the same \nhooks C++ uses to run code for constructing global objects. Separate compilation and library code Unlike \nproposals that ex\u00adploit whole-program analysis [17, 35], SoftBound easily supports separate compilation. \nAs described earlier, SoftBound uses proce\u00addure cloning [12] to transform functions to take additional \nparam\u00adeters and changes the function name to signify that it has been transformed. Separate compilation \nworks naturally the static or dynamic linker matches up caller and callee as usual. This sup\u00adport for \nseparate compilation has two important rami.cations. First, SoftBound supports build environments in \nwhich a large program is built by compiling many distinct modules via separate compi\u00adlation. Second, \nSoftBound can be applied directly to library code, allowing a library writer to create and distribute \na single library archive with both transformed (spatially safe) and untransformed (unsafe)versionsof \neach function.For libraries thathave not (yet) been transformed, SoftBound employs library function wrappers \nsimilar to those used in MSCC [47] or CCured [35] (but without the marshaling issues caused by incompatible \nmemory layout). Memcpy() Among various C standard library calls, memcpy requires special attention. First, \nto reduce runtime overhead, the source and targets of the memcpy are checked for bounds safety once at \nthe start of the copy. Second, memcpy must also copy the metadata corresponding to any pointer in the \nregion being copied. SoftBound could take the safe (but slow) approach of always inserting code to copy \nthe metadata, yet most calls to memcpy involve buffers of non-pointer values. To address this inef.ciency, \nSoftBound infers whether the source of the memcpy contains pointers by looking at the type of the argument \nat the call site. Although not foolproof, we have found this heuristic suf.cient to identify the few \nuses of memcpy involving pointers in our benchmarks. Function pointers To protect function pointers, \nthe SoftBound prototype sets the base and bound for function pointers to be equal to the pointer. Such \nan encoding is not used by data objects (it would correspond to a zero-sized object), so SoftBound can \ncheck for this metadata when the program calls througha function pointer. Although this encoding prevents \ndata pointers or non-pointer data from being interpreted as a function pointer, casts between func\u00adtion \npointers of incompatible types presents a challenge because calling a function with arbitrary values \nmay allow the manufac\u00adture of improper base and bounds. Though not yet implemented in our prototype, \nto ensure complete protection, a full implementation would encode the pointer/non-pointer signature of \nthe function s ar\u00adguments, allowing a dynamic check to properly handle such cases. Creating pointers \nfrom integers By default SoftBound sets the base and bound of a pointer created from a non-pointer value \nto NULL. This is a safe default (any dereference of such a pointer will trigger a bounds violation), \nbut may cause false violations in particularly perverse C programs. Although we have not encoun\u00adtered \nsuch code in the applications we have examined, SoftBound supports such casts by providing a setbound() \nfunction that al\u00adlows the programmer to bypass safety guarantees by explicitly set\u00adting the bound for \na pointer (including completely unbounding a pointer to provide unchecked access to arbitrary memory \nloca\u00adtions if the programmer so desires). The programmer may also use the setbound() function to explicitly \nshrink bounds, for example, when employing a custom memory allocator. Arbitrary casts and unions C supports \narbitrary type conversion by explicit casts and implicit conversions via unions. SoftBound al\u00adlows all \nsuch casts, because separating the metadata and program data ensures that pointer bounds are not unsafely \nmanipulated by casts. In contrast, inline fat pointer schemes [5, 35, 47] have dif.\u00adculty supporting \narbitrary casts. In SoftBound, casts among pointer types simply inherit the same bounds. Like CCured \ns WILD point\u00aders, SoftBound enforces spatial memory safety as de.ned by well\u00adformed memory invariants \n(Section 4.3). That is, SoftBound en\u00adsures that a pointer can only dereference memory locations within \nits bounds, and that all those memory locations are valid; it does not provide an assurance about the \ntypes of those memory locations.  Variable argument functions Variable argument functions are another \nsource of unsafe behavior of C programs. An approach to handling variable arguments functions is to introduce \na safer calling convention for variable argument functions by including two extra parameters: the number \nof parameters passed (in bytes) and the number of pointers passed (and thus the number of extra base/bound \narguments passed to the function). The va_start and va_arg macros could then check that neither too many \narguments nor too many pointer arguments are decoded. Our SoftBound pro\u00adtotype does not yet implement \nthis safer calling convention for vari\u00adable argument functions. 6. Experiments In this section, we describe \nand experimentally evaluate our proto\u00adtype implementation of SoftBound. The goal of this evaluation is \nto (1) show SoftBound is effective in preventing spatial violations, (2) measure its runtime and memory \noverheads, and (3) to show SoftBoundis compatible withexistingC code. 6.1 The SoftBound Prototype The \nSoftBound prototype uses LLVM [33] version 2.4 as its foun\u00addation. SoftBound operates on LLVM s fully \ntyped single static as\u00adsignment (SSA) intermediate form. LLVM invokes the SoftBound pass after it has \nperformed its full set of optimizations. Applying SoftBound post-optimization ensures that SoftBound \ns instrumen\u00adtation does not prevent code optimization. Furthermore, as register promotion and other optimizations \nhave already reduced the num\u00adber of memory operations, this strategy reduces the amount of ad\u00additional \ninstrumentation introduced by SoftBound. The SoftBound pass inserts code to (1) create a base and bound \nvalue for each pointer non-memory value in the program, (2) per\u00adform base/bound metadata manipulation \nprior to every memory op\u00aderation that reads or writes a pointer, (3) perform a bounds check before memory \noperations and (4) rewrite all function calls to pass the base and bounds as was described in Section \n3. To eliminate some obviously redundant checks of the same pointer, our proto\u00adtype performs a simple \nintra-procedural dominator-based redun\u00addant check elimination. These transformations are all strictly \nlo\u00adcal (intra-procedural) transformations, without using any whole\u00adprogram type inference or alias analysis. \nCalls to externalfunctions (i.e., anylibrary function that has not been SoftBound transformed) are mapped \nto wrapper functions. SoftBound uses standard C functions to implement the code to access the base/bound \nmetadata and to perform the bounds checks. The SoftBound pass invokes these routines by inserting appropriate \nfunction calls that are later forcibly inlined by subsequent LLVM passes. After SoftBound has transformed \nthe intermediate code, it re\u00adruns the full suite of LLVM optimizations on the instrumented code. This \nsimpli.es the SoftBound pass, because subsequent op\u00adtimization passes will remove dead code and factor \nout common sub-expressions.To reduce compilationtimein productionenviron\u00adments, SoftBound would likely \nbecome an internal pass performed after early optimizations such as register promotion and function inlining,but \nbefore the most time-consuming optimization passes. The SoftBound pass operates on LLVM s ISA-independent \nin\u00adtermediate form, so the SoftBound pass is independent of any spe\u00adci.c ISA. We selected 64-bit x86 \nas the ISA for evaluation due to its ubiquity. The SoftBound pass is approximately 5000 lines of C++ \ncode, and we plan to make the SoftBound source code pub\u00adlicly available [43]. Attack and Target Detection \nBuffer over.ow on stack all the way to the target Return address Old base pointer Function ptr local \nvariable Function ptr parameter Longjmp buffer local variable Longjmp buffer function parameter Store-only \nFull yes yes yes yes yes yes yes yes yes yes yes yes Buffer over.ow on heap/BSS/data all the way to the \ntarget Function pointer Longjmp buffer yes yes yes yes Buffer over.ow of a pointer on stack and then \npointing to target Return address Base pointer Function pointer variable Function pointer parameter Longjmp \nbuffer variable Longjmp buffer function parameter yes yes yes yes yes yes yes yes yes yes yes yes Buffer \nover.ow of pointer on heap/BSS and then pointing to target Return address Old base pointer Function pointer \nLongjmp buffer yes yes yes yes yes yes yes yes Table 3. Various synthetic attacks proposedbyWilanderet \nal. [45] and SoftBound s ability to detect them with full checking and store\u00adonly checking.  6.2 Effectiveness \nin Preventing Vulnerabilities and Bugs To evaluate the effectiveness of SoftBound in detecting violations \nof spatial safety, we applied SoftBound to a suite of security viola\u00adtions [45] and to versions of programs \nwith well-documented secu\u00adrity violations [34]. SoftBound detects all the spatial violations and prevents \nall the security vulnerabilities in these tests without any false positives. We use a testbed of buffer \nover.ow attacks [45] that includes over.ows on the stack, heap, and global segments to overwrite var\u00adious \nreturn addresses, data pointers, function pointers, and longjmp buffers. Table 3 lists the attacks based \non the technique adopted, location of the over.ow, and the attack target that is used to change the control \n.ow. SoftBound detects and prevents all these attacks in both full and store-only checking mode. Publicly \navailable tools such as StackGuard, ProPolice, Libsafe and Libverify miss more than 50% of these test \ncases [45]. We also evaluated SoftBound s ability to detect spatial bugs using actual spatial errors \nfrom real programs obtained from the BugBench suite [34]: go, compress, gzip, and polymorph. These bugs \nare a mixture of one or more read or write over.ows on the heap, stack, and globals. Table 4 lists the \nbenchmarks and the de\u00adtection ability of SoftBound and various memory checking tools. SoftBound with \nfull checking was able to detect and prevent all of the errors. SoftBound with checking only for stores \nwas able to detect allof the storeover.ows,but not the loadover.ows. As a point of comparison, Table \n4 also reports the ef.cacy of memcheck [42] and ptrcheck [36] from version 3.4.1 of Valgrind, Mud.ap \n[21] from GCC 4.2.0, and the Jones andKelly [29] mod\u00adi.cation to version 4.0.0 of GCC. Like SoftBound, \nthe Jones and Kellyversionof GCC detected all violations.In contrast, bothVal\u00adgrind and Mud.ap detect \nsome of the violations, but they also fail Table 4. Programs with over.ows and the detection ef.cacy \nof SoftBound (store-only and full checking), Valgrind s mem\u00adcheck [42], Valgrind s ptrcheck [36], GCC \ns Mud.ap [21], and Jones andKelly [29].  Violation Detected? SoftBound Valgrind GCC s J&#38;K Benchmark \nStore Full memcheck ptrcheck Mud.ap go no yes no no no yes compress yes yes yes yes yes yes polymorph \nyes yes no yes yes yes gzip yes yes yes yes yes yes to detect violations that SoftBound detects.Forexample,Valgrind \ns memcheck tool does not detect over.ows on the stack, leading to itsfailure to detect some of thebugs. \n 6.3 Runtime Overhead Evaluation Benchmarks We used 23 benchmarks selected from the SPECint, SPECfp, \nand Olden benchmark suites to evaluate SoftBound s per\u00adformance. The Olden benchmarks [40] were used \nbecause they have been used in the most signi.cant prior work in this area [17, 35, 47]. Our SoftBound \nprototype is not yet robust enough to com\u00adpile all of the C programs in the SPEC benchmark suites, but \nwe present data for the benchmarks we examined for which SoftBound works correctly. All runs are performed \nona 2.66 Ghz Intel Core2 processor. Hardware performance counters were used to measure dynamic instruction \ncount and cache effects. Benchmark characterization One of the main sources of over\u00adhead in SoftBound \nis the runtime overhead of metadata accesses, which is highly dependent on the frequency of such accesses. \nOur experiments show that the frequency of metadata accesses varies signi.cantly from benchmark to benchmark. \nFigure 2 shows the benchmarks sorted by the percentage of memory operations that load or store a pointer \nvalue. The SPEC benchmarks are dark bars; Olden benchmarks are white bars. Several of the benchmarks \nhave metadata access ratios of less than 10%, including eleven of the sixteen selected SPEC benchmarks. \nIn the other extreme, over half of the memory operations in several of the Olden benchmarks are loads \nand stores of pointers.To more easily show the correlation of metadata accesses and runtime performance, \nthe remaining graphs will present the benchmarks in this sorted order. Runtime overheads of full checking \nFigure 3 presents the per\u00adcentage of runtime overhead of SoftBound over an uninstrumented baseline (smaller \nbars are better as they represent lower runtime overheads). This graph contains a pair of bars for each \nbenchmark. The total height of each bar corresponds to the overhead of full checking using the hash table \n(left bar of each pair) and shadow space implementations (right bar of each pair) of the metadata fa\u00adcility. \nThe average runtime overhead is 93% (for the hash table implementation) and 67% (for the shadow space \nimplementation). For all the benchmarks these runtimes overheads are likely more than acceptable for \ndebugging, internal and external testing, and for mission-critical applications. The benchmarks on the \nleft of the graph (those with a lower fre\u00adquency of metadata accesses) generally have lower runtime over\u00adheads. \nOn those benchmarks the overhead is largely due to the actual checking of the bounds, so the speci.c \nmetadata encoding scheme has little impact on the overhead. The SoftBound proto\u00adtype s simple dominator-based \nredundant check elimination does reduce the overheads of bounds checking it reduces the overall average \nruntime overhead from 80% to 67% but more advanced bounds check elimination techniques(e.g., [8, 46]) \nwould further reduce the overheads. Figure 2. The percentageof memory operations that load or storea \npointer from/to memory, thus requiring a metadata access. Bench\u00admarks from SPEC are represented by shaded \nbars; Olden bench\u00admarks are represented by white bars. In contrast to the benchmarks on the left whose \noverhead was primarily dominated by bounds checks, the benchmarks on the right of the graph perform frequent \nmetadata accesses. For these benchmarks, metadata accesses are a large source of overhead, and they are \nsigni.cantly impacted by the metadata encoding. The shadow space encoding outperforms the hash table \nencoding, sometimes substantially.Forafew benchmarks(equake, li, and em3d), the shadow space reduces \nthe runtime overhead by more than half. Runtime overhead of store-only checking Our experiments with \nthe security vulnerabilities reinforce the intuition that checking only stores can prevent security vulnerabilities. \nMoreover, in our experience, store over.ow bugs are more insidious because they are harder to diagnose \nand the manifestation of the bug is often widely separated from the root cause location at which the \nmem\u00adory corruption occurred. The height of just the bottom segment (stripe pattern) of each bar in Figure \n3 represents the overheads for checking the bounds only for store operations. Checking only stores reduces \nthe number of check operations. However, the num\u00adber of metadata writes is unchanged, because all the \nsame pointer metadata must be propagated through memory to check subsequent store dereferences. When \nusing the shadow space implementation, LLVM s dead code elimination also removes manyof the metadata \nreads (those that feed only load dereference checks). However, as the hash table implementation uses \na loop, LLVM is unable to re\u00admove the metadata reads. As a result, in the current SoftBound pro\u00adtotype, \nstore-only checking bene.ts the hash table implementation less than the shadow space implementation, \nfor average runtime overheads of 54% and 22%, respectively. Furthermore, the runtime overhead of store-only \nchecking using the shadow space is less than 15% for more than half of the benchmarks, which is likely \nlow enough for production code. Dynamic instruction count overhead Figure4 is similar in form to the \nprevious .gure, except it shows the dynamic instruction count overheads (rather than execution time overhead) \nfor the vari\u00adous con.gurations. This graph con.rms that accessing the hash ta\u00adble shadow space executes \nmore instructions than the shadow space implementation. In most cases, this larger number of instructions \nis the primary source of additional overhead of the hash table imple\u00admentation. The dynamic instruction \ncount overheads are highly correlated with the runtime overheads, but the dynamic instruction count is \ngenerally much larger than the corresponding runtimeoverhead.On average SoftBound s full checking increases \nthe instruction count by 173% (hash table) and 133% (shadow space), which is almost  equake 263 348 \n Hash Table - Full Shadow Space - Full Hash Table - Store-only Shadow Space - Store-only runtime overhead \n250% 200% 150% 100% 50% 0% Figure 3. Normalized execution time overhead of SoftBound with full checking \nand store-only checking with two metadata organizations. 475 473463 350% Hash Table - Full Shadow Space \n- Full 300% Hash Table - Store-only Shadow Space - Store-only instruction overhead 250% 200% 150% 100% \n50% 0% Figure 4. Dynamic instruction overhead of SoftBound. double the runtime overheads. This data \nimplies that the instruction per cycle (IPC) is higher when executing code instrumented by SoftBound. \nIn essence, SoftBound s metadata manipulation and bounds checking add to the instruction count, but they \nalso increase the available instruction-level parallelism (ILP). The data.ow subgraph of base and bound \nmetadata manipulations is disjoint from the data.ow graph of the original program computation. These \nmanipulations are also not on the control-.ow critical path of the program s execution, assuming the \nprocessor correctly predicts both (1) the never-taken branch that is part of the bounds check and (2) \nthe rarely-taken branch as part of the hash table tag check. The Intel Core 2 processor we used for these \nexperiments is a dynamically scheduled processor with a large instruction window and sophisticated branch \npredictor that can execute up to four micro-operations per cycle. As few programs have enough ILP to \nsustain four-wide execution, some of the instructions added by SoftBound are executed for free by the \nunused execution capacity. For example, hardware performance counters report that the benchmark lbm has \na high data cache miss rate of one miss every 20 instructions. The resulting low IPC (just 0.22) provides \nplenty of spare execution capacity to hide SoftBound overheads, which explains lbm s runtime overhead \nof only 3% while its instruction execution overhead is 82%. This .nding has several rami.cations. First, \ntoday s sophisti\u00adcated processors are partly responsible for the low overheads ex\u00adhibited by SoftBound. \nSecond, the runtime overhead of spatial safety enforcement will be higher when running on low-cost power\u00adef.cient \nprocessors commonly used in mobile devices and embed\u00added systems. Third, if SoftBound or any of the other \nproposals for enforcing spatial safety become widely adopted, it could sig\u00adni.cantly impact the tradeoffs \nin the design of microprocessors. Conversely, future microprocessor designs could signi.cantly pos\u00aditively \nor negatively impact the runtime overheads of enforcing spa\u00adtial safety forCprograms. Memory overheads \nOne cost of SoftBound is that its disjoint metadata increase the program s memory footprint. Figure5shows \nthe normalized memory overheads based on the total number of 4KB pages touched during the entire execution \nfor SoftBound with both the hash table and the shadow space encoding. For programs with manylinked data \nstructures (and thus manyin-memory point\u00aders), the worst-case memory footprint overhead can be as high \nas 300% for the hash table (one 24-byte entry for each 64 bits of mem\u00adory) or 200% for the shadow space \n(one 16-byte entry for each 64 bits of memory). However, the memory overhead for many bench\u00admarks is \nmuch lower. The average memory overheads are 87% and 64%, respectively.Thehash tablein theseexperimentsis \nsizedtobe large enough maintain metadata for every allocated memory loca\u00adtion with few collisions in \nthe table, effectively trading space to re\u00adduce instruction countoverheads.A smaller hash tablewouldhave \nthe reverse effect. Cache effects Another impact of SoftBound s metadata is addi\u00adtional cache misses \nand cache capacity pressure. Figure5 plots the  data cache misses (MKPI)memory overhead 300% 250% 200% \n150% 100% 50% 0% Hash Table - Full Shadow Space - Full Figure 5. Memory footprint overhead for various \nbenchmarks 80 60 40 20 0 Hash Table - Full Shadow Space - Full Hash Table - Store-only Shadow Space \n- Store-only Figure 6. Data cache misses per 1000 base instructions for various benchmarks. 153 129 \nmiss rate of the processor s 32KB .rst-level data cache. The miss rates are given as misses for every \nthousand instructions executed by the baseline non-SoftBound execution, which prevents differ\u00adences in \nthe number of dynamic instructions executed by the four SoftBound con.gurations from obfuscating the \ndata. The horizon\u00adtal line across each pair of bars represents the miss rate of the base\u00adline execution. \nThe benchmarks with few metadata accesses (those on the left of the graph) show no difference in the \nbaseline misses and the misses for the SoftBound con.gurations(i.e., the horizontal lineisatthetopofthestackofbars).Forthe \nbenchmarkswithmore frequent metadata accesses (those on the right side of the graph) show an increase \nin the number of cache misses. In some cases, the miss rate more than doubles(e.g., bh, bisort, mst, \nli). Unsur\u00adprisingly, the benchmarks with high baseline miss rates and with signi.cantly more misses \nalso have high runtime overheads. The hash table implementation shows little difference in miss rates \nbe\u00adtween full and store-only checking, because few metadata loads are eliminated (as was discussed above). \n 6.4 Source Code Compatibility Case Studies To evaluate our claim that SoftBound is highly compatible \nwith existing source code and interfaces well with existing libraries, we applied SoftBound to two network \nserver applications: a fully-functional FTP server (tinyftp-0.2) and high-performance web server with \nCGI support from NullLogic (nhttpd-0.5.1). The NullLogic HTTP server is multithreaded and capable of \nhandling thousands of simultaneous connections. SoftBound successfully transformed these network applications \nwithout requiring any source code modi.cations and nofalse positives during program execution. Apart \nfrom these network applications, SoftBound also successfully transformed the 23 benchmarks used in the \nperformance evaluation. In total, these benchmarks and network servers are approximately 272K total lines \nof code, all of which were successful transformed, further supporting SoftBound s source code compatibility \nclaim.  6.5 Performance Comparison to Related Approaches Table 5 reports the overhead of two publicly \navailable compiler\u00adbased object-based implementations. The overheads are generally much higher than SoftBound \ns overhead: 12.1x, 24.1x and 7.7x for Jones and Kelly, Mud.ap with full checking and MudFlap with store \nonly checking respectively. Table 5 also includes the over\u00adheads of two memory checking toolsValgrind, \nwhich are based on dynamic binary instrumentation. CCured [35] and MSSC [47] are two pointer-based schemes \nclosely related to SoftBound. CCured has low runtime overheads, ranging from 3% to 87% [35].CCured s \nwhole-program type infer\u00adence statically removes manymetadata manipulations, resulting in overheads that \nare lower on average than SoftBound. However, on benchmarks whose overhead is dominated by dereference \nbounds check overhead(e.g., the SPEC benchmark compress), SoftBound and CCured have similar overheads. \nFurthermore, applying CCured to a program requires non-trivial changes to the source code. Al\u00adthough \nsome of the changes are simple, restructuring a program to avoid all casts that cause WILD pointers may \nrequire exten\u00adsive code changes such as runtime type information annotations and tagged unions or ultimately \ngiving up on complete safety by marking casts as trusted [35]. Lu et al. used CCured to investigate its \nbug detection ability and have described these code modi.ca\u00adtions as moderate to hard and ultimatelyfailed \nto apply CCured to one benchmark [34]. MSCC [47] has higher overheads than CCured, partly because it \neschews whole-program analysis (as does SoftBound). When con\u00ad.gured to perform only spatial safety checking, \nMSCC s overheads Table 5. Runtime overhead of Jones &#38; Kelly [29], Mud.ap [21] with store only and \ncomplete checking,Valgrind s memcheck [42] and, Valgrind s ptrcheck [36]. Entries with  indicate an \ninter\u00adnal compiler error, spurious runtime exceptions, or trials discarded because of extremely long \nruntimes.  Benchmark J&#38;K Mud.ap Valgrind Store Full memcheck ptrcheck go 28.3x 300.4x 316.0x 19.8x \n98.5x lbm 4.8x 1.4x 1.9x 4.6x 12.0x gzip 9.9x 2.1x 2.8x 19.1x 86.1x hmmer  2.5x 4.8x 13.8x 86.4x compress \n14.1x 1.5x 3.5x 12.8x 54.1x bzip2 17.3x 8.9x 10.3x 13.8x 75.0x ijpeg 40.1x 69.4x 71.1x 16.2x 95.3x crafty \n13.9x 166.9x 170.2x 41.3x 209.2x sjeng 25.7x 19.8x 19.8x 27.3x 27.3x mesa 31.8x 193.9x 197.0x 35.5x 154.0x \nsphinx 24.8x 4.7x 43.8x 24.4x 61.5x bh 32.4x  14.4x 62.7x vpr 25.5x 2.5x 9.6x 21.9x 130.1x art 242.4x \n2.9x 91.1x 16.9x 49.2x tsp 9.0x 2.7x 15.9x 24.2x 93.7x libquant 35.5x 3.0x 118.5x 12.7x 66.7x perimeter \n10.8x 6.1x 13.1x 14.9x 73.6x equake 4.5x 28.4x 208.1x 13.3x 70.7x bisort 18.3x 23.3x 32.5x 9.4x 37.0x \nmst 22.4x 1.9x 11.2x 3.8x 11.1x li 22.7x 20.0x 20.0x 27.8x 176.1x em3d  6.7x 40.1x 13.1x 58.6x treeadd \n7.5x 7.1x 756.4x 44.2x Average 12.1x 7.7x 24.1x 16.7x 65.8x range from 15% to 185% with an average overhead \nof 68% [47]. Our own experimentation with MSCC and the published results in\u00addicate that SoftBound s overhead \nis generally similar to or some\u00adwhat lower than MSCC s overhead on common benchmarks. 7. Additional Related \nWork Many other approaches other than enforcing full spatial safety have been explored for detecting \nand diagnosing bounds violations or preventing bounds-related security vulnerabilities. Many static analyses \nthat detect buffer over.ows have been proposed, includ\u00ading using abstract interpretation [7, 20] and \ninteger programming [22]. Static analysis has also been coupled with lightweight pro\u00adgrammer or inferred \nannotations(e.g., [11, 26]). Static checking tools generally either have false positives or false negatives \n(they are incomplete),but are certainly useful complementary techniques to dynamically enforced spatial \nmemory safety. Other approaches monitor control .ow transfers [30], ensure control .ow integrity [3], \nor enforce data.ow integrity based on reaching de.nition analysis calculated statically [10]. Pointer \nanal\u00adysis can also be used to compute the approximate set of objects written by each instruction [4]. \nIn all four cases, these proper\u00adties are checked dynamically,but neither strategy directly enforces memory \nsafety. Probabilistic memory safety approaches, such as DieHard [6], prevent many security vulnerabilities \nin the heap by using a randomized runtime system and achieving probabilistic memory safety by approximating \nto an in.nite size heap. 8. Conclusion SoftBound is a compile time transformation system to provide spa\u00adtial \nsafety for theC programming language without changes to the source code. SoftBound accomplishes this \nusing a pointer-based approach with a disjoint metadata space. Further, the mechanized formal proof shows \nSoftBound s metadata propagation is suf.cient to provide spatial safety even for programs with arbitrary \ncasts. We experimentally veri.ed SoftBound s ability to catch spa\u00adtial violations using real benchmarks \nwith over.ows and a suite of security vulnerabilities. We found that SoftBound successfully transformed \nseveral benchmarks and two network daemons (around 272K lines of code total) with no source code modi.cations. \nSoft\u00adBound s performance overhead is 67% and 22% on an average in its full and store-only checking modes, \nrespectively. SoftBound s store-only checking mode has less than 15% overhead for more than half of the \nbenchmarks. This runtime overhead is likely low enough to be employed in production code, giving SoftBound \nthe potential to substantially improve the security and robustness of real-world software systems. Acknowledgments \nThe authors thank Vikram Adve, Joe Devietti, Andy Glew, Dan Grossman, and JeffVaughan for comments on \nthiswork.We thank the LLVM developers for answering our LLVM questions, Shan Lu for the BugBench code, \nJohn Wilander for the dynamic secu\u00adrity testbench, Nachiket Kapre for help with hardware performance \ncounters, and Wei Xu for help with MSCC. This paper is based uponwork supportedin partby NSF (National \nScienceFoundation) awards CNS-0524059, CCF-0644197, and CCF-0810947, Defense Advanced Research Projects \nAgency (DARPA) contracts RA06\u00ad46 andFA8650-07-C-7743, and donations from Intel Corporation. Any opinions, \n.ndings and conclusions or recommendations ex\u00adpressed in this paper are those of the authors and do not \nnecessarily re.ect the views of NSF,DARPA, or Intel. References [1] Adobe Reader vulnerability exploited \nin-the-wild, 2008. http://www.trustedsource.org/blog/118/Recent-Adobe-Reader\u00advulnerability-exploited-in-the-wild. \n[2] Adobe Security Advisories: APSB08-19, Nov. 2008. http://www.adobe.com/support/security/bulletins/apsb08-19.html. \n\u00b4 tegrity. In Proceedings of the 10thACM Conference on Computer and Communications Security, Nov. 2005. \n[3] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. Control-Flow In\u00ad [4] P. Akritidis, C. Cadar, C. \nRaiciu, M. Costa, and M. Castro. Preventing Memory Error Exploits with WIT. In Proceedings of the 2008 \nIEEE Symposium on Security and Privacy, 2008. [5] T. M. Austin, S. E. Breach, and G. S. Sohi. Ef.cient \nDetection of All Pointer and Array Access Errors. In Proceedings of the SIGPLAN 1994 Conference on Programming \nLanguage Design and Implemen\u00adtation, June 1994. [6] E. D. Berger and B. G. Zorn. DieHard: Probabilistic \nMemory Safety for Unsafe Languages. In Proceedings of the SIGPLAN 2006 Con\u00adference on Programming Language \nDesign and Implementation, June 2006. [7] B. Blanchet, P. Cousot, R. Cousot, J. Feret, L. Mauborgne, \nA. Mine,\u00b4 D. Monniaux, andX.Rival.AStatic Analyzer for Large Safety-critical Software. In Proceedings \nof the SIGPLAN 2003 Conference on Pro\u00adgramming Language Design and Implementation, June 2003. [8] R.Bod\u00b4ik,R. \nGupta,andV. Sarkar. ABCD: Eliminating Array Bounds Checks on Demand. In Proceedings of the SIGPLAN 2000 \nConference on Programming Language Design and Implementation, June 2000. [9] H.-J. Boehm. Space Ef.cient \nConservative Garbage Collection. In Proceedings of the SIGPLAN 1993 Conference on Programming Lan\u00adguage \nDesign and Implementation, June 1993. [10] M. Castro, M. Costa, and T. Harris. Securing Software by Enforcing \nData-Flow Integrity. In Proceedings of the 7th USENIX Symposium on Operating Systems Design and Implementation, \nNov. 2006.  [11] J. Condit, M. Harren, Z. Anderson, D. Gay, and G. C. Necula. Depen\u00addent Types for Low-Level \nProgramming. In Proceedings of the 16th European Symposium on Programming, Apr. 2007. [12] K. D. Cooper, \nM. W. Hall, and K. Kennedy. A Methodology for Procedure Cloning. Comput. Lang., 19(2):105 117, 1993. \n[13] The Coq Development Team. The Coq Proof Assistant Reference Manual (Version 8.2beta4), 2008. [14] \nC. Cowan, P. Wagle, C. Pu, S. Beattie, and J. Walpole. Buffer Over\u00ad.ows: Attacks and Defenses for the \nVulnerability of the Decade. In Proceedings of theFoundations of IntrusionTolerant Systems, 2003. [15] \nJ. Criswell, A. Lenharth, D. Dhurjati, andV. Adve. SecureVirtual Ar\u00adchitecture: A Safe Execution Environment \nfor Commodity Operating Systems. In Proceedings of the 21st ACM Symposium on Operating Systems Principles, \nOct. 2007. [16] J. Devietti, C. Blundell, M. M. K. Martin, and S. Zdancewic. Hard\u00adbound: Architectural \nSupport for Spatial Safetyof theCProgramming Language. In Proceedings of the 12th International Conference \non Ar\u00adchitectural Support for Programming Languages and Operating Sys\u00adtems, Mar. 2008. [17] D. Dhurjati \nand V. Adve. Backwards-Compatible Array Bounds Checking for C with Very Low Overhead. In Proceeding of \nthe 28th International Conference on Software Engineering, May 2006. [18] D. Dhurjati, S. Kowshik, and \nV. Adve. SAFECode: Enforcing Alias Analysis for Weakly Typed Languages. In Proceedings of the SIG-PLAN \n2006 Conference on Programming Language Design and Im\u00adplementation, June 2006. [19] D. Dhurjati, S. Kowshik, \nV. Adve, and C. Lattner. Memory Safety Without Runtime Checks or Garbage Collection. InProceedings of \nthe 2003 ACM SIGPLAN Conference on Language, Compiler, and Tool for Embedded Systems (LCTES), 2003. [20] \nN. Dor,M. Rodeh, andM. Sagiv. CSSV:Towardsa RealisticTool for Statically Detecting All Buffer Over.ows \nin C. In Proceedings of the SIGPLAN 2003 Conference on Programming Language Design and Implementation, \nJune 2004. [21] F. C. Eigler. Mud.ap: Pointer Use Checking for C/C++. In GCC Developer s Summit, 2003. \n[22] V. Ganapathy, S. Jha, D. Chandler, D. Melski, and D. Vitek. Buffer Overrun Detection using Linear \nProgramming and Static Analysis. In Proceedings of the 10th ACM Conference on Computer and Commu\u00adnications \nSecurity, 2003. [23] D. Gay and A. Aiken. Memory Management with Explicit Regions. In Proceedings of \nthe SIGPLAN 1998 Conference on Programming Language Design and Implementation, June 1998. [24] D. Grossman. \nSafe Programming at the C Level of Abstraction. PhD thesis, Department of Computer Science, Cornell University, \nAug. 2003. [25] D. Grossman, G. Morrisett,T. Jim, M. Hicks,Y.Wang, and J. Cheney. Region-Based Memory \nManagement in Cyclone. In Proceedings of the SIGPLAN 2002 Conference on Programming Language Design and \nImplementation, June 2002. [26] B. Hackett, M. Das, D. Wang, and Z. Yang. Modular Checking for Buffer \nOver.ows in the Large. In Proceedings of the 28th Interna\u00adtional Conference on Software Engineering (ICSE), \n2006. [27] R. Hastings and B. Joyce. Purify: Fast Detection of Memory Leaks and Access Errors. In Proceedings \nof the Winter Usenix Conference, 1992. [28] T. Jim, G. Morrisett, D. Grossman, M. Hicks, J. Cheney, andY.Wang. \nCyclone: A Safe Dialect of C. In Proceedings of the 2002 USENIX AnnualTechnical Conference, June 2002. \n[29] R. W. M. Jones and P. H. J. Kelly. Backwards-Compatible Bounds Checking for Arrays and Pointers \nin C Programs. In Third Interna\u00adtionalWorkshop onAutomated Debugging, Nov. 1997. [30] V. Kiriansky, D. \nBruening, and S. Amarasinghe. Secure Execution via Program Shepherding. In Proceedings of the 11th USENIX \nSecurity Symposium, Aug. 2002. [31] G. Kroah-Hartman. The LinuxKernel Driver Model: The Bene.ts of WorkingTogether.InA.OramandG.Wilson, \neditors,Beautiful Code: Leading Programmers Explain How TheyThink. O Reilly Media, Inc., June 2007. [32] \nL. Lam and T. Chiueh. Checking Array Bound Violation Using Seg\u00admentation Hardware. In Proceedings of \nthe International Conference on Dependable Systems and Networks, June 2005. [33] C. Lattner andV. Adve. \nLLVM:A Compilation Framework for Life\u00adlong Program Analysis &#38; Transformation. In Proceedings of the \nIn\u00adternational Symposium on Code Generation and Optimization, 2004. [34] S. Lu, Z. Li,F. Qin, L.Tan,P. \nZhou, andY. Zhou. Bugbench: Bench\u00admarks for Evaluating Bug Detection tools. In In PLDI Workshop on the \nEvaluation of Software Defect DetectionTools, June 2005. [35] G. C. Necula, J. Condit, M. Harren, S. \nMcPeak, and W. Weimer. CCured:Type-Safe Retro.tting of Legacy Software. ACM Transac\u00adtions on Programming \nLanguages and Systems, 27(3), May 2005. [36] N. Nethercote and J. Fitzhardinge. Bounds-Checking Entire \nPrograms Without Recompiling. In Proceedings of the SecondWorkshop on Se\u00admantics, Program Analysis, and \nComputing Environments for Memory Management, 2004. [37] H.Patil and C. N. Fischer. Low-Cost, Concurrent \nChecking of Pointer and Array Accesses in C Programs. Software Practice &#38; Experi\u00adence, 27(1):87 \n110, 1997. [38] J. Pincus and B. Baker. Beyond Stack Smashing: Recent Advances in Exploiting Buffer Overruns. \nIEEE Security&#38; Privacy, 2(4):20 27, 2004. [39] P. Porras, H. Saidi, and V. Yegneswaran. An Analysis \nof Con.cker s Logic and Rendezvous Points. Technical report, SRI International, Feb. 2009. [40] A. Rogers, \nM. C. Carlisle, J. H. Reppy, and L. J. Hendren. Supporting Dynamic Data Structures on Distributed-Memory \nMachines. ACM Transactions on Programming Languages and Systems, 17(2):233 263, 1995. [41] O. Ruwase \nand M. S. Lam. A Practical Dynamic Buffer Over.ow Detector. In Proceedings of the Network and Distributed \nSystems Se\u00adcurity Symposium, Feb. 2004. [42] J. Seward and N. Nethercote. UsingValgrind to Detect Unde.ned \nValue Errors with Bit-Precision. In Proceedings of the 2005 USENIX AnnualTechnical Conference, Apr. 2005. \n[43] SoftBound website. http://www.cis.upenn.edu/acg/softbound/. [44] D. Wagner, J. S. Foster, E. A. \nBrewer, and A. Aiken. A First Step towards Automated Detection of Buffer Overrun Vulnerabilities. In \nProceedings of the Network and Distributed Systems Security Sympo\u00adsium, 2000. [45] J. Wilander and M. \nKamkar. A Comparison of Publicly Available Tools for Dynamic Buffer Over.ow Prevention. InProceedings \nof the Network and Distributed Systems Security Symposium, 2003. [46]T.W\u00a8ossenb\u00a8urthinger,C.Wimmer, andH.M \n\u00a8ock. Array Bounds Check Elimination for the Java HotSpot Client Compiler. In Proceedings of the 5th \ninternational symposium on Principles and practice of pro\u00adgramming inJava, 2007. [47] W. Xu, D. C. DuVarney, \nand R. Sekar. An Ef.cient and Backwards-CompatibleTransformation to Ensure Memory Safety ofCPrograms. \nIn Proceedings of the 12th ACM SIGSOFT International Symposium onFoundations of Software Engineering \n(FSE), 2004. [48] S.H.Yong andS. Horwitz. ProtectingC Programs From Attacks via Invalid Pointer Dereferences. \nIn Proceedings of the 11th ACM SIG-SOFT International Symposium onFoundations of Software Engineer\u00ading \n(FSE), 2003.    \n\t\t\t", "proc_id": "1542476", "abstract": "<p>The serious bugs and security vulnerabilities facilitated by C/C++'s lack of bounds checking are well known, yet C and C++ remain in widespread use. Unfortunately, C's arbitrary pointer arithmetic, conflation of pointers and arrays, and programmer-visible memory layout make retrofitting C/C++ with spatial safety guarantees extremely challenging. Existing approaches suffer from incompleteness, have high runtime overhead, or require non-trivial changes to the C source code. Thus far, these deficiencies have prevented widespread adoption of such techniques.</p> <p>This paper proposes SoftBound, a compile-time transformation for enforcing spatial safety of C. Inspired by HardBound, a previously proposed hardware-assisted approach, SoftBound similarly records base and bound information for every pointer as disjoint metadata. This decoupling enables SoftBound to provide spatial safety without requiring changes to C source code. Unlike HardBound, SoftBound is a software-only approach and performs metadata manipulation only when loading or storing pointer values. A formal proof shows that this is sufficient to provide spatial safety even in the presence of arbitrary casts. SoftBound's full checking mode provides complete spatial violation detection with 67% runtime overhead on average. To further reduce overheads, SoftBound has a store-only checking mode that successfully detects all the security vulnerabilities in a test suite at the cost of only 22% runtime overhead on average.</p>", "authors": [{"name": "Santosh Nagarakatte", "author_profile_id": "81435608524", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1464286", "email_address": "", "orcid_id": ""}, {"name": "Jianzhou Zhao", "author_profile_id": "81435599390", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1464287", "email_address": "", "orcid_id": ""}, {"name": "Milo M.K. Martin", "author_profile_id": "81100426086", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1464288", "email_address": "", "orcid_id": ""}, {"name": "Steve Zdancewic", "author_profile_id": "81384616728", "affiliation": "University of Pennsylvania, Philadelphia, PA, USA", "person_id": "P1464289", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542504", "year": "2009", "article_id": "1542504", "conference": "PLDI", "title": "SoftBound: highly compatible and complete spatial memory safety for c", "url": "http://dl.acm.org/citation.cfm?id=1542504"}