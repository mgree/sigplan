{"article_publication_date": "06-15-2009", "fulltext": "\n TypedSelf-Representation TillmannRendel KlausOstermann ChristianHofer University ofAarhus,Denmark Abstract \nSelf-representation the ability to represent programs in their own language has important applications \nin re.ective languages and many other domains of programming language design. Al\u00adthough approachestodesigning \ntypedprogram representationsfor sublanguages of some base language have become quite popu\u00adlar recently, \nthe question whether a fully metacircular typed self\u00adrepresentationispossibleis still open.Thispaper \nmakes abig step towards this aim by de.ning the F. * calculus, an extension of the higher-order polymorphic \nlambda calculus F. that allows typed self-representations. While the usability of these representations \nfor metaprogramming is stilllimited, webelieve that our approach makes a signi.cant step towards a new \ngeneration of re.ective languages that areboth safe and ef.cient. Categories and Subject Descriptors \nD.3.1 [Programming Lan\u00adguages]: FormalDe.nitions andTheory General Terms Languages,Theory Keywords Lambda \nCalculus, Language Design, Re.ection, Self Interpretation,Types 1. Introduction It is a basic result \nof computability theory that every Turing\u00adcomplete programming language allows representing programs \nin that language as data, and writing a metacircular interpreter in terms ofthis self-representation.Thereis \nalonghistoryinprogram\u00adminglanguages ondesigning self-representations and metacircular interpreters whichdatesbackatleasttothe \nearlydays ofLISP[18]. Self-representationplays a crucialroleinthedesign ofre.ective languages. For example, \nthe classical re.ective tower[26] consists of a stack ofinterpreters such that each interpreterisprogram \ndata onthe nextlevel.In such re.ectivelanguages, self-representationis usually formalizedin theform of \na quote function, which converts terms to representations of terms, and an unquote or eval function which \nconverts term representationsback to terms. There are manygood reasons to consider thepossibility of \nstat\u00adically typed self-representation. The expressive power of dynami\u00adcallytyped re.ectivelanguagesis \nwell-known,butthelack of static typing makes this power hard to control. Furthermore, statically typedprogram \nrepresentations allow tagless interpreters, whichare an order of magnitude faster than ordinary interpreters \nwhich use Permission to make digital or hard copies of all or part of this work for personal or classroomuseisgranted \nwithoutfeeprovided that copiesarenot madeordistributed forpro.tor commercial advantage andthat copiesbearthis \nnotice andthefull citation onthe .rstpage.Tocopy otherwise,torepublish,topostonserversortoredistribute \ntolists, requiresprior speci.cpermission and/or afee. PLDI 09, June15 20,2009,Dublin,Ireland. Copyright \nc &#38;#169; 2009ACM978-1-60558-392-1/09/06. . .$5.00 tagged unionsto represent values.Another motivationforthis \nwork stemsfromSteele sideaofgrowablelanguages[27],which ac\u00adcording toSteele necessitatesthatfeaturesprovidedby \nalibrary looklikebuilt-inlanguagefeatures.The abilityto representa whole statically typed language within \nthe language itself can be consid\u00adered as a realization of Steele s idea in that the language itself \ncan be made tolook asifit wereprovidedby alibrary. Despite these excitingpossibilities,thequestion ofwhetheritis \npossible to design languages that allow typed self-representations isalong-standing openquestion.Reynoldshashinted \nattheques\u00adtion of typed self-representationinhis classicpaper onde.nitional interpreters[24].Therehavebeen \nattempts, notablythosebyPfen\u00adning andLee[21] and more recentlybyCarette et al.[7],but none of these attempts \nhave resulted in a fully metacircular typed self\u00adrepresentation(more about thatlater). In this paper, \nwe present our attempt to make typed self\u00adrepresentation possible and useful. More speci.cally, the contri\u00adbutions \nof this work are asfollows: Wegive ade.nition what typed self-representationis,by spec\u00adifying a set \nofpropertiesit should minimallyful.ll.  We identify problems of current approaches of typed self\u00adrepresentation. \n Wepresent alanguage, which allows typed self-representation. We show how a metacircular interpreter \ncan be written in the language, and we discuss the scope of alternative interpreta\u00adtions that can be \nde.ned on this self-representation. The lan\u00adguage, which we call F .* , is an extension of the higher-order \npolymorphiclambda calculusF..The nameisbecause the cru\u00adcial addition to F., which enables typed self-representation, \nis a variant of the type:type rulefrom the .* calculus[8].  We have formalized F . * in the Coq theorem \nprover [5] and present a machine-checked proof that the proposed typed self\u00adrepresentation is indeed \nmetacircular. Furthermore, we have implementedboth a type checker andinterpreterforF .* .  We present \nan embedding of F. * into the pure type systems framework[4,29,3].Bythisembedding wecan reuse the meta-theory \nofpure type systems andgive an accurate compar\u00adison withotherPTSinstances.  We conclude with a detailed \ndiscussion of the remaining open issues in our representation, and future work, in particular the issue \nof quoting terms with free variables and the use of type\u00adindexeddatatypestoget more .exibleself-representations. \n  The remainder of this paper is structured as follows. The next section discusses the notion of typed \nself-representation. F. * and itsself-embedding areintroducedinSec.3.Section4presentsour technical results \nand open issues. Section 5 discusses the issue of integrating typed self-representationintoprogramming \nlanguages. Section 6 discusses the design decisions, related approaches, open issuesandfuturework,and \nthe .nalSectionconcludes. 2. TypedSelf-Representation Self-representation refers to the possibility \nof representing terms of a programming language in the language itself. In the untyped setting, thisis \ntypicallyimplementedby a quote mechanism which transforms a term into its representation, and a corresponding \nun\u00adquote or eval function that transforms a representation back to the represented term. Correspondingly, \na typed self-representation is a self-representation of terms within a typed language, mapping typed \nterms to typed representations of terms. Like with untyped self-representation, a code transformation \nquoteis usedtotransform termsto representations ofterms, which can be processed by programs written in \nthe language itself. In the context of static typing, however, we want to describe both the quote transformation \nand the individual operations on quoted terms on the type level to guarantee the well-formedness of these \noperations.Theseadditionalguarantees areanimportant reasonto search for a typed self-representation in \nthe .rst place. It should be noted, however, that this does not necessitate a corresponding quotetransformation \nontypes,transformingthemtoterms ortypes of the language. Instead, the type of the representation of a \nterm may simply re.ectits character asbeing such a representation. In a setting where quoted terms are \nrepresented by encoding their abstract syntax trees as a data structure, the notion of typed self-representation \nmay seem to be intuitive. However, the notion becomes less clear if one considers sophisticated encoding \ntech\u00adniques such as higher-order abstract syntax [20] or .nal rep\u00adresentations of programs [7]. Therefore, \nwe .rst have to clarify the notion of typed self-representation. We consider typed self\u00adrepresentation \nto be constituted by the following .ve properties. After the presentation of our solution, we will revisit \nthese prop\u00aderties and discuss to what degree our solution has the properties proposed here. 1. Representation. \nThere is a family of types ExprT such that quote(t)has type ExprT ifand onlyif t has type T. ' 2. Adequacy.Everyterm \nt of type ExprT corresponds to a term tof type T, which means that for every t as above there exists \na '' tsuch that t = quote(t). 3. FirstClassInterpretations.Itispossibleto express operations onquoted \nterms so thatthey are well-typedfor allterms oftype ExprT , without the need to refer to any speci.c \nsuch terms. 4. SelfInterpretation. Thereis afamily of contexts evalT ()such that evalT (quote(t))is \nobservational equivalent to t if t has type T. 5. Re.ection. quote(t)exhibits the intensional structure \nof t in a useful way.  Theproperties areformulatedintermsoffamiliesof types and contexts to make them \napplicable to different languages and type systems, even if they do not provide functional abstraction. \nFor a functional language, one can read family of types as type constructor , and context as function \n. The .rst property ensures the full circularity of the represen\u00adtation: The quote transformation can \ntransform every well-typed terminto a well-typed term.Furthermore, quote(t)canbe seen as containing a \nproof of the well-typedness of t. But to be more pre\u00adcise, we alsohaveto say something aboutthetyping \ncontext.While one mayliketo allowfree variablesin t, and consequently allow ar\u00adbitrary typing contextsinProp.1, \nthisleads to some complications as we will see below. Hence for now we only demand that quot\u00ading works \ncorrectly for closed terms, i.e., \u00d8f t : T if and only if \u00d8f quote(t): ExprT . Property 1 ensures that \nthe type family ExprT is expressive enough to encompass all representations of well-typed terms. On the \nother hand, Prop. 2 states that ExprT is precise enough to rule out exoticterms oftype ExprT whichdo \nnot correspondto anyterm of type T. Together, these properties specify that the extension of ExprT ispreciselythe \nset ofquoted terms.Obviously, thisproperty cannot hold for languages which allow diverging terms of type \nExprT. However, a weaker variant is applicable, which requires adequacy onlyfor normalizing terms of \ntype Exprt. While Prop. 1 already implies that quoted terms are .rst-class values atleastinthe sensethatthey \ncanbe separatelytyped,Prop.3 requires the samefor operations onquoted terms. Property 4 guarantees that \nquoted terms contain enough infor\u00admation to write a standard evaluator.Although there maybe useful weakerself-representations, \nwebelievethatthispropertyisessen\u00adtialfor many applicationsin re.ectivelanguages. Property 5 aims at the \ncapability to apply interesting non\u00adstandard interpretations on quoted terms. Recurring examples are \npretty printing, size measuring, CPS transformation or converting into an untyped representation. The \nde.nition of the property is intentionally vague, as it is not clear which kind of interpretations could \nor should be possible in a typed setting. Hence we do not want to prematurely preclude other possible \napproaches to typed\u00adself representationby a too narrowde.nition. However, without this property, the \ntrivial encoding, using the identity function as quote, or simple wrappers around terms such as boxing \n[9], or staging annotations [28] would count as forms of typed self-representation, as they ful.ll some \nor all of the other properties above. These representations, however, do not give ac\u00adcess to theintensional \nstructure of terms.Thisprecludes exploring the syntactic structure of aterm, e.g., whetheritis afunction \nappli\u00adcation or a .-abstraction, or changing the meaning of thelanguage primitivesin a non-standard interpretation. \nF* 3. anditsSelf-Embedding . A language with the properties introduced in the last section has to feature \nboth a term language simple enough to allow quote to encode allfeatures of thelanguage and atype system \nrich enough to encode the family of types ExprT . Experiments by Pfenning et al.[21] suggest that to \nsupport alevel of abstractionin the encoded language, a higher level of abstraction has to be supported \nin the encodinglanguage, e.g., second-ordertypes are neededto represent .rst-order types. With self-representation, \nencoded and encoding language are identical. While this seems to preclude typed self\u00adrepresentation at \n.rst, we will show how to escape from this circle after wehaveintroduced the style ofquoting and evaluating \nwe aim at. 3.1 Encoding of terms and types Instead of a representation of terms as an abstract syntax \ntree, we choose a Church encoding, which has a number of advantages over adatatypebased representation, \nmost notably thatitkeeps the language simple since it is not necessary to add, and subsequently represent,datatypes.Furthermore, \nwedo not represent the types of the language explicitly, but each term representation is associated with \na type in the meta-language that ensures type-safety. In order to guarantee the type-safe representation \nof variables, we make use of higher-order abstract syntax (HOAS) [20]. Our encoding hasbeen mainlyinspiredby \nrelated approaches ofPfenning/ Lee [21] and Carette et al. [7] which we will discuss in Sec. 6. In the \nfollowing, we will .rst describe our encoding technique in an untyped setting, and subsequently develop \nour solution to the typingproblem. A lambda term such as the church numeral two in the untyped lambda \ncalculus .f . .x . f(fx)  can be encoded by abstracting over the meaning of the nodes in the syntax \ntree. Since lambda terms contain only abstractions and applications, we can encode theChurch numeral \ntwo as The lam and app binders ful.ll the analogous function in our en\u00adcoding as the f and x bindersintheChurch \nencoding of numerals. Due to the use of HOAS, the bound variables f and x are not rep\u00adresented by some \n.rst-order representation like de Bruijn indices [10],butbyemploying thelambdabinding mechanism ofthe \nmeta\u00adlanguage. A context eval(), asdescribed in theprevious section, for eval\u00aduating suchquoted terms \ncanbede.ned as eval(t)= t(.f . f)(.f . .x . fx). To lift this encoding to a typed lambda calculus, one \nhas to give types for lam and app. A .rst attempt might be the following SystemFtypes: App= .A:: * . \n.B:: * .(A . B). A . B attempt Lamattempt = .A:: * . .B:: * .(A . B). (A . B). Note how these versions \nof App and Lam are polymorphic in the domain and codomain of the processed function. We call the set \nof types(like App and Lam)that describe a language a language interface. Unfortunately, the types for \nApp and Lam above do not allow interestinginterpretersbeyond self-evaluation, since all reasonable functions \nwith these types are identity functions. In type systems withabstraction overtypefunctions, such asF.,we \ncan add another parameter R:: * . * which represents the change in the type we want to perform with app \nand lam. While a self-interpreter can choose R = ID = .T: * . T, other interpreters are free to choose \nmoreinteresting typefunctions.Using R,the types of app and lam are: AppR = .A:: * . .B:: *.R(A . B). \nRA . RB LamR = .A:: * . .B:: *.(RA . RB). R(A . B). Notehow the types nowdepend on R asfree variable. \nHowever, for a metacircular self-representation of all terms in F., we have to account for the type abstraction \nand application operations in these types, too. We call the types that describe type abstraction and \napplication TLam and TApp, respectively.For example, we want to represent the polymorphic identity function \n.T:: * . .x : T. x as .R:: * . * . .lam: LamR. .app : AppR . .tlam : TLamR. .tapp: TAppR . tlam[*][.T:: \n* . T . T](.T:: * . lam[T][T](.x : RT. x)) with suitable types TLam and TApp in addition to the types \nLam and Appintroduced above. We model tlam and tapp analogous to lam and app.Thefunc\u00adtionthatisprocessedisafunction \nmappingtypestoterms,i.e., a polymorphic term. The .rst parameter of tlam and tapp states thedomain(ontypes,i.e,itis \nakind,inthe example: *), while the secondparameter states the codomain.However, the codomain candepend \nonthe respectiveinhabitant of thedomain,i.e.,itis a family of types indexed by types. Thus, it has to \nbeparameterized by the respectiveinhabitant of thedomain(.T:: * . T . T in the example).The thirdparameteris \nthe actualpolymorphic term, rep\u00adresentedby aHOAS encoding on the typelevel. Unfortunately, as the example \nillustrates for TLam, the types TLam and TApp cannot be expressed in F., since they have to App =.R:: \n* . * . .A:: * . .B:: *. R(A . B). RA . RB Lam =.R:: * . * . .A:: * . .B:: *. (RA . RB). R(A . B). TApp \n=.R:: * . * . .S:: D. .T:: S . *. R(.X:: S. TX). (.X:: S. R(TX)) TLam =.R:: * . * . .S:: D. .T:: S . \n*. (.X:: S. R(TX)). R(.X:: S. TX) Expr =.A:: * . .R:: * . *. AppR . LamR . TAppR . TLamR . RA Figure1. \nTheF . * language interface allow abstraction over polymorphic terms of arbitrary kinds, but F. does \nnot allow kind-polymorphism. Indeed, even adding kind\u00adpolymorphism is not enough, because the representation \nof kind polymorphism would again have to abstract over the form of the kind being abstracted over, employing \nanother, higher level of polymorphism. The key idea to break this circle is to add a constant D which \nstandsforthekind of allkinds.Furthermore, we unify the syntactic categories of types and kinds, such \nthat the regular type-level . can be used to express kind functions, and the regular expression\u00adlevel \n. to express kind-polymorphic terms. This extended version of F. allows giving sensible types for tapp \nand tlam, as shown in Fig. 1, which also shows how the type family ExprT from the previous section canbe \nencoded directlyas a typefunction.Hence the type of the representation of ourpolymorphic identityfunction \nisExpr (.T:: * . T . T), asdesired. 3.2 ThelanguageF . * Beforewediscussourlanguage w.r.t. typed self-representation, \nwe .rsthavetoformalizetheextensionstoF. wehad tointroduce tode.ne thelanguage interface.We call thislanguage \nF .* ,because itcombinesfeatures ofF. and .* [12].Itsformalde.nition canbe foundinFig.2. F * . features \nthe same term language as F., but collapses the syntactic categories of types and kinds, similar to how \nin .* all syntactic categories are collapsed.Therefore every(well-typed)F. termis a(well-typed)F . * \nterm as well, and similarly(well-kinded) F. types are(well-kinded) F. * types. Since we collapse types \nand kinds,F. kinds are again well-kinded F . * types.On the otherhand, every typing statement in .* can \nbe transformed into a kinding statementinF.*,if one substitutes * byD, and adapts the syntax to account \nfor the differences in the syntax de.nitions. In this sense, every well-typed .* term corresponds to \na well-kindedF. * type. Notethatwestilldistinguish typing andkinding, astheformer is about well-formedness \nof terms, while the latter is about well\u00adformedness oftypes.Furthermore,the typing andkinding rules en\u00adsure \nthat in all bindings of form x : T, T must be a proper type, while in bindings of the form X:: T, T must \nbe a proper kind. In the same way, we distinguish three function types: T . T, where domain and codomain \nareproper types, .X:: T. T, where the do\u00admainis aproperkind, while the codomainis a type-indexedfamily \nofpropertypes, and .X:: T. T,wherethedomainisaproperkind, whilethe codomainis atype-indexedfamily ofproperkinds.These \ndifferent syntactic forms follow the standard F. syntax de.nition and emphasize the difference between \nstatements about terms and statements about types.As we will arguelater, they are not strictly necessary. \nAbstraction over terms is written with a lower-case lambda .x: T . b while abstraction over types and \nkinds uses a upper\u00ad Syntax x := term variables X := type/kind variables t := terms: x variable | tt \napplication | t[T] type application | .x: T . t abstraction | .X :: T . t type abstraction T := types/kinds: \n* kind of proper types | D kind of all kinds | X type/kind variable | T T type/kind application | .X \n:: T . T type/kind abstraction | T . T function type | .X :: T . T polymorphic type | .X :: T . T dependent \nkind T1 . T2 is syntactic sugarfor .X :: T1 . T2 ifX/. FV(T2) G := contexts \u00d8 empty context | G,x : \nT term variablebinding | G,X :: T type/kind variablebinding Typing G f T :: * x . dom(G) (T-VAR) G,x \n: T f x : T G f t: T1 G f T2 :: * x . dom(G) (T-WEAK1) G,x : T2 f t : T1 G f t : T1 G f T2 :: D X . dom(G) \n (T-WEAK2) G,X :: T2 f t : T1 G f t1 : T1 . T2 G f t2 : T1 (T-APP) G f t1 t2 : T2 G f t :(.X :: T1 . \nT2 )G f T3 :: T1 (T-TAPP) G f t[T3]:T2 [X . T3] G f T1 :: * G,x : T1 f t : T2 (T-ABS) G f (.x: T1 . \nt):(T1 . T2) G f T1 :: D G,X :: T1 f t: T2 (T-TABS) G f (.X :: T1 . t):(.X :: T1 . T2) G f t : T1 G \nf T1 :: * T1 = \u00df T2 (T-CONV) G f t : T2 Kinding (K-TYPE) \u00d8f * :: D (K-KIND) \u00d8f D :: D G f T :: D X . \ndom(G) G,X :: T f X :: T (K-VAR) G f T :: T1 G f T1 :: D T1 = \u00df T2 (K-CONV) G f T :: T2 G f T1 :: T2 \nG f T3 :: * x . G (K-WEAK1) G,x : T3 f T1 :: T2 G f T1 :: T2 G f T3 :: D X . G (K-WEAK2) G,X :: T3 \nf T1 :: T2 G f T1 ::(.X :: T3 . T4) G f T2 :: T3 (K-APP) G f T1 T2 :: T4[X . T2 ] G f T1 :: D G,X :: \nT1 f T2 :: T (K-ABS) G f (.X :: T1 . T2 ):(.X :: T1 . T)G f T1 :: * G f T2 :: * (K-FUN) G f (T1 . T2)::* \nG f T1 :: D G,X :: T1 f T2 :: * (K-TFUN) G f.X :: T1 . T2)::* G f T1 :: D G,X :: T1 f T2 :: D (K-KFUN) \nG f (.X :: T1 . T2 )::D Figure2. De.nition ofF . * caselambda .X :: T . B.Typeapplicationiswrittenwithbrackets \norkindfunction .X :: T . B has a kind of the form .X :: T . B, f [T]. which canbeabbreviated as T . B \nif X is notfreein B. The type and kind language consists of two constants, the kind The de.nitions of \n\u00df reduction and \u00df equivalence on terms and of alltypes * andthekind of allkinds D.Abstractionovertypesor \ntypesarenot shown,butthey arede.ned asusual and canbefound kinds is written with a lower-case lambda \n.X :: T . B.Thereare inourCoqformalization. different syntactic forms for the three different kinds of \nfunctions: The typing rules mostly follow the corresponding rules of F., Afunction.x: T . bhas atype \noftheformT . B,apolymorphic but(T-WEAK2)and(T-TABS)havetoexplicitlycheckthatthemen\u00adfunction .X :: T . \nbhas a type of theform .X :: T . B and atype tionedkindsarethemselveswell-kinded using ajudgmentofthe \n Quoting ' R,lam,app,tlam,tapp . t,T ' (QUOTE) (t)= .R:: * . * . .lam: LamR. .app : AppR. .tlam : TLamR. \n.tapp: TAppR. t Pre-Quoting G f t: T CG f t : T1 C t2 t2 G f T2 :: * x . dom(G) G f T2 :: D X . dom(G) \n(Q-WEAK1) (Q-WEAK2) G,x : T2 CG,X :: T2 C f t : T1 t2 f t: T1 t2 C t4 T2 C t3 G f t2 : T1 G f t1 : T1 \n. G f T1 :: * G,x : T1 C f t : T2 t2 (Q-ABS) (Q-APP) G f (.x: T1 . t):(T1 . T2) C app [T1][T2 ]t3 t4 \nC lam[T1 ][T2 ](.x: RT1 . t2) G f T3 :: T1 G f T1 :: D G f t1 :(.X :: T1 . T2) C t2 G,X :: T1 f t : T2 \nC t2 G f t1 t2 : T2 (Q-TAPP) (Q-TABS) G f t1 [T3 ]:T2[X . T3]G f (.X :: T1 . t):(.X :: T1 . T2) C tapp[T1 \n][.X :: T1 . T2 ]t2 [T3 ] C tlam[T1 ][.X :: T1 . T2](.X :: T1 . t2 ) G f t : T1 C t2 G f T :: * x . dom(G) \n (Q-VAR) G f T2 :: * T1 = \u00df T2 G,x : T f x : T C(Q-CONV) x G f t : T2 C t2 * Figure3. QuotingofF ..Additions \nto the typing rulesinFig.2 are markedbyboxes. form G f T :: D. This is not needed in F. because all syntacti-ID \n=.T:: * . T callypossibleF. kinds are already well-formed. selfapp : AppID * The kinding rules of F . \nare substantially more complex then selfapp =.T1 :: * . .T2 :: * . .f :(T1 . T2 ). .x : T1 . fx thekinding \nrules ofF., sincekinds may now contain variables and sel.am : LamID all contained kinds have to be checked \nfor well-formedness using sel.am =.T1 :: * . .T2 :: * . .f :(T1 . T2 ). f judgments oftheform G f T :: \nD. selftapp : TAppID *  3.3 SelfRepresentationinF . selftapp =.T1 :: D . .T2 ::(T1 . *). .f :(.X:: T1 \n. T2 X). .X: T1 . f[X] Followingthe examplesinSec.3.1,quotingisformalizedas atype\u00addirectedtransformation, \nseeFig.3.Quotingisde.nedintwo steps: selftlam : TLamID A pre-quote computation that is embedded into \nthe typing rules, selftlam =.T1 :: D . .T2 ::(T1 . *). .f :(.X:: T1 . T2 X). f and a quote operation \nwhich turns apre-quoteinto aquoteby clos\u00ad eval : .A:: * . ExprA . A ing overitsfree variablesfromthelanguageinterface:Thejudg\u00ad \neval =.A:: * . .e : ExprA. ' ment G f t : T C t handles theintroduction offree variablesR, e ID selfapp \nsel.am selftapp selftlam app, lam, tapp and tlam, while the rule (QUOTE)de.nes a term (t)of type G f(t):ExprT \nwhich binds these free variables. The Figure 4. Self Interpreter. The types of the terms are given for \n' rules for G f t : T C t are a syntactic superset of the rules for G f t : T in Fig. 2 that do not add \nany new constraints, hence every well-typed term can be quoted. The newly added parts are framed. Note \nthat according to that rule, a term t that contains the variables R, app, lam, tapp and tlam cannot be \nquoted, but a simple a-renaming is suf.cient to remove potential name clashes: As the pre-quoting relation \nis closed under a-renaming, there is an a-equivalent term which can be pre-quoted, if a pre-quoting judgment \ncan be derived for the originalterm. Similarly, if a pre\u00ad ' better readability. the meaning of(type) \napplication and(type) abstractioninthein\u00adterpretation, and give an according de.nition of R that makes \nthe interpretation well-typed. For the meta-circular interpreter, this is showninFig.4.All the operations \narebasicallyidentityfunctions, and R is accordingly theidentityfunction on typelevel. 4. MetatheoryofF* \nquotingjudgmentG f t : T C t isderivedfor atermt such that . T contains these variables, there is an \na-equivalent type, such that We establish basic properties of F . by encoding it as a pure type * t canbequoted,by \nthesameargument. system(PTS)[4,29,3].PTS areafamily oflambdacalculi,param\u00adHavingshownthequotingmechanism,wecannowdemon-eterizedby \nthesortsof termsthey contain(e.g.expressions,types, * strate, how to implement a meta-circular interpreter \nfor quoted F . kinds, ...),theirrelations(e.g.expressionsarequali.edby types) * terms in F ..Inordertode.netheinterpreter,wehavetospecify \nandtheallowed abstractions(e.g.termscanabstractovertypes). F* . is thefollowingPTSinstance. S = {*,D} \nA = {* : D,D : D} R = {(*,*,*),(D,*,*),(D,D,D)} The setof sorts S speci.esthat wehavetwolevels,terms \nwhose types are classi.edby * and types whose types are classi.edby D. The axiomsAcorrespond tothe rules \n(K-TYPE)and(K-KIND),and the relations Rallow the three types of abstraction availablein our language: \nterms can abstract over terms, terms can abstract over types, and types can abstract over types. ThePTSinstances \ncorrespondingtoF., .* andF . * are compared inFig.5, which suggests thatF . * containsF. on the termlevel, \nand .* on the typelevel(renaming * to D). Whilethe representation ofF. * as apuretype system maybeless \naccessiblefor readers notfamiliar withPTS,it allows usto easily derive a number of properties which hold \nfor all PTS, including subject reduction. To do so, we have to show that our typing and kinding rules \nindeed correspond to the PTS rules specialized for the instance de.ned above. A F. * term is converted \nto PTS syntax by dropping all brackets and replacing :: with :, . with ., and . with .. While the syntactic \ncategories collapse in this process, the distinction between terms and types is still upheld by the type \nsystem, whichdistinguishesbetween terms whose types are of sort *, and types whose types are of sort \nD. Therefore, each well\u00adtyped PTS term can be translated back to F . * in a type-directed manner, replacing \n: by :: if the quali.er has type D, . by . if the corresponding termhastype *, .to .ifthetype ofthe whole \nterm has type *, but the quali.er in the .-Expression has type D, and fa to f [a]ifthe type ofthe type \nof a isD,but the type of the type of fa is *. The treatment of the term-type-dichotomy on the syntactic \nlevel allows us to omit some checks of the form G f t : * resp. G f t : D in the typing and kinding rules \nin Fig. 2, which have tobedoneinthetyping rulesforgeneralPTS aspresentedin[3]. However,itiseasy toseethattheomitted \nchecks aresyntactically ensured in F .* .By thisembedding intothePTSframework wecan hence reuse the meta-theory \nofPTS, andinparticular wehave: THEOREM 1 (SubjectReduction). G f t : T and t .\u00df t ' =. G f t ' : T Proof. \nFollows by encoding of F . * as PTS and Thm. 5.2.15 in[3]. Furthermore, sinceF . * contains .* inthe \nsensedescribedabove, weget thefollowing results: THEOREM 2. The kind system of F . * is undecidable. \nAs a logic, it isinconsistent. Proof. Followsfromthe undecidability[23] andinconsistency[8, 12]of the \n.* type system. While the inconsistency result is not relevant for our purpose of using F. * as aprogramming \nlanguage1, the undecidability of the kind(andhence type) systemispotentially a more seriousissue. We \nbelieve that the undecidability is, as in many other undecid\u00adable type systems, not very signi.cant in \npractical programming, sincetheprogramsthatlead tonon-termination of thetypecheck\u00ading algorithm arequite \nesoteric[8].Thisis supported by anecdotal 1It would be interesting, though, to analyze whether the inconsistency \nis con.ned to thekind system or whether itleaksinto the type system F. F * . .* S * * D D * A * : D \n* : D D : D * : * R (*,*,*) (*,*,*) (D,*,*) (D,*,*) (D,D,D) (D,D,D) (*,*,*) Figure5. Comparison ofPTSinstances \n evidencein theform ofthe experiments we made with ourF . * type\u00adchecker implementation, where we never \nencountered theproblem that the typecheckerloops. Let us now discuss the properties of quoting and self \nevalua\u00adtion,inparticular whether they comply to the criteria which we set up in Sec. 2. In the paper, \nwe only provide short proof sketches. A full formalization in Coq using a locally nameless representa\u00adtion \nand corresponding machine-checked proofs are available for download2. 4.1 RepresentationProperty We .rst \nhave to show that our quote transformation is applicable to all well-typed terms. LEMMA 1. For all t, \nT and G which do not contain R, lam, app, tlam or tapp, G f t : T .. .t ' . G f t : T C t ' . ' ' Proof.Assumet \nexists sothat G f t: T C t ,thentheinference treefor G f t : T C t ' canbe transformed into aninference \ntree for G f t : T by removing allparts notframedinFig.3. Now assumethatG f t: T.Thentheinferencetreeof \nG f t: T canbe extended to aninference treefor G f t : T C t ' for some t ' by .lling in the parts framed \nin Fig. 3, proceeding from top to bottom, since no newpremiseshave tobe added. THEOREM 3 (Existence ofQuoting). \nFor alltand T,where w.l.o.g. R, lam,app,tlam,tapp . t,T, \u00d8f t: T =..t ' . (t)= t ' Proof. Followsbyinspection \nof(QUOTE)andLemma1 F * . allows encoding the family of types ExprT directly as type function Expr as \nshowninFig.1.Wecanprovethat Expr adheres toProp.1inSec.2. LEMMA 2. For all t, T and G which do not contain \nR, lam, app, tlam or tapp, with G ' de.ned as G pre.xed by R:: * . *, lam: TLamR, app : TAppR, tlam : \nTLamR, tapp : TAppR and with each occurrence of t: T replaced by t: RT, ' G '' G f t : T C t =.f t : \nRT. Proof. Follows by induction on the structure of the inference tree of G f t : T C t ' .See theCoqformalizationfordetails. \nTHEOREM 4 (WelltypedQuote). For all t and T, \u00d8f t: T .(t)= t ' =. \u00d8f t ' : ExprT Proof. Followsbyinspection \nof(QUOTE)andLemma2 2http://www.daimi.au.dk/~ rendel/metacircular  4.2 AdequacyProperty While we do not \nhave a formal proof of adequacy yet, we believe that the self-representation presented in this paper \nis weakly ade\u00adquate in the sense of Prop. 2 on the ground of the following argu\u00adment. Inspection of the \ntyping rules in Fig. 2 shows that every nor\u00admalizing, closed term of type ExprT for some T must have \nbeen ultimatelybuiltby .and . abstractions of theform .R:: * . * . .lam: LamR. .app : AppR. .tlam : TLamR. \n.tapp: TAppR. body for some term body with R:: * . *,lam: TLamR,app : TAppR, tlam : TLamR,tapp : TAppR \nf body: RA. SinceR is entirely abstractin body, the result of type RA must havebeenproducedbyapplications \nofthefunctions lam, app, tlam and tapp,due to relationalparametricity. 4.3 First-ClassInterpretationProperty \nF * . allows encoding an interpretation with respect to some repre\u00adsentation typefunction Rdirectly as \na term of type .A: D . ExprA . RA. See eval inFig.4for an example of such a term. 4.4 SelfInterpretationProperty \nWe can prove that evalTt ' is observational equivalent to t if t has type T and (t)= t ' . In fact, evalTt \n' is even \u00df-equivalent to t, which means that there is a potential for partial evaluation that might \nallow self-interpretation to be done without the order-of\u00admagnitude slowdowninperformancethatis usually \nassociated with it. LEMMA 3. For all t, T and G which do not contain R, lam, app, tlam or tapp, G f t \n: T C t ' =. t = \u00df eval Tt ' Proof. Follows by induction on the structure of the inference tree of G \nf t : T C t ' .See theCoqformalizationfordetails. THEOREM 5. For all t and T, \u00d8f t : T/(t)= t ' =. t \n= \u00df eval Tt ' Proof. Followsbyinspection of(QUOTE)andLemma3  4.5 Re.ectionProperty Thispropertydemands \nthatother, non-trivialinterpretationbesides standard evaluation must be possible. To this end, Figure \n6 illus\u00adtrateshow aninterpretation that measures the size of a term canbe expressed.Ourlanguagedoes not \nsupport natural numbersdirectly, butwe assume that a standardChurch encoding of natural numbers is used. \nUnfortunately, a closer look at the de.nition of ctlam reveals a signi.cant problem: It is not quite \nclear which type argument to supply to f. It is obvious that the type argument has no signif\u00adicance, \nsince the type function .X :: T1 . Nat is constant func\u00adtion. But still, we have to supply one. In the \n.gure, we have used a constant .::(.S :: D . S)which can easilybe added to thelan\u00adguage.Another solutionisto \naddsyntaxfor coercing aterm oftype .X :: T1 . T2 to T2 if T1 is not free in T2. Both of these solutions \nwork.neforany constant representationfunction.Thismeans,that we can atleastde.ne re.ectiveinterpretationsinto \nan untyped do\u00admain.However, the solutions are still somewhat unsatisfactory.We will revisit thisprobleminSec.6. \nINTR =.T:: * . Nat capp =.T1 :: * . .T2 :: * . .f : Nat. .x : Nat. f + x + 1 clam =.T1 :: * . .T2 :: \n* . .f : Nat . Nat.(f0)+1 ctapp =.T1 :: D . .T2 ::(T1 . *). .f : Nat. .X:: T1 . f + 1 ctlam =.T1 :: D \n. .T2 ::(T1 . *). .f :(.X:: T1 . Nat). f[.T1 ]+1 ceval : .A:: * . ExprA . Nat ceval =.A:: * . .e : ExprA. \ne INTR capp clam ctapp ctlam Figure6. Interpreter whichmeasures the size of a term  4.6 CoqFormalization \nWe have formalized F . * intheCoq theoremprover[5] using alo\u00adcally namelessrepresentationasproposedbyAydemir \netal.[2]. The representation uses de Bruijn indices to represent bound vari\u00adables and atoms withdecidable \nequality to representfree variables. This allows easyreasoning upto aequivalence,infact,term equal\u00adity \nis a equivalence. However, a number of technicallemmashave to be formulated and proved which connect \nthe various forms of substitutionforfree andforbound variables.Unfortunately, the ap\u00adproach described \nby Aydemir et al. seems not to scale well in the number of syntactic categories.Even with only two syntactic \ncate\u00adgories as for F.*, we need up to .ve versions for some of the lem\u00admas opposed to only one version \nin the case of a single syntactic category. This explosion of technical proof obligations somewhat overshadows \nour experience withCoq and thelocally nameless ap\u00adproach. We have formalized the typing, kinding and \nquoting relation, and proved Lemmas 2 and 3 and Theorems 4 and 5 as stated in Sec.4.Inourongoing work \naboutthistopic,weplantoformalize our proof sketch from Sec. 4.5. It would be also interesting to formalize \nthe embedding into thePTSframework. 5. LanguageIntegration The obvious application of our quoting mechanism \nis to integrate it into the programming language itself, which in turn enables a lot of applications \nwell-known from untyped re.ective languages. The application we are mostinterestedinis a polymorphic \nembed\u00adding [16]of the host language, meaning that programs written in the language can be given a non-standard \nmeaning by enabling a parameterization with the desired denotation of the language con\u00adstructs. The main \nconceptual challenge inintegrating thequote mecha\u00adnism into the language is the change of environment \nas described in Thm. 4, or, equivalently, the question of how to deal with free variablesinquoted terms. \nWhile the exact wayhow aquotefunctionisintegratedinto the languageis notin the scope(andpagelimit)of \nthispaper, we want to sketch different wayshow typed self-representation canbe used to this end. Hence \nwe assume that the syntax of our language is extended with terms of theform quotet. 5.1 StaticQuoting \nOne way ofinterpretingquotingisby a transformationduring type checking.The easiest(but most restricted) \nway ofdealing withfree variablesisto allow onlyquoting of closedterms.Hence thetyping ruleforquoted termsis: \n\u00d8f t : T \u00d8f quotet : ExprT  The quotes can simply be compiled away by a syntax-directed transformationduring \ntype checking,i.e., quotet is transformedto (t). Ifwe wanttoallowfree variables withinquotedterms,theyhave \ntobeliftedfrom atype Ato atype RA.One waytodothisisletting the programmer specify their lift functionby \nmakingitpart of the language interface. For example, for a self-interpreter, where R is theidentityfunction,theliftfunction \ncouldbetheidentityfunction. For the interpreter in Fig. 6 the lift function could be the function returning \nzerofor allinputs. In order to allow this, one could extend the language interface by a lift function \nof type Lift = .R:: * . .A:: * . A . RA, which lets the programmer control how external terms are lifted \ninto the respective representation. The language interface compo\u00adnent Expr hencebecomes Expr = ... . \nTLamR . LiftR . RA. To this end, thede.nition ofquoting inFig.3 must be changed suchthatthequote of every \noccurrence of a variable x thatisbound outside the quote is liftx. Occurrences of variables bound inside \nthequote caneasilybedistinguishedfromthosebound outsideby splitting the environment into two parts one \nfor the externally bound variables, and onefor theinternal ones.  5.2 DynamicQuoting Another interesting, \nbut more speculative possibility would be to performthequotetransformationduringreduction.This meansthat \nfree variables in the term to be quoted may have been substituted with other terms during reduction before \nthe actualquote transfor\u00admation takes place. This implies that the result of the transforma\u00adtiondepends \nonthe reduction strategy(call-by-value, call-by-name etc.). This will make the result of quoting harder \nto predict. On the otherhand,dynamicquoting enables exciting newpossibilities, such as a propagating \nquote: Assuming that we have a .xed-point operator \u00b5,and aregiven a representation Randinterpretationfunc\u00adtions \nlam, app, tlam, and tapp, we could then write aliftfunction such as \u00b5lift: LiftR. .A:: * . .x : A . (quotex)Rlamapptlamtapplift \nwhich would transitively quote every term that is bound outside the currentquote andinterpretit with \nthegiveninterpretation.The exactdesign ofdynamicquoting and an evaluation ofitspractical utilityispart \nof ourfuture work. 6. Discussion We can now re.ect on the design decisions that we have made on the way.This \nwilllead to theidenti.cation of a number of areas of future work. First, we will discuss the most important \ndesign choices we have made in our implementation: the choice of language, the representation of terms, \nand of variables.Then, we willdiscuss the problems arisingfrom theintegration ofexternallyde.ned terms. \n 6.1 ThechoiceofF . * Pfenning/Lee[21]havebeenthe .rsttoexploremetacircularityin the context of staticallytypedfunctionallanguages,inparticular,in \nextensions ofSystemF. Theyare able to represent terms ofF2 inF3, and terms ofF. in F+ ..Thelatteris their \nextension ofF. withkind variables andkind polymorphism on terms.Theyclaim thatitis strongly normalizing \nand type-checking isdecidable. However, they do not achieve metacircularity, missing Prop. 1. As we \nwilldiscussbelow, theyfurthermoredo not achieveProp.5. In order to embed F+ ., they would need a language \nthat allows for the representation of kind abstraction and kind application, which would require a notion \nof sorts. By fusing the categories of types and kinds, we are able to evade this problem and achieve \nfull metacircularity, for the price of losing strong normalization and decidable type-checking. Carette \net al.[7](in thejournal version) attempt to write a self\u00adinterpreter without drawing on higher-rank and \nhigher-kind poly\u00admorphism. Instead they use a simply-typed lambda calculus ex\u00adtended with let-bound polymorphism. \nHowever, they cannot de\u00ad.ne a transformation quote that returns a term in their language. They can only \nspecify a pre-encoding that contains free variables and has to be put in the context of an evaluator \nin order to build a closed term. Therefore, it is impossible to type-check a term separately(Prop.1).Accordingly,itisimpossible \ntotalk of ade\u00adquacy(Prop.2).Furthermore,interpretations cantherefore notbe regardedas .rst-classcitizens(Prop.3).InthesenseofProp.4, \nhowever, they de.ne a self interpretation, and their representation allowsfor non-standardinterpretationsinthe \nsense ofthe re.ection property(Prop.5). Another conceivable choice of language would be to use .* rather \nthan F .* . However, it is not obvious whether and how typed self-representation in .* is possible. The \nmain problem in .* is that terms have exactly the same structure as types, and hence terms like * or \n.x: T. T ' must also be represented. An\u00adother problem is the fact that types may depend on terms. In\u00adtuitively, \nit is not clear how to abstract over the interpretation of a term, if the type of the term depend on \na .xed interpreta\u00adtion of the term. For example, to consider types that depend on terms, the App type, \nwhich(omitting theboilerplatedeclarations) is R(A . B). RA . RB in F . * (see Fig. 1) would have to become \nsomething like R(.t: A. Bt). .t ' : RA. X in .* but then it is not clear which reasonable type to .ll \nin for the X placeholder. 6.2 RepresentationofTerms Our representation of terms contains severaldesign \ndecisions. Our basicdecisionistofollowPfenning/Lee[21] in not representing types explicitly, but mapping \nthem to types in the meta-language. This automatically precludes the construction of non-welltyped terms. \nHowever, as a consequence, the representation of variables also has to be delegated to the meta-language. \nTherefore, we like\u00adwise usehigher-order abstract syntax(HOAS). The central difference toPfenning/Lee[21]is \ninhow we em\u00adbed object language terms into the meta-language without an ex\u00adplicitnotion ofdatatypes.The \nconceptof representingtermswithin lambda calculi goes back to Church s numerals and booleans. B\u00a8ohm/ \nBerarducci[6] .rstde.ned arepresentationinthetyped setting ofSystemF. Pfenning / Paulin-Mohring [22] \nhave extended this approach to allow Church encodings for inductive de.nitions ofgeneralized abstract \ndata types(GADTs),i.e. data types whose(polymorphic) constructors are non-uniform in their type variables, \nwithin F.. Pfenning / Lee [21] apply this approach to their embeddings of SystemFtermsinF3 and ofF. termsinF+ \n. . However, this representation onlyworksforinductivelyde.ned datatypes.Inparticular,thedatatype mustnot \nappearin a negative position ofa constructor.In our representation, lam has type .R:: * . * . .A:: * \n. .B:: * .(RA . RB). R(A . B),  and RA appearsin negativeposition.Pfenning/ Lee[21] instead propose \na solution, wherelam has type3 which strongly restricts the range of de.nable interpretations to basically \nonly thestandardinterpretation[21,p.150].Besidesnot beingmetacircular,their approachtherefore cannot \nsatisfyproperty 5 of a typed self-representation(seeSec.2). The representation of terms that we have \nchosen has been in\u00adspiredbyCarette et al.[7], whodevelopeditinthe context of a simply typed lambda calculus. \nIn this setting, the representation allows for implementing simple alternative semantics, like count\u00ading \nthe number of terms.Wehavede.ned a straightforward exten\u00adsion of their representation to type abstraction \nand application. In Sec.3.3 wediscussed thelimitation of this extension: If the repre\u00adsentation is a \nconstant function, then we have the problem that no appropriate typeparameter is availablein the TLam \ncase.Wehave discussed twodifferent solutions to thisproblem and can conclude thatinthe case of non-polymorphic \nrepresentations,these solutions are suf.cient. However, one could argue that our solutions are somewhat \nad hoc since theydo not address the real cause of theproblem, which lies in the design of the language \ninterface itself: Each tlam gets domain S and codomain T and a parametric function f as apa\u00adrameter.Depending \non the type R(.X:: S. TX),ithaspotentially three options.Firstly,ifthereis a closed termthatinhabitsthetype, \nit can returnthisterm(in our case,it could returntheChurch en\u00adcoding of a constant number).Secondly,if \nthe typeis \u00df-equivalent to a type .X:: S. R(TX),it can simply return f.The only alterna\u00adtive option to \nmake use of f, which is the only available term, was to supply atype X:: S.However, as Scanbe anykind,this \ncan only be a type .S. Hence we conclude that our current representation is not verygood at representing \ntype abstraction.  6.3 Accessing theintensional structureofprograms However, the representation of type \nabstraction is just one issue in a wider context of questions related to type-safe program rep\u00adresentations.Ageneral \nchallengeforthe expressivity of eachkind of representation is the degree of access to the intensional \nstruc\u00adture ofprograms [21,p.156].Carette et al.[7] recognize thattheir U = .X:: D . X . (X . X . X). \nX Num = .X:: D . .N:: X. .Ar:: X . X . X. N Arrow = .A:: U. .B:: U. .X:: D . .N:: X. .Ar: X . X . X. \nAr(ANAr)(BNAr) NumR = .R:: (U . *). Nat . RNum App = .R:: (U . *). .S:: U. .T:: U. R(Arrow ST). RS . \nRT Lam = .R:: (U . *). .S:: U. .T:: U. (RS . RT). R(Arrow ST) Expr = .A:: * . .R:: (U . *). NumR R . \nAppR . LamR . RA Figure7. Embedding ofSTLC using type-indexed types Reval = .X:: U. X* Nat(.A:: * . \n.B:: * . A . B) inteval = .x : Nat. x appeval = .A:: U. lambdaB: U. .f :(RevalA). (RevalB). .x :(RevalA). \nfx lameval = .A:: U. .B: U. .f :(RevalA). (RevalB). f eval = .A:: U. .e : ExprA. e[Reval ]inteval appeval \nlameval issimilartotheonegiveninFig.1. . Figure8. An evaluator using type-indexed types Everyinterpretationhastode.ne \nadecodingfunctionR:: U . * on types that re.ectsthe types of theproduced values.We callit R, as its role \nis similar to the type constructor in our representation. Accordingly, the language interface NumR, App, \nLam, and Expr The code for the evaluator is shown in Fig. 8. The decoding functionforthe evaluator Reval \nrepresents numbersby the type Nat and arrowsby ..The codeforthe call-by-nameCPSinterpreteris shown in \nFig. 9. Its decoding function Rcps is more complex. R ' cps re.ectsthat numbers and arrowshave tobe \nrepresenteddifferently. These examples demonstrate that very expressive interpreta\u00adtions canbe encoded \nusingthe samelanguageinterfaceinthisstyle. Inthefuture, we wantto analyzehowthis approach canbegeneral\u00adizedtothefullself-embeddingofF \n* by.ndingan encodingthat en\u00ad compasses the representation of universal quanti.cation. It should representation \nis too limited in this regard, as they cannot de.ne be noted, however, that this is still concerned with \nthe representa\u00adtypefunctions whichdestruct orinspecttheir argument.Inthis rep\u00adtionof termsand .nding \nanappropriatemappingforthetypesthat resentation, they cannot express a partial evaluation or a transfor\u00adre.ectsthis \nrepresentation.Therefore, wedo not require a represen\u00admation to continuation-passing style(CPS).To overcome \nthis,they tation ofdependentkinds, asthey are not containedinthelanguage propose an ad-hoc solution involving \nadding an additional type ar\u00adinterface.Furthermore,theinterpretationsthemselves stillarepara\u00adgument toRfor \neverydifferent typefunction whichis tobeimple\u00admetric.For example,theinterpretation of lamcannotdepend \nonthe mented. However, this means that adding a new interpretation to type of the function s parameter. \nThis is, because interpretations thelanguage potentially necessitates a rede.nition of thelanguage interface. \nThis non-modularity strongly suggests the search for a better solution. ** areordinaryF terms,andF . \n. tions.Aspart of ourfuture work, we also want to considerde.ning does not support type-indexed func\u00ad \nan explicit representation of types by terms. This would imply the * However,inF . disposal.We can therefore \novercome thislimitationby using type\u00adindexed types[15].Todemonstratethis capability, wehave sofar we \nhave a very expressive type system at our possibilityofde.ning type-indexed functions.  6.4 Representation \nof variables developed an embedding of the simply typedlambda calculus with * natural numbersintoF . \nname continuationpassing styleinterpreter(thelatteris modeled after the corresponding interpreter in \n[7]). To this aim, we con\u00adstructed a simply typed universe as in[1], with a constructor Num for representing \nthe base type Nat, and a constructor Arrow for representingfunctiontypes.However,wehad to .nd away torep\u00adresenttypecasing[14].We \nused a simpleChurch encoding of the types in the universe, de.ning the universe U and the constructors \nNum and Arrow asinFig.7. 3Where p corresponds roughly to our Expr. , and de.ned an evaluator and a call-by-Representation \nof variables, both bound and free, can be seen as the main challenge in typed self representation. We \nalready dis\u00adcussed theissue offree variablesinSec.5.There, theproblem has been described as one of lifting \nexternal terms into the respective interpretation using a static or dynamic quoting approach. While bound \nand free variables may be represented differently in some representations, they are always closely related, \nbecause an open term canbe closedby addinglambdabinders aroundit.That means that even a typed self-representation \nwhich restrictsitself to closed terms should account for free variables, since they naturally occur during \nconstruction of closed terms. Rcps = .X:: U. Ct(Rcps ' X) R ' cps = .X:: U. X* Nat(.A:: * . .B:: * . \nCtA . CtB) Ct = .A:: * . .W:: * .(A . W). W intcps = .x : Nat. .W: * . .k:(Nat . W). kx appcps = .A:: \nU. .B: U. .f : Rcps(ArrowAB). .x : RcpsA. .W:: * . .k:((R ' B). W). cpsfW(.g:((RcpsA). (RcpsB)). gx[W]k) \nlamcps = .A:: U. .B:: U. .f :(RcpsA . RcpsB). .W:: * . .k:((RcpsA . RcpsB). W). kf cps = .A:: U. .e : \nExprA. e [Rcps]intcps appcps lamcps Figure 9. A call-by-name CPS interpreter using type-indexed types \nInthetradition ofPfenning/Lee[21] andCarette et al.[7], we have chosen to use HOAS to represent variables \nof the embedded language as variables of the host language. But there is an impor\u00adtant difference between \ntheir approaches regarding the type of the variables.Pfenning/Lee[21] represent embedded variables of \ntype Abyhost variables of type A, whileCarette et al.[7] usehost vari\u00adables of type RA.Pfenning andLee \ns approach allow them to rep\u00adresent terms withfree variables similartohow they represent terms withbound \nvariables.A term of type A with afree variable of type Bcanbe represented as A . pB.Indeed, their constructor \nlamfor representing lambda abstraction can also be used to wrap a term with afree variablein alambdabinder \ntobindit,independently of the semantics. However, as wehave alreadydiscussed in theprevious section, \nthis representation of variables does not allow for interesting se\u00admantics, since the values of all variables \nhave to be given in the hostlanguage semantics, not some embedded semantics. Tohavemore .exiblevariables,which \nvaluescanbeexpressed accordingtothe embedded semantics,Carette et al.[7] useterms of type (RA . RB)to \nrepresent bound variables. While this allows interestingsemantics, the authorsdo notpresent an analogue \nto the lam function above and do not discuss the representation of free variables. Naively, one wouldlike \nto represent terms of type Bwith afree variable oftype Aas ExprA . ExprB.Consider, wehad adatatype of \nterms containing a free variable that is constructed from this function type. In order to work with such \nterms, we had to .nd a waytodecompose them.Itis wellknownthat one can notgenerally decomposedatatypes \nwhichcontainfunctiontypes(likethetype of lam).Fortunately, we canfurther restrict the type offunctions \nthat are allowedtobe usedto representterms withfree variables:Aterm should not be allowed to have access \nto the internals of the repre\u00adsentation of the variable. This corresponds to the requirement that thefunctionhastobeparametric.Fegaras/Sheard[11]have \nshown that terms constructed from those functions can be decomposed. Recently,Washburn/Weirich[30]proposeda \nrepresentation ofthe untyped lambda calculus into the F. fragment of Haskell that al\u00adlows for a binding \noperation of type (Expr . Expr). Expr, and stillis able to apply the technique of[11].The authorsbelieve \nthat this approach can be adapted to the typed self-representation de\u00adscribedin this work.  6.5 FurtherApproaches \n20 years ago Hagiya [13] presented a very innovative approach to writing a meta-circular interpreter \nin the setting of typed lan\u00adguages.Itisbasedon a variant ofthelambda calculus withBoolean and integer \nconstants and symbols (variable constants), let bind\u00adings,if expressions, errorsand casts.Thelanguagehastypeanno\u00adtations, \nin particular for functions and .xed-point operations. It is adependently-typed system, and types are \nconsideredjust normal values.Thebase evaluatoris untyped.Aquote operationisde.ned in the style ofquotinginLisp,giving \na term of type exp. A meta-circular interpreter evaluates each quoted term to a dependent pair of its \ntype and its value. It therefore works both as an evaluator and a type-checker. In this way, well-typedness \nfor the meta-circularinterpreteris shown,by runningit on top ofitself. Thelanguage canbe rede.ned or \nextendedby modifying the meta\u00adcircular interpreter. This new version can be run on top of the old version, \nasin the originalideas about re.ection(e.g.,[26]).Thisis certainly a great result, however it comes with \nits own problems. The phase distinction between evaluation and type-checking is abolished.Some normalization \ntakesplace underbinders to ensure well-typedness.In this way, type-checking is not only undecidable from \na theoretical point of view, but it is also clear that it has only limited applicability in practice. \nStill, there is no indication that type-checking is sound. It is not clear, how well-typedness of termscanbe \nestablishedinthisdependently-typed systemwithout a complete evaluation.Wewouldtherefore consideritmore \nrelatedto systems of untyped self-representation. Seen from the perspective of our properties of a typed \nself-representation, Prop. 1 is not ful.lled:each representation of a termis of type exp.Accordingly, \nProp.2andProp.3 are not applicable.Prop.4isful.lled, as a meta\u00adcircularinterpreterisgiven.Thekind of \nrepresentationallowsfull access to the structure of the code,guaranteeingProp.5. Another early approach \nof implementing re.ection in the con\u00adtextof typedlanguagesisfromL\u00a8aufer/Odersky[17].They write a meta-interpreter \nfor typed terms of the SK calculus in Haskell, together with a rei.cation mechanism that lifts natural \nnumbers to theirrepresentations,and are.ectionmechanismthatevaluates rep\u00adresented expressions to values.Although \naninteresting resultinit\u00adself,itdoes not create a self-representation of theSK calculus,but a representation \nofSK termsinHaskell. Our idea of propagating dynamic quoting is similar to the idea of MapClosure [25]. \nApart from the fact that MapClosure is not statically safe, an operationaldifferenceis thatMapClosure \nallows changing themeaning ofbindingsintheenvironment, whereaswe allow changing the meaning of thelanguageprimitives. \nNanevski [19] proposes a language with explicit distinction of free and bound variables, and corresponding \ndistinct abstrac\u00adtion mechanisms. In contrast to this work, Nanevski s encoding is not metacircular, \nbut it would be interesting to check whether Nanevski s ideas could be transferred to our setting to \naddress the representation of free variables. Nanevski provides pattern match\u00adingforintensionalcode analysis.However,thelack \nofpolymorphic patterns precludes operations which work for terms of arbitrary types.Itseemstherefore \nnottobepossibletoimplementinteresting non-standard interpretations like size measurement in Nanevski \ns system. 7. Conclusion Achievingatyped self-representation ofprogramsisalongstanding goalinprogramminglanguagedevelopment.Wehave \nanalyzedthe dif.culties associated with its accomplishment and have seen that F. and related languages \nare probably not suf.cient for achiev\u00ading this goal. To remedy the problem, we have proposed a new language, \nF .* , which is the .rst language that allows typed self\u00adrepresentation.Wehave analyzed the metatheoreticalproperties \nof F * . and have established the main technical results in a mechani\u00adcally checkedproof.However, wehave \nalso seenthat our approach to representing programs is not satisfactory with respect to repre\u00adsentingtype \nabstraction and application,hence ourfuture work will concentrate onbetter representations of the type \nstructure of terms. Acknowledgments The authors would like to thank Thomas Streicher and the anony\u00admous \nreviewers for their insightful suggestions that helped to im\u00adprove the paper. Tillmann Rendel and Christian \nHofer are sup\u00adported by the ScalPL project of the European Research Commis\u00adsion. References [1] T. Altenkirch \nand C. McBride. Generic programming within dependently typed programming. In Proceedings of the IFIP \nTC2/WG2.1 Working Conference on Generic Programming, pages1 20.Kluwer,B.V.,2003. [2] B.Aydemir,A.Chargu\u00b4eraud,B.C. \nPierce,R.Pollack, and S. Weirich. Engineering formal metatheory. In POPL 08, pages3 15,NewYork,NY,USA,2008.ACM. \n[3] H. P. Barendregt. Lambda calculi with types. In Handbook of logic in computer science (vol. 2): background: \ncompu\u00adtational structures, pages 117 309. Oxford University Press, 1992. [4] S.Berardi. Towards a mathematical \nanalysis of theCoquand-Huetcalculus of constructions andthe other systemsinBaren\u00addregt s cube. Technical \nreport, Department of Computer Sci\u00adence, Carnegie-Mellon University and Dipartimento Matem\u00adatica,UniversitadiTorino,1988. \n[5] Y.Bertot andP.Cast\u00b4eran. Interactive Theorem Proving and Program Development, Coq Art:The Calculus \nof Inductive Constructions. Springer-Verlag,2004. [6] C.B\u00a8ohmandA.Berarducci. Automaticsynthesisoftyped \nlambda-programs on term algebras. Theor. Comput. Sci., 39:135 154, 1985. [7] J.Carette,O.Kiselyov, andC.Shan. \nFinallytagless,partially evaluated. In APLAS 07, extended version to appear in Jour\u00adnal of Functional \nProgramming, pages 222 238. Springer LNCS4807,2007. [8] T. Coquand. An analysis of Girard s paradox. \nIn In Sym\u00adposium on Logic in Computer Science, pages 227 236. IEEE ComputerSocietyPress,1986. [9] R.DaviesandF.Pfenning. \nA modal analysisof staged com\u00adputation. J.ACM,48(3):555 604, 2001. [10] N. G. de Bruijn. Lambda calculus \nnotation with nameless dummies. a toolfor automaticformula manipulation with ap\u00adplication to the church-rosser \ntheorem. Indagationes Mathe\u00admaticae,34:381 392, 1972. [11] L. Fegaras and T. Sheard. Revisiting catamorphisms \nover datatypes with embeddedfunctions(or,programsfrom outer space). In POPL 96,pages284 294. ACM,1996. \n[12] J. Y. Girard. Interpr\u00b4etation fonctionelle et \u00b4elimination des coupuresdel arithm\u00b4etiqued ordre \nsup\u00b4erieur. Th\u00b4esededoc\u00adtoratdetat,Universit\u00b4edeParisVII,1972. [13] M. Hagiya. Meta-circular interpreter \nfor a strongly typed language. J.Symb.Comput.,8(6):651 680, 1989. [14] R. Harper and G. Morrisett. Compiling \npolymorphism using intensionaltype analysis.InPOPL 95,pages130 141.ACM, 1995. [15] R.Hinze,J.Jeuring,andA.L\u00a8oh. \nType-indexeddatatypes. Sci.Comput.Program.,51(1-2):117 151, 2004. [16] C.Hofer,K.Ostermann,T.Rendel,andA.Moors. \nPolymor\u00adphic embedding ofDSLs. In GPCE 08.ACM,2008. [17] K.L\u00a8aufer andM.Odersky. Self-interpretationand \nre.ection in a staticallytypedlanguage. InProc.OOPSLAWorkshop on Re.ection and MetalevelArchitectures.ACM,Oct.1993. \n[18] J. McCarthy. Recursive functions of symbolic expressions and their computation by machine, part \ni. Commun. ACM, 3(4):184 195, 1960. [19] A. Nanevski. Meta-programming with names and necessity. In ICFP,pages206 \n217, 2002. [20] F. Pfenning and C. Elliot. Higher-order abstract syntax. In PLDI 88,pages199 208. ACM,1988. \n[21] F. Pfenning and P. Lee. Metacircularity in the polymorphic .-calculus. Theoretical Computer Science, \n89(1):137 159, 1991. [22] F.PfenningandC.Paulin-Mohring. Inductivelyde.ned types in the calculus of constructions. \nIn Proceedings of the5thIn\u00adternationalConference onMathematicalFoundations ofPro\u00adgramming Semantics,pages209 \n228. Springer-Verlag,1990. [23] M.B.Reinhold.Typecheckingisundecidablewhen type is a type. Technical \nreport, Massachusetts Institute of Technol\u00adogy,1989. [24] J.C.Reynolds. De.nitionalinterpretersforhigher-orderpro\u00adgramming \nlanguages. In ACM 72: Proceedings of the ACM annual conference,pages717 740. ACM,1972. [25] J. M. Siskind \nand B. A. Pearlmutter. First-class nonstandard interpretations by opening closures. In POPL 07,pages \n71 76.ACM,2007. [26] B.C.Smith. Re.ection and semanticsinLISP. In POPL 84, pages23 35.ACM,1984. [27] \nG. L. Steele. Growing a language. Higher-Order and Sym\u00adbolicComputation,12(3):221 236, 1999. [28] W. \nTaha, Z. Benaissa, and T. Sheard. Multi-stage program\u00adming: Axiomatization and type-safety. In In 25th \nInterna\u00adtional Colloquium on Automata, Languages, and Program\u00adming,pages918 929. Springer-Verlag,1998. \n[29] J. Terlouw. Een nadere bewijstheoretische analyse van GSTT s. Technical report,Department ofComputer \nScience, CatholicUniversity,Nijmegen,TheNetherlands,1989. [30] G. Washburn and S. Weirich. Boxes go bananas: \nEncoding higher-order abstract syntax withparametricpolymorphism*. J.Funct.Program.,18(1):87 140, 2008. \n   \n\t\t\t", "proc_id": "1542476", "abstract": "<p>Self-representation -- the ability to represent programs in their own language -- has important applications in reflective languages and many other domains of programming language design. Although approaches to designing typed program representations for sublanguages of some base language have become quite popular recently, the question whether a fully metacircular typed self-representation is possible is still open. This paper makes a big step towards this aim by defining the F<sub>&#969;</sub>* calculus, an extension of the higher-order polymorphic lambda calculus F<sub>&#969;</sub> that allows typed self-representations. While the usability of these representations for metaprogramming is still limited, we believe that our approach makes a significant step towards a new generation of reflective languages that are both safe and efficient.</p>", "authors": [{"name": "Tillmann Rendel", "author_profile_id": "81381610410", "affiliation": "University of Aarhus, Aarhus, Denmark", "person_id": "P1464299", "email_address": "", "orcid_id": ""}, {"name": "Klaus Ostermann", "author_profile_id": "81100028971", "affiliation": "University of Aarhus, Aarhus, Denmark", "person_id": "P1464300", "email_address": "", "orcid_id": ""}, {"name": "Christian Hofer", "author_profile_id": "81326489733", "affiliation": "University of Aarhus, Aarhus, Denmark", "person_id": "P1464301", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542509", "year": "2009", "article_id": "1542509", "conference": "PLDI", "title": "Typed self-representation", "url": "http://dl.acm.org/citation.cfm?id=1542509"}