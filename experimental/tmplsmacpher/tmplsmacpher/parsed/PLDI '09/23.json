{"article_publication_date": "06-15-2009", "fulltext": "\n ErrorPropagation Analysisfor File Systems * Cindy Rubio-Gonz\u00e1lez Haryadi S. Gunawi Ben Liblit Remzi \nH. Arpaci-Dusseau Andrea C. Arpaci-Dusseau Computer Sciences Department, UniversityofWisconsin Madison \n {crubio, haryadi, liblit, remzi, dusseau}@cs.wisc.edu Abstract Unchecked errors are especially pernicious \nin operating system .le management code.Transient or permanent hardwarefailures are inevitable,anderror-managementbugsatthe.le \nsystemlayercan cause silent, unrecoverable data corruption.We propose aninterpro\u00ad cedural static analysisthattracks \nerrors astheypropagate through .le systemcode. Ourimplementationdetectsoverwritten, out-of\u00ad scope, and \nunsaved unchecked errors. Analysis of four widely-used Linux .le system implementations (CIFS, ext3, \nIBM JFSand Rei\u00ad serFS), a relatively new .le system implementation (ext4), and shared virtual .le system \n(VFS)code uncovers 312 error propa\u00adgation bugs. Our .ow-and context-sensitive approach produces more \nprecise results than related techniques while providing bet\u00ad ter diagnostic information,includingpossibleexecutionpaths \nthat demonstrate eachbug found. Categories and Subject Descriptors D.2.4[Software Engineer\u00ading]: Software/ProgramVeri.cation \nformal methods,reliability, validation; D.2.5[Software Engineering]:Testing andDebugging errorhandlingandrecovery; \nD.4.3[Operating Systems]:File Sys\u00ad tems Management General Terms Algorithms, Languages, Reliability,Veri.cation \nKeywords static program analysis,interprocedural data.ow analy\u00ad sis, weighted pushdown systems, copyconstant \npropagation, binary decision diagrams 1. Introduction Run-time errorsare unavoidable wheneversoftwareinteracts \nwith the physical world. Incorrect error handling is a longstanding probleminmanyapplicationdomains,butis \nespecially troubling when it affects operating systems .le management code. File systems occupyadelicatemiddlelayerin \noperatingsystems.They sitabove genericblockstoragedrivers, suchasthose thatimplement SCSI, IDE, orsoftwareRAID; \nor above network driversinthe case * Supportedin partbyAFOSRgrantFA9550-07-1-0210;LLNL contract B580360;NSFgrants \nCCF-0621487,CCF-0701957, andCNS-0720565; and anAAUWInternational Doctoral Fellowship.Anyopinions, .ndings, \nand conclusions or recommendations expressed in this material are those of the authorsanddonot necessarilyre.ecttheviewsofNSForotherinstitutions. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n09, June 15 20, 2009, Dublin, Ireland. Copyright c . 2009ACM 978-1-60558-392-1/09/06... $5.00 of network.lesystems.Theselowerlayers \nultimatelyinteract with the physical world, and as such, may produce both transient and persistent errors.Atthe \nsametime, implementationsof speci.c.le systemssitbelow generic .le managementlayersofthe operating system,whichinturnrelay \ninformationthroughsystem callsinto userapplications.No application can possibly manage errorsthat the \n.le system fails to report. The trustworthiness of the .le system in handling or propagating errors is \nan upper bound on the trustworthiness of all storage-dependent user applications. Furthermore, this problem \ncannot simply be .xed and forgotten. Implementations abound, with more constantly appearing. Linux aloneincludes \ndozensofdifferent.lesystems. Thereisno reasonto believethat .le system designers are running outofideas \nor thatthe technological changesthat motivate new .le systemdevelopment are slowing down. Giventhe destructive \npotentialofbuggy.lesystems,itiscritical thaterrorpropagationpatternsbe carefullyvetted.However,failures \nin the physical layer, while inevitable, are rare enough in daily use that traditional testing is unlikely \nto bear fruit. Therefore, we propose a static analysis to identify certain common classes of error mismanagement. \nOur approach is a .ow-and context\u00adsensitive,interprocedural, forward data.ow analysis.The analysis resembles \nan over-approximating counterpart to a typical (under\u00adapproximating) copyconstantpropagation analysis[31],but \nwith certain additional specializations for our speci.c problem domain. Our analysis is unsound in the \npresence of pointers,but has been designed for a balance of precision and accuracythat is useful to kerneldevelopersinpractice. \nDiagnosticreports include detailed witnesstraces thatillustratethe error-fumblingmisstepsa.lesystem could \ntake. Thekeycontributionsof this paper are as follows: We characterize the error propagation data.ow \nproblem in its various guises (Section 2) and encode these using weighted pushdown systems (WPDSs) (Section \n3). We showhowtoextract detaileddiagnostic error reports from the raw analysis results (Section 4). We \ndescribe a high-performance implementation capable of analyzing real-world .le systems (Section 5). We \nidentify recurring safe and unsafe patterns and offer experi\u00ad mental results for several Linux .le systems \n(Section 5). We considerrelatedworkin Section6, and Section7concludes. 2. Linux Error Management This \npaper focuses on .le systems in the Linux 2.6.27 kernel. Our approach combines generic program analysis \ntechniques with specializationsfor Linux codingidioms.Other operating systems share the same general \nstyle, although some details may differ.  2.1 Integer Error Codes Differentkindsoffailurerequire different \nresponses.Forexample, aninput/output(I/O)error producesan EIO error code,whichmight behandledby abortingafailedtransaction, \nschedulingit for later retry,releasingallocatedbufferstopreventmemoryleaks,andso on. Memoryshortages \nyield the ENOMEM error code, signaling that the systemmustrelease somememoryinordertocontinue.Diskquota \nexhaustion propagates ENOSPC across many.le system routinesto prevent new allocations. Unfortunately, \nLinux(likemanyoperatingsystems)is written in C, which offers no exception handling mechanisms by which \nan errorcode couldberaised orthrown.Errors mustpropagate through conventional mechanisms such asvariable \nassignments andfunction return values. Most Linux run-time errors are represented as simple integer codes. \nEach integer value represents a different kind of error. Macrosgivethese mnemonic names: EIO is de.ned \nas 5, ENOMEM is12,andso on.Linux uses34 basic namederrormacros,de.ned as the constants1through 34. Error \ncodes arenegatedbyconvention, so -EIO maybe assigned to a variable or returned from a function to signal \nan I/O error. Return-valueoverloadingis common.An int-returning function might return the positive count \nof bytes written to disk if a write succeeds,oranegative errorcodeifthewritefails.Callersmust check for \nnegative return values and propagate or handle errors that arise. Remember that error codes are merely \nintegers given special meaning by coding conventions. Any int variable could potentiallyhold an errorcode,andtheCtypesystemofferslittle \nhelp determining which variables actually carry errors. 2.2 Consequences of Not Handling Errors Ideally, \nan error codearisesinlowerlayers (such as blockdevice drivers) and propagates upward through the .le \nsystem, passing fromvariabletovariableandfrom calleetocaller, untilitisproperly handled orescapes into \nuserspace as an error resultfromasystem call. Propagation chains can be long, crossing many functions, \nmodules, and software layers. If buggy code breaks this chain, higher layers receive incorrect information \nabout the outcomes of .le operations. Forexample,ifthereisanI/O errordeepdowninthesync() path,but the \nEIO error codeis lostinthemiddle,thentheapplication willbelieveitsattemptto synchronizewiththe storagesystemhas \nsucceeded, wheninfactitfailed.Anyrecoveryroutineimplemented in upperlayers willnotbeexecuted. Silent \nerrors such as thisare dif.culttodebug,andbythetimetheybecomevisible,datamay already be irreparably corrupted \nor destroyed. Inthis paper,weareinterestedinhow.lesystemspropagateand handle those error codes passed \nup from device drivers.  2.3 CheckedVersus Unchecked Errors Some action shouldbetakenwheneveran error \noccurs.Actions rangefromsimplenoti.cationtoattempted recovery.Wesaythat an error has been checked if \nsuch an action has taken place. There is no requirement to clear or reset an error-carrying variable \nafter that error has been checked and handled. Once recovery code has dealt with the problem, a variable \nthat contained -EIO to report an I/O error can now be seen as merely containing the integer value -5.Overwriting \nsuchavariablebeforeitwas checkedisa bug,butoverwritingitafterit has been checkedis .ne.Forthis reason, \nit is useful to distinguish unchecked error codes from other values that might either be already-checked \nerrors or ordinary (non\u00ad error-bearing) integers. Thisinturn requires recognizing correct error handling \nwhenit does occur.Recognizing error-handlingcode is nontrivial, given the complexity and variety of error \nrecovery policiesinmodern.lesystems.For purposesofthisanalysis,we 1 int status = write(...); 2 if (status \n< 0) { 3 printk(\"write failed: %d\\n\", status); 4 // perform recovery procedures 5 } else { 6 // write \nsucceeded 7 } 8 // no unchecked error at this point Figure 1. Typical error-checking code example adopt \na simple de.nition of correct handling that works well in manycases, and that can be extended easily \nas necessary. Figure1showsatypicalfragmentof Linuxkernel code.Many error-handling routines call printk, \nan error-logging function, with the error code being handled passed as an argument. Because this is an \nexplicit action, it is reasonable to assume that the program\u00ad merisawareof the error andis handlingitappropriately. \nThus,if status containedan unchecked errorinline2,we can assume that it contains a checked error in line \n3. Because error codes are passed as negativeintegers(such as -EIO for -5), sign-checking such as thatinline2iscommon.If \nthe conditionisfalse,then status mustbe non-negative and therefore cannot contain an error code in line \n6. When paths merge in line 8, status cannot possibly contain an unchecked error. Therefore, thereis \nno error propagationbugin this code. Passing error codestoprintk is common,but not universal. Code may \ncheck for and handle errors silently, or may use printk towarn abouta problem that hasbeen detectedbut \nnotyetremedied. More accurate recognition of error-checking code may require annotation.Forexample, wemightrequirethat \nprogrammers assign a special ECHECKED valuetovariableswith checkederrors,orpass suchvariablesas argumentstoa \nspecial checked functionto mark them as handled.Requiringexplicit programmer actiontomark errors as checkedwouldimprovediagnosisbyavoiding \nthe silent propagationfailures that presently occur.  2.4 Error Propagation Bugs Our goalisto .nd those \nerrorinstancesthatvanishbefore proper checking is performed. We .nd three general cases in which unchecked \nerrors are commonly lost. The variable holding the unchecked errorvalue(1)isoverwritten witha newvalue,(2) \ngoes outof scope, or(3)is returnedbya functionbut not savedby the caller. Real-world code examples for \neach of these follow. Figure 2(a) illustrates an overwritten error in ext2. Function ext2_sync_inode, \ncalledin line3, can return oneof several errorsincluding ENOSPC. The codeinsidetheif statementin line4 \nhandlesallerrorsbut ENOSPC. Thus,if ENOSPC is returnedthenit is overwritten in line 8. This may lead \nto silent data loss. Figure 2(b) depicts an out-of-scope error found in IBM JFS. txCommit, startingin \nline1, commits anychangesthatits caller hasmade.This functionreturns EROFS if the .le system is read\u00adonly. \ntxCommit also may propagate EIO from calling diWrite in line 9. diFree calls txCommit in line 17, saving \nthe return valuein variable rc.Unfortunately, diFree does not check rc when the function exits. In fact, \ndiFree always returns 0 in line19, therebyclaiming thatthe commitoperationalways succeeds. Interestingly, \nall other callers of txCommit save and propagate the return value correctly. This strongly suggests that \nrc should be returned, and that the code as it stands is incorrect. Figure 2(c) shows an unsaved error \nfound in ext3. Function log_wait_commit returns EIO if a transaction commit has failed(lines 5 7). In \na synchronous operation, thisEIO error code is correctlypropagatedtothe userapplication.In additionto \nsyn\u00ad chronous foreground I/O operations, there are also background I/O  1 int txCommit(...) { 2 ... \n3 if (isReadOnly(...)) { 1 int log_wait_commit(...) { 4 rc = -EROFS; 2 ... 5 ... 3 wake_up(); 1 int ext2_xattr_set2(...) \n{ 2 ... 3 error = ext2_sync_inode(...); 4 if (error &#38;&#38; error != -ENOSPC) { 5 ... 6 goto cleanup; \n7 } 8 error = 0; //overwriting error 9 } 6 7 8 9 10 11 12 13 14 15 goto TheEnd; } ... if (rc = diWrite(...)) \ntxAbort(...); TheEnd: return rc; } int diFree(...) { 4 ... 5 if (is_journal_aborted(journal))) 6 err \n= -EIO; 7 return err; 8 } 9 } 10 11 int __process_buffer(...) { 12 ... 13 log_start_commit(journal, tid); \n{ (a) An overwritten error in ext2 16 17 ... rc = txCommit(...); 14 15 log_wait_commit(journal, ... tid); \n18 ... 16 } 19 20 } return 0; //rc out of scope (c) An unsaved error code in ext3 (b) An out-of-scope \nerror in IBM JFS Figure 2. Three common scenarios in which unchecked errors are lost operationsthatare \n.ushedperiodicallytothedisk.Sincethereisno wayto communicateanyrelated errorsofbackgroundI/Ooperations \nto user applications,theseerrors are often dropped. Oneexampleis whenaperiodic timerlaunchesa background \ncheckpoint operation that willwrapall dirtybufferstoatransaction, committhetrans\u00adactiontothejournal, \nandwaitforitto.nish.As showninline14, theI/Ofailure propagatedbythe log_wait_commit functionis neglected \nbythe __process_buffer function, which itselfis called duringthe backgroundcheckpoint. Hence,ifthereisafailure, \ndata is silently lost. 3. AnalysisFormalization The .rst task is to determine, at each program point, \nthe set of unchecked error codes each variablemay contain.Giventhis information,thebugs describedin Section \n2.4 canbe detected using a second passover the code.Forexample, erroroverwriting occurs when the left \nside of an assignment already contains an unchecked error, while error dropping occurs when a variable \ncontaining an unchecked error goes out of scope. Error propagation can be formulated asaforward data.owproblem. \nError constants such as EIO generate unchecked error codes. Assignments propagate unchecked errors forward \nfrom one variable to another. Propagation ends when anerrorisoverwritten, dropped, or checkedbyerror\u00ad \nhandling code. This problem resembles copyconstant propagation[31]. How\u00ad ever, copy constant propagation \n.nds one constant value that a variable must contain (if any), whereas we .nd the set of error code constants \nthat a variable may contain. Copyconstant propaga\u00adtion drives semantics-preserving optimization, and \ntherefore under\u00adapproximates.We use error propagation analysis forbug reporting, andover-approximate \nso that no possiblebugisoverlooked. The following subsections describe WPDSs (our formalism of choice) \nand how we useWPDSs to encode the error propagation problem. Note that the error propagation problem \ncan be described asastandard context-sensitiveinterprocedural analysis problem. We choose to cast the \nproblem as a path problem over WPDSs because WPDSs (1) provide an algebraic formulation for handling \nlocal variables [19], and (2) support generating a witness trace as a proofoftheresultofsolvingthepath \nproblem[25].We use witness tracing extensively to provide programmers with detailed diagnostic traces \nfor each potential programbug (see Section4). 3.1 Weighted Pushdown Systems We use WPDSs[25]to formulate \nand solve the error propagation data.ow problem.AWPDSisa pushdown system thatassociates aweight with \neach rule.Weights can serve as transfer functions that describe the effect of each statement on the program \nstate. Such weights must be elements of a set that constitutes a bounded idempotentsemiring.We now formally \nde.ne WPDSsand related terms;Section 3.2 shows how WPDSs can be appliedto solve the error propagation \ndata.ow problem. DEFINITION 1. A pushdown system is a triple P =(P,G,.) where P and G are .nite sets \ncalled the control locations and stack alphabet, respectively. A con.guration of P is a pair (p,w), where \np. P and w . G* . . contains a .nite number of rules ' (p,.) '.(p,w), where p, p'. P, . . G, and w . \nG*, whichde.ne a transition relation . between con.gurations of P as follows: '' If r= (p,.) '.(p,w), \nthen (p,.w') . (p,ww') for all w'. G* . Asshownby Lal et al.[19]andRepsetal.[25], a pushdown sys\u00adtem \ncanbeusedto modelthesetofvalidpathsinaninterprocedural control-.ow graph (CFG). DEFINITION 2. A bounded \nidempotent semiring is a quintuple \u00af (D, ., ., 0\u00af, 1), where D is a set, 0\u00afand 1\u00afare elements of D, and \n. (the combine operator) and . (the extend operator) are binaryoperators on Dconformingto certainalgebraicproperties \nas denoted in Reps et al. [25]. Each element of Dis called a weight. The extend operator(.)is usedto \ncalculatethe weightofapath. The combine operator(.)is used to summarize the weights of a set of paths \nthat merge. DEFINITION 3. A weighted pushdown system is a triple W = (P, S , f) such that P =(P,G,.) \nis a pushdown system, S = \u00af\u00af (D,.,.,0,1) is a bounded idempotent semiring, and f :. . Dis a function \nthat assignsa valuefromDto eachrule P. Let s =[r1,...,rk] bea sequenceofrules(a pathin the CFG) from \n.*.Weassociateavalue with s byusingfunction f. Thisvalue is de.ned as val(s)= f(r1) .\u00b7\u00b7\u00b7. f(rk).For anycon.gurations \nc and c' of P, path(c,c') denotes the set of all rule sequences ' [r1,...,rk], i.e., the set of all paths \ntransforming c into c. DEFINITION 4. Let W =(P,S , f) be a weighted pushdown sys\u00adtem, where P =(P,G,.), \nand let C. P\u00d7 G* be a regular set of  Rule Control .ow modeled (p,a) '.(p,b) Intraprocedural .ow from \na to b (p,c) '.(p, fenterr) Call from c to procedure entry fenter , even\u00adtually returning to r (p, fexit) \n'.(p,e) Return from procedure exit fexit Table 1. Encoding of control .ow as PDS rules con.gurations. \nThe generalized pushdown successor problem is to .nd for each c . P\u00d7 G*: ' d (c) = .{val(s) |s . path(c \n,c),c '. C} '  a witness set of paths w(c) ..c '.C path(c ,c) such that .s.w(c)val(s)= d (c).  The \ngeneralized pushdown successor problem is a forward reachability problem.It .nds d (c), the combine of \nvalues of all paths betweencon.gurationpairs,i.e.,themeetoverallpathsvalue for each con.guration pair.A \ncorresponding witnessset w(c) is a subsetof inspectedpaths suchthattheir combineis d (c). This set can \nbe used to justify the resulting d (c). The meet over all paths value is the best possible solution to \na static data.ow problem. Thus, a WPDS is a useful data.ow engine for problems that can be encoded with \nsuitable weight domains. In Section 3.2 we show how the error propagation problem can be encoded as a \nweight domain. In ordertohandlelocalvariables properly, we useanextension to WPDSsproposedbyLaletal.[19]. \nThis extension requires the de.nition of a merge function, whichcan be seen as a specialcase of the extend \noperator. This function is used when extending a weight w1 at a callprogram point with a weight w2 at \nthe end of the corresponding callee. The resulting weight corresponds to the weight after the call.The \ndifference between the merge function and a standardextend operationis that w2 contains information about \nthecallee slocals;this informationisirrelevanttothecaller.Thus, themergefunction de.nes what informationfrom \nw2 tokeep or discard before performing the extend.  3.2 Creating theWeighted Pushdown System PerDe.nition3,aWPDS \nconsistsofapushdownsystem,abounded idempotentsemiring, anda mappingfrom pushdown system rulesto associated \nweights.We nowde.nethesecomponentsfora WPDS that encodes the error propagation data.ow problem. 3.2.1 \nPushdown System Wemodelthe control .owof theprogram witha pushdown system usingthe approach of Lal et \nal.[21]. Let Pcontain a single state {p}. G corresponds to program statements, and . corresponds to edgesoftheinterprocedural \nCFG.Table1showsthe PDS rule for each type of CFG edge. 3.2.2 Bounded Idempotent Semiring We classify \ninteger constants intoerror constants and non-error con\u00ad stants. Among the error constants we further \ndistinguish tentative from non-tentative errors for reasons we discuss further in Sec\u00ad tion 4.1.Let \nTentativeErrorsbe thesetoftentativeerror constants: integervalues usedtorepresent error codes.Foreachtentative \nerror constant de.ne a corresponding non-tentative error constant. Let NonTentativeErrors be the set \nof all non-tentative error constants. De.ne E = TentativeErrors. NonTentativeErrors as the set of all \nerror constants.Forpurposesofthisanalysis,allnon-error constants can be treated as a single value, which \nwe represent as OK.We also introduce uninitialized to represent uninitialized values. Let C = E .{OK,uninitialized \n} bethe setof all constants.Finally, let V be the set of all program variables. Let S = (D, ., ., 0, \n1)be a bounded idempotent semiring per \u00af\u00af De.nition 2. Elements of Dare drawnfrom V . 2V .C , so each \nweight in Disamappingfromvariablestosets containingvariables, error values, OK and/or uninitialized .Thisgives \nthe possiblevalues of v followingexecutionofagiven program statementin termsof the values of constants \nand variables before that statement. The combine operator is applied component-wise, with each variable \nv mappingtoanyvalueit couldhavemappedtoineitherof the weights being combined.For all w1, w2 . Dand v \n. V : (w1. w2)(v) = w1(v) . w2(v) The extend operator is also applied component-wise:  (w1. w2)(v) = \n(C n w2(v)) . w1(v ') v '.V nw2(v) where w1(v) ./ 0.This de.nition is = 0, otherwise (w1. w2)(v) = /essentially \nfunction composition generalized to the power set of variables and constants rather than just single \nvariables. \u00af De.ne the neutral weight 1as {(v,{v}) |v . V }, which maps each variable to the set containing \nitself. This is a power-set generalizationoftheidentityfunction. De.netheannihilatorweight \u00af 0as {(v,0/)|v. \nV }, mapping each variable to the empty set. Finally, the merge functionis de.ned as follows.Let w1 be \nthe weight of the caller justbefore the call, and let w2 be the weight at the very end of the callee. \nThen for any variable v . V , w1(v) if v is a local variable merge(w1(v), w2(v)) = w2(v) if v is a global \nvariable This propagates anychangesthatthe callee madeto globals while discarding anychanges that the \ncallee made to locals.  3.2.3 Transfer Functions Each control-.ow edge in the source program corresponds \nto a WPDSrule and therefore needsan associatedweightdrawnfrom the set of transfer functions D de.ned \nin Section 3.2.2. In the following discussionofspeci.c source constructs,wedescribe most transfer functions \nasbeing associatedwith speci.cstatements.The corresponding WPDS rule weight is associated with the edge \nfrom a statement to its unique successor. Conditionals have multiple outgoing edges and therefore require \nmultiple transfer functions. Assignments Hereweconsider onlyassignments withoutfunction calls on the \nright side.We leave thediscussionof assignments such as v = f() for later in this section. Copy mode \nversus transfer mode Our analysis has two chief modes of operation: copy mode and transfer mode. Consider \nan assignment t = s where t,s . V are distinct and s might contain an unchecked error code.In copymode, \nassignment copies errors: afterthe assignment t = s, both t and s contain unchecked errors. Intransfermode,the \nassignment t = s leaves an unchecked error in t but removesit from s, effectively transferring ownership \nof uncheckederrorvalues across assignments.Discussion that follows refers to both copyand transfer modes \nunless otherwise stated. Simple assignments These are assignments of the form v = e, where e . V . C \n.Let Ident be the functionthat maps eachvariable to the set containing itself. (Note that this is identical \nto 1\u00afper Section 3.2.2.) The transferfunctionfora simple assignmentin copy mode is then Ident[v .. {e}]. \nIn other words, v must have the value of e after this assignment, while all other variables retain whatevervalues \ntheyhadbefore theassignment.Intransfer mode, let Donor ={e}n V -{v} bethe set containingthe source variable(if \nany)ofthe assignment. Then thetransferfunction for  a simple assignmentintransfer modeis Ident[v .. \n{e}][s .. {OK}for s. Donor] to transfer anyunchecked errors from Donor to v. Complex assignments These \nareassignmentsinwhichthe assigned expression e is notasimplevariable or constant.We assumethatthe program \nhas been converted into three-address form, with no more than one operator on the right side of each \nassignment. Consider an assignment of the form v= e1ope2 where e1,e2 . V . C and op is a binary arithmetic \nor bitwise operator(+, &#38;, <<, etc.).De.ne Donors ={e1, e2}n V asthesetofvariables on the right side \nof the assignment. Error codes are represented as integersbut conceptuallytheyareatomicvaluesonwhicharithmetic \noperations aremeaningless.Thus,if op is an arithmetic or bitwise operation,thenwe can safely assume thatthevariablesin \nDonors do not contain errors. Furthermore, the result of this operation must be a non-error as well. \nTherefore, the transfer function for this assignment is Ident[u .. {OK} for all u . Donors .{v}]. Consider \ninstead an assignment of the form v= e1ope2 where e1,e2 . V . C and op isa binary relational operator(>, \n==, etc.). Relational comparisons are meaningful for error codes, so we cannot assume that e1 and e2 \nare non-errors. However,the Boolean result of the comparison cannot be an error. Therefore, the transfer \nfunction for this assignment is Ident[v.. {OK}]. Assignments with unary operators(v= ope1)are similar: \narith\u00admetic and bitwise operators map both v and e1 (if a variable) to {OK}.However,Cprogrammers often \nuse logical negation to test for equalityto0.So when op is logical negation(!)or an indirection operator(&#38;, \n*), the transfer function maps v to {OK} but leavese1 unchanged. Conditionals Assume that conditional \nstatements with short\u00ad circuiting conditions are rewritten as nested conditional statements withsimpleconditions.Atransfer \nfunctionisthen associatedwith eachbranch of a conditional statement. The transfer function to be applied \non each branch depends upon the condition. Consider a conditional statement of the form if(v), where \nv. V . The true branch is selected when v is not equal to zero, which does not reveal anyadditional information \nabout v: it may or may not contain an errorvalue.In thiscase,variables should remain mapped to whatever \nvalues theyhad before. On the other hand, the false branchis selectedwhen v isequalto zero. Because zerois \nnever an error code, v de.nitely does not containan error. Thus thetransfer functions associatedwith \nthe true and falsebranches are Ident and Ident[v.. {OK}], respectively. Conversely, consider conditionalsofthe \nforms if(v > 0), if(v= 0), if(0< v), if(0= v), if(0== v), if(v == 0), and if(!v). In all ofthesecases,thetransfer \nfunctionassociatedwiththe true branch is Ident[v .. {OK}]. The true branch is never selected when v is \nnegative, so v cannot contain an error onthat branch. Thetransfer function for thefalse branchis the \nidentity function Ident. Lastly, consider conditional statements such as if(v < 0), if(v= 0), if(0> v) \nand if(0= v).We associate thetransfer function Ident with the true branch and Ident[v .. {OK}] with the \nfalse branch. In eachofthese cases, the falsebranchis onlyselectedwhen v is non-negative, which means \nthat v cannot contain an error code. For conditional statements that do match none of the above patterns,wesimply \nassociate Ident with both true and falsebranches. An example of such a pattern is if(v1 < v2), where \nv1, v2 . V . Function calls Weadoptthe convention usedbyCallahan[3],and laterby Repsetal.[25],in whichthe \nCFGfor each function has unique entry andexit nodes. The entry nodeis not the .rststatement inthefunction,butrather \nappearsjustbeforethe.rststatement. Likewise, we assume that function-terminating statements (e.g., return \nor last-blockfall-through statements)haveasynthetic per\u00ad functionexit node astheir unique successors.We \nuse these dummy entry and exit nodes to manage data transfer between callers and callees. CFGs forindividual \nfunctions arecombinedtogetherto forman interproceduralCFG. Furthermore, each CFG node n that contains \nafunction callis splitintotwo nodes:a call node n1 and a return\u00adsite node n2. Thereis an interprocedural \ncall-to-enter edge from n1 to the callee s entry node.Similarly,thereis aninterprocedural exit-to-return-site \nedge from the callee s exit node to n2. Local variable initialization First consideracalltoavoid function \nthat takes no parameters. Let L ,G . V respectively be the sets of all localand globalvariables. Recallthat \ntransfer functions are associated withCFG edges.Forthe edge fromthe callee sentry nodeto the .rst actual \nstatementin the callee, we use thetransfer function Ident[v .. {uninitialized } for v . L ]. When a function \nbegins executing, local variables are uninitialized while global variables retain their old values. Parameter \npassing Now consider a call to a voidfunction that takes one ormore parameters.Weintroduce newglobalvariables, \ncalled exchange variables, to convey actual arguments from the caller intothe formal parametersofthe \ncallee. Oneexchangevari\u00ad ableis introducedfor each functionparameter.Suppose function F hasformal parameters \nf1, f2,..., fn. Let F(a1,a2,...an) be a func\u00adtion call to F with actual parameters ai . V . C .We introduce \nglobal exchange variables F1,F2,...,Fn. The interprocedural call\u00adto-enter edgeisgiven the transferfunction \nfora groupof n simulta\u00adneous assignments Fi = ai,exporting eachactual argumentinto the corresponding \nglobalexchangevariable. Rules for assignmenttrans\u00ad fer functionsdiscussedearlierapply,includingthetransfer-mode \nvariant which maps each ai to {OK} after the assignments. Asimilar processimportsvaluesfromglobalexchangevariables \ninto callee formal parameters.Fora callee Fwith formal parameters f1, f2,..., fn,theedgefromthecallee \ns entrynodetothe.rstactual statementin the calleeisgiven thetransferfunctionfora groupof n simultaneous \nassignments fi = Fi, as though eachformal argument were initialized with a value from the corresponding \nexchange variable. Other local variables are uninitialized as before. Thus, argument passing is modeled \na two-step process: .rst the callerexportsits arguments into globalexchangevariables,then the callee \nimports these exchange variables into its formal parameters. Return value passing Lastly, suppose that \nfunction F returns non\u00ad void.Let r . V . C be thevalue being returnedbysome return r statement, and let \nFret be a per-function global exchange variable. Then the edge connecting this return statement node \nto the dummy exit node is given the transfer function for an assignment Fret = r. As de.nedinSection3.2.2,therearetwokindsoferrorconstants: \ntentative and non-tentative. Error codes are initiallytentative and become non-tentative as soon as returned \nfrom a function. Let E = w(Fret) n TentativeErrors, where w is the weight at the end of function F.For \nall e. E, we replace e with e ', the corresponding non-tentative error. We discuss the need for two kinds \nof error constants in Section 4.1. Let v. V be the variable receiving the return value in the caller. \nThenthe interproceduralexit-to-return-site edgefrom F s exit node isgiven the transfer function for an \nassignment v= Fret. Other interprocedural issues We consider functionswhoseimple\u00ad mentation is not available \nto not have anyeffect on the state of the program. Thus the weight across anysuch call is simply Ident. \nFor functions with variable-length parameter lists,we applythe above transferfunctionsbutwe onlyconsider \nthe formalparameters explicitly declared. Pointers Our treatment of pointers is both unsound and incom\u00adplete,butis \ndesignedforsimplicityandtogive useful resultsin practice.We.ndthatmanyfunctions takea pointertoa callee-local \n variablewhereanerrorcode,ifany, shouldbewritten.Thusweonly considerpointer parameters and ignore other \npointer operations.We assume thatinside a function, pointer variables have no aliases and are never changed \nto point to some other variable. Under these conditions, pointer parameters are equivalent to call-by-copy-returnparameters.Ontheinterprocedural \ncall-to-enter edge,wecopypointed-tovalues fromthe callertothecallee,just asforsimpleinteger parameters.Onthe \ninterprocedural exit-to\u00adreturn-site edge, we copycalleevalues backinto the caller. This extra copy-back \non return is whatdistinguishes pointer arguments from non-pointer arguments, becauseitallows changesmadebythe \ncallee to become visible to the caller. Function pointers Mostfunction pointers inLinux .le systems are \nusedinafairly restricted manner.Globalstructuresde.ne han\u00ad dlers for generic operations (e.g., read, \nwrite, open, close), withone function pointer .eld per operation. Fields are populated statically or \nvia assignments of the form file_ops->write = ext3_\u00adfile_write where ext3_file_write identi.es afunction, \nnot another function pointer. It is straightforward to identify the setofall possibleimplementationsofagiven \noperation.We then rewrite calls across such function pointers as switch statements thatchoose among possible \nimplementations nondeterministically. This technique,previouslyemployedbyGunawietal.[11],accounts for \napproximately80%offunction pointer calls whileavoidingthe overhead and complexity of a general .eld-sensitive \npoints-to analy\u00ad sis.Theremaining 20%of calls aretreated as Ident.Note that we analyze each .le system \nindividually; this perfectly disambiguates nearly all indirect calls in the code under study. Error-handling \nfunctions As suggested in Section 2.3, we con\u00ad sider any error values in a variable to have been checked \nwhen thevariableispassed as an argumentto printk. printk is a variadic function whose .rstparameterisalwaysaformatstring. \nThetransfer function for suchacallis Ident[v .. {OK} for v in the actual int-typed arguments to printk]. \nThisalso appliesto error-handlingfunctionsspeci.cto each.lesystemunderstudy: ext3_error, jfs_error, etc. \n4. Finding and Describing Bugs Herewe describehowwe querytheWPDSto.nd error propagation bugs.Wealso describehowwitness \ninformationis usedto construct paths and slices that better describe thebugs found. 4.1 Querying theWeighted \nPushdown System We perform a poststar query[25]onthe WPDS, with thebeginning ofthe program asthe starting \ncon.guration.Forkernel analysis, we synthesize a main function that nondeterministicallycalls all exported \nentry pointsofthe.le system under analysis. The result isaweighted automaton.We applythe path_summary \nalgorithm of Lal et al.[20]to read out weights from this automaton. This algorithm calculates, for each \nstateinthe automaton,the combine ofallpathsinthe automatonfrom thatstatetotheacceptingstate,if any.We \ncan thenretrieve theweightrepresentingexecutionfrom the beginning of the program to anyparticular point \nof interest. We turn the three cases in which error codes are commonly lost intoasingle case:overwritten \nerrors.For out-of-scope errors,we insertassignmentstatementsattheendofeachfunction.Theseextra statements \nassign OK to each local variable except for the variable being returned (if any). Thus, if any local \nvariable contains an unchecked error whenthe function ends,thenthe errorisoverwritten bytheinsertedassignment \nand our analysis detects the problem. In the case of unsaved errors, for each function whose result is \nnot already being saved by the caller, we introduce a temporary local variableto hold that result. These \ntemporariesareoverwritten CIFS ext3 ext4 IBM JFS ReiserFS VFS Full path 14.7 66.6 70.4 16.7 17.9 22.6 \nPath slice 6.0 8.1 8.3 4.7 3.8 5.8 Table 2. Average lengths of full paths and path slices with OK at \nthe end of the function, as described above. Thus, unsavedreturnvalues are transformedinto out-of-scopebugs.A \nsystematic naming convention for these newly-added temporary variablesletsusdistinguishthetwo caseslatersothattheycanbe \ndescribed properlyindiagnostic messages. Thus, both out-of-scope and unsaved errors are ultimately turned \ninto overwritten errors. Our goal is to .nd whether each assignment may overwrite an error value. At \neach assignment pwe retrievetheassociatedweight w. Let S,T . C respectively be the sets of possible constant \nvalues heldbythe sourceandtargetoftheassignment,asrevealedby w. Note that wdoes notincludetheeffectofassignment \npitself.Rather, it re.ects the state just before p. Then: 1. If T n NonTentativeErrors = 0/, then the \nassignment cannot overwrite anynon-tentative error code and is not examined. 2. If Tn NonTentativeErrors \n= S= {e} for some single error code e, then the assignment can only overwrite an error code with the \n same error code and is not examined.1 3. Otherwise,itis possible thatthis assignmentwilloverwrite an \nunchecked error code with a different code. Such an assignment is incorrect, and is presented to the \nprogrammer along with suitable diagnostic information. Observe that we only report overwrites of non-tentative \nerrors. We .nd thatoverwritesoftentative errors arerarely truebugs. This isduetocoding conventionssuchas \nstoringpotential error codesin variablesbeforefailure conditionsactuallyhold.Thisphenomenon is usually \ncontained within the function that generates the error code:error codesreturnedto callers generally represent \nreal run\u00ad time errors. Our transformation of returned errors from tentative to non-tentative models this \ncoding practice; ignoring it wouldhave tripled ourfalse-positive count.Welist all error codesthat could \nbe possibly overwritten at each bad assignment, then select one for detailed path reporting as described \nnext.  4.2 Witnesses,Paths, and Slices WPDSs supportwitnesstracing.As mentionedinDe.nition4,a witnesssetisasetofpathsthatjustifytheweight \nreportedfora given con.guration. This information lets us report not just the locationofabad assignment,butalso \ndetailedinformation about how that program pointwas reachedinaway thatexhibits thebug. For eachprogram \npoint pcontaining a bad, error-overwriting assignment, we retrieve a corresponding set of witness paths. \nEach witness path starts at the beginning of the program and ends at p.We selectoneofthesepathsarbitrarilyandtraverseitbackward, \nstarting at pandmovingalongreversedCFG edgestowardthebeginning oftheprogram. Duringthisbackwardtraversal,wetrack \nasingle special targetlocation whichis initiallythevariableoverwritten at p.The goal is to stop when \nthe target is directlyassigned the errorvalue underconsideration, i.e.,when wehave foundthe error s pointoforigin. \nThisallowsustopresentonlyarelevantsuf.xof the complete witness path. Let t be the currently-tracked targetlocation. \nEach statement alongthe backwardtraversalof theselectedwitness path has oneof the following forms: 1Weopenthisloopholebecausewe.ndthatthisisa \ncommonly-occurring pattern judged to be acceptable by .le-system developers.  1 int nextId() { Error \ncodes: *EIO 2 3 static return int id; ++id; (b) List of overwritten/dropped errors 4 } 5 6 int getError() \n7 return -EIO; 8 } 9 { example.c:7: unchecked example.c:14: \"status\" example.c:16: \"result\" example.c:18: \n\"result\" error \"EIO\" is returned receives unchecked error receives unchecked error has unchecked error \nfrom from function \"status\" \"getError\" 10 int load() { example.c:3: \"result\" has unchecked error 11 int \nstatus, result = 0; example.c:18: \"result\" has unchecked error 12 example.c:19: overwriting unchecked \nerror in \"result\" 13 14 if (nextId()) status = getError(); (c) Complete diagnostic path trace 15 16 17 \nresult = status; example.c:7: unchecked error \"EIO\" is returned 18 19 if (nextId()) result = -EPIPE; \nexample.c:14: example.c:16: \"status\" \"result\" receives receives unchecked unchecked error error from \nfrom function \"status\" \"getError\" 20 example.c:19: overwriting unchecked error in \"result\" 21 22 } return \nresult; (d) Diagnostic path slice (a) Example code Figure 3. Example code fragment and corresponding \ndiagnostic output 1. t = x for some other variable x . V .Then the overwritten error valuein t must havecomefrom \nx.We continue the backward path traversal, but with x as the new tracked target location instead of t.Additionally,we \nproducediagnostic outputshowing the source .le name,line number, andthemessage t receives unchecked error \nfrom x. If x is a return exchange variable, then weprintanalternate message re.ectingthefactthat t receives \nan errorcodefroma function call(e.g., see the messageforline14 in Figure 3(a)). 2. t = e for some error \nconstant e . E . We have reached the point of origin of the overwritten error. Our diagnostic trace is \nnow complete for the bad assignment at p. We produce a .nal diagnostic message showing the source .le \nname, line number, and the message t receives error value e. If t is a return exchange variable, then \nwe print an alternate message re.ectingthefact that an error codeis beingreturned froma function (e.g., \nsee the message for line7in Figure 3(a)). 3. Anything else.We continue the backward path traversal, retain\u00ad \ning t asthe trackedtargetlocation.Additionally, we produce diagnostic output showingthe source .le name,line \nnumber, and the message t has unchecked error. If all diagnostic output mentioned above is presented \nto the programmer, then the resultisa step-by-steptraceofeveryprogram statement fromthe originof an errorvaluetoitsoverwritingat \np. Ifdiagnostic outputis omittedfor case3, then the trace shows only keyevents of interest, where the \nerror value was passed from one variabletoanother.Weterm thisa path slice, as it is analogous to a programslicethatretainsonlythestatements \nrelevanttoaparticular operation.In practice, we .ndthattheconcise path slice providesa usefuloverview \nwhilethecompletewitnesspathtrace helpsto .ll in details wheregaps between relevant statements are largeenough \nto make interveningcontrol .ow non-obvious.Table2showsthat slicingsigni.cantlyreducespathlengths.Acrossall.ve.lesystems \nandthesharedvirtual.lesystem,slicing shrinks pathsbyanaverage ratio of 5.7 to 1. Notethatweonlyprovide \ndiagnosticoutputforoneoverwritten error code per badassignment. If the badassignment may overwrite more \nthan one error code, then we choose one arbitrarily. The instance chosen may notbea truebug, foolingthe \nprogrammer into believingthat no real problemexists.Adifferent errorvalue potentiallyoverwrittenbythe \nsameassignment maybea truebug. However, providing diagnostic output for all error values might overwhelm \nthe programmer with seemingly-redundant output. Figure3(a) shows anexample code fragmentthat has an error \npropagationbugintransfermode. Figure3(b)liststhe errorcodes thatmaybeoverwritten/droppedata particular \nprogram point.The error code whichthe rest of the diagnostic information correspond to is marked with \nan asterisk. EIO is the only error code that may be overwritten in this example. Figure 3(c) shows the \ncomplete diagnostic path trace. Observe that this trace begins in function getError, which is called \nfrom load in line 14. Execution eventually traverses into nextId (line3) while travelingfrom the errorcode \ngenerationpoint(line7)totheoverwritingassignment (line 19).Figure3(d) showsthediagnostic pathslicewhichincludes \nonly thoselinesdirectlyrelevantto the error. Herewe seejust foureventsofinterest: the generationof an \nerror code,whichis returned by function getError in line 7; the transfer of that error to status inline14;thetransferof \nthaterror codefrom status to result in line 16; and the assignment to result in line 19. 5. Experimental \nEvaluation Ourimplementation usestheCILCfront end[24]to apply pre\u00adliminarysource-to-sourcetransformations \nonLinuxkernel code. This includes rede.ning error code macros as distinctive expres\u00ad sionstoavoid mistakingregular \nconstantsfor errorcodes.Wethen traverse the CFG and emit a textual representation of the WPDS. Our separate \nanalysis tool uses theWALi WPDSlibrary[18]to perform the interprocedural data.ow analysis onthis WPDS.Within \nourWALi-based analysis code,we encode weights using binary decision diagrams (BDDs)[2]asimplementedby \nthe BuDDyBDD library[22].BDDshave been usedbeforetoencode weight domains [27]. The BDDrepresentation \nallows highly-ef.cient implementa\u00ad tionofkeysemiring operations, such asextend and combine. Wepresent \nthe resultsof ouranalysis onfour local .lesystems (ReiserFS, IBMJFS,ext3andext4), one network .le system(CIFS), \nand common virtual .le system (VFS) code used by all others.2 Our analysis reports 501bugsin total,ofwhich312are \njudged true bugs following manual inspection of the reports. IBM JFS andReiserFSreports wereinspectedbythe.le \nsystems respective 2Weexclude shared memory-management code(mm), asitslows the analysis signi.cantly \nwhile containingveryfew error-propagationbugs.  1 if (err == -EIO) { 2 ... 3 4 } err = ...; //safe 1 \nint 2 ... err; (a) Speci.c error code 3 retry: 4 ... 5 if (...) 1 reiserfs_warning(...); 6 return ...; \n2 err = -EIO; //safe 7 //err is safely out of scope (b) Special function 8 9 err = ...; //safe 10 ... \n1 if (retval 2 retval = &#38;&#38; err) err; //safe 11 12 if (err == -ENOSPC goto retry; &#38;&#38; ...) \n(c) Replacement (d) Retries Figure 4. Some recurring safe patterns recognizedby the analysis developers. \nCIFS and ext4 developers inspected a subset of their corresponding reports.Alocal domainexpert whois \nalso coauthor of this paper assessed the rest, including the reports for ext3. Developer response has \nbeen positive: Ithinkthisis anexcellentwayof detectingbugsthat happen rarelyenough that there are no \ngood reproductioncases,but likely hit users on occasion and are otherwise impossible to diagnose. [5] \nOurlocalexpert reportsspending anaverageof.veminutes to accept or reject each path trace. We .nd that \nunsaved error propagationbugs are the most common.In general we .ndthat transfermode yields better results \nthan copymodeinthe sensethat it producesfewerfalse positives. Inthe discussionthat follows, we present \nresults for eachbug category.Allresults reportedare for transfer mode unlessexplicitly stated otherwise. \nTable 3 summarizes our .ndings. We identify anddescribesafepatterns thatwe usetore.ne ourtool.We also \ndescribefalsepositivesindetail. Notethattheseareonly false positivesinthatdevelopersand our local expertjudgethat \nerrors are safelyoverwritten, outof scope or unsaved. Thefact that errors areoverwritten, outofscope \nor unsavedis real, andin this sensethe analysisisprovidingcorrect,precise informationforthe questions \nit was designed to answer. 5.1 Overwritten Bug Reports Developers and ourlocalexpertidentify25overwritten \ntruebugs. We .nd thatEIO and ENOMEM are the most commonlyoverwritten error codes. EIO signalsI/O errors,includingwritefailures \nthat mayleadto data loss. ENOMEM is used when thereis insuf.cient memory. Ourtoolrecognizesfourrecurringpatternsthat \nrepresentsafe overwrites. Figure 4(a) shows the most common recurring pattern found acrossall.ve.le systems.Here,line1compares \nerr with a speci.c error code.Iftheymatch,thenline3clears err or assigns it a different error code. Overwriting \none error code with another does notalways representabug.Forexample, an errorcode generatedin one layer \nof the operating system may need to be translated into a different codewhen passedto another layer. Thisclearlydepends \non the context andtheerror codesinvolved.In this case,we can see thatthe programmeracknowledgesthat err \ncontains a speci.c error code before performingthe assignment.We chooseto trust the programmer in this \nparticular scenario, thus we assume that overwriting the error code contained in err is safe. Figure4(b)showsthesecond \ncommon pattern, foundin both ReiserFS and ext3. In this case the programmer acknowledges that something \nmight be wrong by calling a function such as 1 ret = ...; 1 if (err) 2 ret2 = ...; 2 retval = err; //unsafe \n3 4 if (ret == 0) (a) Replacement 5 ret = ret2; 6 ... 7 ret2 = ...; //unsafe  1 int ret, err; 2 ret \n= ...; (c) Precedence/overwrite 3 4 if (ret) goto out; 51 buffer_head *tbh = NULL; 6 ret = ...; 2 ... \n7 err = ...; 3 if (buffer_dirty(tbh)) 84 sync_dirty_buffer(tbh); 9 if (!ret &#38;&#38; err) 5 // unsaved \nerror 10 ret = err; 6 11 7 if (!buffer_uptodate(tbh)) { 12 out: return ret; 8 reiserfs_warning(...); \n13 // err out of scope 9 retval = -EIO; 10 } (b) Precedence/scope (d) Redundancy Figure 5. Some recurring \nunsafe patterns reiserfs_warning in the caseof ReiserFS.Thecallis usually followedby an assignment that \nmay overwrite an error code.We choose to allow overwrites that occur immediately after such calls. Thethirdpattern,showninFigure4(d), \nappearsinbothext3and ext4. Here variable err may receive an errorcodefroma function call(the functioncould \nreturndifferent error codes)inline9. Our tool initiallyreportedanoverwriteatthatlineinthecaseofaretry. \nWe observe that thegoto statementin line 12 is alwayslocated inside an if statement. In addition, the \nvariable being overwritten always appearsin the condition (line 11), making it possible to identify the \nvariable that needs to be cleared before retrying. ThelastpatternisshowninFigure4(c). Bothvariables retval \nand err might contain error codes at line 1. Thus a potential overwrite would be reported in line 2 when \nthe error stored in err replaces that in retval. In this case, we can see that the programmer acknowledges \nthat those variables might contain error codes before performing the assignment: the assignment occurs \nonly if both variables are nonzero. We trust the programmer in this particular scenarioand assume thatoverwritingtheerror \ncode contained in retval is safe. Mostfalse positivesarisefromoverwriting one error code with anothererror \ncodewithout clearknowledgethatan errormaybe overwritten. Unfortunately,thereisnoformalerror hierarchy,which \nprevents us from automaticallydifferentiating between correct and incorrectoverwrites.We identifytwo \nunsafepatternsinwhicherror codesarecommonly overwritten.We .nd that27outof44false positives obeythe pattern \nshownin Figure5(a).In this case, only the variable err is acknowledged to be nonzero in line 1.We do \nnot consider the overwrite in line 2 to be safe because it is not clearthatthedeveloperisawareoftheoverwrite. \nOurtoolreports thepotentialbuganddevelopers mustdetermineitsvalidity.The second unsafepatternisshowninFigure5(c).Ifboth \nret and ret2 contain error codes at line 4, then ret2 is overwritten in line 7. In this case, ret has \nprecedence over ret2.We .nd that 9 out of the remaining 17 false positives fall into this category. We \ncan recognize these patterns and mark these reports in the future. This would allow developers to prioritize \nthe reports or skip certain categoriesaltogetherif considered safe.We callthese false positives removable. \nThe8remainingfalse positivesrequired signi.cant humaninterventiontodeterminetheirsafeness; wecall these \nunavoidable.  CIFS ext3 ext4 IBM JFS ReiserFS VFS Bug category TB FP T TB FP T TB FP T TB FP T TB FP \nT TB FP T Overwritten 8 1+5 14 5 5+0 10 5 10+0 15 2 7+0 9 3 2+0 5 2 11+3 16 Out of scope 2 0+0 2 5 6+0 \n11 3 7+0 10 2 0+1 3 3 12+1 16 3 16+5 24 Unsaved 12 11+4 27 69 16+2 87 68 39+1 108 58 0+3 61 24 6+5 35 \n38 10+0 48 Total 22 12+9 43 79 27+2 108 76 56+1 133 62 7+4 73 30 20+6 56 43 37+8 88 Table 3. Summary \nresults for the six case studies. Bug reports are broken down into overwritten, out-of-scope and unsaved. \nEach category is furtherdividedintotruebugs(TB)andfalsepositives(FP).The.rstcolumnunderFPs correspondsto \nremovable FPs(FPsthatcanbe removedifourtoolrecognizesunsafepatterns).Thesecondcolumncorrespondsto unavoidable \nFPs(FPsthat cannotbeautomatically removed becausesigni.canthumaninterventionisrequired).Thelastcolumn(T)givesthe \ntotal numberofbug reportsperbugcategory. Results for unsaved errors were produced in copymode.  5.2 \nOut-of-Scope Bug Reports Out-of-scopebugsare the leastcommon.Atotalof66bug reports concern out-of-scope \nerrors.Amongthese, 18 truebugs areiden\u00adti.ed. Figure 2(b) shows an out-of-scopebug foundin IBMJFS. Mostof \nthesebugsrelateto ignoringI/O errors.Weidentify four recurringsafe patterns for out-of-scope errors,of \nwhichthree are variants of those discussed in Section 5.1. The .rstpatternappearsinCIFS,ext4andIBMJFS.Thispattern \nissimilartothatshowninFigure4(a),howeverifthevariable holds aspeci.c error code,then zero ora different \nerror codeisreturned inline3, i.e., thereisa returnstatementinsteadof an assignment. Wealsotrusttheprogrammerinthis \ncaseanderr is not reported to go out of scope at this line. Thesecondpattern,shownin Figure4(d), appearsinext3and \next4.Without recognizingthis pattern, ourtoolwould reportthat err is outof scopeinline6. Thisis not the \ncasewhen err is cleared before retrying. ThethirdpatternhasalreadybeenshowninFigure4(b),however thereisa \nsubtle difference. In this case, reiserfs_warning takesthevariablethatis abouttogooutofscopeasparameter.Asa \ngeneral approachforthispattern,weclearanyvariablethatispassed as parameter to reiserfs_warning and similar \nfunctions. The fourthpattern concerns error transformation: changesin how errors are represented as they \ncross software layers. Integer error codesmaypassthrough structure .elds,be castintoother types,betransformedinto \nnull pointers, and so on. Our analysis does not track errors across allof these representations. As a \nresult, error codes are notpropagatedwhentransformed,yielding out-of\u00adscopefalse positives.Wealso .nd \nthat transformation from integers to pointers predominates. Thistransformation uses the ERR_PTR macro, \nwhich takes the error to be transformed as parameter. As in thecaseoffunctionssuch as reiserfs_warning, \nwe clear any variable that is passed as parameter to ERR_PTR. Adhoc errorprecedenceisthemain sourceoffalsepositives. \nFigure 5(b) presents one example. Both ret and err may be assigned errorcodesin lines6and7,respectively.Variable \nret is propagatedregardlessthe contentsof err,unless it does not contain an error code, i.e., ret has \nprecedenceover err. Our tool produces an out-of-scope reportfor err inline12.This couldbeabugornot depending \non the context.We .nd that41 outof48false positives exhibitthispattern.Wecan recognizethispatterntoprovide \nmore informationinthe future.Asforoverwrites,the false positives here are not indicationsof analysisimprecision,but \nrather are based ona humanexpert s judgmentthat some errorscanfalloutof scope safely. 5.3 Unsaved Bug \nReports Unsavedbugspredominateinall.ve .le systems.Developers and ourlocalexpertidentify 269 truebugs \namong 366 unsavedbug reportsin copy mode.Transfer mode produces 48% fewerfalse Table 4. Analysis performance. \nKLOCgives the size of each.le Analysis time (h:mm:ss) File system KLOC Phase 1 Phase 2 Phase 3 Total \nCIFS 91 0:00:12 1:14:18 0:01:10 1:15:40 ext3 83 0:00:12 1:37:00 0:01:06 1:38:18 ext4 97 0:00:13 3:36:54 \n0:01:22 3:38:29 IBM JFS 93 0:00:12 1:16:01 0:01:00 1:17:13 ReiserFS 88 0:00:12 2:28:59 0:01:19 2:30:30 \n systemin thousandsoflinesofcode,including60 KLOCof shared VFS code. positivesbutmisses33%ofthetruebugsfoundincopymode.The \nmostcommon unsaved error code is EIO, followedby ENOSPC and ENOMEM. Figure 2(c) shows an unsavedbug foundinext3. \nClose inspection reveals serious inconsistencies in use of some functions returnvalues.Forexample, we \n.nd one function whose returnederrorcodeis unsavedat35callsites,butsavedat17 others. Inthisparticularexample,9outofthe35badcalls \naretruebugs;the restarefalsepositives.Whenwealerteddevelopers,some suggested they could use annotations \nto explicitly mark cases where error codes are intentionally ignored. The main sourceoffalse positivesconcerns \nerror paths:paths along which an error is already being returned, so other errors may besafelyignored.Thesecondmostcommon \nsourceoffalsepositives isduetothefactthereis anotherwayto detectthe problem, which we term redundant \nerror reporting. Figure 5(d) shows an example from ReiserFS. The sync_dirty_buffer call in line 4 may \nreturn an errorcode,but checkingits parameter tbh inline7is suf.cientinthis case.However,itisstillpossibleforamorespeci.c \nerrortobe droppedleadingtolossofinformationaboutwhatexactly went wrong.Afewfalse positives arise when \ncallers know that the callee returns an error code onlyifcertainpreconditions are not met. Callers thathave \nalreadyestablishedthose preconditions knowthat success is assured and therefore ignore the return value. \nWe.ndthat errorpathsandredundant error reportingdescribe82 outof97false positives.We considertheseremovablesince \nwe can recognize these unsafe patterns and provide additional information for the developer to decide \nabout their safety. The remaining 15 unavoidablefalse positives correspond to met preconditions.  5.4 \nPerformance Ourexperiments usea dual 3.2GHzIntelprocessorworkstation with 2.96 GB RAM. We divide the \nanalysis into three phases: (1) extracting a textual weighted pushdown representation of the kernelcode,(2) \nsolvingthepoststar query,and(3) .ndingbugsand traversing the witness information to produce diagnostic \noutput. Table4shows the sizes and the timerequiredto analyze each .le system. While turnaroundtimeis \nnotfast enoughforinterac\u00adtive use,the analysisisclearly suitable for regular usebykernel  developers \nusing widely-available hardware. Extracting the push\u00addown system (phase1)is quite cheap, asis traversingwitnesses \nto produce diagnostic output (phase3). Solvingthe poststar query (phase2)isthemostcostlyoperation,andisalsothe \noperationthat is most generic to WPDSs. Thus, futureimprovementsto this phase will further boost both \nthe performance of this speci.c tool as well asanynumberofother WPDS-basedanalyses. Furthermore,this \nphase involves the application of hundreds of thousands of semiring operations.Operationperformanceisgivenbytheweight \ndomain representation. The BDDrepresentation is known for already provid\u00ad ing a highlyef.cient implementation, \nhowever BDDperformance is notoriously .ckle; additionaltuning or alternateimplementations may yield substantial \nimprovements.  5.5 Other File Systems We have performed the analysis on 43 other Linux .le systems and \nveri.ed that it runs correctly. Together, these account for 250thousand additionallinesofkernel code(KLOC).However \nwe have not identi.ed recurring safe patterns, and therefore we refrain from reporting detailed results. \nOur implementation readily accommodates pattern changes with a modicum of OCaml coding. Wehavealsoanalyzeddifferent \nLinuxversions,and.ndthat.le system codeevolvessigni.cantlyin eachrelease.Thisdemonstrates that .xingthisclassofbugsis \nnota one-time operation. Rather, kernel developers need robust tools to ensure that existing error propagationbugs \nare.xed,and also that newbugs arenotintroduced as implementations change over time. TheNASA/JPLLaboratoryforReliable \nSoftwareis currently using our implementation to check code in the Mars Science Laboratory. JPL builds \nupon the VxWorks real-time operating system, notLinux,butwasabletotunethetool themselveswithout dif.culty.To \ndate ourtool has found one error-propagationbugin .ying code (code used for space missions): We ve found \nonelegitimateproblem....We calla non-void function(that canreturn some critical errorcodes) and don t \nassign the returnvalue, dropping some nicethings such as EASSERT, EABOUND, and EEBADHDR on the ground.We \nwouldhaveexpectedthe compileror[anothercode-checking tool]tocatchthat, actually...We regoingtorerunonabig \nupdate to the code, soon. [10] 6. Related work The problem of unchecked function return values is longstanding, \nand is seen as especially endemic in C due to the wide use of returnvaluestoindicate success orfailureofsystem \ncalls.LCLint staticallychecksforfunctioncallswhosereturnvalueisimmediately discarded[6],butdoesnottracethe.owof \nerrorsoverextended paths. GCC 3.4introduceda warn_unused_result annotation for functions whose return \nvalues should be checked, but again enforcementislimitedtothecallitself:storingthe resultinavariable \nthatis never subsequently usedis enoughto satisfyGCC. Neither LCLint norGCC analyzes deeplyenoughto uncoverbugs \nalong extended propagation chains. Itis temptingtoblamethisproblemonC,andargueforstruc\u00ad turedexception \nhandlinginstead. Language designsforexception managementhavebeen under considerationfordecades[8, 23]. \nSet\u00ad ting aside theimpracticalityof reimplementingexisting operating systemsinnew languages,staticveri.cationof \nproperexception managementhasitsown dif.culties.C++exception throwing decla\u00ad rations are explicitly checked \nat run time only, not at compile time. Java sinsistencethatmostexceptionsbe either caught orexplic\u00aditly \ndeclared as thrownis controversial[29, 30]. Frustrated Java programmers areknowntopacifythe compilerbyaddingblanket \ncatch clausesthat catchanddiscardallpossibleexceptions.C# imposesno staticvalidation;Sacramentoetal.[26]found \nthat 90% ofrelevantexceptionsthrownby.NET assemblies(C#libraries) are undocumented. Thus,whileexceptions \nchange the error propagation problem in interesting ways, theycertainly do not solve it. Numerous proposals \ndetect or monitor error propagation patterns at runtime,typically during controlled in-housetestingwithfault\u00ad \ninjection to elicitfailures[4, 7, 9, 13 17, 28].Workby Guoetal. [12]ondynamicabstracttypeinference couldbeusedtodistinguish \nerror-carryingvariables from ordinaryintegers,but this approach also requires running on real (error-inducing) \ninputs. In contrast to these dynamic techniques, our approach offers the stronger assurancesofstatic \nanalysis,which become especiallyimportant for critical softwarecomponents suchasoperatingsystemkernels. \nStorage errors are rare enough to be dif.cult to test dynamically, but can be catastrophic whentheydo \noccur.This is precisely the scenario in which intensive static analysis is most suitable. Gunawi etal.[11]highlight \nerrorcode propagationbugsin .le systemsasa specialconcern.Gunawi sproposedError Detection andPropagation \n(EDP) analysisis essentiallya type inferenceover the .le system s call graph, classifying functions as \ngenerators, propagators,orterminatorsoferror codes.Ourapproachusesamore precise analysisframeworkthatoffers \n.ow-and context-sensitivity. Thedifferenceis notmerelytheoretical: wehave compared thetwo in detailand \nwhileGunawi sEDP .nds 97% of ourtrue unsaved bugs,italso produces 2.75 times morefalse positives.Furthermore, \nEDP.nds nooverwrites andjust oneof our true out-of-scopebugs. EDP runsfaster, producing resultsina matterof \nseconds.However, it does not produce detailed diagnostic information; WPDS witness traces (Section 4) \noffer a level of diagnostic feedbacknot possible with EDP s whole-function-classi.cation approach. Bigrigg \nandVos[1]describe a data.ow analysis for detecting bugs in the propagation of errors in user applications. \nTheir ap\u00ad proachaugmentstraditional def-use chains withintermediatecheck operations: correct propagation \nrequires a check between each de.\u00ad nitionandsubsequent use.Thisissimilartoourtrackingoferror values from \ngenerationtoeventual handling or accidental discarding. Bigrigg andVosapplytheir analysis manually, whereas \nwehavea workingimplementationthatisinterprocedural, context-sensitive, andhasbeenappliedto516 thousandlinesofkernelcode. \nTheFiSCsystem ofYang et al.[32] uses software model checkingtocheckforanumberof .le-system-speci.cbugs.Relative \nto ourwork,FiSCemploysaricher(moredomain-speci.c)modelof .le system behavior, including properties of \non-disk representations. However, FiSC does not check for errorpropagationbugs and has been applied to \nonly three of Linux s many.le systems. 7. Conclusions We have designed and implemented an interprocedural, \n.ow-and context-sensitive static analysis for tracking the propagation of errors through .le systems. \nOur approach is based on a novel over\u00ad approximating counterpartto copyconstant propagation analysis, \nwith additionalspecializationsfor our unusual problem domain. The analysisis encoded asa WPDS, and poststar \nqueries on this system allow detailed diagnosisofavarietyof error mismanagementbugs. Wepresent six case \nstudies,including four widely-usedLinux .le systems and onerelatively new.lesystem.We .nd 312 nontrivial \nbugs.Falsepositivesarise,butmanyofthese canbeascribedto a small number of recurring unsafe patterns that \nshould also be amenableto automated analysis;weidentifyseveral suchpatternsin ourdetailedcase studies.We \nalso .ndthatthe same patternsrepeat among different .le system implementations. The unstructured natureofC \nerror reporting createsa signi.cant analysis challenge. Programmer intentis oftenimplicit,and our .ndings \nshow that current practice (manualinspection and testing) is insuf.cient. For good or ill, implementing \noperating systems  inCisalsopartofthestatusquo,andthisis unlikelyto change soon.Analyses such asthatwe \ndescribe here cangoalongway toward eliminating error propagation bugs. This increases the trustworthinessof \n.le systems and,inturn,ofcomputer systemsas a whole. Acknowledgments Weare gratefultothe anonymous reviewers \nfortheir constructive suggestions, andto NicholasKidd,Akash Lal, and ThomasW.Reps fortheirinvaluable \nWPDS support.Wethankdevelopers Andreas Dilger(ext4), SteveFrench (CIFS),DavidKleikamp (JFS), Jeff Mahoney(ReiserFS), \nand AlexD.Groce(JPL)fortheir prompt and insightful feedback on the reports produced by our tool. The \n.rst author also wishestothankthe NationalCouncil on Science and TechnologyofMexico and the SecretariatofPublic \nEducation for their .nancial support. References [1] M. W. Bigrigg and J. J. Vos. The set-check-use methodology \nfor detecting error propagationfailuresinI/O routines. In Workshop on Dependability Benchmarking,Washington, \nDC, June 2002. [2] R. E. Bryant. Binary decision diagrams and beyond: enabling tech\u00ad nologies for formal \nveri.cation. In R. L. Rudell, editor, ICCAD, pages 236 243. IEEE Computer Society, 1995. [3] D. Callahan. \nThe programsummary graph and.ow-sensitiveinterpro\u00adcedural data .ow analysis. In PLDI, pages 47 56, 1988. \n[4] G.Candea,M. Delgado,M. Chen, andA.Fox. Automaticfailure-path inference:Ageneric introspection technique \nforInternet applications. In Proceedingsofthe The ThirdIEEEWorkshop on Internet Applica- tions(WIAPP \n03), pages 132 141, San Jose,California, June 2003. IEEE. [5] A.Dilger. Error propagationbugsinext4. \nPersonal communication, Nov. 2008. [6] D. Evans. LCLint User s Guide. UniversityofVirginia,May 2000. \n[7] C. A. Flanagan and M. Burrows. System and method for dynamically detecting unchecked error condition \nvalues in computer programs. United StatesPatent #6,378,081B1,Apr. 2002. [8] J.B. Goodenough. Structuredexception \nhandling.In POPL, pages 204 224, 1975. [9] T. Goradia. Dynamicimpact analysis:Acost-effective technique \nto enforce error-propagation. In ISSTA, pages 171 181, 1993. [10] A. D. Groce. Problem solved. Personal \ncommunication, Jan. 2009. [11] H.S.Gunawi,C. Rubio-Gonz\u00e1lez,A.C. Arpaci-Dusseau,R.H.Arpaci- Dusseau, \nandB. Liblit. EIO:Error handlingis occasionally correct. In 6th USENIX Conference on File and Storage \nTechnologies (FAST 08), San Jose, California, Feb. 2008. [12] P.J. Guo,J.H. Perkins,S. McCamant,andM.D.Ernst. \nDynamic inference of abstract types. In L. L. Pollock and M. Pezz\u00e8, editors, ISSTA, pages 255 265.ACM, \n2006. [13] M. Hiller, A.Jhumka, andN. Suri. An approachfor analysing the propagation of data errors in \nsoftware. In DSN, pages 161 172.IEEE Computer Society, 2001. [14] M. Hiller, A. Jhumka, and N. Suri. \nPropane: an environment for examining the propagation of errors in software. In ISSTA, pages 81 85, 2002. \n[15] M. Hiller, A. Jhumka, and N. Suri. Epic: Pro.ling the propagation and effect of data errors in software. \nIEEETrans. Computers, 53(5): 512 530, 2004. [16] A. Jhumka, M. Hiller, and N. Suri. Assessing inter-modular \nerror propagationin distributed software. In SRDS, pages 152 161.IEEE Computer Society, 2001. [17] A.Johansson \nandN. Suri. Error propagation pro.ling of operating systems. In DSN, pages 86 95. IEEE Computer Society, \n2005. [18] N. Kidd,T.Reps, andA. Lal. WALi:AC++library forweighted pushdown systems. http://www.cs.wisc.edu/wpis/wpds/ \ndownload.php, 2008. [19] A.Lal,T.W.Reps, andG.Balakrishnan. Extended weighted pushdown systems. InK.Etessami \nand S. K. Rajamani, editors,CAV, volume 3576 of Lecture Notes in Computer Science, pages 434 448. Springer, \n2005. [20] A. Lal,N.Kidd,T.W. Reps, andT.Touili. Abstract error projection. In H.R. NielsonandG.Fil\u00e9,editors, \nSAS, volume 4634 of Lecture Notes in Computer Science, pages 200 217. Springer, 2007. [21] A. Lal,T.Touili,N.Kidd, \nandT.Reps. Interprocedural analysis of concurrent programs under a context bound. TechnicalReport1598, \nUniversityofWisconsin Madison,July 2007. [22] J. Lind-Nielsen. BuDDy -A Binary Decision Diagram Package. \nhttp://sourceforge.net/projects/buddy, 2004. [23] B.Liskov. Ahistory of CLU. InHOPLPreprints, pages 133 \n147, 1993. [24] G.C.Necula,S. McPeak,S.P. Rahul, andW.Weimer. CIL: Intermedi\u00ad ate language and toolsforanalysis \nandtransformationofCprograms. In R. N. Horspool, editor, CC, volume 2304 of Lecture Notes in Com\u00ad puter \nScience, pages 213 228. Springer, 2002. [25] T.W.Reps,S. Schwoon,S. Jha, andD. Melski.Weightedpushdown \nsystems andtheir applicationtointerprocedural data.ow analysis. Sci. Comput. Program., 58(1-2):206 263, \n2005. [26] P. Sacramento,B. Cabral, andP. Marques. Uncheckedexceptions: Cantheprogrammerbe trustedto \ndocumentexceptions?In Second International Conference on InnovativeViews of .NETTechnologies, Florian\u00f3polis, \nBrazil, Oct. 2006. Microsoft. [27] S. Schwoon. Model-Checking Pushdown Systems. PhDthesis,Techni\u00adcal \nUniv. of Munich, Munich, Germany, July 2002. [28] K.G.ShinandT.-H. Lin. Modelingand measurementof errorpropa\u00ad \ngation in a multimodule computing system. IEEETrans. Computers, 37(9):1053 1066, 1988. [29] Sun Microsystems, \nInc. Unchecked exceptions the contro\u00adversy. http://java.sun.com/docs/books/tutorial/ essential/exceptions/runtime.html, \nAug. 2007. [30] M. van Dooren and E. Steegmans. Combining the robustness of checked exceptions with the \n.exibility of unchecked exceptions using anchored exception declarations. In R. Johnson and R. P. Gabriel, \neditors, OOPSLA, pages 455 471.ACM, 2005. [31] M.N.WegmanandF.K. Zadeck.Constant propagationwith condi\u00adtional \nbranches. In POPL, pages 291 299, 1985. [32] J.Yang,P.Twohey,D.R. Engler, andM.Musuvathi. Usingmodel \nchecking to .nd serious .le system errors. ACM Trans. Comput. Syst., 24(4):393 423, 2006.    \n\t\t\t", "proc_id": "1542476", "abstract": "<p>Unchecked errors are especially pernicious in operating system file management code. Transient or permanent hardware failures are inevitable, and error-management bugs at the file system layer can cause silent, unrecoverable data corruption. We propose an interprocedural static analysis that tracks errors as they propagate through file system code. Our implementation detects overwritten, out-of-scope, and unsaved unchecked errors. Analysis of four widely-used Linux file system implementations (CIFS, ext3, IBM JFS and ReiserFS), a relatively new file system implementation (ext4), and shared virtual file system (VFS) code uncovers 312 error propagation bugs. Our flow- and context-sensitive approach produces more precise results than related techniques while providing better diagnostic information, including possible execution paths that demonstrate each bug found.</p>", "authors": [{"name": "Cindy Rubio-Gonz&#225;lez", "author_profile_id": "81435599688", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464291", "email_address": "", "orcid_id": ""}, {"name": "Haryadi S. Gunawi", "author_profile_id": "81100603773", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464292", "email_address": "", "orcid_id": ""}, {"name": "Ben Liblit", "author_profile_id": "81100555854", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464293", "email_address": "", "orcid_id": ""}, {"name": "Remzi H. Arpaci-Dusseau", "author_profile_id": "81100272389", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464294", "email_address": "", "orcid_id": ""}, {"name": "Andrea C. Arpaci-Dusseau", "author_profile_id": "81100272384", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464295", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542506", "year": "2009", "article_id": "1542506", "conference": "PLDI", "title": "Error propagation analysis for file systems", "url": "http://dl.acm.org/citation.cfm?id=1542506"}