{"article_publication_date": "06-15-2009", "fulltext": "\n Type-based Data Structure Veri.cation * Ming Kawaguchi Patrick Rondon Ranjit Jhala University of California, \nSan Diego University of California, San Diego University of California, San Diego mwookawa@cs.ucsd.edu \nprondon@cs.ucsd.edu jhala@cs.ucsd.edu Abstract We present a re.nement type-based approach for the static \nveri.ca\u00adtion of complex data structure invariants. Our approach is based on the observation that complex \ndata structures are typically fashioned from two elements: recursion (e.g., lists and trees), and maps \n(e.g., arrays and hash tables). We introduce two novel type-based mecha\u00adnisms targeted towards these \nelements: recursive re.nements and polymorphic re.nements. These mechanisms automate the chal\u00adlenging \nwork of generalizing and instantiating rich universal invari\u00adants by piggybacking simple re.nement predicates \non top of types, and carefully dividing the labor of analysis between the type system and an SMT solver \n[6]. Further, the mechanisms permit the use of the abstract interpretation framework of liquid type inference \n[22] to automatically synthesize complex invariants from simple logi\u00adcal quali.ers, thereby almost completely \nautomating the veri.ca\u00adtion. We have implemented our approach in DSOLVE, which uses liquid types to verify \nOCAML programs. We present experiments that show that our type-based approach reduces the manual anno\u00adtation \nrequired to verify complex properties like sortedness, bal\u00adancedness, binary-search-ordering, and acyclicity \nby more than an order of magnitude. Categories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: \nSoftware/Program Veri.cation; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning \nabout Pro\u00adgrams General Terms Languages, Reliability, Veri.cation Keywords Dependent Types, Hindley-Milner, \nPredicate Abstrac\u00adtion, Type Inference 1. Introduction Recent advances in Satis.ability Modulo Theories \n(SMT) solving, Model Checking and Abstract Interpretation have made it possible to build tools that automatically \nverify safety properties of large software systems. However, the inability of these tools to automati\u00ad \n* This work was supported by NSF CAREER grant CCF-0644361, NSF PDOS grant CNS-0720802, NSF Collaborative \ngrant CCF-0702603, and a gift from Microsoft Research. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PLDI 09, June 15 20, 2009, Dublin, Ireland. Copyright c &#38;#169; \n2009 ACM 978-1-60558-392-1/09/06. . . $5.00. cally reason about data structures severely limits the \nkinds of prop\u00aderties they can verify. The challenge of automating data structure veri.cation stems from \nthe need to reason about relationships between the unbounded number of values comprising the structure. \nIn SMT and theorem proving based approaches, manual effort is needed to help the prover to generalize \nrelationships over speci.c values into universal facts that hold over the structure, and dually, to instantiate \nquanti\u00ad.ed facts to obtain relationships over particular values. In model checking and abstract interpretation \nbased approaches, manual ef\u00adfort is needed to design, for each data structure, an abstract domain that \nis capable of generalizing and instantiating relevant relation\u00adships. Types provide a robust means for \nreasoning about coarse\u00adgrained properties of an unbounded number of values. For exam\u00adple, if a variable \nx is of the type int list, then we are guaranteed that every value in the list is an integer. Similarly, \nif a variable g is of the type (int, int) Map.t, then we are guaranteed that g is a hash-map where every \nkey is an integer that is mapped to another integer. Modern type systems automatically generalize such \nglobal properties from local properties of the individual values added to the structure, and dually, \nautomatically instantiate the properties when the structures are accessed. In this paper, we show how \ncoarse-grained types can be re.ned with simple, quanti.er-free predicates to yield a framework that is \nexpressive enough to enable the speci.cation of a variety of com\u00adplex data structure properties, yet \nstructured enough to enable au\u00adtomatic veri.cation and inference of the properties. We reconcile expressiveness \nand automation through two novel type re.nement mechanisms targeted towards the two elements from which \ncom\u00adplex structures are fashioned recursion (e.g., lists and trees) and maps (e.g., arrays and hash tables). \nThe .rst mechanism, recursive re.nements, allows the recursive type that encodes a structure to be re.ned \nwith a matrix of predi\u00adcates that individually re.ne the elements of the recursive type. Re\u00adcursive re.nements \nallow us to express uniform properties, for ex\u00adample that a list contains values greater than some program \nvariable i, abbreviated as {. :int | i <.} list. Further, by recursively propagating the matrix when \nthe type is folded or unfolded, the mechanism allows us to algorithmically analyze rich nested prop\u00aderties \nlike sortedness, distinctness and binary-search-ordering. The second mechanism, polymorphic re.nements, \nallows the polymorphic type schemes of map data types to be re.ned, enabling the types of stored values \nto depend on the keys used to access them. For example, the polymorphic re.nement type (i :a, \u00df) Map.t \ncorresponds to a hash-map where each key i has the (re.ned) type a, and is mapped to a value of type \n\u00df, which can depend on the key i. For example, (i :int, {. : int | i <.}) Map.t speci.es a hash-map where \neach integer key is mapped to a value greater than the key. Suppose that the edge-adjacency relation \nof a graph is represented as a hash\u00admap that maps each node s integer identi.er to its list of succes\u00adsors. \nThen, (i : int, {. : int | i <.} list) Map.t speci.es that the graph is acyclic, as each successor is \ngreater than its source. Our key insight is that, by piggybacking quanti.er-free re.ne\u00adment predicates \non top of types, the complementary strengths of types and SMT solvers can be harnessed to automatically \nverify data structures. The typing rules encode an algorithm for quanti.er generalization and instantiation, \nwhile subtyping reduces quanti\u00ad.ed relationships into quanti.er-free checks over simple predicates which \ncan then be ef.ciently discharged by an SMT solver. Fur\u00adther, we can use the abstract interpretation \nframework of liquid types [22] to automatically infer re.nements from a set of simple logical quali.ers, \nthereby eliminating the prohibitive cost of writ\u00ading type annotations for all functions and polymorphic \ninstantia\u00adtions. We have implemented recursive and polymorphic re.nements in DSOLVE, a tool that infers \nliquid types for OCAML pro\u00adgrams. We describe experiments using DSOLVE to verify a variety of complex \ndata structure invariants, including sorted\u00adness, balancedness, binary-search-ordering, variable ordering, \nset\u00adimplementation, heap-implementation, and acyclicity, on several benchmarks including textbook data \nstructures, such as sorted lists, union-.nd, splay heaps, AVL trees, red-black trees, and heavily\u00adused \nlibraries implementing stable sort, heaps, associative maps, extensible vectors, and binary decision \ndiagrams. Previously, the veri.cation of such properties required signi.cant manual anno\u00adtations in the \nform of loop invariants, pre-and post-conditions, and proof scripts totaling several times the code size. \nIn contrast, DSOLVE is able to verify complex properties using a handful of simple quali.ers amounting \nto 3% of the code size. 2. Overview We begin with an overview of our type-based veri.cation approach. \nFirst, we review simple re.nement and liquid types. Next, we describe recursive and polymorphic re.nements, \nand illustrate how they can be used to verify data structure invariants. Re.nement Types. Our system \nis built on the notion of re.ning ML types with predicates over program values that specify addi\u00adtional \nconstraints which are satis.ed by all values of the type [2, 9]. Base values, for example, those of type \ninteger (denoted int), can be described as {. :int | e} where . is a special value variable not appearing \nin the program, and e is a boolean-valued expression constraining the value variable called the re.nement \npredicate. In\u00adtuitively, the base re.nement predicate speci.es the set of values c of the base type B \nsuch that the predicate e[c/.] evaluates to true. For example, {. : int | . = n} speci.es the set of \nintegers whose value is less than or equal to the value of the variable n. We use the base re.nements \nto build up dependent function types, written x: T1.T2. Here, T1 is the domain type of the function, \nand the for\u00admal parameter x may appear in the base re.nements of the range type T2. For example, x: int.{. \n: int | x = .} is the type of a function that takes an input integer and returns an integer greater than \nthe input. Thus, the type int abbreviates {. :int | T}, where T and . abbreviate true and false respectively. \nLiquid Types. A logical quali.er is a boolean-valued expression (i.e., predicate) over the program variables, \nthe special value vari\u00adable . which is distinct from the program variables, and the special placeholder \nvariable * that can be instantiated with program vari\u00adables. We say that a quali.er q matches the quali.er \nq' if replacing some subset of the free variables in q with * yields q'. For example, the quali.er i \n= . matches the quali.er * = .. We write Q* for the set of all quali.ers not containing * that match \nsome quali.er in Q. In the rest of this section, let Qbe the quali.ers Q = {0 <., * = .}. A liquid type \nover Q is a dependent type where the re.nement predicates are conjunctions of quali.ers from Q*. We write \nliquid type when Q is clear from the context. We can automatically infer re.nement types by requiring \nthat certain expressions like recursive functions have liquid types [22]. Safety Veri.cation. Re.nement \ntypes can be used to statically prove safety properties by encoding appropriate preconditions into the \ntypes of primitive operations. For example, to prove that no divide-by-zero or assertion failures occur \nat run-time, we can type check the program using the types int.{. :int | . =0}.int and {. : bool | .}.unit \nfor division and assert respectively. 2.1 Recursive Re.nements The .rst building block for data structures \nis recursion, formalized using recursive types, which is used to fashion structures like lists and trees. \nThe key idea behind recursive re.nements is that recur\u00adsive types can be re.ned using a matrix of predicates, \nwhere each predicate applies to a particular element of the recursive type. For ease of exposition, we \nconsider recursive types whose body is a sum-of-products. Each product can be re.ned using a product \nre\u00ad.nement, which is a vector of predicates where the jth predicate re.nes the jth element of the product. \nEach sum-of-products (and hence the entire recursive type), can be re.ned with a recursive re\u00ad.nement, \nwhich is a vector of product re.nements, where the ith product re.nement re.nes the ith element of the \nsum. Uniform Re.nements. The ML type for integer lists is: \u00b5t.Nil + Cons(x1 : int,x2 :t) a recursive \nsum-of-products which we abbreviate to int list. We specify a list of integers each of which satis.es \na predicate p as (((); (p; T))) int list. For example, (((); (i = .; T))) int list speci.es lists of \nintegers greater than some program variable i. This representation reduces speci.cation and inference \nto determining which logical quali.ers apply at each position of the re.nement matrix. In the sequel, \nfor any expression e and relation N we de.ne the abbreviation .e as: .e= ((); (eN .; T)) (1) To see \nhow such uniform re.nements can be used for veri.ca\u00adtion, consider the program in Figure 1. The function \nrange takes two integers, i and j, and returns the list of integers i,..., j. The function harmonic takes \nan integer n and returns the n th (scaled) harmonic number. To do so, harmonic .rst calls range to get \nthe list of denominators 1,..., n, and then calls List.fold left with an accumulator to compute the harmonic \nnumber. To prove that the divisions inside harmonic are safe, we need to know that all the integers in \nthe list is are non-zero. Using Q, our system infers: range :: i :int.j :int.(.=i ) int list By substituting \nthe actuals for the formals in the inferred type for range, our system infers that the variable ds has \nthe type: (.1 As the polymorphic ML type for =) int list. List.fold left is .a, \u00df.(a.\u00df.a).a.\u00df list.a, \nour sys\u00adtem infers that, at the application to List.fold left inside harmonic, a and \u00df are respectively \ninstantiated with int and {. :int | 0 <.}, and hence, that the accumulator has the type: s :int.k :{. \n: int | 0 <.}.int As k is strictly greater than 0, our system successfully typechecks the application \nof the division operator /, proving the program di\u00advision safe . Hence, by re.ning the base types that \nappear inside re\u00adcursive types, we can capture invariants that hold uniformly across all the elements \nwithin the recursively de.ned value. Nested Re.nements. The function range returns an increasing se\u00adquence \nof integers. Recursive re.nements can capture this invariant rec range i j = if i > j then [] else let \nis = range (i+1) i::is harmonic n = let ds = range 1 n in List.fold_left j in (fun s k -> s + 10000/k) \n0 ds let rec insert x ys = match ys with | [] -> [x] | y::ys -> if x < y then x::y::ys else y::(insert \nx ys ) let rec insertsort xs = match xs with | [] -> [] | x::xs -> insert x (insertsort xs ) let fib \ni = let rec f t0 n = if mem t0 n then (t0, get t0 n) else if n <= 2 then (t0, 1) else let (t1,r1) = f \nt0 (n-1) in let (t2,r2) = f t1 (n-2) in let r = r1 + r2 in (set t2 n r, r) in snd (f (new 17) i) let \nrec build_dag (n, g) = let node = random () in if (0>node || node>=n) then (n, g) else let succs = get \ng node in let succs = (n+1)::succs in let g = set g node succs in build_dag (n+1, g ) let g0 = set (new \n17) 0 [] let (_,g1) = build_dag (1, g0) Figure 1. Divide-by-zero Figure 2. Insertion Sort Figure 3. Memoization \nFigure 4. Acyclic Graph let let by applying the recursive re.nement to the \u00b5-bound variables in\u00adside \nthe recursive type. For each type t de.ne: . t list= = \u00b5t.Nil + Cons(x1 :t,x2 :(.x1 ) t) (2) = Thus, \na list of increasing integers is int list=. This succinctly captures the fact that the list is increasing, \nsince the result of unfolding the type by substituting each occurrence of t with the entire recursively \nre.ned type is: 1 Nil + Cons(x1 ' : int,x 2 ' :(.x) int list=) = where x1' ,x 2 ' are fresh names introduced \nfor the top-level head and tail . Intuitively, this unfolded sum type corresponds to a value that is \neither the empty list or a cons of a head x1 ' and a tail which is an increasing list of integers greater \nthan x ' 1. For inference, we need only .nd which quali.ers .ow into the recursive re.nement matrices. \nUsing Q, our system infers that range returns an increasing list of integers no less than i: range :: \ni : int.j : int.(.=i ) int list= As another example, consider the insertion sort function from Figure \n2. In a manner similar to the analysis for range, using just Q, and no other annotations, our system \ninfers that insert has the type x : a.ys :a list=.a list=, and hence that program cor\u00adrectly sorts lists. \nFurthermore, the system infers that insertsort has the type xs :a list.a list=. Structure Re.nements. \nSuppose we wish to check that insertsort s output list has the same set of elements as the in\u00adput list. \nWe .rst specify what we mean by the set of elements of the list using a measure, an inductively-de.ned, \nterminating func\u00adtion that we can soundly use in re.nements. The following speci.es the set of elements \nin a list: measure elts = [] -> empty | x::xs -> union (single x) (elts xs) where empty, union and single \nare primitive constants corre\u00adsponding to the respective set values and operations. Using just the measure \nspeci.cation and the SMT solver s decidable theory of sets our system infers that insertsort has the \ntype: xs :a list.{. :a list= | elts . = elts xs} i.e., the output list is sorted and has the same elements \nas the input list. In Section 6 we show how properties like balancedness can be veri.ed by combining \nmeasures (to specify heights) and recursive re.nements (to specify balancedness at each level).  2.2 \nPolymorphic Re.nements The second building block for data structures is .nite maps, such as arrays, vectors, \nhash tables, etc. The classical way to model maps is using the array axioms [15], and by using algorithmically \nproblematic, universally quanti.ed formulas to capture properties over all key-value bindings. Polymorphic \nre.nements allow the implicit representation of universal map invariants within the type system and provide \na strategy for generalizing and instantiating quanti.ers in order to verify and infer universal map invariants. \n To this end, we extend the notion of parametric polymorphism to include re.ned polytype variables and \nschemas. Using poly\u00admorphic re.nements, we can give a polymorphic map the type (i :a, \u00df) Map.t. Intuitively, \nthis type describes a map where ev\u00adery key i of type a is mapped to a value of type \u00df and \u00df can refer \nto i. For example, if we instantiate a and \u00df with int and {. :int | 1 <. . i - 1 <.}, respectively, the \nresulting type de\u00adscribes a map from integer keys i to integer values strictly greater than 1 and i - \n1. Memoization. Consider the memoized .bonacci function fib in Figure 3. The example is shown in the \nSSA-converted style of Ap\u00ad pel [1], with t0 being the input name of the memo table, and t1 and t2 the \nnames after updates. To verify that fib always returns a value greater than 1 and (the argument) i - \n1, we require the universally quanti.ed invariant that every key j in the memo table t0 is mapped to \na value greater than 1 and j - 1. Using the quali\u00ad.ers {1 = ., * - 1 = .}, our system infers that the \npolytype vari\u00adables a and \u00df can be instantiated as described above, and so the map t0 has type (i : int, \n{. : int | 1 = . . i - 1 = .}) Map.t, i.e., every integer key i is mapped to a value greater than 1 and \ni - 1. Using this, the system infers that fib has type i :int.{. :int | 1 = . . i - 1 = .}. Directed \nGraphs. Consider the function build dag from Fig\u00adure 4, which represents a directed graph with the pair \n(n, g) where n is the number of nodes of the graph, and g is a map that encodes the link structure by \nmapping each node, an integer less than n, to the list of its directed successors, each of which is also \nan inte\u00adger less than n. In each iteration, the function build dag randomly chooses a node in the graph, \nlooks up the map to .nd its successors, creates a new node n +1 and adds n +1 to the successors of the \nnode in the graph. As each node s successors are greater than the node, there can be no cycles in the \ngraph. Using just the quali.ers {. = *,* < .} our system infers that the function build dag in\u00adductively \nconstructs a directed acyclic graph. Formally, the system infers that g1 has type . DAG =(i : int, (((); \n(i <.; T))) int list) Map.t (3) which speci.es that each node i has successors that are strictly greater \nthan i. Thus, by combining recursive and polymorphic re\u00ad.nements over simple quanti.er-free predicates, \nour system infers complex shape invariants about linked structures. 3. Language We begin by reviewing \nthe core language NanoML from [22], by presenting its syntax and static semantics. NanoML has a strict, \ncall-by-value semantics, formalized using a small-step operational e ::= Expressions: | x variable | \nc constant | .x.e abstraction | xx application | if e then e else e if-then-else | let x = e in e let-binding \n| fix x.e .xpoint | [.a]e type-abstraction | [t]e type-instantiation Q ::= Liquid Re.nements |T true \n| q quali.er in Q* | Q . Q conjunction B ::= Base: | int integers | bool booleans | a type variable A(B) \n::= Unre.ned Skeletons: | B base | x:T(B).T(B) function T(B) ::= Re.ned Skeletons: |{. :A(B) | B} re.ned \ntype S(B) ::= Type Schema Skeletons: | T(B) monotype |.a.S(B) polytype t, s ::= T(T), S(T) Types, Schemas \nT,S ::= T(E), S(E) Depend. Types, Schemas T, S ::= T(Q), S(Q) Liquid Types, Schemas Figure 5. NanoML: \nSyntax semantics [21]. In Sections 4 and 5, we extend NanoML with recursive and polymorphic re.nements \nrespectively. Expressions. The expressions of NanoML, summarized in Fig\u00adure 5, include variables, primitive \nconstants, .-abstractions and function application. In addition, NanoML has let-bindings and recursive \nfunction de.nitions using the .xpoint operator fix. Our type system conservatively extends ML-style parametric \npolymor\u00adphism. Thus, we assume that the ML type inference algorithm au\u00adtomatically places appropriate \ntype generalization and instantiation annotations into the source expression. Finally, we assume that, \nvia a-renaming, each variable is bound at most once in an environment. Types and Schemas. NanoML has \na system of base types, function types, and ML-style parametric polymorphism using type variables a and \nschemas where the type variables are quanti.ed at the out\u00adermost level. We organize types into unre.ned \ntypes, which have no top-level re.nement predicates, but which may be composed of types which are themselves \nre.ned, and re.ned types, which have a top-level re.nement predicate. An ML type (schema) is a type (schema) \nwhere all the re.nement predicates are T.A liquid type (schema) is a type (schema) where all the re.nement \npredicates are conjunctions of quali.ers from Q*. We write t and s for ML types and schemas, T and S \nfor re.nement types and schemas, and T and S for liquid types and schemas. We write t to abbreviate {. \n:t | T}, and t to abbreviate {. :t | .}. When t is clear from context, we write {e} to abbreviate {. \n: t | e}. Instantiation. We write Ins(S, a, T ) for the instantiation of the type variable a in the scheme \nS with the re.ned type T . Intuitively, Ins(S, a, {. :T ' | e ' }) is the re.ned type obtained by replacing \neach occurrence of {. :a | e} in S with {. :T ' | e . e ' }. Constants. The basic units of computation \nin NanoML are primi\u00adtive constants, which are given re.nement types that precisely cap\u00adture their semantics. \nPrimitive constants include basic values, like integers and booleans, as well as primitive functions \nthat de.ne ba\u00adsic operations. The input types for primitive functions describe the values for which each \nfunction is de.ned, and the output types de\u00adscribe the values returned by each function. Next, we give \nan overview of our static type system, by describing environments and summarizing the different kinds \nof judgments. Environments and Shapes. A type environment G is a sequence of type bindings of the form \nx:S and guard predicates e. The guard predicates are used to capture constraints about path information \ncorresponding to the branches followed in if-then-else expressions. The shape of a re.nement type schema \nS, written as Shape(S), is the ML type schema obtained by replacing all the re.nement predicates with \nT (i.e., erasing the re.nement predicates). The shape of an environment is the ML type environment obtained \nby applying Shape to each type binding and removing the guards. Judgments. Our system has four kinds \nof judgments that relate environments, expressions, recursive re.nements and types. Well\u00adformedness judgments \n(G h S) state that a type schema S is well\u00adformed under environment G. Intuitively, the judgment holds \nif the re.nement predicates of S are boolean expressions in G. Subtyping judgments (G h S1 <: S2) state \nthat the type schema S1 is a subtype of the type schema S2 under environment G. Intuitively, the judgments \nstate that, under the value-binding and guard constraints imposed by G, the set of values described by \nS1 is contained in the set of values described by S2. Typing judgments (G hQ e :S) state that, using \nthe logical quali.ers Q, the expression e has the type schema S under environment G. Intuitively, the \njudgments state that, under the value-binding and guard constraints imposed by G, the expression e will \nevaluate to a value described by the type S. Decidable Subtyping and Liquid Type Inference. In order \nto determine whether one type is a subtype of another, our system uses the subtyping rules (Figure 6) \nto generate a set of implication checks over re.nement predicates. To ensure that these implica\u00adtion \nchecks are decidable, we embed the implication checks into a decidable logic of equality, uninterpreted \nfunctions, and linear arithmetic (EUFA) that can be decided by an SMT solver [6]. As the types of branches, \nfunctions, and polymorphic instantiations are liquid, we can automatically infer liquid types for programs \nusing abstract interpretation [22]. Soundness. We have proven the soundness of the type system by showing \nthat if an expression is well-typed then we are guaranteed that evaluation does not get stuck , i.e., \nat run-time, every primi\u00adtive operation receives valid inputs. We defer the details about the judgments, \nthe proof of soundness, and type inference to [21]. 4. Recursive Re.nements We now describe how the core \nlanguage is extended with recur\u00adsively re.ned types which capture invariants of recursive data struc\u00adtures. \nFirst, we describe how we extend the syntax of expressions and types, and correspondingly extend the \ndynamic semantics. Sec\u00adond, we describe measures, a special class of functions that are syntactically \nguaranteed to terminate, thereby allowing us to use them to re.ne recursive types with predicates that \ncapture struc\u00adtural properties of recursive values. Finally, we extend the static type system by formalizing \nthe derivation rules that deal with re\u00adcursive values, and illustrate how the rules are applied to check \nexpressions. 4.1 Syntax and Dynamic Semantics Figure 7 describes how the expressions and types of NanoML \nare extended to include recursively-de.ned values. The language of expressions includes tuples, value \nconstructors, folds, unfolds, and pattern-match expressions. The language of types is extended with \nWell-Formed Types G f S Shape(T )= T [WF-REFLEX] G f T G f T G; . :Shape(T ) f e : bool [WF-REFINE] G \nf{. : T | e} G f T G; x: Shape(T ) f T [WF-FUN] G f x : T .T Decidable Subtyping G f S1 <: S2 [<:-REFLEX] \nG f T<: T G f T<: T Valid([[G]] . [ e] . [ e ]]) [<:-REFINE] G f{. : T | e} <: {. : T | e } G f T2 <: \nT1 G; x2 : T2 f T1[x2/x1] <: T2 [<:-FUN] G f x1 : T1.T1 <: x2 : T2.T2 Liquid Type Checking G fQ e : S \nG fQ e : S G f S<: S G fQ S [L-SUB] G fQ e : S G(x)= {. : T | e} [L-VAR] [L-CONST] G fQ x : {. :T | e \n. . = x} G fQ c : ty(c) G f x :T x.T G; x :T x fQ e : T [L-FUN] G fQ (.x.e): x : T x.T G fQ x1 : x:T \n.T G fQ x2 : T [L-APP] G fQ x1 x2 : T [x2/x] G f T G fQ e1 : bool G; e1 fQ e2 : T G; \u00ace1 fQ e3 : T [L-IF] \n G fQ if e1 then e2 else e3 : T G f T G fQ e1 : S1 G; x: S1 fQ e2 : T [L-LET] G fQ let x = e1 in e2 \n: T G f S G; x: S fQ e : S [L-FIX] G fQ fix x.e : S G fQ e : Sa . G [L-GEN] G fQ [.a]e : .a.S G f T Shape(T \n)= t G fQ e : .a.S [L-INST] G fQ [t]e : Ins(S, a, T ) Figure 6. Liquid Type Checking Rules product types, \ntagged sum types, and a system of iso-recursive types. We assume that appropriate fold and unfold annotations \nare automatically placed in the source at the standard construction and matching sites, respectively \n[19]. We assume that different types use disjoint constructors, and that pattern match expressions contain \nexactly one match binding for each constructor of the appropriate type. The run-time values are extended \nwith tuples, tags and explicit fold/unfold values in the standard manner [19]. Notation. We write (Z) \nfor a sequence of values of the kind Z. We write (Z; (Z)) for a sequence of values whose .rst element \nis Z, and the remaining elements are (Z). We write () for the empty sequence. As for functions, we write \ndependent tuple types using a sequence of name-to-type bindings, and allow re.nements for later elements \nin the tuple to refer to previous elements. For e ::= . . . Expressions: | (e) tuple | C (e) constructor \n| match e with |i Ci(xi) . ei match-with | unfold e unfold | fold e fold e ::= m | c | x | e e M-Expressions \nM ::= (m, (Ci(xi) . ei), t, \u00b5t.SiCi(xi :ti)) Measures .(B) ::= ((B)*)* Recursive Re.nement A(B) ::= . \n. . Unre.ned Skeletons: | (x : T(B)) product | SiCi(x: T(B)) sum | (.(B)) t recursive type variable | \n(.(B)) \u00b5t.SiCi(x:T(B)) recursive type Figure 7. Recursive Re.nements: Syntax example, (x1 : int; x2 \n:{. : int | x1 = .}) is the type of pairs of integers where the second element is greater than the .rst. \nMeasures. Many important attributes of recursive structures, e.g., the length or set of elements of a \nlist, or the height of a tree, are most naturally speci.ed using recursive functions. Unfortunately, \nthe use of arbitrary, potentially non-terminating recursive functions in re.nement predicates leads to \nunsoundness. Thus, we cannot use re.nements containing arbitrary functions to encode invariants over \nrecursive attributes. We solve this problem by representing recursively-de.ned attributes using measures, \na class of .rst order functions from the recursive type to any range type. Measures are syntactically \nguaranteed to terminate, and so we can soundly use them inside re.nements. Further, because their domain \nis the recur\u00adsive type, we can automatically instantiate them at the appropriate fold and unfold expressions. \nFigure 7 shows the syntax of measure functions. A measure name m is a special variable drawn from a set \nof measure names. A measure expression e is an expression drawn from a restricted language of variables, \nconstants, measure names and application. A measure for a recursive (ML) type \u00b5t.SiCi(xi : ti) of type \nt is a quadruple: (m, (Ci(xi) . ei), t, \u00b5t.SiCi(xi :ti)).A measure speci.cation is an ordered sequence \nof measures. Figure 8 shows the rules used to check that a measure speci.cation (i.e., (M)) is well-formed \n(i.e., \u00d8h(M)). As measures are de.ned by structural induction, they are well-founded and hence total. \n 4.2 Static Semantics The derivation rules pertaining to recursively re.ned types, includ\u00ading the rules \nfor product, sum, and recursive types, as well as construction, match-with, fold and unfold expressions \nare shown in Figure 8. The fold and unfold rules use a judgment called .\u00adapplication, written (.) T NT \n'. Intuitively, this judgment states that when a recursive re.nement . is applied to a type T , the result \nis a sum type T ' with re.nements from .. Next, we describe each judgment and the rules relevant to it. \n.-Application and Unfolding. Formally, a recursive type (.) \u00b5t.T is unfolded in two steps. First, we \napply the recursive re.nement . to the body of the recursive type T to get the result T ' (writ\u00adten (.) \nT NT '). Second, in the result of the application T ' , we replace the \u00b5-bound recursive type variable \nt with the entire origi\u00adnal recursive type ((.) \u00b5t.T ), and normalize by replacing adjacent re.nements \n(.)(. ' ) with a new re.nement . '' which contains the conjunctions of corresponding predicates from \n. and . ' . Example. Consider the type which describes increasing lists of integers greater than some \nx1' : (. x= 1 ) \u00b5t.Nil + Cons(x1 : int,x2 :(.x= 1 ) t)  Measure Well-formedness G f(M) G; m : \u00b5t.SiCi(xi \n: ti).t f(M) .i : G; m : \u00b5t.SiCi(xi : ti).t; (xi :ti)f ei : t [WF-M] G f (m, (Ci(xi) . ei), t, \u00b5t.SiCi(xi \n:ti)); (M) .-Application (.) Tr T fresh x ((e)[x /x]) (x : T [x /x]) r (x : T ) [t-PROD] (e; (e))(x: \n{. : T | ex}; (x : T )) r (x :{. :T | e . ex}; (x : T )) .i :(.i) (xi :Ti) r (xi : Ti ) [t-SUM] (.)SiCi(xi \n:Ti) r SiCi(xi :Ti ) Well-Formed Types G f S G f T G; x : Shape(T ) f(x:T ) [WF-PROD] G f x : T ; (x: \nT ) .i :G f(xi : Ti) [WF-SUM] G f SiCi(xi : Ti) (.) Tr T G f T [Shape(\u00b5t.T )/t] [WF-REC] G f (.) \u00b5t.T \nDecidable Subtyping G f S1 <: S2 G f T<: T G; x: T f(x :T ) <: (x : T [x/x ]) [<:-PROD] G f x: T ; (x \n:T ) <: x : T ; (x :T ) .i :G f(xi :Ti) <: (xi : Ti ) [<:-SUM] G f SiCi(xi : Ti) <:SiCi(xi :Ti ) (.1) \nT1 rT1 (.2) T2 rT2 t = Shape(\u00b5t.T1)= Shape(\u00b5t.T2) G f T1[t/t] <: T2[t/t] [<:-REC] G f (.1) \u00b5t.T1 <:(.2) \n\u00b5t.T2 Liquid Type Checking G fQ e : S G f ( .) \u00b5t. (.) T T Tr G fQ e : {. : T [( T /t] | e } .) \u00b5t. \n[L-FOLD-M] G fQ fold e : {. :( .) \u00b5t.T | e } (.) Tr T G f e : {. :(.) \u00b5t.T | e } [L-UNFOLD-M] G f unfold \ne : {. :T [(.) \u00b5t.T /t] | e } G fQ (e) : (x:T ) [L-SUM-M] G fQ Cj(e) : {. :Cj (x: T ) +Si= j Ci(xi : \nti)|.mm(.)= ej((e))} G f e :SiCi(xi :Ti) G f T .i G; (xi : Ti); .mm(e)= ei((xi)) f ei : T  [L-MATCH-M] \n G f match e with |Ci(xi) . ei : T i Figure 8. Recursive Re.nements: Static Semantics To unfold this \ntype, we .rst apply the recursive re.nement .= x1 to the recursive type s body, Nil + Cons(x1 :int,x2 \n:(.x1 )t). To = apply the recursive re.nement to the above sum type, we use rule [N-SUM] to apply the \nproduct re.nements () and (x1 ' = .; T) of .= x1 to the products corresponding to the Nil and Cons construc\u00adtors, \nrespectively. To apply the re.nements to each product, we use the rule [N-PROD] to obtain the result: \n'' ''' x1 Nil + Cons(x1 :{. : int | x1 = .},x 2 :(.)t) (4) = Notice that the result is a sum type with \nfresh names for the head and tail of the unfolded list. Observe that this renaming allows us to soundly \nuse the head s value to re.ne the tail, via a recursive re.nement stipulating all elements in the tail \nare greater than the '' head, x1 . To complete the unfolding, we replace t with the entire recursive \ntype and normalize to get: '' ''' Nil + Cons(x1 : {. :int | x1 = .},x 2 :(.) int list=). ' '' where \n. = ((); (x1 = . . x1 = .; T)). Intuitively, the result of the unfolding is a type that speci.es an empty \nlist, or a non\u00adempty list with a head greater than x1 ' and an increasing tail whose ' '' elements are \ngreater than x1 and x1 . Well-formedness. Rule [WF-REC] checks if a recursive type (.) \u00b5t.T is well-formed \nin an environment G . First, the rule applies the re.nement . to T , the body of the recursive type, \nto obtain T ' . Next, the rule replaces the \u00b5-bound variable t in T ' with the shape of the recursive \ntype and checks the well-formedness of the result of the substitution. . Example. When .T = ((); (T; \nT)), the check \u00d8h (.T) \u00b5t.Nil + Cons(x1 :int,x2 :(.x1 ) t) = is reduced to checking, using [WF-REFINE] \nthat in the environ\u00adment where x1 ' (the fresh name given to the unfolded list s head ) has type int, \nthe re.nement {. :int | x1 ' = .} (applied to the el\u00adements of the unfolded list s tail ) is well-formed. \nSubtyping. Rule [<:-PROD] (resp. [<:-SUM]) determines whether two products (resp. sums) satisfy the subtyping \nrelation by checking subtyping between corresponding elements. . ' Example. When G= x1 : int, the check \nG h(y1 :{x1 ' <.},y2 : int list) <: (z1 :{x1 ' = .},z2 :int list) (5) is reduced by [<:-PROD] to: G h{. \n: int | x1 ' <.} <: {. :int | x1 ' = .} G; y1 :int hint list <: int list [<:-REFLEX] ensures the latter. \n[<:-REFINE] reduces the former to checking the validity of x1 ' <. . x1 ' = . in EUFA. Rule [<:-REC] \ndetermines whether the subtypingrelationholds between two recursively re.ned types. The rule .rst applies \nthe outer re.nements to the bodies of the recursive types, then substi\u00adtutes the \u00b5-bound variable with \nthe shape (as for well-formedness), and then checks that the resulting sums are subtypes. Example. Consider \nthe subtyping check ' x1 x1 x1 : int h(.< ) int list <:(. ) int list (6) = that is, the list of integers \ngreater than x1 ' is a subtype of the list of integers distinct from x1' . Rule [<:-REC] applies the \nre.nements to the bodies of the recursive types and then substitutes the shapes, reducing the above (after \nusing [<:-SUM], [<:-PROD] and [<:-REFLEX]) to (5). Finally, applying the rule [<:-REC] yields the judgment \n\u00d8hint list< <: int list (7) = . int list< =(.T) \u00b5t.Nil + Cons(x1 : int,x2 :(.x1 ) t) < . int list =(.T) \n\u00b5t.Nil + Cons(x1 : int,x2 :(.x1) t) = = that is, that the list of strictly increasing integers is a \nsubtype of the list of distinct integers. To see why, observe that after apply\u00ading the trivial top-level \nrecursive re.nement .T to the body, sub\u00adstituting the shapes, and applying the [<:-SUM], [<:-PROD] and \n[<:-REFLEX] rules, the check reduces to (6). Local Subtyping. Our recursive re.nements represent universally \nquanti.ed properties over the elements of a structure. Hence, we re\u00adduce subtyping between two recursively-re.ned \nstructures to local subtype checks between corresponding elements of two arbitrarily chosen values of \nthe recursive types. The judgment [<:-REC] car\u00adries out this reduction via .-application and unfolding \nand enforces the local subtyping requirement with the .nal antecedent. Typing. We now turn to the rules \nfor type checking expressions. Rules [L-UNFOLD-M] and [L-MATCH-M] describe how values extracted from \nrecursively constructed values are type checked. First, [L-UNFOLD-M] is applied, which performs one unfolding \nof the recursive type, as described above. Second, the rule [L-MATCH-M] is used on the resulting sum \ntype. This rule stipulates that the entire expression has some type T if the type is well-formed in the \ncurrent environment, and that, for each case of the match (i.e., for each element of the sum), the body \nexpression has type T in the environment extended with: (a) the corresponding match bindings and (b) \nthe guard predicate that captures the relationship between the measure of the matched expression and \nthe variables bound by the matched pattern. Example. Consider the following function: let rec sortcheck \nxs = match xs with | x::(x ::_ as xs ) -> assert (x <= x ); sortcheck xs | _ -> () Let G be xs :a list=. \nFrom rule [L-UNFOLD], we have G hQunfold xs : Nil + Cons(x :a; xs ' :(.x =) a list=) For clarity, we \nassume that the fresh names are those used in the match-bindings. For the Cons pattern in the outer match, \nwe use the rule [L-MATCH-M] to get the environment G ', which is G extended with x :a, xs ' :(.x =) a \nlist=. Thus, [L-UNFOLD] yields '' '' G ' hQunfold xs : Nil + Cons(x :{. : a | x = .}; xs : ...) Hence, \nin the environment: xs : a list=; x : a; xs ' :(.x x ' =) a list=;:{. : a | x = .} which corresponds \nto the extension of G ' with the (inner) pattern\u00admatch bindings, the argument type {. = x = x ' } is \na subtype of the input type {.} and system veri.es that the assert cannot fail. Rules [L-SUM-M] and [L-FOLD-M] \ndescribe how recursively constructed values are type checked. First, [L-SUM-M] is applied, which uses \nthe constructor Cj to determine which sum type the tu\u00adple should be injected into. Notice that, in the \nresulting sum: (a) the re.nement predicate for all other sum elements is ., capturing the fact that Cj \nis the only inhabited constructor within the sum value, and (b) for each measure m de.ned for the corresponding \nrecur\u00adsive type, a predicate specifying the value of the measure m is con\u00adjoined to the re.nement for \nthe constructed sum. Second, the rule [L-FOLD-M] folds the (sum) type into a recursive type. Example. \nConsider the expression Cons(i, is) which is returned by the function range from Figure 1. Let . G= i \n: int; is :(.i+1) int list=. Rule [<:-REFINE] yields: = G; x1 ' :{i = .} h{i +1 = .} <: {x1 ' = . . i \n= .} Consequently, using the rules for subtyping, we derive: ' i+1 ' G; x1 :{i = .}h(.) int list= <:(. \n) int list= (8) = where . ' is ((); (x1 ' = . . i = .; T)). Using [L-PROD]: ' '' G hQ(i, is): (x1 : {i \n= .}; x2 :(. ) int list=) and so, using the subsumption rule [L-SUB] and (8) we have: ' '' G hQ(i, is): \n(x1 : {i = .}; x2 :(. ) int list=) i.e., the .rst element of the pair is greater than i and the second \nelement is an increasing list of values greater than than the .rst element and i. Thus, applying [L-SUM], \nwe get: ' '' G hQ Cons(i, is): Nil + Cons (x1 :{i = .}; x2 :(. ) int list=) As (.i =) int list= unfolds \nto the above type, [L-FOLD] yields G hQ fold(Cons(i, is)) : (.=i ) int list= i.e., range returns an \nincreasing list of integers greater than i. Example: Measures. Next, let us type check the below expression \nusing the elts measure speci.cation from Section 2. leta=[]in let b=1::a in match b with x::xs -> () \n| [] -> assert false Using [L-SUM-M] and [L-FOLD-M] (and [L-LET]), we derive: \u00d8hQNil : {elts . = empty} \na : {elts . = empty}hQCons(1, a): T1::a where T1::a abbreviates {elts . = union (single 1)(elts a)}. \nDue to [L-UNFOLD-M] and [L-MATCH-M], the assert in the Nil pattern-match body is checked in an environment \nG containing a :{elts . = empty}, b :T1::a and the guard (elts b = empty) from the de.nition of elts \nfor Nil. Under this inconsistent G, the argument type {not .} is a subtype of the input type {.} and \nso the call to assert type checks, proving the Nil case is not reachable. 4.3 Type Inference Next, we \nsummarize the main issues that had to be addressed to extend the liquid type inference algorithm of [22] \nto the setting of recursive re.nements. For details, see [21]. Polymorphic Recursion. Recall the function \ninsert from Fig\u00adure 2. Suppose that ys is an increasing list, i.e., it has the type a list=. In the case \nwhen ys is not empty, and x is not less than y, the system must infer that the list Cons(y, insert x \nys ' ) is an increasing list. To do so, it must reason that the recursive call to insert returns a list \nof values that are (a) increasing and, (b) greater than y. Fact (a) can be derived from the (inductively \nin\u00adferred) output type of insert. However, fact (b) is speci.c to this particular call site y is not \neven in scope at other call sites, or at the point at which insert is de.ned. Notice, though, that the \nbranch condition at the recursive call tells us that the .rst param\u00adeter passed to insert, namely, x, \nis greater than y. As y and ys ' are the head and tail of the increasing list ys, we know also that every \nelement of ys ' is greater than y. The ML type of insert is .a.a.a list.a list. By instantiating a at \nthis call site with {. :a | y = .}, we can deduce fact (b). This kind of reasoning is critical for establishing \nrecursive prop\u00aderties. In our system it is formalized by the combination of [L-INST], a rule for dependent \npolymorphic instantiation, and [L-FIX], a dependent version of Mycroft s rule [16] that allows the instantiation \nof the polymorphic type of a recursive function within the body of the function. Although Mycroft s rule \nis known to render ML type inference undecidable [11], this is not so for our system, as it conservatively \nextends the ML type system. In other words, since only well-typed ML programs are typable in our sys\u00adtem, \nwe can use Milner s rule to construct an ML type derivation tree in a .rst pass, and subsequently use \nMycroft s rule and the generalized types inferred in the .rst pass to instantiate dependent types at \n(polymorphic) recursive call sites. Conjunctive Templates. Recall from Section 3 that polymorphic instantiation \nusing Ins (rule [L-INST]) results in types whose re\u00ad.nements are a conjunction of the re.nements applied \nto the orig\u00adinal type variables (i.e., a) within the scheme (i.e., S) and the top\u00adlevel re.nements applied \nto the type used for instantiation (i.e., T ). B ::= ... Base: | a[y/x] re.ned polytype variable S(B) \n::= ... Type Schema Skeletons: |.a(x : t).S(B) re.ned polytype schema Well-Formed Types G f S a(x :t). \nGG f y : t [WF-REFVAR] G f a[y/x] G; a(x: t)f S [WF-REFPOLY] G f.a(x : t).S Decidable Subtyping G f S1 \n<: S2 a(x: t). GG f{. : t | . = y1} <: {. : t | . = y2} [<:-REFVAR] G f a[y1/x] <: a[y2/x] G; a(x :t)f \nS1 <: S2 [<:-REFPOLY] G f.a(x: t).S1 <: .a(x: t).S2 Liquid Type Checking G fQ e : S G; a(x: t)fQ e : \nSa(x : t) . G [L-REFGEN] G fQ [.a(x :t)]e : .a(x:t).S G; x : tx f T Shape(T )= t G fQ e : .a(x: tx).S \n[L-REFINST] G fQ [t]e : Ins(S, a, T ) Figure 9. Polymorphic Re.nements: Syntax, Static Semantics Similarly, \nthe normalizing of recursive re.nements (i.e., collapsing adjacent re.nements (.)(. ' )) results in new \nre.nements that con\u00adjoin re.nements from . and . '. Due to these mechanisms, the type inference engine \nmust solve implication constraints over conjunc\u00adtive re.nement templates described by the grammar . ::= \nE | [e/x]; . (Pending Substitutions) L ::= e | . \u00b7 . . L (Re.nement Template) where . are liquid type \nvariables [22]. We use the fact that P . (Q . R) is valid iff P . Q and P . R are valid to reduce each \nimplication constraint over a conjunctive template into a set of constraints over simple templates (with \na single con\u00adjunct). The iterative weakening algorithm from [22] suf.ces to solve the reduced constraints, \nand hence infer liquid types. 5. Polymorphic Re.nements We now describe how the language is extended \nto capture invariants of .nite maps by describing the syntax and static semantics of polymorphic re.nements. \nThe syntax of expressions and dynamic semantics are unchanged. 5.1 Syntax Figure 9 shows how the syntax \nof types is extended to include polymorphically re.ned types (in addition to standard polymor\u00adphic types). \nFirst, type schemas can be universally quanti.ed over re.ned polytype variables a(x:t). Second, the body \nof the type schema can contain re.ned polytype variable instances a[y/x]. Intuitively, the quanti.cation \nover a(x : t ) indicates that a can be instantiated with a re.ned type containing a free variable x of \ntype t. It is straightforward to extend the system to allow multiple free variables; we omit this for \nclarity. A re.ned polytype instance a[y/x] is a standard polymorphic type variable a with a pending substitution \n[y/x] that gets applied after a is instantiated. The polytype variable instance is syntactic sugar for \n.x.{. :a | y = x}. That is, y serves as a witness for the existen\u00adtially bound x. To keep the quanti.cation \nimplicit, the instantia\u00adtion function Ins eagerly applies the pending substitution when\u00adever each polytype \nvariable is instantiated. When the polytype variable is instantiated with a type containing other polytype \nin\u00adstances, it suf.ces to telescope the pending substitutions by replac\u00ading a[x1/x][y/x2] with a[y/x] \nif x1 = x2 and with a[x1/x] oth\u00aderwise. Example. The following re.ned polytype schema signature speci\u00ad.es \nthe behavior of the key operations of a .nite dependent map. new ::.a, \u00df(x :a).int.(i : a, \u00df[i/x]) t \nset ::.a, \u00df(x :a).(i :a, \u00df[i/x]) t.k :a.\u00df[k/x].(j :a, \u00df[j/x]) t get ::.a, \u00df(x :a).(i :a, \u00df[i/x]) t.k \n:a.\u00df[k/x] mem ::.a, \u00df(x :a).(i :a, \u00df[i/x]) t.k :a.bool In the signature, t is a polymorphic type constructor \nthat takes two arguments corresponding to the types of the keys and val\u00adues stored in the map. If the \nsignature is implemented using as\u00adsociation lists, the type (i : a, \u00df[i/x]) t is an abbreviation for \n(i :a, \u00df[i/x]) list. In general, this signature can be implemented by any appropriate data structure, \nsuch as balanced search trees, hash tables, etc. The signature speci.es that certain relationships must \nhold between the keys and values when new elements are added to the map (using set), and it ensures that \nsubsequent reads (using get) return values that satisfy the relationship. For example, when a and \u00df are \ninstantiated with int and {. : int | x = .} re\u00adspectively, we get a .nite map (i :int, {. : int | i = \n.}) t where, for each key-value binding, the value is greater than the key. For this map, the type for \nset ensures that when a new binding is added to the map, the value to be added has the type {x = .}[k/x], \nwhich is {k = .}, i.e., is greater than the key k. Dually, when get is used to query the map with a key \nk, the type speci.es that the returned value is guaranteed to be greater than the key k. 5.2 Static \nSemantics Figure 9 summarizes the rules for polymorphic re.nements. Well-formedness. We extend our well-formedness \nrules with a rule [WF-REFVAR] which states that a polytype instance a[y/x] is well-formed if: (a) the \ninstance occurs in a schema quanti.ed over a(x : t), i.e., where a can have a free occurrence of x of \ntype t, and (b) the free variable y that replaces x is bound in the environment to a type t. Subtyping. \nWe extend our subtyping rules with a rule [<:-REFVAR] for subtyping re.ned polytype variable instances. \nThe intuition behind the rule follows from the existential interpretation of the re.ned polytype instances \nand the fact that ...(. = y1) . (. = y2) implies y1 = y2, which implies (.x.P . x = y1) . (.x.P . x = \ny2) for every logical formula P in which x occurs free. Thus, to check that the subtyping holds for any \npossible in\u00adstantiation of a containing a free x, it suf.ces to check that the replacement variables \ny1 and y2 are equal. Example. It is straightforward to check that each of the schemas for set, get, etc. \nare well-formed. Next, let us see how the following implementation of the get function let rec getxsk \n= match xs with | [] -> diverge () | (k ,d )::xs -> if k=k then d else get xs k implements the re.ned \npolytype schema shown above. From the input assumption that xs has the type (i : a, \u00df[i/x]) list, and \nthe rules for unfolding and pattern matching ([L-UNFOLD-M] and [L-MATCH-M]) we have that, at the point \nwhere d ' is returned, the environment G contains the type binding d ' : \u00df[i/x][k ' /i] which, after \ntelescoping the substitutions, is equivalent to the binding d ' :\u00df[k ' /x]. Due to [L-IF], the branch \ncondition k = k ' is in G, and so G h{. :a | . = k ' } <: {. : a | . = k}. Thus, from rule [<:-REFVAR], \nand subsumption, we derive that the then branch has the type \u00df[k/x] from which the schema follows. Typing. \nWe extend the typing rules with rules that handle re\u00ad.ned polytype generalization ([L-REFGEN]) and instantiation \n([L-REFINST]). A re.ned polytype variable a(x:t) can be instantiated with a dependent type T that contains \na free occurrence of x of type t . This is ensured by the well-formedness antecedent for [L-REFINST] \nwhich checks that T is well-formed in the environment extended with the appropriate binding for x. However, \nonce T is substituted into the body of the schema S, the different pending substitutions at each of the \nre.ned polytype instances of a are ap\u00adplied and hence x does not appear free in the instantiated type, \nwhich is consistent with the existential interpretation of polymor\u00adphic re.nements. Polymorphic Re.nements \nvs. Array Axioms. Our technique of specifying the behavior of .nite maps using polymorphic re.ne\u00adments \nis orthogonal, and complementary, to the classical approach that uses McCarthy s array axioms [15]. In \nthis approach, one mod\u00ad els reads and writes to arrays, or, more generally, .nite maps, using two operators. \nThe .rst, Sel(m, i), takes a map m and an address i and returns the value stored in the map at that address. \nThe second, Upd(m, i, v), takes a map m, an address i and a value v and re\u00adturns the new map which corresponds \nto m updated at the address i with the new value v. The two ef.ciently decidable axioms .m, i, v. Sel(Upd(m, \ni, v),i)= v .m,i,j,v. i = j . Sel(Upd(m, i, v),j)= Sel(m, j) specify the behavior of the operators. Thus, \nan analysis can use the operators to algorithmically reason about the exact contents of explicitly named \naddresses within a map. For example, the predicate Sel(m, i)=0 speci.es that m maps the key i to the \nvalue 0. However, to capture invariants that hold for all key-value bindings in the map, one must use \nuniversally quanti.ed formulas, which make algorithmic reasoning brittle and unpredictable. In contrast, \npolymorphic re.nements can smoothly capture and reason about the relationship between all the addresses \nand values but do not, as described so far, let us refer to particular named addresses. We can have the \nbest of both worlds in our system by com\u00adbining these techniques. Using polymorphic re.nements, we can \nreason about universal relationships between keys and values and by re.ning the output types of set and \nget with the predicates (. = Upd(m, k, v)) and (. = Sel(m, k)), respectively, we can si\u00admultaneously \nreason about the speci.c keys and values in a map. Example. Polymorphic re.nements can be used to verify \nproperties of linked structures, as each link .eld corresponds to a map from the set of source structures \nto the set of link targets. For example, a .eld f corresponds to a map f, a .eld read x.f corresponds \nto getf x, and a .eld write x.f . e corresponds to setfx e. Consider the following SSA-converted [1] \nimplementation of the textbook find function for the union-.nd data structure. let rec find rank parent0 \nx = let px = get parent0 x in if px = x then (parent0, x) else let (parent1, px ) = find rank parent0 \npx in let parent2 = set parent1 x px in (parent2, px ) The function find takes two maps as input: rank \nand parent0, corresponding to the rank and parent .elds in an imperative imple\u00admentation, and an element \nx, and .nds the root of x by transi\u00adtively following the parent link, until it reaches an element that \nis its own parent. The function implements path-compression, i.e., it destructively updates the parent \nmap so that subsequent queries jump straight to the root. The data structure maintains the acyclic\u00adity \ninvariant that each non-root element s rank is strictly smaller than the rank of the element s parent. \nThe acyclicity invariant of the parent map is captured by the type (i : int, {. :int | (i = .) . Sel(rank, \ni) < Sel(rank,.)}) t which states that for each key i, the parent . is such that, either the key is its \nown parent or the key s rank is less than the parent s rank. Our system veri.es that when find is called \nwith a parent map that satis.es the invariant, the output map also satis.es the invariant. To do so, \nit automatically instantiates the re.ned polytype variables in the signatures for get and set with the \nappropriate re.nement types, after which the rules from Section 3 (Figure 6) suf.ce to establish the \ninvariant. Similarly, our system veri.es the union function where the rank of a root is incremented when \ntwo roots of equal ranks are linked. Thus, polymorphic re.nements enable the veri.cation of complex acyclicity \ninvariants of mutable data structures. 6. Evaluation We have implemented our type-based data structure \nveri.cation techniques in DSOLVE, which takes as input an OCAML program (a .ml .le), a property speci.cation \n(a .mlq .le), and a set of logical quali.ers (a .quals .le). The program corresponds to a module, and \nthe speci.cation comprises measure de.nitions and types against which the interface functions of the \nmodule should be checked. DSOLVE combines the manually supplied quali.ers (.quals) with quali.ers scraped \nfrom the properties to be proved (.mlq) to obtain the set Q used to infer types for veri.cation. DSOLVE \nproduces as output the list of possible re.nement type errors, and a .annot .le containing the inferred \nliquid types for all the program expressions. Benchmarks. We applied DSOLVE to the following set of bench\u00admarks, \ndesigned to demonstrate: Expressiveness that our ap\u00adproach can be used to verify a variety of complex \nproperties across a diverse set of data structures, including textbook structures, and structures designed \nfor particular problem domains; Ef.ciency that our approach scales to large, realistic data structure \nimplemen\u00adtations; and Automation that, due to liquid type inference, our ap\u00adproach requires a small set \nof manual quali.er annotations. List-sort: a collection of textbook list-based sorting rou\u00adtines, including \ninsertion-sort, merge-sort and quick-sort,  Map: an ordered AVL-tree based implementation of .nite maps, \n(from the OCAML standard library)  Ralist: a random-access lists library, (due to Xi [23])  Redblack: \na red-black tree insertion implementation (without deletion), (due to Dun.eld [7])  Stablesort: a tail \nrecursive mergesort, (from the OCAML standard library)  Vec: a tree-based vector library (due to de \nAlfaro [5])  Heap: a binary heap library, (due to Filli atre [8])  Splayheap: a splay tree based heap, \n(due to Okasaki [18])  Malloc: a resource management library,  Bdd: a binary decision diagram library \n(due to Filli atre [8])  Unionfind: the textbook union-.nd data structure,  Subvsolve: a DAG-based \ntype inference algorithm [12]  On the programs, we check the following properties: Sorted, the output \nlist is sorted, Elts, the output list has the same elements as the input, Balance, the output trees are \nbalanced, BST, the out\u00adput trees are binary search ordered, Set, the structure implements a set interface, \ne.g., the outputs of the add, remove, merge func\u00adtions correspond to the addition of, removal of, union \nof, (resp.) the Total 1754 40 297 Program LOC Ann. T(s) Property List-sort 110 7 11 Sorted, Elts Map \n95 3 23 Balance, BST, Set Ralist 91 3 3 Len Redblack 105 3 32 Balance, Color, BST Stablesort 161 1 6 \nSorted Vec 343 9 103 Balance, Len1, Len2 Heap 120 2 41 Heap, Min, Set Splayheap 128 3 7 BST, Min, Set \nMalloc 71 2 2 Alloc Bdd 205 3 38 VariableOrder Unionfind 61 2 5 Acyclic Subvsolve 264 2 26 Acyclic Figure \n10. Results: LOC is the number of lines of code without comments, Property is the properties veri.ed, \nAnn. is the number of manual quali.er annotations, and T(s) is the time in seconds DSOLVE requires to \nverify each property. elements or sets corresponding to the inputs, Len, the various oper\u00adations appropriately \nchange the length of the list, Color, the output trees satisfy the red-black color invariant, Heap, the \noutput trees are heap-ordered, Min, the extractmin function returns the smallest element, Alloc, the \nused and free resource lists only contain used and free resources,VariableOrder, the output BDDs have \nthe vari\u00adable ordering property, Acyclic, the output graphs are acyclic. The complete benchmark suite \nis available in [21]. Results. The results of running DSOLVE on the benchmarks are summarized in Figure \n6. Even for the larger benchmarks, very few quali.ers are required for veri.cation. These quali.ers capture \nsim\u00adple relationships between variables that are not dif.cult to spec\u00adify after understanding the program. \nDue to liquid type inference, the total amount of manual annotation remains extremely small just 3% \nof code size, which is acceptable given the complexity of the implementation and the properties being \nveri.ed. Next, we de\u00adscribe the subtleties of some of the benchmarks and describe how DSOLVE veri.es \nthe key invariants. Sorting. We used DSOLVE to verify that implementations of var\u00adious list sorting algorithms \nreturned sorted lists whose elements were the same as the input lists , i.e., that the sorting functions \nhad type xs :a list.{. :a list= | elts . = elts xs}. We checked the above properties on insertsort (shown \nin Fig\u00adure 2), mergesort [23] which recursively halves the lists, sorts, and merges the results, mergesort2 \n[23] which chops the list into a list of (sorted) lists of size two, and then repeatedly passes over \nthe list of lists, merging adjacent lists, until it is reduced to a single\u00adton which is the fully sorted \nlist, quicksort, which partitions the list around a pivot, then sorts and appends the two partitions, \nand stablesort, from the OCAML standard library s List module, which is a tail-recursive mergesort that \nuses two mutually recursive functions, one which returns an increasing list, another a decreas\u00ading list. \nFor each benchmark, DSOLVE infers that the sort function has type Sorted using only the quali.er {. = \n*}. To prove Elts, we need a few simple quali.ers relating the elements of the output list to those of \nthe input. DSOLVE cannot check Elts for stablesort due to its (currently) limited handling of OCAML s \npattern syntax. Non-aliasing. Nested re.nements can be useful not just to verify properties like sortedness, \nbut also to ensure non-aliasing across an unbounded and unordered collection of values. As an example, \nconsider the two functions alloc and free of Figure 11. The functions manipulate a world which is a triple \ncomprised of: m, a bitmap indicating whether addresses are free (0) or used (1), us, let alloc (m, us, \nfs) = let free (m, us, fs) p = matchfswith ifgetmp=0then | [] -> (m, us, fs) assert false else |p::fs \n-> letm =setmp0in letm =setmp1in letus =deletepusin let us = p::us in let fs = p::fs in ((m , us , fs \n), p) (m , us , fs ) Figure 11. Excerpt from Malloc a list of addresses marked used, and fs, a list \nof addresses marked free. Suppose that the map functions have types: set :: m :(a, \u00df) t.k :a.d :\u00df.{. \n:(a, \u00df) t | . = Upd(m, k, d)} get :: m :(a, \u00df) t.k :a.{. : \u00df | . = Sel(m, k)} We can formalize the invariants \non the lists using the product type: . .c = ((); (Sel(m, .)= c; T)) . sc =(.c) int list . 10 RES = (m \n:(int, int) t, us : s, fs :s) The function alloc picks an address from the free list, sets the used \nbit of the address in the bitmap, adds it to the used list and returns this address together with the \nupdated world. Dually, the function free checks if the given address is in use and, if so, removes it \nfrom the used list, unsets the used bit of the address, and adds it to the free list. We would like to \nverify that that the functions preserve the invariant on the world above, i.e., alloc :: RES .(RES , \nint), free :: RES .int.RES . However, the functions do not have these types. Suppose that the free list, \nfs, passed to alloc, contains duplicates. In particular, suppose that the head element p also appears \ninside the tail fs '. In that case, setting p s used bit will cause there to be an element of the output \nfree list fs ', namely p, whose used bit is set, violating the output invariant. Hence, we need to capture \nthe invariant that there are no duplicates in the used or free lists, i.e., that no two elements of the \nused or free lists are aliases for the same address. In our system, this is expressed by the type int \nlist=, as de.ned by (1). Hence, If the input world has type RES=, then when p s bit is set, the SMT solver \nuses the array axioms to determine that for each . = p, Sel(m ' ,.)= Sel(m,.) and hence, the used bit \nof each address in fs ' remains unset in the new map m '. Dually, our system infers that the no-duplicates \ninvariant holds on p :: us as p (whose bit is unset in m) is different from all the elements of us (whose \nbits are set in m). Thus, our system automatically veri.es: alloc :: RES=.(RES=, int), free :: RES=.int.RES= \nMaps. We applied DSOLVE to verify OCAML s tree-based func\u00adtional Map library. The trees have the ML type: \ntype ( a, b) t = E |N of a* b* ( a, b)t*( a, b)t *int The N constructor takes as input a key of type \na, a datum of type b, two subtrees, and an integer representing the height of the resulting tree. The \nlibrary implements a variant of AVL trees where, internally, the heights of siblings can differ by at \nmost 2.A binary search tree (BST) is one where, for each node, the keys in the left (resp. right) subtree \nare smaller (resp. greater) than the node s key. A tree is balanced if, at each node, the heights of \nits subtrees differ by at most two. Formally, after de.ning a height measure ht: measure ht = E -> 0 \n| N (_,_,l,r,_) -> ifht l<htr then1+ htrelse1+ht l the balance and BST invariants are respectively speci.ed \nby: (.bal) \u00b5t. E + N(k : a, d:\u00df, l :t, r :t, h : int) (Balance) \u00b5t. E + N(k : a, d:\u00df, l :(.<) t, r :(.>) \nt, h : int) (BST) . . = ((); (.N k; T; T; T; T)) for N .{<, >} . .bal = ((); (T; T; T; eb; eh)) . eh \n=(ht l< ht r)?(. =1+ ht r):(. =1+ ht l) . eb =(ht l - ht . = 2) . (ht . - ht l = 2) DSOLVE veri.es that \nall trees returned by API functions are bal\u00adanced binary search trees, that no programmer-speci.ed assertion \nfails at run-time, and that the library implements a set interface. Vectors. We applied DSOLVE to verify \nvarious invariants in a li\u00adbrary that uses binary trees to represent C++-style extensible vec\u00adtors [5]. \nTo ensure that various operations are ef.cient, the heights of the subtrees at each level are allowed \nto differ by at most two. DSOLVE veri.es that that all the trees returned by API functions, which include \nappending to the end of a vector, updating values, deleting sub-vectors, concatenation, etc., are balanced, \nvector oper\u00adations performed with valid index operands, i.e., indices between 0 and the number of elements \nin the vector don t fail (Len1), and that all functions passed as arguments to the iteration, fold and \nmap pro\u00adcedures are called with integer arguments in the appropriate range (Len2). For example, DSOLVE \nproves: iteri :: v :a t.({0 = .< len v}.a.unit).unit That is, the second argument passed to the higher-order \niterator is only called with inputs between 0 and the length of the vector, i.e., the number of elements \nin each vector. DSOLVE found a subtle bug in the rebalancing procedure; by using the inferred types, \nwe were able to .nd a minimal and complete .x which the author adopted. Binary Decision Diagrams. A Binary \nDecision Diagram (BDD) is a reduced decision tree used to represent boolean formulas. Each node is labeled \nby a propositional variable drawn from some or\u00addered set x1 < ... < xn. The nodes satisfy a variable \nordering in\u00advariant that if a node labeled xi has a child labeled xj then xi <xj . A combination of hash-consing/memoization \nand variable ordering ensures that each formula has a canonical BDD representation. Us\u00ading just three \nsimilar, elementary quali.ers, DSOLVE veri.es the variable ordering invariant in Filli atre s OCAML BDD \nlibrary [8]. The veri.cation requires recursive re.nements to handle the order\u00ading invariant and polymorphic \nre.nements to handle the memoiza\u00adtion that is crucial for ef.cient implementations. The type used to \nencode BDDs, simpli.ed for exposition, is: type var = int typebdd=Zof int |Oofint | Nof var *bdd*bdd* \nint where var is the variable at a node, and the int elements are hash\u00adcons tags for the corresponding \nsub-BDDs. To capture the order invariant, we write a measure that represents the index of the root variable \nof a BDD: measurevar=Z_|O_ ->maxvar+1 | N (x,_,_,_) -> x where maxvar is the total number of propositional \nvariables being used to construct BDDs. After de.ning . bdd = \u00b5t. Z int + O int + N(x:int, t, t, int) \n. .V = ((T); (T); (T;(x< var .); (x< var .); T)) we can specify BDDs satisfying the variable ordering \nVariableOrder invariant as (.V ) bdd. The following code shows the function that computes the BDD corresponding \nto the negation of the input x, by using the table cache for memoization. let mk_not x = let cache = \nHash.create cache_default_size in let rec mk_not_rec x = if Hash.mem cache x then Hash.find cache x else \nlet res = match x with |Z _-> one |O_-> zero |N (v,l,h,_)-> mk v (mk_not_rec l) (mk_not_rec h) in Hash.add \ncache x res; res in mk_not_rec x Using the polymorphically re.ned signatures for the hash table op\u00aderations \n(set, get, etc. from Section 5), with the proviso, already enforced by OCAML, that the key s type be \ntreated as invariant, DSOLVE is able to verify that variable ordering (VariableOrder) is preserved on \nthe entire library. To do so, DSOLVE uses the quali\u00ad.er var * = var . to automatically instantiate the \nre.ned poly\u00adtype variables a and \u00df(x : a) in the signatures for Hash.find and Hash.add with bdd and {. \n: bdd | var x = var .}, which, with the other rules, suf.ces to infer that: mk not :: x :bdd.{. :bdd \n| var x = var .} Bit-level Type Inference. We applied DSOLVE to verify an imple\u00admentation of a graph-based \nalgorithm for inferring bit-level types from the bit-level operations of a C program [12]. The bit-level \ntypes are represented as a sequence of blocks, each of which is rep\u00adresented as a node in a graph. Mask \nor shift operations on the block cause the block to be split into sub-blocks, which are represented by \nthe list of successors of the block node. Finally, the fact that value-.ow can cause different bit-level \ntypes to have uni.ed sub\u00adsequences of blocks is captured by having different nodes share successor blocks. \nThe key invariant maintained by the algorithm is that the graph contains no cycles. DSOLVE combines recursive \nand polymorphic re.nements to verify that the graph satis.es an acyclicity invariant like DAG from (3) \nin Section 2.2. 6.1 Limitations and Future Work Our case studies reveal several expressiveness limitations \nof our system. Currently, simple modi.cations allow each program to typecheck. We intend to address these \nlimitations in future work. First-order Re.nements. To preserve decidability, our EUFA em\u00adbedding leaves \nall function applications in the re.nement predi\u00adcates uninterpreted. This prevents checking quicksort \nwith the standard higher-order partition function: part :: a list.p :(a.bool).{p(.)} list * {\u00acp(.)} list \nwhere p is the higher-order predicate used for partitioning. The function applications p(.) in part s \noutput type are left uninter\u00adpreted, so we cannot use them in veri.cation. Instead, we change the program \nso that the type of p is a.(\u00df, .) either where (\u00df, .) either has constructors T of \u00df and F of .. The \nnew part function then collects T and F values into a pair of separate lists. Thus, if w is the pivot, \nwe can verify quicksort by passing part a higher-order predicate of type: a.({. :a | . = w}, {. : a | \n.< w}) either. Existential Witnesses. Recall that expressing the key acyclicity in\u00advariant in union-.nd \ns find function (Section 5.2) required refer\u00ad encing the rank map. Although rank is not used in the body \nof the find function, omitting it from the parameter list causes this acyclicity invariant to be ill-formed \nwithin find. Instead of compli\u00adcating our system with existentially quanti.ed types, we add rank as a \nwitness parameter to find. Similarly, notice that the list ob\u00adtained by appending two sorted lists xs \nand ys is sorted iff there exists some w such that the elements of xs (resp. ys) are less than (resp. \ngreater than) w. In the case of quicksort, this w is exactly the pivot. Hence, we add w as a witness \nparameter to append, and pass in the pivot at the callsite, after which the system infers: append :: \nw :a.{. = w} list=.{w = .} list=.a list= and hence that quicksort has type Sorted. Similar witness param\u00ad \neters are needed for the tail-recursive merges used in stablesort. Context-Sensitivity. Finally, there \nwere cases where functions have different behavior in different calling contexts. For example, stablesort \nuses a function that reverses a list. Depending upon the context, the function is either (1) passed an \nincreasing list as an argument and returns a decreasing list as output, or, (2) passed a decreasing list \nas an argument and returns an increasing list. Our system lacks intersection types (e.g., [7]), and we \ncannot capture the above, which forces us to duplicate code at each callsite. In our experience so far, \nthis has been rare (out of all our benchmarks, only one duplicate function in stablesort was required), \nbut nev\u00adertheless, in the future, we would like to investigate how our system can be extended to intersection \ntypes. 7. Related Work Indexed Type based approaches use types augmented with indices which capture invariants \nof recursive types [24, 4, 7]. Recursive re\u00ad .nements offer several signi.cant advantages over indexed \ntypes. First, they compose more easily. While indexed types can be used to specify invariants like sortedness \nand binary-search-ordering, ex\u00adpressing additional invariants requires the programmer to add more type \nindices, altering both the type and functions de.ned on that type. Thus, it is cumbersome to use indices \nto encode auxiliary in\u00advariants: e.g., one must manually de.ne different types (and con\u00adstructors) to \ndescribe decreasing lists, or sorted lists with elements in some range, as well as different functions \nto manipulate data of these types. In contrast, by separating the re.nements from the underlying types, \nwe allow the programmer to compose different re.nements with the same type skeleton, which is essential \nto the usability of the system. Second, no inference algorithm for indexed types has been demonstrated, \nwhich greatly limits their usability due to the drastically increased annotation burden; the programmer \nmust annotate all functions and polymorphic instantiations. For ex\u00adample, at each call to Hash.add, the \nprogrammer would have to specify the appropriate indexed type instantiations for the type vari\u00adables \na, \u00df. In contrast, by separating the re.nements from the un\u00adderlying types, and uniformly representing \nre.nements as conjunc\u00adtions of quali.ers, our system permits inference, which is essential for usability. \nHoare Logic based approaches require that the programmer write pre-and post-conditions and loop invariants \nfor functions in a rich, higher-order speci.cation logic. From these and the code, veri.\u00adcation conditions \n(VCs) are generated whose validity implies that the code meets the speci.cation. The VCs are then proved \nusing automatic [13] or interactive theorem proving [17, 26, 20]. These approaches allow for the speci.cation \nof far more expressive prop\u00aderties than is possible in our system. However, they require signif\u00adicantly \nmore manual effort in interacting with the prover. Of the above proposals, the latter three have equal \nor more expressiveness than our approach, but require, at a conservative estimate, annota\u00adtions amounting \nto more than three times the code size to prove similar properties. A direct comparison is dif.cult as \n[17, 26] con\u00ad sider lower-level languages and [20] considers some different prop\u00ad erties. Nevertheless, \nthe order-of-magnitude annotation reduction proves the utility of our approach. Abstract Interpretation \nbased approaches focus on inferring lower-level shape properties (e.g., that a structure is a singly-linked \nlist or tree) in the presence of destructive heap updates. These techniques work by carefully controlling \ngeneralization (i.e., blur\u00adring ) and instantiation (i.e., focusing ) using a combination of user-de.ned \nrecursive predicates [14, 25] and abstract domains tai\u00ad lored to the structure being analyzed [10, 3]. \nOur insight is that in high-level languages, shape invariants can be guaranteed using a rich type system. \nFurthermore, by piggybacking re.nements on top of the types, one can use abstract interpretation (in \nthe form of liquid type inference) to verify properties which have hitherto been beyond the scope of \nautomation. In future work we would like to apply our techniques to lower-level languages, by .rst using \nshape analysis to reconstruct the recursive type information, and then us\u00ading recursive and polymorphic \nre.nements over the reconstructed shapes to verify high-level properties. Acknowledgments. We thank \nRobbie Findler and Amal Ahmed for valuable discussions about Polymorphic Re.nements. References [1] A. \nW. Appel. SSA is functional programming. SIGPLAN Notices, 33(4), 1998. [2] L. Augustsson. Cayenne -a \nlanguage with dependent types. In ICFP, 1998. [3] B. E. Chang and X. Rival. Relational inductive shape \nanalysis. In POPL, pages 247 260, 2008. [4] S. Cui, K. Donnelly, and H. Xi. Ats: A language that combines \nprogramming with theorem proving. In FroCos, 2005. [5] Luca de Alfaro. Vec: Extensible, functional arrays \nfor ocaml. http://www.dealfaro.com/vec.html. [6] L. de Moura and N. Bj\u00f8rner. Z3: An ef.cient smt solver. \nIn TACAS, pages 337 340, 2008. [7] Joshua Dun.eld. A Uni.ed System of Type Re.nements. PhD thesis, Carnegie \nMellon University, Pittsburgh, PA, USA, 2007. [8] J.C. Filli atre. Ocaml software. http://www.lri.fr/ \n.lli\u00adatr/software.en.html. [9] C. Flanagan. Hybrid type checking. In POPL. ACM, 2006. [10] S. Gulwani, \nB. McCloskey, and A. Tiwari. Lifting abstract interpreters to quanti.ed logical domains. In POPL, pages \n235 246, 2008. [11] F. Henglein. Type inference with polymorphic recursion. ACM TOPLAS, 15(2):253 289, \n1993. [12] R. Jhala and R. Majumdar. Bit-level types for high-level reasoning. In FSE. ACM, 2006. [13] \nS. K. Lahiri and S. Qadeer. Back to the future: revisiting precise program veri.cation using smt solvers. \nIn POPL, 2008. [14] T. Lev-Ami and S. Sagiv. TVLA: A system for implementing static analyses. In SAS, \nLNCS 1824, pages 280 301. Springer, 2000. [15] John McCarthy. Towards a mathematical science of computation. \nIn IFIP Congress, pages 21 28, 1962. [16] Alan Mycroft. Polymorphic type schemes and recursive de.nitions. \nIn Symposium on Programming, pages 217 228, 1984. [17] A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, \nand L. Birkedal. Ynot: Reasoning with the awkward squad. In ICFP, 2008. [18] C. Okasaki. Purely Functional \nData Structures. CUP, 1999. [19] B. C. Pierce. Types and Programming Languages. MIT Press, 2002. [20] \nY. Regis-Gianas and F. Pottier. A Hoare logic for call-by-value functional programs. In MPC, 2008. To \nappear. [21] P. Rondon, M. Kawaguchi, and R. Jhala. Type based data structure veri.cation. http://pho.ucsd.edu/liquid. \n[22] P. Rondon, M. Kawaguchi, and R. Jhala. Liquid types. In PLDI, pages 158 169, 2008. [23] H. Xi. DML \ncode examples. http://www.cs.bu.edu/fac/hwxi/DML/. [24] H. Xi and F. Pfenning. Dependent types in practical \nprogramming. In POPL, pages 214 227, 1999. [25] H. Yang, J. Berdine, C. Calcagno, B. Cook, D. Distefano, \nand P. W. O Hearn. Scalable shape analysis for systems code. In CAV, 2008. [26] K. Zee, V. Kuncak, and \nM. C. Rinard. Full functional veri.cation of linked data structures. In PLDI, pages 349 361, 2008.  \n  \n\t\t\t", "proc_id": "1542476", "abstract": "<p>We present a refinement type-based approach for the static verification of complex data structure invariants. Our approach is based on the observation that complex data structures are typically fashioned from two elements: recursion (e.g., lists and trees), and maps (e.g., arrays and hash tables). We introduce two novel type-based mechanisms targeted towards these elements: recursive refinements and polymorphic refinements. These mechanisms automate the challenging work of generalizing and instantiating rich universal invariants by piggybacking simple refinement predicates on top of types, and carefully dividing the labor of analysis between the type system and an SMT solver. Further, the mechanisms permit the use of the abstract interpretation framework of liquid type inference to automatically synthesize complex invariants from simple logical qualifiers, thereby almost completely automating the verification. We have implemented our approach in <sc>dsolve</sc>, which uses liquid types to verify <sc>ocaml</sc> programs. We present experiments that show that our type-based approach reduces the manual annotation required to verify complex properties like sortedness, balancedness, binary-search-ordering, and acyclicity by more than an order of magnitude.</p>", "authors": [{"name": "Ming Kawaguchi", "author_profile_id": "81435598242", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1464302", "email_address": "", "orcid_id": ""}, {"name": "Patrick Rondon", "author_profile_id": "81435603774", "affiliation": "University of California, San Diego, San Diego, CA, USA", "person_id": "P1464303", "email_address": "", "orcid_id": ""}, {"name": "Ranjit Jhala", "author_profile_id": "81100198278", "affiliation": "University of California, San Diego, San Diego, USA", "person_id": "P1464304", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542510", "year": "2009", "article_id": "1542510", "conference": "PLDI", "title": "Type-based data structure verification", "url": "http://dl.acm.org/citation.cfm?id=1542510"}