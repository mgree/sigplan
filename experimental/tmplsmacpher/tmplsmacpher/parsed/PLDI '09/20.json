{"article_publication_date": "06-15-2009", "fulltext": "\n GC Assertions: Using the Garbage Collector to Check Heap Properties EdwardE.Aftandilian SamuelZ.Guyer \nDepartment ofComputerScience TuftsUniversity {eaftan,sguyer}@cs.tufts.edu Abstract This paper introduces \nGC assertions, a system interface that pro\u00adgrammers can use to check for errors, such as data structure \nin\u00advariant violations, and to diagnose performance problems, such as memory leaks. GC assertions are \nchecked by the garbage collec\u00adtor, whichisin a uniqueposition togatherinformation and answer questions \nabout thelifetime andconnectivity of objectsintheheap. By piggybacking on existing garbage collector \ncomputations, our system is able to check heap properties with very low overhead around 3% of total execution \ntime low enough for use in a de\u00adployed setting. We introduce several kinds of GC assertions and describe \nhow they areimplementedin the collector.We alsodescribe our report\u00ading mechanism, which provides a complete \npath through the heap to the offending objects.We report results onboth theperformance of oursystemandtheexperienceof \nusing ourassertionsto .nd and repair errorsin real-worldprograms. Categories and Subject Descriptors \nD.2.4[Software Engineer\u00ading]:Software/ProgramVeri.cation Reliability,StatisticalMeth\u00adods General Terms \nReliability,Performance,Experimentation Keywords MemoryLeaks,Managed Languages,Garbage collec\u00adtion 1. \nIntroduction Garbage collection provides many software engineering bene.ts, most notablyby eliminating \nalarge class ofinsidiousprogramming errors associated with manual memory management, such as dan\u00adglingpointersanddoublefrees.Onedownside \nof automaticmem\u00adory management, however, is that programmers are left with less control and less information \nabout the memory behavior of their programs. For example, in the absence of explicit free operations, \nJava programmers have no way to answer even seemingly simple questions, such as Will this object be reclaimed \nduring the next garbage collection? In this paper we present GC assertions, an introspective inter\u00adface \nthat allowsprogrammers toquery thegarbage collector about Permission to make digital or hard copies of \nall or part of this work for personal or classroomuseisgranted withoutfeeprovided that copiesarenot madeordistributed \nforpro.tor commercial advantage andthat copiesbearthis notice andthefull citation onthe .rstpage.Tocopy \notherwise,torepublish,topostonserversortoredistribute tolists, requiresprior speci.cpermission and/or \nafee. PLDI 09, June15 20,2009,Dublin,Ireland. Copyright c &#38;#169; 2009ACM978-1-60558-392-1/09/06. \n. .$5.00 the run-timeheap structure andbehavior oftheirprograms.Like or\u00addinary assertions,programmers \naddGC assertionstotheircodeto express expected properties of objects and data structures. Unlike ordinary \nassertions,however,GC assertions are not checkedimme-diately.Instead, whenGCassertions are executedthey \nconvey their information tothegarbage collector, whichchecks themduring the next collection cycle.Thekeyto \nourtechniqueisthat wepiggyback these checks on the normal GC tracing process, imposing little or no additional \ncost. We describe a suite of GC assertions designed to help identify bugsinJavadata structures,including \nmemoryleaks andimproper structure sharing.Our selection of assertionsbalances two compet\u00adinggoals.The \n.rstistoprovide arich and expressivesetof asser\u00adtions that programmers .nd easy to use and valuable. \nThe second istokeepthe run-time overheadlow enough thatthe system canbe used todetect andprevent errorsindeployed \nsoftware.To this end, wehaveidenti.ed several categories ofheapproperties,including lifetime andlifespan, \nallocation volume, andconnectivity and own\u00adership, that can be checked during a single pass over the \nheap. In addition, we minimize space overheadbylimiting our meta-data to the set of assertions tobe checked \nand extrabits stolenfrom object headers. Even with a signi.cant set of assertions to check during eachgarbage \ncollection, our techniqueincreases collection timeby less than14% and overall run-timebyless than3%. \nUsing thegarbage collectortocheckprogrammer-writtenheap assertions provides a combination of features \nnot available with existing techniques: More precise than static analysis. Unlikestaticheap checking, \nwhich operates on an abstract model of theheap, our technique works onthe actual concreteheap, avoidingthe \nneedfor conser\u00advative approximations. In addition, our technique is unaffected byfeaturesthattypicallythwartstatic \nanalysis, such asdynamic classloading, re.ection, andbytecode rewriting.  More ef.cient than run-time \ninvariant checking. Systems that support trueprograminvariants must check theseproperties af\u00adter any \ncomputation that might violate them, imposing a sub\u00adstantial performance penalty as much as 10X to 100X \nslow\u00addown[12].Bydeferring checks untilgarbage collectiontime, our system can batch them together and \nleverage the existing collection computation to eliminate much of the overhead.The pricewepay isthatwe \ncanmiss atransienterrorifitdoes not persistacross aGC cycle.  More accurate than heuristics. Unlike \ntools based on heuris\u00adtics(such as staleness ) oranomalydetection,GC assertions capture information that \nis both precise and application spe\u00adci.c. Although adding assertions requires extra effort on the partof \ntheprogrammer, the systemgenerates nofalsepositives   because any violation represents a mismatch between \nthe pro\u00adgrammer s expectations andthe actualbehavior oftheprogram. We describe our implementation of \nthese assertions in the JikesRVM virtual machine. We also explore different ways that the virtual machine \ncan react to triggered assertions and the kinds ofinformation it canprovide tohelp theprogrammer diagnose \nthe bug.Finally, wepresentresultsfor realprograms, showingboththe debugging experience and theperformance \nimpact. The rest of this paper is organized as follows: in Section 2 we describe the kinds of assertions \nwe support and their implementa\u00adtion in the Jikes RVM research virtual machine. In Section 3 we provide \nboth quantitative performance results and qualitative de\u00adbugging results.Wedescribe related workinSection4 \nand conclu\u00adsionsinSection5. 2. GC Assertions The goal of GC assertions is to provide a simple and low-cost \nwayforprogrammers to express and checkproperties of theirdata structures. Assertions are a familiar construct \nfor program checks, and the kinds of assertions we support involve program behavior that programmers \nwant to know about, but in many cases have no direct way to check. The assert dead assertion, described \nbelow, checks that a given object is reclaimed at the next garbage collection.In the absence of explicitfree \noperations,programmers have no easy way of checking that reclamation occurs,particularly at thegranularity \nofindividual objectinstances. In this section we describe the speci.c GC assertions we sup\u00adport,how theycanbe \nusedby theprogrammer todetect errors, and how the assertions areimplementedin theJikesRVMresearch vir\u00adtual \nmachine. We also discuss different ways that the system can react to assertion violations, since they \nare notdetected at thepoint the assertionis executed. 2.1 Adding assertions Unlike other approaches, \nourtechniqueisprogrammer-driven:itre\u00adquires extra efforton thepart of theprogrammer to add assertions. \nThis design, however, has several advantages over tools based on heuristics or anomaly detection. First,GC \nassertions captureprop\u00aderties that programmers already know and want to be able to ex\u00adpress.Second, theseproperties \noften represent high-level informa\u00adtion that cannot be inferred from the program. Because this infor\u00admation \nis precise and application-speci.c, any violation of a GC assertionis animmediate and unambiguous error. \nFor example, we can useGC assertions todetect memoryleaks in a way that is very different from previous \ntechniques. A num\u00adber of systems have been designed to detect memory leaks, both in managed and unmanaged \nlanguages. The challenge in managed languages is determining what constitutes a leak, since leaked ob\u00adjects \nare stillreachable.Withoutextrainformation, mostleakdetec\u00adtors must rely on heuristics to identify potential \nleaks. Some tools use the notion of staleness to identify potential leaks: objects that have not been \naccessed in a long time are probably mem\u00adory leaks[14,7].Othertools useheapdifferencing to .nd objects \nthat areprobably responsibleforheapgrowth[3,37,35,32,27]. Thesetechniques,however, can onlysuggest potentialleaks, \nwhich theprogrammer mustthen examine manually.UsingGCassertions, programmers can tell our system exactly \nwhen particular objects should be dead. Violations can be detected almost immediately, rather than having \nto wait for objects to become stale or .ll up the heap. Our system provides detailed information about \nthe rea\u00adsonforthefailure(for example,thepath throughtheheap thatis keeping the object alive.) 2.2 Implementation \noverview We implemented these assertions in Jikes RVM 3.0.0 using the MarkSweep collector. We chose MarkSweep \nbecause it is a full\u00adheapcollector, which will check all assertions at everygarbage col\u00adlection.Ourtechnique \nwillwork with any tracing collector, such as generational mark/sweep. A generational collector, however, \nper\u00adforms full-heap collections infrequently, allowing some assertions togo unchecked forlongperiods \nof time.  2.3 Lifetime assertions Lifetime assertions allowtheprogrammer to checkthatthelifetime characteristics \nof objects conformto expectations.These assertions generally work by marking the given objects at the \ncall to the as\u00adsertion andthen reportingifthey are encounteredduring collection. Lifetimeproperties are \neasyto express andextremely cheapforthe collector to check,but are almostimpossible to obtainby any other \nmeans.Weimplement thefollowingkinds oflifetime assertions: 2.3.1 assert-dead assert-dead(p) is triggered \nat the next garbage collection if the object pointed to by p is not reclaimed(i.e.,found tobe still reachable.) \nUsage. assert-dead allows the programmer to check that a par\u00adticular object is reclaimed at or soon after \na speci.c point in the program. For example, a common Java idiom is to assign null to a reference when \nthe object pointed to should be reclaimed. How\u00adever, if there are still other references to the object, \nthe object will not be reclaimed. assert-dead can be used in this situation to verify that the objectis \nreclaimed. Implementation. We implement assert-dead as follows. During execution, when the JVM encounters \nthis assertion, it marks the object pointed to by p as dead using a spare bit in the object s header.Atthe \nnextgarbage collection,thegarbage collector checks whether any object encountered during tracing has \nits dead bit set.If so,itprints a warning along withdebugginginformationto help the programmer .nd the \nerror that led to this dead object being reachable. Because we use sparebitsin objectheaders to storeinformation \nabout which objects are expected to be dead, there is no space overhead for this assertion. Time overhead \nis limited to checking the state of a bit in the object s header when it is encountered duringGC.Because \nthe object sheader mustbe read(andpossibly written) anyway as part of the GC tracing process, the data \nis alreadyin cache and the slowdown is minimal.  2.3.2 assert-alldead assert-alldead() is usedin conjunction \nwitha separate start-region() assertion: the assertion is triggered if any ob\u00adject allocated after start-region() \nis not reclaimed at the assert-alldead(). This allows the programmer to bracket a particular region of \ncode, for example a particular method or loop body, and ensure that it is memory-stable. The region is \ncon.ned to a single thread(i.e. eachthread canindependentlybe eitherin or out of a region). Usage. This \nassertionisusefultoensurethatcertainregions of code donot leak memoryintootherpartsoftheapplication.Forexam\u00adple, \nin a server application, one might bracket the connection ser\u00advicing code with start-region and assert-alldead \nassertions to ensure that, when the server has .nished servicing the connec\u00adtion, all memory related \nto that connection is released. Regions are widely usedintheC/C++ world[4,41],particu\u00adlarly by theApacheHTTPServer[18] \nand otherprojectsthat use theApachePortableRuntime[20].Ratherthanenforce regionbe\u00adhavior toimproveperformance, \nour assertions check for regionbe\u00adhaviorin order to validateprogrammer expectations.  Implementation. \nWe implement assert-alldead as follows. Each thread in Jikes RVM has a boolean .ag to indicate whether \nit is currently in an alldead region, and a queue to store a list of objects that have been allocated \nwhile in the region. When the programmer invokes the start-region assertion, the .ag in the thread is \nswitched to indicate that we are now in a region. Every allocation checks the .ag to determine if it \noccurred within a re\u00adgion, andifitis,the allocated objectis added tothequeue.When the assert-alldead \ncall occurs, the region .ag is reset and the queue is processed, calling assert-dead on each object in \nthe queue. Thespaceoverheadforthisassertiondepends onwhetherare\u00adgion is currently active in the given \nthread. If not, the space over\u00adheadis aboolean andaqueue referencefor eachthread.Otherwise, the space \noverhead consists of a boolean and a queue for each re\u00adgion that is currently active, plus a word for \neach object that has been allocate while the region has been active. When the region ends,thequeuewillbe \n.ushed,and wewill reclaimtheone-word\u00adper-objectspace neededfor the region metadata. The time overhead \nconsists of checking the thread s region .ag on every allocation, plus, if we are in an active region, \nadding the newly allocated object to the thread s region object list. By using assert-dead to mark the \nobjects at the end of the region, we do not incur an extra time or space penalty to check that objects \nare deallocated at the end of the region.  2.4 Volume assertions Volume assertions express constraints \non the number or total vol\u00adume ofparticular categories of objects.These assertions areimple\u00admentedby \naccumulatingtheinformationduringheap scanning, and checking against the constraints when .nished. 2.4.1 \nassert-instances assert-instances(T, I) is triggered when the total number of objects of type T exceeds \nI at the next collection. Passing 0 for I checks that noinstances of aparticular class exist(atGC time.) \nUsage. This assertion is most useful for checking that either 0 or 1instance of acertainclassexist.Forexample,one \nmightemploy this assertionto check uses ofthe singletonpattern.For a variety of reasons,including subclassing \nand serialization, thisdesignpattern isdif.culttoimplementcorrectly[22].WithGC assertions, we can easily \ncheck for correctness by asserting that only one instance of the class exists at atime.Note,however, \nthat we cannot enforce the singletonpattern usingGC assertions. Another potential use is in situations \nwhere the number of objects of a certain type should be limited for best performance, but it is not strictly \nan error if the limit is exceeded. We discuss such a situationinSection3.2.2. Implementation. Ourimplementation \nof assert-instancesisdiffer\u00adent from that of the previous two assertions since this assertion is tied \nnot to object instances but to types. In Jikes RVM, the RVM-Class class corresponds to aJava class, so \nwe modifyRVMClassto maintain two extrapieces ofinformation: theinstancelimit and the instance countfor \nthis class. When the virtual machine encounters an assert-instances call, we set the instance limit for \nthe type and add the type to a list of types for which we are tracking instances. During GC, every time \nwe encounter an object of a tracked type, weincrement the corresponding RVMClass s instance count. At \nthe end of GC, we iterate through our list of tracked types, checking whether the instancelimithasbeen \nviolated. This implementation incurs a space overhead of two words per loaded class(fortheinstancelimitandinstance \ncount), as well as one wordper tracked type(i.e. a type thathashad aninstancelimit asserted)for the array \nof tracked types. We alsoincur a small time overheadby checkingtheRVMClassof every objectduringtracing, \nplusincrementing theinstance countif necessary and checking the listof tracked typesfor violations at \nthe end ofGC.  2.5 Ownership assertions Ownershipassertions allowprogrammers to checkthe connectivity \nproperties of individual objects or data structures. The garbage collector is in a unique position to \ncheck such properties, since it traverses all reachable objects in the heap, regardless of their type \nor access controlquali.ers. 2.5.1 assert-unshared assert-unshared(p) is triggered if the given object \nhas more than one incoming pointer. It is a simple test to ensure than an objecthas no more than onedirectparent. \nUsage. This assertion can be used to check simple connectivity properties ofdata structures.For example, \naprogrammer can use assert-unshared to verify that a treedata structurehas notinad\u00advertentlybecome aDAG \nor otherkind ofgraph. Implementation. Our implementation of assert-unshared is similarto that of assert-dead.Once \nagain, theprogrammer must assertintheprogramcodethat aobject shouldbeunshared aftera certain point. The \nJVM marks the object as unshared by setting a spare bit in the object header. During garbage collection, \nthe garbage collector checks objects that are encountered more than once(i.e.whosemarkbitsarealready \nset)forthis unshared bit. If such an object is encountered, we print a warning along with debugginginformation. \nThere is no space overhead for this assertion since we use a sparebitin the objectheader, and the time \noverheadisjust the cost of checking thebitin each object sheaderduringGC tracing.  2.5.2 assert-ownedby \nassert-ownedby(p,q) is triggered if the object pointed to by q is not ownedby the objectpointed toby \np. There are several different ways to de.ne what it means for one object(the owner)to own another object(the \nownee)[15,10]. Initially, our ownershipassertion requiredthat allpaths through the heap from the roots(local \nandglobal variables) to the ownee must pass through the owner. This de.nition, however, is too restrictive \nto be practical: common constructs, such as iterators, violate the assertions and make them useless. \nInstead we provide a notion of ownership that focuses on detecting unexpected structure sharing, particularly \nwhen it impacts object lifetimes. Our de.nition is as follows: once ownership is asserted, the set of \npaths through the heap to the ownee must include at least one path that passes through the owner.Theideaisthat \nan ownee maybe referencedby other objects,butit should never outliveits owner.Thispropertyis checkedfor \neach owner/owneepair at everygarbage collection. As we show in Section 3, this assertion is often a more \nnatural way to .nd memoryleaksthanusing assert-dead(p).Instead of identifying the point at which an object \nis no longer needed, the programmerjustidenti.es thelargerdata structure thatgoverns its lifetime.Forexample,consider \nadatastructureinwhich elements are stored in a main container and also cached in a hash table. We can \nassert that the container owns the elements; if the system ever .nds elementsthat are only reachablefromthehashtable,it \nreports an error.  We impose some restrictions on ownership in order to keep the cost low: the regions \nof the heap governed by different owner objects may not overlap. That is, the path from an owner to its \nownee should notpass though any other owner(orits ownees).We discuss this restrictionfurtherbelow. Usage. \nWe expect assert-ownedby to be most useful when an object slifetimeis correlatedtothelifetime ofits owner \ncollection. That is, when an object should not outlive its owner collection or survive when removed from \nthat collection.For example, an order processing program might store orders in a collection, and when \nthose orders havebeenprocessed, they are removed from the table and should be deallocated. Using assert-ownedby \nto assert that the orders are ownedbytheir collection wouldhelptheprogrammer detect memory leaks caused \nby outstanding references to these order objects. Implementation. assert-ownedBy isthe mostcomplicated \nasser\u00adtion toimplement.Ourgoalis to check this assertion with no extra GC work and without storing extraneous \npath information during collection. Withassert-ownedBy, the user expresses owner/owneepairs. There may \nbe an unbounded number of owners and ownees, and we wish to check them all in a single GC pass. In its \nmost gen\u00aderal form, this problem incurs a signi.cant overhead in space and time. Consider the following \ngeneral algorithm for checking own\u00adership assertions:during GC tracing,if the collector encounters an \nownee, it checks to see if that ownee s owner is on thispath. If so, the ownee is marked as owned. The \nother possibility is that the collector encounters the owner and then a previously marked ob\u00adject. We \nneed to know whether the ownee is reachable from this previously marked object,but wedonot wanttorepeatthetracing \nwork.One way around this wouldbe tobubble ownee information up thepath when an owneeis encountered.In \nthegeneral case, this resultsin each objectbeing tagged with all ownees reachablefrom it. The space and \ntime overhead from storing this information is prohibitive. To avoid this problem, we modi.ed the garbage \ncollector to trace objectsin adifferent order.Instead of starting atthe roots, we added a new ownership \nphase to the collector that starts tracing from each owner object. If we encounter an ownee object that \nbelongstothecurrent owner,wemarkit as owned. Aftertracing from allthe owners, we enter the standard root \nscanningphase and allow the collector to proceed as normal. If the GC encounters an ownee object that \nhas not been marked as owned, we know it is not reachablefromitsowner, and weprint a warning anddebugging \ninformation.Notice that theportions of theheap that are reachable from the owners are marked in the ownership \nphase, so they will not be traced again. Thus we are able to check the ownership assertion without per-object \nmemory overhead or processing any objects twice. This strategy solves the performance problem, but introduces \ntwo newissues.First,bystartingGCtracing withtheowner objects, we are assuming they arelive.This may notbe \nthe case.To address this problem, we avoid marking the owner object when we do the ownership scan.We \nstill mark all objects reachablefromthe owner. For the owner to remain live, it needs to be marked during \nthe root scan phase, that is, it must be reachable from a root. Thus if the owner object is unreachable, \nit will be collected during this GC. However, any objects reachable from the owner that are not reachable \nfrom a root will not be collected until the next GC.This results in additional memory pressure that may \ncause the next GC to occur sooner. The second problem relates to data structure overlap. Suppose an ownee \nobject is reachable from both its owner and another object s owner, and the other owner is selected to \nbe traced .rst in the ownership phase. The ownee will be marked but not set as owned because we did not \nstart scanning from its owner. When we start tracing from the ownee s owner, the ownee has already been \nmarked and will notbeprocessed again.Thus we will trigger afalsewarningforthisobject.One could addressthisproblemby \nenforcing a condition that thedata structuresde.nedby ownersbe disjoint. However, data structures in \nreal programs are usually not disjoint;theirobjects oftenhavebackedgesthat resultin signi.cant overlap.Instead, \nwedesigned the ownership scanningphaseto stop following a path when an ownee is reached. Ownees are added \nto a queue and processed after the scanning from owners has been completed. Thus collections are essentially \ntruncated when their leaves are reached, avoidingtheback edgeproblem.Wedo enforce a condition that theparts \nof thedata structurefrom the owner node to the ownees must be disjoint from that of other owners. For \nthe typical use-case where assert-ownedBy is used to keep track of objectsin a collection, thisdesign \nmaintains thedesired semantics, while supporting the kinds of data structures that occur in real programs. \nWe modify the marking algorithm by breaking it into twophases: Phase 1: Perform aheapscan starting at \neach owner: Do not mark the owneritself atthispoint, since wedo notyet knowifitis actually reachable. \n Ifwe encounter an ownee object, check to make sureitbelongs tothe current owner.If not,issue a warning(improper \nuse of the assertion).  If we encounter another owner, mark it and stop the scan we will scan this \nownerindependently.  Phase 2: Perform the normalheap scan(starting at the roots): If we encounter an \nownee (of any owner) it means that it is notproperly owned orit wouldhavebeenmarkedinthe .rst phase ofthe \nalgorithm. To check this assertion we must maintain alist of owner-ownee pairs.Weimplement this as apair \nof arrays, one containing owner objects and the other containing arrays of ownee objects, one for each \nowner.Thus the metadata overheadfor thisimplementationis one wordper owner or ownee object.Time overhead \nis asfollows: for each ownee object encountered during tracing, we must check an ownee array to seeifit \nowned by the correct owner.The ownee arraysaresorted,sowedoabinary searchto .ndtheowneeobject. Thus, \nthe worse case time overhead is n log n, where n is the number of ownee objects. In practice we .nd the \noverhead to be negligible, asdiscussedinSection3.1.  2.6 Assertion violations When an assertion is \ntriggered the garbage collector has several waysit can take action. Log an error, but continue executing. \nIn the case of the life\u00adtime assertions we can report eitherthe referencethatisdirectly keepingthe object \nalive orthefullpath through theheap.In our experimentsinSection3 wefoundthat our system can maintain \nfullpathinformation with no measurable overhead.  Log an error and halt. Similar to the case above, \nbut is used for assertions whosefailureindicates a non-recoverable error.  Force the assertion to be \ntrue. In the case of lifetime asser\u00adtions, the garbage collector can force objects to be reclaimed  \n Warning: an object that was asserted dead is reachable. Type: Lspec/jbb/Order; Path to object: Lspec/jbb/Company; \n-> [Ljava/lang/Object; -> Lspec/jbb/Warehouse; -> [Ljava/lang/Object; -> Lspec/jbb/District; -> Lspec/jbb/infra/Collections/longBTree; \n-> Lspec/jbb/infra/Collections/longBTreeNode; -> [Ljava/lang/Object; -> Lspec/jbb/infra/Collections/longBTreeNode; \n-> [Ljava/lang/Object; -> Lspec/jbb/Order; Figure 1. Example offull-patherror reporting.Eachlinegives \nthe type of an object along thepathfrom root to the object ofinterest. by nulling out allincoming references.This \nmight allow apro\u00adgram to run longer without running out of memory but risks introducing a nullpointer \nexception. In this system, we choose to log the error and continue execut\u00ading, so that we retain the \nsemantics of the program without any assertions.Wediscuss our error reporting schemeinSection2.7. However, \nfor future work we would like to explore the other options above, as well as a programmatic interface \nthat would allowtheprogrammertotestthe conditionsdirectly andtake action in an application-speci.c manner. \nIt might make sense to support different actionsbased on the class of assertion thatis violated.  2.7 \nProviding debugging information Once an assertion is triggered, the programmer still needs help determining \nthe cause of the error.For most ofthese assertions, the problem occursbecause ofan unexpectedpath through \ntheheap to the offending object. Thus,displaying thatpath for the user would be thebest way tohelppinpoint \nthe error. Our reporting strategy is to provide the full path through the object graph, from root to \nthe dead object. This information is extremely valuable for .xing Java memory leaks, since all leaks \nare ultimately caused by outstanding references to objects that are no longer needed. The full path to \nthe leaked object identi.es the reference or container that needs to be cleared to stop the leak. Our \ninformation is similar to thatprovided by Cork[27], but much moreprecise: ourpath consists of objectinstances, \nnotjust types(although currently, wedisplay only theirtypesinthe error message.) Our implementation modi.es \nthe management of the worklist that holds unprocessed references for the collector during tracing (the \nso-called gray objects.) The baseline algorithm performs a depth-.rst search by popping a reference off \nthe worklist, scan\u00adning the object, andpushing allits outgoing referencesback on the worklist.In our \nalgorithm, wekeepthis object onthe worklist while its outgoing references arebeing traced, allowing us \nto reconstruct thepath when necessary.Wepop a referencefrom the worklist, set its low order bit and push \nit back onto the worklist; then we con\u00adtinue to scan the object normally.Because all objectsinJikesRVM \nare word aligned, the two low order bits are unused, and we can safely use one of them for this algorithm. \nIf we encounter a refer\u00adence whose low-order bit is set, we discard it and continue this simply indicates \nthat we have already visited all objects reachable from it. Thus, at any given time during tracing, the \nsubset of the worklist whose referenceshavetheirlowbit setde.nethe complete path from the root to the \ncurrent object. Figure 1 shows an exam\u00adple of the full-path output provided when an assertion violation \nis detected. Alimitationofthistechniqueisthat,toprintthisinformationfor the user, we must be able to \nidentify the offending object or path whenwe .rst encounterit.Forassert-dead and assert-ownedBy,the detection \nalgorithm naturally provides this information. However, for assert-unshared, we have no way of knowing \nwhich path is the correct one, and we only know there is a problem when we encounter the secondpath.We \ncanprintthe secondpath,butit may nothelp theuser .nd theproblem.Similarly,with assert-instances, we only \nknow that there is a problem after we have exceeded the instance limit for a type, and the problem paths \nmay have been traced earlier.In these cases, the user will need to use other toolsif shecannot .nd theproblemwith \nthegivendebugging output. 3. Results WeimplementedGCassertionsinJikesRVM3.0.0usingtheMark-Sweep collector.This \nsectiondescribes our results,presentingper\u00adformance results for the system along a description of our \nexpe\u00adriences using it to .nd and .x bugs. We collected performance measurements using a standardbenchmark \nsuite;for ourqualitative evaluation we used GC assertions to check for errors in real-world programs. \n 3.1 Performance We .rstpresentperformancemeasurementsforGC assertionsrun\u00adning on a standard set ofbenchmarks. \nFor most of thebenchmarks we measuretheperformance of running with no assertions,in order todetermine \nthebaseline cost of adding the assertioninfrastructure intothe collector.Due tothe effortrequiredto add \nassertions to un\u00adfamiliar code, wepresentmeasurementsfortwo ofthebenchmarks running with a non-trivial \nset of assertions added. In all cases, the overhead of the system remains extremelylow around3% or4%. \n 3.1.1 Methodology WeusetheDaCapobenchmarks(version2006-10-MR2)[6],SPEC JVM98 [39], and a .xed-workload \nversion of SPEC JBB2000 called pseudojbb [40]toquantifyperformance.ForSPECJVM98, we usethelargeinput \nsize(-s100);for DaCapo and pseudojbb, we use the default input size. All experiments were run on a 2.0 \nGHz Pentium-M machine with 2 GB of RAM, running Linux 2.6.20. We use the adaptive con.guration of Jikes \nRVM, which dy\u00adnamically identi.es frequently executed methods and recompiles them athigher optimizationlevels.Weiterate \neachbenchmarkfour times and record the results from the fourth iteration. We repeat thistwentytimesfor \neachbenchmark.We execute eachbenchmark with a heap size .xed at two times the minimum possible for that \nbenchmark using theMarkSweep collector. In Figures 2 and 3 we report two results for each benchmark. \nThe Base con.guration corresponds to running the unmodi.ed benchmark on an unmodi.ed version of Jikes \nRVM 3.0.0, using theMarkSweep collector.TheInfrastructure con.guration runs the unmodi.ed benchmark on \nour modi.ed version ofJikesRVM that supports GC assertions. This experiment measures the overhead of \nchecking the extra bits and recording debugging information the GC assertions infrastructure without \nany assertions added to the programs. We report the change in total execution time and GC time separately \nso the reader can understand the performance impact on both overall execution time and the GC subsystem. \nThe errorbars correspond to a90% con.denceinterval. InFigures4and5 we report resultsfor 209 db and pseudojbb \nmodi.ed toincludeGC assertionsin appropriateplaces.For exam\u00adple,in 209 db we assertedthat allEntry objects \nare ownedbytheir containingDatabase object, and we added assert-dead assertions at code locations where \nthe authors had assigned null to an instance Figure 3. GC-time overheadforGC assertioninfrastructure.OverallGC \ntimeincreasesby13.36%(thegeometric mean) and30%inthe worst case(bloat).     variable(a commonJavaidiomthat \nusuallyindicatesthatthe object pointed to should be unreachable). We describe our modi.cations to pseudojbb \ninSection3.2.1below.Thesetests are meantto sim\u00adulate the typical usage ofGC assertionsinproduction code.Again, \nthe errorbars correspond to a90% con.denceinterval.  3.1.2 Discussion For the Infrastructure con.guration, \nour results in Figures 2 and 3 show that the overhead of the assertion-checking infrastructure is very \nlow. Overall execution time increases by 2.75%, and mutator timeincreases1.12%, whichis withinthe noise.GCtimeincreases \nby13.36%, whichis reasonable considering thatthe collector must perform several checks on every objectit \nencounters. For the WithAssertions test, our results in Figures 4 and 5 show that we can check a large \nnumber of GC assertions without negatively affecting overall run-time. For 209 db, our added GC assertions \nresult in 695 calls to assert-dead and 15,553 calls to assert-ownedBy. During each GC, we check on average \n15,274 ownee objects to ensure they are correctly owned. Running time increases by 1.02% and GC time \nby 49.7% compared to the Base con.guration; they increase by 0.47% and 30.1%, respectively, compared \nto theInfrastructure con.guration.While theincreasein GC time is signi.cant, it is a low cost for checking \nthe ownership properties ofover15,000 objects.  For pseudojbb, our added GC assertions result in one \ncall to assert-instances and 31,038 calls to assert-ownedBy at run-time. However,we .nd thatduring eachGC \nonly420 owneeobjectsare checked(on average).The reasonforthisdescrepencyisthatOrder objects are relatively \nshort-lived. We instrument Order objects as they are inserted into an orderTable, but there is a great \ndeal of churn in the Orders as they are processed and removed from the orderTable. As a result, there \nare many con.gurations of the orderTable that our system never sees.Notethat our system must still maintain \nmeta-datafor each call to assert-ownedBy we must store information about each ownee, and we must remove \neach unreachable ownee after a GC. However, this extra work does not impactoverallperformance.We .ndthat \nrunningtimeincreasesby 1.84% andGC timeby15.3% compared to theBase con.guration; they increase by 2.47% \nand 4.40%, respectively, compared to the  Normalized execution time 150 Base Infrastructure WithAssertions100 \n50 0 with an assert-dead assertion,believingthat an objectthathadbeen destroyed shouldbeunreachable.Wefound \nthat dead Orderob\u00adjects are reachablefromCustomer objects.Uponfurtherinvestiga\u00adtion, we found that each \nCustomer object maintains a reference to the last Order this Customerplaced. When the Order is destroyed, \nthe lastOrder .eldin the associatedCustomeris not cleared, and this referenceprevents theOrderfrombeing \nreclaimed.Since each Order object maintains a reference to theCustomer to which itbe\u00adlongs, we were able \nto repair this leak by setting the reference in theCustomer to null when theOrderisdestroyed.Wefound \na sim\u00adilar situation with Address objects, which are also pointed to by Customer objects,butwe were not \nable to repairit since thereis no back referencefromAddresses toCustomers.Thepath examplein Figure1shows \nthedebugging outputgivenbyGC assertions when this errorisdetected. Figure 4. Run-time overheadwithGC \nassertions added.Even with The secondproblem wefoundwas moresubtle.Inthe mainloop of thebenchmark,theCompany \nobjectfromthepreviousiteration is destroyed (triggering a call to assert-dead) before creating the Companyobjectforthe \ncurrentiteration.ThepreviousCompanyis referencedinthe oldCompany localvariable,which remains visible \nthrough the whole method. Thus the previous Company object cannot be reclaimed. Simply setting the variable \nto null after the Companyisdestroyedallowsthis wholeCompanydata structureto be reclaimed. Note that the \nobject referenced by the oldCompany variable will be reclaimed on the following iteration when it is \nreplaced by the Company that was allocated in this iteration. This is not a memory leak but an example \nof memory drag, where the Companyobject couldbe reclaimed earlierthanitis.TheCompany data structure keeps \na great deal of data live, and reclaiming it earlier reduces memory pressure on the system. Notice also \nthat this problem could have been found by using assert-instances on theCompany type, sincethere can \nonlybe oneCompanyliveinthe benchmark at anygiven time. Third, weinvestigatedaknown memoryleakinSPECJBB2000 \n.rstreportedby Jump andMcKinley[27].SPECJBB2000places Order objectsinto anorderTable,implemented as aBTree, \nwhen they are created.They are completedduring aDeliveryTransaction butarenot removedfromthetable,causing \namemoryleak.To .nd alarge number of assertionsto check(over100,000for 209 db),  run-timeincreasesbyless \nthan2%. Normalized GC time 200 Base Infrastructure150 WithAssertions 100 50 0 Figure 5. GC-time overhead \nwithGC assertions added. Although this leak, we placed an assert-dead assertion for the Order object \nat the end of DeliveryTransaction.process(). OurGC asser\u00adtions system showed us the path through the \nobject graph where these Order objects were reachable, and with this information we were able to repair \ntheleak.Itisimportant to note that,for theGC the overheadfor 209 db is around49%, this timeis used to \ncheck assertionto work,theprogrammer mustknow thattheOrder object  shouldbedead atthe end of DeliveryTransaction.process(). \nHowever,in alargeprojectwhere no singleprogrammer can under\u00adstand the whole system, a GC assertion like \nthis would be helpful in explaining anomalousbehavior. Finally, we revisited the issue of dead Order \nobjects being reachable from Customer objects. One .aw of the assert-dead as\u00adsertion is that the user \nmust know where to place the assertions, i.e. where objects become unreachable. InSPECJBB2000, we are \nlucky that the program includes destructors to deallocate objects, but in the general case Java programs \nwill not have such infor\u00admation. Instead, we applied the assert-ownedBy assertion to the Orders in SPEC \nJBB2000. Orders are stored in an orderTable in each District, so we instrumented the District.addOrder() \nmethod and asserted that each Order added is owned by its orderTable. We found the same problem as before: \nCustomer objects keep Order objects live after they are removed from the orderTable. The ownership assertion \nis an easier way to detect suchproblems sincethe userdoes not needtoknow when an object shouldbedead. \napproximately15,000 owner-owneepairsduring eachGC. Infrastructure con.guration. We are able to check \nthe assertionsin pseudojbb at verylow cost.  3.2 Qualitative evaluation In addition to the performance \nbenchmarks above, we tested our GC assertions on real-world code to search for memory leaks and other \nerrors.WeinstrumentedSPECJBB2000 and lusearch from the Dacapo suite. In addition, we attempted to answer \na question from the Sun Developer Network by instrumenting the attached program. We found that in most \ncases, GC assertions helped us .nd and repair problems quickly and precisely. In addition, GC assertions \ngave us a better understanding of how these programs worked. 3.2.1 SPEC JBB2000 SPECJBB2000 is a benchmark \nthat emulates a three-tier business system, withdata storedinb-trees rather than an externaldatabase. \nNotably,ituses thefactorypattern to create anddispose of objects. We .rst instrumented the destroy() \nmethod of the Entity object  3.2.2 lusearch lusearch is abenchmarkintheDacapo suitethatteststheApache \nLucene textsearch enginelibrary[19]. lusearch reads apre-built index on disk andperforms searches over \nthe index using multiple threads. ThisbenchmarkusestheLuceneIndexSearcher classtoperform thesearches.TheLucenedocumentationstates, \nForperformance reasons it is recommended to open only one IndexSearcher and useitfor all ofyour searches. \n[21] Weinstrumented lusearch with an assert-instances assertion stating that only one instance of IndexSearcher \nshould be live. We found that for most of the benchmark s execution,32instances ofIndexSearcher arelive, \none for each thread performing searches. This could be repaired by using only oneinstance ofIndexSearcher \nand sharingit among the threads. In this example, the programmer using the Lucene library was not aware \nof this performance recommendation. The library code couldinclude an assert-instances assertion to warn \na userifhe tries to use more than oneIndexSearcherinstanceinhis code.  3.2.3 SwapLeak We investigated \na memory leak reported by Bond and McKin-ley[8].The memoryleak comesfrom aSunDeveloperNetwork post where \na user was asking for help understanding why an at\u00adtachedprogram runs out of memory[17].Theprogramde.nes \na class SObject with a non-static inner class Rep with an instance .eld that points to a Rep instance. \nThe SObject class de.nes a swap() method that takes another SObject and swaps the Rep .elds of each. \nThe main loop of the program allocates a .xed number of SObjectsand addsthemtoanarray.Ittheniteratesoverthearray, \nallocating new SObjects and swapping their Rep .elds with those of the SObjects already in the array. \nThe user expected that these new SObjects would be reclaimed after the swap, since they were not referencedby \nanylocal variables. Weinstrumented the user s code with assert-dead assertions af\u00adter the swap operation, \nand on execution we received thefollowing warning: Warning: an object that was asserted dead is reachable. \nType: LSObject; Path to object: LSArray; -> [LSObject; -> LSObject; -> LSObject$Rep; -> LSObject; This \nwarning explains the problem. An SObject in the array has a reference to an instance of the Rep inner \nclass, but that Rep instance maintains a pointer to a different SObject, one that we expected to be unreachable. \nThe problem stems from the fact that non-static inner classes have access to other members of the enclosing \nclass.Thus they must maintain ahidden reference to the enclosing class instance in which they were instantiated. \nOur GC assertions system displays this hidden reference and explains why theSObjectinstances were notbeing \nreclaimed. 4. Related Work Our work is related to a variety of techniques for checking heap\u00adbaseddata \nstructures andfordetecting memory errors.These tech\u00adniques can be roughly categorized according to (a) \nhow the de\u00adsiredproperties are speci.ed(rangingfromprogrammer-writtenin\u00advariants to statistical analyses, \nsuch as anomaly detection), and(b) when andhow oftenthe checks areperformed(either at compile\u00adtime, or \nat various granularities during execution.) GC assertions represent aparticularpoint in this space: on \nthe one hand, they re\u00adquire extra work to add to code, and thereis noguarantee of when they willbe checked; \non the otherhand, theyprovide theprogram\u00admer with an expressive range of checks and high-quality results, \nwhile maintaining extremelylow run-time cost. 4.1 Run-time checking GC assertions are closely related \nto program invariants, but dif\u00adfer in the balance between the strength of the guarantees pro\u00advided and \ntheperformance of checking. Modeling languages, such asJML[12] andSpec#[2], allowprogrammers to addinvariant \nspeci.cations into their code, which are checked automatically at run-time. These systems ensure that \nthe invariants always hold by checking them at every program point where they could be vio\u00adlated (for \nexample, after every routine that updates a data struc\u00adture). This approach, while complete, is extremely \nexpensive it can cause programs to run many times slower. Our system, on the other hand, checks heap \nproperties very ef.ciently, but at essen\u00adtially randomprogrampoints(GCs).GC assertions, therefore, can\u00adnot \ntechnically be considered invariants, since we can miss tran\u00adsient violations(those thatdo notpersist \nacross aGCboundary). Recent work has used incrementalization to speed up run-time invariant checking \nby eliminating recomputation of the invariant check onparts of thedata structure thathave not changed[38,25]. \nThistechniqueis complementary toGC assertions:if weknow that parts of a data structure have not changed \nsince the last GC, we could avoid checking assertionsfor those objects. HeapMD[13] monitorsproperties \nof objects(such asin-degree and out-degree) at run time and reports statistical anomalies as possible \nerrors. ShapeUp monitors similar properties for Java, but uses type information to make checks moreprecise[28].ShapeUp \ncomputes a class-.eld summarygraph and reports anomaliesinthe in-degree and out-degree of its nodes. \nAs with leak detection, the primary difference between this work and ours is that we allow theprogrammer \ntodeclare explicitly what conditions constitute an error, and we check those conditionsprecisely and \ncheaply. TheQVM[1]Java virtualmachineprovides heapprobes, which canbe used to check some of the sameproperties \nasGC assertions and are also implemented using garbage collector infrastructure. The semantics of heap \nprobes, however, are substantially different fromGCassertions.Heapprobes areperformedimmediately atthe \npointtheprobeis requested.QVMtriggers agarbage collectionfor each heap probe that must be checked, incurring \na hefty overhead thatis mitigatedby sampling theheapprobes rather than checking every single one.Our \nsystem, on the otherhand,batches assertions together and checks them all in a single heap traversal during \na regularly scheduled collection. As a result, checking is much moreef.cient,butit cannot verifypropertiesattheexactpointthe \nassertionis made.  4.2 Static analysis Previous work on static analysis has yielded a signi.cant body \nof sophisticated techniques for modeling the heap and analyz\u00ading data structures at compile-time. Previous \napproaches include pointer analysis[11,30,5], shape analysis[24,36,26],type sys\u00adtems[23,15,9], and formal \nveri.cation[31,16,42].The strength of static analysis is that it explores all possible paths through \nthe program: a sound analysis algorithm can prove the absence of er\u00adrors, or even verify the full correctness \nof a data structure imple\u00admentation. Static analyses, however, face three substantial chal\u00adlenges:(1) \nconservative assumptions aboutinput values and con\u00adtrol .owcanlead tomany spuriouserrors(falsepositives),(2) \nal\u00adgorithmsforbuilding adetailedheap model scalepoorly to whole\u00adprogram properties, and (3) analysis \ntypically fails for programs that use dynamic class loading, re.ection, or bytecode rewriting.  Our \nsystem builds on this work by supporting the kinds of data structure checks that have proved useful in \nstatic analysis, but avoids thepitfallsby checking them at run-time.  4.3 Instrumenting and controlling \nthe JVM SunprovidestheJVMToolInterface(JVMTI)[29] to allowtool developers to monitor run-time andGC activity.Several \nof ourGC assertions couldbeimplemented usingJVMTI, with the advantage that they would be portable across \ndifferent JVMs. We chose not to use JVMTI for three reasons. First, many of the hooks we need for GC \nassertions are optional parts of the speci.cation. Second, JVMTI would not allow us to explore certain \nreporting mecha\u00adnisms, such as the full object path. Finally, modifying the virtual machine incurs a \nlower performance overhead since we can per\u00adformlow-leveloptimizationslike using sparebitsin objectheaders \nand changing the order of object traversal in the GC to speed up assertion checking. O Neill and Burton \npropose a mechanism that allows users to annotate objects with smallpieces of code called simpli.ers, \nwhich are executedbythegarbage collector[34] when an objectistraced. Simpli.ersprovide ageneralmechanismforinjecting \ncodeintothe GC process, but the focus is on improving program performance. Some ofourGC assertions couldbeimplemented \nusing simpli.ers: for example,assert-dead() could useasimpli.ertocheck a .ag in the object or objectheader.It \nwould notbepossible,however, to implement an assertion like assert-ownedBy(), which requires changing \nthe order of traversal of the objectgraph. The COLA system allows programmers to dictate the layout order \nof objects to the garbage collector using an iterator-style interface[33].Like simpli.ers,thefocus ofCOLAison \ncontrolling thegarbage collector sbehavior toimproveperformance. 5. Conclusion The garbage collector \nis a powerful source of information about large-scale program state and behavior because it systematically \nvisits all objects and references in the heap. It is in a unique posi\u00adtion to check a wide variety of \ndata structure properties. Further\u00admore, the garbage collector can check properties, such as object lifetime,thatno \nother subsystemhas access to.Thispaperpresents a programmer-driven technique for taking advantage of \nthese ca\u00adpabilities by providing a structured way to communicate with the garbage collector. GC assertions \nare easy to use and provide ac\u00adcurate resultswithhigh-qualitydebugginginformation.Bypiggy\u00adbacking assertion \nchecks on the existingGC tracing algorithm,GC assertions are cheap enough tobe usedindeployed software, \nwhere they canhelpdetectthe mostimportant and seriousbugs:thosethat occurduring real executions. Acknowledgments \nWe would like to thank Mike Bond, Kathryn McKinley, Nick Mitchell, Nathan Ricci, Gary Sevitsky, Yannis \nSmaragdakis, and BenWiedermannfor theirhelpfulideas anddiscussions.We thank Steve Blackburn for his help \nwith the measurement methodology. Wethank the anonymous reviewersfor theirhelpful comments.Fi\u00adnally, \nwethanktheJikesRVMteamfortheirgreat workinbuilding animportantplatformfor research. References [1] M. \nArnold, M. Vechev, and E. Yahav. Qvm: an ef.cient runtime for detecting defects in deployed systems. \nIn OOPSLA 08: Proceedings of the 23rd ACM SIGPLAN conference on Object oriented programming systems languages \nand applications, pages 143 162,NewYork,NY,USA,2008.ACM. [2] M. Barnett, K. Rustan, M. Leino, and W. \nSchulte. The spec# programming system: An overview. http://research.microsoft.com/\u00adusers/leino/papers/krml136.pdf. \n[3] BEA. JRockit Mission Control. http://dev2dev.bea.com/jrockit/\u00adtools.html. [4] E.D.Berger,B.G.Zorn,andK.S.McKinley.Reconsidering \ncustom memory allocation. In Conference onObject-Oriented Programming, Systems,Languages, andApplications,pages1 \n12,2002. [5] M.Berndl,O.Lhot\u00b4ak,F.Qian,L.Hendren,andN.Umanee.Points-to analysis usingbdds. In ACMConference \nonProgrammingLanguages Design and Implementation, pages 103 114, New York, NY, USA, 2003.ACM. [6] S.M.e.a.Blackburn.TheDaCapoBenchmarks:JavaBenchmarking \nDevelopment and Analysis. In Conference on Object-Oriented Programming,Systems,Languages, andApplications, \n2006. [7] M.D.Bond andK.S.McKinley.Bell:Bit-Encoding OnlineMemory LeakDetection. InInternationalConference \nonArchitecturalSupport forProgramming Languages andOperating Systems,2006. [8] M. D. Bond and K. S. McKinley. \nTolerating memory leaks. In OOPSLA 08:Proceedingsof the23rdACMSIGPLAN conferenceon Object oriented programming \nsystems languages and applications, pages109 126,2008. [9] C. Boyapati, B. Liskov, and L. Shrira. Ownership \ntypes for object encapsulation. In ACMSymposium on thePrinciples ofProgramming Languages,pages213 223,2003. \n[10] N.R.Cameron,S.Drossopoulou,J.Noble,andM.J.Smith.Multiple ownership. In ACM Conference on Object-Oriented \nProgramming Systems,Languages, andApplications,pages441 460,2007. [11] D.R.Chase,M.Wegman,andF.K.Zadeck.Analysisofpointersand \nstructures. In ACM Conference on Programming Languages Design and Implementation, pages296 310,1990. \n[12] Y.CheonandG.T.Leavens.A runtimeassertioncheckerforthejava modelinglanguage(jml). TechnicalReportTR03-09,IowaState \nUniversity, 2003. [13] T.M.Chilimbi andV.Ganapathy. HeapMD:Identifying Heap-based Bugs using Anomaly \nDetection. In International Conference on Architectural Support for Programming Languages and Operating \nSystems,2006. [14] T. M. Chilimbi and M. Hauswirth. Low-Overhead Memory Leak Detection Using Adaptive \nStatistical Pro.ling. In Conference on Architectural Support for Programming Languages and Operating \nSystems,pages156 164,2004. [15] D.G.Clarke,J.M.Potter,andJ.Noble.Ownership typesfor .exible aliasprotection. \nSIGPLANNotices,33(10):48 64, 1998. [16] P. T. Darga and C. Boyapati. Ef.cient software model checking \nofdata structureproperties. In ACM Conference on Object-Oriented ProgrammingSystems,Languages, andApplications,pages363 \n382, 2006. [17] S.D.N.Forum. Javaprogramming[archive] -garbagecollection dilema(sic). http://forums.sun.com/thread.jspa?threadID=446934. \n[18] A.S.Foundation.Apachehttpserverproject.http://httpd.apache.org/. [19] A.S.Foundation. Apachelucene \n-overview. http://lucene.apache.\u00adorg/java/docs/index.html. [20] A. S. Foundation. Apache portable runtime \nproject. http://apr.\u00adapache.org/. [21] A.S.Foundation. Indexsearcher(lucene1.9.1 api). http://lucene.\u00adapache.org/java/1 \n9 1/api/org/apache/lucene/search/IndexSearcher.\u00adhtml. [22] J. Fox. When is a singleton not a singleton? \nhttp://java.sun.com/\u00addeveloper/technicalArticles/Programming/singletons/. [23] P.Fradet andD.L.M\u00b4etayer.Shapetypes.In \nACMSymposium onthe Principles ofProgramming Languages,pages27 39,1997. [24] R.GhiyaandL.J.Hendren. Isit \natree,aDAG,oracyclicgraph?A shape analysis for heap-directed pointers in C. In ACM Symposium onthePrinciples \nofProgramming Languages,pages1 15,1996.  [25] M.Gorbovitski,T.Rothamel,Y.A.Liu, andS.D.Stoller. Ef.cient \nruntime invariant checking: a framework and case study. In WODA 08: Proceedings of the 2008 international \nworkshop on dynamic analysis,pages43 49,2008. [26] B.Hackett andR.Rugina. Region-based shapeanalysis \nwith tracked locations. In ACM Symposium on the Principles of Programming Languages,pages310 323,2005. \n[27] M.Jump andK.S.McKinley.Cork:dynamicmemoryleakdetection for garbage-collected languages. In Symposium \non Principles of ProgrammingLanguages,pages31 38,2007. [28] M. Jump and K. S. McKinley. Dynamic shape \nanalysis. In ACM InternationalSymposium onMemoryManagement, 2009. [29] Jvmtoolinterface.http://java.sun.com/javase/6/docs/platform/jvmti/\u00adjvmti.html. \n[30] W.Landi,B.G.Ryder, andS.Zhang. Interprocedural modi.cation side effect analysis with pointer aliasing. \nIn ACM Conference on Programming Languages Design and Implementation, pages 56 67, 1993. [31] S. McPeak \nand G. Necula. Data structure speci.cations via local equality axioms. In Computer Aided Veri.cation, \npages 476 490, 2005. [32] N. Mitchell and G. Sevitsky. LeakBot: An Automated and LightweightToolforDiagnosingMemoryLeaksinLargeJavaAppli\u00adcations. \nIn European Conference on Object-Oriented Programming, pages351 377,2003. [33] G. Novark, T. Strohman, \nand E. D. Berger. Custom object layout forgarbage-collectedlanguages. TechnicalReportUM-CS-2006-06, UMassAmherst,2006. \n[34] M. E. O Neill and F. W. Burton. Smarter garbage collection with simpli.ers. In Workshop on Memory \nSystem Performance and Correctness,pages19 30,2006. [35] Quest. JProbe Memory Debugger. http://www.quest.com/jprobe/\u00addebugger.asp. \n[36] M.Sagiv,T.Reps,andR.Wilhelm. Parametric shapeanalysis via3\u00advalued logic. In ACMSymposium onthePrinciples \nofProgramming Languages,pages105 118,1999. [37] SciTech Software. .NET Memory Pro.ler. http://www.scitech.se/\u00admempro.ler/. \n[38] A.ShankarandR.Bod\u00b4ik.Ditto:automaticincrementalization ofdata structureinvariant checks(injava). \nIn PLDI 07: Proceedings of the 2007 ACM SIGPLAN conference on Programming language design and implementation, \npages 310 319, New York, NY, USA, 2007. ACM. [39] Standard Performance Evaluation Corporation. SPECjvm98 \nDocu\u00admentation, release1.03 edition,1999. [40] Standard Performance Evaluation Corporation. SPECjbb2000 \nDocumentation, release1.01 edition,2001. [41] X.Wang,Z.Xu,X.Liu,Z.Guo,X.Wang,andZ.Zhang.Conditional correlation \nanalysis for safe region-based memory management. In PLDI 08: Proceedings of the 2008 ACM SIGPLAN conference \non Programming language design and implementation, pages 45 55, NewYork,NY,USA,2008.ACM. [42] K. Zee, \nV. Kuncak, and M. Rinard. Full functional veri.cation of linked data structures. In ACM Conference on \nProgramming LanguagesDesign andImplementation, pages349 361,2008.    \n\t\t\t", "proc_id": "1542476", "abstract": "<p>This paper introduces <i>GC assertions</i>, a system interface that programmers can use to check for errors, such as data structure invariant violations, and to diagnose performance problems, such as memory leaks. GC assertions are checked by the garbage collector, which is in a unique position to gather information and answer questions about the lifetime and connectivity of objects in the heap. By piggybacking on existing garbage collector computations, our system is able to check heap properties with very low overhead -- around 3% of total execution time -- low enough for use in a deployed setting.</p> <p>We introduce several kinds of GC assertions and describe how they are implemented in the collector. We also describe our reporting mechanism, which provides a complete path through the heap to the offending objects. We report results on both the performance of our system and the experience of using our assertions to find and repair errors in real-world programs.</p>", "authors": [{"name": "Edward E. Aftandilian", "author_profile_id": "81350584830", "affiliation": "Tufts University, Medford, MA, USA", "person_id": "P1464284", "email_address": "", "orcid_id": ""}, {"name": "Samuel Z. Guyer", "author_profile_id": "81332502517", "affiliation": "Tufts University, Medford, MA, USA", "person_id": "P1464285", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542503", "year": "2009", "article_id": "1542503", "conference": "PLDI", "title": "GC assertions: using the garbage collector to check heap properties", "url": "http://dl.acm.org/citation.cfm?id=1542503"}