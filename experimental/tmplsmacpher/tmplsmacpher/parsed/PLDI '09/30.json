{"article_publication_date": "06-15-2009", "fulltext": "\n Automatic Generation of Library Bindings Using Static Analysis * Tristan Ravitch Steve Jackson Eric \nAderhold Ben Liblit Computer Sciences Department, UniversityofWisconsin Madison {travitch, sjackso, \naderhold, liblit}@cs.wisc.edu Abstract High-level languagesaregrowinginpopularity.However,decadesof \nCsoftwaredevelopmenthaveproduced large librariesoffast, time\u00ad tested,meritorious code thatareimpracticalto \nrecreatefromscratch. Cross-language bindingscanexposelow-levelCcodeto high-level languages. Unfortunately,writingbindingsby \nhandis tedious and error-prone, while mainstream binding generators require extensive manual annotation \norfailtooffer thelanguagefeaturesthat usersof modern languages have come to expect. We present an improved \nbinding-generation strategy based on staticanalysisof unannotatedlibrary source code.We characterize \nthree high-level idiomsthat are not uniquely expressibleinC slow\u00ad level type system:array parameters, \nresourcemanagers, andmultiple returnvalues.We describea suiteof interprocedural analysesthat recoverthis \nhigh-levelinformation, and we show howthe results canbeusedinabinding generatorforthePythonprogramming \nlanguage.InexperimentswithfourlargeClibraries,we.ndthat our approach avoids the mistakes characteristic \nof hand-written bindingswhileofferingalevelof Python integration unmatched by prior automated approaches. \nAmong the thousands of functions inthe public interfacesoftheselibraries,roughly 40%exhibit the behaviors \ndetectedby our static analyses. Categories and Subject Descriptors D.2.11[Software Engineer\u00ad ing]:Software \nArchitectures Languages; D.2.13[Software Engi\u00ad neering]: Reusable Software Reusablelibraries; D.3.2[Program\u00ad \nming Languages]:LanguageClassi.cations C,Python; D.3.3 [Programming Languages]:LanguageConstructs and \nFeatures Dynamic storagemanagement,Procedures, functions,and subrou\u00ad tines; D.3.4[Programming Languages]:Processors \nCode genera\u00ad tion,Memory management; E.1[Data Structures]: Arrays; F.3.2 [Logics and Meanings of Programs]: \nSemantics of Programming Languages Program analysis General Terms Languages,Reliability, Experiments,HumanFac\u00ad \ntors * Supportedin partbyAFOSRgrantFA9550-07-1-0210;LLNL contract B580360; andNSF grantsCCF-0621487, \nCCF-0701957, andCNS-0720565. Anyopinions, .ndings, and conclusions or recommendations expressed in this \nmaterial arethoseof the authors anddo not necessarilyre.ect theviews of NSF or other institutions. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 09, June 15 20, 2009, \nDublin, Ireland. Copyright c . 2009ACM 978-1-60558-392-1/09/06... $5.00 Keywords FFI, foreign function \ninterfaces, bindings, libraries, data.ow analysis, modular static program analysis, multi-language code \nreuse 1. Introduction In recent years, high-level languages have made inroads into areas formerly reservedforlow-levellanguages, \nsuch as scienti.ccom\u00ad puting and non-kernel systems programming.Ahigh-level language can speeddevelopmentbyoffering \nhelpful featureslikeautomatic memory management. However,even withincreasingly-capable high-levellanguages, \nthere remains a need to access code written in low-level languages. Some important reasons include: Direct \naccess: By theirverynature,high-levellanguagesattempt to hidelow-level detailsfrom programmers. Sometimes,these \ndetailsbecomeimportant,eitherforperformanceincriticalloops orforinteractionwith hardware,andhigh-levellanguagesdo \nnot always provide means to operate on the metal. Codereuse: Well-tested codehas greatvalue:itsbugs areatleast \nknown,if not .xed.Rewritingcoderisksintroducing new and unknownbugs.In manysituations, there may notbetimeto \nport a large code-base to a new language, even if such a port is desirable. Additionally, sharingasinglelibrary \namong severallanguages promotesinteroperabilityandfrees designersfrom theburden of reimplementing the \nsame speci.cation in every language. Many high-level languages facilitate the reuse of low-level libraries \nthrough foreignfunction interfaces, which permit high\u00adlevellanguagestomakecallstonativecode.When discussingsuch \ncalls, werefertothe high-levellanguage as the hostlanguage and the native code as a guest library;thelow-levellanguage \nthatproduced the guest libraryis thus the guest language.We refer to a set of host language functions \nwhich make an entire guestlibraryavailable through some form of function interface as a librarybinding.We \nonly considerCastheguestlanguageinthispaper,buttheprinciples can be applied to other languages. Whena \nsmallnumberofguest functions are neededina host language, it may be convenient for a developer to use \nforeign function interfaces by hand. However, the task of building a complete binding for a large library \nis nontrivial. In this paper, wearguethatthistaskoughttobe automated,andshowthatexisting techniques for \nsuchautomation maybe greatlyimprovedby static analysis of a guest library s source code. Theremainderof \nthis paperis organizedasfollows. Section2 motivates ourwork. Section3identi.es desirablefeaturesforlibrary \nbindings that cannotbe representedinCfunction declarationsalone. Section4describesasuiteofinterproceduralstatic \nprogramanalyses that recoverthismissing informationfromClibrarysource code.In  Section5 we presenta \nconcreteexampleclient for thisinformation: anautomated binding generator for thePython scriptinglanguage. \nWe have used this generator to create bindings to four large C libraries,andweevaluatetheresultsin Section6.Section7discusses \nrelated research, and Section8concludes. 2. Motivation Creating and maintaining library bindings can \nbe a costly and error\u00ad proneprocess,especiallywhentheinterfacesofguestlibrariesare subjectto change.Numerous \nteamsofdevelopersexistto maintain major binding projects. Examples include gtk2-perl, PyQt, gtkmm, andjava-gnome. \nTheyrepresent an under-served programmer com\u00ad munity whose work willbecome more critical as mixed-language \ndevelopment becomes more prevalent. Forlargelibraries,itisimpracticaltohand-code hostlanguage wrappersforallguestlibrary \nfunctions.ToolssuchasSWIG[3]and ctypeslib [18]partiallyautomate this processby readinglibrary headers \nand generating library bindings automatically. Several librarybindingteams,includingPyGTK andPyQt,havecreated \nand maintain theirowncode generators based uponCorC++headersto partially automate the binding generation \nprocess. However, the interfaces generatedby header-scanning systems do not takeadvantageofhigher-levelfeaturesofferedby \nhostlan\u00ad guages unless manual annotations to the guest library are provided. This needforannotations \narises becausethereis no one-to-one map\u00ad pingof programmer intentto thesetofClanguage constructs that \ndeclarealibrary s publicinterface.Keyaspectsof high-level design arelost,andno amountof header scanningwillbringthemback.We \nassert that these higher-level properties can be recovered, without annotations, by moving beyond headers \nto deeper static analysis oflibraryimplementation code. This,inturn, supports automated generation of \nlibrary bindings which are less prone to error and more natural to use. Additionally, the analysis techniques \nshown in this paper can support library understanding. The analyses produce summaries of functioninterfaces; \nthesummariescanhelpdevelopersverify their understandingof theseinterfaces.Ifa summary exhibits an unexpected \nfeature, or lacks an expected one, a developer may investigate the cause. Such information may be useful \nto boththe creators and users of a library. The results of our analysis may also be useful for tracking \nAPI evolution.Givenfunction summariesfromtwodifferentversions ofalibrary,asimpledifferencingtool canshow \nchangesinthe prototypesoflibrary functions, as well as changesin their higher\u00adlevel behavior. 3. Interface \nSpeci.cationinC Wewouldliketo generatelibrarybindings forlow-level code that arebothsafeand natural.Asafebindingintroducesnomorememory \nunsafetythanis inherenttotheguestlibrarybeingused.Anatural binding supports host-language programmers \nby integrating the guest library into the high-level services of the host language. Unfortunately, theC \ntype systemitselfstands as an obstacle to both of these goals. In one regard, the type system is highly \nunambiguous:every parameterinCispassedbyvalue,andpointers are simplyaddresses. Considered more closely, \nhowever, several higher-levelidiomsarepresent;programmerssimplylackthesyntax to distinguish them. 3.1 \nPointerParameter Ambiguities Modern host languages typically offer some tightly-integrated sequence type, \nsuchasalist or dynamic arraytype. Programmersin a hostlanguage will preferthesecontainersover containersde.ned \nbya guestlibrary. Thus,itwouldbe naturaltoallow programmersto pass host-language sequencetypesacrossbindingsto \nguestlibraries, with appropriate data transformations applied automatically. InC,theonly.rst-class sequencetypeisthe \narray. Unfortunately, C offers no enforced syntax for declaring array-typed function parameters: arrays \nare passedby address, and thereforeafunction which processes an array must declare that it takes a pointer \nto the array selementtype asaparameter.C s type system simply cannot distinguish array parametersfrom \nother pointer parameters. Any interface generator based only on parsingCheaders, then, requires anannotationtorecognizeopportunitiestoallow \nuserstopasshost\u00ad language sequence typesin placeof rawCarrays. Pointer-typedparameters are likewise overloaded \nto simulate call-by-reference,such asfor multiplereturnvalues. TheClanguage providesat most onereturnvalueforanyfunction,andoffersno \ncall-by-reference parameters.Afunction that produces more than one value must either return a wrapper \nstructure or accept pointers to locations where additional outputvalues shouldbestored.To avoid cumbersome \nuse of custom struct types, manylibraries choose the latter approach. Forexample, the standardClibraryfunctionfrexp \ntakestwo parameters: a .oating point number x and an integer pointer exp. double frexp(double x, int \n*exp); This function returns a value r and stores a second value e through the pointer exp such that \nr = x \u00d72e. Here, exp is used as an output parameter, but is syntactically indistinguishable from a generic \npointer (or indeed an array). Manyhost languages have better support for multiple return val\u00ad ues.Library \nbindingscan performa usefulserviceby transforming instancesofthiscommonpatternintorealmultiple-return-value \ncon\u00ad structsinthe host language.A wrapper functioncan automatically allocate space for these output parameters, \npasstheir addresses to the underlyinglibraryfunction, and return the resultsthrough the hostlanguage \ns native multiple returnvalue mechanism.Again,C headersdo notprovideenough informationto distinguishthis \ncon\u00ad structionfroma standardpointerparameter,anda binding generator that relies only on headers would \nneed annotations to detect it.  3.2 Object Ownership One signi.cant bene.t of working in a high-level \nlanguage is a garbage collector s assistance withmemory management. Such a facility can also help to \nclean up other program resources, like .le handles. Since users of most potential host languages are \naccustomed to automatic resource management, it is desirable to integrate foreign library resources with \nthis infrastructure. C libraries often contain a set of constructor functions that return handles (typically \npointers)to newly allocatedandinitialized objects.1 Anaturalhigh-levellanguagebindingfora constructor \nfunction would extend automatic resource management to cover these newly-allocated objects. While registering \nthese objects with the host language garbage collector is important, it is equally important to ensure \nthatthey are cleaned up, or .nalized, correctly. No one general-purpose .nalizing function is appropriatefor \nall objectsallocatedinC, since the host language maynot know their composition and semantics. Properly \nreclaiming resources held by complex objects, such as .le handles or database connections, requires more \nthan simple memory deallocation. Constructorfunctions aresyntacticallyindistinguishable from any otherCfunction \nthat happensto returnapointer. Likewise, .nalizers are indistinguishablefrom anyother function that takesa \npointer-typed argument.Abinding generatorthatrelies on header 1Chas no formal object system.We useobject \nhere to describe structured regionsof memorythat occupyresources when constructedand releasethem when \n.nalized.  .les alone would require annotations to detect constructors and .nalizers.However,identifying \nthesefunctions helps us to create library bindings that are safe and natural. Since header .les are insuf.cient, \nwe mustlook deeper. By detecting functions that create anddestroyresources,staticanalysisoflibrary sourcecodecanhelp \nusbuild the bindings we desire. The goalofalibrarybindingistofollow the resourcemanage\u00adment conventionsoftheguestlibrary \nwithoutneedlesslyburden\u00adingthe hostlanguage programmer. Garbage collector integration is only one broadly-applicable \nexample of how our analysis can helpwith cross-language resource management; other management policies \ncould be applied. Regardless of the strategy employed, cross-languageresource managementisa serious issue.A \nsearchof theGNOME ProjectBugzilla database[14]reveals numerousbugs in library bindings relating to memory \nmanagement2. 4. Analyses Wehaveimplementeda seriesofanalysestoinfer enoughinfor\u00ad mationtoprovide higher-levelinterfaces.Allof \nouranalysesmake conservative assumptions because we do not have an entire program to analyze. Our analyses \nare all interprocedural, context-insensitive, and path-insensitive. In each analysis, information propagates \nalong the callgraph fromcalledfunctions(callees)totheir callers,but not viceversa.This ensures that imprecision \nincurredfrom our lackof path-sensitivity does not lead tofalse inferences about callees. Alibrarymayrelyonotherlibraries,and \nmostClibrariesrely onthestandardClibrary.Inorderto analyze dependentlibraries separately, our suite of \nanalyses take a set of interface descriptions asanadditional input. The interface descriptionforalibrary \ncontains all the facts about its functions (and their parameters) that our analysis requires. These descriptions \nare stored as an immutable base set offacts, which ouranalysis consults whenit encountersa calltoanexternalfunction.Thedomainoffactsprovidedinthese \ndescriptionsisexactlythe domainoffacts producedby the analysis itself.Thus,the analysisismodularper-library:theoutputofthe \nanalysis on onelibrary canbe used as aninputinterface description for another library thatrelies upon \nit.To bootstrap our analysis, we havehand-written interfacedescriptions fortheCstandard library and the \nLinuxkernelsystem callinterface. These descriptions serve as a base set for all libraries. We have also \nimplemented a lightweight, optionalannotation systemthatcanimprove theanalysis outputby puttingextra \ninfor\u00ad mation into thebase setoffacts before analysisbegins.We discuss these annotations withtheir associated \nanalyses.Thisannotation sys\u00ad temisseparatefrom thesourcecodeof the library,andso requires no modi.cation \nto the library itself. Inthe followingdiscussion,weassumethatthe guestlanguageis C,andthattheguestlibrarysourcecodehas \nundergonethefollowing preparatory transformations: 1. Array operations have been replaced with equivalent \npointer\u00adarithmetic. For example, buffer[offset] is rewritten as *(buffer + offset). 2. Each function \nhas a unique exit node. 3. The entire program has been placed in static single assignment  (SSA)formwithglobalvalue \nnumbering(GVN)perAlpernetal. [1]. 4. Aglobal alias analysis has been performed. 2A few examples are GNOME \nbugs 129754, 133681, 313861, 358294, 482795, and 498334.Our approach could have prevented atleast .ve \nof these. = INOUT  IN OUT   . = UNUSED Figure1: Hassediagramofoutput parameterlattice.Anedge a. b \nrepresents a-bin the lattice partial order. 4.1 OutputParameters Our .rst analysisfacilitates the multiplereturnvalue \ntransforma\u00adtiondiscussedin Section 3.1.Toperformthistransformation,we needto knowwhich parametersto anygivenfunction \nare output parameters. An output parameter is a pointer-typed parameter that isalways written through \nbefore beingreadfrom.Otherpointer\u00adtypedparametersfall into oneofthreeremainingcategories.An input parameter \nisalways read frombut never written through.An input/output parameter is readfrom andlaterwritten through.An \nunused parameter is neither read from nor written through at all. We classifypointer-typedparameters \nusingaforwarddata.ow analysis. The analysis operates over single program statements and considers each \npointer-typed parameterinisolation.Theanalysis for a given formal parameter p in a function f is constructed \nas follows. The state of p at eachstatementis anelementof the boundedlattice given in Figure 1.The initial \nstate on entry to f is .. The join operation atany statementistheleast upper bound(latticejoin) of the \nexit states from all predecessor statements. The transfer function atagivenstatementdepends on the syntacticformofthat \nstatement: For statementsthat writethroughq where q must alias p,the exitstateistheleast upper boundoftheentry \nstateandOUT.For example,following*p =v,apointerthathadnever previously been used at all(.)will acquire \nthe stateOUT, while a pointer thathadpreviously beenreadfrom(IN)willacquirethe state INOUT . For statementsthat \nread fromq where q mayalias p, the exit stateis OUT if the entry state was OUT, oristhe least upper boundofthe \nentry state and IN otherwise.Thus, following v= *p,a pointer thatwas previously unused(.)will acquire \nthe state IN, while a pointer that had previouslyonlybeen written through(OUT)will retain the stateOUT. \n For function calls that pass q as a parameter to function f where q mayalias p, the writing and reading \nrules discussed  above apply and are determinedby the states of the appropriate parameter of f . Calls \nthrough function pointers are treated conservatively: if q is used as a parameter to a function pointer, \nit acquiresthe state INOUT unlessit hasalready beenprovedto be OUT. Forallotherstatements,theexit stateisthesameasthe \nentry state. At any given statement, the least solution to these data.ow equations associates OUT with \neachpointer-typed parameter that must be writtenthrough atleast once before it may be readfrom. Parametersin \ntheOUT state ata function s unique exit node, then, are the output parameters for that function. Theabovealgorithmappliesonlyto \npointerstoprimitivetypes (including other pointers). A straightforward change is required to extend it \nto handle pointers to aggregates, as follows. At the \n\t\t\t", "proc_id": "1542476", "abstract": "<p>High-level languages are growing in popularity. However, decades of C software development have produced large libraries of fast, time-tested, meritorious code that are impractical to recreate from scratch. Cross-language bindings can expose low-level C code to high-level languages. Unfortunately, writing bindings by hand is tedious and error-prone, while mainstream binding generators require extensive manual annotation or fail to offer the language features that users of modern languages have come to expect.</p> <p>We present an improved binding-generation strategy based on static analysis of unannotated library source code. We characterize three high-level idioms that are not uniquely expressible in C's low-level type system: array parameters, resource managers, and multiple return values. We describe a suite of interprocedural analyses that recover this high-level information, and we show how the results can be used in a binding generator for the Python programming language. In experiments with four large C libraries, we find that our approach avoids the mistakes characteristic of hand-written bindings while offering a level of Python integration unmatched by prior automated approaches. Among the thousands of functions in the public interfaces of these libraries, roughly 40% exhibit the behaviors detected by our static analyses.</p>", "authors": [{"name": "Tristan Ravitch", "author_profile_id": "81435608761", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464315", "email_address": "", "orcid_id": ""}, {"name": "Steve Jackson", "author_profile_id": "81536535256", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464316", "email_address": "", "orcid_id": ""}, {"name": "Eric Aderhold", "author_profile_id": "81435611352", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464317", "email_address": "", "orcid_id": ""}, {"name": "Ben Liblit", "author_profile_id": "81100555854", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P1464318", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542516", "year": "2009", "article_id": "1542516", "conference": "PLDI", "title": "Automatic generation of library bindings using static analysis", "url": "http://dl.acm.org/citation.cfm?id=1542516"}