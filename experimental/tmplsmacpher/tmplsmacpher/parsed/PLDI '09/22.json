{"article_publication_date": "06-15-2009", "fulltext": "\n Implementation of the Memory-safe Full ANSI-C Compiler Yutaka Oiwa Research Center for Information \nSecurity (RCIS) National Institute of Advanced Industrial Science and Technology (AIST), Japan y.oiwa@aist.go.jp \nAbstract This paper describes a completely memory-safe compiler for C lan\u00adguage programs that is fully \ncompatible with the ANSI C speci.\u00adcation. Programs written in C often suffer from nasty errors due to \ndan\u00adgling pointers and buffer over.ow. Such errors in Internet server programs are often exploited by \nmalicious attackers to crack an entire system. The origin of these errors is usually corruption of in-memory \ndata structures caused by out-of-bound array accesses. Usual C compilers do not provide any protection \nagainst such out\u00adof-bound access, although many other languages such as Java and ML do provide such protection. \nThere have been several proposals for preventing such memory corruption from various aspects: run\u00adtime \nbuffer overrun detectors, designs for new C-like languages, and compilers for (subsets of) the C language. \nHowever, as far as we know, none of them have achieved full memory protection and full compatibility \nwith the C language speci.cation at the same time. We propose the most powerful solution to this problem \never pre\u00adsented. We have developed Fail-Safe C, a memory-safe implemen\u00adtation of the full ANSI C language. \nIt detects and disallows all un\u00adsafe operations, yet conforms to the full ANSI C standard (includ\u00ading \ncasts and unions). This paper introduces several techniques both compile-time and runtime to reduce the \noverhead of runtime checks, while still maintaining 100% memory safety. This compiler lets programmers \neasily make their programs safe without heavy rewriting or porting of their code. It also supports many \nof the dirty tricks commonly used in many existing C programs, which do not strictly conform to the standard \nspeci.cation. In this paper, we demonstrate several real-world server programs that can be pro\u00adcessed \nby our compiler and present technical details and benchmark results for it. Categories and Subject Descriptors \nD.3.4 [PROGRAMMING LANGUAGES]: Processors Compilers General Terms Languages, Security Keywords Memory \nSafety, C language Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 09, June 15 20, 2009, Dublin, Ireland. Copyright c . 2009 ACM 978-1-60558-392-1/09/06. \n. . $5.00 1. Introduction The C language, which was originally designed for programming early Unix systems, \nallows a programmer to code .exible mem\u00adory operations for high runtime performance. It provides .exible \npointer arithmetic and type casting of pointers, which can be used for direct access to raw memory. Thus, \nC can be easily used as a re\u00adplacement for assembly languages to write many low-level system programs \nsuch as operating systems, device drivers, and runtime systems of programming languages. Today, C remains \none of the major languages for writing ap\u00adplication programs, including those running on various Internet \nservers. As requirements for applications have become more com\u00adplex, though, programs written in C have \noften been used to per\u00adform very frequent complex pointer manipulations. This has cre\u00adated serious security \n.aws. In particular, if in-memory data struc\u00adtures are destroyed by array buffer over.ows or dangling \npointers, the behavior of a running program becomes completely different from its text. In addition, \nby forging specially formed input data, malicious attackers can sometimes hijack the behavior of programs \nthat contain such bugs. Most of the recently reported security holes have been due to such misbehavior. \nMany countermeasures to this problem have been proposed. Buffer-overrun detection techniques, such as \nStackGuard [6], ProPolice [7], and dmalloc [21], are well matured and have been introduced into many \ncommercial and open-source compilers, al\u00adthough they prevent only some of the possible attacks. There \nhave been many proposals for C-like languages that satisfy type safety and memory safety, such as Cyclone \n[9, 11]. Necula et al. [16, 5] proposed a type-based program analysis for compiling a large sub\u00adset of \nC languages and succeeded in compiling existing C bench\u00admarks with a small amount of program modi.cation. \nHowever, as far as we know, no one has achieved both complete memory safety (e.g., comparable to Java \nor many Lisp/ML dialects) and full com\u00adpatibility with the C language at the same time. To resolve the \ncurrent situation, we have developed Fail-Safe C, a special implementation of the full ANSI C language \nthat prevents all of the dangerous memory operations that lead to execution hijacking. Our compiler inserts \ncheck code into the program to prevent operations that destroy memory structures or execution states. \nIf a buggy program attempts to access a data structure in a way that would lead to memory corruption, \nthe runtime system of our compiler system cooperates with the inserted codes to report the error and \nterminate program execution. Use of our compiler system instead of usual C compilers enables safe execution \nof existing C programs. Our compiler supports all programs written in conformity with the 1989 version \nof the ANSI C speci.cation [10, 1, 14], includ\u00ading casts, unions, arbitrary pointer arithmetics, function \npointers (cast and uncast), and variable-number arguments (varargs). More\u00adover, it also supports many \nof the dirty tricks popular with C programmers in order to ensure it can accept most existing pro\u00adgrams. \nOf course, our compiler cannot accept every existing pro\u00adgram: programs that really need raw memory access \n(e.g., the core part of operating system kernels) con.ict with our memory protec\u00adtion scheme. However, \nour scheme is powerful enough to accept many security-critical programs used on Internet servers, most \nof which do not need raw memory access. The current implementation of our compiler accepts several existing, \nrealistic server programs such as OpenSSL, OpenSSH, and BIND9.  This paper describes several implementation \ntechniques and de\u00adsigns introduced in Fail-Safe C. The rest of the paper is organized as follows: Section \n2 describes the basic ideas of our system design to support memory-safe execution of C programs including \ncast and pointer arithmetics. Section 3 describes some details of the im\u00adplementation, including tricks \nfor better performance and support for various subtle features of C. Sections 4 and 5 present the current \nstatus of Fail-Safe C implementation and some benchmark results for performance evaluation. Section 6 \ncompares the design of Fail-Safe C with those in some previous reports. Section 7 concludes by summarizing \nthe main points and mentioning future work. This work is based on the implementation method proposed \nin the author s Ph.D. dissertation [19] with various design and implementation improvements. For more \nspeci.c details of our implementation, please refer to the dissertation as a full version of this paper. \nNote Throughout this paper, we assume that the underlying ar\u00adchitecture uses 32-bit pointers and integers \nfor clarity. This is just for an example: our technique, as well as those in most other re\u00adports, can \nsupport various word widths such as 32 and 64. The term word refers to the natural size of pointers, \ni.e., 32 bits or 4 bytes. Example program code shown in this paper was written by hand for clear understanding \nof concepts: it is not textually equal to the program generated by the compiler. 2. Basic Designs There \nare many language constructs in C that are not found in var\u00adious safe languages (such as Java, C#, Lisps, \nand MLs) and make safe implementation of the language dif.cult. First, C supports .ex\u00adible arithmetic \noperations on the pointers. In most safe languages, references to objects or arrays are designed so that \nthey point only to a whole array or an object. Such languages allow refer\u00adences handled as only opaque \ndata and do not allow arbitrary arith\u00admetic operations on them. This is a common design choice to ease \nruntime checking of array boundaries: by allowing references that point only to a .xed location inside \nan object, the language run\u00adtime systems can easily access metadata associated with each ob\u00adject such \nas array sizes and perform required runtime validations. In C, however, pointers are allowed to point \nanywhere inside array objects, which makes boundary checking hard. Storing the object boundaries (e.g., \nusing memory object tables) does not work well: pointers that have over.owed might even point to the \ninterior of another object. Cast operations and union types make safe implementation of the language \nvery hard. C is a weakly statically typed language: unlike many other strongly statically typed languages, \na pointer in C can be cast to another type so that it points to an object that does not have a data type \nexpected by the static type system. This breaks many assumptions that are essential for ensuring the \ntype safety of statically-typed languages. Many people might think that as long as cast operations exist, \nit is impossible to implement C in a memory-safe way. Furthermore, there are many more obstacles to safe \nimplementation: function pointers (with cast operations), varargs (common in printf-family functions), \nuntyped malloc functions, and guaranteed cast operations between pointers and integers. Our goal in designing \nour compiler was to invent a set of new implementation techniques that can solve all of the above problems. \nWe introduced the following set of techniques, amongst other things. They are described in more detail \nin subsections 2.1 2.7. Although some of them are mutually related, they are nevertheless described in \nsequential order. Fat Pointer: A pointer that accepts arithmetic operations and still keeps information \nabout the objects being pointed to. Fat Integer: An integer that can hold a fat pointer value. OO-based \nTyped Memory Block: A memory block implemented using object-oriented techniques that stores both its \nown types and sizes. Virtual Offset: A special memory addressing technique that hides internal representation \nof any data types and provides a uniform view over objects of various types. Access Methods: A set of \nmethods associated with memory blocks; it supports dereferencing operations on cast pointers. Cast Flag: \nA hint embedded in fat pointers for shortcutting mem\u00adory access operations to reduce runtime overhead. \nSafe Memory Management: A memory management method that prevents any temporal memory access errors such \nas dan\u00ad gling pointers and double block releases. 2.1 Fat pointer To access various meta-information \nabout blocks (e.g., the block size and content type) regardless of the pointer arithmetic, Fail-Safe \nC internally represents all pointers using two-word fat-pointer representations: a pair consisting of \na base and an offset. The base of a fat pointer always keeps the address of the top of a block, and the \n32-bit offset keeps the relative position of the element referred to by the pointer from the block top. \nThe spe\u00adcial value 0 can be used as a base part representing null point\u00aders ; i.e., pointer values that \ndo not point to any objects. The offset, which is initially 0, represents the byte offset of the referred \nele\u00adment from the block top. In all pointer arithmetic operations, only the offset is modi.ed. The fat \npointer technique itself is not very original: fat pointers or smart pointers have already been introduced \nin various im\u00adplementations. For example, CCured [16] introduces a three-word representation for seq \npointers (one of the kinds of pointers in CCured that allow pointer arithmetic inside objects), and many \npeo\u00adple implement it by hand when they need to simulate internal point\u00aders in existing safe languages. \nHowever, the fat pointer in our de\u00adsign has been extended from existing ones in the following ways: \nIt holds a special .ag called the cast .ag embedded in a two\u00adword representation.  The offset holds \nvirtual offsets instead of real memory ad\u00address offsets or element indexes.  Both these features are \ndescribed in more detail below. base pb = &#38;a;int *p = &#38;a; . ofs po=0; p++; po+= 4; .  2.2 Fat \ninteger In ANSI-C, integers equal to or larger than the pointer size are required to be able to hold \nany pointer value. Integer values that Figure 1. Block structure for arrays of pointers and primitive \ntypes.  were originally pointers can be cast back to corresponding pointer types if the values were \nnot modi.ed while they were integers. To implement this behavior, the usual one-word representation of \nintegers is of course insuf.cient because we cannot distinguish such integers (valid as pointers) from \narbitrary integers. Therefore, we also use two-word representation for integers, which are called fat \nintegers. Conceptually, fat integers could use the same representation as fat pointers. However, to enable \nmore ef.cient implementation of integer arithmetic operations, a fat integer in our system is internally \nhandled as a pair consisting of the base and a value (or virtual address) de.ned to be equivalent to \nthe sum of the base and the offset. All arithmetic operations on integers ignore the bases of operands \nand operate on only the value parts. An arithmetic result always has a base part of 0, corresponding \nto a null pointer. A cast operation between pointers and integers converts offsets to virtual addresses, \nand vice versa. base i b = p b; int i v = p b + p o; base p b = i b; ofs p o = i v - i b; i b = 0; i \nv *= 5; int i = (int)p; . int *p = (int *)i; . i *= 5; . (Cast .ags are not shown in these examples.) \n 2.3 Typed Memory Blocks In safe languages, every memory access operation must ensure that the offset \nand the type of a pointer are valid. If a statically typed language has no casts, or only a cast respecting \nsubtype relations (as in objects in Objective Caml), no runtime type information is needed. However, \nas C does not impose such restrictions on cast operators, the system must know the boundary and the type \nof contents for every memory block in order to check this safety property at runtime. The runtime system \nof Fail-safe C keeps track of these by using custom memory management routines. A memory block is an \natomic unit of memory management and boundary over.ow detection. Each block consists of a block header \nand a data area. A block header contains information about the block s size and its dynamic type, which \nwe call the data representation type. The actual layout and representation of the data stored in a block \ndepend on its data representation type: a different representation is used for each representation type \nin our system. This allows the implementation to utilize several different representations for each type \nappearing in user programs. For example, if there is an array of pointers, it is stored as a collection \nof packed fat pointers (Figure 1). This is also true for arrays of fat integers. However, for an array \nof simple primitive types (which cannot hold pointers), such as characters or .oats, we use a packed \narray without any base parts, to gain better performance for I/O operations (If the representation of \nchar arrays is the same as the native one, the runtime system can use the internal address of data directly \nfor .le I/O operations). For each user-de.ned struct, the compiler automatically generates more complex \nruntime representations (an example is shown in Figure 2), and generates various related data structures \nas well. In our current implementation, all unions are translated as a combination of casts and structs. \nFor example, if there is a dec\u00adlaration union { int a; char *b; double c; } x; it will be translated \nas if it were a struct holding only the .rst element and any necessary padding (if any): union { int \na; char __pad[(sizeof(double) -sizeof(int)]; } x; A member access x.b is treated as an equivalent code \n*((char **)&#38;(x.a)) and translated to a code which uses cast pointer handling.  2.4 Virtual offsets \nSeveral methods may be used to indicate a speci.c element in a memory block. The usual methods used in \nconventional language implementations use one of the memory addresses of elements, the index count of \nelements from the block top (sometimes called the word offset), or the difference between the memory \naddress and block top address (the byte-offset). For most implementations, some or all of these will \nwork. In our system, the situation is more complicated because there is a cast operation that needs to \nbe implemented safely and consis\u00adtently. The method using real addresses or offsets of real addresses \ncreates a safety problem (although these are used for many exist\u00ading systems aimed at making C secure): \nif a pointer is cast to the char * type, it will point to every byte of the internal representa\u00adtions \nof several data including pointers. If such internal informa\u00adtion about pointers (e.g., base parts of \nfat pointers) are compro\u00admised through these cast pointers, the safety of the system is no longer ensured. \nSeveral proposed systems, including Safe-C [2] and BCC [12], seem to suffer from this problem. CCured \n[16, 5] solves the problem by maintaining a bit-array for each memory block to indicate whether each \nword in the block can be used as a valid pointer to the block top; however, the handling is rather complex \nand unintuitive. The element index does not have a similar problem for primitive types if alignment requirements \nare equal to the size of the corre\u00adsponding type. However, this complicates the implementation of cast \noperations and makes it impossible to properly represent a cast pointer to data types having alignment \nrequirements smaller than  1. A 3-byte padding labeled pad[3b] aligns .eld f to a word boundary in both \nvirtual and real addressing. 2. A 4-byte padding labeled pad[4b] aligns the whole struct to a double-word \nboundary (required by double-word aligned .eld d) in the native addressing. 3. A 4-byte padding at the \nlast word of the translated representation aligns the whole structure to a double-word boundary in the \nreal addressing. This padding is invisible to the user program.  Figure 2. Example of the representation \nof a struct. the element size (e.g., structs); that is, the C speci.cation allows pointers that are not \naligned to elements. Consequently, another method of addressing had to be invented for our system. The \naddressing used in Fail-Safe C, which is called virtual offset, corresponds to the program-visible size \n(hereinafter called the virtual size) of elements, not to the actual size of repre\u00adsentations altered \nto implement security mechanisms. For example, the virtual size of a natural-sized integer in our system \nwill be equal to the native word size although these values use two-word repre\u00adsentation internally because \nits value range visible to the running user program will still correspond to one word. The virtual size \nof pointers will also be one word, and .oating numbers and smaller integers (which cannot hold pointer \nvalues) will have virtual sizes equivalent to their real sizes. Figures 1 and 2 shows some examples of \nthe differences between virtual and real offsets. In other words, the virtual size of every type will \nbe the real size of the equivalent data type in the native implementation of C. This de.nition of virtual \noffsets does not lead to the problems that arise with the other two methods: a cast pointer temporarily \npointing to the middle of elements can be properly cast back to its original type and pointing to only \nthe base part of fat pointers is impossible because there is no speci.c offset that points to only the \nbase part of pointers. Another important consequence of this representation is the possibility of consistent \nde.nition for memory access performed via cast pointers. Although the ANSI-C standard does not support \nmemory access via cast pointers, an ill-typed memory access is sometimes safe (e.g., when the .rst byte \nof a pointer is read). Ac\u00adtually, C programmers are often skilled at using this sort of access and .nd \nit useful. Fail-Safe C allows the use of ill-typed memory access as far as possible unless it collapses \nruntime memory struc\u00adtures since such accesses appear frequently in most application pro\u00adgrams. Because \nthe virtual sizes used in Fail-Safe C correspond to real sizes in native implementation, the mapping \nfrom our repre\u00adsentation of data to the corresponding native representation can be de.ned simply; in \nshort, we can simulate what will happen when the operation is performed in the native implementation \n. For ex\u00adample, if there is an integer 0x12345678 (hexadecimal) and one reads a single byte from that \naddress via a cast pointer, it will be read as either 0x78 or 0x12 (depending on the byte order). The \nsame holds when there is a pointer to the offset 8 of the memory block at address 0x12345670.  2.5 Type \ninformation and access methods As the actual representation of data in a memory block differs from that \nin conventional compilers, some methods to support memory access via a cast pointer must be provided \nfor every combination of a pointer type and a block representation type. Our compiler uses an object-oriented \nimplementation technique for this purpose. In the header of each block, there is a typeinfo .eld that \ncon\u00adtains a pointer to a block containing several items of information about its representation type. \nOne type-information block is gen\u00aderated for each representation type that appears in a user program. \nFurthermore, a method table similar to that usually used in a C++ implementation is stored in the type-information \nblocks. Access methods stored in the method tables implement a generic interface for read/write block \ncontents with various access sizes such as a byte or word, regardless of the type of block. A read method \nreceives a virtual offset and returns the corresponding con\u00adtent in a data area as a fat integer1 if \nthe given virtual offset falls inside the block boundary. The write method receives a virtual off\u00adset \nand a value to be written as a fat integer and performs an appro\u00adpriate write operation depending on \nthe actual data representation. These methods will signal a runtime error if the virtual offset is outside \nthe block boundary. Type information blocks and access methods for primitive types are implemented in \nthe runtime library provided in the compiler distribution. For user-de.ned types such as structs or pointers, \nthe compiler system automatically generates them for every type used in the program.  2.6 Faster memory \naccess and cast .ags Given typed memory blocks, access methods, and fat pointers, there is always a simple \nway to access the contents of memory blocks, regardless of pointer casts. To access word data referred \nto by a non-null fat pointer, the program can always look up type in\u00adformation in the block header using \nthe base part of the fat pointer, pick up the associated access method from the type information block, \nand invoke it. The called access method always knows the representation of the referred data block and \nreturns the corre\u00adsponding data as a fat integer. This can then be easily converted back to any type \nthat the program wants. However, as one can easily guess, this process with indirect function invocation \nis very slow compared with usual unsafe mem\u00adory access in C, or even compared with memory access in other \nstatically typed languages. Our experiments have shown that ex\u00adecution takes more than 10 times longer \neven for a very simple program when this access method is used for every memory access. Since this is \nan unacceptable performance penalty, we implemented a shortcut for memory access. For every fat pointer, \nthere is a one-bit .ag called the cast .ag embedded in an unused bit in the base part. This .ag indicates \n1 Returned values will be narrow (native) integers if the access size is smaller than the word size. \n Figure 3. Basic procedure for memory access via pointers. whether or not a pointer is cast. More precisely, \nwhen this .ag is zero, and if the pointer is not null, the memory block referred to by the base part \nmust have a correct representation type for the pointer s static type, and the offset part of the pointer \nmust be a multiple of the (virtual) size of the element. This ensures that the following property holds \nduring runtime: if there is a pointer with cast .ag = 0, the pointer may be a null pointer, point to \na valid element inside the memory block, or point outside the valid memory block. The introduction of \na cast .ag enables memory access opera\u00adtions to be optimized as follows (Figure 3): check whether the \npointer is null; if not,  check whether that cast .ag is set; if it is set, use an access method; otherwise, \n check whether the offset is smaller than the block size; then,  convert the virtual offset into a \nreal memory offset and access the memory directly.  fatint i; base ib; int iv; /* NULL check */ if ((p \nb &#38; ~CASTFLAG) == 0) raise error(); /* cast check */ if (pb &#38; CASTFLAG != 0 || /* over.ow check \n*/ get header(p b)->size <= p o) inti =*p; /* invoke an access method */ . i = (*get header(p b) ->read \nint method)(p b,p o); else /* read memory directly */ i = *(fatint *)(pb + po * 2); /* real/virtual size \nratio for int is 2 */ i b = base of fat int(i); i v = value of fat int(i); The cast .ag of a pointer \nis recalculated each time when a pointer (or integer) is cast to another pointer type. It uses a rep\u00adresentation \ntype of the referred block stored in the block header. p b = q b &#38; ~CASTFLAG; /* NULL check */ if(pb== \n0|| /* type check */ get header(p b)->type != int *p = (int *)q; . type of int pointer || /* alignment \ncheck */ oq%4!= 0) p b |= CASTFLAG; po = qo; As most pointers in C programs are not cast, the introduction \nof cast .ags greatly reduces the runtime overhead of real programs. In the real implementation of Fail-Safe \nC, the memory access is further optimized by a clever scheme, as described in Section 3.1.  2.7 Safe \nmemory management Another cause of memory errors in C programs is bad use of mem\u00adory management routines. \nUnlike most safe language implementa\u00adtions, memory management in C is completely non-automatic: pro\u00adgrammers \nmust specify when heap-allocated memory blocks are deallocated. If they fail to specify the correct timing, \nthere will be a dangling pointer pointing to the debris of an already-deallocated block, which could \nlead to further invalid memory accesses. In ad\u00addition, local variables in C can be pointed to by pointers, \nbut they are automatically released at the end of the function s execution regardless of such pointers. \nWe utilize a garbage-collection technique, as is used in almost all implementations of safe languages, \nto prevent fatal misbehavior related to the early deallocation of memory blocks. When a user program \nrequests deallocation of a memory block, the runtime sys\u00adtem will not immediately release the block, \nbut only forbid further access to it .2 The garbage collector will later check that there are no pointers \npointing to the block, and it will release the memory block only after all dangling pointers pointing \nto the block have disappeared. It also collects any unreferenced leaked objects in memory. The current \nimplementation uses Boehm-Weiser s con\u00adservative GC library [3, 4] as a backend library. In future, we \nmay implement a type-exact garbage collector in order to avoid false pointers. For the local variables, \nthe compiler performs a simple check on the use of local variables and pointers, and if there is a pointer \nto any local variable, the compiler automatically moves that variable to the heap area. The memory blocks \nfor such variables are allo\u00adcated at the start of the function, and they are automatically deal\u00adlocated \nat the end of the function. The area will be then under the management of garbage collectors, like other \nheap-allocated mem\u00adory blocks. 3. Implementation Details This section gives further details of the implementation \ntechniques (tricks) introduced in the compiler to improve performance and compatibility. 3.1 Fast checking \nof cast .ags As described in the previous section, when a fat pointer is derefer\u00adenced, three properties \nmust be checked before any direct access to 2 This behavior differs slightly from that of most safe languages \nbecause user programs are supposed to call the free() function to declare explicitly that the memory \nblocks are no longer to be used.  Figure 5. Fast cast-.ag check. this overhead, our implementation uses \na clever trick. In other circumstances, if a null pointer is dereferenced as if it were a valid pointer, \noffset checking code that attempts to read the size .eld will access the very end of the address space \n(be\u00adcause of an integer wraparound). In most operating systems, no memory is mapped to these addresses \nand a SIGSEGV signal will always be raised if they are accessed. This condition can be reli\u00adably detected \nby checking the address information passed to signal handlers. Thus, those checks can be merged into \none offset check, which is generally necessary anyway, without damaging the safety properties. The resulting \noptimized memory access procedure is shown in Figure 6. Compared with Figure 3, there is only one check \non its fast path . Figure 6. Procedure for memory access via pointers with fast access checking. int \ni=*p; . fatint i; base ib; int iv; /* single combined check */ if (get header(p b)->size <= p o) /* slow \npath: invoke an access method */ i = (*get header(p b) ->read int method)(p b,p o); else /* fast path: \nread memory directly */ i = *(fatint *)(pb + po * 2); i b = base of fat int(i); i v = value of fat int(i); \n 3.2 Separate Compilation Separate compilation and reuse of modules are important features in any modern \nprogramming language. Virtually all languages cur\u00adrently in use have some provision for separate compilation \nof mod\u00adules. In implementations of most statically typed languages, it is important that the type safety \nof the whole program is guaranteed when type-safe modules are linked together. However, in C, inter\u00admodule \ntype safety is not guaranteed in usual implementations. Conventional C linkers hardly check inter-module \nconsistency and simply unify sets of the same symbols. If a function or value in one module is referenced \nfrom another module as that of some other type, or if a type de.nition of structs or unions is inconsis\u00adtent \namong modules, the type safety is easily broken in C. Most existing works on safe C implementation offer \nno pro\u00advision for link-time type safety or no separate compilation at all. CCured provides a source-level \npreprocessor that links several source .les together before compilation so that any type inconsis\u00adtency \ncan be found at compile time, but it discards most of the bene.ts of separate compilation. Frankly, it \nis a good design choice for CCured, which depends heavily on static analysis even with\u00adout separate compilation \nand requires whole-program analysis be\u00adfore compiling a single component module (because the result of \nwhole-program analysis sometimes requires a change in the value representations in the module). However, \nfor our compiler, we took a different approach. In Fail-Safe C, there is virtually no requirement at \nall for whole\u00adprogram analysis. Whether or not a pointer is cast outside one module, the value representation \nfor any type does not change, unlike in CCured. Because virtually no performance overhead is imposed \nby the existence of a cast pointer thanks to the fast cast\u00ad.ag checking described above, Fail-Safe C \nalways generates code that can handle cast pointers appearing in any location.  Fail-Safe C implementation \nprovides a special linker that checks inter-module type consistency at link time. The compiler stores \nin\u00adformation about every type de.nition appearing in a module in a generated object module .le. The linker \nextracts the information from all modules to be linked and detects any mutual inconsisten\u00adcies. It also \ngenerates all type-related metadata and various access methods associated with the user-de.ned types \n(such as structs) at link time to avoid duplicate code in the resulting executable .les. Our linker also \nimplements some tricks for better compatibility: it has special support for undeclared functions and \na workaround for the GNU autoconf system. Details of our linker are given elsewhere [20].  3.3 Determination \nof block types allocated by malloc() The implementation of memory blocks in Fail-Safe C depends on the \ntype information associated with each memory block. However, there are many situations where the block \ntype is not known. For example, the interface for the malloc() function in the standard C library does \nnot take any type information. Many existing sys\u00adtems assume that type inference for memory allocation \nis always possible or ensure this by introducing some explicitly typed mem\u00adory allocation syntax (like \nC++ s new operator). In contrast, our system does not completely rely on static knowledge of types, but \ncombines static (compile-time) and dynamic (runtime) approaches. 3.3.1 Compile-time type analysis First, \nFail-Safe C implements a combination of static type analy\u00adsis and a dynamic type-passing mechanism to \ndetermine the type of memory allocation. Our system inserts an additional argument internally into any \nfunction that returns void * type (including malloc() and calloc()). At each invocation of such a function, \nthe compiler performs a simple data-.ow analysis to .nd out what type the return value will be cast to. \nIf it succeeds in .nding such a type, the generated code passes a pointer to the type informa\u00adtion block \nof that type as an additional argument as a hint. Memory allocators such as malloc() and calloc() can \nuse this hint to initialize a new memory block in the correct type. In a special case, when such return \nvalues are used as return val\u00adues of another function returning void *, the compiler generates code that \npasses the hint received from the caller to the child func\u00adtion. This enables the implementation of wrapper \nfunctions (such as allocx, which is equal to malloc except that it aborts the program when an allocation \nfails) around memory allocation functions. This mechanism also works without whole program analysis, \nif separate compilation is needed. If there is no single type that can be used as a hint (e.g., when \nsuch a return value is cast to two different types in an if statement), the compiler does not pass any \nhints to the callee, and the runtime system falls back to the runtime type analysis below. 3.3.2 Runtime \ntype analysis (delayed type decision) If the type cannot be reliably deduced through the analysis above, \nthe Fail-Safe C system delays deciding the type of dynamically allocated blocks from allocation time \nto the .rst use. If a block is allocated without a type hint, the system .rst as\u00adsigns a special pseudo-type \n(called type-undecided) to the block. Because this pseudo-type is not equal to any real types, the .rst \nwrite access to this block will always be forwarded to access meth\u00adods associated with the pseudo-type. \nAccess methods for the type\u00adundecided pseudo-type will then guess the block type based on the type used \nfor the access. Memory layout when a 22-byte heap block is allocated for a struct type with a size of \n8 bytes containing a .oat element. The block contains 2 elements and 6 bytes of remainder area. Two block \nsize values are stored in the header: 16 is the size without the remainder area (this one is used for \nboundary checks), and 22 is the size of the whole block. Figure 7. Formats of remainder area and additional \nbases. A type-undecided block has basically the same structure as ordinary blocks. The real size of the \nallocated buffer will be about twice the requested virtual size, as this is suf.cient. The type information \n.eld in the header points to a specially de.ned type\u00adinformation block. In addition, the size of the \nstructured data area is initialized to zero. This causes all accesses to this block to be trapped and \ndelegated to the associated access methods. The write access methods associated with type-undecided blocks \ninitialize the data area according to the access type, which is passed as an additional argument to the \naccess methods. After initialization, its size and the typeinfo .eld of the block s header is reinitialized \nto turn the block into a normal block. Finally, the method handles the write request from a caller by \ndelegating it to the newly associated access methods. As a last resort, if both the block type estimations \nfails, the memory block may have been assigned the wrong type In that case, cast pointers and access \nmethods will maintain the compatibility and the program will continue running; the only effect is that \nthis slows the execution.  3.4 Memory block extensions Memory blocks allocated by users using malloc() \nin real pro\u00adgrams are used in some weird ways in many real programs. For example, C programmers often \nallocate a memory area whose size is not a multiple of the size of its data type in order to implement \na variable-sized structure 3. They de.ne a 1-element array as the last element of a struct and use it \nas an array of arbitrary size, which is determined at allocation time. In other cases, some heap\u00adallocated \nobjects can be .rst initialized as a simple char array and then later used in a different type, which \nconfuses the type determi\u00adnation algorithm in the previous section. To cope with such tricky programs, \nour implementation con\u00adtains two general workarounds. First, the memory management routines maintain \na remainder area in the heap block, which is not a multiple of the element size. Such a memory area is \nformat\u00adted in the same way as an array of characters and used by access methods to simulate a memory \naccess between the end of all el\u00adements and the end boundary of the block. Second, if a non-null pointer \nis to be written in the array or in a .eld of a primitive type that does not normally hold a pointer \nvalue, the runtime system will allocate a separate cache called an additional base area to store 3 This \ntechnique is of.cially supported in the newer version of the C speci\u00ad.cation (often called C99).  Figure \n9. Data structure for functions in Fail-Safe C. the base parts of the values. This area is also used \nas a last resort when type determination for heap blocks fails and guessed type was incorrect. The formats \nof additional base areas and remainder areas are shown in Figure 7.  3.5 Varargs and cast function pointers \nSome C functions such as printf accept variable numbers of arguments. The ANSI-C speci.cation even allows \nusers to de\u00ad.ne such functions and handle arguments using macros de.ned in stdarg.h. In usual native \ncompilers for most architectures, such arguments are put onto the stacks in the same way as for other \n.xed arguments. The corresponding access macros read the stack area directly to fetch variable arguments, \nwhich is obviously an unsafe operation. Our system implements a similar behavior in a safe way (Fig\u00adure \n8). If functions with variable arguments are called, then any parameters that fall into the variable \narguments will be automat\u00adically coerced and stored in a fat integer array in a heap, instead of the \nnative stack4. The array is then passed to the function us\u00ading hidden arguments and can be accessed through \nsystem-de.ned macros. Of course, block boundaries are checked during accesses to variable parameters, \nand if excess arguments are accessed, an error is generated. The same technique is used when a pointer \nto a function is cast. For each function, the compiler generates a second entry point that receives all \nparameters as variable arguments, as well as a stub 4 This varargs block is heap-allocated because an \naddress of this block may leak if the called function uses a va list value returned from the va start \nmacro inappropriately. memory block which contains pointers for both the main and the second entry (Figure \n9). A pointer to a function is represented by the address of the stub blocks internally. If an uncast \npointer is used for an invocation, the caller extracts the address of the main entry point from the pointed \nstub block and call it directly. However, if a cast pointer is used for an invocation, the caller prepares \nall arguments as variable arguments and invokes the second entry point instead. The second entry point \nextracts the real arguments and passes them to the main entry of the function.  3.6 Runtime libraries \nAlmost all C programs require some library functions and system call functions to work correctly. The \nstandard library requires many functions: the ANSI C and POSIX speci.cations of Unix system calls de.ne \nmore than 1000 functions. We have already imple\u00admented more than 500 functions, mostly by hand. Some \nfunctions, such as many string-related functions in string.h, can be imple\u00admented in a usual C language \nand compiled by Fail-Safe C. However, some functions, especially ones that interact with un\u00adderlying \nsystems (including kernel-level system calls) cannot be implemented in that way. For those functions, \nwe implemented a custom wrapper around the function. Each wrapper receives argu\u00adments encoded in our \nsystem s representation, converts all the ar\u00adguments to the corresponding native representations, and \ncalls the native function to perform system interaction. Returned values are also converted back to our \nrepresentation. In addition, the wrap\u00adpers are responsible for keeping the memory safety of the whole \nof our system and so on: before invoking a native function, they check boundary preconditions such as \nthe length of an I/O opera\u00adtion and buffer lengths. We have implemented a preliminary wrap\u00adper generator \nto reduce some of the cumbersome work involved in implementing such wrappers. As an implementation choice, \nwe used the same technique for several complex user-level C library functions that interact with op\u00aderating \nsystems, such as .le I/O (stdio functions), locales, and setjmp. When such functions are implemented, \nsome native point\u00aders, such as FILE * pointers, must be stored in data structures ac\u00adcessible from user \nprograms. To prevent such pointers from being exploited, they are wrapped as a special memory block and \nassoci\u00adated with special access methods that deny all memory accesses. 4. Current status Here, we brie.y \nreport on the current status of our implementation. We have implemented the whole proposed system. The \ncurrent compiler accepts most features (including all essential features) of the ANSI-C speci.cation \non the Intel x86 architecture. Ports to other 32-bit architectures do not seem very hard, and 64-bit \nsupport is also theoretically possible (although many runtime routines must be rewritten accordingly). \nFail-Safe C system consists of the compiler and linker (written in Objective Caml), runtime and standard \nC libraries (written in our C compiler itself and in native C with a custom wrapper helper language), \nand some support scripts (in Perl). The compiler part was written as a source-to-source C translator; \nin other words, we used the native C compiler (Gnu C compiler) as a backend rich assembler . The current \nimplementation does little program analysis; but some local code optimizations such as redundant value \nelimination are implemented. Our system supports the same command-line syntax as conventional C compilers. \nMany library functions from ANSI C and POSIX are already implemented and are contained as part of the \nsystem. The system has been published on our website [17] as open\u00adsource software since April 2008. We \nprovide both a source dis\u00adtribution and an unof.cial binary package for Debian GNU/Linux.  Fail-Safe \nC can compile various server programs in real use on the Internet. The currently supported programs include: \n OpenSSL version 0.9.8j, the most widely used open-source cryptographic library and tools  OpenSSH version \n5.1p1, the most widely used remote secure login software  ISC BIND (Berkley Internet Name Domain) server \nversion 9.4.2, the most widely used Internet domain name server,  thttpd version 2.25b, a compact web \nserver,  qmail version 1.03, a famous Internet mail server,  post.x version 2.5.5, another recently \nfamous Internet mail server,  libtiff version 3.8.2 and libpng version 1.2.34, libraries for man\u00adaging \nimage .les,  zlib version 1.2.3, a .le compression library.  During compilation, almost all of the \nmain program code was left unchanged; most of the modi.cations required to accept those programs are \n.xes for small bugs in the programs themselves to adhere the stricter type and declaration checking of \nthe Fail-Safe C. These modi.cations will be available on our website as patch .les. This is very unlike \nany existing methods that provide complete memory safety: even CCured requires the modi.cation of up \nto 1% of the original source code. We changed build procedures such as Makefiles accordingly. During \nthe implementation, we found a small off-by-one bug in thttpd. Luckily, although this bug was unsafe, \nit is almost never exploitable. We reported it to the original author. We have also tested our system \nagainst several real vulnerabilities in existing programs such as older versions of Sendmail and xv by \nextracting some of the buggy code as a test program, and we veri.ed that our scheme can correctly handle \nand detect such memory corruption attempts. 5. Evaluation We have applied Fail-Safe C to a few benchmark \nprograms to eval\u00aduate the performance of the current implementation. The programs that we used were: \n ByteMARK benchmark version 2,  the Speed subcommand available in OpenSSL.  We also include the results \nof three small micro-benchmarks here for evaluating the performance of primitive operations. The performance \nof the current implementation is shown in Fig\u00adure 10. The values in the .gure are normalized to give \nthe speed index of the program compiled by the native compiler the value 1.0 (smaller is better). We \nused a computer with dual-core AMD Opteron processors running at 2.4 GHz and a GNU C Compiler ver\u00adsion \n4.1.2 distributed with Debian GNU/Linux 4.0 (release etch). The points marked by . show the performance \nof the assembly rou\u00adtines implemented in OpenSSL, for reference. The micro-benchmark micro .b 44 calculates \nan element of the Fibonacci sequence by simple recursion. It shows that there is little performance overhead \n(.2%) on the handling of fat integers. The two tests micro sumup , which sums up an array of random integers, \nand micro qsort , which sorts an array of random inte\u00adgers, show performance on memory operations. They \nshow that memory accesses with fat integers take about 1.7 to 2.2 times as long to perform as one compiled \nby a native compiler. However, when we force access methods to be used for all memory accesses (shown \nas CAST ), the overhead grows to more than 10 times. This shows importance of cast .ags and short-cut \nmemory accesses in Fail-Safe C. In the OpenSSL RSA tests, the performance depended on the length of the \npublic key: in the range conventionally used (1024 to 4096), the program compiled by our compiler took \nabout two to four times as long to run as one compiled by the conventional com\u00adpiler. For AES tests, \nunfortunately, the slowdown was about .ve times. The reason for this is not yet completely determined, \nbut we guess that the programming style of the OpenSSL implementation (implemented in a kind of object-oriented \nprogramming style in C) involves moderate use of cast pointers. The Bytemark benchmark shows that performance \nvaries greatly depending on the way that programs are written. In the Fourier test, our compiler imposed \nalmost no performance penalty. The worst test was em.oat, which showed performance results about six \ntimes as long. The reason for this seems to be a limitation of the current implementation, which detects \nonly some of the local variables that can be safely allocated in the stack: the em.oat test allocates \nmany local structs whose addresses are passed around among sev\u00aderal functions. Current function-local \nanalysis does not .nd such variables as stack-allocatable. In future, we will implement a bet\u00adter analysis \nto solve this problem, which should work well with separate compilation. On average, we can see that \nsafety checks performed by our sys\u00adtem increased the execution time of computation-bound programs by \naround two to four times in the ByteMARK test. For server pro\u00adgrams with much heavier I/O overhead than \nthese benchmarks, we would expect slightly better performance than indicated by these evaluation results. \n6. Related Work Canary-word techniques The canary word technique, which is a well-known way to avoid \nsimple kinds of sequential-access buffer over.ows, has been implemented for a long time. Protection on \nstack buffers was provided by StackGuard [6]. Recent versions of the Microsoft Visual C compiler include \nthe /GS compile option, which has a similar function on the Windows operating system platform. The recent \nGNU C compiler also implements a similar buffer smashing protection (-fstack-protector option) based \non ProPolice [7]. The bene.ts of the canary-based technique are its low overhead and high compatibility \nwith existing systems. These systems modify only the structure of stack frames and the unreferenced area \nbetween global variables, both of which are not usually accessed directly by user programs. However, \nthe limitation of this approach is also obvious: it can only prevent sequential\u00adaccess buffer over.ows \nthat are used to directly attack execution\u00adcontrolling data; it cannot prevent even a buffer over.ow \nbased on random access. If the execution-controlling data is overwritten directly without modifying the \ncanary words (e.g., by random\u00adaccess over.ow and other exploits), the system is ineffective. For example, \nboth StackGuard and GCC stack smashing protector are unable to prevent a security exploit found in the \noption parsing routine in the old Sendmail. Safe memory management for C There have been some pro\u00adposals \nfor safe memory management of C programs. Loginov et al. [15] proposed a method of ensuring pointer safety \nby adding a 4-bit tag to every octet in the working memory. Backward\u00adcompatible bounds checking by Jones \nand Kelly [12] modi.es the GNU C compiler (gcc) by inserting bounds-checking code that uses a table of \nlive objects. Safe-C [2] can detect all errors caused by early deallocation of memory regions. However, \nas far as we know, these proposals are not only slower than our method, but also in\u00adcomplete. They seem \nto have limitations regarding the source and destination types of cast operations or do not protect pointers \nstored in memory overwritten by integers via a cast.  Safe languages There are already plenty of languages \n(both stat\u00adically and dynamically typed) that ensure complete memory safety. Some of these, such as ML \nand Lisp, are accepted by some pro\u00adgrammers for writing programs in a memory-safe way. However, although \nthese languages are good for new programs, it is hard to reuse existing C programs on those systems. \nThe syntax of Java seems to have been designed intentionally to be similar to C, for acceptance in the \nreal world. Thanks to this, porting C programs to Java is a little bit easier than porting them to other \nlanguages, but it still requires heavy rewriting of the code. Some other safe imperative languages resemble \nC more closely. For example, Cyclone [9, 11] is designed to ease the porting of C programs so that they \nbecome type safe. For common C programs to conform to Cyclone, however, about 10% of the program code \nmust still be rewritten [9, 11], which is a considerable task. CCured Necula et al. have designed and \nimplemented CCured [16, 5], a sound type system that can support C programs that include cast operations. \nThe approach of CCured is to analyze the en\u00adtire program and then split it into two parts: the type-safe \npart that does not use cast operations and the type-unsafe part that could be contaminated by cast operations. \nHowever, to the best of our knowledge, the designers did not focus on perfect source\u00adlevel compatibility \nwith existing programs, and the system does in fact support only a subset of the ANSI-C semantics. The \nreported amount of code that must be rewritten is less than 1% of the source code, which is much smaller \nthan for other proposals such as Cy\u00adclone, but still a signi.cant amount. Our work was designed with \na greater focus on complete compatibility with the ANSI-C spec\u00adi.cation and on the highest possible compatibility \nwith existing programs. The main technical difference between CCured and our pro\u00adposal is that CCured \nis based mainly on static analysis of cast oper\u00adations, while ours uses dynamic handling as its main \ntool. CCured statically determines which variables might have a cast pointer, and quarantines the wild \npart from the pure part of the program. The pure part will then behave almost like a program of a pure \nstatically typed language; e.g., there will be no type information inside. The weakness of this method \nis that the system cannot allow any point\u00aders in the wild part to point to values in the pure part. In \naddition, as value types are completely determined statically, a pointer that could point to wild values \nmust always point to wild values. This means that wild pointers have a pollution problem: if one pointer \nin a variable is found to have a cast in some case, all the data struc\u00adtures that might be pointed to \nby the same variable, and even all the data structures that could be indirectly traversed from the variable, \nmust be in the wild part. Thus, the relative size of the program s wild part is likely to increase with \nprogram size. In our scheme, on the other hand, a cast pointer does not infect any other data because \neach memory block has a representation type: even if there is a cast pointer pointing to a memory block, \nthe pointers in that block can still be typed (not cast). Another problem with CCured is con.icts between \nthe system library and the pointer-type pollution described above. As system libraries are compiled beforehand, \na library must have a single static type. However, in CCured, one wild pointer may pollute other values \nby forcing them to be the wild type, including data to be passed to the system library. If a library \nhas already been compiled as a non-wild type, the program cannot be linked safely. This makes it harder \nto compile the large programs used in the real world. Extensions to our work Kamijima and Sumii [13] \nhave imple\u00admented a C-to-Java translator which supports pointer arithmetic and arbitrary pointer cast \nbased on our scheme. They have intro\u00adduced local static to reduce additional overhead imposed by the \nrepresentation of Fail-Safe C s data structure on Java. Furuse proposed VITC [8], an extension of our \nscheme with analysis and enforcement of information .ow restriction. As our compiler enforces basic memory \nsafety and runtime conformity to the de.ned language semantics, it can be combined with various static/dynamic \nanalysis to ensure stronger safety/security proper\u00adties on the C language. 7. Conclusion We have designed \na completely memory-safe implementation of the full ANSI-C language that can support all of the features \nof ANSI-C, including casts and unions. We have introduced several techniques to support C language features \nthat most safe languages do not have. We also exploited several implementation tricks to reduce the runtime \noverhead as much as possible. We have implemented both the compiler system and the runtime library, which \ncontains over 500 standard library functions de.ned in the ANSI-C and POSIX speci.cations. The system \naccepts many existing, well-used server programs such as OpenSSL, OpenSSH, and BIND9. A performance evaluation \nshowed that, on average, the safe programs compiled by Fail-Safe C take two to four times as long to \ncompute as unsafe programs compiled by native compilers.  7.1 Future work Compatibility with more existing \nprograms: Due to the nature of the memory-safety provided by our system, the current com\u00adpiler does not \ndirectly support programs that use custom memory management, including Apache httpd and many implementations \nof programming languages. Such programs may either run very slowly (due to the heavy use of cast pointers \nand access methods) or simply not work correctly (if integer arithmetics are used in point\u00aders). We are \nconsidering implementing a compatibility library that supports an interface for several custom memory \nmanagements routines, e.g., the Apache APR and Boehm-Weiser s GC library. We expect the introduction \nof such libraries to enable our system to support a broader range of existing programs. Optimization: \nAs an instant safety measure for existing pro\u00adgrams, we think that the current performance is acceptable \nbut not completely satisfactory. We will investigate several compiler optimization techniques to further \nreduce runtime overheads. We observed that programs written in some safe languages with so\u00adphisticated \nimplementations (such as Java and Objective Caml), usually ran at about (very roughly) half the speed \nof heavily tuned C programs. We have currently set this value as a future goal for our optimization efforts. \nHowever, we must be aware that not all existing optimizations are directly applicable to our system. \nNeedless to say, the optimiza\u00adtions to be applied must be sound. Moreover, many optimizations assume \nthat if the boundary checks fail, the program execution does not continue, (or at least that the current \nscope of execution is ter\u00adminated e.g., by escaping via exceptions). This not always true in our system: \nas can be seen in Figure 6, there is a control path that leads from the failed branch of a boundary check \nand merges back to the main path. We intend to implement optimizations care\u00adfully without sacri.cing \nany safety. Extensions: An extension of our compiler to accept programs written in the 1999 revision \nof C (C99, ISO/IEC 9899 : 1999) will not be dif.cult: however, C99 de.nes that a byte-to-byte copy of \na valid pointer will become a valid pointer, which is not supported in current Fail-Safe C. We think \nthat this will not cause any critical in\u00adcompatibility to any existing programs, since this de.nition \nmight be intended to ensure that pointers copied by memcpy will be valid pointers, which is supported \nin Fail-Safe C. To support C++ language, we have designed an extension to the cast .ags of Fail-Safe \nC to support class inheritance, nominal sub\u00adtype relations on pointers and virtual method invocations \n[18]. The extended scheme uses 2-bit cast .ags to distinguish uncast point\u00aders (which allow pointer arithemtic), \nand pointers to subtype ob\u00adjects (which do not allow pointer arithmetic), from arbitrary-cast pointers. \nHowever, supporting full C++ language will require huge amount of implementation efforts on various language \nfeatures un\u00adrelated to memory safety (such as method and operator overload\u00ading, templates, and huge standard \nlibraries). Acknowledgments The author is grateful to Dr. Eijiro Sumii, Prof. Akinori Yonezawa and Prof. \nHideki Imai for valuable advices and supports on this project. The author also thanks anonymous referees \nfor valuable and encouraging comments. Implementation of a part of Fail-Safe C runtime system and standard \nlibrary is performed jointly with Lepidum, Inc. under the project New-generation Security R &#38; D Program \nfrom the Ministry of Economy, Trade and Industry (METI) in Japan. References [1] American National Standard \nInstitute. American national standard for information systems programming language C. ANSI X3.159\u00ad1989. \n[2] Todd M. Austin, Scott E. Breach, and Gurindar S. Sohi. Ef.cient detection of all pointer and array \naccess errors. In Proc. 94 Conference on Programming Language Design and Implementation (PLDI), pages \n290 301, 1994. [3] Hans Boehm. A garbage collector for C and C++. http: //www.hpl.hp.com/personal/Hans \nBoehm/gc/. [4] Hans Boehm and Mark Weiser. Garbage collection in an uncoopera\u00adtive environment. Software: \nPractice &#38; Experience, pages 807 820, September 1988. [5] Jeremy Condit, Matthew Harren, Scott McPeak, \nGeorge C. Necula, and Westley Weimer. CCured in the real workd. In ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation, pages 232 244, June 2003. [6] Crispan Cowan, Calton Pu, Dave Maier, \nJonathan Walpole, Peat Bakke, Steve Beattie, Aaron Grier, Perry Wagle, Qian Zhang, and Heather Hinton. \nStackGuard: Automatic adaptive detection and prevention of buffer-over.ow attacks. In Proc. 7th USENIX \nSecurity Conference, pages 63 78, San Antonio, Texas, January 1998. [7] Hiroaki Etoh and Kunikazu Yoda. \nPropolice: Improved stack\u00adsmashing attack detection. IPSJ SIG Notes, 2001(75):181 188, 2001. [8] Jun \nFuruse. VITC: Safe C code compilation against attacks. In 4th Workshop on Dependable Software, 2006. \nIn Japanese. [9] Dan Grossman, Greg Morrisett, Trevor Jim, Michael Hicks, Yanling Wang, and James Cheney. \nRegion-based memory management in Cyclone. In Proc. ACM Conference on Programming Language Design and \nImplementation (PLDI), pages 282 293, June 2002. [10] International Organization for Standards and International \nElec\u00adtrotechnical Commission. Programming languages C. ISO/IEC Standard ISO/IEC 9899:1990. [11] Trevor \nJim, Greg Morrisett, Dan Grossman, Michael Hicks, James Cheney, and Yanling Wang. Cyclone: A safe dialect \nof C. In USENIX Annual Technical Conference, June 2002. [12] Richard W. M. Jones and Paul H. J. Kelly. \nBackwards-compatible bounds checking for arrays and pointers in C programs. In Automated and Algorithmic \nDebugging, pages 13 26, 1997. [13] Yuhki Kamijima and Eijiro Sumii. Safe implementation of C pointer \narithmetics by translation to Java. JSSST, 26(1):139 154, 2009. In japanese. [14] Brian W. Kernighan \nand Dennis M. Ritchie. The Programming Language C. Prentice Hall, second edition, 1988. [15] Alexey Loginov, \nSuan Hsi Yong, Susan Horwitz, and Thomas Reps. Debugging via run-time type checking. Lecture Notes in \nComputer Science, 2029:217 , 2001. [16] George Necula, Scott McPeak, and Westley Weimer. CCured: Type-safe \nretro.tting of legacy code. In Proc. The 29th Annual ACM SIGPLAN SIGACT Symposium on Principles of Programming \nLanguages (POPL2002), pages 128 139, January 2002. [17] Yutaka Oiwa. Fail-Safe C webpage. https://staff.aist.go. \njp/y.oiwa/FailSafeC/index-en.html. [18] Yutaka Oiwa. An extension to Fail-Safe C to support object-oriented \nlanguages. In Symposium on Programming and Programming Languages, March 2005. [19] Yutaka Oiwa. Implementation \nof a Fail-Safe ANSI C Compiler. PhD thesis, University of Tokyo, 2005. [20] Yutaka Oiwa. Type-safe linking \nof C programs. In Symposium on Programming and Programming Languages, March 2007. [21] Gray Watson. Dmalloc \n debug malloc library. http://www. dmalloc.com/.   \n\t\t\t", "proc_id": "1542476", "abstract": "<p>This paper describes a completely memory-safe compiler for C language programs that is fully compatible with the ANSI C specification.</p> <p>Programs written in C often suffer from nasty errors due to dangling pointers and buffer overflow. Such errors in Internet server programs are often exploited by malicious attackers to crack an entire system. The origin of these errors is usually corruption of in-memory data structures caused by out-of-bound array accesses. Usual C compilers do not provide any protection against such out-of-bound access, although many other languages such as Java and ML do provide such protection. There have been several proposals for preventing such memory corruption from various aspects: runtime buffer overrun detectors, designs for new C-like languages, and compilers for (subsets of) the C language. However, as far as we know, none of them have achieved full memory protection and full compatibility with the C language specification at the same time.</p> <p>We propose the most powerful solution to this problem ever presented. We have developed <i>Fail-Safe C</i>, a memory-safe implementation of the full ANSI C language. It detects and disallows all unsafe operations, yet conforms to the full ANSI C standard (including casts and unions). This paper introduces several techniques--both compile-time and runtime--to reduce the overhead of runtime checks, while still maintaining 100% memory safety. This compiler lets programmers easily make their programs safe without heavy rewriting or porting of their code. It also supports many of the \"dirty tricks\" commonly used in many existing C programs, which do not strictly conform to the standard specification. In this paper, we demonstrate several real-world server programs that can be processed by our compiler and present technical details and benchmark results for it.</p>", "authors": [{"name": "Yutaka Oiwa", "author_profile_id": "81418599038", "affiliation": "National Institute of Advanced Industrial Science and Technology (AIST), Japan, Tokyo, Japan", "person_id": "P1464290", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1542476.1542505", "year": "2009", "article_id": "1542505", "conference": "PLDI", "title": "Implementation of the memory-safe full ANSI-C compiler", "url": "http://dl.acm.org/citation.cfm?id=1542505"}