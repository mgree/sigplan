{"article_publication_date": "08-25-2003", "fulltext": "\n A Theory of Aspects * David Walker Steve Zdancewic Jay Ligatti Princeton University University of Pennsylvania \nPrinceton University dpw@cs.princeton.edu stevez@cis.upenn.edu jligatti@cs.princeton.edu Abstract This \npaper de.ne the semantics of MinAML, an idealized aspect-oriented programming language, by giving a type\u00addirected \ntranslation from its user-friendly external language to its compact, well-de.ned core language. We argue \nthat our framework is an e.ective way to give semantics to aspect\u00adoriented programming languages in general \nbecause the trans\u00adlation eliminates shallow syntactic di.erences between re\u00adlated constructs and permits \nde.nition of a clean, easy-to\u00adunderstand, and easy-to-reason-about core language. The core language extends \nthe simply-typed lambda cal\u00adculus with two central new abstractions: explicitly labeled program points \nand .rst-class advice. The labels serve both to trigger advice and to mark continuations that the advice \nmay return to. These constructs are de.ned orthogonally to the other features of the language and we \nshow that our ab\u00adstractions can be used in both functional and object-oriented contexts. The labels are \nwell-scoped and the language as a whole is well-typed. Consequently, programmers can use lexical scoping \nin the standard way to prevent aspects from interfering with local program invariants. Categories and \nSubject Descriptors D.3.1 [Formal De.nitions and Theory]: Semantics; D.3.3 [Language Constructs and Features]: \nControl struc\u00adtures; F.3.2 [Semantics of Programming Languages]: Operational semantics General Terms \nLanguages, Design, Theory Keywords Aspects, Aspect-oriented Programming, Operational Seman\u00adtics, Type \nTheory * This research was supported in part by National Science Foundation CAREER grant No. CCR-0238328. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n03, August 25 29, 2003, Uppsala, Sweden. Copyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00. 1. Introduction \nAspect-oriented programming languages (AOPL) [3], such as AspectJ [10] and Hyper/J [13], provide the \nfacility to in\u00adtercept the .ow of control in an application and insert new computation at that point. \nIn this approach, certain control\u00ad.ow points, called join points, are designated as special typically, \njoin points include the entry and exit points of functions. Computation at these control .ow points may \nbe intercepted by a piece of advice, which is a piece of code that can manipulate the surrounding local \nstate or cause global e.ects. Advice is triggered only when the run-time context at a join point meets \nprogrammer-speci.ed conditions, mak\u00ading advice a useful way to instrument programs with debug\u00adging information, \nperformance monitors, or security checks. An aspect is a collection of advice and corresponding join \npoints that apply to a particular program. Much of the research on aspect-oriented programming has focused \non applying aspects in various problem domains and on integration of aspects into full-scale programming \nlan\u00adguages such as Java. However, aspects are a very power\u00adful and complex language mechanism, combining \nfeatures of both dynamic scoping and continuation manipulation. While recent research e.orts [6, 9, 14, \n16] have made sig\u00adni.cant progress on understanding some of the semantic is\u00adsues involved, the theoretical \nunderpinnings for this novel paradigm lag well behind practical implementation e.orts. The primary goal \nof this paper is to distill aspect-oriented programming into its fundamental components: (1) a means \nof designating interesting control-.ow points, and (2) a way of manipulating the data and computation \nat those points. The goal is to obtain a clear, reusable semantic framework, but there are at least two \nsigni.cant di.culties: 1. Most object-oriented AOPL specify that there are join points at the entry-and \nthe exit-points of every method. Such a de.nition of join points breaks the principle of orthogonality, \nwhich suggests that each program\u00adming language construct should be understood inde\u00adpendently of other \nprogramming language constructs. Tightly coupling join-point de.nition with the seman\u00adtics of methods \nand objects makes it impossible to un\u00adderstand aspects without .rst understanding methods and objects, \nwhich are complicated in isolation. 2. There are several di.erent and relatively complex va\u00adrieties \nof advice one can give to any particular join point. For instance, AspectJ allows programmers to specify \nadvice before, after and around its various join points. While each sort of advice has a similar feel, \n they are su.ciently di.erent that they appear to re\u00adquire independent semantic analysis. To resolve \nthese di.culties, we adopt the central ideas of a type-theoretic semantic framework de.ned by Harper \nand Stone for Standard ML [8]. Rather than give a semantics directly to a large and relatively complex \nAOPL with several di.erent kinds of advice and join points, we translate the unwieldy external language \ninto a simpler core language and then provide a precise and elegant operational semantics for the core. \nThe translation eliminates shallow syntactic di.erences between similar constructs, thereby shrinking \nthe number of features in the core and e.ectively modularizing the overall semantics. We also use the \ntranslation as an implementation strategy for the source language. This core language de.nes two central \nnew abstractions. 1. Explicit, labeled join points that are de.ned orthogo\u00adnally from the other constructs \nin the language, and 2. A single kind of .rst-class advice that, together with labeled join points, \ngives meaning to the before, after and around advice that one .nds in AspectJ.  The main contributions \nof this paper include: A type-theoretic interpretation of an idealized, but useful aspect-oriented language \ncalled MinAML that includes advice, functions, and objects.  A minimalist core aspect language with \na well-de.ned operational interpretation, and a sound type system.  Evidence that our core language \nis general, expressive, and scalable. The paper gives a number of examples written in our aspect framework. \nIt also shows that enriching the point-cut language with context-sensitive predicates and adding features \nsuch as objects does not change the central machinery needed for aspects.  A prototype implementation \nof a toy functional, aspect\u00adoriented language, AspectML (AML) that includes ad\u00advice and point-cut declarations. \nThe implementation comes in two parts, mirroring our theoretical develop\u00adment. The core language is implemented \nas a library for SML/NJ, and AML is translated into SML by a simple rewriter that inserts calls to the \ncore library.  The next section introduces the features of the core aspect calculus and its syntax, \nlargely via examples. These exam\u00adples motivate the design of the operational semantics and type system, \nwhich are described in Sections 2.1 and 2.2. Section 3 de.nes the external language, MinAML. Subse\u00adquent \nsections generalize the core calculus and MinAML by extending them to include objects (Section 3.2) and \nricher point-cut designators (Section 4). The paper concludes with a description of a prototype implementation \nin SML/NJ and discussion of related and future work (Sections 5 and 6). 2. Core aspect calculus Labeledjoinpoints \nl( e) are the essential mechanism of the core aspect calculus. The labels, which are drawn from some \nin.nite set of identi.ers, serve several purposes: They mark the points at which advice may be triggered, \nthey pro\u00advide the appropriate contextual information for trigger pred\u00adicates, and they mark points to \nwhich control may be trans\u00adferred when some advice decides to abort part of the current computation. \nFor example, in the expression v1 + l( e2) ,af\u00adter e2 has been evaluated to a value v2, evaluation of \nthe resulting subterm l( v2) causes any advice associated with the label l to be triggered. This construct \npermits the un\u00adambiguous marking of any control .ow point rather than relying upon some apriori designation \nof the interesting control .ow points, which are hard-wired in most aspect\u00adoriented languages. Advice, \nat the most fundamental level, is a computation that exchanges data with a particular join point, and \nhence a piece of advice is similar to a function. However, there are some subtleties involved in the \nde.nition. Advice can not only manipulate the data at the point, it can also in.uence the control .ow \nperhaps by skipping code that would have been run in the advice s absence. The advice {l.x . e} indicates \nthat it will be triggered when control .ow reaches a point labeled l.The variable x is bound to the data \nat that point, and evaluation proceeds with the expression e, the body of the advice. Assuming that the \nadvice {l.x . e} has been installed in the program s dynamic environment, the example v1 + l( v2) evaluates \nto v1 + e{ v2/x} . Note that the advice computes a value of the same type as its argument, in this case \nan integer importantly, advice can be composed with other advice. The same label may be used to tag distinct \ncontrol .ow points, as long as those points indicate computations of the same type. For example, the \nprogram l( v1) + l( v2) causes two instances of the advice {l.x . e} to be run, but one instance will \nbe passed v1 and the other will be passed v2 Multiple pieces of advice may apply at the same control\u00ad.ow \npoint. Because, in general, advice may have e.ects, the order in which they run is important. It therefore \nseems natural that there should be at least two ways to install advice in the run-time environment, one \nthat runs the new advice prior to any other and one that runs it after any other. (One could imagine \ngeneralizations of this idea, but this simple scheme su.ces for many interesting applications of aspects.) \nAccordingly, the core aspect language includes expression forms a << e and a >> e to respectively install \nthe advice a prior to and after the other advice. In both cases running the advice a is delayed until \nthe corresponding join point is reached; the program continues as expression e. The following examples \nshow how advice precedence works (assuming that there is no other advice associated with label l in the \nenvironment).1 {l.x . x +1}<< {l.y . y * 2}<< l( 3) * 7 -. {l.x . x +1}<< {l.y . y * 2}>> l( 3) * 8 -. \nBecause it can be di.cult to reason about the behavior of a program when the advice associated with a \nlabel is unknown, it is useful to introduce a scoping mechanism for labels. The expression new p: t. \ne allocates a fresh label that is bound to the variable p in the expression e.Labels are considered .rst \nclass values, so the example above can be rewritten as follows: new p: int. {p.x . x +1}<<{p.y . y * \n2}<< p( v) This ensures that only the advice explicitly declared in the scope of the new get triggered \nat the location p( v) .The 1The operators << and >> are left-associative, and eval\u00aduation proceeds from \nleft to right. Hence, a1 << a2 << e installs a1 in the environment .rst and a2 in the environ\u00adment second, \nbefore proceeding with evaluation of e. variables bound by the new expression a-vary, providing for modular \nprogram design. With the features described so far, it is easy to see that as\u00adpects are a powerful (and \npotentially dangerous) tool. Con\u00adsider the following example: new p : bool. {p.x .p(x)}<< p(true) This \nprogram immediately goes into an in.nite loop, even though the underlying program to which the advice \napplies, true, is already a value. Wand and others [16] have ob\u00adserved that aspects can be used to implement \narbitrary .x\u00adpoints of functions using this technique. As another exam\u00adple of the power of aspects, the \nprogram below shows how to encode a (somewhat ine.cient) implementation of reference cells using the \nstate provided by advice. A reference cell is represented as a pair of functions, the .rst dereferences \nthe cell and the second updates the cell s contents. The data is stored in advice associated with label \nref ;the last advice to be run returns the current contents of the reference. def makeref = .init : t. \nnew ref : t. {ref .x .init}<< let get = ._ : unit.ref (init)in let set = .y. : t.{ref .y .y '}>>() in \n(get,set) As these examples show, aspects can radically alter the se\u00admantics of a given programming language. \nPart of the con\u00adtribution of this work is to provide a framework that makes studying these issues straightforward. \nIt is sometimes desirable for advice to suppress the exe\u00adcution of a piece of code or replace it altogether. \nThe last feature of the core aspect calculus, written return v to l, allows such alterations to the control \n.ow of the program. Operationally, return is very similar to throwing a value to a continuation or raising \nan exception. The value v is directly passed to the nearest enclosing control-.ow point labeled l, bypassing \nany intervening pending computation. If there is no point with label l, the program halts with an error \n(this is analogous to an uncaught exception). As an example, the following program evaluates to the value \n3: new p : int.p(4+(return 3 to p)) A second example (below) shows how to instrument a function f = .x \n: bool.e of type bool .t so that if its argument is true then e proceeds as usual, otherwise some alternative \ncode e is run. new fpre : bool. new fpost : bool. {fpre .x.if x then x else return e . to fpost } >> \n.x:bool.fpost (let x = fpre (x)in e) The strategy is to use two labels, fpre and fpost ,that get triggered \nat the function s entry and exit. The advice asso\u00adciated with the precondition checks the value of x \nand, if it is true simply returns control to the body of the function. If x is false, the advice runs \ne . and returns the result directly to the point labeled fpost . The function is instrumented by adding \nthe label fpre , which will trigger the precondition ad\u00advice to inspect the function argument x, and \nby adding the label fpost around the entire function body, which speci.es the return point from the function. \n2.1 Operational Semantics This section describes the operational semantics for the core language, whose \ngrammar is summarized below. For simplicity, the base language is chosen to be the simply\u00adtyped lambda \ncalculus with Booleans and n-tuples. l . Labels v ::= {v.x .e} |b |l |.x : t. e |(tv) e ::= x |v |if \ne1 then e2 else e3 |e1 e2 | (e1,...,en)(n=0) |let(tx:tt) = e1 in e2 | new x : t. e |e1(e2)|return e1 \nto e2 | {e1.x .e2} |e1 >> e2 |e1 << e2 Let b range over the Boolean values true and false and a range \nover advice values {v.x .e2}. The other syntac\u00adtic categories in the language include labels for control-.ow \npoints (l), values (v) and expressions (e). If te is a vector of expressions e1, e2, ..., en for n =0, \nthen (te) creates a tuple. The expression let(tx : tt) = e1 in e2 binds the components of a tuple e1 \nto the vector of variables tx in the scope of e2. Types on let-bound variables are often omitted when \nthey are clear from context. The point cut language has been reduced to the barest minimum for the core \ncalculus. However, the language de\u00adsign and semantics are completely compatible with more expressive \npoint cuts; Section 4 investigates several alterna\u00adtives. Note that point cuts, advice and labels are \n.rst-class values; these values may be passed to and from functions just as any other data structure. \nThe operational semantics uses evaluation contexts (E) de.ned according to the following grammar: E ::= \n[] |if E then e2 else e3 |Ee |vE | (tv, E, te) |E << e |E >> e |E(e)|l(E)| {E.x .e} |return E to e |return \nv to E These contexts give the core aspect calculus a call-by-value, left-to-right evaluation order, \nbut that choice is orthogonal to the design of the language. The only requirement is that evaluation \nbe allowed to proceed under labeled points: l(E)should be an evaluation context. This requirement ensures \nthat the evaluation contexts accurately describe the nesting of labels as they appear in the call stack. \nThe operational semantics must keep track of both the labels that have been generated by the new construct \nand the advice that has been installed into the run-time envi\u00adronment by the program. An allocation-style \nsemantics [12] keeps track of a set L of labels (and their associated types). Similarly, A is an ordered \nlist of installed advice the << and >> operators respectively add advice to the head (left) and tail \nof this list. Finally, the abstract machine states or con.gurations C used in our operational semantics \nare triples, (L, A, e). L ::= \u00b7|L, l : tA ::= \u00b7|A,a C ::= (L, A, e) Because the return operation needs \nto pass control to the nearest enclosing labeled point, it is convenient to de.ne a function stack(E) \nthat takes an evaluation context E and returns the stack of labels appearing in the context. Such stacks \ns, are given by the following grammar: s ::= \u00b7|l |s1 :: s2 The top of the stack is to the left of the \nlist. Stack con\u00adcatenation, written s1 :: s2, is associative with unit \u00b7.The function stack(E) is inductively \nde.ned on the structure of E, where the only interesting cases are: stack([ ]) = \u00b7 stack(l( E) )=stack(E):: \nl For the other evaluation context forms, stack(E)simply re\u00adturns the recursive application of stack(- \n) to the unique subcontext: stack(E << e)=stack(E), etc. As an example, stack(l1( (.x : t. l3( e) ) l2( \n[])) )= \u00b7 :: l2 :: l1 The operational semantics of the core aspect calculus is a transition relation \n( L, A, e) -. ( L',A',e') between machine con.gurations consisting of the set of allocated labels, the \nlist of installed advice, and the running program. Most of the rules are straightforward. An auxiliary \nrela\u00adtion -. \u00df, de.ned below, gives the primitive \u00df reductions for the language. ( L, A, (.x : t. e) \nv) -. \u00df ( L, A, e{ v/x}) ( L, A, if true then e1 else e2) -. \u00df ( L, A, e1) ( L, A, if false then e1 else \ne2) -. \u00df ( L, A, e2) ( L, A, let (tx) = (tv)in e) -. \u00df ( L, A, e{tv/tx}) (l . L) ( L, A, new x : t. e) \n-. \u00df ( (L, l : t),A, e{ l/x}) ( L, A, a << e) -. \u00df ( L, (a, A),e) ( L, A, a >> e) -. \u00df ( L, (A, a),e) \nThe .rst four rules are the usual \u00df-rules for the lambda calculus with Booleans and tuples, where e{ \nv/x} is capture\u00adavoiding substitution of the value v for the variable x in the expression e. The .fth \nrule allocates a fresh label l and substitutes it for the variable x in the scope of the new operator. \nThe last two rules simply add the advice a to the appropriate end of the list. Advice at the head of \nthe list will be run before advice at the tail. The \u00df-reductions apply in any evaluation context, as \nex\u00adpressed by the following rule: ( L, A, e) -. \u00df ( L',A',e') ( L, A, E[e]) -. ( L',A',E[e']) The remaining \nconstructs, advice invocation and the return expression, require more complex evaluation semantics. Because \nmultiple pieces of advice may be triggered at a single point, the operational semantics must compose \nthem together in the order indicated by the list A.To do so, the advice {p.x . e} is treated as a function \n.x : t. e,which can be combined with other advice using standard function composition. The composition \nis well de.ned because advice that accepts input of type t must produce an output of type t (or return \nto a point lower in the stack). This behavior is captured by two auxiliary de.nitions. ' The .rst, A \n[[A]]C = e, takes a list of advice A and returns a ' function ethat is the composition of the applicable \nadvice in the state C. The second judgment has the form C |= p and is valid if the point-cut p is satis.ed \nby the con.guration C. In general, the satisfaction relation may be an arbitrary predicate on the current \nstate of the abstract machine; Sec\u00adtion 4 details some more point-cuts. However, in this core language, \nthe satisfaction relation is simply de.ned to be the equality relation between p and the label at the \ncur\u00adrent program point. The advice composition and point-cut satisfaction are de.ned by the following \nrules. A [[\u00b7 ]](L,A,E[l(v)]) = .x : L(l).x C |= v A [[A]]C = .y : t. e' ' A [[{v.x . e},A]]C = .x : t. \n((.y : t. e) e) C| =v A [[A]]C = e' l = p A [[{v.x . e},A]]C = e' ( L, A, E[l( v) ])|= p With these de.nitions, \nthe evaluation rule for l( v) simply applies the function resulting from interpreting the advice list \nto the value v. A [[A]](L,A,E[l(v)]) = e ( L, A, E[l( v) ]) -. ( L, A, E[ev]) The expression return v \nto l immediately hands the value v to the nearest enclosing program point labeled by l.Using evaluation \ncontexts and the stack(- ) function, this behavior is expressed by the following rule: (l . stack(E)) \n( L, A, l( E[return v to l])) -. \u00df ( L, A, l( v)) Here, the program consists of a return expression in \na con\u00adtext E labeled by l. Because the stack of labels in E does not contain the label l, the point labeled \nby l must be the closest such point to the return expression. The program thus steps immediately to the \npoint labeled l, discarding the context E. This semantics is essentially the same as those used for exception \nhandlers. Note that if there is no point labeled l in the context of the return this rule does not apply \nand the program will get stuck. 2.2 Type System The type system for the core aspect calculus is a very \nsimple extension of the type system for the base language (in this case, the simply typed lambda calculus). \nThe main consideration is that because it is necessary to pass data back and forth between the join point \nof interest and the advice, the advice and control .ow points must be in agree\u00adment with respect to the \ntype of data that will exchanged. The three new types are t label, the type of labels that can annotate \nprogram contexts of type t, t pc, the type of point cuts matching program contexts of type t,and advice,the \ntype of advice. Types and typing contexts are given by the following grammar: t ::= bool | (t1,...,tn)(n=0) \n| t1 . t2 | t label | t pc | advice G ::= \u00b7| G,x : t Figure 1 contains the typing rules for the new aspect \nex\u00adpressions. These rules make use of the standard judgments of the form G f e : t, indicating that term \ne can be given type t in context G. Boolean and tuple typing (not shown) are standard. Tuple expressions \nare typed by a vector of types tt,where \u00b7 is the empty tuple of types (i.e. unit, inhab\u00adited by ()), \nand if tt and tt' are tuple types, then tt, tt' is their concatenation. For simplicity, the type system \nis parameterized by a map L from labels to the types of the expressions they may mark. A concrete label \nvalue l is given the type t label whenever L(l)= t.The new expression simply introduces a new vari\u00adable \nof type t label. An expression of type t label may be used to label another expression of type t. Since \npoint L(l)= t G,x : t label f e : t ' G f l : t label G f new x : t. e : t ' G f e1 : t label G f e2 \n: t G f e : t label G f e1( e2) : t G f e : t pc G f e1 : t pc G,x : t f e2 : t G f e1 : advice G f e2 \n: t G f {e1.x . e2} : advice G f e1 << e2 : t G f e1 : advice G f e2 : t G f e1 : t G f e2 : t label \nG f e1 >> e2 : t G f return e1 to e2 : t ' Figure 1: Type system cuts are simply labels here, the type \nt pc is implemented by t label: Any expression with type t label may be consid\u00adered to have type t pc. \nAdvice associated with a point cut of type t pc is con\u00adstructed from code that expects a variable of \ntype t.The body of advice must produce a result suitable for returning to the point from which the advice \nwas triggered. Thus, the body of the advice must itself be of type t.Note that because all advice associated \nwith a point cut p accept and produce values of the same type, it is possible to compose them in any \norder the soundness of the composition used in the operational semantics follows from this constraint. \nThe rules for installing advice permit the program to be executed in the presence of the advice to have \nany type. Lastly, the value returned to a label marking a context of type t should itself have type t. \nHowever, as with exception or continuation invocation, the return expression itself may be used in any \ncontext. These rules lead to a straightforward soundness proof in the style of Wright and Felleisen [17]. \nA .nished con.gura\u00adtion is one that is either of the form ( L, A, v) or of the form ( L, A, E[return \nv to l]) where l . stack(E). A con.guration ( L, A, e) is well typed if, for all advice a . A it is the \ncase that \u00b7f a : advice and \u00b7f e : t for some t (where L is the label type map that parameterizes these \ntype checking judgments). Given these de.nitions, the standard lemmas can easily be proved. Theorem 2.1 \n(Progress). If C is well typed then either the con.guration is .nished, or there exists another con.guration \nC ' such that C -. C ' . Theorem 2.2 (Preservation). If ( L, A, e) is well typed and ( L, A, e) -. ( \nL ' ,A ' ,e ' ) then L ' extends L and ( L ' ,A ' ,e ' ) is well typed.  3. MinAML This section gives \na semantics for a concrete AOPL called MinAML by translating it into the core aspect calculus. Figure \n2 displays the MinAML syntax. The base types are Booleans and functions. Booleans are as usual. Func\u00adtion \ndeclarations de.ne a (non-recursive) value and also im\u00adplicitly declare a program point f that can be \nreferred to by advice. Otherwise, functions are treated normally. MinAML allows programmers to de.ne \nstatic, second\u00adclass advice unlike in the more general core language, pro\u00adgrams may not manipulate advice \nat run-time in any signif\u00adicant way. Advice is immediately appended to the advice types t ::= bool | \nt1 . t2 terms e ::= x | b | if e1 then e2 else e3 | let ds in e | e1 e2 decls ds ::= \u00b7 | (bool x = e) \nds | (fun f(x : t1): t2 = e) ds | ad ds prog pts p ::= f aspects ad ::= before p(x) = e | after p(x) \n= e | around p(x) = e | around p(x) = e1; proceed y . e2 Figure 2: MinAML Syntax store when it is declared. \nIn this respect, MinAML is quite similar to AspectJ. Also like AspectJ, MinAML has three sorts of aspects: \nthose that give advice before execution of point cut p (for now, p is limited to be a function call), \nthose that give advice after execution of p, and those that give advice around p. In the .rst and third \ncases, the bound variable x will be replaced by the argument of p when theadviceis triggered. In the \nsecond case, x will be replaced by p s result. When declaring around advice, the programmer can choose \neither to replace p entirely or to perform some pre-computation, proceed with p and then perform some \npost-computation.2 In the latter case, after proceeding with p,afresh variable y is bound to the result \nof the function. Unlike AspectJ, which allows programmers to refer to any method that appears anywhere \nin their program, even pri\u00advate methods of classes, the functions referred to by Mi\u00adnAML advice must \nbe in scope. This decision allows pro\u00adgrammers to retain some control over basic information hid\u00ading \nand modularity principles in the presence of aspects. For instance, a programmer can declare a nested \nutility function and be assured that no advice interferes with its execution. The programmer can also \ndecide to expose the function dec\u00adlaration to manipulation by advice by declaring it in an outer scope. \nThe decision to make the external language well scoped truly is an external language design decision: \nwe believe the core aspect calculus is rich enough to express AspectJ-style, scopeless advice by using \na slightly di.erent translation strategy.3 3.1 MinAML Interpretation We give a semantics to well-typed \nMinAML programs by de.ning a type-directed translation into the core language. The translation is de.ned \nby mutually recursive judg\u00ad 2It is straightforward to permit the proceed command to appear in arbitrary \nexpressions inside advice, but doing so needlessly complicates the presentation without adding any further \ninsight. 3Allowing programmers to reference variables de.ned in in\u00adner scopes would pose some (again, \nexternal language) dif\u00ad.culties as any simple scheme would be incompatible with the basic principles \nof alpha-conversion. However, these dif\u00ad.culties could likely be overcome by giving bindings both an \ninternal and external name, as in Harper and Lillibridge s translucent sum calculus [7]. Once naming \nconventions for the external language have been overcome, the translation to internal language should \nbe straightforward. x: t . G term term P ;G f x : t =. xP ;G f b : bool =. b term P ;G f e1 : bool =. \ne ' 1 term term P ;G f e2 : t =. e ' 2 P ;G f e3 : t =. e ' 3 term ''' P ;G f if e1 then e2 else e3 : \nt =. if e1 then e2 else e3 decs P ;G f ds; e : t =. e ' term P ;G f let ds in e : t =. e ' term term \nP ;G f e1 : t1 . t2 =. e ' 1 P ;G f e2 : t1 =. e ' 2 term P ;G f e1 e2 : t2 =. e ' 1 e ' 2 Figure 3: \nMinAML Interpretation: Terms ments for terms, for declarations and for advice. The term term translation \njudgment has the form P ;G f e : t =. e ' .It computes the type t of the term e and, if it is well-formed, \nproduces a core language term e ' of the same type. The type-checking context is split into two parts. \nThe context G is a mapping from MinAML variables to types. The con\u00adtext P is a mapping from program points \np to pairs of input and output types for that program point. For example, a function f : bool . int extends \nthe context P with the binding f :(bool, int) and extends the typing context G with f : bool . int. The \nterm translation type checks external language terms and translates them into analogous core language \nconstructs. All of the interesting action happens when translating dec\u00adlarations and advice. Figures \n3, 4 and 5 present the details. The main idea in the translation of function declarations has already \nbeen explained by example. Two new program points are declared in the course of the translation, one \nfor the function entry point (fpre ) and one for the exit point (fpost ). These two points may be used \nin advice de.nitions declared in the following scope. The translation maintains the invariant that if \nthe binding p:(t1,t2)appears in P then the translated term will type check in a context extended with \nppre : t1 label,ppost : t2 label. The main ideas for the aspect translation have also been explained \ninformally in previous sections. Before advice for p is de.ned to be core language advice triggered by \nthe ppre join point. After advice for p is triggered by the ppost join point. Around advice with a proceed \nstatement de.nes two pieces of advice, one for the ppre point and one for the ppost point. Finally, around \nadvice without a proceed statement is triggered by ppre but returns to ppost . The main property of the \ntranslation is that it produces well-typed core language terms. De.ne P(p :(t1,t2))to be the context \nppre : t1 label,ppost : t2 label and let P(P )be the point-wise extension of the former translation. \nLemma 3.1 (Translation Type Preservation). 1. If P ;G f e : t term =. e ' then G, P(P ) f e ' : t. 2. \nIf P ;G f ds; e : t decs =. e ' then G, P(P ) f e ' : t. 3. If P ;G f ad adv =. e ' then G, P(P ) f e \n' : advice. term P ;G f e : t =. e ' decs P ;G f\u00b7; e : t =. e ' term decs P ;G f e1 : bool =. e ' 1 \nP ;G,x: bool f ds; e2 : t =. e ' 2 decs P ;G f(bool x = e1) ds; e2 : t =. let x: bool = e1 ' in e2 ' \nterm P ;G,x: t1 f e1 : t2 =. e1 ' decs P, f :(t1,t2); G,f : t1 . t2 f ds; e2 : t =. e2 ' decs P ;G f(fun \nf(x: t1): t2 = e1) ds; e2 : t =. new fpre : t1. new fpost : t2. let f = eb in e ' where eb = .x: t1.fpost \n(let x: t1 = fpre (x) in e1' ) adv decs P ;G f ad =. e ' 1 P ;G f ds; e2 : t =. e ' 2 decs P ;G f ad \nds; e2 : t =. e1 ' >> e2 ' Figure 4: MinAML Interpretation: Declarations term p:(t1,t2) . PP ;G,x: t1 \nf e : t1 =. e ' adv P ;G f before p(x) = e =. {ppre .x . e ' } term p:(t1,t2) . PP ;G,x: t2 f e : t2 \n=. e ' adv P ;G f after p(x) = e =. {ppost .x . e ' } p:(t1,t2) . P term term P ;G,x: t1 f e1 : t1 =. \ne ' 1 P ;G,y : t2 f e2 : t2 =. e ' 2 adv P ;G f around p(x) = e1; proceed y . e2 =. {ppre .x . e1' }>> \n{ppost .y . e2' } term p:(t1,t2) . PP ;G,x: t1 f e : t2 =. e ' adv P ;G f around p(x) = e =. {ppre .x \n. return e ' to ppost } Figure 5: MinAML Interpretation: Aspects The proof of Lemma 3.1 is by induction \non the translation derivation. Combining Lemma 3.1 with the type safety re\u00adsult for the core language \nyields an important safety result for MinAML. Theorem 3.1 (MinAML Safety). term Suppose that \u00b7; \u00b7f e \n: t =. e ' . Then either e ' fails to termi\u00adnate or there is a .nished con.guration (L, A, e '' ) such \nthat (\u00b7, \u00b7,e ' ) -.. (L, A, e '' ) 3.2 Objects The bulk of this paper focuses on using aspects in the \ncontext of a purely functional language. However, we have tried to design the core language so that each \nfeature is orthogonal to the others. In particular, the labeled join points are de.ned independently \nof other constructs and hence can be reused in other computational settings with little change. In order \nto justify this claim, we have lifted Abadi and Cardelli s .rst-order object calculus (AC) directly from \ntheir textbook [1]. This section shows how the aspect language constructs interoperate with it. The main \npoint is that while we naturally need to add objects to both the external and core languages, the semantics \nof join points remains unchanged. Moreover, while additional syntax is needed in the external language \nto allow programmers to refer to new join points, the underlying semantics of advice also remains the \nsame. This analysis provides evidence that the semantic framework is both general and robust. 3.2.1 Object-oriented \nCore Language The type system and syntax for the AC object-oriented language is taken directly from Abadi \nand Cardelli [1]. | [mi:ti]1..n t ::= \u00b7\u00b7\u00b7 = .xi.ei]1..n e ::= \u00b7\u00b7\u00b7 | [mi | e.m | e1.m ..x.e2 = .mi.ei]1..n \nv ::= \u00b7\u00b7\u00b7 | [mi = .xi.ei]1..n AC is a classless language. New objects [mi may be de.ned at any point \nin a computation. The super\u00adscript 1..n indicates there is a series of n method declara\u00adtions in the \nobject. Method invocation is denoted e.m and method update (override) is denoted e1.m ..x.e2. The AC \ntyping rules are straightforward. We have mod\u00adi.ed them to permit labels, and slightly more signi.cantly, \nwe have dropped the subtyping for the sake of simplicity. G,x :[mi:ti]1..n fei : ti = .xi.ei]1..n :[mi:ti]1..n \nG f[mi G fe :[mi:ti]1..n 1 =j =n G fe.mj : tj G fe1 :[mi:ti]1..n G,x :[mi:ti]1..n fe2 : tj 1 =j =n G \nfe1.mj ..x.e2 :[mi:ti]1..n Finally, to extend the operational semantics, we de.ne further evaluation \ncontexts corresponding to the new ex\u00adpression forms and the appropriate beta rules. Evaluation Contexts: \nE ::= \u00b7\u00b7\u00b7 | E.m | E.m ..x.e2 Beta Rules: = .xi.ei]1..n (L, A, [mi .mj )-.\u00df = .xi.ei]1..n (L, A, ej {[mi \n/xj}) = .xi.ei]1..n (L, A, [mi .mj ..x.e)-.\u00df (L, A, [m1 = .x1.e1,...,mj = . x.e,...,mn = .xn.en] ) To \nadapt the progress and preservation theorems stated in the previous section, we need only .ll in the \ninductive cases for objects; the overall proof structure remains intact. 3.2.2 Object-oriented External \nLanguage The external language requires a new type for objects, new declarations for de.ning objects \nand new expression forms for method invocation and update. In addition, we add an expression form to \ncontrol monitoring of method updates. The declaration monitor t.m speci.es that any update of method \nm to an object with type t may be intercepted and modi.ed by advice. This declaration also introduces \na new join point t.m, and programmers can declare before, after and around advice that will be triggered \nby that join point (i.e., triggered whenever the associated method update oc\u00adcurs). Programmers can also \ndeclare advice triggered by calls to the m method of object x via the join point x.m. | [mi:ti]1..n t \n::= \u00b7\u00b7\u00b7 e ::= \u00b7\u00b7\u00b7 | e.m | e1.m ..x.e2 = .xi.ei]1..n d ::= \u00b7\u00b7\u00b7 | (object x : t =[mi ) ds | monitor t.m \nds p ::= \u00b7\u00b7\u00b7 | x.m | t.m As a simple example, consider the following code which declares an object with \ntwo .elds. One .eld holds an integer and the other holds a function that adds the integer to its argument. \nTo prevent the integer .eld from being updated (e.ectively rendering it const ), the program declares \nthat the .eld is monitored and installs around advice that re\u00adplaces any attempted update with the identity \nfunction. let object x:t = [i = .s.3; plus = .s.let fun f x= s.i +xin f] monitor t.i around (t.i) (x) \n= x in ... where t = [i : int; plus : int -> int] Interpreting the object-oriented source language in \nthe core aspect calculus poses no challenges. The monitor dec\u00adlaration translates to a pair of expressions \nthat allocate new pre-and post-labels used to mark method updates. In\u00adterpreting both method update in \nthe case that the up\u00addate is monitored, and object declarations, follows a similar strategy to compilation \nof function bodies. The translation marks the control-.ow points just prior to and just after the operation \nin question. Advice declarations in the same scope can manipulate these program points just as they ma\u00adnipulate \nfunction entry and exit points. The full details have been omitted due to space considerations.  4. \nComplex Point Cuts This section investigates two further generalizations of the basic aspect framework. \nThe .rst generalization allows ad\u00advice to be associated with a set of labels instead of just one label, \nwhich permits the code of the advice to be shared by many program points. The second generalization is \nto per\u00admit run-time inspection of the labels that appear in the call stack, which allows advice to make \ncontext sensitive deci\u00adsions about how to modify the program. 4.1 Label Sets The .rst generalization \nassociates a set of labels with each piece of advice. Doing so is useful in situations where the same \nadvice is applied at many di.erent locations. For ex\u00adample, one might want to instrument a collection \nof related functions of type t1 .t2 with the same preprocessing of the argument, yet still allow the \npossibility of associating other, di.erent advice with each function. With sets of labels, this situation \ncan be expressed as: new pre1:t1.new pre2:t1. {{pre1,pre2}.x.e1} >> // Runs at either point {{pre1}.y.e2} \n>> // Runs at pre1 {{pre2}.z.e3} >> // Runs at pre2 let f = .x:t1. let x = pre1(x) in ... in let g = \n.x:t1. let x = pre2(x) in ... in ... The necessary change to the syntax of the language is minimal, as \nshown in the grammar below: e ::= \u00b7\u00b7\u00b7 |{e1,...,en}| e1 .e2 | e1 ne2 v ::= \u00b7\u00b7\u00b7 |{v1,...,vn} The advice \n{{l1,...,ln}.x .e} is triggered whenever a point labeled by any of the labels l1 through ln is reached. \nTo change the operational semantics of advice invocation, we simply replace the de.nition of the satisfaction \nrelation with the following: l .{l1,...,ln} (L,A,E[l(v)])|= {l1,...,ln} Advice is still applied in the \norder de.ned by the list A, but now advice is triggered by a label l if l is in the set. Evaluation semantics \nfor the set operators e1 .e2 and e1 ne2 are straightforward to de.ne. The type system is altered to use \nthe following rules for type checking point cuts. The type tpc is now implemented by a set of labels \nof the same type. (G fei : tlabel)(1=i=n) G fe1 : tpc G fe2 : t pc G f{e1,...,en}: tpc G fe1 .e2 : tpc \nG fe1 : tpc G fe2 : tpc G fe1 ne2 : tpc One could imaging further re.nements along these lines. For instance, \none re.nement would be to put more structure on the labels themselves, perhaps by introducing a hierarchy \nof labels. A piece of advice would then be triggered by its label or any label lower in the tree. Including \na top label in the hierarchy would let one de.ne advice that is triggered whenever any labeled point \nis reached. 4.1.1 MinAML Extensions and Interpretation Extending MinAML s point cut language to include \nsets of labels requires some minor adjustments to the syntax: pc ::= {p1,...,pn} ad ::= before pc(x) \n= e | after pc(x) = e | around pc(x) = e | around pc(x) = e1; proceed y .e2 The interpretation also requires \nsome adjustments. One problem is that around advice can be called from multi\u00adple di.erent labeled points, \nso it is impossible to determine statically which label it should return to. To circumvent this di.culty, \nthe translation uses .rst-class labels: the around advice is passed the continuation label it should \nreturn to. The new translation of function and advice declarations appears in Figure 6. Given a set s \nof source-level program points {p1,...,pn}, we use the meta-level function pre(s)to generate the corresponding \nset of labels {p1,pre ,...,pn,pre }. The function post(s) is similar. The translation of object expressions \n(omitted) can be dealt with analogously.  4.2 Stack Patterns While labeled program expressions su.ce \nto capture some of the interesting program points, whether a point is in\u00adteresting often depends on context. \nFor example, a typical use of aspects for debugging is to print the arguments of term P;G,x: t1 fe1 : \nt2 =.e1 ' decs P,f:(t1,t2); G,f: t1 .t2 fds; e2 : t=.e2 ' decs P;G f(fun f(x: t1): t2 = e1) ds; e2 : \nt =. new fpre : t1 \u00d7t2 label.new fpost : t2. let f = eb in e ' 2 def eb = .x: t1.fpost (let (x, )= fpre \n((x,fpost ))in e1' ) term (p:(t1,t2) .P)p.s P;G,x: t1 fe: t1 =.e ' adv P;G fbefore s(x) = e =. {pre(s).x \n.let (x,l)= xin (e ' ,l)} term (p:(t1,t2) .P)p.s P;G,x: t2 fe: t2 =.e ' adv P;G fafter s(x) = e=.{post(s).x.e \n' } (p:(t1,t2) .P)p.s term term P;G,x: t1 fe1 : t1 =.e ' 1 P;G,y: t2 fe2 : t2 =.e ' 2 adv P;G faround \ns(x) = e1; proceed y .e2 =. {pre(s).x .let (x,l)= xin (e1' ,l)} >> {post(s).y .e2' } term (p:(t1,t2) \n.P)p.s P;G,x: t1 fe: t2 =.e ' adv P;G faround s(x) = e =. {pre(s).x .let (x,l)= xin return e ' to l} \nFigure 6: MinAML Interpretation: Label Sets a function f when it is called from inside the body of a \nsecond function, g. The debugging advice is not invoked when f is called from some third function h. \nTo enable this application, AOPLs provide mechanisms that allow the pro\u00adgrammer to specify in what dynamic \ncontexts advice should be triggered. One could tie this contextual information into the advice construct \nitself, but it seems more general to provide an orthogonal mechanism for querying the run-time state \nof the program. This section proposes stack patterns as a way to achieve the desired expressiveness without \naltering the advice; this approach leads to a cleaner semantics. During the course of evaluation, the \nlabeled program points naturally form a stack, which is a useful model of the com\u00adputation being carried \nout by the program. The return expression already makes use of this fact to determine to which point \ncontrol should be passed. Stack patterns allow programmers to write queries over the label stack. Aspect-oriented \nlanguages also permit queries on the data stored in the run-time stack. This facility is useful for writ\u00ading \npoint-cut designators: triggers that depend on context. To handle this feature, we extend the core language \nwith a means of storing data values in the stack by adding a new expression store x: t= e1 in e2.The \nsemantics of store is like an ordinary let except that the substitution of the value for the bound variable \nis performed explicitly evaluation proceeds within the body of the store. The evaluation con\u00adtexts are \nextended to include: E ::= ... | store x= E in e | store x= v in E Two additional \u00df-rules model the explicit \nsubstitutions; here, the function svars(E) yields the set of variables x such that E = E ' [store x = \nv in E '' ]. (L, A, store x = v in E[x]) -.\u00df (L, A, store x = v in E[v]) (x .svars(E)) (L, A, store x \n= v in v ' ) -.\u00df (L, A, v ' ) Allowing evaluation to proceed under the store binding means that the stack \nembodied by the evaluation contexts now includes the stored data. Thus, we can extend stacks to include \nvalues (val : t = v) in addition to the labels, and extend the stack(-) function to extract the data \ntoo: s ::= \u00b7| l | s1 :: s2 | val : t = v stack(store x : t = v in E)=stack(E):: (val : t = v) stack(store \nx : t = E in e)=stack(E) Stack patterns are expressions that describe the stack of labels and stored \nvalues present in the dynamic evaluation context the metavariable pat is used to emphasize that a given \nexpression is in fact a stack pattern. A stack pattern is similar to a regular expression over labels, \nbut it may also bind stored values. The grammar below summarizes the additions to the base language needed \nfor stack patterns. e ::= ... | l | e1; e2 | e1 | e2 | e * | e1 &#38; e2 |\u00ace | val : t | match[t](e) \nthen e1 else e2 v ::= ... | l | v1; v2 | v1 | v2 | v * | v1 &#38; v2 |\u00acv | val : t The pattern l matches \nthe stack consisting of the label l. Concatenation of pattern expressions is written e1; e2, union is \nwritten e1 | e2, and a Kleene star operator is written e * . The intersection operator e1 &#38; e2 matches \npatterns in the intersection of those matched by e1 and e2, binding the data from both patterns. A negation \npattern, \u00ace, matches a stack if there is no possible way to parse the stack successfully according to \ne. The pattern val : t matches a value of type t stored in the stack. Booleans true and false are patterns \nthat respectively match all stacks and no stacks. The program form match[t](pat) then e1 else e2 attempts \nto match the pattern pat against the dynamic stack, extract\u00ading any data bound by val : t patterns. If \nthe stack success\u00adfully matches the pattern, the expression e1,which must be a function, is applied to \nthe extracted data. Otherwise the expression e2 is evaluated. Consider instrumenting a function f with \npre-and post\u00adlabels as in the translation from MinAML. Using store rather than an ordinary let to bind \nthe argument to f gives the following: .x : t. fpost (store x = fpre (x)in e) This new translation allows \na stack pattern to extract the argument passed to f. For example, one can write a piece of advice that \ntakes action only when g is called directly from the body of f. In the example, the f s argument is bound \nto the variable y in the expression e. {gpre .x . match(gpre ;gpost ;val : t;fpost ;true) then .y : t. \ne // take action else x} // just continue The stack matches the pattern gpre ;gpost ;val : t;fpost ;true \nonly when control is inside the precondition advice of g but before leaving the scope of f. (The tail \nof the stack, matched by true, can be anything.) There is some subtlety here, s |= true .\u00b7 l |= l .\u00b7 \nval : t = v |= val : t .v s |= pat1 .vt1 s |= pat2 .vt2 s |= pat1 .vt1 s |= pat1 &#38; pat2 .vt1,tv2 \ns |= pat1 | pat2 .vt1 s1 |= pat1 .vt1 s2 |= pat2 .vt2 s |= pat2 .vt2 s1 :: s2 |= pat1; pat2 .vt1,tv2 \ns |= pat1 | pat2 .vt2 s1 |= pat .\u00b7 s2 |= pat * .\u00b7 s |= pat .tv \u00b7|= pat * .\u00b7 s1 :: s2 |= pat * .\u00b7 s |= \n\u00acpat .\u00b7 Figure 7: Stack Pattern Interpretation though: Unless all functions have been instrumented with \npre-and post-labels, there might be calls to arbitrarily many unlabeled functions between the fpost and \ngpre . On the other hand, this regular expression does not permit any labels to appear between fpost \nand gpost on the stack. To allow that situation, the regular expression gpre ;gpost ;true;val : t;fpost \n;true could be used instead. Which label is desirable depends on the situation. The point is that this \nframework is .exible enough to express many possible choices, several more of which are explored in the \ntranslation of an extended variant of MinAML discussed below. Besides adding additional evaluation contexts \nto handle the evaluation of the stack patterns themselves, the opera\u00adtional semantics must de.ne the \nbehavior of the match ex\u00adpression. Two additional rules are needed: stack(E) |= pat .tv (L, A, E[match[t](pat) \nthen e1 else e2])-.(L, A, E[e1 (tv)]) stack(E) |= pat .tv (L, A, E[match[t](pat) then e1 else e2])-.(L, \nA, E[e2]) In these evaluation rules, the judgment s |= pat .tv de\u00adtermines when the stack s matches the \npattern pat.If so, any values matched by pat are returned in the vector tv. A reasonable implementation \nof stack matching would be to restrict the regular expressions to be second class values by permitting \nonly matches against stack predicate values. This would permit the compiler to generate an e.cient au\u00adtomaton \nfor pattern matching; however, for the sake of gen\u00aderality, we consider the fully dynamic case here. \nIt is easy to specify the implementation of s |= pat . tv using the nondeterministic inference rules \nshown in Figure 7. The only remaining issue is how to assign types to pat\u00adterns. The simplest solution \nis to give stack patterns their own type, t pat, the type of patterns that binds data of type t. Booleans \nand labels can be treated as stack predicates rather than use full-blown subtyping, the rules in Figure \n8 instead permit the coercion directly. The additional type machinery is straightforward: stack patterns \nmay be built compositionally out of stack patterns, and the match ex\u00adpression takes a pattern, function \nto handle the successful match, and an expression to return in case of match failure. 4.2.1 MinAML Extensions \nand Interpretation Extending MinAML with richer point-cut designators in the style of AspectJ requires \na change to the source syntax, as shown in the following grammar. G fe : bool G fe : t label G fe : tt \npat G fe : \u00b7pat G fe : \u00b7pat G f\u00ace : \u00b7pat G fe1 : tt1 pat G fe2 : tt2 pat G fe : \u00b7pat G fe1 &#38; e2 : \ntt1, tt2 pat G fe * : \u00b7pat G fe1 : tt pat G fe2 : tt pat G fe1 | e2 : tt pat G fval : t : t pat G fe1 \n: tt1 pat G fe2 : tt2 pat G fe : \u00b7pat G fe1; e2 : tt1, tt2 pat G fe * : \u00b7pat G fe : tt pat G fe1 : tt \n.t ' G fe2 : t ' G fmatch[t](e) then e1 else e2 : t ' Figure 8: Stack Pattern Typing (f :(t1,t2) .P ) \npcd P ;G fwithinf(x): x : t1 =.(val : t1); fpost ; true pcd P ;G fpcd :G ' =.pat pcd P ;G fcflow(pcd) \n:G ' =.\u00ac(true; pat; true); pat; true pcd P ;G fpcd :G ' =.pat pcd P ;G fcflowtop(pcd) :G ' =.true; pat; \n\u00ac(true; pat; true) Figure 9: MinAML Interpretation: Point-cut desig\u00adnators pcd ::= withinf(x) | pcd1 \n&#38; pcd2 | pcd1 | pcd2 |\u00acpcd | cflow(pcd) | cflowtop(pcd) ad ::= before pc(x) when pcd = e | after \npc(x) when pcd = e | around pc(x) when pcd = e | around pc(x) when pcd = e1; proceed y .e2 The when clauses \nspecify that the advice will be triggered only under the conditions given by the point-cut designa\u00adtor \npcd.The withinf(x) designator says that the advice is triggered only when control is immediately inside \nthe body of the function f (with no intervening calls). In this case, the variable x is bound to the \nargument passed to f.The cflow(pcd) designator says that the advice is triggered if a part of the calling \ncontext matches pcd, where the ar\u00adguments bound in the pcd are the nearest such call . For example, cflow(withinf(x)) \nmeans that the advice may be triggered from within arbitrarily deeply nested function calls reachable \nfrom within the body of f and that x will be bound to the most recent arguments passed to f.Designator \ncflowtop(pcd) is similar to cflow except that the arguments are bound to the earliest calls rather than \nthe most recent. The pcd1 &#38; pcd2 designator requires the context to match both pcd1 and pcd2,and \npcd1 | pcd2 requires the context to pcd (p :(t1,t2) .P )p.s P ;G fpcd :G ' =.pat term ctx ' G ' P ;G, \nG ' ,x : t1 f e : t1 =. e =. t adv P ;G fbefore s(x) when pcd = e =.Pre(s, x, t, pat, G ' ,e ' ) pcd \n(p :(t1,t2) .P )p.s P ;G fpcd :G ' =.pat term ctx ' G ' P ;G, G ' ,x : t2 f e : t2 =. e =. t adv P ;G \nfafter s(x) when pcd = e =.Post(s, x, t, pat, G ' ,e ' ) pcd ctx (p :(t1,t2) .P )p.s P ;G fpcd :G ' =.pat \nG ' =.t term term P ;G, G ' ,x : t1 fe1 : t1 =.e ' 1 P ;G, G ' ,y : t2 fe2 : t2 =.e ' 2 adv P ;G faround \ns(x) when pcd = e1; proceed y .e2 =. Pre(s, x, t, pat, G,e1' ) >> Post(s, x, t, pat, G,e2' ) pcd (p :(t1,t2) \n.P )p.s P ;G fpcd :G ' =.pat ctx term G ' =.tP ;G, G ' ,x : t1 fe : t2 =.e ' adv P ;G faround s(x) when \npcd = e =. Return(s, x, t, pat, G,e ' ) def Pre(s, x, t, pat, G,e)= {pre(s).x. let (x, l)= x in PreBody(s, \nx, t, pat, G,e) def Return(s, x, t, pat, G,e)= {pre(s).x. let (x, l)= x in PreBody(s, x, t, pat, G, \nreturn e to l) def PreBody(s, x, t, pat, G,e)= match[t](oneOf(pre(s)); l; pat) then args(t, G,e) else \nx} def Post(s, x, t, pat, G,e)= {post(s).x. let (x, l)= x in match[t](oneOf(post(s)); pat) then args(t, \nG,e) else x} def oneOf(l1,...,ln)= (l1|...|ln) def args(t, G,e)= .a : t. let (G) = a in e Figure 10: \nMinAML Interpretation: when advice match at least one of pcd1 and pcd2. Negation, \u00acpcd,holds if there \nis no possible way of parsing the stack to match pcd. The new translation assumes that function arguments \nare store-bound rather than let-bound. With that slight change to the MinAML translation, the stack, \nexcept for the top of the stack, is guaranteed to look like: nn-1 00 val : t :: fn :: val : t :: fn-1 \n:: ... :: val : t :: f(.) post post post ; fn+1 The top of the stack is either fn+1 or fn+1, depending \npre post post on whether execution is just entering or just leaving f. A point-cut designator translates \nto a stack pattern. The three interesting cases are shown in Figure 9 (the remaining cases are straightforward). \nThe patterns assume that the stack is of the form (.) the translation of the advice dec\u00adlarations themselves \ntake care of the rest of the pattern, as shown in Figure 10. This translation handles label sets as well \nas when clauses, so it threads the return label through the aspects. The withinf(x) pattern requires \nthat the top of the stack have the form val : t :: fpost ;the variable x will be bound to the value matched \nby the pattern. The cflow(pcd) and cflowtop(pcd) clauses respectively compile to patterns that match \nthe closest and farthest occurrence of pat. The compilation of point-cut designators is similar to the \ntranslation shown in Figure 6. One di.erence is that the when clause pattern is matched before proceeding \nwith the advice. The top of the stack for before advice must have the corresponding pre label; for after \nadvice the top of the stack is the post label. Another di.erence is that the advice bodies bind the tuple \nof values extracted from the stack by the match. In the .gure, the notation (G) stands for the tuple \nof variable bindings evident from the typing context ctx G. Similarly, the notation G =. t means that \nt is the tuple of types found in the context G. This translation of MinAML is also type preserving. Let \nP (p :(t1,t2)) be the context ppre :(t1,t2 label) label,ppost : t2 label and let P (P ) be the point-wise \nextension. Lemma 4.1 (Translation Type Preservation). term 1. If P ;G f e : t =. e ' then G, P (P ) f \ne ' : t. decs 2. If P ;G f ds; e : t =. e ' then G, P (P ) f e ' : t. adv 3. If P ;G f ad =. e ' then \nG, P (P ) f e ' : advice. pcd ctx 4. If P ;G f pcd :G ' =. pat and G ' =. t then G, P (P ) f pat : t \n  5. Discussion 5.1 AspectML: A Prototype Implementation In order to experiment further with our language \ndesign, we have developed a prototype implementation of most of the features described in this paper, \nomitting objects, and negation and value patterns for now. The prototype, which we call AspectML, is \ndeveloped in SML/NJ [2] as an exten\u00adsion to core ML. The core aspect calculus is implemented as a set \nof ML libraries for explicitly manipulating labeled program points, creating and using higher-order, \n.rst-class aspects and query\u00ading the calling context via a stack predicate language. The libraries have \nthree main modules. Point manages creation and comparison of the struc\u00adtured labels used to mark join \npoints.  RE supplies utilities for building regular expression pat\u00adterns out of points and matching \nthem against point lists. It is implemented using the SML/NJ regular ex\u00adpression matching utilities. \n Aspect implements the operational semantics of the core calculus.  The library interfaces are included \nin Appendix C. For the most part, the implementation follows the theory di\u00adrectly. One deviation is that \nrather than limiting program\u00admers to some set of domain-speci.c predicates for specifying point cuts, \nwe have left the language open for experimenta\u00adtion. Programmers can use any function from label-stacks \nto Booleans as trigger predicates; if the function evaluates to true at a join point, the advice is invoked. \nProgrammers can also expose the current label stack as a list of points and use regular expression queries \nto construct these functions or write their own functions over point lists. One other deviation is that \nSML s type system is not quite strong enough to encode the heterogeneous list of aspects that makes up \nthe aspect store.4 Hence, before passing data to an aspect we need to coerce it into a universal data \ntype (UniversalDT.all), and we need to coerce it back out of a universal data type on return. The external \nlanguage (AspectML) is implemented by a simple program rewriter that converts .aml .les into .sml .les. \nAspectML programmers may explicitly call the core calculus libraries if they wish to manipulate labeled \nprogram points directly. They may also use a new form of function declaration, afun f (x:t1):t2 = e, \nwhich implic\u00aditly allocates pre-and post-join points for monitoring func\u00adtion entry and exit as described \nearlier. Ordinary SML fun declarations cannot be monitored by aspects. Consequently, unlike in other \naspect-oriented programming languages that we are aware of, AML programmers can choose to protect sections \nof their code from external interference and retain the standard ML reasoning principles that they are \nused to. 5.2 Related work There are a number of aspect-oriented language design and implementation e.orts \nthat have already made a sig\u00adni.cant impact on industry, including AspectJ [10] and Hy\u00adper/J [13]. However, \nthe study of the semantics of aspect\u00adoriented languages lags well behind. Most closely related to this \npaper is Tucker and Krishna\u00admurthi s work on encoding aspects in Scheme [14]. Their approach uses continuation \nmarks, a construct introduced by Clements et al. to aid in the implementation of program debugging tools \n[5]. Continuation marks are very similar to labeled program points except that (dynamically) they do \nnot nest the outer continuation mark overrides the inner. In the notation of this paper, the behavior \nof continuation marks could be modeled by adding an additional \u00df rule: l1( l2( v)) -. \u00df l1( v) . This \ndi.erence leads to a slightly more complex encoding of aspects. A more signi.cant di.erence between this \nwork and Tucker and Krishnamurthi s is that this paper develops a typed theory of aspects as opposed \nto an untyped theory of aspects. Douence, Motelet and Sudholt [6] give a de.nition of point\u00adcuts by encoding \nthem in Haskell; they also provide an im\u00adplementation in Java. However, the speci.cation of advice is \nnot integrated into their language. Instead, programs have two parts, an event (program point) producer \nand a moni\u00adtor that consumes and reacts to these program points. Ma\u00adsuhara, Kiczales and Dutchyn [11] \nspecify the semantics of an aspect-oriented language in Scheme and show how partial evaluation can be \nused to compile and optimize it. A couple of authors have developed small, untyped formal calculi for \nreasoning about aspects. For instance, Wand, Kiczales and Dutchyn [16] have developed a denotational \nsemantics for pointcuts and advice in a small aspect calcu\u00ad 4The aspect store would ideally be a list \nof . t.t label \u00d7 t . t elements. Unfortunately, SML does not provide existential types or the primitives \nfor intensional type analysis that we would need. Stephanie Weirich suggested the encoding using universal \ndata types that we currently use. lus. Jagadeesen, Je.rey and Riely [9] develop an object\u00adoriented, aspect-oriented \nlanguage and give a speci.cation and correctness proof for weaving. In each case, join points are directly \nlinked to the semantics of method calls rather than being developed as an orthogonal programming con\u00adstruct. \nWe believe that elevating join points to the status of a .rst-class abstraction allows our semantic framework \nto be used in a broader collection of situations, including functional, imperative and object-oriented \nlanguages. We also feel that staging AOP semantics in terms of core and external languages is an important \ndevelopment as it helps modularize the theory and makes it possible to simplify the core language to \nits barest minimum. Bauer, Ligatti and Walker [4] describe a language for con\u00adstructing .rst-class and \nhigher-order aspects. They also pro\u00advide a system of logical combinators for composing advice and type \nand e.ect system to ensure that advice does not interfere with other advice. Unfortunately, the presence \nof aspect combinators makes the operational semantics for the language very complex. Consequently, their \nsemantics does not make an appropriate platform for experimenting with aspect-oriented design in general \nor for investigating general\u00adpurpose reasoning principles in the presence of aspects. Stack patterns \nprovide a mechanism similar to stack in\u00adspection mechanism [15], and it would be interesting to ex\u00adplore \nthis connection further. One might be able to imple\u00adment stack-inspection-like security policies via \naspects. 5.3 Future Work Avenues for future research fall into four main categories: 1. Further development \nof the semantics of aspects. 2. Program analysis and type systems that promote safe use of aspect-oriented \nparadigms. 3. Extension of our AspectML implementation to cover all of Standard ML, including admitting \nfurther im\u00adplicit program points and integration with ML s so\u00adphisticated module system. 4. Analysis \nof the performance cost of the advanced fea\u00adtures including .rst-class advice and stack patterns.  While \nall of these directions are appealing, we plan to concentrate on items (1) and (3) in the near future. \nMore speci.cally, we wish to consider enriching our simple calcu\u00adlus by adding new primitives, for example \nto explicitly delete advice. In addition, it seems desirable to develop a theory of contextual equivalence \nfor aspect-oriented programs. We conjecture that such a theory will be tractable for the mini\u00admalist \ncore calculus we presented in Section 2. With respect to item (3), we believe that de.ning a well-typed \nand well\u00adscoped core aspect calculus is a signi.cant step towards de\u00adveloping an aspect-oriented language \nthat can interoperate benignly with advanced ML-style modules. In fact, our ini\u00adtial inspiration for \nlabeled control-.ow points was derived in part from the internal and external labels found in Harper \nand Lillibridge s translucent sum calculus [7].  6. Conclusions This paper has shown that the main features \nof aspect\u00adoriented languages can be modeled by a few relatively simple constructs in a core calculus. \nThe key features are: labeled control .ow points, support for manipulating data and con\u00adtrol at those \npoints, and a mechanism for inspecting the run-time stack. This approach leads to a (largely) language \nindependent, semantically clean way of studying aspects. We have developed the theory of this core aspect \ncalculus and demonstrated its applicability by type-directed transla\u00adtions from MinAML, a fragment of \nML with aspects, and an object-oriented language. We claim that this approach is scalable, general, and \ntheoretically well founded.  Acknowledgments Many thanks to Dan Dantas, Kathleen Fisher, Stephanie Weirich, \nand the U. Penn. PL Club for their helpful feed\u00adback on earlier drafts of this work. We also thank Shriram \nKrishnamurthi and John Clements for pointing us to the work on aspects and continuation marks in Scheme. \n References [1] M. Abadi and L. Cardelli. A Theory of Objects. Monographs in Computer Science. Springer-Verlag, \nNew York, 1996. [2] A. W. Appel and D. B. MacQueen. Standard ML of New Jersey. In M. Wirsing, editor, \nThird International Symposium on Programming Language Implementation and Logic Programming, pages 1 13, \nNew York, Aug. 1991. Springer-Verlag. Volume 528 of Lecture Notes in Computer Science. [3] Aspect-oriented \nprogramming. In T. Elrad, R. E. Filman, and A. Bader, editors, Special Issue of Communications of the \nACM, volume 40(10). Oct. 2001. [4] L. Bauer, J. Ligatti, and D. Walker. Types and e.ects for non-interfereing \nprogram monitors. In International Symposium on Software Security,Tokyo, Japan, Nov. 2002. [5] J. Clements, \nM. Flatt, and M. Felleisen. Modeling an algebraic stepper. In European Symposium on Programming, pages \n320 334, 2001. [6] R. Douence, O. Motelet, and M. S\u00a8udholt. A formal de.nition of crosscuts. In Third \nInternational Conference on Metalevel architectures and separation of crosscutting concerns, volume 2192 \nof Lecture Notes in Computer Science, pages 170 186, Berlin, Sept. 2001. Springer-Verlag. [7] R. Harper \nand M. Lillibridge. A type-theoretic approach to higher-order modules with sharing. In Twenty-First \nACM Symposium on Principles of Programming Languages, pages 123 137, Portland, OR, January 1994. [8] \nR. Harper and C. Stone. A type-theoretic interpretation of Standard ML. In Proof, Language and Interaction: \nEssays in Honour of Robin Milner. The MIT Press, 1998. [9] R. Jagadeesan, A. Je.rey, and J. Riely. A \ncalculus of untyped aspect-oriented programs. In European Conference on Object-Oriented Programming, \nDarmstadt, Germany, July 2003. To appear. [10] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersten, J. Palm, \nand W. Griswold. An overview of AspectJ. In European Conference on Object-oriented Programming. Springer-Verlag, \n2001. [11] H. Masuhara, G. Kiczales, and C. Dutchyn. Compilation semantics of aspect-oriented programs. \nIn G. T. Leavens and R. Cytron, editors, Foundations of Aspect-Oriented Languages Workshop, pages 17 \n25, Apr. 2002. [12] G. Morrisett, M. Felleisen, and R. Harper. Abstract models of memory management. \nIn ACM Conference on Functional Programming and Computer Architecture, pages 66 77, La Jolla, June 1995. \n[13] H. Ossher and P. Tarr. Hyper/J: multi-dimensional separation of concerns for Java. In International \nconference on software engineering, pages 734 737, Limerick, Ireland, June 2000. [14] D. B. Tucker and \nS. Krishnamurthi. Pointcuts and advice in higher-order languages. In Proceedings of the 2nd International \nConference on Aspect-Oriented Software Development, pages 158 167, 2003. [15] D. S. Wallach, A. W. Appel, \nand E. W. Felten. The security architecture formerly known as stack inspection: A security mechanism \nfor language-based systems. ACM Transactions on Software Engineering and Methodology, 9(4), Oct. 2000. \n[16] M. Wand, G. Kiczales, and C. Dutchyn. A semantics for advice and dynamic join points in aspect-oriented \nprogramming. In G. T. Leavens and R. Cytron, editors, Foundations of Aspect-Oriented Languages Workshop, \npages 17 25, Apr. 2002. Iowa State University University technical report 02-06. [17] A. K. Wright and \nM. Felleisen. A syntactic approach to type soundness. Information and Computation, 115(1):38 94, 1994. \nAPPENDIX A. Core Language Summary Types t ::= bool |t1 .t2 |(t1,...,tn)(n=0) | t label |t pc |advice \n|t pat Base calculus l . Labels e ::= x |true |false |if e1 then e2 else e3 | .x : t. e |e1 e2 | (e1,...,en)(n=0) \n|let(tx:tt) = e1 in e2 Aspects | l |{e1.x .e2} |e1(e2)|return e1 to e2 | new x : t. e |e1 >> e2 |e1 \n<< e2 Label sets |{e1,...,en}|e1 .e2 |e1 ne2 Stack patterns | e1; e2 |e1 | e2 |e * |e1 &#38; e2 |\u00ace |val \n: t | match[t](e) then e1 else e2 | store x : t = e1 in e2 B. MinAML Summary Types t ::= bool |t1 .t2 \n|[mi:ti]1..n Expressions e ::= x |b |if e1 then e2 else e3 | e.m |e1.m ..x.e2 | let ds in e |e1 e2 Declarations \nds ::= \u00b7 | (bool x = e) ds | (fun f(x : t1): t2 = e) ds = .xi.ei]1..n | (object x : t =[mi ) ds | monitor \nt.m ds | ad ds Program Points p ::= f |x.m |t.m Point Cuts pc ::= {p1,...,pn} Point Cut Designators pcd \n::= withinf(x) |pcd1 &#38; pcd2 |pcd1 | pcd2 |\u00acpcd |cflow(pcd) |cflowtop(pcd) Aspects ad ::= before \npc(x) when pcd = e | after pc(x) when pcd = e | around pc(x) when pcd = e | around pc(x) when pcd = e1; \nproceed y .e2 C. AspectML Libraries We have implemented a simple functional aspect-oriented programming \nlanguage called AspectML (AML) as an ex\u00adtension of core SML/NJ. A simple rewriter translates AML .les \ninto well-typed SML/NJ source that can be compiled and linked to the libraries with the signatures below. \nsignature POINT = sig type point val new : string list -> point val toStrings : point -> string list \nval unique : point -> int val equals : point * point -> bool end signature RE = sig type re (* functions \nto create base REs *) val primitive : Point.point -> re val empty : unit -> re (* functions to create \ncomplex REs *) valopt:re ->re (*0 or1of re*) valplus :re -> re (* 1ormoreofre*) valstar :re -> re (* \n0ormoreofre*) val concat : re -> re -> re (* concatenation *) val alt : re -> re -> re (* alternation \n*) (* attempts to match the RE to the point stack *) val match : re -> Point.point list -> bool end signature \nASPECT = sig type aspect type stack val toList : stack -> Point.point list (* create a new aspect *) \nval aspect : (stack -> bool) -> (stack * UniversalDT.all -> UniversalDT.all) -> aspect (* functions \nto add initial and final aspects *) val << : aspect -> unit val >> : aspect -> unit (* mark a control-flow \npoint *) val mark : Point.point -> (unit -> UniversalDT.all) -> UniversalDT.all (* return a value from \nan aspect to a label *) val return : UniversalDT.all * Point.point -> a end  \n\t\t\t", "proc_id": "944705", "abstract": "This paper define the semantics of MinAML, an idealized aspect-oriented programming language, by giving a type-directed translation from its user-friendly external language to its compact, well-defined core language. We argue that our framework is an effective way to give semantics to aspect-oriented programming languages in general because the translation eliminates shallow syntactic differences between related constructs and permits definition of a clean, easy-to-understand, and easy-to-reason-about core language.The core language extends the simply-typed lambda calculus with two central new abstractions: explicitly labeled program points and first-class advice. The labels serve both to trigger advice and to mark continuations that the advice may return to. These constructs are defined orthogonally to the other features of the language and we show that our abstractions can be used in both functional and object-oriented contexts. The labels are well-scoped and the language as a whole is well-typed. Consequently, programmers can use lexical scoping in the standard way to prevent aspects from interfering with local program invariants.", "authors": [{"name": "David Walker", "author_profile_id": "81100426485", "affiliation": "Princeton University, Princeton, NJ", "person_id": "PP18001632", "email_address": "", "orcid_id": ""}, {"name": "Steve Zdancewic", "author_profile_id": "81384616728", "affiliation": "University of Pennsylvania", "person_id": "PP14144604", "email_address": "", "orcid_id": ""}, {"name": "Jay Ligatti", "author_profile_id": "81100429229", "affiliation": "Princeton University, Princeton, NJ", "person_id": "PP33026131", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944718", "year": "2003", "article_id": "944718", "conference": "ICFP", "title": "A theory of aspects", "url": "http://dl.acm.org/citation.cfm?id=944718"}