{"article_publication_date": "08-25-2003", "fulltext": "\n Invited Talk Understanding Aspects (Extended Abstract) Mitchell Wand* College of Computer and Information \nScience Northeastern University Boston, MA 02115, USA wand@ccs.neu.edu 1 Background Since the mid-90 \ns, Kiczales and others have identi.ed new lim\u00aditations of traditional layered architectures for complex \nsystems. The most serious of these new limitations is the problem of scatter\u00ading. A typical large system \nrequires many services, such as logging, locking, authentication, etc. While the functionality to implement \na particular service may be located in a single module, the code to invoke the service is typically scattered \nacross many modules. Kiczales s solution was to use a special-purpose language to give a declarative \nspeci.cation of where or when each service should be invoked. A service typically takes the form of a \nclass called an as\u00adpect, possibly containing several methods. The potential points at which a method \nof an aspect can be invoked are called join points, and each method of the aspect is associated with \na point cut, which is the set of join points at which it should act. Kiczales called this aspect-oriented \nprogramming (AOP). This idea has attracted widespread attention in the software-engineering community. \nDifferent aspect-oriented programming languages use different join-point models and different ways to \ninvoke services. Join points may be temporal entities or spatial ones. A typical join point in As\u00adpectJ \n[4] is a temporal event: the execution of a method call along with an abstraction of the call stack at \nthat call. The invocation of a service takes the form of advice [2] on the execution of the method call. \nIn Hyper/J [7], the join points are spatial: they are class def\u00adinitions and method de.nitions within \nthose classes, and actions typically take the form of merging methods from different modules into a single \ncomposite class. The dif.culty with existing AOP languages is that they defeat mod\u00adular reasoning as \nwe know it. Modular reasoning usually means that we can reason about a module independent of the context \nin * Work supported by the National Science Foundation under grant number CCR-0097740. which it is installed, \nand that we can deduce the behavior of a com\u00adposite module from the behavior of its components. Typical \nAOP languages, most notably AspectJ, violate both of these principles. Wand et al [9] and Jagadeesan \net al [3] have given examples of pro\u00adgram fragments that are contextually equivalent in ordinary con\u00adtexts, \nbut that may be distinguished by aspect-oriented contexts. Among the contextual equivalences that fail \nare most of the trans\u00adformations associated with refactoring, such as moving a method from one class \nto another. 2 Reconceptualizing AOP To the extent that modular reasoning forms the conceptual founda\u00adtion \nfor good software engineering principles, the failure of mod\u00adular reasoning in current AOP systems is \ncause for concern. Our goal in this talk is to discuss a reconceptualization of AOP that we hope will \nallow an eventual reconciliation between AOP and mod\u00adular reasoning. A number of researchers [3, 8, 9] \nhave provided semantics for ad\u00advice; our goal is to abstract away from the mechanism of advice to consider \naspect-orientation in general, along the lines of Masuhara and Kiczales [6]. Our reconceptualization \ntakes the form of three theses: Scattering is inevitable. A speci.cation, such as pop(push(x,s)) = s \nspeci.es a conspiracy between the implementation of push and the implementation of pop. These two procedures \nmust conspire to produce the speci.ed behavior. When the conspir\u00adators are in the same module, as they \nare in a typical ADT, this leads to locality of knowledge: if we wish to change the repre\u00adsentation of \nstacks, we need only change the implementations of push and pop. But in the kinds of applications for \nwhich AOP is useful, the speci.cation involves conspirators in different modules. We may wish to specify, \nfor example, a policy for when an au\u00adthentication service should be invoked. Such a policy spec\u00adi.cation \nnecessarily involves entities both from the underly\u00ading application and from the invoked service.1 If \nwe wish to change the policy speci.cation or the representation of some 1We have phrased this asymmetrically, \nin terms of the under- Copyright is held by the author/owner(s). lying application or base program, \nbut the analysis would be un- ICFP 03, August 25 29, 2003, Uppsala, Sweden. ACM 1-58113-756-7/03/0008 \nchanged if the system consisted entirely of communicating aspects. entity mentioned in the policy, we \nwill most likely need to change the implementations of all the actors in the conspir\u00adacy, which may be \nscattered across many modules. How, then, do we restore some notion of modularity? Aspects are modular \nunits of speci.cation. Modularity can be restored by thinking not about programs, but about speci.ca\u00adtions. \nEach aspect of a complex system, be it authentication, logging, or display, is probably speci.ed separately, \nusing its own names and its own logic or speci.cation language. The great innovation of AOP is the introduction \nof declarative pol\u00adicy languages (in AspectJ, the language of point-cut descrip\u00adtors) for specifying \nthe interaction of the aspects. The idea of aspects as units of speci.cation was more evident in early \nAOP languages like COOL and RIDL [5]. They used special-purpose declarative languages for the speci.cation \nof particular aspects. Current AOP languages instead use full\u00ad.edged programming languages as surrogates \nfor the speci.\u00adcation of the individual aspects, using declarative policy lan\u00adguages only to specify \nthe way in which the aspects should interact. A join-point model is a joint ontology. In a modular speci.ca\u00adtion, \neach module or aspect is likely to de.ne its own entities; these entities constitute an ontology for \nthat module. A pol\u00adicy speci.cation, by its very nature, constrains the behavior of named entities in \na number of different modules. For this to be sensible, these modules must agree on the meanings of these \nnames. There must be a joint ontology on which all the participants in the policy must agree. The participants \nmust agree on what entity each name refers to in the real world, and on how that entity is represented; \notherwise, they cannot communicate. For example, a client that expects services to be provided by procedure \ncalls cannot directly communicate with a server that provides services by method calls, because the client \nand server do not have a shared ontology. Of course, each participant may bring additional knowledge \nabout these entities. The joint ontology refers to that part of the participants knowledge that is held \nin common. The join points are distinguished entities in that joint ontology. For example, in AspectJ, \nthe entities in the joint ontology are events like the execution of a method call; the ontology deter\u00admines \nwhat data is associated with each such event (typically, the signature of the method, the values of the \nparameters, and similar data for each method call on the stack). The aspects and the base program share \nthis common model of the opera\u00adtion of the underlying machine. In Hyper/J, the joint ontology represents \na repository containing code. The join point enti\u00adties in its ontology are class de.nitions and method \nde.nitions within those classes. Other AOP languages can be analyzed similarly.  3 Implications In the \ntalk, we will consider the implications of this reconceptual\u00adization of AOP. We will see how existing \nAOP languages .t this model, and how other widely-used systems, not usually considered in this way, draw \ntheir power from aspect orientation. This perspective suggests some research directions. Here some ex\u00adamples: \nDomain-and application-speci.c ontologies Existing aspect languages like AspectJ and Hyper/J are, by \ndesign, general\u00adpurpose languages, and therefore have general-purpose joint-point models. These ontologies \nmay be either too coarse or too .ne for a particular application. Can we develop languages and tools \nthat will let a system designer design an ontology and join-point model that is appropriate to a speci.c \napplication or domain? UML and OCL [1, 10] provide an approximation to this kind of facility; can we \ndo better? Domain-and application-speci.c aspect languages In the talk, we will show an example of an \nextremely widely-used aspect\u00adoriented language, and see how its power comes from being domain-speci.c. \nCan we work with domain experts to pro\u00advide other, better examples? What kinds of tools can we build \nto help develop and support such languages? Ontology-respecting equivalence When we say equivalent in \nall contexts , we do not usually really mean all contexts. We usu\u00adally mean something like all type-respecting \ncontexts. Can we develop a similar notion of equivalence in all ontology\u00adrespecting contexts? Can such \na notion be used to restore a notion of modular reasoning for aspects that respect ontolo\u00adgies? 4 References \n[1] M. Fowler and K. Scott. UML Distilled: Applying the Stan\u00addard Object Modeling Language. Addison-Wesley, \nNew York, 1997. [2] R. P. Gabriel, J. L. White, and D. G. Bobrow. CLOS: Integrat\u00ading object-oriented \nand functional programming. Communi\u00adcations of the ACM, 34(9):28 38, Sept. 1991. [3] R. Jagadeesan, A. \nJeffrey, and J. Riely. A calculus of untyped aspect-oriented programs. In Proceedings European Confer\u00adence \non Object-Oriented Programming, 2003. To appear. [4] G. Kiczales, E. Hilsdale, J. Hugunin, M. Kersen, \nJ. Palm, and W. G. Griswold. An overview of AspectJ. In Proceed\u00adings European Conference on Object-Oriented \nProgramming, volume 2072 of Lecture Notes in Computer Science, pages 327 353, Berlin, Heidelberg, and \nNew York, 2001. Springer-Verlag. [5] C. V. Lopes and G. Kiczales. D: A language framework for distributed \nprogramming. Technical Report SPL97-010, Xe\u00adrox PARC, Palo Alto, CA, USA, February 1997. [6] H. Masuhara \nand G. Kiczales. Crosscutting in aspect\u00adoriented mechanisms. In Proceedings European Conference on Object-Oriented \nProgramming, 2003. To appear. [7] H. Ossher and P. Tarr. Hyper/J: multi-dimensional separation of concerns \nfor Java. In Proceedings of the 22nd International Conference on Software Engineering, June 4-11, 2000, \nLim\u00aderick, Ireland, pages 734 737, 2000. [8] D. Walker, S. Zdancewic, and J. Ligatti. A theory of aspects. \nIn Proc. ACM SIGPLAN International Conference on Func\u00adtional Programming, 2003. This proceedings. [9] \nM. Wand, G. Kiczales, and C. Dutchyn. A semantics for ad\u00advice and dynamic join points in aspect-oriented \nprogramming. TOPLAS, 2003. To appear. [10] J. Warmer and A. Kleppe. OCL: The constraint language of the \nUML. Journal of Object-Oriented Programming, May 1999. \n\t\t\t", "proc_id": "944705", "abstract": "", "authors": [{"name": "Mitchell Wand", "author_profile_id": "81100072594", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP39025873", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944732", "year": "2003", "article_id": "944732", "conference": "ICFP", "title": "Understanding aspects: extended abstract", "url": "http://dl.acm.org/citation.cfm?id=944732"}