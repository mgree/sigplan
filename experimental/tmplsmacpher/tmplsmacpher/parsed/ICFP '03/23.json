{"article_publication_date": "08-25-2003", "fulltext": "\n FreshML: Programming with Binders Made Simple Mark R. Shinwell Andrew M. Pitts Murdoch J. Gabbay Cambridge \nUniversity Computer Laboratory, Cambridge, CB3 0FD, UK {Mark.Shinwell,Andrew.Pitts,Murdoch.Gabbay}@cl.cam.ac.uk \nAbstract FreshML extends ML with elegant and practical constructs for declaring and manipulating syntactical \ndata involving statically scoped binding operations. User-declared FreshML datatypes in\u00advolving binders \nare concrete, in the sense that values of these types can be deconstructed by matching against patterns \nnaming bound variables explicitly. This may have the computational effect of swapping bound names with \nfreshly generated ones; previous work on FreshML used a complicated static type system inferring infor\u00admation \nabout the freshness of names for expressions in order to tame this effect. The main contribution of this \npaper is to show (perhaps surprisingly) that a standard type system without fresh\u00adness inference, coupled \nwith a conventional treatment of fresh name generation, suf.ces for FreshML s crucial correctness property \nthat values of datatypes involving binders are operationally equivalent if and only if they represent \na-equivalent pieces of object-level syntax. This is established via a novel denotational semantics. FreshML \nwithout static freshness inference is no more impure than ML and experience with it shows that it supports \na programming style pleasingly close to informal practice when it comes to dealing with object-level \nsyntax modulo a-equivalence. Categories and Subject Descriptors D.3.1 [Programming Languages]: Formal \nDe.nitions and Theory syntax; D.3.2 [Programming Languages]: Lan\u00adguage Classi.cations applicative (functional) \nlanguages; D.3.3 [Programming Languages]: Language Constructs and Features data types and structures, \npatterns; F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages denotational semantics, \noperational semantics General Terms Languages, Design, Theory Keywords Metaprogramming, variable binding, \nalpha-conversion Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee.  1 Introduction User-declared datatypes and pattern-matching in functional pro\u00adgramming languages \nlike ML and Haskell simplify one of the main tasks for which these languages were intended, namely metapro\u00adgramming \nthe construction and manipulation of syntactical struc\u00adtures. In particular, the declaration of recursive \nfunctions for ma\u00adnipulating the parse trees of object-level languages is made much simpler (and hence \nless error prone) through the use of patterns to match against parts of trees. Unfortunately a pervasive \nproblem spoils this rosy picture: object-level languages often involve bind\u00ading operations. In this case \nmeta-level programs only make sense, or at least only have good properties, when we operate not on parse \ntrees but on their equivalence classes for a relation of a-equivalence identifying trees differing only \nin the names of bound entities. At the moment programmers deal with this case-by-case according to the \nnature of the object-level language being implemented, using a self-imposed discipline. For example, \nthey might work out (not so hard) and then correctly use (much harder) some nameless rep\u00adresentation \nof a-equivalence classes of parse trees in the style of de Bruijn [8]. The tedious and error-prone nature \nof ad hoc solu\u00adtions to this semantically trivial, but pragmatically non-trivial issue of a-equivalence \nis widely acknowledged [27, Sect.13]. We need better automatic support for object-level a-equivalence \nin metapro\u00adgramming languages. FreshML is an ML-like language which provides such support. Its design \nwas introduced by Pitts and Gabbay [25] and subsequently re.ned and implemented by Shinwell [29]. It \nprovides the user with a general-purpose type construction, written (bty)ty, for bind\u00ading names of user-declared \ntype bty in expressions of arbitrary type ty. This can be used in datatype declarations of types representing \nobject-level syntax to specify information about binding in the type. For example, suppose we want to \nrepresent expressions of a small fragment of ML with the following forms: x value identi.er fn x=> e \nfunction abstraction e1 e2 function application let fun fx= e1 in e2 end local recursive function In \nFreshML we can declare a new type name of bindable names for object-level value identi.ers and then declare \na datatype expr for the above ML expressions: bindable type name datatype expr = Vid of name | Fn of \n<name>expr | App of expr * expr | Let of expr *<name>expr  ICFP 03 August 25 29, 2003, Uppsala, Sweden. \n| Letf of <name>((<name>expr )* expr ) Copyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00 In this declaration, \ntypes tell the system which data constructors are binders and how their arguments are bound. For example \nin let fun fx = e1 in e2 end there is a binding occurrence of f whose scope is both e1 and e2; and another \nof x whose scope is just e1. These binding scopes are re.ected by the argument type of Letf in the declaration \nof expr . This declarative speci.cation of binding structure is particularly useful because FreshML endows \ndatatypes like expr with two crucial properties: Abstractness: object-level expressions represented as \nvalues of the datatype are operationally equivalent in FreshML if and only if they are a-equivalent in \nthe object language. Indeed, datatypes like expr are equality types in the ML sense, and meta-level equality \ncorrectly represents object-level a-equivalence. Concreteness: values of such datatypes can be deconstructed \nby matching against patterns which explicitly name bound entities. Indeed, FreshML provides automatic \nlanguage-level support for the common informal idiom which refers to a-equivalence classes via representative \nparse trees, with bound names changed on the .y to make them distinct among themselves and distinct from \nany other names in the current context of use. For example, the following FreshML declaration of a function \nsubst of type expr . name . expr . expr suf.ces for subst e1 xe2 to com\u00adpute (a representation of) the \nML expression obtained by capture\u00adavoiding substitution of the expression represented by e1 for all free \noccurrences of the value identi.er named xin the expression repre\u00adsented by e2. fun subst e x (Vid y \n)= if x =y then e else Vid y | subst e x (Fn (<y >e1)) = Fn (<y >(subste x e1)) | subst e x (App (e1,e2)) \n= App (subste x e1,subste x e2) | subst e x (Let (e1,<y >e2)) = Let (subste x e1,<y >(subste x e2)) | \nsubst e x (Letf (<f >(<y >e1,e2))) = Letf (<f >(<y >(subste x e1),subste x e2)) Note how simple subst \nis! only the .rst clause of the declara\u00adtion is not boiler plate [15]. In particular the clauses dealing \nwith substitution under a binder only have to specify the result when the bound name is suf.ciently fresh. \nSection 2 shows how FreshML ensures only this case arises during evaluation; and subst is a to\u00adtal function \nbecause by Sect. 5 values of type expr represent a\u00adequivalence classes of expressions in the ML fragment. \nThe Abstractness property says FreshML is correct as a language for programming modulo a-equivalence \n, and the Concreteness property says it is expressive. The two properties oppose each other and it is \ntricky to make them co-exist. We were guided to the design in [25] that achieves this by using the FM \nmathematical model of binding in terms of name-swapping [10, 13, 24]. This model has a notion of an object \ns support which specialises to the set of free names when it is an a-equivalence class of parse trees \ninvolv\u00ading binders. We put forward the following informal thesis relating what is sometimes called the \nBarendregt variable convention [3, page 26] to this notion of support. Thesis: when people carry out \nconstructions on a-equivalence classes of parse trees via representative trees using dynamically freshened \nbound names, the end result is well-de.ned, i.e. indepen\u00addent of which fresh bound names are chosen, \nbecause the freshly chosen names do not occur in the support of the .nal result. The type system in [25] \nenforces the condition freshly chosen names do not occur in the support of the .nal result at compile\u00adtime \nby deducing information about a relation of freshness of names for expressions which is a decidable approximation \nto the (in gen\u00aderal undecidable) not-in-the-support-of relation. The result is a pure functional programming \nlanguage; static freshness inference ensures the dynamics of replacing insuf.ciently fresh names on the \n.y is referentially transparent. Purity makes reasoning about program properties simpler and is desirable, \nbut our static fresh\u00adness inference which achieved it had a drawback: since freshness is only an approximation \nof not-in-the-support-of , the type-checker inevitably rejects some algorithms that do in fact conform \nto the above Thesis. Experience showed this happened too often (we dis\u00adcuss why in Sect. 6). The main \ncontribution of this paper is to show, perhaps surpris\u00adingly, that static freshness inference is not \nnecessary for the crucial Abstractness property to hold in the presence of the Concreteness property, \nso long as the operational semantics of [25] is modi.ed to make the declaration of fresh bindable names \ngenerative like some other sorts of names (references, exceptions and type names) are in ML. This fact \nis not at all obvious and requires proof, which we give. Summary Section 2 introduces a new version of \nFreshML with a slightly more effectful dynamics than in [25], but considerably simpler type system. Since \nwe wish to promote it, this new version of the language is simply called FreshML; the older, more compli\u00adcated \ndesign from [25] will be referred to as FreshML 2000.As explained in Sect. 3, the essence of the dynamics \nis the combi\u00adnation of generative names with name-swapping. To prove that the FreshML type system controls \nthe dynamics suf.ciently for object-level a-equivalence to coincide with meta-level operational equivalence \n(the Abstractness property), in Sect. 4 we describe a denotational semantics of FreshML in the FM-sets \nmodel of bind\u00ading [13] that gave rise to the design of FreshML 2000 in the .rst place. The denotational \nsemantics is structured using a monad and makes use of FM-cpos, which seem interesting in their own right. \nSection 5 contains the main technical contributions of the paper: we prove that this denotational semantics \nis computation\u00adally adequate for the operational semantics (the proof uses a suit\u00adable logical relation \nbetween semantics and syntax whose details are omitted in this extended abstract) and then we use this \nresult to establish the Abstractness property (Theorem 5.6). Section 6 dis\u00adcusses the pros and cons of \nusing static freshness inference as orig\u00adinally envisioned in [25] for FreshML 2000. Section 7 describes \nour experiences implementing FreshML. From the programmer s point of view, we claim that FreshML extends \nML with elegant and practical constructs for declaring and manipulating syntacti\u00adcal data involving binding \noperations. We give a few examples: capture-avoiding substitution, a-equivalence, computation of free \nvariables (Fig. 5), and normalisation by evaluation (Fig. 7); more can be found at http://www.freshml.org/. \nFinally, Sect. 8 dis\u00adcusses related work and draws some conclusions about the results presented here \nand their implications for future work.  2 FreshML-Lite This section introduces the new version of FreshML. \nCompared with [25], we do without freshness inference in the type system and use a generative operational \nsemantics for fresh names. To make the presentation more accessible, here we use a cut-down language, \nwhich we call FreshML-Lite, combining the principal novelties of FreshML with a pure functional subset \nof ML. Types t .Ty ::= Values v .Val ::= bindable name name atom a abstraction type (name)t abstraction \n(a)v unit type unit pair (v,v) product type t \u00d7t unit () function type t .t closure [E,x(x)= e] data \ntype d constructed C Cv Patterns pat ::= variable x abstraction <x>x pair (x,x) Declarations dec ::= \nvalue val pat = e fresh atom fresh x recursive function fun x(x)= e sequential dec dec Expressions e \n::= value identi.er x constructor C atom equality test e= e atom swapping swap e,ein e atom abstraction \n<e>e unit () pair (e,e) application ee case split case eof (Cx=> e| \u00b7\u00b7\u00b7) local declaration let dec in \neend Environments Typing contexts States .n.n E .VId -.Val G .VId -.Ty a...n . Top-level datatype declaration \ndatatype bool = true | false and d1 = C of t | \u00b7\u00b7\u00b7 . . . Figure 1. FreshML-Lite syntax and semantic objects \nFreshML-Lite syntax is speci.ed in Fig. 1. For simplicity we as\u00adsume a single, top-level datatype declaration, \nincluding a type bool of booleans and possibly some other mutually recursively de.ned datatypes d1,d2,...There \nis a single type of bindable names, called name, whose values are called atoms1 and which are the elements \nof a .xed, countably in.nite set .. The type (name)t of abstractions has values given by pairs, written \n(a)v and consisting of an atom a . .and a value v of type t. As we see below, FreshML-Lite s semantics \n(both operational and denotational) identi.es abstraction values up to renaming the ()-enclosed atom; \nfor example, (a)a and (a ')a ' turn out to be operationally equivalent values of type (name)name. In \nFreshML-Lite programs, values of type name are introduced via local declarations of fresh atoms, in much \nthe same way that names of references are introduced in ML; values of ab\u00adstraction type are introduced \nwith expressions of the form <e1>e2 and eliminated via a local declaration with an abstraction pattern, \n' let val <x>y= ein eend. FreshML-Lite s type system is quite standard compared with the one given in \n[25] (the latter infers freshness information in addition to conventional ML typing properties). Figure \n2 gives a selection of 1The terminology stems from the denotational model given in Sect. 4. Expressions \nG fe1 : name G fe2 : name (1) G fe1 = e2 : bool G fe1 : name G fe2 : name G fe3 : t (2) G fswap e1,e2 \nin e3 : t G fe1 : name G fe2 : t G f<e1>e2 : (name)t (3) G fe1 : t1 G fe2 : t2 (4) G f(e1,e2) : t1 \u00d7t2 \nG fdec :G' G+G' fe : t (5) G flet dec in eend : t Declarations G fe : (name)t x= y G fval <x >y = e \n: {x .name,y .t} (6) G fe : t1 \u00d7t2 x= y G fval (x ,y )= e : {x .t1,y .t2} (7) G ffresh x : {x. name} \n(8) Values a.. (9) fa : name a..fv : t f(a)v : (name)t (10) fv1 : t1 fv2 : t2 (11) f(v1,v2): t1 \u00d7t2 \nFigure 2. FreshML-Lite typing (excerpt) the typing rules. Comparing rules (3), (6) and (10) with rules \n(4), (7) and (11) respectively, we see that as far as typing properties are concerned, (name)t is like \na product type name \u00d7t (cf. The\u00adorem 3.1). However, the two types have different dynamic proper\u00adties. \nWe have chosen to remain close to the De.nition of Standard ML [18] and specify the dynamics using inductively \nde.ned evalu\u00adation relations of the form ' a,E fe .v,a(21) ' a,E fdec .E',a(22) where the states a and \na' are .nite subsets of .and the value environments E and E' are .nite functions mapping value identi\u00ad.ers \nto values.2 Figure 3 gives a selection of the evaluation rules. Rules (14) and (18) make use of the notation \n' (aa) \u00b7v (23) which stands for the value obtained from v by swapping all occur\u00adrences of the atoms aand \na' in it. 2In contrast to FreshML 2000 where the environment-style operational semantics is necessary \nfor type soundness, it is quite possible to use a substituted-in formulation of FreshML s dynamics, in \nwhich values form a subset of expressions. '' '' a, E fe1 .a,a a, E fe2 .a, a (12) a, E fe1 = e2 .true,a \n'' '' '''' a, E fe1 .a,a a, E fe2 .a,a a = a (13) a, E fe1 = e2 .false,a '' '' '' a, E fe1 .a1,a a, E \nfe2 .a2,a '' ''' a, E fe3 .v, a (14) a, E fswap e1,e2 in e3 .(a1 a2) \u00b7v, a ''' '' '' a, E fe1 .a,a a, \nE fe2 .v, a a, E f<e1>e2 .(a)v, a '' (15) '' '' a, E fe1 .v1,a a, E fe2 .v2,a (16) a, E f(e1,e2) .(v1,v2),a \n'' '' '' a, E fdec .E ' ,a a, E + E ' fe .v, a (17) a, E flet dec in e end .v, a '' '' ''' a, E fe .(a)v,a \na ..-av =(aa ) \u00b7v a, E fval <x1>x2 = e .{x1 .a ' ,x2 .v ' },a ' .{a ' } (18) a, E fe .(v1,v2),a ' a, \nE fval (x1,x2)= e .{x1 .v1,x2 .v2},a ' (19) a ..-a a, E ffresh x .{x .a},a .{a} (20) Figure 3. FreshML-Lite \nevaluation (excerpt) The state may grow during evaluation: if (21) holds, Lemma 2.4 below shows that \na . a ' (and similarly for (22)). The features that cause it to grow are not only declarations of fresh \natoms (see rule (20)), but also value declarations involving abstraction pat\u00adterns: see rule (18). This \nrule lies at the heart of our treatment of binders. It says that when matching an abstraction pattern \n<x>y against an abstraction value (a)v, we associate x not with a,but rather with a new atom a ' not \nin the current state; and then y is as\u00adsociated with (aa ' ) \u00b7v. In fact the valid instances of the evaluation \nrelations (21) and (22) all have the property that a ' contains all the atoms occurring in v (provided \na contains all those occurring in E, which we will always assume to be the case). So the new atom a ' \nin rule (18) does not occur in v and therefore the swapping (aa ' ) \u00b7v is equal to [a:=a ' ] \u00b7v, the \nresult of replacing all occurrences of a in v with a ' . We postpone to Sect. 7 discussing ways of making \nthe implementation of this rule more ef.cient, both by avoiding the generation of fresh atoms where possible \nand by delaying the com\u00adputation of atom swaps (replacements) until needed. FreshML-Lite permits explicit \nname-swapping in expressions with the syntax swap e1,e2 in e3; typing and evaluation rules are (2) and \n(14) in Figs 2 and 3. Name-swapping can express the operation e @ x from [25] of concreting an abstraction \nat a (fresh) atom, using let val <x >y = e in swap x,x in y . Here is a more typical example, using swap-expressions \nto replace the bound names in a number of abstractions with the same name. Example 2.1. If eq : t \u00d7 t \n. bool gives a notion of equality for t -values, then the following function eqa of type (name)t \u00d7(name)t \n.bool correctly computes equality modulo a-conversion for (name)t -values: fun eqa (p)= let val (z,z \n)= p val <x>y = z val <x >y = z in eq (swap x,x in y, y ) end. Compare this with the characterisation \nof a-equivalence via swap\u00adping of [32, Theorem 1]. . Remark 2.2. The full version of FreshML extends \nFreshML-Lite with a number of useful features, as well as including standard fea\u00adtures from ML such as \npolymorphism, references and exceptions. Compound patterns are allowed, in which abstraction patterns \ncan be nested with other forms of pattern. For example, the declaration of eqa from Example 2.1 can be \nsimpli.ed to: fun eqa (<x>y,<x >y )= eq (swap x,x in y, y ). Rather than having just one type name of \nbindable names, users can declare as many distinct such types as they need; they form a subclass of the \nequality types and expressions can be polymorphic in the type of bindable names used.  Abstraction types \n(bty)ty, with bty a declared type of bindable names, are a special case of abstraction types (ety)ty \nwhere ety is an arbitrary equality type. Their values are written ((v1))v2 (so (a)v is a synonym for \n((a))v when a is an atom). The se\u00admantics ensures that these values are indistinguishable up to renaming \nall the free atoms in the value v1 (of equality type ety) occurring in the value v2 (of type ty); this \npermits sim\u00adple representations of binding constructs in which the number of bound names is not .xed, \nsuch as the ML matching con\u00adstructs (which bind all the variables occurring in a pattern), or Scheme \ns general form of let-expression with a list of decla\u00adrations.  If ety and ety ' are equality types, \nthen so is (ety)ety ' and the built-in equality function at that type is the appropriate form of a-equivalence \n(cf. Example 2.1).  We conclude this section by giving some sanity checks on FreshML-Lite s typing and \nevaluation rules. Lemma 2.3. Given value and typing environments E and G, write fE :G to mean that dom(E)= \ndom(G) and that for each x . dom(G), fE(x): G(x) holds. Then if a, E fe .v, a ' , fE :G and G fe : t \nhold, so does fv : t . . Lemma 2.4. Given a state a containing all the atoms occurring in a value environment \nE,if a, E f e . v, a ' holds then a . a ' . Moreover, the pair (v, a ' ) is uniquely determined up to \npermuting ' ''' the atoms in a -a:if a, E f e .v ,a also holds, then there is a bijection p between a \n' -a and a '' -a such that v ' is obtained from v by applying p to the atoms occurring in it. .  3 The \nessence of FreshML is swapping Although in rule (18) of Fig. 3 one can replace swapping (aa ' ) \u00b7v with \nrenaming [a:=a ' ] \u00b7v, because a ' does not occur in v, neverthe\u00adless swapping rather than renaming underlies \nour treatment of fresh bindable names. This is because it is simpler to use a totally de.ned operation \nthat can be applied whether or not a ' occurs in v; but if a ' Types [[ name]] ML = unit ref [[ (name)t]] \nML =[[ name]] ML \u00d7 [[ t]] ML Expressions [[ e1 = e2]] ML =[[ e1]] ML = [[ e2]] ML [[ swap e1,e2 in e3]] \nML = swap [[ e1]] ML [[ e2]] ML [[ e3]] ML [[ <e1>e2]] ML = ([[ e1]] ML,[[ e2]] ML) [[ val <x1>x2 = \ne]] ML = val (x ' 1,x ' 2)= [[ e]] ML; val x1 = ref (); val x2 = swap x1 x1 ' x ' 2 (where x1' ,x2 ' \nare fresh) [[ fresh x]] ML = val x= ref () Values [[ a]] ML = a [[ (a)v]] ML =([ a]] ML,[[ v]] ML) The \nrest of the translation is the identity; for example [[ t1 \u00d7 t2]] ML =[[ t1]] ML \u00d7 [[ t2]] ML [[ (e1,e2)]] \nML = ([[ e1]] ML,[[ e2]] ML) [[ val (x1,x2)= e]] ML = val (x1,x2)= [[ e]] ML [[( v1,v2)]] ML =([ v1]] \nML,[[ v2]] ML) , etc. Figure 4. Translating FreshML-Lite into ML+swap does occur in v, renaming can \nhave bad properties, whereas swap\u00adping is well-behaved. For example if a, a ' and a '' are distinct, \n(a ' )a and (a '' )aare equivalent, but [ a:= a ' ] \u00b7 ( -) sends the .rst to (a ' )a ' and the second \nto the inequivalent value (a '' )a ' . We might repair this familiar problem of capture of free names \nby binders with a theory of capture-avoiding renaming, but a much simpler solution is just to use swapping \n( aa ' ) \u00b7( -) ; its self-inverse nature has excel\u00adlent properties which include preserving a-equivalence. \nIndeed, a growing body of evidence shows that name-swapping, and more generally permutations of names, \nare very useful for describing properties of syntax involving binders: see [5, 6, 11, 24, 32]. As far \nas dynamics are concerned, name-swapping is the only thing FreshML has over ML. To see this, consider \nthe extension of Stan\u00addard ML [18] with a primitive polymorphic function swap of type unit ref .unit \nref .a.afor swapping addresses (the values of type unit ref) in ML values. Then the FreshML-Lite language \nof the previous section can be translated into it as in Fig. 4. Theorem 3.1. The above translation preserves \nand re.ects FreshML-Lite typing and evaluation: G f e : t holds in FreshML-Lite iff [[G ] ML f [[ e]] \nML :[[ t]] ML holds in ML+swap; and a,E f e. v,a ' holds in FreshML-Lite iff a,[[ E]] ML f [[ e]] ML \n. [[ v]] ML,a ' holds in ML+swap. . Since the translation is compositional, this theorem implies it is \ncomputationally adequate : if the translations of two phrases are contextually equivalent in ML+swap, \nthen they are already contex\u00adtually equivalent in FreshML-Lite. (See De.nition 5.3 for a pre\u00adcise de.nition \nof contextual equivalence.) The converse is not true; the translation is far from being fully abstract \n. This is because abstraction values in FreshML-Lite are translated to (atom,value)\u00adpairs in ML+swap \nand the identity of the .rst component can be discovered there in a way that we shall prove in Sect. \n5 is impossible in FreshML-Lite. For example, the results in Sect. 5 show that the following two expressions \nof type ( (name)name) \u00d7 ( (name)name) are contextually equivalent in FreshML-Lite: let fresh x fresh \ny in (<x >x ,<y >y ) end, let fresh x in (<x >x ,<x >x ) end. Under the translation they become the contextually \ninequivalent ex\u00adpressions let val x = ref () val y = ref () in ((x ,x ),(y ,y )) end, let val x = ref \n() in ((x ,x ),(x ,x )) end which are distinguished in ML+swap by the context let val x= [ ] in #1(#1(x)) \n= #1(#2(x)) end (where #1 and #2 are ML notation for .rst and second projection functions). It might \nseem then that we could better mimic (name)t in ML+swap with an abstract type with underlying representation \nname \u00d7 t. However, being abstract, we would lose the Concrete\u00adness property mentioned in the Introduction, \ni.e. the ability to match against patterns involving abstraction, which seems so convenient in practice \n(see also Remark 5.7).  4 Denotational semantics In this section we give meaning to FreshML-Lite types \nand ex\u00adpressions with a denotational semantics in the universe of FM\u00adsets. This permutation model of \nset theory devised by Fraenkel and Mostowski in the 1930s is shown in [13] to provide a syntax\u00adindependent \nmathematical model of fresh bindable names and a\u00adconversion, by expressing those concepts purely in terms \nof swap\u00adping names. This mathematics gave rise to the FreshML 2000 de\u00adsign [25]. We saw in the previous \nsection that the dynamics of FreshML s treatment of bindable names reduces to two things: a dynamically \ngenerated supply of fresh names (provided by the ML type unit ref) and name-swapping (which we had to \nintroduce as a primitive). So it is perhaps not surprising that a mathematical model of freshness and \nname-swapping can provide a denotational semantics of FreshML-Lite that .ts its operational semantics \nwell. The computational adequacy result of Theorem 5.4 shows that it does; from this we deduce results \nabout the correctness of repre\u00adsentation of object-level a-equivalence. What is an FM-set? Ordinary sets \nare members of a cumulative hi\u00aderarchy obtained by starting with nothing (\u00d8) and continuing trans\u00ad.nitely, \nat each stage forming new sets by taking powersets. The universe of FM-sets differs just in that we start \nwith a .xed in.nite collection .of atoms (so-called because they will be members of the universe that \ndo not possess elements themselves), and at each stage take only the set of subsets that possess a .nite \nsupport.By de.nition a set aof atoms is a support for X if for all a,b. .- a, X equals ( ab) \u00b7 X. Here \n( ab) \u00b7 X denotes the set obtained from X by swapping aand bwherever they appear in it (hereditarily). \nIt is the case (though not obviously so: see [13, Proposition 3.4]) that every member X of the universe \nof FM-sets possesses a smallest .nite support, written supp( X) . The only restriction we have when doing \nFM-set theory is that we must remain within the universe of sets with .nite support. The axiomatic development \nof [10] shows that nearly all logical and set\u00adtheoretical constructs have this property. Just axioms \nof choice, the ability to form a set consisting of an arbitrary choice of in.nitely many objects of the \nuniverse, are limited. For example, and this will be relevant below, if xn (for n =0 ,1 ,...) is a countable \nsequence of elements of an FM-set, although each element of the sequence possesses a .nite support, there \nmay be no single .nite set of atoms that is a support for all the xn simultaneously; only if there is \nsuch a .nite set will the function sending each n to xn, i.e. the set of ordered pairs {( n,xn) |n =0 \n,1 ,...}, be .nitely supported and hence an FM-set. FreshML-Lite features .xpoint recursion in both types \nand ex\u00adpressions. It is well-known how to use domain theory to give denotational semantics for this. \nHere we use a domain theory in FM-sets; this gives us access to the FM-set former for atom\u00adabstractions \n[13, Sect. 5] to give meaning to FreshML-Lite s ab\u00adstraction types (name)t. We only need a relatively \nsimple notion of domain, namely .-complete partial orders (cpos), within the FM\u00adsets universe: De.nition \n4.1. An FM-cpo D is an FM-set equipped with a .nitely supported partial order .D.D\u00d7D(often written just \n.) such that any .nitely supported .-chain d0 .d1 .d2 .\u00b7\u00b7\u00b7.D (i.e. one for which there is a single .nite \nset of atoms a with supp( dn) . a for all n) has a least upper bound (lub). We also assume supp( D)= \nsupp( .D)= \u00d8(i.e. Dand .D do not depend on particular atoms). A morphism of FM-cpos f : D .D ' is a function \nD .D ' that preserves ., swapping (i.e. f(( ab) \u00b7d)= ( ab) \u00b7f( d) ), and lubs of .nitely supported .-chains. \n. Such a Dneed not have lubs of arbitrary .-chains. For example the denotation of name .unit turns out \nto be isomorphic to the FM\u00adcpo of subsets of .that are either .nite or whose complement is .nite, partially \nordered by inclusion; if we enumerate the elements of .= {a0,a1,a2,...},3 then the chain \u00d8.{a0}.{a0,a2}.{a0,a2,a4}.\u00b7\u00b7\u00b7is \nnot .nitely supported and moreover does not possess a lub in this FM-cpo. Our semantics is monadic in \nthe sense of Moggi [19]: each type t is assigned an FM-cpo [[ t]] whose elements are used to give meaning \nto FreshML-Lite values, fv : t; whereas (closed) expressions of type t are assigned elements of T[[ t]] \n, where T is a particular dynamic allocation monad on FM-cpos. We de.ne T below, but .rst here is the \nde.nition of [[ t]] as t ranges over FreshML-Lite types. def def [[ unit]] = {1}, [[ name]] = .: Each \nFM-set X determines a discrete FM-cpo taking .as equality on X. The one-element set interprets unit and \nthe set of atoms .interprets name. def [[ dn]] = Dn: For datatypes we use minimal solutions to simul\u00adtaneous \nrecursive domain equations corresponding to the datatype declaration. We can construct them by standard \ntechniques using colimits of embedding-projection pairs (see [1, Sect. 5] for exam\u00adple), which transfer \nsmoothly to FM-cpos; we omit details. def [[ (name)t]] =[ .][[ t]] : For abstraction types we use the \natom\u00adabstraction FM-cpo [ .] D built from an FM-cpo D, much like the atom-abstraction FM-set in [13, \nSect. 5]. This consists of equiva\u00adlence classes for the pre-order (i.e. re.exive-transitive relation) \non .\u00d7D given by: ( a1,d1) .( a2,d2) iff a1 = a2 and d1 .D d2, or a2 ./supp( d1) and ( a1 a2) \u00b7d1 .D d2 \n(cf. Example 2.1). Over\u00adloading the notation, we write [ a] d for the element of [ .] D given by the \nequivalence class of the pair ( a,d) . We can calculate that supp([ a] d)= supp( d) -{a}. def [[ t \u00d7t \n' ]] =[[ t]] \u00d7[[ t ' ]] : For product types we use the prod\u00aduct of FM-cpos, given as for ordinary cpos \nby ordered pairs with componentwise ordering. def [[ t .t ' ]] =[[ t]] .T[[ t ' ]] : The function FM-cpo \nD .D ' of D and D ' consists of all .nitely supported subsets of D\u00d7D ' that 3Any such bijection of the \nset of atoms with the natural numbers is external to the FM-sets universe since it cannot be .nitely \nsupported. are total, monotone functions from D to D ' preserving least upper bounds of .nitely supported \nchains. To interpret function types we combine this construct with the dynamic allocation monad T de\u00adscribed \nbelow. Thus values of type t .t ' , i.e. recursive function closures, are modelled by functions mapping \nvalues (elements of [[ t]] ) to computations of values (elements of T[[ t ' ]] ). T is the analogue for \nthe category of FM-cpos of one of the dy\u00adnamic allocation monads on a presheaf category used by Stark \n[30] to model the Pitts-Stark .-calculus [26]. Each FM-cpo TD can be constructed as the quotient of ( \n..n .\u00d7D) . by a suitable equiva\u00adlence relation; we omit the details here and just note that TDcarries \nthe following structure: A (mono)morphism . : D.TD(the monad unit).  A least element ..TD.  A morphism \n. :[ .] D .D ( restriction ) satisfying for all a,b..and x .TDthat  .[ a]( .[ b] x)= .[ b]( .[ a] x) \n(24) .[ a] x = x if a/.supp( x) . (25) TD is the minimal cpo with these properties, i.e. it has a certain \ncategory-theoretic universal property, which we omit; and we can use that to de.ne the lifting part of \nthe monad structure and verify the usual monad laws. We can present each non-bottom element of TD as \ndef .a.d = .[ a1] \u00b7\u00b7\u00b7.[ an] .( d) (26) where a = {a1,...,an}is a .nite (possibly empty) set of atoms \noccurring in the support of d . D (by property (24), the order in which we list the elements of a on \nthe right-hand side of (26) is immaterial). The element (26) models a convergent FreshML-Lite expression \nwhose evaluation creates some fresh atoms a and returns a value denoted by d. We need a dynamic allocation \nmonad satisfying (24) and (25), rather than a simpler one just pairing up name sets and values, to prove \nTheorem 5.6. We can now construct the denotations of FreshML-Lite values, ex\u00adpressions and declarations: \n if fv : t is derivable, then [[ fv : t]] .[[ t]] if G fe : t is derivable, then [[G fe : t]]:[[G] .T[[ \nt]] if G fdec :G ' is derivable, then [[G fdec :G ' ]] : [ G]] .T[[G ' ]]  where the denotation [[G] \nof a typing environment G is the product of the FM-cpos [[G( x)]] as x ranges over the .nite domain of \nde.\u00adnition of G . De.nition is by induction on judgements; we just give the interesting clauses. Fresh \nname declaration, G ffresh x :G ' : def [[G ffresh x :G ' ]]( .)= .{a}.{x.a}, for some/any a .. (by construction \nof T, the right-hand side is independent of a). Value declaration for abstractions, G fval <x>x ' = e \n:G ' : Let d =[[G fe : (name)t]]( .) . Then, for mas de.ned below, def . if d = . [[G fval <x>x ' = \ne :G ' ]]( .)= m otherwise. def For d = ., we have that d = .a.[ a] d ' and we can de.ne m = ''' ' .( \n{a ' }la) . {x . a ,x . ( aa ) \u00b7d ' }for some/any a ./a.{a}.supp( d ' ) . Swap expression, G fswap e1,e2 \nin e3 : t: Let a1 =[[G fe1 : name]]( .) ,a2 =[[G fe2 : name]]( .) and d=[[G fe3 : t]]( .) . Then . if \na1 = ., { def [[G fswap e1,e2 in e3 : t]]( .)=or a2 = .  ( a1 a2) \u00b7d otherwise. Abstraction expression, \nG f<e1>e2 : (name)t: Given d1 =[[G fe1 : name]]( .) and d2 =[[G fe2 : t]]( .) , then def [[G f<e1>e2 \n: (name)t]]( .)= . if d1 = ., or d2 = . { .( ala ' ) .[ a] d otherwise, where d1 = .a.a, d2 = .a ' \n.dand ana ' = \u00d8. def Atom value: [[ fa : name]] = a. def Abstraction value: [[ f(a)v : (name)t]] =[ a][[ \nfv : t]] . When we refer to some/any atom above, we are really using the freshness quanti.er of [13]: \nwe choose some atom satisfying the N condition, but in fact any such one will do. 5 Correctness In this \nsection we show the denotational semantics of Sect. 4 Thus denotations of values of FreshML-Lite datatypes \nlike lam are in bijection with a-equivalence classes of terms of the object\u00adlanguage they represent. \nTo connect this to operational behaviour of FreshML-Lite programs we have to do two things. First, we \nexam\u00adine the translation of object-level terms into expressions rather than values, since these are what \nthe programmer writes, and second, we relate equality of denotation of expressions to an appropriate \nnotion of operational behaviour (De.nition 5.3). To tackle the .rst issue, still using an object-language \nof .-terms, note that atoms .and value identi.ers VId are both countably in.\u00adnite sets. By enumerating \neach, .x some explicit bijection ai .xi, then translate the .-terms tof Example 5.1 into FreshML-Lite \nex\u00adpressions ( t) e as follows: def ( ai) e = Var xi def ( .ai.t) e = let fresh xi in Lam (<xi>( t) e) \nend def ( t1 t2) e = App (( t1) e,( t2) e). Lemma 5.2. One can show by induction on the structure of \ntthat if its free variables are among {a1,...,an}and if G is the typing context mapping the corresponding \nvalue identi.ers x1,...,xn to matches the operational semantics closely enough that we can prove prove \nthat values of recursively de.ned FreshML-Lite datatypes represent a-equivalence classes of object-level \nsyntax (the Ab\u00adstractness property from the Introduction). For simplicity we take as object-language \nthe familiar untyped .-calculus, but the results easily generalise to other algebraic signatures with \nbinders. We noted in the previous section that the denotation [[ d]] of a declared FreshML-Lite datatype \nd is a recursively de.ned FM-cpo. When d arises from an algebraic signature with binders, it only involves \nproduct-and abstraction-, but not function-types; in this case [[ d]] is a discrete FM-cpo given by an \ninductively-de.ned FM-set. Example 5.1. Given the datatype declaration datatype lam = Var of name | Lam \nof (name)lam | App of lam \u00d7lam then [[ lam ]] is isomorphic to the discrete FM-cpo given by the in\u00adductively \nde.ned FM-set \u00b5X.( .+[ .] X + X \u00d7X) . Previous work [13, Theorem 6.2] shows this to be in bijection with \nthe set .( .) /=a of a-equivalence classes [ t]=a of untyped .-terms t with variables in .: t..( .) ::= \na|.a.t|tt (Swapping is given by ( ab) \u00b7[ t]=a =[( ab) \u00b7t] =a , where ( ab) \u00b7 interchanges all instances \nof aand bin t; the support of [ t]=a is the .nite set of free variables of t.) It is not hard to see \nfrom the typing rules for values in FreshML-Lite that there is a bijection between .-terms t..( .) and \nvalues ( t)v of type lam , given by def ( a) v = Var a def ( .a.t) v = Lam ( (a)( t) v) def ( t1 t2) \nv = App (( t1) v,( t2) v) . One can show by induction on the structure of t that under the ~ isomorphism \n.( .) /=a = [[ lam ]] above, [ t] =a is identi.ed with [[ f( t) v : lam ]] . Therefore for all tand t \n' , t=a t ' iff [[ f( t) v : lam ]]= [ f( t ' ) v : lam ]] (27) . name, then G f( t) e : lam holds and \nfor any . .[[G] = . n [[G f( t) e : lam ]]( .)= .\u00d8.[[ f( .t) v : lam ]] .T[[ lam ]] (28) where .tis the \n.-term obtained by simultaneous capture-avoiding substitution of .( xi) for ai in t(for i=1 ,...,n). \nPROOF. When it comes to the step for .-abstractions in the proof of (28), the garbage collection property \n(25) of the monad T is crucial, combined with the fact that in an atom-abstraction FM-cpo [ .] D, an \nelement of the form [ a] d never contains a in its support. ' , then .t = . We now kno w for all tand \nt ' that ' ' t=a t iff [[ G f( t) e : lam ]] = [ G f( t ) e : lam ]] (29) ' where G is as in Lemma 5.2. \nFor if t =a t a .t for any .; so from (27) we get [[ f( .t)v : lam ]]= [ f( .t ' ) v : lam ]] and therefore \n[[G f( t) e : lam ]]( .)= [ G f( t) e : lam ]]( .) by (28); since this holds for any ., we have the left-to-right \nimplication in (29). Conversely, if [[G f( t) e : lam ]]( .)= [[G f( t) e : lam ]]( .) holds for any \n., from (28) again we get .\u00d8. [[ f( .t) v : lam ]] = .\u00d8. [[ f( .t ' ) v : lam ]] in T[[ lam ]] ;but this \nimplies that [[ f( .t) v : lam ]]= [ f( .t ' ) v : lam ]] in [[ lam ]] (since the unit of the monad T \nis a monomorphism); so by (27) we have .t =a .t ' ; and then we can take . to be .( xi)= ai (i =1 ,...,n), \nfor which .t =a tand .t ' =a t ' , to conclude that t=a t ' . . Turning to the second issue mentioned \nabove, namely relating equality of denotation of expressions to operational behaviour, we give a notion \nof contextual equivalence for FreshML-Lite expres\u00adsions. Roughly speaking, two expressions (of the same \ntype) are contextually equivalent if they are interchangeable in any complete program without changing \nobservable behaviour. We take programs to be closed expressions of type unit, and their observable be\u00adhaviour \nto be whether they evaluate, ignoring any fresh atoms cre\u00adated along the way. The following more precise \nde.nition uses typ\u00ading and evaluation as de.ned in Sect. 2, and the notion of a context C[ ] . As usual, \ncontexts are generated by the grammar in Fig. 1 augmented by a placeholder . C[ e] then denotes the \nresult of replacing  by e. De.nition 5.3. Given G fe : t and G fe ' : t, we write G fe ctx e ' : t and \nsay that e and e ' are contextually equivalent if for all contexts C[ ] with \u00d8fC[ e]: unit and \u00d8fC[ e \n' ]: unit, we have .a( \u00d8,\u00d8f C[ e] . () ,a) if and only if .a ' ( \u00d8,\u00d8fC[ e ' ] . () ,a ' ) . . Theorem \n5.4. (Computational adequacy) Suppose G f e : t, fE :G , and acontains the atoms of E. Let .be given \nby .( x)= [[ fE( x): G( x)]] , for x.dom(G) . (a) If a,E fe . v,a ' , then [[G fe : t]]( .) is equal \nto the non\u00adbottom element .( a ' -a) .[[ fv : t]] of T[[ t]] . (b) Conversely, if [[G fe : t]]( .)= \n., then a,E f e . v,a ' holds for some v and a ' .  PROOF. (a) is proved by induction on the derivation \nof a,E fe . v,a ' . The proof of part (b) is more involved. We use a standard method based on type-indexed \nlogical relations relating domain el\u00adements to FreshML-Lite values and expressions. The construction \nis complicated because, as for ML, FreshML allows function types in recursively de.ned datatypes (see \nFig. 7 in Sect. 6 for an exam\u00adple), precluding a simple inductive technique; instead, we deduce the existence \nof the logical relations using the general theory of minimal invariant relations [23] applied in the \nsetting of FM-cpos (details omitted in this extended abstract). . Parts (a) and (b) together give the \n.rst part of the following corol\u00adlary. The second part can be deduced from the proof of the theorem, \nby exploiting particular properties of the logical relation at equal\u00adity types, which for the simpli.ed \nlanguage given in Sect. 2 we can take to be types not involving use of the function type construct (ei\u00adther \nin themselves, or in the declarations of any datatypes that they involve). Corollary 5.5. Suppose G fe \n: t and G fe ' : t.If [[G fe : t]] = [[G fe : t]] , then G fe ctx e ' : t. The converse holds if t is \nan equality type. . Theorem 5.6. (Correctness of representation) Under the trans\u00adlation of .-terms tinto \nFreshML-Lite expressions ( t)e of type lam given above, a-equivalence of .-terms corresponds to contextual \nequivalence of FreshML-Lite expressions: given two .-terms t and t ' , with free variables among {a1,...,an} \nsay, letting G be the typing context that maps the corresponding value identi.ers x1,...,xn to name, \nwe have t =a t ' iff G f( t) e ctx ( t ' ) e : lam . PROOF. The type lam is an equality type, so we can \ncombine Corollary 5.5 with (29) to get the desired conclusion. . We emphasise that although this correctness \ntheorem is for .-terms, similar results hold for object languages speci.ed by a general no\u00adtion of binding \nsignature (such as the nominal signatures of [32, De.nition 1], or the nominal algebras of [14]) versus \ndatatypes in FreshML-Lite whose declarations are derived from the signature in the simple declarative \nfashion discussed in the Introduction. Remark 5.7. What more could one want from such a representa\u00adtion \nof object languages in a metalanguage? Well, to be useful, the metalanguage should provide rich facilities \nfor writing algorithms to manipulate these representations. FreshML s abstraction patterns are very useful \nin this respect. In particular we can use them to provide an important facility, namely the ability to \nrecognise that a meta-level expression represents some object-level term. For an im\u00adpure functional programming \nlanguage this cannot just be a matter 1 (* remove : name -> name list -> name list *) 2 fun re move x \n[]= [] 3 | remove x (y ::ys )= 4 if x = y then remove x ys 5 else y ::(remove x ys ); 6 (* fv : lam -> \nname list *) 7 fun fv (Var x )=[x ] 8 | fv (Lam (<x >t )) = remove x (fv t ) 9 | fv (App (t1,t2 )) =(fv \nt1 )@(fv t2 ); 10 (* is closed t : lam -> bool *) 11 fun is closed t =((fv t )=[]) Figure 5. Testing \nfor closed .-terms in FreshML of typing and termination; because of side-effects from references and \nexceptions, the full FreshML has terminating closed expres\u00adsions of type lam from Example 5.1 which are \nnot in the image of the translation t . ( t) e of .-terms. However, even the cut-down FreshML-Lite of \nSect. 2 has this property. For example def genvar = let fresh xin (Var x) end (30) evaluates to some \nfresh object-level variable . Once we identify [[ lam ]] with .( .) /=a as in Example 5.1, the denotational \nse\u00admantics of genvar is [[ \u00d8fgenvar : lam ]] = .{a} . ([ a] =a ) . T[[ lam ]] (and [ a] =a is just {a}); \nfrom this and Sect. 5 it follows that genvar is not contextually equivalent to ( t)e for any closed .-term \nt. Nevertheless, we can easily write FreshML-Lite boolean\u00advalued functions to recognise an expression \nas the encoding of some object-level term; for example is closed declared in Fig. 5 (for legibility we \nused syntax for nested patterns and standard list con\u00adstructs). This uses helper functions remove for \nremoving an atom from a list of atoms and fv for computing the free variables of a .\u00adterm (possibly with \nrepeats); and then is closed tests whether that list is empty. For example is closed genvar evaluates \nto false (creating a fresh atom as it does so). Our results can show that for a closed FreshML-Lite expression \ne of type lam, if evaluation of e terminates (i.e. if \u00d8,\u00d8fe . v,a holds for some v and a), then \u00d8fis \nclosed e ctx true : bool if and only if \u00d8fe ctx ( t) e : lam holds for some closed .-term t. 6 Freshness \ninference Recall from Sect. 4 the important FM-sets notion of .nite support (and the notation supp( X) \nfor the smallest set of atoms supporting an FM-set X). In informal reasoning about a-equivalence classes \nby choosing representatives with suf.ciently fresh bound names (c.f. the Barendregt variable convention \n[3, page 26]), it seems that the end result is always well-de.ned, i.e. independent of which fresh bound \nnames are chosen, because the freshly chosen names do not occur in the support of the .nal result (for \nif a,b /. supp( X) , then swapping aand bhas no effect on X, i.e. ( ab) \u00b7X = X). This is the informal \nThesis put forward in the Introduction. (See [11, Sect. 2.3] for some mathematical justi.cation of it.) \nThe de.nition of the denotational semantics at the end of Sect. 4 contains several examples of this phenomenon, \nfor example. FreshML 2000 [25] enforces that freshly chosen names not be in the support of .nal results \nat compile time: the type-checker builds up additional information about a relation of freshness between \nvalue identi.ers and expressions, x # e, which is a sound decidable ap\u00adproximation to the not-in-the-support-of \nrelation a/. supp([[ e]]) in the denotational semantics. (Semantic not-in-the-support-of is undecidable \nfor the usual recursion-theoretic reasons.) This al\u00adlows FreshML 2000 to reject phrases causing observable \nside ef\u00ad 1 (* remove : <name>(name list ) -> name list *) 2 fun re move(<x >[]) = [] 3 | remove (<x >(y \n::ys )) = 4 if x # y then y ::(remove (<x >ys )) 5 else remove (<x >ys ); 6 (* fv : lam -> name list \n*) 7 fun fv (Var x )=[x ] 8 | fv (Lam (<x >t )) = remove (<x >(fv t )) 9 | fv (App (t1,t2 )) =(fv t1 \n)@(fv t2 ); Figure 6. Free variables of .-terms in FreshML 2000 fects when fresh names are allocated \ndynamically. For example, x is most de.nitely not fresh for the expression Var x (correspond\u00ading to the \nfact that a . supp(a)={a}); and FreshML 2000 will not admit genvar declared in (30) as a well-typed expression \nof type lam . In fact FreshML 2000 s static freshness inference allows one to simplify its dynamics by \nnot threading through evaluation a state containing the names generated so far. Not only does a cor\u00adrectness \nresult like Theorem 5.6 hold for FreshML 2000, but it also satis.es no junk properties; for example, \nevery closed terminating expression of type lam in the fragment of FreshML 2000 without references and \nexceptions is of the form (t)e for some closed .\u00adterm t. As we saw in Sect. 5, FreshML-Lite has some \njunk , but at least it is possible to recognise it dynamically (Remark 5.7). So static freshness-checking \ngives a more effect-free functional lan\u00adguage with better programming laws. However our experiences im\u00adplementing \nand using freshness inference indicate that the price is too high, as we shall discuss. As far as implementation \ngoes, unfortunately the freshness infer\u00adence algorithm has to proceed not solely on the structure of \nexpres\u00adsions, but also sometimes on the structure of (inferred) types. This is due to the notion of purity \njudgements which state that values of certain types (such as bool, int,or string, for example) can never \ncontain atoms in their support. We need this to treat many seemingly innocuous uses of freshened bound \nnames. For example to deduce that fn <x >y => y +1 respects the conditions imposed by freshness checking, \nwe must deduce x #y +1. To do that we examine the type of the body of the match, which is int, and with \npurity judgements can observe that a value of type int cannot ever contain any atoms in its support; \nso we deduce x #y +1. More complicated problems of this kind arise in recursive datatype dec\u00adlarations; \nto deduce which kinds4 of atoms may or may not occur in the support of values of the declared datatypes, \nit is necessary to converge on a .xed point as in the procedure for maximising equal\u00adity in ML [18, Sect. \n4.9]. With purity, more programs are typeable, but type-checking gets harder for the user to understand \nand predict. Experience writing syntax-manipulating programs in FreshML 2000 was one of the main motivations \nfor developing a simpler FreshML without freshness inference. We were too frequently forced to adopt \nan obtuse coding style to get programs to pass the freshness checks. For example, the code in Fig. 5 \ndoes not type\u00adcheck in FreshML 2000, because at line 8 the freshness checking algorithm cannot deduce \nthat x #(remove x fv t )holds. In fact when evaluating an application of the fv function by match\u00ading \nagainst the clause at line 6, the .nal result does not depend upon the particular fresh atom associated \nwith the bound name x , because an atom is not in the support of a list of atoms that has had that atom \nremoved. This fact has a simple proof by induction 4Both FreshML 2000 and FreshML permit the declaration \nof different types of bindable names, whose values range over disjoint copies of .. 1 (* syntax *) 2 \ndatatype lam = 3 Var of name 4 | Lam of <name> lam 5 | App of lam *lam ; 6 (* semantics *) 7 datatype \nsem = 8 L of (unit -> sem )-> sem (* function *) 9 | N of neu (* neutral *) 10 and neu = 11 V of name \n(* variable *) 12 | A of neu *sem ; (* neutral appn *) 13 (* reification reify : sem -> lam *) 14 fun \nreify (Lf )= 15 let fresh x :name in 16 Lam (<x >(reify (f (fn () => N (Vx ))))) end 17 | reify (Nn )= \nreifyn n 18 and reifyn (Vx )= Var x 19 | reifyn (A (n,d )) = 20 App (reifyn n, reify d ); 21 (* evals \n: (unit -> sem )list -> lam -> sem *) 22 fun evals [] (Var x )= N (Vx ) 23 | evals ((x,v )::env )(Var \ny )= 24 if x = y then v () 25 else evals env (Var y ) 26 | evals env (Lam (<x >t )) = 27 L (fn v => evals \n((x,v )::env ) t ) 28 | evals env (App (t1,t2 )) = 29 (case evals env t1 of 30 Lf => f (fn () => evals \nenv t2 ) 31 | Nn => N (A (n,evals env t2 ))); 32 (* evaluation eval : lam -> sem *) 33 fun eval t = evals \n[] t ; 34 (* normalisation norm : lam -> lam *) 35 fun norm t = reify (eval t ) Figure 7. Normalisation \nby evaluation in FreshML on the length of the list, but this is not something our freshness\u00adchecking \nalgorithm is able to use at the point it needs to verify the condition x #(remove x fv t ). For this \nparticular example we can circumvent the problem by using a remove function of type (name) (name list). \nname list, as in Fig. 6.5 At line 8 of this .gure the previous problem has gone away because x is always \nfresh for an object of the form <x >e (and also because x is fresh for remove , since the de.nition of \nthat function does not depend upon any atom in particular). FreshML 2000 spots this at compile\u00adtime and \nallows this new version of fv as a well-typed expression of type lam . name list. Figure 7 gives a subtler \nexample of the shortcomings in static fresh\u00adness inference in FreshML 2000, at the same time showing \noff how FreshML can express rather clearly non-trivial syntax-manipulating algorithms; in this case an \nalgorithm computing the normal form of an untyped .-term (if there is one) using normalisation by evalua\u00adtion \nin a form suggested to us by Thierry Coquand [private commu\u00adnication] and adapted for call-by-value by \nOlivier Danvy. (See [2, Sect. 3] and the references there for more on normalisation by eval\u00aduation in \nan untyped setting.) In FreshML the function norm has type lam . lam (and does indeed compute normal \nforms where they exist); in FreshML 2000, norm does not type-check because 5Atom inequality, written \nx # y , is needed in this declaration of remove to signal to the freshness-checker that it can use the \nfact that x is fresh for y when checking the .rst branch of the conditional. datatype a am = In of a \n| Ab of <name>( a am ); (* monad unit *) fun return x = In x ; (* monad lifting op>>= : a am * ( a -> \nb am )-> b am *) infix >>= ; fun ((In x ) >>= f )= fx |((Ab (<n >y )) >>= f )= Ab (<n>(y >>= f )); (* \nforcing at pure types, e.g... *) fun force (In (s :string)) = s | force (Ab (<n >y )) = force y Figure \n8. An abstraction monad the helper function evals does not. Checking fails at the clause in the de.nition \nof evals at lines 26 27, where the system cannot deduce that x # (fn v => evals ((x,v )::env ) t ) holds, \nunder the assumption that x # evals and x # env hold. Indeed the proof of the corresponding property \nof supports in the denota\u00adtional model, though true, is far from immediate. Remark 6.1. We can get around \nthese shortcomings of freshness inference within FreshML 2000 by adopting a monadic program\u00adming style \nthat mimics the use of the dynamic allocation monad T in the denotational semantics of Sect. 4, using \nan abstraction monad, such as the one in Fig. 8. Using this monad to wrap return types in abstractions, \nfreshness inference only needs to use the sim\u00adple fact x # <x>e; plus the fact that abstractions can \nbe discarded at pure types, as in the function force in the .gure. The ef.ciency of this style is questionable, \nand the resulting programs somewhat obfuscated. Nevertheless, it was the realisation that one can adopt \nthis monadic style in FreshML 2000 that led us to the design of the simpler FreshML and its denotational \nsemantics; and using name abstraction to model name generation (such as in Fig. 8) still has its uses \nin FreshML: see [12]. We advocate use of FreshML, which does not enforce the Introduc\u00adtion s Thesis (the \nproperty of freshly chosen names not being in the support of .nal results) at compile-time. However, \nfreshness infer\u00adence may still be useful for other purposes: it could be used in a program logic for \nverifying properties of FreshML programs; and information about freshness deduced at compile-time may \nbe useful for optimising run-time implementation, the issue we turn to next. 7 Implementation The source \ncode of an experimental implementation of the FreshML language (written in Objective Caml) is available \nat the web site http://www.freshml.org/. Our implementation pro\u00advides the Core of Standard ML [18] together \nwith FreshML s dis\u00adtinctive features for programming with binders. There is an interac\u00adtive interpreter, \ntogether with support for processing FreshML code held in individual source .les, but no modules layer. \nIf so desired, FreshML 2000 s freshness inference can be switched on by starting freshml with the command-line \nargument --pure. The web site contains examples of programming with binders in FreshML, in\u00adcluding programs \ncalculating the possible labelled transitions from a p-calculus [17] process, using various forms of \nencoding [12]; and Barthe s classi.cation algorithm for type-checking injective Pure Type Systems [4]. \nWe invite readers to try FreshML for them\u00adselves! We saw in Sect. 3 that the dynamics of FreshML can \nbe imple\u00admented by translating it into ML augmented with a primitive func\u00adtion swap : unit ref .unit \nref .a.afor swapping address Canonical values c ::= atom a abstraction (a)p pair (p,p) unit () closure \n[P,f(x)= e] constructed C Cp Non-canonical values p ::= p c Explicit permutations p ::= identity [] \ncomposite (aa ' ):: p Value environments P ::= [x .p,...] (where a,a ' range over .and x,f over VId) \nFigure 9. Values with delayed swapping names in ML values. It is possible to add this to some existing \nML implementations using unsafe features.6 Since the representa\u00adtion of values in such systems was not \ndesigned with swapping in mind, such simple hacks may not yield very ef.cient implementa\u00adtions of FreshML; \nbut they do enable us to demonstrate FreshML s novel features for computing with binders integrated into \na com\u00adplete ML system. Shinwell [28] reports on such an experiment with Objective Caml and the resulting \nFresh O Caml is available at http://www.freshml.org/. To make atom-swapping more ef.cient, our implementation \nof FreshML uses a representation of FreshML values suggested by Mark Shields [private communication] \nusing delayed swapping.In this scheme, shown in Fig. 9, values phave at each structural level explicit \npermutations of atoms (represented by .nite lists of pairs of atoms, p, standing for the sequential composition, \nreading from left to right, of the corresponding atom swaps). Evaluation pro\u00adduces values in canonical \nform, c, where the outermost constructor is manifest; but value environments P need only associate value \nidenti.ers with values that are not necessarily in canonical form. For example, evaluation rule (14) \nfrom Fig. 3 becomes '' '' a,P fe1 .a1,a a,P fe2 .a2,a '' '''' a,P fe3 .c,a c =cf((a1 a2):: [] c) (31) \n' ''' a,P fswap e1,e2 in e3 .c ,a where p . cf(p) is an auxiliary function converting a non\u00adcanonical \nvalue to canonical form by pushing the outermost explicit permutation through one structural level and \napplying it to any atom it meets. This is relatively inexpensive to implement compared with traversing \nthe whole parse tree swapping its atoms. It seems that in practice most swappings arise from deconstructing \nabstraction values (a)v. In the delayed swapping implementation scheme, the evaluation rule for this \n(cf. rule (18) in Fig. 3) becomes '' ' a,P fe .(a)(p c),a a ..-a p1 =[] a ' p2 =(aa ' ):: p c a,P fval \n<x1>x2 = e .{x1 .p1,x2 .p2},a ' .{a ' } (32) with (aa ' ) appended to p. Another optimisation is to try \nto avoid choosing a fresh atom a ' at all. To make this possible, we can consider garbage collection \nrules that try to reduce the state (set of atoms) by removing atoms not in the support of the results \nof 6Thanks to Claudio Russo for showing how to do this in Moscow ML. evaluation (properties such as Lemma \n2.4 have to be modi.ed if we do this). Then in the above rule it may be the case that a . .- a ' ' ' \nand we can take a = aand replace (aa):: p cwith p c. We have not yet fully exploited such optimisations. \nIn particular the freshness inference discussed in Sect. 6 could be useful for op\u00adtimising the dynamics \nof FreshML. For example, for non-canonical values of pure type, when converting to canonical form we \ncan just discard the outermost permutation rather than pushing it down into the value.  8 Related work \nSheard [27, Sect. 13] gives an excellent survey of the problems for metaprogramming caused by statically \nscoped binders in ob\u00adject terms and some of the solutions that have been proposed. FreshML seems unique \namong metaprogramming languages in pro\u00adviding language-wide support for object-level a-equivalence while \nstill allowing the user to refer to bound entities by name. Miller [16] proposed incorporating elements \nof higher order abstract syntax, HOAS [22], into an ML-like programming language, ML., with intentional \nfunction types ty => ty . HOAS also underlies Raf\u00adfalli s Bindlib Library for O Caml.7 FreshML s underlying \ntheory of binders [13] lifts less to the metalevel: like HOAS it promotes object-level renaming to the \nmetalevel (via the swapping opera\u00adtion), but unlike HOAS it leaves object-level substitution to be de\u00ad.ned \ncase-by-case using structural recursion. The advantage is that FreshML data types are concrete and their \ndenotational semantics in the universe of FM-sets retain the pleasant recursion/induction properties \nof classical .rst-order algebraic data types: see [13, Sect. 6]. Also, while ML. and Bindlib give no \ndirect access to bound names and their distinctions (name equality and inequality), FreshML does. The \nprice paid for this ability is dynamic generation of fresh names. The seemingly small computational effect \n(which in fact has rather subtle interactions with higher order functions: see [26]) has a long history \nin functional programming, from Lisp s gensym to more recent advocates, such as [21, 7]. However, the \ncombination with name-swapping and abstraction types (bty)ty is unique to FreshML. Since the original \ndesign was published in [25], the use of swapping and freshness to deal with a-equivalence and name restriction \nhas been taken up by others, such as in [6]. Indeed, it was reading this work that inspired us to remove \nthe rather restric\u00adtive freshness checking from FreshML 2000 s statics and design the new version of \nFreshML presented here. FreshML 2000 s approach to names and binding has also inspired work on open code \ntypes in homogeneous metaprogramming languages by Nanevski and Pfen\u00adning [20]. FreshML s correctness \nproperties established in Sect. 5 are not ob\u00advious, and we had to work quite hard to establish them. \nWe in\u00adtroduced a new denotational model, FM-cpos, that we think is in\u00adteresting in its own right. Traditional, \nScott-Strachey models of dynamically allocated local names are not suf.ciently abstract to establish \nthese correctness results (roughly speaking, they do not verify the laws (24) and (25)). Therefore, beginning \nwith Oles, Reynolds and Moggi, various people have developed and applied dynamic allocation monads in \ncategories of functors valued in .\u00adcpos: see [9, 31] for example. The detailed proofs of the results \nin Sects 4 and 5 are less complicated than the corresponding ones in the functor category approach both \nconceptually (we are just doing traditional domain theory, but in a slightly different classical set \ntheory) and practically (constructions on FM-cpos, especially function spaces, are much easier to describe \nconcretely than are the 7 http://www.lama.univ-savoie.fr/ sitelama/Membres/pages web/RAFFALLI/bindlib.html \nanalogous constructs in functor categories). We believe that FM\u00adcpos should be investigated as an interesting \nmodel of restriction (in the sense of p-calculus) and spatial locality in general; the work in [5, 11, \n12] already takes steps in this direction. Simplifying FreshML 2000 to produce FreshML as we have de\u00adscribed \nin this paper opens up many interesting possibilities. For one thing, it opens the door to full-scale \nfunctional language im\u00adplementations incorporating our approach to programming with binders, as Shinwell \ns work on Fresh O Caml [28] shows. It has also made it possible to support abstraction types for binding \ndata consisting of more than a single atom (see Remark 2.2). Freshness inference is poorly-understood \nfor such types; the main problem is judging which atoms are in the support of a value as well as which \nare not. FreshML neatly removes the need to solve this problem and allows us to provide this generalised \nform of abstraction. The features we have described here for programming with binders seem really useful. \nPerhaps the school of pure, lazy functional pro\u00adgramming should have them too there should be a FreshHaskell! \nOnce again, the simple form of FreshML presented here holds out hope that this might be possible, since \nit removes the need to get effective static freshness information, which appears to be much harder for \na non-strict language than for a strict one. Of course our design is impure some side-effects of generating \nfresh names are left exposed in FreshML; in FreshHaskell one would presumably encapsulate them using \na monad, mimicking the use of a monad in the denotational semantics of Sect. 4 (cf. the abstraction monad \na am in Fig. 8). The design and implementation of FreshHaskell remains to be investigated. 9 Acknowledgements \nThis research was funded by UK EPSRC grant GR/R07615/01 and by a donation from Microsoft s Cambridge \nResearch Laboratory. We thank Luca Cardelli, Thierry Coquand, Olivier Danvy, Simon Peyton Jones, Claudio \nRusso, Mark Shields, Keith Wansbrough and the anonymous referees for helpful comments and feedback on \nthis work. Peter White contributed much to the implementation work, which bene.tted enormously from use \nof the O Caml compiler of INRIA s projet Cristal. 10 References [1] S. Abramsky and A. Jung. Domain \ntheory. In S. Abramsky, D. M. Gabbay, and T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, \nVolume 3. Semantic Structures, chapter 1. Oxford University Press, 1994. [2] M. S. Ager, D. Biernacki, \nO. Danvy, and J. Midtgaard. From interpreter to compiler and virtual machine: A functional derivation. \nTechnical Report BRICS RS-03-14, BRICS, De\u00adpartment of Computer Science, University of Aarhus, March \n2003. [3] H. P. Barendregt. The Lambda Calculus: Its Syntax and Se\u00admantics. North-Holland, revised edition, \n1984. [4] G. Barthe. Type-checking injective pure type systems. Jour\u00adnal of Functional Programming, 9(6):675 \n698, 1999. [5] L. Caires and L. Cardelli. A spatial logic for concurrency (part II). In CONCUR 2002 \nConcurrency Theory, 13th In\u00adternational Conference, Brno, Czech Republic, August 20-23, 2002. Proceedings, \nvolume 2421 of Lecture Notes in Com\u00adputer Science, pages 209 225. Springer-Verlag, Berlin, 2002. [6] \nL. Cardelli, P. Gardner, and G. Ghelli. Manipulating trees with hidden labels. In Foundations of Software \nScience and Com\u00ad putation Structures, 6th International Conference, FOSSACS 2003, Warsaw, Poland. Proceedings, \nvolume 2620 of Lecture Notes in Computer Science, pages 216 232. Springer-Verlag, Berlin, 2003. [7] K. \nClaessen and D. Sands. Observable sharing for func\u00adtional circuit description. In Advances in Computing \nScience ASIAN 99, 5th Asian Computing Science Conference, volume 1742 of Lecture Notes in Computer Science, \npages 62 73. Springer-Verlag, 1999. [8] N. G. de Bruijn. Lambda calculus notation with nameless dummies, \na tool for automatic formula manipulation, with application to the Church-Rosser theorem. Indag. Math., \n34:381 392, 1972. [9] M. P. Fiore, E. Moggi, and D. Sangiorgi. A fully abstract model for the p-calculus \n(extended abstract). In Eleventh An\u00adnual Symposium on Logic in Computer Science, pages 43 54. IEEE Computer \nSociety Press, Washington, 1996. [10] M. J. Gabbay. A Theory of Inductive De.nitions with a-Equivalence: \nSemantics, Implementation, Programming Lan\u00adguage. PhD thesis, University of Cambridge, 2000. [11] M. \nJ. Gabbay. The p-calculus in FM. Submitted, September 2002. [12] M. J. Gabbay. FM for process calculi \nthat generate fresh names. Submitted, June 2003. [13] M. J. Gabbay and A. M. Pitts. A new approach to \nabstract syntax with variable binding. Formal Aspects of Computing, 13:341 363, 2002. [14] F. Honsell, \nM. Miculan, and I. Scagnetto. An axiomatic ap\u00adproach to metareasoning on nominal algebras in HOAS. In \n28th International Colloquium on Automata, Languages and Programming, ICALP 2001, Crete, Greece, July \n2001. Pro\u00adceedings, volume 2076 of Lecture Notes in Computer Science, pages 963 978. Springer-Verlag, \nHeidelberg, 2001. [15] R. Laemmel and S. L. Peyton Jones. Scrap your boilerplate: A practical approach \nto generic programming. In ACM SIG-PLAN Workshop on Types in Language Design and Implemen\u00adtation (TLDI \n2003), New Orleans, pages 26 37. ACM Press, 2003. [16] D. A. Miller. An extension to ML to handle bound \nvariables in data structures: Preliminary report. In Proceedings of the Logical Frameworks BRA Workshop, \n1990. [17] R. Milner, J. Parrow, and D. Walker. A calculus of mobile pro\u00adcesses (parts I and II). Information \nand Computation, 100:1 77, 1992. [18] R. Milner, M. Tofte, R. Harper, and D. MacQueen. The De.\u00adnition \nof Standard ML (Revised). MIT Press, 1997. [19] E. Moggi. Notions of computation and monads. Information \nand Computation, 93(1):55 92, 1991. [20] A. Nanevski. Meta-programming with names and necessity. In Proceedings \nof the Seventh ACM SIGPLAN International Conference on Functional Programming, ICFP 2002, Pitts\u00ad burgh, \nPennsylvania, pages 206 217. ACM Press, New York, 2002. [21] M. Odersky. A functional theory of local \nnames. In Confer\u00adence Record of the 21st Annual ACM Symposium on Princi\u00adples of Programming Languages, \npages 48 59. ACM Press, 1994. [22] F. Pfenning and C. Elliott. Higher-order abstract syntax. In Proc. \nACM-SIGPLAN Conference on Programming Lan\u00adguage Design and Implementation, pages 199 208. ACM Press, \n1988. [23] A. M. Pitts. Relational properties of domains. Information and Computation, 127:66 90, 1996. \n[24] A. M. Pitts. Nominal logic, a .rst order theory of names and binding. Information and Computation, \nto appear. (A pre\u00adliminary version appeared in the Proceedings of the 4th In\u00adternational Symposium on \nTheoretical Aspects of Computer Software (TACS 2001), LNCS 2215, Springer-Verlag, 2001, pp 219 242.). \n[25] A. M. Pitts and M. J. Gabbay. A metalanguage for program\u00adming with bound names modulo renaming. \nIn Mathemat\u00adics of Program Construction. 5th International Conference, MPC2000, Ponte de Lima, Portugal, \nJuly 2000. Proceedings, volume 1837 of Lecture Notes in Computer Science, pages 230 255. Springer-Verlag, \nHeidelberg, 2000. [26] A. M. Pitts and I. D. B. Stark. Observable properties of higher order functions \nthat dynamically create local names, or: What s new? In Mathematical Foundations of Computer Science, \nProc. 18th Int. Symp., Gda\u00b4nsk, 1993, volume 711 of Lecture Notes in Computer Science, pages 122 141. \nSpringer-Verlag, Berlin, 1993. [27] T. Sheard. Accomplishments and research challenges in meta\u00adprogramming. \nIn Semantics, Applications, and Implementa\u00adtion of Program Generation, Second International Workshop, \nSAIG 2001, Florence, Italy, September 6, 2001, Proceedings., volume 2196 of Lecture Notes in Computer \nScience, pages 2 44. Springer, 2001. [28] M. R. Shinwell. Swapping the atom: Programming with binders \nin Fresh O Caml. Submitted, June 2003. [29] M. R. Shinwell and A. M. Pitts. FreshML User Manual. Cam\u00adbridge \nUniversity Computer Laboratory, November 2002. Available at (http://www.freshml.org/docs/). [30] I. D. \nB. Stark. Categorical models for local names. Lisp and Symbolic Computation, 9(1):77 107, 1996. [31] \nI. D. B. Stark. A fully abstract domain model for the p\u00adcalculus. In 11th Annual Symposium on Logic in \nComputer Science, pages 36 42. IEEE Computer Society Press, Wash\u00adington, 1996. [32] C. Urban, A. M. Pitts, \nand M. J. Gabbay. Nominal uni\u00ad.cation. In Computer Science Logic and 8th Kurt G\u00a8odel Colloquium (CSL \n03 &#38; KGC), Vienna, Austria. Proccedings, Lecture Notes in Computer Science. Springer-Verlag, Berlin, \n2003.  \n\t\t\t", "proc_id": "944705", "abstract": "FreshML extends ML with elegant and practical constructs for declaring and manipulating syntactical data involving statically scoped binding operations. User-declared FreshML datatypes involving binders are concrete, in the sense that values of these types can be deconstructed by matching against patterns naming bound variables explicitly. This may have the computational effect of swapping bound names with freshly generated ones; previous work on FreshML used a complicated static type system inferring information about the 'freshness' of names for expressions in order to tame this effect. The main contribution of this paper is to show (perhaps surprisingly) that a standard type system without freshness inference, coupled with a conventional treatment of fresh name generation, suffices for FreshML's crucial correctness property that values of datatypes involving binders are operationally equivalent if and only if they represent a-equivalent pieces of object-level syntax. This is established via a novel denotational semantics. FreshML without static freshness inference is no more impure than ML and experience with it shows that it supports a programming style pleasingly close to informal practice when it comes to dealing with object-level syntax modulo a-equivalence.", "authors": [{"name": "Mark R. Shinwell", "author_profile_id": "81100441095", "affiliation": "Cambridge University Computer Laboratory, Cambridge, UK", "person_id": "PP24017838", "email_address": "", "orcid_id": ""}, {"name": "Andrew M. Pitts", "author_profile_id": "81100104445", "affiliation": "Cambridge University Computer Laboratory, Cambridge, UK", "person_id": "P18268", "email_address": "", "orcid_id": ""}, {"name": "Murdoch J. Gabbay", "author_profile_id": "81100506670", "affiliation": "Cambridge University Computer Laboratory, Cambridge, UK", "person_id": "PP14176715", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944729", "year": "2003", "article_id": "944729", "conference": "ICFP", "title": "FreshML: programming with binders made simple", "url": "http://dl.acm.org/citation.cfm?id=944729"}