{"article_publication_date": "08-25-2003", "fulltext": "\n MLF Raising ML to the Power of System F Didier Le Botlan and Didier R\u00e9my INRIA-Rocquencourt 78153 Le \nChesnay Cedex, France {Didier.Le_Botlan,Didier.Remy}@inria.fr Abstract We propose a type system MLF \nthat generalizes ML with .rst-class polymorphism as in System F. Expressions may contain second\u00adorder \ntype annotations. Every typable expression admits a principal type, which however depends on type annotations. \nPrincipal types capture all other types that can be obtained by implicit type instan\u00adtiation and they \ncan be inferred. All expressions of ML are well\u00adtyped without any annotations. All expressions of System \nF can be mechanically encoded into MLF by dropping all type abstractions and type applications, and injecting \ntypes of lambda-abstractions into MLF types. Moreover, only parameters of lambda-abstractions that are \nused polymorphically need to remain annotated. Categories and Subject Descriptors: D.3.3 Language Constructs \nand Features. General Terms: Theory, Languages. Keywords: Type Inference, First-Class Polymorphism, Second-Order \nPolymorphism, System F, ML, Type Annotations.  The quest for type inference with .rst-class polymorphic \ntypes Programming languages considerably bene.t from static type\u00adchecking. In practice however, types \nmay sometimes trammel pro\u00adgrammers, for two opposite reasons. On the one hand, type anno\u00adtations may \nquickly become a burden to write; while they usefully serve as documentation for toplevel functions, \nthey also obfuscate the code when every local function must be decorated. On the other hand, since types \nare only approximations, any type system will reject programs that are perfectly well-behaved and that \ncould be accepted by another more expressive one; hence, sharp program\u00admers may be irritated in such \nsituations. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n03, August 25 29, 2003, Uppsala, Sweden. Copyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00 Fortunately, \nsolutions have been proposed to both of these prob\u00adlems. Type inference allows to elide most type annotations, \nwhich relieves the programmer from writing such details and simultane\u00adously lightens programs. In parallel, \nmore expressive type systems have been developed, so that programmers are less often exposed to their \nlimitations. Unfortunately, those two situations are often con.icting. Expres\u00adsive type systems tend \nto require an unbearable amount of type decorations, thus many of them only remained at the status of \nproto\u00adtypes. Indeed, full type inference for System F is undecidable [26]. Conversely, languages with \nsimple type inference are still limited in expressiveness; more sophisticated type inference engines, \nsuch as those with subtyping constraints or higher-order uni.cation have not yet been proved to work \nwell in practice. The ML language [4] appears to be a surprisingly stable point of equilibrium between \nthose two forces: it combines a reasonably powerful yet simple type system and comes with an effective \ntype inference engine. Besides, the ML experience made it clear that expressiveness of the type system \nand a signi.cant amount of type inference are equally important. Despite its success, ML could still \nbe improved: indeed, there are real examples that require .rst-class polymorphic types [25, 20, 7] and, \neven though these may not occur too frequently, ML does not offer any reasonable alternative. (The inconvenience \nis often un\u00adderestimated, since the lack of a full-.edged language to experi\u00adment with .rst-class polymorphism \ninsidiously keeps programmers thinking in terms of ML polymorphism.) A .rst approach is to extend ML \nwith .rst-class second-order poly\u00admorphism [15, 25, 20, 7]. However, the existing solutions are still \nlimited in expressiveness and the amount of necessary type decla\u00adrations keeps .rst-class polymorphism \nuneasy to use. An alternative approach, initiated by Cardelli [2], is to start with an expressive but \nexplicitly typed language, say F. .: , and perform a suf.cient amount of type inference, so that simple \nprograms ideally including all ML programs would not need any type an\u00adnotation at all. This lead to local \ntype inference [24], recently im\u00adproved to colored local type inference [21]. These solutions are quite \nimpressive. In particular, they include subtyping in combina\u00adtion with higher-order polymorphism. However, \nthey fail to type all ML programs. Moreover, they also fail to provide an intuitive and simple speci.cation \nof where type annotations are mandatory. In this work, we follow the .rst approach. At least, by being \nconser\u00advative over ML, we are guaranteed to please programmers who are already quite happy with ML1. \nWe build on some previous work [7], which has been used to add polymorphic methods to OCaml [16]. Here, \nwe retain the same primary goal, that is to type all expressions of System-F, providing explicit annotations \nwhen needed, and to keep all expressions of ML unannotated. In addition, we aim at the elimination of \nall backward coercions from polymorphic types to ML-types. In particular, our goal is not to guess polymorphic \ntypes. Our track Church s style System-F and ML are quite different in nature. In ML, the elimination \nof polymorphism is implicitly performed at every use occurrence of a variable bound with a polymorphic \ntype Va\u00af.t, which can then be given any instance, of the form t[t\u00afja\u00af]. Indeed, a polymorphic type somehow \nrepresents the set of its in\u00adstances. This induces an instance relation between polymorphic types themselves. \nFor example, the (polymorphic) type V(a)a \u00ada is said to be more general than V(a)V(\u00df)(a -\u00df)-(a -\u00df) and \nwe write V(a)a -a .V(a)V(\u00df)(a -\u00df)-(a -\u00df)be\u00adcause all instances of the latter are also instances of the \nformer. Conversely, in Church s style System F, a type V(a)a -a only stands for itself (modulo renaming \nof bound variables) and the elim\u00adination of polymorphism must be performed explicitly by type ap\u00adplication \n(and abstraction) at the source level. A counter-part in System F is that bound type variables may be \ninstantiated by poly\u00admorphic types, allowing for expressive impredicative second-order types. For example, \nan expression of type V(a)a -a can be given type (V(\u00df)\u00df -\u00df)-(V(\u00df)\u00df -\u00df)by an explicit type-application \nto V(\u00df)\u00df -\u00df. Unfortunately, combining implicit instantiation of polymorphic types with second-order types \nraises con.icts almost immediately. For illustration, consider the application of the function hoose, \nde.ned as .(x).(y)iftrue thenx elsey, to the identity function id. In ML, hooseand idhave principal types \nV(a)a -a -a and V(a)a -a, respectively. For conciseness, we shall write ida for a -a and sfor V(a)ida. \nShould hooseidhave .. type s1 equal to V(a)ida -V(a)ida, obtained by keeping the type of iduninstantiated? \nOr, should it have type s2 equal to V(a)(ida -ida), obtained by instantiating the type of idto the monomorphic \ntype ida and generalizing a only at the end? In\u00addeed, both s1 and s2 are correct types for hooseid. However, \nneither one is more general than the other in System F. Indeed, the function autode.ned as .(x : s)xx \ncan be typed with s1,as .. hooseid, but not with s2 ; otherwise autocould be applied, for instance, to \nthe successor function, which would lead to a runtime error. Hence, s1 cannot be safely coerced to s2 \n. Conversely, how\u00adever, there is a retyping function a function whose type erasure .-reduces to the identity \n[19] from type s2 to type s1 , namely, cation has type t -t for any instance t of s. This form of quan\u00ad \n.. ti.cation allows to postpone the decision of whether sshould .. be instantiated as soon as possible \nor kept polymorphic as long as possible. The bound of a in V(a ;s)a -a, which is said to .. be .exible, \ncan be weakened either by instantiating sor by re\u00ad .. placing ;by . Both forms of weakening can be captured \nby an appropriate instance relation .between types. In a binder of the form (a s)the bound s, which is \nsaid to be rigid, cannot be in\u00ad d stantiated any longer. Intuitively, the type V(a s)sstands for the \nSystem-F type s d[sja]. Finally, both hooseidsuand hooseidautoare well-typed, taking int-intor sfor the \ntype of a, respectively. In fact, the type V(a ;s..)a..-a happens to be a principal type for hooseidin \nMLF. This type summarizes in a compact way the part of typechecking hooseidthat depends on the context \nin which it will be used: some typing constraints have been resolved de.nitely asandforgotten;others,suchas \nisanyinstanceof ,arekept * ..unresolved. In short, MLF provides richer types with constraints on the \nbounds of variables so that instantiation of these variables can be delayed until there is a principal \nway of instantiating them. A technical road-map The instantiations between types used above remain to \nbe captured formally within an appropriate relation .. Indeed, the instance re\u00adlation plays a crucial \nrole in type inference, via a typing rule INST stating that any expression a of type s in a context G \nhas also type dd sin the same context whenever s .s. Intuitively, the larger the relation .is, the more \n.exibility is left for inference, and, usually, the harder the inference algorithm is. Unsurprisingly, \nthe smallest reasonable relation .that validates all the instantiations used above leads to undecidable \ntype infer\u00adence, for full type inference in System-F is undecidable. Still, the relation .induces an \ninteresting variant UMLF that has the same expressiveness as MLF but requires no type annotations at \nall. For\u00adtunately, the relation .can be split into a composition of rela\u00adtions where uses of the relation \ncan be inferred as long as all applications of are fully explicit: this sets a clear distinc\u00ad tion between \nexplicit and inferred type information, which is the essence of MLF. Unfortunately, subject reduction \ndoes not hold in MLF for a simple notion of reduction (non local computation of annotations would be \nrequired during reduction). Thus, we introduce an intermediate variant MLF where only place holders for \nare indicated. For ex\u00ad ample, using the symbol *in place of polytypes, .(x : *)xx belongs FFMLandtypesoundnessfollowsforML*FtoML* \n* .. belongs to UMLF). Subject reduction and progress are proved for )xx belongs to MLF(and of course, \n.(x)since .(x : s xx .(g : s2 ).(x : s).(a)g a (x a). Actually, s2 is a principal type for hooseidin \nF.*(System F closed by .-expansion) [19]. .. and, indirectly, for MLF. While the argument of automust \nbe at least as polymorphic as s, .. the argument of the function hooseidneed not be polymorphic: it may \nbe any instance t of sand the type of the return value is .. then t. We could summarize these constraints \nby saying that: FFprimitivessothatMLcanthenbeembeddedintoML*FInfact,weabstractthepresentationofML*FvelopmentsarepursuedinML* \ntype-annotations as an appropriate choice of primitives and disal\u00adlowing annotation place holders in \nsource terms. Thus, although over a collection of by treating auto: V(a s)a -a our practical interest \nis the system MLF, most of the technical de\u00ad V(a ;s.. )a -a hooseid: .. . The type given to hooseidcaptures \nthe intuition that this appli- FFUnsurprisingly, neitherUMLnorML* Conversely, every expression typable \nin MLF admits a principal 1On a practical level, this would also ensure upward compati\u00ad bility of existing \ncode, although translating tools could always be admits principal types. provided. type. Of course, \nprincipal types depend on type annotations in Figure 1. Syntax of Types t :: a Ign t1 ..tn Monotypes \ns :: t I.IV(a ;s)s IV(as)s Polytypes the source term. More precisely, if an expression is not typable \nin MLF, it may sometimes be typable by adding extra type annota\u00ad tions. Moreover, two different type \nannotations may lead to two in\u00adcomparable principal types. As an example, the expression .(x)xx is not \ntypable in MLF, while both expressions .(x : Va.a)xx and .(x : Va.a -a)xx are typable, with incomparable \ntypes. Adding a (polymorphic) type annotation to a typable expression may also lead to a new type that \nis not comparable with the previous one. This property should not be surprising since it is inherent \nto second\u00adorder polymorphism, which we keep explicit remember that we only infer .rst-order polymorphism \nin the presence of second-order types. Still, the gain is the elusion of most type annotations, via the \ninstance relation . The paper is organized as follows. In Section 1, we describe types and instance relations \nand . The syntax and the static and dy\u00adnamic semantics of MLF *are described in Section 2. Section 3 \npresents formal properties, including type soundness for MLF *and type inference for MLF. Section 4 introduces \nexplicit type annota\u00adtions. A comparison with System-F is drawn is Section 5. In Sec\u00adtion 6, we discuss \nexpressiveness, language extensions, and related works. For the sake of readability, uni.cation and type \ninference al\u00adgorithms have been moved to the appendices. Due to lack of space, all proofs are omitted. \n  Monomorphic abstraction of polymorphic types In our proposal, ML-style polymorphism, as in the type \nof hoose or id, can be fully inferred. (We will show that all ML programs remain typable without type \nannotations.) Unsurprisingly, some polymorphic functions cannot be typed without annotations. For instance, \n.(x)xx cannot be typed in MLF. In particular, we do not infer types for function arguments that are used \npolymorphically. Fortunately, such arguments can be annotated with a polymorphic type, as illustrated \nin the de.nition of autogiven above. Once de\u00ad.ned, a polymorphic function can be manipulated by another \nunan\u00adnotated function, as long as the latter does not use polymorphism, which is then retained. This \nis what we qualify monomorphic ab\u00adstraction of polymorphic types . For instance, both idand auto hooseidautoremain \nof type V(as)a -a (the type s .... of autois never instantiated) and neither hoosenor idrequire any type \nannotation. Finally, polymorphic functions can be used by implicit instantiation, much as in ML. To summarize, \na key feature of MLF is that type variables can al\u00adways be implicitly instantiated by polymorphic types. \nThis can be illustrated by the killer-app(lication) (.(x)x id)This ex\u00ad auto. pression is typable in MLF \nas such, that is without any type ap\u00adplication nor any type annotation except, of course, in the def\u00adinition \nof autoitself. In fact, a generalization of this example is the appfunction .(f ).(x)fx, whose MLF principal \ntype is V(a,\u00df)(a -\u00df)-a -\u00df. It is remarkable that whenever a1 a2 is typable in MLF,sois appa1 a2, without \nany type annotation nor any type application. This includes, of course, cases where a1 ex\u00adpects a polymorphic \nvalue as argument, such as in appautoid.We .nd such examples quite important in practice, since they \nmodel it\u00aderators (e.g. app) applied to polymorphic functions (e.g. auto) over structures holding polymorphic \nvalues (e.g. id).  1 Types 1.1 Syntax of types The syntax of types is given in Figure 1. The syntax \nis parameter\u00adized by an enumerable set of type variables a E. and a family of type symbols g EG given \nwith their arity IgI. To avoid degenerated cases, we assume that G contains at least a symbol of arity \ntwo (the in.x arrow -). We write gn if g is of arity n. We also write t\u00affor tuples of types. The polytype \n.corresponds to (Va.a), intuitively. More precisely, it will be made equivalent to V(a ;.)a. We distinguish \nbetween monotypes and polytypes. By default, types refer to the more general form, i.e. to polytypes. \nAs in ML, mono\u00adtypes do not contain quanti.ers. Polytypes generalize ML type schemes. Actually, ML type \nschemes can be seen as polytypes of the form V(a1 ;.)...V(an ;.)t with outer quanti.ers. Inner quanti.ers \nas in System F cannot be written directly inside mono\u00adtypes. However, they can be simulated with types \nof the form V(as)sd, which stands, intuitively, for the polytype sdwhere all occurrences of a would have \nbeen replaced by the polytype s. However, our notation contains additional meaningful sharing in\u00adformation. \nFinally, the general form V(a ;s)sdintuitively stands for the collection of all polytypes sdwhere a is \nan instance of s. Notation. We say that a has a rigid bound in (as)and a .exible bound in (a ;s). A particular \ncase of .exible bound is the unconstrained bound (a ;.), which we abbreviate as (a).For convenience, \nwe write (a 0s)for either (as)or (a ;s). The symbol 0acts as a meta-variable and two occurrences of 0in \nthe same context mean that they all stand for or all stand for ;.To allow independent choices we use \nindices 01 and 02 for unrelated occurrences. Conversion and free variables. Polytypes are considered \nequal modulo a-conversion where V(a0s)sdbinds a in sd, but not in s. The set of free variables of a polytype \ns is written ftv(s)and de.ned inductively as follows: . ftv(a){a}ftv(gn t1 ...tn )ftv(ti )ftv(.)0/ i=1..n \n ftv(sd) if a Ejftv(sd)ftv(V(a 0s)sd) ftv(sd){a}ftv(s)otherwise The capture-avoiding substitution of \na by t in s is written s[tja]. EXAMPLE 1. The syntax of types only allows quanti.ers to be outermost, \nas in ML, or in the bound of other bindings. There\u00adfore, the type Va .(V\u00df .(t[\u00df]-a))-a of System F2 cannot \nbe written directly. (Here, t[\u00df]means a type t in which the vari\u00adable \u00df occurs.) However, it could be \nrepresented by the type V(a)V(\u00dfd V(\u00df)t[\u00df]-a)\u00dfd-a. In fact, all types of Sys\u00adtem F can easily be represented \nas polytypes by recursively bind\u00ading all occurrences of inner polymorphic types to fresh variables beforehand \nan encoding from System F into MLFis given in Sec\u00adtion 5.1. Types may be instantiated implicitly as in \nML along an instance relation . As explained above, we decompose into .In 2We write Va .t for types of \nSystem F, so as to avoid confusion. Section 1.2, we .rst de.ne an equivalence relation between types, \nwhich is the kernel of both and . In Section 1.3, we de.ne the relation that is the inverse of . The \ninstance relation , which contains , is de.ned in Section 1.4. 1.2 Type equivalence The order of quanti.ers \nand some other syntactical notations are not always meaningful. Such syntactic artifacts are captured \nby a notion of type equivalence. Type equivalence and all other relations between types are relative \nto a pre.x that speci.es the bounds of free type variables. DEFINITION 1(PREFIXES). A pre.x Q is a sequence \nof bind\u00adings (a1 01 s1 )...(an 0n sn )where variables a1 ,...an are pair\u00adwise distinct and form the domain \nof Q, which we write dom(Q). The order of bindings in a pre.x is signi.cant: bindings are meant to be \nread from left to right; furthermore, we require that variables aj do not occur free in si whenever i \n:j. Since a1 ,...an are pair\u00adwise distinct, we can unambiguously write (a 0s)EQ to mean that Q is of \nthe form (Q1 ,a 0s,Q2 ). We also write V(Q)s for the type V(a1 01 s1 )...V(an 0n sn )s. (Note that ai \ns can be renamed in the type V(Q)s, but not in the pre.x Q.) DEFINITION 2(EQUIVALENCE). The equivalence \nunder pre.x is a relation on triples composed of a pre.x Q and two types s1 and s2 , written (Q)s1 s2 \n. It is de.ned as the smallest relation that satis.es the rules of Figure 2. We write s1 s2 for (0/)s1 \ns2. Rule EQ-COMM allows the reordering of independent binders; Rule EQ-FREE eliminates unused bound variables. \nRules EQ-CONTEXT-L and EQ-CONTEXT-R tell that is a congruence; Rea\u00adsoning under pre.xes allows to break \nup a polytype V(Q)s and look inside under pre.x Q . For instance, it follows from iter\u00adations of Rule \nEQ-CONTEXT-R that (Q)s sdsuf.ces to show (0/)V(Q)sV(Q)sd . Rule EQ-MONO allows to read the bound of a \nvariable from the pre.x when it is (equivalent to) a monotype. An example of use of EQ-MONO is (Q,at0 \n,Qd)a -a t0 -t0 . Rule EQ-MONO makes no difference between ;and whenever the bound is (equivalent to) \na monotype. The restriction of Rule EQ-MONO to the case where s0 is (equivalent to) a monotype is required \nfor the well-formedness of the conclusion. Moreover, it also disallows (Q,as0 ,Qd)a s0 when t is a variable \na: variables with non trivial bounds must be treated abstractly and cannot be silently ex\u00adpanded. In \nparticular, (Q)V(as0 ,ad s0 )a -adV(as0 ) a -a does not hold. Rule EQ-VAR expands into both V(as)a s \nand V(a ;s) a s. The former captures the intuition that V(as)sdstands for sd[sja], which however, is \nnot always well-formed. The latter may be surprising, since one could expect V(a ;s)as to hold, but not \nthe converse. The inverse part of the equivalence could be removed without changing the set of typable \nterms. However, it is harmless and allows for a more uniform presentation. The equivalence (Q)V(a 0t)s \ns[tja]follows from Rules EQ-MONO, context rules, transitivity, and EQ-FREE, which we further refer to \nas the derived rule EQ-MONO. . The equivalence under (a given) pre.x is a symmetric operation. In other \nwords, it captures reversible transformations. Irreversible transformations are captured by an instance \nrelation . Moreover, we distinguish a subrelation of called abstraction. Inverse of Figure 2. Type equivalence \nunder pre.x All rules are considered symmetrically. EQ-TRANS (Q)s1 s2 EQ-CONTEXT-R EQ-REFL (Q)s2 s3 (Q,a \nos)s1 s2 (Q)s s (Q)s1 s3 (Q)V(a os)s1V(a os)s2 EQ-CONTEXT-L EQ-FREE (Q)s1 s2 a Ejftv(s1 ) (Q)V(a 0s1 \n)sV(a 0s2 )s (Q)V(a 0s)s1 s1 EQ-COMM a1 Ejftv(s2 )a2 Ejftv(s1 ) (Q)V(a1 01 s1 )V(a2 02 s2 )sV(a2 02 s2 \n)V(a1 01 s1 )s EQ-MONO EQ-VAR (a 0s0 )EQ (Q)s0 t0(Q)V(a 0s)a s (Q)t t[t0 ja] Figure 3. The abstraction \nrelation A-TRANS A-EQUIV (Q)s1 Es2 A-CONTEXT-R (Q)s1 s2 (Q)s2 Es3 (Q,a os)s1 Es2 (Q)s1 Es2 (Q)s1 Es3 \n(Q)V(a os)s1 EV(a os)s2 A-HYP A-CONTEXT-L (a1 s1 )EQ (Q)s1 s2 (Q)s1 a1 (Q)V(as1 )s V(as2 )s abstractions \nare sound relations for but made explicit so as to preserve type inference, while inverse of instance \nrelations would, in general, be unsound for .  1.3 The abstraction relation DEFINITION 3. The abstraction \nunder pre.x, is a relation on triples composed of a pre.x Q and two types s1 and s2 , written3 (Q)s1 \ns2 , and de.ned as the smallest relation that satis.es the rules of Figure 3. We write s1 s2 for (0/)s1 \ns2. Rules A-CONTEXT-L and A-CONTEXT-R are context rules; note that Rule A-CONTEXT-L does not allow abstraction \nunder .exible bounds. The interesting rule is A-HYP, which replaces a polytype s1 by a variable a1 , \nprovided a1 is rigidly bound to s1 in Q. Remarkably, rule A-HYP is not reversible. In particular, (as)E \nQ does not imply (Q)a s, unless s is (equivalent to) a monotype. This asymmetry is essential, since uses \nof will be inferred, but uses of will not. Intuitively, the former consists in abstracting the polytype \ns as the name a (after checking that a is declared as an alias for s in Q). The latter consists in revealing \nthe polytype abstracted by the name a. An abstract polytype, i.e. a variable bound to a polytype in Q, \ncan only be manipulated by its name, i.e. abstractly. The polytype must be revealed explicitly (by using \nthe relation ) before it can be further instantiated (along the relation or ). (See also examples 6 and \n7.) 3Read s2 is an abstraction of s1 or s1 is a revelation of s2 under pre.x Q. Figure 4. Type instance \nI-TRANS I-ABSTRACT (Q)s1 rs2 I-CONTEXT-R (Q)s1 Es2 (Q)s2 rs3 (Q,a os)s1 rs2 (Q)s1 rs2 (Q)s1 rs3 (Q)V(a \nos)s1 r V (a os)s2 I-HYP I-CONTEXT-L (a1 ;s1 )EQ (Q)s1 s2 (Q)s1 a1 (Q)V(a ;s1 )s V(a ;s2 )s I-BOT I-RIGID \n(Q). s (Q)V(a ;s1 )s V(a s1 )s EXAMPLE 2. The abstraction (as)V(as)sd sdis deriv\u00adable: on the one hand, \n(as)s a holds by A-HYP, leading to (as)V(as)sd V(aa)sdby A-CONTEXT-L; on the other hand, (as)V(aa)sd \nsdholds by EQ-MONO* . Hence, we conclude by A-EQUIV and A-TRANS. 1.4 The instance relation DEFINITION \n4. The instance under pre.x, is a relation on triples composed of a pre.x Q and two types s1 and s2 , \nwritten4 (Q) s1 s2 . It is de.ned as the smallest relation that satis.es the rules of Figure 4. We write \ns1 s2 for (0/)s1 s2. Rule I-BOT means that .behaves as a least element for the in\u00adstance relation. Rules \nI-CONTEXT-L and I-RIGID mean that .exi\u00adble bounds can be instantiated and changed into rigid bounds. \nCon\u00adversely, instantiation cannot occur under rigid bounds, except when it is an abstraction, as described \nby Rule A-CONTEXT-L. The interesting rule is I-HYP the counter-part of rule A-HYP, which replaces a polytype \ns1 by a variable a1 , provided s1 isa .exible bound of a1 in Q. EXAMPLE 3. The instance relation (a ;s)V(a \n;s)sd sd holds. The derivation follows the one of Example 2 but uses I-HYP and I-CONTEXT-L instead of \nA-HYP and A-CONTEXT-L. More generally, (QQd)V(Qd)ss holds for any Q, Qd, and s, which we refer to as \nRule I-DROP . The relation (Q)V(a1 ;V(a2 0s2 )s1 )s V(a2 0s2 )V(a1 ;s1 ) s holds whenever a2 Ejftv(s), \nwhich we further refer to as the derived rule I-UP. As expected, the equivalence is the kernel of the \ninstance relation: LEMMA 1(EQUIVALENCE). For any pre.xes Q and types s and sd, we have (Q)ssdif and only \nif both (Q)ssdand (Q)sd s hold. The instance relation coincide with equivalence on monotypes, which captures \nthe intuition that monotypes are really monomor\u00adphic . LEMMA 2. For all pre.xes Q and monotypes t and \ntd, we have (Q)ttdif and only if (Q)ttd . 4Read s2 is an instance of s1 or s1 is more general than s2 \n under pre.x Q. The instance relation also coincides with the one of ML on ML\u00adtypes. In particular, V(a\u00af)t0 \nt1 if and only if t1 is of the form t0 [t\u00afja\u00af]. EXAMPLE 4. The instance relation covers an interesting \ncase of type isomorphism [3]. In System F, type Va .td-t is isomorphic5 to td-Va .t whenever a is not \nfree in td.In MLF, the two cor\u00adresponding polytypes are not equivalent but in an instance relation. Precisely, \nV(ad;V(a)t)td-adis more general than V(a)td-t, as shown by the following derivation: V(ad;V(a)t)td-ad \nV(a)V(ad;t)td-ad by I-UP V(a)td-t by EQ-MONO* (However, as opposed to type containment [19], the instance \nrela\u00adtion cannot express any form of contravariance.) 1.5 Operation on pre.xes and uni.cation Rules \nA-CONTEXT-L and I-CONTEXT-L show that two types V(Q)s and V(Qd)s with the same suf.x can be in an instance \nrelation, for any suf.x s. This suggests a notion of inequality be\u00adtween pre.xes alone. However, because \npre.xes are open this relation must be de.ned relatively to a set of variables that lists (a superset \nof) the free type variables of s. In this context, a set of type variables is called an interface and \nis written with letter I. DEFINITION 5(PREFIX INSTANCE). A pre.x Q is an instance of a pre.x Qdunder \nthe interface I, and we write Q IQd, if and only if V(Q)s V(Qd)s holds for all types s whose free variables \nare included in I. We omit I in the notation when it is equal to dom(Q). We de.ne Q and Q IQdsimilarly. \nIQd Pre.xes can be seen as a generalization of the notion of substitu\u00adtions to polytypes. Then, Q captures \nthe usual notion of (a Qd substitution) Q being more general than (a substitution) Qd . DEFINITION 6(UNIFICATION). \nA pre.x Qduni.es monotypes t1 and t2 under Q if and only if QQdand (Q)t1 t2. The uni.cation algorithm, \ncalled unify, is de.ned in Appendix A. THEOREM 1. For any pre.x Q and monotypes t1 and t2 , unify (Q,t1 \n,t2 )returns the smallest pre.x (for the relation .om(Q)) that uni.es t1 and t2 under Q, or fails if \nthere exists no pre.x Qdthat uni.es t1 and t2 under Q. The following lemma shows that .rst-order uni.cation \nlies under MLF uni.cation. LEMMA 3. If (Q)t1 t2 , then there exists a substitution Q (de\u00adpending only \non Q) that uni.es t1 and t2 .  2 The core language As explained in the introduction we formalize the \nlanguage MLF as a restriction to the more permissive language MLF *. We assume given a countable set \nof variables, written with letter x, and a count\u00adable set of constants c EC. Every constant c has an \narity IcI.A constant is either a primitive f or a constructor C. The distinction 5That is, there exists \na function (.,\u00df)-reducible to the identity that transforms one into the other, and conversely. Figure \n5. Expressions of MLF * a :: x Ic I.(x)a Iaa Iletx a ina Terms I(a : *) Oracles c :: f IC Constants z \n:: x Ic Identi.ers between constructors and primitives lies in their dynamic seman\u00adtics: primitives \n(such as +) are reduced when fully applied, while constructors (such as cons) represent data structures, \nand are not reduced. We use letter z to refer to identi.ers, i.e. either variables or constants. (Q)G \nIz : s (Q)G Ia1 a2: t1 LET FUN (Q)G Ia1: s (Q)G,x : t0 Ia : t (Q)G,x : s Ia2: t (Q)G I.(x)a : t0 -t (Q)G \nIletxa1 ina2: t GEN (Q,a 0s)G Ia : sd a Ejftv(G) (Q)G Ia : V(a 0s)sd INST ORACLE (Q)G Ia : s (Q)G Ia \n: s ure 5. Expressions are those of ML extended with oracles.An FExpressionsofML* , written with letter \na, are described in Fig-(Q)ssd (Q)ssd (Q)G Ia : sd (Q)G I(a : *): sd oracle, written (a : *)is simply \na place holder for an implicit type annotation around the expression a. Intuitively, oracles are places \nwhere the type inference algorithm must call an oracle to .ll the hole with a type annotation. Equivalently, \nthe oracles can be a monotype in G. Indeed, the latter must be guessed while the for\u00adreplaced by explicit \ntype annotations before type inference. Ex\u00admer can be inferred from the type of the bound expression. \nThis plicit annotations (a : s), which are described in Section 4, are restriction is essential to enable \ntype inference. Notice that a .\u00adactually syntactic sugar for applications (s)a where (s)are con\u00adbound \nvariable can refer to a polytype abstractly via a type variable stants. Examples in the introduction \nalso use the notation .(x : s)a, a bound to a polytype s in Q. However, this will not allow to take which \ndo not appear in Figure 5, because this is, again, syntac\u00addifferent instances of s while typing the body \nof the abstraction, tic sugar for .(x)letx (x : s)ina. Similarly, .(x : *)a means unless the polytype \nbound s of a is .rst revealed by an oracle. In\u00ad .(x)letx (x : *)ina. deed, the only possible instances \nof a under a pre.x Q that contains the binding (as)are types equivalent to a under Q. However, (Q)as \ndoes not hold. Thus, if x : a is in the typing context not contain oracles. FFThelanguageMListherestrictionofML* \nto expressions that do G, the only way of typing x (modulo equivalence) is (Q)G Ix : a, whereas (Q)G \nIx : s is not derivable. Conversely, (Q)G I(x : *): s 2.1 Static semantics is derivable, since (Q)as. \n * Typing contexts, written with letter G are lists of assertions of the form z : s. We write z : s EG \nto mean that z is bound in G and z : s is its rightmost binding in G. We assume given an initial typing \ncontext G0 mapping constants to closed polytypes. Typing judgments are of the form (Q)G Ia : s. A tiny \ndifference with ML is the presence of the pre.x Q that assigns bounds to type variables appearing free \nin G or s. By comparison, this pre.x is left implicit in ML because all free type variables have the \nsame (implicit) bound ..In MLF, we require that s and all polytypes of G be closed with respect to Q, \nthat is, ftv(G)ftv(s)Cdom(Q). Typing rules. The typing rules of MLF and MLF are described ML as a subset \nof MLF . ML can be embedded into MLF by restricting all bounds in the pre.x Q to be unconstrained. Rules \nGEN and INST are then exactly those of ML. Hence, any closed program typable in ML is also typable in \nMLF. EXAMPLE 5. This .rst example of typing illustrates the use of polytypes in typing derivations: we \nconsider the simple expres\u00adsion Kdde.ned by .(x).(y)y. Following ML, one possible typing derivation is \n(we recall that (a,\u00df)stands for (a ;.,\u00df ;.)): (a,\u00df)x : a,y : \u00df Iy : \u00df FUN (a,\u00df)x : a I.(y)y : \u00df -\u00df FUN \n(a,\u00df)IKd: a -(\u00df -\u00df) in Figure 6. They correspond to the typing rules of ML modulo the GEN IKd: V(a,\u00df)a \n-(\u00df -\u00df) richer types, the richer instance relation, and the explicit binding of free type variables in \njudgments. In addition, Rule ORACLE allows for the revelation of polytypes, that is, the transformation \nof types along the inverse of the abstraction relation. (This rule would has no effect in ML where abstraction \nis the same as equivalence.) For UMLF, it suf.ces to replace Rule ORACLE by U-ORACLE given below or, \nequivalently, combine ORACLE with INST into U-INST. U-ORACLE U-INST (Q)G Ia : s (Q)ssd (Q)G Ia : s (Q)ssd \n(Q)G Ia : sd (Q)G Ia : sd As in ML, there is an important difference between rules FUN and LET: while \ntypechecking their bodies, a let-bound variable can be assigned a polytype, but a .-bound variable can \nonly be assigned There is, however, another typing derivation that infers a more gen\u00ad eral type for Kdin \nMLF(for conciseness we write Q for a,\u00df ;s): .. (Q,.) x : a,y : . Iy : . FUN (Q,.) x : a I.(y)y : . \u00ad. \nGEN (Q) x : a I.(y)y : s (Q)s \u00df INST (Q) .. x : a I.(y)y : \u00df .. FUN (Q) IKd : a \u00ad\u00df GEN IKd : V(Q)a \u00ad\u00df \n Notice that the polytype V(a,\u00df ;s)a -\u00df is more general than .. V(a,\u00df)a -(\u00df -\u00df), which follows from Example \n4. Figure 7. Syntax directed typing rules a for t0 , we obtain: VAR-FUN-VAR-(Q)x : a I-x : a z : s EG \n(QQd)G,x : t0 I-a : s dom(Qd)nG 0/ (Q)as..(3) (Q)sa -a .. --a : V(Qd ORACLE--\u00ad(Q)G Iz : s (Q)G I.(x),a \n;s)t0 -a (Q)x : a I(x : *): s.. (Q)x : a Ix : a VAR- APP\u00ad(Q)x : a I -(x : *)x : a APP-FUN\u00ad(Q)G I-a1: \ns1 (Q)G I-a2: s2 I.(x)(x : *)x : V(as..)a -a (Q)s1 V(Qd)t2 -t1 (Q)s2 V(Qd)t2 The oracle plays a crucial \nrole in (3) the revelation of the type (Q)G I-a1 a2: V(Qd)t1 scheme s..that is the bound of the type \nvariable a used in the type of x. We have (Q)sa, indeed, but the converse relation does LET-ORACLE-not \nhold, so rule INST ..cannot be used here to replace a by its bound (Q)G I-a1: s1 (Q)G I-a : ss.. . -sd \n(Q)G,x : s1 Ia2: s2 (Q)s (Q)G Iletxa1 ina2: s2 (Q)G I(a : *): sd 2.3 Dynamic semantics FThesemanticsofML* \nML. We present it as a small-step reduction semantics. Values and call-by-value evaluation contexts are \ndescribed below. v :: .(x)a  2.2 Syntax directed presentation Ifv1 ...vn n <If I ICv1 ...vn n :ICI \nFAsinML,wecanreplacethetypingrulesofML* is the standard call-by-value semantics of by a set of I(v : \n*) equivalent syntax-directed typing rules, which are given in Figure 7. E :: []IEa IvE I(E : *)IletxE \nina Naively, a sequence of non-syntax-directed typing Rules GEN and The reduction relation -is parameterized \nby a set of d-rules of INST should be placed around any other rule. However, many of the form (d)below: \nthese occurrences can be proved unnecessary by following an ap\u00adpropriate strategy. For instance, in ML, \njudgments are maintained fv1 ...vn -a when If In (d) instantiated as much as possible and are only generalized \non the (.(x)a)v -a[vjx](\u00dfv ) more occurrences of generalization. Instead, we prefer to maintain (v1: \n*) Fleft-handsideofRuleL.InMLET* , this strategy would require letxv ina -a[vjx](\u00dflet ) v2 -(v1 v2: *)(*) \ntyping judgments generalized as much as possible. Then, it suf.ces to allow Rule GEN right after Rule \nFUN and to allow Rule INST The main reduction is the \u00df-reduction that takes two forms Rule right before \nRule APP (see Rules FUN-and APP-). (\u00dfv )and Rule (\u00dflet ). Oracles are maintained during reduction to \nwhich they do not contribute: they are simply pushed out of ap- EXAMPLE 6. As we claimed in the introduction, \na .-bound vari-plications by rule (*). Finally, the reduction is the smallest re\u00ad able that is used polymorphically \nmust be annotated. Let us check lation containing (d), (\u00dfv ), (\u00dflet ), and (*)rules that is closed by \nthat .(x)xx is not typable in MLF by means of contradiction. A E-congruence: syntax-directed type derivation \nof this expression would be of the d E[a]-E[ad]if a -a(CONTEXT ) form:  3 Formal properties VAR-(Q)x \n: t0 Ix : t0 (Q)x : t0 Ix : t0 VAR- FWeverifytypesoundnessforML* (Q)x : t0 I-xx : V(Qd)t1 MLF. FUN-(Q)0/ \nI.(x)xx : V(a ;V(Qd)t1 )t0 -a 3.1 Type soundness (Q)t0 V(Qd)t2 -t1 (2)(Q)t0 V(Qd)t2 (1) and address type \ninference in APP- FTypesoundnessforML* subject reduction, which ensures that typings are preserved by \nre\u00adis shown as usual by a combination of Applying Rule I-DROP to (2) and (1) , we get respectively (QQd) \nt0 t2 -t1 and (QQd)t0 t2 . Then (QQd)t2 -t1 t2 fol\u00adduction, and progress, which ensures that well-typed \nprograms that lows by Lemma 2 and EQ-TRANS. Thus, by Lemma 3, there ex\u00adare not values can be further \nreduced. ists a substitution . such that .(t2 ).(t2 -t1 ), that is, .(t2 ) .(t2 )-.(t1 ), which cannot \nbe the case. To ease the presentation, we introduce a relation Cbetween pro\u00adgrams: we write a Cadif and \nonly if every typing of a, i.e. a triple (Q,G,s)such that (Q)G Ia : s holds, is also a typing of ad. \nA rela- This example shows the limit of type inference, which is actually tion R on programs preserves \ntypings whenever it is a sub-relation the strength of our system! That is, to maintain principal types \nby rejecting examples where type inference would need to guess second-order types. of C. Of course, type \nsoundness cannot hold without some assumptions EXAMPLE 7. Let us recover typability by introducing an \noracle relating the static semantics of constants described by the initial and build a derivation for \n.(x)(x : *)x. Taking (as)for Q and typing context G0 and their dynamic semantics. .. DEFINITION 7(HYPOTHESES). \nWe assume that the following in which FtermsofSystemFcanbetypedinML*FinterestingchoiceofconstantsthatprovidesMLwiththesame \n. Fortunately, there is an (H0) (Arity) Each constant c Edom(G0 )has a closed type G0 (c)of the form \nV(Q)t1 -...t.c. -t and such that the top symbol of V(Q)t is not in {-,.}whenever c is a constructor. \n(H1) (Subject-Reduction) All d-rules preserve typings. we provide type annotations as a collection of \ncoercion primitives, i.e. functions that change the type of expressions without changing their meaning. \nThe following example, which describes a single annotation, should provide intuition for the general \ncase. FexpressivenessasML* while retaining type inference. Precisely, (H2) (Progress) Any expression \na of the form fv1 ...v.f ., such that (Q)G0 Ia : s is in the domain of (d). EXAMPLE 8. Let f be a constant \nof type s equal to V(a s,ad;s)a -adwith the d-reduction fv -(v : *). Then, THEOREM 2(SUBJECT REDUCTION). \nReduction preserves typ-.. .. the expression a de.ned as .(x ings. is well-typed, of type V(a )(fx)x \nbehaves as .(x)xx and s)a -a. To see this, let Q s .. and G stand for (as,ad )and x : a. By Rules INST, \nTHEOREM 3(PROGRESS). Any expression a such that (Q)G0 I (Q)G I.. .. fx : ad; hence by rule GEN, (as VAR, \nand APP ) a : s is a value or can be further reduced. .. By rule G Ifx : V(ad s)adsince adis not free \nin the G. .. we have V(ad s)ad s EQ-VAR, (under any pre.x); be\u00ad .. .. sides, sa \u00ad a under any pre.x that \nbinds a. (as.. )G Ifx : a -a by Rule INST. Thus, we get Combining theorems 2 and 3 ensures that the reduction \nof well\u00ad typed programs either proceeds for ever or ends up with a value. The result follows by .. Rules \nAPP,FUN, and GEN. since MLFis a subset of MLF . Hence MLFis also sound. However, Observe that the static \neffect of f in fx is (i) to enforce the type MLF does not enjoy subject reduction, since reduction may \ncreate FThisholdsforprogramsinML* * but also for programs in MLF, oracles. Notice, however, that oracles \ncan only be introduced by d-rules.  3.2 Type inference A type inference problem is a triple (Q,G,a), \nwhere all free type variables in G are bound in Q. A pair (Qd ,s)is a solution to this problem if QQdand \n(Qd)G Ia : s. A pair (Qd ,sd)is an instance of a pair (Q,s)if QQdand (Qd)ssd . A solution of a type inference \nproblem is principal if all other solutions are instances of the given one. Figure 9 in the Appendix \nB de.nes a type inference algorithm WF for MLF. This algorithm proceeds much as type inference for ML: \nthe algorithm follows the syntax-directed typing rules and reduces type inference to uni.cation under \npre.xes. THEOREM 4(TYPE INFERENCE). The set of solutions of a solv\u00adable type inference problem admits \na principal solution. Given any type inference problem, the algorithm WFeither returns a principal solution \nor fails if no solution exists.  4 Type annotations In this section, we restrict our attention to MLF, \ni.e. to expressions that do not contain oracles. Since expressions of MLF are exactly those of ML, its \nexpressiveness may only come from richer types and typing rules. However, the following lemma shows that \nthis is not suf.cient: LEMMA 4. If the judgment (Q)G Ia : s holds in MLF where the typing context G contains \nonly ML types and Q contains only type variables with unconstrained bounds, then there exists a derivation \nof G Ia : V(a\u00af)t in ML where V(a\u00af)t is obtained from s by moving all inner quanti.ers ahead. The inverse \ninclusion has already been stated in Section 2.1. In the particular case where the initial typing context \nG0 contains only ML types, a closed expression can be typed in MLFunder G0 if and only of x to be abstracted \nby a variable a bound to sin Q and (ii) to .. give fx, that is x, the type s, exactly as the oracle (x \n: *)would. .. Notice that the bound of a in s is rigid: the function f expects a value v that must have \ntype s..(and not a strict instance of s..). Conversely, the bound of adis .exible: the type of fv is \ns.. but may also be any instance of s. .. DEFINITION 8. We call annotations the denumerable collection \nof primitives (:(Q)s), of arity 1, de.ned for all pre.xes Q and polytypes s closed under Q. The initial \ntyping environment G0 con\u00adtains these primitives with their associated type: (:(Q)s): V(Q)V(as)V(\u00df ;s)a \n-\u00df EG0 We may identify annotation primitives up to the equivalence of their types. Besides, we write \n(a : :(Q)s)for the application (:(Q)s)a.We also abbreviate (:(Q)s)as (s)when all bounds in Q are uncon\u00adstrained. \nActually, replacing an annotation (:(Q)s)by (s)pre\u00adserves typability and, more precisely, preserves typings. \nWhile annotations are introduced as primitives for simplicity of pre\u00adsentation, they are obviously meant \nto be applied. Notice that the type of an annotation may be instantiated before the annotation is applied. \nHowever, the annotation keeps exactly the same reveal\u00ading power after instantiation. This is described \nby the following technical lemma (the reader may take 0/ for Q0 at .rst). LEMMA 5. The judgment (Q0 )G \nI(a : :(Q)s): s0 is valid if and only if there exists a type V(Qd)sd 1 such that the judgment (Q0 )G \nI a : V(Qd)sd 1 holds together with the following relations: Q0Q Q0Qd , (Q0 Qd)sd s, and (Q0 )V(Qd)ss0 \n. 1 The pre.x Q of the annotation :(Q)s may be instantiated into Qd . However, Qdguards sd s in (Q0 Qd)sd \ns. In particular, the 11 lemma would not hold with (Q0 )V(Qd)sd V(Qdd)s and (Q0 ) 1 V(Qdd)sd 1 s0. Lemma \n5 has similarities with Rule ANNOT of Poly-ML [7]. COROLLARY 6. The judgment (Q)G I(a : *): s0 holds \nif and only if there exists an annotation (s)such that (Q)G I(a : s): s0 holds. as all annotation primitives \nare in the initial typing context G0. Reduction of annotations. The d-reduction for annotations just \nreplaces explicit type information by oracles. (v : :(Q)s)-(v : *) LEMMA 7(SOUNDNESS OF TYPE ANNOTATIONS). \nAll three hypotheses (H0, arity), (H1, subject-reduction), and (H2, progress) hold when primitives are \nthe set of annotations, alone. FHence,allexpressionstypableinML* are typable in MLF as long written \n[ A]], returns a pair (Q)G of a pre.x and a typing context and is de.ned inductively as follows: [ 0/]] \n()0/ [ A]] [ A,x : t]] (Q)G (Q)G,x : [ t]] [ A]] (Q)G a jEdom(Q) [ A,a]] (Q,a)G The translation of System \nF terms into MLF terms forgets type abstraction and type applications, and translates types in term\u00adabstractions. \nboth statically and dynamically. Hence annotations primitives are [ .(a)M]][[M]][ Mt]][[M]][ x]] FinML: \n*)x* FunnecessaryinML* The annotation (:(Q)s)can be simulated by .(x)(, . [ MMd]][[M]][[Md] [ .(x :t \n)M]].(x : [[t]])[[M]] Syntactic sugar. As mentioned in Section 2, .(x : s)a is syntactic sugar for .(x)x \n(x : s)ina. The derived typing let rule is: FUN. (Q)G,x : s Ia : sd Qd Q (Q)G I.(x : :(Qd)s)a : V(as)V(ad;sd)a \n-ad This rule is actually simpler than the derived annotation rule sug\u00adgested by lemma 5, because instantiation \nis here left to each occur\u00adrence of the annotated program variable x in a. \u00df . The derived reduction \nrule is (.(x : :(Q)s)a)v -letx (v : :(Q)s)ina. Values must then be extended with expressions of the form \n.(x : :(Q)s)a, indeed.  5 Comparison with System-F We have already seen that all ML programs can be \nwritten in MLF without annotations. In Section 5.1, we provide a straightforward compositional translation \nof terms of System-F into MLF. In Sec\u00adtion 5.2, we then identify a subsystem of MLF, called Shallow-MLF \n, whose let-binding free version is exactly the target of the * Finally, we can state the following lemma: \nLEMMA 8. For any closed typing context A (that does not bind the same type variable twice), term M, and \ntype t of system F such that A IM : t, there exists a derivation (Q)G I[ M]]: t such that (Q)G [[A]]and \n[ t]] t. Remarkably, translated terms contain strictly fewer annotations than original terms a property \nthat was not true in Poly-ML. In particular, all type .-abstractions and type applications are dropped \nand only annotations of .-bound variables remain. Moreover, some of these annotations are still super.uous. \n 5.2 Shallow-MLF * Types whose .exible bounds are always .are called F-types (they are the translation \nof types of System F). Types of the form V(a ;s)t, where s is not equivalent to a monotype nor to ., \nhave been introduced to factor out choices during type inference. Such types are indeed used in a derivation \nof letf hooseidin (f auto)(f su). However, they are never used in the encoding of System-F. Are they \nneeded as annotations? encoding of System-F. Let a type be shallow if and only if all its rigid bounds \nare F-types. More generally, pre.xes, typing contexts, and judgments are shal\u00ad 5.1 Encoding System-F \ninto MLF low if and only if they contain only shallow types. A derivation is shallow if all its judgments \nare shallow and Rule ORACLE is onlyThe types, terms, and typing contexts of system F are given below: \napplied to F-types. Notice that the explicit annotation (s)has a t :: a It -t IVa .t Fsshallowtypeifandonlyif \nisanF-type.WecallShallow-ML* FreductionalsoholdsforShallow-ML* M :: x IMM I.(x :t )M I.(a)M IMt the set \nof terms that have shallow derivations. Interestingly, subject A :: 0/ IA,x : t IA,a . FLet-bindingsdonotincreaseexpressivenessinML* \nrigid bindings for arrow types. This ensures that there are no inner always be replaced by .-bindings \nwith oracles or explicit annota\u00adpolytypes left in the result of the translation, which would otherwise \ntions. This is not true for Shallow-MLF The translation of types of System-F into MLF types uses auxiliary \n, since they can be ill-formed. Quanti.ers that are present in the original types are * are not F-types \ncannot be used as annotations. Therefore, we also , since shallow-types that FconsidertherestrictionShallow-FofShallow-ML* \n[ a]]a [ Va .t]]V(a)[[t]] without let-bindings. [ t1 -t2 ]]V(a1 [[t1 ] )V(a2 [[t2 ] )a1 -a2 The encoding \nof System-F into MLF given in Section 5.1 is actu-In order to state the correspondence between typing \njudgments, we ally an encoding into Shallow-F. Conversely, all programs typable must also translate typing \ncontexts. We write A IM : t to mean that into Shallow-F are also typable in System-F. Hence, Shallow-F \nand M has type t in typing context A in System F. The translation of A, System-F have the same expressiveness. \ntranslated to unconstrained bounds. to programs 6 Discussion itly and the interaction of annotations \nwith implicit types remains unclear. Furthermore, to the best of our knowledge, this has not yet 6.1 \nExpressiveness of MLF been formalized. Indeed, type inference is undecidable as soon as universal quanti.ers \nmay appear at rank 3 [14]. By construction, we have the chain of inclusions Shallow-F C Although our \nproposal relies on the let-binding mechanism to in\u00ad FFShallow-MLMLC* * . We may wonder whether these \nlanguages troduce implicit polymorphismand .exible bounds in types to fac\u00adhave strictly increasing power. \nThat is, ignoring annotations and the difference in notation between let-bindings and .-redexes, do torize \nall ways of obtaining type instances, there may still be some connection with intersection types [12], \nwhich we would like to they still form a strict chain of inclusions? We conjecture that this explore. \nOur treatment of annotations as type-revealing primitives is true. also resembles retyping functions \n(functions whose type-erasure .\u00adreduces to the identity) [19]. However, our annotations are explicit \nand contain only certain forms of retyping functions. Type infer\u00ad not be signi.cantly more expressive \nthan System F. In particular, FStill,ML* remains a second-order system and in that sense should ence \nfor System F modulo .-expansion is known to be undecidable we conjecture that the term (.(y)yI ; yK)(.(x)xx)that \nis typable as well [27]. in F. but not in F [9] is not typable in MLF either. Conversely, we do not know \nwhether there exists a term of MLF that is not typable in F. Several people have considered partial type \ninference for System F . [10, 1, 23] and stated undecidability results for some particular vari\u00adants \nthat in all cases amount directly or indirectly to permitting FReducingalllet-bindingsinatermofShallow-ML* \n produces a (and so forcing) inference of the type of at least one variable that malizable. We conjecture \nthat so are all terms of MLF.   6.2 Simple language extensions Because the language is parameterized \nby constants, which can be used either as constructors or primitive operations, the language can import \nforeign functions de.ned via appropriate d-rules. These could include primitive types (such as integers, \nstrings, etc.) and operations over them. Sums and products, as well as prede.ned FterminShallow-F.Hence,termsofShallow-ML* \ndatatypes, can also be treated in this manner, but some extension is required to declare new data-types \nwithin the language itself. The value restriction of polymorphism [28] that allows for safe mu\u00adtable \ndata-structures in ML should carry over to MLF by allowing only rigid bounds that appear in the type \nof expansive expressions to be generalized. However, this solution is likely to be disappointing in MLF, \nas it is in Poly-ML, which uses polymorphism extensively. An interesting relaxation of the value-only \nrestriction has been re\u00adcently proposed [6] and allows to always generalize type variables that never \nappears on the left hand-side of an arrow type; this gave quite satisfactory results in the context of \nPoly-ML and we can ex\u00adpect similar bene.ts for MLF.  6.3 Related works Our work is related to all other \nworks that aim at some form of type inference in the presence of higher-order types.The closest of them \nis unquestionably Poly-ML [7], with which close con\u00adnections have already been made. Poly-ML also subsumes \nprevi\u00adous proposals that encapsulate .rst-class polymorphic values within datatypes [25]. Odersky and \nLaufer s proposal [20] also falls into this category; however, a side mechanism simultaneously allows \na form of toplevel rank-2 quanti.cation, which is not covered by Poly-ML but is, we think, subsumed by \nMLF. Rank-2 polymorphism actually allows for full type inference [13, 11]. However, the algorithm proceeds \nby reduction on source terms and is not very intuitive. Rank-2 polymorphism has also been in\u00adcorporated \nin the Hugs implementation of Haskell [17], but with explicit type annotations. The GHC implementation \nof Haskell has recently been released with second-order polymorphism at arbitrary ranks [8]; however, \ntypes at rank 2 or higher must be given explic\u00ad are strongly nor-can be used in a polymorphic manner, \nwhich we avoid. Second-order uni.cation, although known to be undecidable, has been used to explore the \npractical effectiveness of type inference for System F by Pfenning [22]. Despite our opposite choice, \nthat is not to support second-order uni.cation, there are at least two com\u00adparisons to be made. Firstly, \nPfenning s work does not cover the language ML per se, but only the .-calculus, since let-bindings are \nexpanded prior to type inference. Indeed, ML is not the simply\u00adtyped .-calculus and type inference in \nML cannot, in practice,be reduced to type inference in the simply-typed .-calculus after ex\u00adpansion of \nlet-bindings. Secondly, one proposal seems to require annotations exactly where the other can skip them: \nin [22], markers (but no type) annotations must replace type-abstraction and type\u00adapplication nodes; \nconversely, this information is omitted in MLF, but instead, explicit type information must remain for \n(some) argu\u00adments of .-abstractions. Our proposal is implicitly parameterized by the type instance rela\u00adtion \nand its corresponding uni.cation algorithm. Thus, most of the technical details can be encapsulated within \nthe instance relation. We would like to understand our notion of uni.cation as a particular case of second-order \nuni.cation. One step in this direction would be to consider a modular constraint-based presentation of \nsecond\u00adorder uni.cation such as [5]. Flexible bounds might partly capture, within principal types, what \nconstraint-based algorithms capture as partially unresolved multi-sets of uni.cation constraints. Another \nexample of restricted uni.cation within second-order terms is uni\u00ad.cation under a mixed pre.x [18]. However, \nour notion of pre.x and its role in abstracting polytypes is quite different. Actually, none of the above \nworks did consider subtyping at all. This is a signi.cant difference with proposals based on local type \ninference [2, 24, 21] where subtyping is a prerequisite. The addition of subtyping to our framework remains \nto be explored. Furthermore, beyond its treatment of subtyping, local type infer\u00adence also brings the \nidea that explicit type annotations can be prop\u00adagated up and down the source tree according to .xed \nwell-de.ned rules, which, at least intuitively, could be understood as a prepro\u00adcessing of the source \nterm. Such a mechanism is being used in the GHC Haskell compiler, and could in principle be added on \ntop of MLF as well. Conclusions We have proposed an integration of ML and System F that com\u00adbines the \nconvenience of type inference as present in ML and the expressiveness of second-order polymorphism. Type \ninformation is only required for arguments of functions that are used polymorphi\u00adcally in their bodies. \nThis speci.cation should be intuitive to the user. Besides, it is modular, since annotations depend more \non the behavior of the code than on the context in which the code is placed; in particular, functions \nthat only carry polymorphism without using it can be left unannotated. The obvious potential application \nof our work is to extend ML-like languages with second-order polymorphism while keeping full type inference \nfor a large subset of the language, containing at least all ML programs. Indeed, we implemented a prototype \nof MLF and veri.ed on a variety of examples that few annotations are actually required and always at \npredictable places. However, further investi\u00adgations are still needed regarding the syntactic-value polymorphism \nrestriction and its possible relaxation. Furthermore, on the theoretical side, we wish to better understand \nthe concept of .rst-order uni.cation of second-order terms , and, if possible, to con.ne it to an instance \nof second-order uni.cation. We would also like to give logical meaning to our types and to the abstraction \nand instance relations. 7 References [1] H.-J. Boehm. Partial polymorphic type inference is undecidable. \nIn 26th Annual Symposium on Foundations of Computer Science, pages 339 345. IEEE Computer Society Press, \nOct. 1985. [2] L. Cardelli. An implementation of FSub. Research Report 97, Digital Equipment Corporation \nSystems Research Center, 1993. [3] R. D. Cosmo. Isomorphisms of Types: from lambda-calculus to infor\u00admation \nretrieval and language design. Birkhauser, 1995. [4] L. Damas and R. Milner. Principal type-schemes for \nfunctional pro\u00adgrams. In Proceedings of the Ninth ACM Conference on Principles of Programming Langages, \npages 207 212, 1982. [5] G. Dowek, T. Hardin, C. Kirchner, and F. Pfenning. Higher-order uni.cation via \nexplicit substitutions: the case of higher-order patterns. In M. Maher, editor, Joint international conference \nand symposium on logic programming, pages 259 273, 1996. [6] J. Garrigue. Relaxing the value-restriction. \nPresented at the third Asian workshop on Programmaming Languages and Systems (APLAS), 2002. [7] J. Garrigue \nand D. R\u00e9my. Extending ML with semi-explicit higher-order polymorphism. Journal of Functional Programming, \n155(1/2):134 169, 1999. A preliminary version appeared in TACS 97. [8] The GHC Team. The Glasgow Haskell \nCompiler User s Guide, Ver\u00adsion 5.04, 2002. Chapter Arbitrary-rank polymorphism. [9] P. Giannini and \nS. R. D. Rocca. Characterization of typings in poly\u00admorphic type discipline. In Third annual Symposium \non Logic in Com\u00adputer Science, pages 61 70. IEEE, 1988. [10] J. James William O Toole and D. K. Gifford. \nType reconstruction with .rst-class polymorphic values. In SIGPLAN 89 Conference on Pro\u00adgramming Language \nDesign and Implementation, Portland, Oregon, June 1989. ACM. also in ACM SIGPLAN Notices 24(7), July \n1989. [11] T. Jim. Rank-2 type systems and recursive de.nitions. Technical Re\u00adport MIT/LCS/TM-531, Massachusetts \nInstitute of Technology, Lab\u00adoratory for Computer Science, Nov. 1995. [12] T. Jim. What are principal \ntypings and what are they good for? In ACM, editor, ACM Symposium on Principles of Programming Lan\u00ad guages \n(POPL), St. Petersburg Beach, Florida, pages 42 53, 1996. [13] A. J. Kfoury and J. B. Wells. A direct \nalgorithm for type inference in the rank-2 fragment of the second-order lambda -calculus. In ACM Conference \non LISP and Functional Programming, 1994. [14] A. J. Kfoury and J. B. Wells. Principality and decidable \ntype inference for .nite-rank intersection types. In ACM Symposium on Principles of Programming Languages \n(POPL), pages 161 174. ACM, Jan. 1999. [15] K. L\u00e4ufer and M. Odersky. Polymorphic type inference and \nabstract data types. ACM Transactions on Programming Languages and Sys\u00adtems, 16(5):1411 1430, Sept. 1994. \n[16] X. Leroy, D. Doligez, J. Garrigue, D. R\u00e9my, and J. Vouillon. The Objective Caml system, documentation \nand user s manual -release 3.05. Technical report, INRIA, July 2002. Documentation distributed with the \nObjective Caml system. [17] Mark P Jones, Alastair Reid, the Yale Haskell Group, and the OGI School of \nScience &#38; Engineering at OHSU. An overview of hugs extensions. Available electronically, 1994-2002. \n[18] D. Miller. Uni.cation under a mixed pre.x. Journal of Symbolic Computation, 14:321 358, 1992. [19] \nJ. C. Mitchell. Polymorphic type inference and containment. Infor\u00admation and Computation, 2/3(76):211 \n249, 1988. [20] M. Odersky and K. L\u00e4ufer. Putting type annotations to work. In Pro\u00adceedings of the 23rd \nACM Conference on Principles of Programming Languages, pages 54 67, Jan. 1996. [21] M. Odersky, C. Zenger, \nand M. Zenger. Colored local type inference. ACM SIGPLAN Notices, 36(3):41 53, Mar. 2001. [22] F. Pfenning. \nPartial polymorphic type inference and higher-order uni\u00ad.cation. In Proceedings of the ACM Conference \non Lisp and Func\u00adtional Programming, pages 153 163. ACM Press, July 1988. [23] F. Pfenning. On the undecidability \nof partial polymorphic type recon\u00adstruction. Fundamenta Informaticae, 19(1,2):185 199, 1993. Prelim\u00adinary \nversion available as Technical Report CMU-CS-92-105, School of Computer Science, Carnegie Mellon University, \nJanuary 1992. [24] B. C. Pierce and D. N. Turner. Local type inference. In Proceedings of the 25th ACM \nConference on Principles of Programming Languages, 1998. Full version in ACM Transactions on Programming \nLanguages and Systems (TOPLAS), 22(1), January 2000, pp. 1 44. [25] D. R\u00e9my. Programming objects with \nML-ART: An extension to ML with abstract and record types. In M. Hagiya and J. C. Mitchell, editors, \nTheoretical Aspects of Computer Software, volume 789 of Lecture Notes in Computer Science, pages 321 \n346. Springer-Verlag, April 1994. [26] J. B. Wells. Typability and type checking in the second order \n.\u00adcalculus are equivalent and undecidable. In Ninth annual IEEE Sym\u00adposium on Logic in Computer Science, \npages 176 185, July 1994. [27] J. B. Wells. Type Inference for System F with and without the Eta Rule. \nPhD thesis, Boston University, 1996. [28] A. K. Wright. Simple imperative polymorphism. Lisp and Symbolic \nComputation, 8(4):343 355, 1995.  A Uni.cation algorithm The algorithm unifyis speci.ed in Section \n1.5; it takes a pre.x Q and two types t and tdand returns a pre.x that uni.es t and td under Q (as described \nin Theorem 1) or fails. In fact, the algorithm unifyis recursively de.ned by an auxiliary uni.cation \nalgorithm for polytypes: polyunifytakes a pre.x Q and two type schemes s1 and s2 and returns a pair (Qd \n,sd)such that QQdand (Qd) s1 sdand (Qd)s2 sd . The algorithms unifyand polyunifyare described in Figure \n8. For the sake of comparison with ML, think of the input pre.x Q Figure 8. Uni.cation algorithm ,tddd) \nunify(Q,tdd .rst rewrites all bounds of Q in normal form and proceeds ,tddd): by case analysis on (tdd \nCase (a,a): return Q. Case (g t1 ..tn 1 ,g t1 ..tn 2 ): 12 let Q1 be Q in  let Qi+1 be unify(Qi ,ti \n1 ,t2 i )for 1 .i .n in  return Qn+1. Case (g1 t11 ..t1 p ,g2 t1 ..tq 2 )with g1 g2: fail.  2 Case \n(a,t)or (t,a)when (a 0td)EQ: return unify(Q,t,td). Case (a,t)or (t,a)when (a 0s)EQ and t Ejdom(Q)and \ns EjT let (Qd ,_)be polyunify(Q,s,t)in return (Qd)-(at) Case (a1 ,a2 )when (a1 01 s1 )EQ and (a2 02 s2 \n)EQ and a1 a2 and s1, s2 are not in T . let (Qd ,s3 )be polyunify(Q,s1 ,s2 )in return (Qd)-(a1 01 s3 \n)-(a2 02 s3 )-a1 Aa2. polyunify(Q,s1 ,s2 ) requires s1 , s2 , and all bounds in Q to be in normal form1 \n: Case (.,s)or (s,.): return (Q,s) Case (V(Q1 )t1 ,V(Q2 )t2 )with Q1, Q2, and Q having disjoint domains \n(which usually requires renaming s1 and s2) let Q0 be unify(QQ1 Q2,t1 ,t2 )in  let (Q3 ,Qd)be Q0tdom(Q) \nin  return (Q3 ,V(Qd)t1 )  1Actually, only need to replace types of the form V(a 0s)a by s, which can \nalways be done lazily. given to unifyas a substitution and of the result pre.x Qdas an instance of Q \n(i.e. a substitution of the form Qdd\u00c6Q) that uni.es t and td . First-order uni.cation of polytypes essentially \nfollows the general structure of .rst-order uni.cation of monotypes. The main differences are that (i) \nthe computation of the unifying substitution is replaced by the computation of a unifying pre.x, (ii) \nadditional work must be performed when a variable bound to a strict polytype (i.e. other than .and not \nequivalent to a monotype) is being uni\u00ad.ed: bounds must be further uni.ed (last case of polyunify) and \nthe pre.x updated accordingly. Auxiliary algorithms are used for this purpose. Let a rearrangement of \na pre.x Q be a pre.x equivalent to Q ob\u00adtained by a permutation of bindings of Q. DEFINITION 9. The split \nalgorithm Qta\u00aftakes a pre.x Q and re\u00adturns a pair of pre.xes (Q1 ,Q2 )such that (i) Q1Q2 is a rearrange\u00adment \nof Q, (ii) a\u00afCdom(Q1 ), and (iii) dom(Q1 )is minimal (in other words, Q1 contains only bindings of Q \nuseful for exporting the interface a\u00af, and Q2 contains the rest). DEFINITION 10. The abstraction-check \nalgorithm (Q)s ? sd Figure 9. Algorithm WF The algorithm infer (Q,G,a)is de.ned by cases on expression \na: \u00c6CASE x: return Q,G(x) \u00c6CASE .(x)a: let Q1 (Q,a ;.)with a Ejdom(Q)in  let (Q2 ,s)infer (Q1 ,G,x \n: a,a)in  let \u00df Ejdom(Q2 )and (Q3 ,Q4 )Q2tdom(Q)in return Q3,V(Q4 )V(\u00df ;s)a -\u00df \u00c6CASE ab:  let (Q1 ,sa \n)infer (Q,G,a) in  let (Q2 ,sb )infer (Q1 ,G,b)in  let aa ,ab ,\u00df Ejdom(Q2 )in  let Q3 unify((Q2 ,aa \n;sa ,ab ;sb ,\u00df ;.), aa ,ab -\u00df)in  let (Q4 ,Q5 )Q3tdom(Q) in  return (Q4 ,V(Q5 )\u00df) \u00c6CASE let xa1 in \na2:  let (Q1 ,s1 )infer (Q,G,a1 )in  return infer (Q1 ,(G,x : s1 ),a2 )  takes a pre.x Q and two polytypes \ns and sdsuch that (Q)ssd and checks that (Q)s sdor fails otherwise. DEFINITION 11. The update algorithm \nQ -(a 0s)takes a pre.x Q and a binding (a0s)such that a is in the domain of Q and returns a pre.x (Q0 \n,a 0s,Q1 )such that (i) (Q0 ,a 0dsd ,Q1 )is a rearrange\u00adment of Q and (ii) dom(Q1 )nftv(s)0/. The algorithm \nfails when there is not such decomposition (because of circular dependencies) or when 0dis and (Q)sd \n? s fails. DEFINITION 12. The merge algorithm Q -aAadtakes two vari\u00adables a and adand a pre.x of the \nform (Q0 ,a 0s,Q1 ,ad0dsd ,Q2 ) and returns the pre.x (Q0 ,a 0dds,Q1 ,ad a,Q2 )where 0ddis ;if both 0and \n0dare ;, and 0ddis otherwise. The implementation of algorithms split, update, and merge is straightforward. \nThe algorithm abstraction-check can be reduced to a simple check on the structure of paths, thanks to \nthe assump\u00adtion (Q)ssd. By lack of space, they are all omitted. B Type inference algorithm Figure 9 \nde.nes the type-inference algorithm WF for MLF. The algorithm follows the algorithm W for ML, with only \ntwo differ\u00adences: .rst, the algorithm builds a pre.x Q instead of a substitu\u00adtion; second, all free type \nvariables not in G are quanti.ed at each abstraction or application. Since free variables of G are in \ndom(Q), .nding quanti.ed variables consists in splitting the current pre.x according to dom(Q), as described \nby De.nition 9.  \n\t\t\t", "proc_id": "944705", "abstract": "We propose a type system ML<sup>F</sup> that generalizes ML with first-class polymorphism as in System F. Expressions may contain second-order type annotations. Every typable expression admits a principal type, which however depends on type annotations. Principal types capture all other types that can be obtained by implicit type instantiation and they can be inferred.All expressions of ML are well-typed without any annotations. All expressions of System F can be mechanically encoded into ML<sup>F</sup> by dropping all type abstractions and type applications, and injecting types of lambda-abstractions into ML<sup>F</sup> types. Moreover, only parameters of lambda-abstractions that are used polymorphically need to remain annotated.", "authors": [{"name": "Didier Le Botlan", "author_profile_id": "81319495481", "affiliation": "INRIA-Rocquencourt, Cedex, France", "person_id": "PP18001031", "email_address": "", "orcid_id": ""}, {"name": "Didier R&#233;my", "author_profile_id": "81100311096", "affiliation": "INRIA-Rocquencourt, Cedex, France", "person_id": "PP39037168", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944709", "year": "2003", "article_id": "944709", "conference": "ICFP", "title": "ML<sup>F</sup>: raising ML to the power of system F", "url": "http://dl.acm.org/citation.cfm?id=944709"}