{"article_publication_date": "08-25-2003", "fulltext": "\n Dynamic Rebinding for Marshalling and Update, with Destruct-time. Gavin Bierman Michael Hicks Peter \nSewell Gareth Stoyle Keith Wansbrough University of Cambridge University of Maryland, College Park {First.Last}@cl.cam.ac.uk \nmwh@cs.umd.edu Abstract Most programming languages adopt static binding, but for dis\u00adtributed programming \nan exclusive reliance on static binding is too restrictive: dynamic binding is required in various guises, \nfor exam\u00adple when a marshalled value is received from the network, contain\u00ading identi.ers that must be \nrebound to local resources. Typically it is provided only by ad-hoc mechanisms that lack clean semantics. \nIn this paper we adopt a foundational approach, developing core dynamic rebinding mechanisms as extensions \nto simply-typed call\u00adby-value .-calculus. To do so we must .rst explore re.nements of the call-by-value \nreduction strategy that delay instantiation, to en\u00adsure computations make use of the most recent versions \nof rebound de.nitions. We introduce redex-time and destruct-time strategies. The latter forms the basis \nfor a .marsh calculus that supports dy\u00adnamic rebinding of marshalled values, while remaining as far as \npossible statically-typed. We sketch an extension of .marsh with concurrency and communication, giving \nexamples showing how wrappers for encapsulating untrusted code can be expressed. Fi\u00adnally, we show that \na high-level semantics for dynamic updating can also be based on the destruct-time strategy, de.ning \na .update calculus with simple primitives to provide type-safe updating of running code. We thereby establish \nprimitives and a common se\u00admantic foundation for a variety of real-world dynamic rebinding requirements. \nCategories and Subject Descriptors D.3.3 [Programming Languages]: Language Constructs and Features General \nTerms Languages, Theory, Veri.cation Keywords programming languages, dynamic binding, dy\u00adnamic update, \nmarshalling, serialisation, distributed programming, lambda calculus 1. Introduction Most programming \nlanguages employ static binding, with the meaning of identi.ers determined by their compile-time context. \nIn general, this gives more comprehensible code than dynamic Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 03, August 25 29, 2003, Uppsala, Sweden. \nCopyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00. binding alternatives, where the meanings of identi.ers \ndepend in some sense on their use-time contexts; static binding is also a re\u00adquirement for conventional \nstatic type systems. Modern software, though, is becoming increasingly dynamic, as it becomes ever more \nmodular, extensible, and distributed. Exclusive use of static bind\u00ading is too limiting in many ways: \n When values or computations are marshalled from a running system and moved elsewhere, either by network \ncommunication or via a persistent store, some of their identi.ers may need to be dynamically rebound. \nThese may be both external identi.ers of system-calls or language run-time library functions, and, more \nin\u00adterestingly, internal identi.ers from application libraries which exist in the new context. Such libraries \nshould not be automatically copied with values that use them, both for performance reasons and as they \nmay have location-dependent behaviour (e.g., routing func\u00adtions). Moreover, a value may be moved repeatedly, \nand the set of identi.ers to be rebound may change as it moves. For example, it may be desirable to acquire \nan organisation-speci.c library that, once resolved, should be .xed and carried with code moved within \nthat organisation.  Flexible control of dynamic rebinding can support secure en\u00adcapsulation of untrusted \ncode, by allowing access only to sand\u00adboxed resources. For example, when loading an untrusted applet, \nwe may bind its open identi.er to a safe open function that only opens .les in the /tmp directory. On \nthe other hand, we want the .exibility to link trusted code with the unconstrained open func\u00adtion.  \nSystems that must provide uninterrupted service (e.g., tele\u00adphone switches) must be dynamically updated \nto .x bugs and add new functionality essentially by loading new code into the pro\u00adgram and then dynamically \nrebinding some of the existing identi\u00ad.ers to the new de.nitions.  While dynamic rebinding is clearly \nuseful in practice, most mod\u00adern programming languages provide only rather limited and ad-hoc mechanisms. \nMoreover, no adequate semantic understanding of re\u00adbinding currently exists. Our goal in this paper is \nto identify core mechanisms for dynamic rebinding, as a step towards the design of improved languages \nfor distributed computation. We are focussing on distributed ML-like languages: with higher\u00adorder functions, \nfor expressiveness; with call-by-value (CBV) re\u00adduction, for a simple evaluation order (desirable in \nthe presence of either communication effects or dynamic updates); and where pos\u00adsible with static typing, \nas early detection of errors is particularly important in both distributed and long-running systems. \nThe motivations for dynamic rebinding arise from distribution, but it turns out that the essential problems \ncome from the inter\u00adaction between rebinding and sequential computation. We there\u00adfore begin with the \nsimply-typed CBV lambda-calculus and de\u00advelop calculi that support rebinding for marshalling and update. \nTo demonstrate feasibility we sketch an extension of the former with inter-machine communication, and \ndiscuss a possible implementa\u00adtion. We express the semantics of these calculi with direct operational \nsemantics, de.ning reductions over the calculus syntax. This ap\u00adproach provides clarity, and should scale \nwell to full language de\u00adsigns; it avoids commitment to any particular implementation strat\u00adegy. We .nd \nthis preferable to the lower-level alternatives of ex\u00adpressing semantics using abstract machines or encodings \n(into lan\u00adguages with references), which we believe would lead to rather complex de.nitions. A full version \nis available as a technical report [BHS+03]. Revisiting CBV .-Calculus Consider the CBV .-calculus, a \nmodel fragment of ML, and in particular the way in which identi\u00ad.ers are instantiated. The usual operational \nsemantics substitutes out binders the standard construct-time (app) and (let) rules (app) (.z:T.e)v \n-. { v/z} e (let) let z= vin e -. { v/z} e instantiate all instances of zas soon as the value vthat it \nhas been bound to has been constructed. This semantics is not compatible with dynamic rebinding, as it \nloses too much information. To see this, suppose that ein let z = v in etransmits a function containing \nzto some other machine, and we have indicated somehow that zshould be dynam\u00adically rebound to the local \nde.nition when it arrives. With the (let) rule this would be futile, as the zis substituted away before \nthe communication occurs. Similarly, a dynamic update of zafter a (let) would be vacuous. We therefore \nneed a more re.ned semantics that preserves in\u00adformation about the binding structure of terms, allowing \nus to de\u00adlay looking up the value associated with an identi.er as long as possible so as to obtain the \nmost relevant/recent version of its def\u00adinition. This should maintain the essentially call-by-value nature \nof the calculus, however (we elaborate below on exactly what this means). We present two reduction strategies \nwith delayed instantiation in \u00a72. The redex-time (.r) semantics resolves identi.ers when in redex position. \nWhile this is clean and simple, it is still unneces\u00adsarily eager, and so we formulate the destruct-time \n(.d) semantics to delay resolving identi.ers until their values must be destructed. Dynamic Rebinding: \nthe .marsh Calculus With .d in place we can consider dynamic rebinding of marshalled values. The key \nquestion is this: when a value is moved between scopes, how can the user specify which identi.ers should \nbe rebound and which should be .xed? Our answer is embodied in the .marsh calculus of \u00a73, which contains \nprimitives for packaging a value such that some of its identi.ers are .xed to bindings in the current \ncontext, while others will be rebound when unpackaged in a new scope (e.g., when the value is moved). \nWhich bindings will be .xed is dynam\u00adically determined with respect to a mark. Marking is done with an \nexpression form mark Min e. Here the mark name Mis taken from a new syntactic class (not subject to binding); \nit names the sur\u00adrounding declaration context. Packaging and unpackaging is done by expressions marshal \nMeand unmarshal Me, which are both with respect to a mark. An expression marshal Mewill .rst reduce eto \na value u, and copy all bindings within the nearest en\u00adclosing mark M; these bindings are essentially \nstatic. Identi.ers of unot bound within the mark are recorded in a type environment within the packaged \nvalue, which has form marshalled G u, and can be rebound. For example: let x1 =5 in -. let x1 =5 in \nmark Min mark Min let y1 =6 in let y1 =6 in marshal M(x1,y1) marshalled (x1:int)( let y1 =6 in (x1,y1)) \nBecause y1 is de.ned within the mark M, its de.nition is copied into the package, while x1 is de.ned \noutside of M, so it is sim\u00adply noted in the captured type environment. When this package is unmarshalled \nusing unmarshal with respect to some mark M. , x1 will be rebound to a de.nition outside M', subject \nto a dynamic type environment check. To indicate more concretely how .marsh can form the basis for a \ndistributed programming language that supports mobile code, we sketch an extension with concurrency, \ncommunication and exter\u00adnal library functions, giving examples showing how wrappers for encapsulating \nuntrusted code can be expressed. Dynamic Update: the .update Calculus Dynamic updating also requires \ndynamic rebinding and delayed variable instantiation. We again extend .d, here with a simple update primitive \nthat al\u00adlows a program variable to be rebound to a new expression. The resulting .update calculus is \ngiven in \u00a74. As an example, consider the expression on the left below: {y.(x1,6)} let x1 =5 in -------. \nlet x1 =5 in let y1 =(4,6) in let y1 =(x1,6) in let z1 = update in let z1 =() in p1y1 p1y1 The update \nexpression indicates that an update is possible at the point during evaluation when update appears in \nredex position. At that run-time point the user can supply an update of the form { w . e} , indicating \nthat wshould be rebound to expression e. In the example this update is { y. (x1,6)} ; the let-binder \nfor y1 is modi.ed accordingly yielding the expression on the right above, and thence a .nal result of \n5. Here any identi.er in scope at the update point can be rebound, to an expression that may mention \nidenti.ers in scope at its binding point. We de.ne what it means for an update to be well-typed with \nrespect to a program; apply\u00ading well-typed updates preserves typing. The use of .d enables us to deal \nsimply and cleanly with higher-order functions, largely ig\u00adnored in past work. We imagine .update will \nform the core of future calculi that include other desirable features, such as state trans\u00adformation, \nabstract types, changing the types of variables, multi\u00adthreading, etc. 2. Call-by-value .-calculus revisited \nThis section reconsiders the call-by-value lambda calculus, explor\u00ading re.ned operational semantics that \ninstantiate identi.ers at dif\u00adferent times. We take a standard syntax: Identi.ers x,y,z Integers n Types \nT ::= int | unit | T* T. | T. T. Expressions e ::= z| n| () | (e,e ') | pre | .z:T.e| ee . | let z= ein \ne . | letrec z= .x:T.ein e . Construct-time .c Values v ::= n | () | (v, v') | .z:T .e Atomic evaluation \ncontexts A ::= ( , e) | (v, ) | pr | e | v | let z = in e Evaluation contexts E ::= | E.A (proj) pr(v1, \nv2) -. vr (app) (.z:T.e)v -. { v/z} e (let) let z = v in e -. { v/z} e (letrec) letrec z = .x:T .e in \ne' -. { .x:T .letrec z = .x:T .e in e/z} e' if z = x e -. e' E.e -. E.e' Redex-time .r and Destruct-time \n.d Common Syntax and Semantics Values u ::= n | () | (u, u') | .z :T .e | let z = u in u' | letrec z \n= .x:T.e in u Atomic evaluation contexts A1 ::= ( , e) | (u, ) | pr | e | u | let z = in e Atomic bind \ncontexts A2 ::= let z = u in | letrec z = .x:T .e in Evaluation contexts E1 ::= | E1.A1 Bind contexts \nE2 ::= | E2.A2 Reduction contexts E3 ::= | E3.A1 | E3.A2 e -. e' E3.e -. E3.e ' (proj) pr(E2.(u1, u2)) \n-. E2.ur (app) (E2.(.z:T .e))u -. E2.let z = u in e if fv(u) /. hb(E2) Redex-time Instantiation Semantics \n(inst) let z = u in E3.z -. let z = u in E3.u if z /. hb(E3) and fv(u) /. z, hb(E3) (instrec) letrec \nz = .x:T.e in E3.z -. letrec z = .x:T .e in E3..x:T .e if z /. hb(E3) and fv(.x:T .e) /. hb(E3) Destruct-time \nSyntax Extension and Instantiation Semantics Values u ::= ... | z Destruct contexts R ::= pr | u (inst-1) \nlet z = u in E3.R.E2.z -. let z = u in E3.R.E2.u if z /. hb(E3, E2) and fv(u) /. z, hb(E3, E2) (inst-2) \nR.E2.let z = u in E'2.z -. R.E2.let z = u in E'2.u if z /. hb(E'2) and fv(u) /. z , hb(E'2) (instrec-1) \nletrec z = .x:T .e in E3.R.E2.z -. letrec z = .x:T .e in E3.R.E2..x:T .e if z /. hb(E3, E2) and fv(.x:T.e) \n/. hb(E3, E2) (instrec-2) R.E2.letrec z = .x:T .e in E'2.z -. R.E2.letrec z = .x:T .e in E'2..x:T .e \nif z /. hb(E'2) and fv(.x:T .e) /. hb(E'2) Figure 1: Three Call-by-Value Lambda Calculi where r ranges \nover { 1, 2} . Expressions are taken up to alpha equivalence (though contexts are not). It is simply-typed, \nwith a typing judgement G f e:T de.ned as usual, where G ranges over sequences of z:T pairs. We omit \nthe typing rules for brevity. 2.1 Construct-time The standard semantics, here called the construct-time \nsemantics, is recalled at the top of Fig. 1. We de.ne a small-step reduction relation e -. e', using \nevaluation contexts E, and a run-time\u00aderror predicate e err (the rules for the latter are elided, but \nas usual, projections from non-pairs and application to non-functions are the only conditions giving \nrise to errors). Context composition and ap\u00adplication are both written with a dot, e.g., E.E' and E.e, \ninstead of the usual heavier brackets E[e]. Standard capture-avoiding substi\u00adtution of e for z in e' \nis written { e/z } e'. We write hb(E), de.ned below, for the list of binders around the hole of E. For \nnow we will be concerned only with the behaviour of closed expressions, with\u00adout external library functions. \nThe choice of a small-step semantics will be important when we add dynamic rebinding and communi\u00adcation \nlater.  2.2 Redex-time The redex-time and destruct-time semantics are shown in Fig. 1, with common syntax \nand semantics presented .rst. Instead of sub\u00adstituting bindings of identi.ers to values, as in the construct-time \n(app) and (let), both semantics introduce a let to record a binding of the abstraction s formal parameter \nto the application argument, e.g., (.z:T .e)u -. let z = u in e This is reminiscent of an explicit substitution \n[ACCL90], save that here the let will not be percolated through the term structure, and also of the .let-calculus \n[AFM+95], though we are in a CBV not CBN setting, and do not allow commutation of lets. In contrast, \nwe must preserve let-binding structure, since our later rebinding and update primitives will depend on \nit. Example (1) in Fig. 2 illustrates (app), contrasting it with the substitution approach of the construct-time \nsemantics. Note that the resulting let z =8 in 7 is a .r (and .d) value. Because values may involve lets, \nsome clean-up is needed to extract the usual .nal Construct-time .c Redex-time .r Destruct-time .d (1) \n(.z .7)8 (.z .7)8 (.z .7)8 -. 7 let z =8 in 7  let z =8 in 7  (2) let x =5 in p1(x, x) -. p1(5, 5) \n-. 5 -.  (3)  -. -. -. let x =5 in p1(x, x) let x =5 in p1(x, x) let x =5 in p1(5, x) let x =5 in \nx let x =5 in p1(5, 5) let x =5 in 5 let x =(5, 6) in let y = x in p1y let x =(5, 6) in let y = x in \np1y let x =(5, 6) in let y = x in p1y let y =(5, 6) in p1y let x =(5, 6) in let y =(5, 6) in p1y let \nx =(5, 6) in let y = x in p1x p1(5, 6) let x =(5, 6) in let y =(5, 6) in p1(5, 6) let x =(5, 6) in let \ny = x in p1(5, 6) 5 let x =(5, 6) in let y =(5, 6) in 5 let x =(5, 6) in let y = x in 5 Figure 2: Call-by-Value \nLambda Calculi Examples result, for which we de.ne [| n |]= n [| () |]=() [| (u, u ' ) |]=([| u |], [| \nu '|]) [| .x:T.e |]= .x:T .e [| let z = u in u '|]= { [| u |]/z} [| u '|] [| letrec z = .x:T .e in u \n|] = { .x:T .letrec z = .x:T .e in e/z} [| u |] if z = x [| z |]= z taking any value (.r or .d) and substituting \nout the lets. The semantics must allow reduction under lets in addition to the atomic evaluation contexts \nA we had above (here A1)we now have the binding contexts A2 ::= let z = u in . Re\u00adduction is closed under \nboth. Redex-time variable resolution is handled with the (inst) rule, which resolves an occurrence of \nthe identi.er z in redex position with the innermost enclosing let that binds that identi.er. The side-condition \nz ./hb(E3) ensures that the correct binding of z is used. Here hb(E) denotes the list of identi.ers that \nbind around the hole of a context E, is de\u00ad.ned by hb()=[];hb(E.(let z = e in )) = hb(E), z; hb(E.(letrec \nz = .x:T .e in )) = hb(E), z; and hb(E.A)= hb(E) for any other atomic context A. We overload . for lists. \nThe other side-condition, fv(u) ./z, hb(E3), which can always be achieved by alpha conversion, prevents \nidenti.er capture, making E3 and let z = u in transparent for u. Here fv() denotes the set of free identi.ers \nof an expression or context. Example (2) in Fig. 2 illustrates identi.er instantiation. While the construct-time \nstrategy substitutes for x immediately, the redex\u00adtime strategy instantiates x under the let, following \nthe evaluation order. Both this and the .rst example also illustrate a further aspect of the redex-time \ncalculus: values u include let-bindings of the form let z = u in u ' . Intuitively, this is because a \nvalue should carry its bindings with it preventing otherwise stuck applications, e.g., (.x:int.x)(let \nz =3 in 5) or (for an example where the let is not garbage) (.f :(int . int).x 2)(let z =3 in .x:int.z). \nNote that identifers are not values, so z , (z, z ) and let z =3 in (z, z) are not values. Values may \ncontain free identi.ers under lambdas, as usual, so .x:int.z is an open value and let z =3 in .x:int.z \nis a closed value. The (proj) and (app) rules are straightforward except for the ad\u00additional binding \ncontext E2. This is necessary as a value may now have some let bindings around a pair or lambda; terms \nsuch as p1(let z =3 in (4, 5)) or (more interestingly) p1(let z = 3 in (.x:int.z, 5)) would otherwise \nbe stuck. The side condition for (app) can always be achieved by alpha conversion; it prevents capture. \n2.3 Destruct-time The redex-time strategy is appealingly simple, but it instantiates earlier than necessary. \nIn example (2) in Fig. 2, both occurrences of x are instantiated before the projection reduction. However, \nwe could delay resolving x until after the projection; we see this be\u00adhaviour in the destruct-time semantics \nin the third column. In many dynamic rebinding scenarios it is desirable to instantiate as late as possible.1 \nFor example, in repeatedly-mobile code, we want to in\u00adstantiate each identi.er only as needed to always \npick up local def\u00adinitions. Similarly, for dynamically updateable code we want to delay looking up a \nvariable as long as possible, so as to acquire the most recent version. To instantiate as late as possible, \nwhile remaining call-by-value, we instantiate only identi.ers that are immediately under a projec\u00adtion \nor on the left-hand-side of an application. In these destruct positions their values are about to be \ndeconstructed, and so their outermost pair or lambda structure must be made manifest. The destruct contexts \nR ::= pr | u can be seen as the outer parts of the construct-time (proj) and (app) redexes. The choice \nof destruct contexts is determined by the basic redexes for example, if we added arithmetic operations, \nwe would need to instantiate identi\u00ad.ers of int type before using them. The essential change from the \nredex-time semantics is that now any identi.er is a value ( u ::= ... | z ). The (proj) and (app) rules \nare unchanged. The (inst) rule is replaced by two that together instantiate identi.ers in destruct contexts \nR. The .rst (inst-1) copes with identi.ers that are let-bound outside a destruct context, e.g.: let z \n=(1, 2) in p1z -. let z =(1, 2) in p1(1, 2) whereas in (inst-2) the let-binder and destruct context are \nthe other way around: p1(let z =(1, 2) in z ) -. p1(let z =(1, 2) in (1, 2)) Further, we must be able \nto instantiate under nested bindings be\u00adtween the binding in question and its use. Therefore, (inst-2) \nmust allow additional bindings E2 and E2 ' between R and the let and 1 It is the conventional wisdom \nof distributed programming that in any cases of this sort early binding is extremely wicked, and every \nopportunity must be taken to allow for variability. [Nee93]. between the let and z. Similarly, (inst-1) \nmust allow bindings E2 between the R and z; it must allow both binding and evaluation contexts E3 between \nthe let and the R, e.g., for the instance let z =(1, (2, 3)) in p1(p2z) -. let z =(1, (2, 3)) in p1(p2(1, \n(2, 3))) with E3 = p1 , R = p2 and E2 = . The conditions z ./hb(E3, E2) and z ./hb(E2' ) ensure that \nthe correct binding of z is used; the other conditions prevent capture and can always be achieved by \nalpha equivalence. Example (3) illustrates a chain of instantiations, from outside in for .r and from \ninside out for .d.  2.4 Properties This subsection gives properties of our various .-calculi: sanity \nchecks to con.rm that our de.nitions are coherent and more sub\u00adstantial results showing that .r and .d \nare essentially CBV. Details of proofs can be found in the technical report [BHS+03]. First, we recall \nthe important unique decomposition property of evaluation contexts for .c, essentially as in [FF87, p. \n200], and generalise it to the more subtle evaluation contexts of .r and .d: THEOREM 1(UNIQUE DECOMPOSITION \nFOR .r AND .d). Let e be a closed expression. Then, in both the redex-time and destruct-time calculi, \nexactly one of the following holds: (1) e is a value; (2) e err; (3) there exists a triple (E3, e ' , \nrn) such that E3.e ' = e and e ' is an instance of the left-hand side of rule rn. Furthermore, if such \na triple exists then it is unique. (Note that the destruct-time error rules de.ning e err, which have \nbeen elided, must include cases for identi.ers in destruct contexts that are not bound by enclosing lets \nand so are not instantiatable, giving stuck non-value expressions.) Determinacy is a trivial corol\u00adlary. \nWe also have type preservation and type safety properties for the three calculi. THEOREM 2(TYPE PRESERVATION \nFOR .c, .r AND .d). If G f e:T and e -. e ' then G f e ' :T . THEOREM 3(SAFETY FOR .c, .r AND .d ). If \nf e:T then \u00ac (e err). Finally we show that all three calculi are observationally equiv\u00adalent, hence that \nboth .r and .d are essentially call-by-value. As we noted earlier, values in .r and .d may need to be \ncleaned-up to exactly correspond to .c values. The proof of this is non-trivial; it involves constructing \na tight correspondence between reduction steps in the three calculi. THEOREM 4(OBSERVATIONAL EQUIVALENCE). \n* **' 1. If f e:int and e -. n then e -. u and e -. u for c rd some u and u ' with [| u |]=[| u '|]= \nn. 2. If f e:int and e -. r * u (or e -. d * u) then for some n we have e -. c * n and [| u |]= n. Proof \nSketch The proof technique is the same for both claims: generalise the claim to arbitary type and proceed \nto construct a bisimulation (modulo possible instantiations of letrec bindings) that captures a tight \noperational correspondence between reductions in the different calculi. To do so, we introduce intermediate \ncaluli with annotated lets, distinguishing lets that, in the .c reduction sequence, correspond to substitutions \nfrom those that have yet to be reached. Additional transitions move value-lets from the latter to the \nformer. Bisimulations can then be constructed by factoring simulations through these intermediate calculi. \nA key notion in the simulation proofs is that of instantiation normal form. Essentially a term is in \ninstantiation normal form if it can not do an instantiation reduction. It is important that this form \nis always .nitely reachable by reduction from any term. Finally, we use the bisimulation and some auxilary \nlemmas to prove the generalised claim (the claim as stated in the theorem avoids the complication of \npossible letrec unfoldings). 3. A Dynamic Rebinding Calculus: .marsh Many applications require a mix \nof dynamically and statically bound variables. Consider sending a function value between ma\u00adchines. It \nmight contain identi.ers for (1) ubiquitous standard library calls, e.g., print, which should be rebound \nat the destination; (2) application-speci.c location-dependent library calls, e.g., routing functions, \nwhich should be rebound at the destina\u00adtion; (3) application code which is not location-dependent but \n(for performance) should be rebound rather than sent; and (4) other let-bound application values, which \nshould be sent with it.  Moreover, for both (1) and (2) one may wish the rebinding to be to non-standard \nde.nitions, to securely encapsulate (sandbox) un\u00adtrusted code. In this section we develop a calculi to \nsupport all of the above. The calculus .marsh extends the destruct-time .d-calculus of \u00a72.3 with high-level \nrepresentations of marshalled values and primitives to manipulate them. We make two main choices. First, \nto have as intuitive a semantics as possible we want dynamic rebinding to only occur when unmarshalling \nvalues, not during normal computation. Second, to allow the programmer to cleanly and .exibly notate \nwhich de.nitions should be .xed and which should be rebindable, we introduce marks mark M in e which \nname contexts. Marshal and unmarshal operations marshal Me and unmarshal Me are each with respect to \na mark: a marshal Mu packages the value u together with all the bindings within the closest enclosing \nmark M (thus .xing them); it cuts any bindings of identi.ers in u that cross that mark M (thus making \nthem rebindable). When the packaged value is unpackaged by an unmarshal M ' , the latter identi.ers are \nrebound to binders outside the closest enclosing mark M ' . The mark M in e construct does not bind M \n; marks have global meaning across a distributed system. Allowing the choice of context to be made differently \nfor each marshal and unmarshal provides important .exibility, especially for implementing secure encapsulation; \nnote that we have just a single class of identi.ers, rather than dynamic and static forms. In the simplest \npractical case each program might have a single mark Lib in , distinguishing li\u00adbrary code, de.ned above \nthe mark, from application code, de.ned below it. For simplicity, .marsh simulates communication using \nbeta\u00adreduction (in fact, .d (inst) reduction), and omits treatment of (1), focusing on the more interesting \ncases of rebinding application\u00adspeci.c libraries. At the end of this section we sketch .io marsh, which \nstraightforwardly extends .marsh with communication and external identi.ers, and discuss alternative \ndesign choices. 3.1 Syntax The .marsh syntax and an example, discussed below, are given in Fig. 3; the \nnew semantic rules are given in Fig. 4 (error rules omit\u00adted). The calculus requires a more elaborate \ntreatment of alpha Syntax Integers n Identi.ers Type environments G Types T ::= Expressions e ::= x, \ny, z Tags i, j, k Context marks M .nite partial functions from (identi.er,tag) pairs to types int | unit \n| T* T ' | T. T ' | Marsh T zi | n| ()| (e, e ' )| pre| .xi:T.e| ee ' | let zk:T=ein e ' | letrec zk:T \n' =.xi:Tmark Min e| marshal Me| marshalled Gu| unmarshal Me .ein e ' | Example let y1:int =6in mark Min \nlet x1:Marsh (int * int)=( let z1:int =3in marshal M(y1,z1)) in let y2:int =7in mark M ' in unmarshal \nM ' x1 where T=Marsh (int * int) (marshal)-. let y1:int =6in mark Min let x1:T=( let z1:int =3in marshalled \n(y0:int)( let z1:int =3in (y0,z1)))in let y2:int =7in mark M ' in unmarshalM ' x1 (inst-1)-. let y1:int \n=6in mark Min let x1:T=( let z1:int =3in marshalled (y0:int)( let z1:int =3in (y0,z1)))in let y2:int \n=7in mark M ' in unmarshal M ' ( let z1:int =3in marshalled (y0:int)( let z1:int =3in (y0,z1))) (unmarshal)-. \nlet y1:int =6in mark Min let x1:T=( let z1:int =3in marshalled (y0:int)( let z1:int =3in (y0,z1)))in \nlet y2:int =7in mark M ' in let z1:int =3in (y2,z1) Figure 3: Dynamic Rebinding Calculus .marsh: Syntax \nand Example equivalence than .d. There as usual for .-calculi we had to use alpha equivalence during \nnormal computation steps, to avoid mistaken capture of identi.ers as the rules move subterms between \ndifferent scopes. Here that is still required, but occurrences of the same identi.er under different \nbindings must be related so that the identi.er can be marshalled with respect to one and unmarshalled \nwith respect to another. Accordingly, instead of working with iden\u00adti.ers x, we work with variables xi \nthat are pairs of an identi.er x and a tag i, similar to the external and internal names used in some \nmodule systems. Alpha equivalence changes only the tags; tags for different identi.ers lie in different \nnamespaces, so e.g., .x1:T.x1 =.x2:T.x2 =.y2:T.y2 and .x1:T..y1:T.(x1,y1)=.x2:T..y3:T.(x2,y3) In practice \ntags would not appear in source programs; they are needed only for the semantics. The fv()and hb()functions \nnow give sets and lists of variables, respectively, not identi.ers.  3.2 Example As an example, consider \nthe expression on the left of Fig. 3. The value (y1,z1)is marshalled with respect to the context marked \nM, where y =6, but unmarshalled with respect to the context M ' , where y=7. The z1, on the other hand, \nis bound below mark M, so its binding z1 =3is grabbed and carried with it. The reduction sequence is \nshown in the Figure, boxing key parts of redexes and contracta. The .rst reduction step copies the bindings \nthat are inside mark Mand around the marshal ex\u00adpression (here just z1 =3), ensuring that these have \nstatic-binding semantics. This gives a value marshalled (y0:int)(let z1 =3in (y0,z1)) This marshalled \nG u form would not occur in source pro\u00adgrams. The free variables of uare subject to rebinding when this \nis unmarshalled, so we regard all of fv(u)as bound by Gin marshalled Gu. This is emphasised in the example \nby showing a y0 alpha-variant. The second step instantiates the x1 under the (unmarshal M ' ) with its \nvalue let z1 =3in ...marshalled.... (In this case the outer z1 let is redundant but in more complex cases \nit would not be, e.g., if x1 were bound to a pair of the marshalled value and some other value mentioning \nz1.) The third step performs the unmarshal, rebinding the y0 in the packaged value let z1 =3in (y0,z1)to \nthe innermost yi binder outside mark M ' here, to y2. It also discards the now-redundant bindings. Modulo \n.nal instantiation, the result is (7, 3)not (6, 3), showing the y1 and z1 have been treated dynamically \nand statically respec\u00adtively. For contrast, putting the .rst let y1 =6inside the .rst mark Mwould give \n(6, 3).  3.3 Semantics Turning now to the details of the rules, the (proj), (app) and (inst-r) rules \nare as in .d but with zk instead of z. In the (marshal) and (unmarshal) rules we abuse notation, writing \nthe con\u00adtext mark M in as mark M. The (marshal) rule copies all bindings and marks between the marshal \nM and the closest en\u00adclosing mark M, using the bindmark()auxiliary to extract the bind and mark components \nof a context E3, discarding the evalua\u00adtion context components: bindmark( )= , bindmark(E3.A1)= bindmark(E3), \nand bindmark(E3.A2)= bindmark(E3).A2. The predicate dhb(E3)holds iff the hole-binders of E3 are all distinct \n(which can always be made so by alpha conversion). The auxiliary env(E3)extracts the type environment \nof the hole-binders of E3, so they can be recorded in the marshalled value. The (unmarshal) rule rebinds \nthe fv(u)to the let-binders in E3 around the nearest enclosing mark M, using the auxiliary func\u00ad ' '' \nValues u ::= n | () | (u, u ) | .xi:T .e | let zk:T = u in u | letrec zk:T = .xi:T.e in u | zi | mark \nM in u | marshalled G u Atomic evaluation contexts A1 ::= ( , e) | (u, ) | pr | e | (.xi:T .e) | let \nzk:T = in e | marshal M | unmarshal M Atomic bind and mark contexts A2 ::= let zk:T = u in | letrec zk:T \n' = .xi:T .e in | mark M in Evaluation contexts E1 ::= | E1.A1 Bind and mark contexts E2 ::= | E2.A2 \nReduction contexts E3 ::= | E3.A1 | E3.A2 Destruct contexts R ::= pr | u | unmarshal M Rules (proj), \n(app), (inst-r), (instrec-r) are exactly as in .d except for zk replacing z and the addition of explicit \ntypes. These reductions are closed under E3, whereas the (marshal) and (unmarshal) rules are global. \n'' ' (marshal) E3.mark M .E3.marshal Mu -. E3.mark M .E3.marshalled (env(E3)) (bindmark(E3).u) if dhb(E3) \nand no mark M around in E3 ' (unmarshal) E3.mark M .E3' .unmarshalM .E2.marshalled G u -. E3.mark M .E3' \n.S(u) if dhb(E3), dhb(E3' , hb(E3)), S = rebind(G, thb(E3)) is de.ned, and no mark M around in E3' . \n Figure 4: Dynamic Rebinding Calculus .marsh: Semantics tion rebind( , ) to construct the appropriate \nsubstitution. Here dhb(E3' , hb(E3)) holds iff the hole-binders of E3 ' are distinct from each other \nand from all the variables in hb(E3) (always possible by alpha conversion). The thb(E3) gives the list \nof (variable,type) pairs, which are the typed hole-binders of E3 (type annotations were added to lets \nto facilitate this). Finally, rebind(G, L), for a type environment G and list of typed hole-binders L, \nis a substitu\u00adtion taking each xi in dom(G) to the rightmost xj in L, if the types correspond appropriately. \nIt is de.ned by rebind(G, []) unde.ned if G nonempty = {} otherwise rebind(G, (L, (xi:T ))) '' ' unde.ned, \nif . j , T .(xj :T ) . G . T = T = { xi/xJ }. rebind(G - xJ , L), otherwise where xJ = { xj | (xj :T) \n. G} (abusing notation to treat the partial function G as a set of tuples and writing { xi/xJ } for the \nsubstitution of xi for all the xj . xJ ). To keep a unique decomposition property the (unmarshal) rule \nis global, not closed under additional E3. We brie.y justify why the (unmarshal) rule discards its E2 \ncontext: observe the right hand side of the rule and notice that the binders in the E2 context can no \nlonger be referenced after unmarshalling, the only possible refer\u00adences to the enclosing E2 are the free \nvariables of u, but subsequent to this reduction these variables are rebound to binders in E3. Reduction \nmust take place under a mark so A2 now con\u00adtains mark M in . To maintain a CBV semantics both marshal \nand unmarshal should fully reduce their arguments, so they are included in the evaluation contexts A1. \nThe (unmarshal) rule can only .re if the argument to unmarshal is of the form marshalled G u, so the \ndestruct contexts must include unmarshal M . There are several choices embodied in the semantics. First, \nin (marshal) bindmark(E3' ) records the marks of E3 ' as well as its let\u00adbindings, so that uses of marshal \nand unmarshal within u will behave as expected. Second, in (marshal) we record the full type environment \nenv(E3), not just its restriction to fv(u). The latter believe would lead to code that is hard to maintain: \nsuccess of an unmarshal would depend on the free variables of the marshalled value, instead of simply \non the binders above the mark used for marshalling. Third, if there is shadowing of identi.ers outside \na mark then a marshalled G u may have G with xi:T and xj :T ' for T = T ' , in which case (unmarshal) \nwill always fail. One could check this at (marshal)-time, or indeed forbid shadowing outside marks. \n 3.4 Typing and Run-Time Errors In some cases one would expect dynamic rebinding to require a run-time \ncheck to ensure safety, e.g., if code is sent to a site that may or may not provide some resource it \nrequires. For .marsh we have new run-time errors, if a marshal or an unmarshal refers to a mark which \nis not in scope, or if at (unmarshal)-time the envi\u00adronment does not have the required binders at the \ncorrect types. At the very least, however, one would like a type system to exclude all run-time errors \nexcept these. This can be done by a simple type system, as usual but with a type Marsh T of marshalled \ntype-T values, and rules G f e:T G f e:T  G f mark M in e:T G f marshal Me:Marsh T G f e:Marsh T G \n' f u:T  G f unmarshal Me:T G f marshalled G ' u:Marsh T Partitioning the run-time errors into e err \nfor the usual projec\u00adtion/application errors, together with unmarshalling of values not of the form marshalled \nG u, and e err ' for the new errors above (their rules are elided), we have: THEOREM 5(UNIQUE REDEX/CONTEXT \nDECOMPOSITION). Let e be a closed .marsh expression. Then exactly one of the following holds: (1) e is \na value; (2) e err; (3) e err ' ; (4) there exist E3, e0, rn such that E3.e0 = e and e0 is an instance \nof the left-hand side of rule rn . (proj,app,inst-r,instrec-r). (5) there exists rn . (marshal),(unmarshal) \nsuch that e is an instance of the left-hand side of rule rn. Furthermore, if such a triple or rn exists \nthen it is unique. would be more liberal (more unmarshals would succeed) but we THEOREM 6(TYPE PRESERVATION \nFOR .marsh). Simple: P = ... . t1:let here0 = site 1 in t2:let here0 = site 2 in  .. . . mark AppLib \nin mark AppLib in .. . .  . let = print0here0 in .. c?(.f0:Marsh (unit . unit).(unmarshal AppLib f0)()) \n. c!marshal AppLib (.x0:unit.print0here0) Secure encapsulation: Q = . t1:let here0 = site 1 in .  mark \nAppLib in . . let = print0here0 in c!marshal AppLib (.x0:unit.print0here0) . . t2:let here0 = site 2 \nin . mark TrustedAppLib in . . . . . let print3 =(.s0:string. . . .  . let = print0 sandboxed: in \nprint0s0) in . . . . . . let here3 = site 33 in . . . . . mark UntrustedAppLib in . . . . c?(.f0:Marsh \n(unit . unit). . . . let g0 =(if trusted() then unmarshal TrustedAppLib f0 else unmarshal UntrustedAppLib \nf0) in g0()) Figure 5: Dynamic Rebinding with IO and Communication: .io Examples marsh If f e:T and e \n-. e ' then f e ' :T THEOREM 7(PARTIAL SAFETY FOR .marsh). If f e:T then \u00ac (e err). A full language would \nraise catchable exceptions in the e err ' cases, thereby allowing code to dynamically check the presence \nof resources. Ideally, of course, one would like a type system that could stati\u00adcally prevent all run-time \nerrors, in the case where all parts of the (distributed) system can be type-checked coherently. Unfortunately \nstatic typing and dynamic rebinding seem to be at odds. Any sound type system for .marsh must constrain \nthe contexts around marks, ensuring that when unmarshalling a marshalled value the context of the unmarshal \nmark contains bindings for all identi.ers that were in the context of the marshal mark. The problem is \nthat reduc\u00adtion moves subterms, in particular subterms containing marks, so the shape of the context \naround a mark can change dynamically. One can devise rather draconian systems that prevent some run\u00adtime \nerrors, but it is hard to see what a really useful system could be like. Moreover, in the wide-area setting \nit is generally impos\u00adsible to guarantee that all parts are type-checked together, so we believe that \nthe limited guarantees of the simple type system above may have to suf.ce. In practice one would expect \nprograms to contain only a few marks. For ML-like languages with second-class module systems it may be \ndesirable to allow marks only between module declarations a considerable simpli.cation. 3.5 Implementation \nThe reduction semantics as presented is not proposed as a realis\u00adtic implementation strategy. Instead \nof representing bindings by nested let terms, and preserving binding scopes in the instantiation rules \nby copying and a-conversion, we propose to use linked en\u00advironment frames with sharing, as is done to \nimplement function closures. A function closure consists of the binding variable name, function body, \nand a pointer to the enclosing environment. The environment consists of frames, each containing a variable \nname, value, and a link pointer to the parent frame. For .d, variables as well as functions are values; \ntherefore we introduce variable clo\u00adsures, consisting of a variable name and an environment pointer through \nwhich to look it up. Only when the variable closure ap\u00adpears in a destruct context is the pointer followed \nto obtain its value. For .marsh, the marshal operation captures the linked environment between the environment \npointers of its argument and the relevant mark, and the unmarshal operation attaches the captured environ\u00adment \nto the current environment. We have sketched an abstract ma\u00adchine semantics for the above, but leave \nan actual implementation for future work.  3.6 Adding Distributed Communication We now extend .marsh \njust enough to show examples of the rebind\u00ading scenarios from \u00a71, sketching a .io calculus. For lack \nof marsh space almost all details are omitted; we show just some examples in Fig. 5, and touch on the \nmain points. Two extensions are required: semantics for open terms, to ad\u00admit programs that use external \nlibrary calls such as print; and communication, to support code movement. There are many de\u00adsign choices \nin combining functional and concurrent computation. Here we adopt a simple language, just to illustrate \nthe application of .marsh and demonstrate what is required the exact choice of primitives is therefore \nrather arbitrary. We consider parallel compositions of expressions e, each with a thread ID t. One should \nthink of threads as partitioned among a set of machines, although that structure has been omitted from \nthe formalisation. We suppose for simplicity that all machines provide the same external library calls, \nwith types given by a Glib, and that there are global channels c for communication between threads, with \ntypes given by a .. l The semantics de.nes a transition relation P-. P ' over con.g\u00adurations where the \nlabels l are either empty, t:fu for an invocation by thread t of library call f :T . T ' from Glib, with \nargument u, or t:u for a return of value u from the OS to such an invocation. The (marshal) and (unmarshal) \nrules must be modi.ed slightly to deal with external identi.ers. Communication between threads is by \nasynchronous message passing on typed channels c, with output and input forms e!e ' and e?e ' . Only \nmarshalled values should be communicated, so com\u00admunications are typed as below. ., G f e:Chan T ., G \nf e:Chan T ' '' ., G f e :Marsh T ., G f e :(Marsh T ) . T ' '' ., G f e!e :unit ., G f e?e :T Example \nP in Fig. 5 shows rebinding to an external print and an internal (application library) here, together \ndelimited by AppLib, Simple Update Calculus: Syntax Integers n Identi.ers x, y, z Tags i, j, k Types \nT ::= int | unit | T * T ' | T . T ' Expressions e ::= xi | n | () | (e, e ' ) | pre | .xi:T .e | ee \n' | let zk:T = e in e ' | letrec zk:T = .xi:T .e in e | update Simple Update Calculus: Semantics (upd-replace-ok) \nS = rebind(fv(e), hb(E3)) is de.ned env(E3) f S(e):T . j .xj /. hb(E ' 3) E3.let xi:T = u in E ' 3.update \n{x.e}-. E3.let xi:T = S(e) in E ' 3.() Figure 6: Simple Update Calculus: .update on a communication \nfrom the left thread to the right. It has a tran\u00adsition sequence with labels t1:print site 1 , t1:(), \nt2:print site 2 , t2:() for the invocations and returns of the two external print calls. Our rebinding \ncalculus is powerful enough to perform cus\u00adtomized linking, useful for implementing secure encapsulation. \nEx\u00adample Q is similar to P but the receiver de.nes two marks to be linked against, TrustedAppLib and \nUntrustedAppLib. The for\u00admer is for trusted programs, whereas the latter is an encapsulated context, \nwhich reimplements both print and here with safe ver\u00adsions. The safe print prints the warning string \nsandboxed: be\u00adfore any output; the safe here provides the fake site 33 to the encapsulated code, which \nhas no way to access the true here0 = site 2 binding. Which context to use is determined by the hy\u00adpothetical \nfunction trusted, which would take into account some security criteria, such as the origin of the message. \nAssuming that trusted() returns false, Q has a transition sequence with labels t1:print site 1 , t1:(), \nt2:print sandboxed: , t2:(), t2:print site 33 , t2:() It is worth emphasising that without delayed instantiation, \nrebind\u00ading in these examples would not be possible. In particular, in both cases the construct-time (let) \nrule would substitute out here0 in t1 before sending the lambda-term, thus preventing a rebinding of \nhere at the remote site.  3.7 Discussion In this subsection we review some of the design choices embodied \nin .marsh and their advantages and disadvantages. A simple alternative is to allow marshalling only of \nvalues that are in some sense closed (with a marshal-time check that they do not refer to, e.g., print). \nThis would require the programmer to ex\u00adplicitly abstract on all the identi.ers that are to be treated \ndynami\u00adcally when constructing a value to be marshalled, and to explicitly apply to the local de.nitions \non unmarshalling. For rebinding to a single standard library this might be acceptable, though even there \nnotationally heavy, but for the richer usages we describe above it would be prohibitively complex. One \ntherefore needs some form of dynamic rebinding. To keep the semantics of local computation simple, with \nthe nor\u00admal static scoping, we choose to permit rebinding only when un\u00admarshalling values. The most interesting \nquestion is then which variables in a value should be rebound after marshalling and un\u00admarshalling. The \nmain choice is between having two classes of variable (one treated statically and one dynamically), or \none class of variable, with some other way of specifying which are rebound in any par\u00adticular marshal/unmarshal \ninstance. Two classes were used in some related systems, though not mo\u00adtivated by marshalling [LLMS00, \nLF93, Dam98, Jag94] (discussed further in \u00a75). The disadvantages of the two-class choice are: (a) it \nis less .exible than our use of marks, in which different mar\u00adshals and unmarshals can refer to different \nmarks, e.g. in the \u00a73.6 examples; and (b) if the types or usage-forms of the two classes dif\u00adfer, then \nchanging the class of a variable would require widespread code change (if the two classes are distinguished \nonly by their declaration-forms, this is not such a problem). Code would thus be hard to maintain. In \ncontrast, adding marks or changing their position is syntac\u00adtically lightweight; it does not require \nany change to code ex\u00adcept at marshal/unmarshal points. Moreover, it will usually be straightforward \nto change the let-bindings in programs that contain marks: changing let-bindings inside marks is as usual; \nchanging them outside a mark may require corresponding changes outside other marks but no change to any \nmarshal and unmarshal expres\u00adsions. Taking one class has the disadvantage that it is not obvious from \na code fragment which variables might have been rebound, but in typical cases one can simply look for \nenclosing marks and marshals. A further disadvantage of .marsh is that programs with many nested marks, \nand with marks under lambdas, can become con\u00adfusing. Whether this is a problem in practice remains to \nbe seen. With one class one could specify the variables to be rebound ei\u00adther with marks or by explicitly \nannotating marshal with the set of rebindable identi.ers. We believe the latter would be cumbersome in \npractice (with large sets of standard library identi.ers). It would also be conceptually complex and \ndif.cult to implement ef.ciently for example, consider a sequence of bindings, each depending on the \none before, around a marshal that speci.es that alternate bindings should be treated dynamically. 4. \nSimple Update Calculus: .d + update We now turn from dynamic rebinding of marshalled values to the rebinding \ninvolved in dynamic update. Dynamic updating is re\u00adquired for long-running systems that must provide \nuninterrupted service the canonical example is the telephone switch, with a complex internal state, \nmany overlapping interactions with its envi\u00adronment, and a requirement for high availability. Applying \nupdates, however, can quickly lead to confusion particularly if they are in the form of binary patches. \nTo ameliorate this, we would like high\u00adlevel update primitives: with semantics expressed in terms of \nthe source programming language rather than some abstract machine or particular compilation strategy. \nWe show this can be done for typed CBV functional programs. Delayed instantiation is again re\u00adquired, \nnow so that running code picks up any updated de.nitions as it executes, and applying an update involves \nsome explicit re\u00adbinding. We design a .update calculus accordingly, again based on our .d semantics and \nwith tagged identi.ers. It is intended as a proof-of-concept, to demonstrate that a clean high-level \nsemantics can be based on .d, rather than a complete treatment of updating, so we include only a simple \nupdate primitive. Nonetheless, the cal\u00adculus is still quite expressive, and unlike other work in this \narea is not tied to a particular abstract machine, or to a .rst-order setting. The .update-calculus is \ngiven in Fig. 6 (the .d rules and error rules are elided). As in \u00a73 it is convenient to use tagged identi.ers \nand explicitly-typed lets, but the types are omitted in examples. We allow the programmer to place an \nexpression update at points in the code where an update could occur; de.ning such updating safe points \nis useful for ensuring programs behave properly [Hic01]. The intended semantics is that this expression \nwill block, waiting for an update (possibly null) to be fed in. An update can modify any identi.er that \nis within its scope (at update-time), for example in  let x1 =(let w1 =4 in w1) in let y1 = update in \n let z1 =2 in (x1,z1) x1 may be modi.ed by the update, but w1, y1 and z1 may not. For simplicity we only \nallow a single identi.er to be rebound to an expression of the same type, and we do not allow the introduction \nof new identi.ers. We de.ne the semantics of the update primitive using a labelled transition system, \nwhere the label is the updating expression. For example, supplying the label { x . p1(3,4)} means that \nthe near\u00adest enclosing binding of x is replaced with a binding to p1(3,4). Note that updates can be expressions, \nnot just values after an up\u00addate the new expression, if not a value, will be in redex position. Further, \nthey can be open, with free variables that become bound by the context of the update. The static typing \nrule for update is trivial, as it is simply an expression of type unit. Naturally we have to perform \nsome type checking at run-time; this is the second condition in the transition rule in Fig. 6. Notice \nhowever, that we do not have to type-check the whole program; it suf.ces to check that the expression \nto be bound to the given identi.er has the required type in the context that it will evaluate in. The \nother conditions of the transition rule are similarly straightforward. The .rst ensures that a rebinding \nsub\u00adstitution is de.ned, i.e. that the context E3 has hole binders that are alpha-equivalent to the free \nvariables of e. Here rebind(V ,L), for a set V and list L of variables, is de.ned if for all xi . V there \nis some j with xj . L, in which case it is the the substitution taking each such xi to the rightmost \nsuch xj . The third condition ensures that the binding being updated, xi, is the closest such binding \noc\u00adcurrence for x (notice that an equivalence class x is speci.ed for the update, but that the closest \nenclosing member, xi, of this class is chosen as the updated binding). These conditions are suf.cient \nto ensure that the following theorem holds. THEOREM 8(TYPE PRESERVATION FOR UPDATES). {x.e .} '' '' If \nf e:T and e-. e then f e :T We have safety and unique decomposition results that follow the form of Theorems \n1 and 3. Our use of delayed instantiation cleanly supports updating higher-order functions. Consider \nthe following program: let f1 = .y1.(p2y1,p1y1) in let w1 =.g1.let = update in g1(5,6) in let y1 = f1(3,4) \nin let z1 = w1f1 in (y1,z1) which contains an occurrence of update in the body of w1. If, when w1 is \nevaluated, we update the function f : {f ..p1.p1} e -. * --------.-. * u we have [| u |] = ((4,3),(5,6)). \nDelayed instantiation plays a key role here: with the .c semantics, the result would be [| u |]= ((4,3),(6,5)); \ni.e. the update would not take effect because the g1 in the body of w1 would be substituted away by the \n(app) rule before the update occurs. Our semantics preserves both the struc\u00adture of contexts and the \nnames of variables so that updates can be expressed. Erlang [AVWW96] has a simple update mechanism where \nmod\u00adules can be replaced at runtime. The transition to a new module, or the continued use of the old \nmodule, is speci.ed at each call site. A semantics for a (higher-order, typed) version of the Erlang \nupdate mechanism extended to support multiple coexisting mod\u00adule versions can easily be expressed using \nthe ideas in this paper [BHSS03]. 5. Related Work 5.1 Lambda Calculi As discussed in \u00a72.2, our approach \nin .r and .d of using letsto record the arguments of functions has some similarities to prior work on \nexplicit substitutions [ACCL90] and on sharing in call-by\u00adneed languages [AFM+95]. There are also similarities \nwith Felleisen and Hieb s syntactic theory of state [FH92]. Their .S models late (redex-time) resolu\u00adtion \nof state variables in a substitution-based system by labelling the substituted-in values with the name \nof the variable; assignment to a variable triggers a global replacement of all values labelled with that \nvariable throughout the program with the new value. This is then revised to an equivalent store-based \nmodel. 5.2 Dynamic Rebinding and .marsh Dynamic Binding Work on dynamic binding can be roughly classi.ed \nalong three dimensions. First, one can have either dy\u00adnamic scoping, in which variable occurrences are \nresolved with re\u00adspect to their dynamic environment, or static scoping with explicit rebinding, where \nvariables are resolved with respect to their static environment, but additional primitives allow explicit \nmodi.cation of these environments. Second, one can work either with one class of variables or split into \ntwo: one treated statically and one dynam\u00adically. Third, for explicit rebinding the variables to be rebound \ncan be speci.ed either individually, per name, or as all those bound by a certain term context. We identify \nsome points in this space below, and refer the reader to the surveys of Moreau and Vivas [Mor98, VF01] \nfor further discussion. Dynamic scoping .rst appeared in McCarthy s Lisp 1.0 as a bug, and has survived \nin most modern Lisp dialects in some form. It is there usually referred to as dynamic binding. Lisp 1.0 \nhad one class of variables. MIT Scheme s [MIT] fluid-let form and Perl s local declaration similarly \nperform dynamically-scoped re\u00adbinding of variables. Modern Lisp distinguishes at declaration time between \ndynamically and statically scoped variables, as for\u00admalised in the .d-calculus of Moreau [Mor98]. Lewis \net al. pro\u00adpose to add syntactically-distinct, dynamically-scoped implicit pa\u00adrameters [LLMS00] to statically-scoped \nHaskell. While .exible, dynamic scoping can result in unpredictable behaviour, since vari\u00adables can be \ninadvertently captured; this was referred to as the downward funarg problem in the Lisp community (to \navoid this in a typed setting Lewis et al. forbid arguments of higher-order func\u00adtions from using dynamically \nscoped variables). Turning to static scoping with explicit rebinding, the quasi-static scoping Scheme \nextension of Lee and Friedman [LF93] and the .N-calculus of Dami [Dam98] both have two classes of variable \nwith a rebinding primitive that speci.es new bindings for individual variables. Jagannathan s Rascal \nlanguage [Jag94] maintains both a static environment and a public environment, corresponding again to \ntwo variable classes. The barrier, reify, and re.ect operations allow explicit manipulation of the variables \nbound by an entire term context. Outside the above classi.cation, MIT Scheme also permits ex\u00adplicit manipulation \nof top-level environments. Hashimoto and Ohori introduce a typed context calculus [HO01] for expressing \n.rst-class evaluation contexts within the lambda calculus. Con\u00adtext holes can be .lled in with terms \nhaving free variables which are captured by the surrounding context. This allows binding at context-application \ntime, but does not support rebinding. It is de\u00adveloped in the MobileML language [HY00]. Garrigue [Gar95] \npresents a calculus based on streams that can be used to encode dynamic binding for particular, scope-free \nvariables. Locating our .marsh calculus in this space, it adopts static scoping with explicit rebinding, \nhas a single class of variables, and supports rebinding with respect to named contexts (not of individual \nvari\u00adables). Use of the destruct-time strategy delays variable resolution until the last possible moment \nto give the most useful semantics, e.g., for repeatedly-mobile code. As argued in \u00a73, we believe these \nchoices will lead to code that is easier to write and maintain, par\u00adticularly for large systems. We conjecture \nthat .marsh could be encoded in Rascal, and also that it could be given semantics either in an environment-passing \nstyle or using an abstract machine with concrete environments. We believe, however, that our reduction \nsemantics, with small-step re\u00adductions over the source syntax, is more perspicuous. Partial Continuations \nThe context-marking operator mark is reminiscent of Felleisen and Friedman s [FF87] prompt opera\u00adtor \n#, and marshal/unmarshal of their control operator F. Their operators capture partial continuations, \nwhereas our operators may be seen as capturing partial environments: whereas mark marks a binding context, \n# marks an evaluation context. In fact, .marsh .l\u00adters the captured context to retain only the binding \nstructure (E2), whereas Felleisen et al. s semantics exhibits the behaviour of our .c, eagerly substituting \nout bindings and leaving only the control structure (E1) to be captured. Another interesting connection \nis between abstract continua\u00adtions [FWFD88], as used by Queinnec [Que93], and the reduction contexts \nE3 used in our operational semantics. Each A1 or A2 cor\u00adresponds to a frame of the continuation, except \nthat the semantics of ACPS substitutes the A2 binding frames away. Gunter et al. [GRR95] have studied \n# and F in a typed setting. It is interesting to note that although they state a type safety result, \nthis does not exclude the possibility that a well-typed program can get stuck if an appropriate prompt \ndoes not exist (c.f. \u00a73.4). In the .marsh calculus, marks are named (not anonymous), are not bound, and \nare preserved by marshal/unmarshal operations. Some other choices have been investigated in the context \nof partial con\u00adtinuations by Moreau and Queinnec [MQ94, Que93]. Dynamic Linking Dynamic linking is a \nubiquitous simple form of dynamic binding, allowing program bindings to be resolved ei\u00adther at load-time \nor run-time, rather than statically. However, once dynamically bound, a variable s de.nition is .xed, \nprecluding re\u00adbinding for marshalling or update. Rebinding in Distributed Calculi A number of distributed \nprocess calculi provide implicit rebinding of names, adopting in\u00adteraction primitives with meanings that \ndepend on where they are used in a location structure [CG98, SV00, RH99, Sch02, SWP99, CS00]. This allows \na form of rebinding to application libraries, but these works do not address the problem of integrating \nthis rebind\u00ading with local functional computation. The JoCaml and Nomadic Pict languages for mobile computa\u00adtion \n[FGL+96, SWP99] provide rebinding to external functions, but the details are matters of implementation, \nnot semantically speci.ed though a more principled proposal for JoCaml has been made by Schmitt in a \nJoin-calculus setting [Sch02]. 5.3 Dynamic Update There are a number of implemented systems for dynamic \nupdating surveyed in [Hic01], notably including Erlang [AVWW96]. There is very little rigorous semantics, \nhowever. Duggan [Dug01] has a formal framework for updating types, but updating code is consid\u00adered only \ninformally, based on arguments around reference types. Gilmore et al. [GKW97, Wal01] have a formal description \nof up\u00addating, but it is centred on abstract types, and is tied to their par\u00adticular abstract machine. \nNeither of these systems properly handles updating .rst-class functions. Gilmore et al. require that \na function not be active when it is updated; closures in activation records are active, and cannot thus \nbe updated. Reference-based indirections require that the types of function arguments change in a way \nthat interacts poorly with polymorphism [Hic01]. 6. Conclusions and Future Work We have established a \nclean semantic foundation for dynamic re\u00adbinding and update. In particular, we reconciled the dynamic-rebinding \nneed for delayed instanti\u00adation with standard CBV semantics via novel redex-time and destruct-time reduction \nstrategies;  introduced the .marsh calculus, providing core mechanisms for dynamic rebinding of marshalled \nvalues, with a clean destruct-time operational semantics, and argued that our de\u00adsign choices are appropriate \nfor a distributed programming language;  showed how to extend .marsh with communication and exter\u00adnal \nfunctions, to express dynamic rebinding and secure en\u00adcapsulation of transmitted code; and  demonstrated \nthat dynamic update of programs with higher\u00adorder functions can be expressed using similar mechanisms, \nby introducing the .update calculus again with a simple destruct-time semantics.  There are several \ndirections that are worth pursuing. Part of the motivation for this work is to cope with marshalling \nof values in distributed functional languages, but this paper does not deal with issues of type coherence \nbetween separately-compiled run-times. One might combine .io marsh with the hash types of [LPSW03]. The \n.io calculus has communication on channels but not p\u00ad marsh calculus-style new channel generation. Adding \nthese is an inter\u00adesting problem, as the usual p semantics allows scope extrusion of new-binders but \nfor marshal/unmarshal we require a semantics that preserves the shape of the binding environment outside \nmarks. This paper has focussed on semantics for small calculi, but ulti\u00admately dynamic rebinding mechanisms \nshould be integrated with full-scale programming languages. For ML-like languages with second-class module \nsystems it may be natural to have mark only at the module level (loosely analogous to the allowing marks \nonly between top-level .marsh lets). Generalising, one might wish to marshal/unmarshal with respect to \na set of structures rather than a single mark. Libraries may need careful design to work well with mobile \ncode, to delimit any hard-to-move OS or library state. There are obvious problems with optimised implementation \nof calculi with redex-or destruct-time semantics, as dynamic rebinding or update primitives invalidate \ngeneral use of standard optimisations, e.g., inlining, and perhaps also environment-sharing schemes. \nFor performance it will be important to identify conditions under which such optimisations are still \nvalid perhaps via a characterisation of contextual equivalence for .marsh. A full implementation should \nobviously be carried out. Finally, for dynamic update the .update calculus is only the begin\u00adning of \na rigorous treatment. The full story must address correct\u00adness of updates with state transformation, \nabstract types, changing the types of variables, multi-threading, and so on. Acknowledgments We acknowledge \nsupport from a Royal Society University Research Fellowship (Sewell), a Marconi EPSRC CASE Studentship \n(Stoyle), EPSRC grant GRN24872 (Wansbrough), AFRL-IFGA IAI grant AFOSR F49620-01-1-0312 (Hicks, while \nat Cornell University), EC FET-GC project IST\u00ad2001-33234 PEPITO, and APPSEM 2. 7. REFERENCES [ACCL90] \nMart\u00edn Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques L\u00e8vy. Explicit substitutions. In Proc. \n17th POPL, pages 31 46, 1990. [AFM+95] Zena M. Ariola, Matthias Felleisen, John Maraist, Martin Odersky, \nand Philip Wadler. A call-by-need lambda calculus. In Proc. 22nd POPL, pages 233 246, 1995. [AVWW96] \nJoe Armstrong, Robert Virding, Claes Wikstrom, and Mike Williams. Concurrent Programming in Erlang. Prentice \nHall, 1996. 2nd ed. [BHS+03] Gavin Bierman, Michael Hicks, Peter Sewell, Gareth Stoyle, and Keith Wansbrough. \nDynamic rebinding for marshalling and update, with destruct-time .. Technical Report 568, University \nof Cambridge Computer Lab, June 2003. http://www.cl.cam.ac.uk/~pes20/. [BHSS03] Gavin Bierman, Michael \nHicks, Peter Sewell, and Gareth Stoyle. Formalizing dynamic software updating. In Proc. 2nd International \nWorkshop on Unanticipated Software Evolution (USE 2003), April 2003. [CG98] Luca Cardelli and Andrew \nD. Gordon. Mobile ambients. In Proc. 1st FoSSaCS, LNCS 1378, pages 140 155, 1998. [CS00] Tom Chothia \nand Ian Stark. A distributed pi-calculus with local areas of communication. In Proc. 4th HLCL, ENTCS \n41.2, 2000. [Dam98] Laurent Dami. A lambda-calculus for dynamic binding. Theoretical Computer Science, \n192(2):201 231, 1998. [Dug01] Dominic Duggan. Type-based hot swapping of running modules. In Proc. 5th \nICFP, pages 62 73, 2001. [FF87] Matthias Felleisen and Daniel P. Friedman. Control operators, the SECD-machine, \nand the lambda calculus. In M. Wirsing, editor, Formal Description of Programming Concepts III, pages \n193 219. Elsevier North-Holland, 1987. [FGL+96] C\u00e9dric Fournet, Georges Gonthier, Jean-Jacques L\u00e9vy, \nLuc Maranget, and Didier R\u00e9my. A calculus of mobile agents. In Proc. 7th CONCUR, LNCS 1119, pages 406 \n421, 1996. [FH92] Matthias Felleisen and Robert Hieb. The revised report on the syntactic theories of \nsequential control and state. Theoretical Computer Science, 103(2):235 271, 1992. [FWFD88] Matthias Felleisen, \nMitchell Wand, Daniel P. Friedman, and Bruce F. Duba. Abstract continuations: A mathematical semantics \nfor handling full functional jumps. In ACM Conference on LISP and Functional Programming, Snowbird, Utah, \npages 52 62, July 1988. [Gar95] Jacques Garrigue. Dynamic binding and lexical binding in a transformation \ncalculus. In Workshop on Functional and Logic Programming, 1995. [GKW97] Stephen Gilmore, Dilsun Kirli, \nand Chris Walton. Dynamic ML without dynamic types. Technical Report ECS-LFCS-97-378, The University \nof Edinburgh, 1997. [GRR95] C.A. Gunter, D. R\u00e9my, and J.G. Riecke. A generalisation of exceptions and \ncontrol in ML-like languages. In Proc. FPCA, pages 12 23, 1995. [Hic01] Michael Hicks. Dynamic Software \nUpdating. PhD thesis, University of Pennsylvania, August 2001. [HO01] Masatomo Hashimoto and Atsushi \nOhori. A typed context calculus. Theoretical Computer Science, 266(1-2):249 272, 2001. [HY00] Masatomo \nHashimoto and Akinori Yonezawa. MobileML: A programming language for mobile computation. In COORDINATION, \nLNCS 1906, page 198 ff., 2000. [Jag94] Suresh Jagannathan. Metalevel building blocks for modular systems. \nACM TOPLAS, 16(3):456 492, May 1994. [LF93] Shinn-Der Lee and Daniel P. Friedman. Quasi-static scoping: \nSharing variable bindings across multiple lexical scopes. In Proc. 20th POPL, pages 479 492, 1993. [LLMS00] \nJeffrey R. Lewis, John Launchbury, Erik Meijer, and Mark Shields. Implicit parameters: Dynamic scoping \nwith static types. In Proc. 27th POPL, pages 108 118, 2000. [LPSW03] James J. Leifer, Gilles Peskine, \nPeter Sewell, and Keith Wansbrough. Global abstraction-safe marshalling with hash types. In Proc. ICFP \n2003, August 2003. [MIT] MIT Scheme. http://www.swiss.ai.mit.edu/projects/scheme/. [Mor98] Luc Moreau. \nA syntactic theory of dynamic binding. Higher-Order and Symbolic Computation, 11(3):233 279, December \n1998. [MQ94] Luc Moreau and Christian Queinnec. Partial continuations as the difference of continuations: \nA duumvirate of control operators. In Proc. PLILP, LNCS 844, pages 182 197, September 1994. [Nee93] R. \nM. Needham. Names. In S. Mullender, editor, Distributed Systems, pages 315 327. Addison-Wesley, Wokingham, \n2nd edition, 1993. [Que93] Christian Queinnec. A library of high level control operators. Lisp Pointers, \nACM SIGPLAN Special Interest Publ. on Lisp, 6(4):11 26, October 1993. [RH99] James Riely and Matthew \nHennessy. Trust and partial typing in open systems of mobile agents. In Proc. 26th POPL, pages 93 104, \n1999. [Sch02] Alan Schmitt. Safe dynamic binding in the join calculus. In Proc. IFIP TCS 2002, 2002. \n[SV00] Peter Sewell and Jan Vitek. Secure composition of untrusted code: Wrappers and causality types. \nIn Proc. 13th Computer Security Foundations Workshop, pages 269 284, 2000. [SWP99] Peter Sewell, Pawel \nT. Wojciechowski, and Benjamin C. Pierce. Location-independent communication for mobile agents: a two-level \narchitecture. In Internet Programming Languages, LNCS 1686, pages 1 31, 1999. [VF01] Jos\u00e9 Luis Vivas \nFrontana. Dynamic Binding of Names in Calculi for Mobile Processes. PhD thesis, KTH, Stockholm, March \n2001. [Wal01] Chris Walton. Abstract Machines for Dynamic Computation. PhD thesis, University of Edinburgh, \n2001. ECS-LFCS-01-425. Id: paper2.mng,v 1.96 2003/06/23 20:30:48 pes20 Exp Id: common.mng,v 1.92 2003/06/23 \n17:22:33 pes20 Exp Id: examples.mng,v 1.10 2003/04/05 10:11:26 pes20 Exp Id: related.mng,v 1.49 2003/06/23 \n20:30:48 pes20 Exp   \n\t\t\t", "proc_id": "944705", "abstract": "Most programming languages adopt static binding, but for distributed programming an exclusive reliance on static binding is too restrictive: dynamic binding is required in various guises, for example when a marshalled value is received from the network, containing identifiers that must be rebound to local resources. Typically it is provided only by ad-hoc mechanisms that lack clean semantics.In this paper we adopt a foundational approach, developing core dynamic rebinding mechanisms as extensions to simply-typed call-by-value ? -calculus. To do so we must first explore refinements of the call-by-value reduction strategy that delay instantiation, to ensure computations make use of the most recent versions of rebound definitions. We introduce <i>redex-time</i> and <i>destruct-time</i> strategies. The latter forms the basis for a ?<inf>marsh</inf> calculus that supports dynamic rebinding of marshalled values, while remaining as far as possible statically-typed. We sketch an extension of ? marsh with concurrency and communication, giving examples showing how wrappers for encapsulating untrusted code can be expressed. Finally, we show that a high-level semantics for dynamic updating can also be based on the destruct-time strategy, defining a ?<inf>marsh</inf> calculus with simple primitives to provide type-safe updating of running code. We thereby establish primitives and a common semantic foundation for a variety of real-world dynamic rebinding requirements.", "authors": [{"name": "Gavin Bierman", "author_profile_id": "81100249578", "affiliation": "University of Cambridge", "person_id": "PP39034558", "email_address": "", "orcid_id": ""}, {"name": "Michael Hicks", "author_profile_id": "81100060959", "affiliation": "University of Maryland, College Park", "person_id": "PP40023253", "email_address": "", "orcid_id": ""}, {"name": "Peter Sewell", "author_profile_id": "81100511814", "affiliation": "University of Cambridge", "person_id": "PP14177906", "email_address": "", "orcid_id": ""}, {"name": "Gareth Stoyle", "author_profile_id": "81100523612", "affiliation": "University of Cambridge", "person_id": "P639761", "email_address": "", "orcid_id": ""}, {"name": "Keith Wansbrough", "author_profile_id": "81100225284", "affiliation": "University of Cambridge", "person_id": "PP38023996", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944715", "year": "2003", "article_id": "944715", "conference": "ICFP", "title": "Dynamic rebinding for marshalling and update, with destruct-time ?", "url": "http://dl.acm.org/citation.cfm?id=944715"}