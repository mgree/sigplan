{"article_publication_date": "08-25-2003", "fulltext": "\n Software is Discrete Mathematics Rex L Page University of Oklahoma School of Computer Science Norman \nOK 73019 USA +1 405-325-5408 page@ou.edu ABSTRACT A three-year study collected information bearing \non the question of whether studying mathematics improves programming skills. An analysis of the data \nrevealed significant differences in the programming effectiveness of two populations of students: (1) \nthose who studied discrete mathematics through examples focused on reasoning about software and (2) those \nwho studied the same mathematical topics illustrated with more traditional examples. Functional programming \nplayed a central role in the study because it provides a straightforward framework for the presentation \nof concepts such as predicate logic and proof by induction. Such topics can be covered in depth, staying \nalmost entirely within the context of reasoning about software. The intricate complexities in logic that \nmutable variables carry with them need not arise, early on, to confuse novices struggling to understand \nnew ideas. In addition, because functional languages provide useful and compact ways to express mathematical \nconcepts, and because the choice of notation in mathematics courses is often at the discretion of the \ninstructor (in contrast to the notational restrictions often fiercely guarded by the faculty in programming \ncourses), discrete mathematics courses, as they are found in most computer science programs, provide \nan easy opportunity to enhance the education of students by exposing them to functional programming concepts. \n Categories and Subject Descriptors D.2.4 [Software Engineering]: Software/Program Verification correctness \nproofs, formal methods. K.3.2. [Computers and Education]: Computer and Information Science Education \n computer science education, curriculum. General Terms Design, Languages, Verification.  Keywords Functional \nprogramming, discrete mathematics, predicate logic, correctness proofs, formal methods, software engineering. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, or republish, \nto post on servers or to redistribute to lists, requires prior specific permission and/or a fee. ICFP \n03, August 25-29, 2003, Uppsala, Sweden. Copyright 2003 ACM 1-58113-756-7/03/0008 $5.00. 1. INTRODUCTION \nEducators have long argued about the value of mathematics in the study of computing. What the various \nparticipants in the argument mean by mathematics, while not firmly tied down, generally boils down to \nthe use of mathematical reasoning to prove theorems. In this sense, most computer science programs include \nvery little real mathematics. Students do not learn much about constructing proofs when they study infinitesimal \ncalculus for science and engineering, or when they study other mathematical subjects such as differential \nequations, linear algebra, statistical methods, and numerical analysis. Most computing programs require \ncourses in most of these topics, and in taking these courses students learn important methods for solving \ncertain kinds of problems, but they do not learn to construct mathematical proofs. They do not learn \nto think like mathematicians. Should they? Should computing students learn to think like mathematicians? \nIf so, why? To appreciate their cultural legacy? To support their study of computing? To make them more \nemployable? All of these reasons have value, but the argument often focuses on how the study of mathematics \naffects the practice of software development. Observations of such effects bring substance to the argument. \nOne of the goals of the Beseme Project (three syllables, all rhyming with eh ) is to provide observations \nof this kind.  2. PROJECT The Beseme Project offers educational material for courses in discrete mathematics \nor more specialized topics, such as mathematical logic, along with some evidence of the effectiveness \nof the material. Most of the usual topics of an elementary discrete mathematics course are discussed \nin the Beseme materials, with a special emphasis on the concept of mathematical proof. The lecture notes \nelucidate several dozen proofs, and homework projects and examination questions provide opportunities \nfor students to succeed in constructing their own proofs. The intent is for students to gain experience \nwith the thought processes of mathematicians. Because these thought processes apply in many problem areas, \nthere is a wide range of interesting examples to choose from, many of which can illustrate, equally well, \nthe basic ideas. Examples in the Beseme material come primarily from the realm of reasoning about properties \nof software artifacts. It happens that almost all of these software artifacts are expressed in the form \nof inductive equations. That is, they are functional programs, and that makes it possible for functional \nprogramming concepts to play a central role in the study of discrete mathematics. The project also provides \ndata about the performance of students who have studied the Beseme materials and compares their performance \nto that of students who have studied the same topics from another point of view. The data lends credence \nto the idea that studying real mathematics benefits the practice of software development, and that the \nbenefits are greater when students are allowed to see how the mathematical ideas they are studying apply \nto software artifacts. The topics covered in discrete mathematics courses are fairly standard: logic, \nsets, relations, functions, proof methods including induction, combinatorics, discrete probability, graphs, \ntrees, and recursion. Section 4 of this paper provides details about the coverage of these topics in \nthe Beseme materials. At the University of Oklahoma, where the Beseme Project has been conducted, discrete \nmathematics is a prerequisite for a course in data structures and algorithms. The data structures course \naddresses primarily implementation issues, and the course in discrete mathematics focuses on theoretical \nissues, with structures such as trees and graphs, and algorithmic concepts such as recursion figuring \nprominently in the coverage. One could view the discrete mathematics course as the theoretical framework \nfor the data structures course. Most of the work in the data structures course involves software development, \nand the grades students earn in this course depend heavily on their programming skills. For this reason, \nit seems reasonable to expect a correlation between effectiveness in software development and grades \nin the data structures course. One could use the data structures grades of students as estimates of their \nprogramming abilities. The discrete mathematics course is taught in two sections. For the past six semesters, \none of the sections has taken a traditional approach, as exemplified in the text of Rosen [12]. Here, \nfor example, proof by induction is used to verify number theoretic results, such as the formula for the \nsum of the first n natural numbers. Applications in the traditional course have a pure math flavor. When \nsoftware is discussed at all, projects call for writing small programs, not reasoning about them. The \nstudy of logic and proof by induction comprises about a third of the material, and none of it involves \nreasoning about software artifacts. The other two\u00adthirds concerns sets, combinatorics, probability, graphs, \nand trees, and the emphasis is on traditional aspects of these topics. Theorems about properties of trees \nwould be more likely choices for examples than, say, theorems about applications of trees in software \ncontexts, even though either choice might equally well illustrate the same mathematical concept. The \nother section of discrete mathematics, the Beseme section, reverses the ratio. Logic and proof by induction \ncomprise about two-thirds of the material, and the other topics about one-third. A variation in emphasis \nof this magnitude among the topics in a required course is not unusual at the university level. Different \ninstructors have different interests and ideas about the relative importance of topics. Their courses \nreflect those interests. In the Beseme course, almost every example in predicate logic and proof by induction \ninvolves reasoning about a software artifact, usually concerning a correctness-related property, but \nsometimes a property related to the software s use of resources. Beseme students study the traditional \nmathematical methods and concepts, but the examples they see as illustrations of these concepts come \nfrom a non-traditional collection. Students see many examples of software, and all but a few of them \nare expressed as functional programs. The programming language chosen for the project is Haskell, but \ncould just as well have been another language based on lambda calculus, such as ML, Scheme, or a host \nof others. The fact that the software artifacts used in these examples are functional programs is not \na primary point of emphasis. They are presented as inductive equations, and justified on the basis that \nany function meeting certain computational requirements would have to satisfy the equations. For example, \nmost students find it obvious that an operator (++) for concatenating two lists would have to satisfy \nthe following equations. (x : xs) ++ ys = x : (xs ++ ys) [ ] ++ ys = ys In these equations, colon (:) \ndenotes insertion of a new element at the beginning of a list, square brackets delimit lists (used here \nto denote the empty list), x stands for an element of a list, and xs and ys stand for arbitrary lists. \nThe equations express certain properties of concatenation, and they are used as a starting point to confirm \nother properties of the operation. The fact that the equations provide a complete definition of concatenation \nis not the main point. The objective is to explore properties that the equations entail. The focus is \nnot directly on programming, but the students see dozens of inductive definitions of this sort, and the \nidea that they act as complete definitions of functions in useful software gradually emerges. Students \ngain some facility with elementary functional programming concepts, and their interest is piqued. Some \nof them later complain in the data structures course about the gratuitous difficulty of implementing, \nin a language like C++, the simple ideas they learned in discrete mathematics. The software artifacts \nthat become targets for the application of the principles of logic in the Beseme section include definitions \nof many reduction operations, such as computing the sum of a list of numbers, Boolean logic operations \non lists, concatenation, list length, computing the maximum value in a list, and other reductions. They \nalso include sorting, exponentiation in logarithmic time, vector addition, inner product, sequence reversal, \nbuilding and searching AVL trees, and other important computations. There are significant differences \nbetween the Beseme and the traditional sections of the discrete mathematics course in terms of concepts \nemphasized, and even more significant differences in terms of examples used to illustrate the concepts. \nTherefore, the subsequent data structures course is taken by two different populations of students: those \nwho have studied discrete mathematics with an emphasis on reasoning about software (the Beseme group) \nand those who have seen a more traditional 2  Beseme Traditional 1 DSG GPA 0  Below-Median Students \nBeseme Traditional Avg GPA 2.90 2.93 Avg DSG 2.02 2.18 30% event not statistically significant  1.75 \n2.00 2.25 2.50 2.75 3.00 3.25  Above-Median Students Beseme Traditional Avg GPA 3.70 3.75 Avg DSG 3.76 \n3.49 2% event  statistically significant 3.50 3.75 4.00 Figure 1. Grade Point Average vs. Data Structures \nGrade for Beseme and Traditional Students collection of examples in their study of discrete mathematics \n(the traditional group). One might be able to assess some of the effects of the two approaches by comparing \nthe performance of these two groups of students in the data structures course. And, since the data structures \ncourse has a heavy programming component, one might reasonably interpret affects on performance in the \ndata structures course as effects on the programming skills of the students. This paper takes that point \nof view. That is, it uses grades in the data structures course as estimates of the programming skills \nof students. Claims in the paper about programming skills are, more precisely, claims about grades in \nthe data structures course.   3. STATISTICS A common statistical method for comparing the average values \nof two random variables is to compute Student s t statistic from the data and to check how far out in \nthe tails of its statistical distribution this measurement falls. Common standards call for rejecting \nthe hypothesis that the two random variables have the same average value (the null hypothesis ) when \nthe likelihood of the observed t-statistic (under the assumption that null hypothesis is true) is less \nthan 5%. The reliability of a statistical decision to reject the null hypothesis depends, in part, on \nthe sizes of the populations of the two groups being compared. When both groups have populations exceeding \n30, conclusions tend to be more consistently reliable than with smaller populations. On the average, \nabout eighty students per semester enroll in the data structures course at the University of Oklahoma. \nAbout two\u00adthirds of these students have taken the discrete mathematics course during the previous semester, \nand another ten to fifteen percent have taken it two or more semesters prior to enrolling in data structures. \nA small percentage of students gain the right to enroll in data structures without having taken the discrete \nmathematics course. These enrollment patterns mean that there is a lag of one or two semesters from the \ntime the students complete the discrete mathematics course to the time they complete the data structures \ncourse. Data presently available consists of the records of 144 students who have passed both courses. \nFigure 1 compares the performance of the Beseme and traditional groups. In this chart, student GPAs are \nplotted along the horizontal axis, and their grades in the data structures course are plotted along the \nvertical axis. GPAs are computed to three significant figures, but grades in data structures fall into \nonly five categories (A, B, C, D, and F), so there is much less resolution along the vertical axis than \nthe horizontal. Vertical bands in the chart contain data for students with similar GPAs. Not much can \nbe perceived from this presentation of the data, but statistical computations yield some interesting \nresults. It happens that the 144 students are evenly divided between the Beseme group and the traditional \ngroup. This makes it possible to divide both groups into two subgroups and still maintain adequate populations \nfor stable statistics within each of the resulting four subgroups. The 72 students in the database from \nthe traditional sections of discrete mathematics have an average GPA of 3.35 on a 4.00\u00adpoint scale. These \nGPAs are computed for individual students upon completion of the data structures course by averaging \nall the grades they earned at the university, weighting each grade by the number of credits awarded for \nthe course in which the grade was earned. A GPA of 4.00 indicates a grade of A in all classes taken by \nthe student. The 72 students in the Beseme group had an average GPA of 3.25. This was slightly lower \nthan the 3.35 of the traditional group, but the difference is not statistically significant according \nto the t-statistic criterion discussed earlier. Those are the average GPAs. With regard to the median, \nhalf of the 144 students in the database had a GPA exceeding 3.42. The average grade earned in the data \nstructures course by the 144 students in the database was 2.81 on a 4.00-point scale. The average data \nstructures grade for the 72 students in the traditional group was 2.84, compared to 2.79 for the 72 Beseme \nstudents. This difference, like the difference in average GPAs for the two groups, is not statistically \nsignificant. However, when the groups are divided into subgroups of more uniform ability (as estimated \nby GPA), statistical analysis yields more definitive conclusions. Of the better half of the students, \nthat is the 73 students with GPAs exceeding the median grade of 3.42, there were 39 from the traditional \ngroup and 34 from the Beseme group. The average GPA of the 39 above-median traditional students was 3.75. \nThat figure for the Beseme students was 3.70, which is a little lower than the traditional group, but \nit is not a statistically significant difference. This means that the innate talent of the students in \nthe two groups can be regarded as about the same. The above-median students in the traditional group \nhad an average grade in the data structures course of 3.49, compared with 3.76 for the above-median students \nin the Beseme group. According to the distribution of the t-statistic, there is less than a 2% likelihood \nthat a difference this large would occur if the two groups represented samples from statistical populations \nwith the same average grade in data structures. Furthermore, since the students in this data set all \nhad grade point averages exceeding 3.42, one would be very surprised if the average grade in data structures \nfell below 3.00. Since the probable range of the average is 3.00 to 4.00, the observed difference in \nthe averages of the two groups, 0.27, seems significant in an intuitive sense. A reasonable statistical \ninterpretation of this result would be to reject the null hypothesis that the observations come from \nrandom variables with the same average. This means that one can, at a confidence level of 98%, accept \nthe alternative that the better performance of the above-median students in the Beseme group is an effect \narising from differences in the groups, not a random event. Using the data structures grade as an estimate \nof software development skills, as discussed earlier, one would interpret this to mean that Beseme students \nbecome better software developers than traditional students. The average data structures grade for the \nbelow-median Beseme students was 2.02. Their average GPA was 2.90. This compares with an average data \nstructures grade of 2.18 for the traditional students, who had an average GPA of 2.93. The distribution \nof grades in data structures for below-median students is more spread out than for above-median students. \nBecause of the higher variance and the smaller difference between the average grades of the two groups, \nthe difference is not significant statistically. That is, it is not a large enough difference to reject \nthe null hypothesis at the 5% level. It is, in fact, a 30% event, which places it near the middle of \nthe distribution, so it seems likely to be a random effect. What factors explain the differences in the \nsoftware development success of Beseme students compared with students of comparable talent in the traditional \ngroup? Three factors that might contribute to the observed differences include: material studied in \ndiscrete mathematics  effectiveness of the discrete math instructor  innate talent of individual students \n With regard to innate talent, the average GPA of the Beseme students is slightly below that of the \ntraditional students. The two groups are, apparently, more or less the same in terms of innate talent. \nSo, innate talent is not a convincing explanation of the difference. How about the instructor factor? \nAs the instructor for the Beseme sections of discrete mathematics, I would like to claim instructor effectiveness \nas a reason for the better performance of the above\u00admedian Beseme students in the data structures course. \nHowever, students think otherwise. Near the end of each semester, students complete a questionnaire giving \ntheir assessment of various aspects of the quality of instruction. Their overall ratings of my teaching \neffectiveness in the discrete mathematics course averaged 2.17 on a 4.00-point scale (4.00 being the \nbest rating). The ratings of the instructors for the traditional sections averaged 2.83. Many instructors \nbelieve that student assessments of the performance of instructors are strongly influenced by the grades \nthey award to students. This view holds that students will give better evaluations to instructors who \naward higher grades. The average grade awarded in discrete mathematics to the Beseme students was 2.83, \ncompared with 2.96 for the traditional students. This difference falls near the middle of the distribution \nof the t\u00adstatistic. It is insignificant, statistically probably a random event. So, grading effects \ndo not appear to explain the difference in instructor ratings. I have to accept the fact that students \nregard me as a less effective instructor than other members of the faculty who teach discrete mathematics. \nIt s a bitter pill, but it means that the instructor effect fails to stand as a convincing explanation \nof the relative performance in the data structures course of students in the Beseme group compared with \nstudents in the traditional group. That leaves course content in discrete mathematics as the primary \nsuspect in the investigation of factors contributing to the better performance of Beseme students in \nthe software development tasks required in the data structures course. Many explanations are possible, \nbut this analysis suggests low credibility for the influence of two of them (innate student ability and \ninstructor effectiveness). It seems reasonable to accept course content as an important factor contributing \nto the software development success of Beseme students. 4. MATERIAL The Beseme course materials include \nover 350 animated slides. Many of the slides seem busy when viewed in isolation, at the end of the animation \nsequence, but the animation steps add information gradually, so that a step-by-step presentation can \nproceed at a comfortable pace. A typical slide, presented at a prudent pace through the animation sequence, \nwith time for interactions with students along the way, takes five to ten minutes to discuss in a lecture. \nThe materials also include examinations (over 150 exam questions in all, with solutions), more than a \nhundred homework exercises and solutions, lesson plans, reading assignments, and software that checks \nproofs in propositional logic for correctness. (This software is an extension of tools provided with \na textbook by Hall and O Donnell [7]). All of the Beseme course materials are available to instructors \nthrough the Beseme website [9]. The website is password protected in the hope that instructors will feel \ncomfortable using the materials in their courses. Selected materials may be viewed without a password \nand are provided to help instructors decide whether to request access to the full website. In the Beseme \ncourse, all examples illustrating proof by induction are chosen from the realm of properties satisfied \nby software artifacts. Most of the analyzed properties confirm relationships between function inputs \nand results (that is, correctness issues). For example, early examples discuss properties of concatenation \nof lists, such as length-conservation and associativity. Later exam\u00adples include verifying that a key \npresent in an AVL tree will be found through binary search, with dozens of other examples in between. \nSome examples discuss termination and performance properties. Those include, among other things, the \nlogarithmic performance of the Russian peasant algorithm for exponentiation, the n log(n) performance \nof merge-sort, and the logarithmic performance of AVL tree insertion. In all, over two-dozen proofs by \ninduction are carried out in lectures, and dozens more are required in homework and exams, all of which \nconcern properties of software artifacts. About a third of these proofs use ordinary mathematical induction, \n(P(0) . .n.P(n).P(n+1)) . .n.P(n), to verify that if a piece of software satisfies a few given equations, \nit must also have certain other desirable properties, which are stated in the theorem being proved. Another \nthird of the examples rely on strong induction, (.n.(.m < n.P(m)).P(n)) . .n.P(n). Induction on tree \nstructures, and a form of induction on loops based on Floyd-Hoare logic are also illustrated in lectures, \nhomework problems and exam questions. Most of these examples involve reasoning based on a few equations \nthat comprise an inductive definition of a function. The function might be selection of the maximum value \nin a sequence or merging two sequences, or some other useful computation. Proofs by induction are used \nto show that a function satisfying a few basic equations must also have other important properties. The \nbasic equations of an inductive definition are presented as reasonable properties that any function with \nthe intended purpose would have to satisfy if it worked properly. The concatenation function mentioned \nin Section 2 provides an example. The basic equations that concatenation satisfies are repeated here \nwith labels to facilitate referring to them in proofs. (x : xs) ++ ys = x : (xs ++ ys) {++ :} [ ] ++ \nys = ys            {++ [ ]} As noted before, the fact that these equations happen to form \na complete definition of concatenation is not the main point. In fact, it is hardly mentioned. The goal \nis to show, through the application of logic, that the properties specified in these equations imply \nother properties of the concatenation operation, such as length conservation, associativity, etc. One \napproach to verifying properties implied by these equations relies on induction over list structures. \nHowever, ordinary induction over the natural numbers can also be used, at least when the lists involved \nhave finite length. Ordinary mathematical induction happens to be the topic of study at the time these \nequations appear in the Beseme course, so that is the method used to prove properties of concatenation. \nThe following sketch of a proof along these lines illustrates the approach taken in the Beseme materials. \nPrior to discussing the associativity of concatenation, a length conservation property is proved: length(xs \n++ ys) = length xs + length ys Associativity is then proved through induction on the length of xs in \nthe equation expressing associativity: xs ++ (ys ++ zs) =(xs ++ ys) ++ zs The inductive case in the proof \nof associativity shown in Figure 2 makes use of equational reasoning. Reasons justifying each step in \nthe sequence of equations are noted on the right-hand side of the figure. The argument applies in the \ncase when the leftmost operand is nonempty. The proof for an empty leftmost operand is shorter. It consists \nof two applications of the {++ [ ]} equation, with no need to cite the induction hypothesis. In the Beseme \nmaterials, most proofs of properties derived from inductive definitions make use of syntax-driven substitution \nin equations as illustrated in this example. (x: xs) ++ (ys ++ zs) = x: (xs ++ (ys ++ zs)) {++ :} = x: \n((xs ++ ys) ++ zs) induction hypothesis = (x: (xs ++ ys)) ++ zs             {++ :} = ((x: \nxs) ++ ys) ++ zs            {++ :} Figure 2. Associativity of Concatenation, Inductive Case \nMost students are familiar with reasoning based on equations from their experience in high-school algebra. \nThis much comes to them easily. In fact, one of the few examples in the course that does not involve \na piece of software is a proof that the product of two negative numbers is a positive number. This proof \nserves to introduce the idea of equational reasoning, and it has a profound effect. Most students have \nno idea why negative-times-negative is positive, and they are delighted to learn that this rule is only \na few equations away from more basic rules of arithmetic such as the associative and distributive laws. \nThey see from this example how a formal argument based on equations can be constructed, and they learn \nto apply this idea with new equations and strange operations like list-insertion and concatenation, just \nas they formerly applied the ideas with more familiar operations, such as the addition and multiplication \nof numbers. What does not come so easily to most students is the idea of proof by induction. This takes \na lot of thinking and experience, and that is why the concept is presented in four guises (ordinary, \nstrong, tree, and loop) with a couple dozen examples in lectures, and many more than that in homework \nand exams. Gradually, students begin to grasp both induction and the idea of formal proof based on syntactic \nsubstitution in equations. Equational reasoning and proof by induction comprise about thirty-five percent \nof the Beseme material, but it is not the only basis for reasoning that the students see. About thirty \npercent of the material focuses on natural deduction with Gentzen-style inference rules in propositional \nand predicate logic. Software involving mutable variables provides another way for the students to gain \nexperience in the process of conjuring up proofs, in this case relying on a form of induction for looping \nsoftware based on Floyd-Hoare logic. A little less than ten percent of the material is devoted to this \ntopic. The different forms of induction reinforce each other. Students end up getting a lot of experience \nwith inductive reasoning, and it helps them understand other concepts related to induction, such as recursion, \nnumeric recurrence equations, and loop invariants. The basic operations of set theory (union, intersection, \ndifference, power sets, and so on) are discussed along with proofs about properties of sets. Functions \nand relations are discussed in set theoretic terms, along with special attributes (injective, surjective, \nreflexive, symmetric, transitive, etc.) and analytic tools (image, inverse image, etc.). These ideas \ncomprise about fifteen percent of the lecture material, and they emerge repeatedly in other parts of \nthe course, usually in a software context. The idea of comparing asymptotic rates of growth (f = O(g)) \nhelps describe algorithmic complexity, and several examples in this area serve to illustrate the estimation \nof algorithmic performance and solving recurrence equations. This coverage comprises a little more than \nten percent of the material. sL(T u h uL (T v i vL vR)) T v j (T u k uL vL) vR j = 1 + max k (ht vR) \nk = 1 + max (ht uL) (ht vL) Of the traditional list of topics in discrete mathematics courses (logic, \nsets, relations, functions, proof methods including induction, combinatorics, discrete probability, graphs, \ntrees, and recursion), only probability is entirely missing from the Beseme materials, although combinatorics \ngets short shrift. This is only fifteen-week, three-credit course, after all. Because most of the software \nartifacts presented to illustrate the use of logic in the Beseme course are expressed in the form of \ninductive equations, they tend to be short. Most of them are two or three lines long. They exceed six \nlines in only one case. That case is AVL tree insertion. The equations for AVL tree insertion cover eleven \nlines. They are short lines. They fit on a standard slide to be displayed with an ordinary video projector. \nThey are readable from the back of the room, so they use large print, which means that the lines have \nto be short. AVL tree insertion is more complicated than concatenation. However, there is a straightforward, \nentirely formal (that is, mechanical) translation of the usual rotation diagrams into inductive equations. \nThe simple case for left rotation is illustrated in Figure 3. The equations in this figure use a tree \nconstructor T, which builds a tree from its root key, height, and left and right subtrees. (T is too \ncryptic. The Beseme presentation uses more descriptive names. Shorter names are used here to make the \nequations fit in one column of the required document style.) The function ht in these equations extracts \nthe height component from a tree structure. Since the more complex rotations amount to a composition \nof simple rotations, they are equally easy to derive from diagrams. Given this information, and an understanding \nof how to use left and right rotation (l and r) to ensure AVL balancing, most students can derive the \nfive-case equation for AVL tree insertion (^:) shown in Figure 4. z ^: (T u h uL uR) = if z < u &#38;&#38; \n(ht vL) <= (ht uR)+1 then T u i vL uR else if z < u &#38;&#38; (ht vL) > (ht uR)+1 then r(T u i vL uR) \nelse if z > u &#38;&#38; (ht vR) <= (ht uL)+1 then T u j uL vR else if z > u &#38;&#38; (ht vR) > (ht \nuL)+1 then l(T u j uL vR) else error key already present where vL = z ^: uL i = 1 + max (ht vL) (ht uR) \nvR = z ^: uR j = 1 + max (ht uL) (ht vR) Figure 4. AVL Tree Insertion Induction on AVL trees (yet another \nkind of induction) is used to verify that a tree that is balanced before insertion remains balanced after \ninsertion, that the time required for insertion is proportional to the height of the tree, and that the \nnumber of nodes in a balanced tree is exponential, compared with its height. This leads to the conclusion \nthat AVL insertion requires computation time proportional to the logarithm of the number of keys in the \ntree. Recurrence equations needed for these arguments match the structure of the inductive equations \nfor insertion. Inductive equations are common in mathematics, and the fact that these happen to be presented \nwithin the syntax of a programming language might be viewed as more-or-less incidental. In practice, \nhowever, it is more than incidental because students can run programs directly from the equations. They \nalso begin to see how significant pieces of software can be constructed from inductive equations. That \nis, they acquire some experience with functional programming. It occurs as if by osmosis, but statistical \nanalysis of the Beseme data suggests that it has a significant, positive effect, at least on the upper \nhalf of the students. 5. RELATED AND FUTURE WORK The Beseme Project is one of many efforts emphasizing \nthe use of logic in software development. Dean and Hinchey [3] edited acollection of papers presenting \nprojects with goals related to those of the Beseme Project. There are also several textbooks that, to \nvarying extents, discuss applications of logic to reasoning about software ([2], [4], [5], [6], [7], \n[8]). The TeachLogic Project [1] based at Rice University is developing materials similar to those of \nthe Beseme Project, using Scheme as the notation for inductive definitions instead of Haskell, which \nis the notation used in the Beseme Project. The TeachLogic Project aims to provide two- to four-week \nmodules that can be used in mainstream computing courses, such as programming languages, databases, artificial \nintelligence, and discrete mathematics, while the Beseme project focuses on an extensive treatment in \none of these areas. Both projects share the goal of presenting logic to students in the context of software \ndevelopment. The Beseme Project has, so far, assessed results only in terms of grades in the data structures \ncourse. As the students progress further through the curriculum, it will be interesting to see if a larger \npattern of effects can be observed by looking at grades in other courses. Part of the motivation of the \nBeseme Project is to provide materials that can help instructors introduce functional programming to \nstudents in ways that can benefit them. The expectation would be that students with this background might \nbe inclined to make use of it later, and that might lead to substantial improvements in software quality. \nBarriers to the use of functional programming for developing software in industry are not as high as \nmany suppose. Many software development groups have license to choose their implementation tools [10]. \nSupport for functional programming in terms of libraries and communication with other software is manageable \nin a practical way for many projects. So, why don t software developers choose functional languages more \noften for their projects? There are many answers to this question [13], one of which is that only a tiny \npercentage of software developers receive any serious exposure to functional programming in their education. \nWhat they are unfamiliar with, they are unlikely to choose. The Beseme Project provides at least a little \nmaterial to fill some gaps. It is part of a larger plan that envisions a core curriculum for a programming-oriented \nbaccalaureate that might be dubbed hard-core software engineering. Dictionaries and engineering organizations \ndefine engineering as the use of mathematics and science to design useful artifacts. A straightforward \nextension of this definition would imply that software engineering is the use of mathematics and science \nto design software. However, that is neither the general understanding of the term software engineering, \nnor does it well describe the usual practice of software engineering. The hard-core software engineering \ncurriculum will appeal to those who think software engineering would be better practiced if it, like \nother engineering disciplines, consisted primarily in the application of mathematical principles to the \ndesign of useful artifacts, which in this case would be software rather than bridges or radios or other \nuseful things. A software engineering program at McMaster University [11] has similar goals to those \nof the program envisioned as an extension of the Beseme Project. In the Beseme version of this approach, \nsix courses occurring in three, closely coupled pairs, would form the core of the curriculum. Within \neach pair, there would be a mathematics course and a programming course. Students would enroll in the \ntwo courses during the same term, and the material of each of the courses would complement that of the \nother. All of the mathematics would be illustrated in terms of the software concepts being discussed \nin the programming course, and all of the ideas in the programming course would be explained in terms \nof the principles being discussed in the mathematics course. The first pair would be a functional programming \ncourse, together with a discrete mathematics course along the lines of the Beseme materials. The second \npair would cover aspects of graph theory and abstract algebra in the mathematics component, and would \ncover data structures in the programming component, using, initially, functional programming, but gradually \nintroducing conventional programming techniques. The third pair of courses would cover a formal model \nfor concurrency, such as Milner s pi calculus, in the mathematics component, and would cover the design \nand architecture of operating systems in the programming component. The programs in the operating systems \ncourse would be written in a conventional programming language. These six courses would form a basis \nfor the rest of the computing curriculum, which could consist of a selection of more-or-less standard, \nupper division, computer science courses. The core courses would place students on a firm footing for \ntheir study of the software enterprise, including both the theoretical and the practical aspects of computing. \nThe program is envisioned as a software-oriented one, and the degree title software engineering seems \nappropriate, even if the core material does not have the generally accepted shape of software engineering \nas commonly understood and practiced. The first integrated pair, discrete mathematics and introductory \nfunctional programming, is scheduled to be offered at the University of Oklahoma in the coming academic \nyear. Progress on the other two pairs awaits the time and energy required for their development, and \ndepends, in part, on success in the delivery of the first pair. 6. CONCLUSION The Beseme Project has \ndelivered a body of materials for courses in discrete mathematics. The materials include lecture notes, \nlesson plans, reading assignments, homework (and solutions), exam questions (and solutions), and software \ntools that have been tested across six semesters of use in the classroom. The material focuses on reasoning \nabout software, and most of that software is expressed using the functional programming paradigm. The \napproach provides an example of exposing students to functional programming concepts at a point in the \ncurriculum that provides an excellent, but often overlooked, target of opportunity. Functional programming \nis a crucial element in the process. Without it, things get too complicated, too fast, and students tend \nto miss the point. Functional programming provides a context in which student interest remains high as \nthe course progresses and in which most students can succeed. Beseme Project results support the conjecture \nthat experience in the direct application of logic to reasoning about software leads to increased effectiveness \nin the practice of software development. A statistical analysis of data on student performance in software \ndevelopment projects indicates that students whose educational background includes experience in applying \nmathematical logic to the problem of reasoning about properties of software get better grades in a subsequent, \nprogramming-intensive course than students who studied mathematical logic in more traditional contexts. \nThe data supports this conclusion at a 98% confidence level for students in the upper half of the distribution \nof academic talent. No statistically significant effect was observed for below-median students. This \noutcome was observed through data collected from a population of 144 students in two courses, one in \ndiscrete mathematics and the other in data structures. Half of the students studied discrete mathematics \nwith an emphasis on logic applied to reasoning about software, and the other half took a traditional \ndiscrete mathematics course. All of the students went on to study implementations of data structures \nin a course with a heavy software development component. Performance in the software development course \nwas used to estimate the software development abilities of the students. Fac\u00adtors such as innate academic \nability and the quality of instruction in the courses on which the study was based appear to have played \nno significant role in the outcome. A single study of the impact of particular choices of educational \nmaterials requires reinforcement from other quarters if it is to have an influence on computing education. \nIf the results of this study make it easier for other educators to introduce reasoning about software \nin their own courses, then the Beseme Project may contribute to the goal of better software engineering \nthrough mathematics education. 7. ACKNOWLEDGMENTS This material is based on work supported by the National \nScience Foundation under Grant No. EIA 0082849. Any opinions, findings and conclusions or recommendations \nexpressed in this material are those of the author and do not necessarily reflect the views of the National \nScience Foundation. I am grateful to John Canning for sharing in the design of the Beseme Project and \nthe writing of the proposal that led to funding, even though he was not able to join the project when \nit got underway. I am also grateful to Jeffrey Sharp, who wrote the software for the database of statistics \nused in this work, to Justin Beitelspacher, who maintained the database software and developed the Beseme \nwebsite, and to Shauna Singleton for entering the data and providing it to the research staff, stripped \nof all student identification information. Two students deserve credit for extending the proof-checking \nsoftware provided with the Hall-O Donnell textbook: Pierre Lemaire added the ability to cite proven theorems \nin proofs by natural deduction, and Jonathan Cast added the ability to check equational proofs, in addition \nto the support for natural deduction provided in the original software. Finally, I want to thank the \nreferees, all of whom made suggestions that improved the quality of this paper. 8. REFERENCES [1] Barland, \nI., Felleisen, M. Kolaitis, P., and Vardi, M. TeachLogic Project, http://www.cs.rice.edu/~tlogic [2] \nBroda, K. Eisenbach, S. Khoshnevisan, H., and Vickers, S. Reasoned Programming, Prentice Hall, 1994. \n[3] Dean, C., and Hinchey, M. (eds.) Teaching and Learning Formal Methods, Academic Press, 1996. [4] \nGrassman, W., and Tremblay, J-P. Logic and Discrete Mathematics: A Computer Science Perspective, Prentice \nHall, 1996. [5] Gries, D., and Schneider, F. A Logical Approach to Discrete Math, Springer-Verlag, 1993. \n[6] Hein, J. Discrete Structures, Logic, and Computability, 2nd Edition, Jones and Bartlett, 2003. [7] \nHall, C., and O Donnell, J. Discrete Mathematics with a Computer, Springer, 2000. [8] Huth, M., and Ryan, \nM. Logic in Computer Science: Modelling and Reasoning about Systems, Cambridge University Press, 2000. \n[9] Page, R. Beseme Project, http://www.cs.ou.edu/~beseme [10] Page, R. Functional programming ... and \nwhere you can put it, ACM SIGPLAN Notices 36, 9 (September 2001) 19-24. [11] Parnas, D. A software engineering \nprogram of lasting value, in Proceedings of AMAST 2000 (Iowa City IA, May 2000), Lecture Notes in Computer \nScience 1816, Springer, 2000. [12] Rosen, K. Discrete Mathematics and Its Applications, McGraw-Hill, \n1999. [13] Wadler, P. Why no one uses functional languages, ACM SIGPLAN Notices 33, 8 (August 1998) 23-27. \n  \n\t\t\t", "proc_id": "944705", "abstract": "A three-year study collected information bearing on the question of whether studying mathematics improves programming skills. An analysis of the data revealed significant differences in the programming effectiveness of two populations of students: (1) those who studied discrete mathematics through examples focused on reasoning about software and (2) those who studied the same mathematical topics illustrated with more traditional examples. Functional programming played a central role in the study because it provides a straightforward framework for the presentation of concepts such as predicate logic and proof by induction. Such topics can be covered in depth, staying almost entirely within the context of reasoning about software. The intricate complexities in logic that mutable variables carry with them need not arise, early on, to confuse novices struggling to understand new ideas. In addition, because functional languages provide useful and compact ways to express mathematical concepts, and because the choice of notation in mathematics courses is often at the discretion of the instructor (in contrast to the notational restrictions often fiercely guarded by the faculty in programming courses), discrete mathematics courses, as they are found in most computer science programs, provide an easy opportunity to enhance the education of students by exposing them to functional programming concepts.", "authors": [{"name": "Rex L. Page", "author_profile_id": "81100469073", "affiliation": "University of Oklahoma, Norman, OK", "person_id": "PP40027591", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944713", "year": "2003", "article_id": "944713", "conference": "ICFP", "title": "Software is discrete mathematics", "url": "http://dl.acm.org/citation.cfm?id=944713"}