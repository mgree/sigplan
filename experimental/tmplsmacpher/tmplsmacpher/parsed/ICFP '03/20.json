{"article_publication_date": "08-25-2003", "fulltext": "\n A Static Type System for JVM Access Control* Tomoyuki Higuchi School of Information Science Japan Advanced \nInstitute of Science and Technology Tatsunokuchi Ishikawa, 923-1292 Japan thiguchi@jaist.ac.jp Atsushi \nOhori School of Information Science Japan Advanced Institute of Science and Technology Tatsunokuchi Ishikawa, \n923-1292 Japan ohori@jaist.ac.jp Abstract This paper presents a static type system for JAVA Virtual \nMachine (JVM) code that enforces an access control mechanism similar to the one found, for example, in \na JAVA implementation. In addition to verifying type consistency of a given JVM code, the type sys\u00adtem \nstatically veri.es that the code accesses only those resources that are granted by the prescribed access \npolicy. The type system is proved to be sound with respect to an operational semantics that enforces \naccess control dynamically, similarly to JAVA stack in\u00adspection. This result ensures that well typed \ncode cannot violate access policy. The paper then develops a type inference algorithm and shows that \nit is sound with respect to the type system and that it always infers a minimal set of access privileges. \nThese results allows us to develop a static system for JVM access control without resorting to costly \nruntime stack inspection. Categories and Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions \nand The\u00adory; D.3.2 [Programming Languages]: Language Classi.ca-tions Macro and assembly languages, Object-oriented \nlanguages; D.4.6 [Operating Systems]: Security and Protection access con\u00adtrols, authentication General \nTerms Languages, Security, Theory, Veri.cation  Keywords JVM, access control, stack inspection, type \nsystem, type inference * The authors was partially supported by Grant-in-aid for sci\u00adenti.c research \non priority area informatics A01-08, grant no:15017239. The second author was also partially supported \nby Grant-in-aid for scienti.c research (B), grant no:15300006. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 03, August 25 29, 2003, Uppsala, Sweden. \nCopyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00 1 Introduction Access control is a mechanism to prevent \nan unauthorized agent (or principal) from accessing protected resources. This has tradi\u00adtionally been \nenforced by monitoring each user s resource access requests dynamically in a resource server, typically \nin an operat\u00ading system. This simple strategy has been based on the assumption that the semantics of \na program code the user executes is transpar\u00adent to the user, and therefore resource access requests \nissued by the code re.ect the user s intention. This assumption no longer holds in the recently emerging \nnetwork computing environment, where a program code to be executed is dynamically composed from vari\u00adous \npieces downloaded from not necessarily trusted foreign sites. To deal with this situation, we need to \ndevelop code-level access control, where an unauthorized principal is not some other user but some untrusted \npiece of code, and whether a principal has some access privilege or not is a property of some portion \nof the code. This requires us to develop a veri.cation system for the property of low-level code. This \nproblem has recently attracted attentions of the researchers and developers, and several veri.cation \nsystems have been proposed and developed. Among them, the most notable one is perhaps the JAVA access \ncontrol system [8] (implemented in JDK1.2 and later.) In this system, each class (consisting of a set \nof methods) is owned by some principal, and each principal is assigned a set of privileges that is granted \nto the principal. In order to enforce access control, the implementer of the code explicitly inserts \na call of special static method checkPermission before accessing protected resources. This static method \nchecks that the principal associated to the current calling code has the required privilege under the \ncurrent execution environment. Since method calls are in general nested, and the ac\u00adcess requests issued \nby some method should be regarded as those of calling methods, it traverses the current frame stack to \nensure that all the calling methods have the required access privileges. This process is known as stack \ninspection. As we shall review later, the JAVA access control system also provides a mechanism for trusted \ncode to gain privileges even when the calling method does not have these privileges. Various formal properties \nof this approach have been studied and ef.cient implementation methods have been proposed. Karjoth [7] \nhas presented a formal operational semantics as a transition relation on abstract machine states. Wallach, \nAppel and Felten [16, 15] and Banerjee and Naumann [2] have provided denotational and logical account, \nrespectively. Fournet and Gordon [3] have studied seman\u00adtic properties of a program performing stack \ninspection. With these efforts, this JAVA-style stack inspection approach has become one of most important \ncode-level access control methods. There are however some weaknesses that are inherent in this ap\u00adproach. \nOne is its high runtime overhead due to dynamic inspec\u00adtion of the entire call stack. This method also \nmakes some pro\u00adgram optimization dif.cult or impossible to apply due to the need of maintaining a call \nstack. To reduce the run-time overhead, Wal\u00adlach, Appel and Felten [16, 15] have analyzed the stack inspection \nsemantics, and proposed an alternative method, called a security\u00adpassing style approach. Instead of inspecting \nthe entire call stack, this method explicitly passes security information as extra param\u00adeters so that \nthe called method can verify access privileges. This could be a potentially more ef.cient alternative \nto stack inspec\u00adtion. Since this method does not assume any runtime architecture, it would also be more \namenable to various optimization. Erlings\u00adson and Shneider [10] have reported implementation experiences \nincluding one for security passing style. Despite these advantages, it still incurs non-trivial runtime \noverhead for passing extra security information, which could potentially be large. Another and perhaps \nmore serious weakness of the stack in\u00adspection approach is that the programmer must explicitly call checkPermission \nmethod before accessing protected resources. The apparent problem of this strategy is that some programmer \nmight fail to insert all the appropriate calls, or malicious one would intentionally left out some of \nthe necessary calls. The security\u00adpassing approach [15] also share this weakness. As we have noted above, \ncode-level access control is a veri.cation system for security property of code. As such, it should ideally \nbe a proof system that veri.es the desired properties of code stat\u00adically from the given code itself \nwithout relying on practice of the programmer. Based on this insight, Skalka and Smith [13] have developed \na static type system of code-level access control for a variant of the lambda calculus by re.ning the \nstatic type system of the lambda calculus with access privilege information. They have proved the soundness \nof the type system, which ensures that a well typed program will not cause security violation. Pottier, \nSkalka, and Smith [4] further re.ned its type system. Banerjee and Naumann [1] have de.ned a denotational \nsemantics for a language similar to the calculus considered in [13, 4], which provides another assur\u00adance \nof the safety of this type-based approach. However, since the target language is the lambda calculus \nand their development relies on properties of a static type system of the lambda calculus, it is not \nclear whether or not this approach can be applicable to low-level code languages including the JVM bytecode \nlanguage [12]. The goal of the present work is to establish a static type system for code-level access \ncontrol of the JVM bytecode language, and show that it is correct with respect to a standard model of \nJVM ex\u00adecution. We base our development on our earlier work [5], where we have shown that the JVM language \ncan be regarded as a typed term calculus based on a proof theory for low-level code [6]. In this formalism, \nthe type system represents static semantics of a code language as a type system of the lambda calculus \ndoes. This prop\u00aderty allows us to transfer the concepts and methods developed for the lambda calculus \nin [13] to the JVM bytecode language. We de\u00ad.ne a type system with access control information for the \nJVM lan\u00adguage, and establish its soundness with respect to an operational se\u00admantics which closely models \nthe JAVA access control using stack inspection. For this type system, we develop a type inference al\u00adgorithm. \nThese results allow us to develop a static access control system that automatically detects all the possible \naccess violation statically from a given code, and infers the minimal set of privi\u00adleges required to \nexecute the code. Since the type system examines each resource access directly through method invocation \ninstruc\u00adtions, explicit insertion of checkPermission is unnecessary. This property makes our system more \nreliable than those based on ex\u00adplicit library calls by the programmer, and it can also be used for verifying \nun-trustworthy and potentially malicious code. A proto\u00adtype type inference algorithm has been implemented, \ndemonstrat\u00ading the feasibility of our approach. The rest of the paper is organized as follows. Section \n2 outlines our approach. Section 3 de.nes the target language and the type system. Section 4 de.nes an \noperational semantics of the target language and shows that the type system is sound with respect to \nthe semantics. Section 5 develops a type inference algorithm and shows its soundness and other desirable \nproperties. Section 6 discusses several extensions and implementation. Section 7 concludes the paper. \n 2 Our Approach In order to develop a static access control system for a low-level code language like \nthe JVM bytecode language, we need to estab\u00adlish a type theoretical framework for low-level code. We \nalso need to devise a strategy to extract resource access information from a given code. Before going \nto the technical details, in this section, we outline our approach focusing on these two points. In the \nframework of Skalka and Smith [13], a function has a type of the form . t1 . t2 indicating the fact that \nit takes an argument of type t1, and com\u00adputes a result of type t2 using the privileges .. It is not \nimmedi\u00adately obvious that this idea can be applied to type systems of JVM bytecode such as the one by \nStata and Abadi [14] that only checks consistency of machine states and instructions. To apply the general \nidea exploited in [13] to a low-level language, we need to de.ne a type system that deduces a static \nsemantics of a given code. In an earlier work [5], we have developed a type theoretical frame\u00adwork that \nallows us to regard the JVM bytecode language as a typed term calculus. In this formalism, a JVM block \nB is represented as a static judgment of the form . . B : t indicating the property that B computes a \nvalue of type t using a stack of the form .. (For the simplicity of presentation, we ignore local variable \nenvironments, which is irrelevant to the approach presented here.) The type system is constructed based \non a proof-theoretical interpretation of low\u00adlevel machine instructions [6], which we outline below. \nEach ordinary instruction I, which changes a machine state . to a new state .., is regarded as a left-rule \nof the form .. . B : t . . I\u00b7B : t in a sequent style proof system. return statement corresponds to an \ninitial sequent (axiom in the proof system) of the form: t\u00b7. . return : t A jump instruction refers to \nan existing code block (proof) through a label, and can be represented as a meta-level rule of the form: \n. . goto(l) : t (if L(l)=. . t) where L is an environment describing the typing of each entry point of \nexisting blocks (i,e. the end sequent of existing proofs.) Our strategy is to re.ne this formalism to \nintroduce access control information. We interpret a code block B as a proof of a judgment of the form \n.,.,p . B : t indicating the fact that B is owned by principal p, and computes a value of type t from \na stack of values of type ., using a privilege set .. To de.ne a type system to deduce a sequent of the \nabove form, we must prescribe the relationship between the privilege sets . and the block B according \nto its behavior with respect to resource access. Our strategy is to associate each method with a set \nof privileges .. required to execute it, and consider . in the sequent as a constraint .... to invoke \nthe method. A method has then a type of the form .. .t similar to function type in [13]. In order to \nproperly grant a code to gain some privilege through a special instruction similar to doPrivileged in \nJava, the type system maintains an access policy, which describes the maximum set of privileges for each \nprincipal. The type system is constructed in such a way that it type-checks a class with respect to an \naccess policy and a given class environment describing existing classes. Each method in an existing class \nis as\u00adsumed to be either one that has already been checked by this type system so that it has a correct \nprivilege information, or a trusted method whose privilege information is declared correctly. After type-checking \na class under a given class environment, the type system produces a correct type for each new method, \nso that the system can extend the class environment with the new class. Since the type system checks \nall the method invocation statically, veri.cation of conformance of access privileges against a given \nac\u00adcess policy is thorough and complete. This mechanism frees the programmer from the responsibility \nfor checking access privilege using checkPermission. The only thing required is to declare a type of \nthe form .. .t for each trusted method so that . represents the set of privileges used by the method. \nThese trusted methods are typically native methods in a system library, for which we can safely assume \nthat the correct type has already been declared. 3 A JVM Access Control Calculus To present our method, \nwe de.ne a calculus, JVMsec, and its static type system. JVMsec is a language similar to Java bytecode \ncontain\u00ading minimal features suf.cient to present our method. In the subsequent development, we shall \nuse the following nota\u00adtions. For a sequence S and an element e, e\u00b7S is the sequence ob\u00adtained by adding \ne at the front of S, and S.i denotes the ith element of S. S{i . e} is the sequence obtained from S by \nupdating ith el\u00adement of S to e. |S| is the length of the sequence S. We use similar notations for a \n.nite function f : f .x is the value assigned to x in f , and f {x .v}is the function f such that Dom(f.)=Dom(f \n).{x}, f .(x)=v and f .(y)= f (y)for any y . =x. 3.1 The language syntax We assume that the user sets \nup an access policy (ranged over by A) statically and globally. It is a function assigning a set of privileges \n(ranged over by p) to each principal. The syntax of access policies is given below. A := {p1 =.1,\u00b7\u00b7\u00b7,pn \n=.n} . := 0/ |{p}.. p := FileRead | FileWrite | SocketConnect | \u00b7\u00b7\u00b7 A privilege p is an atom (constant) \nmodeling some system resource to be protected, and corresponds to a permission in JAVA. A permis\u00adsion \nof JAVA consists of a target and an action. Later in Section 6, we shall discuss a mechanism to extend \nour formalism to include target speci.cation in p. For simplicity, we assume that a unit of security \nveri.cation is one class under a given access policy and a given class environment. An actual JVM program \nmay contain a set of mutually dependent classes. It is routine to extend our framework to allow mutually \ndependent classes as a unit of veri.cation. A class consists of a set of methods. The syntax of classes \nis given below. C := {m =M,...,m =M}M := {l1: B1,\u00b7\u00b7\u00b7,ln : Bn} (entry .{l1,\u00b7\u00b7\u00b7,ln}) B := goto(l) | return \n| I\u00b7B I := acc(n) | iconst(n) | dup | ifeq(l) | priv(p) | new(c) | invoke(c,m) Each class is associated \nwith its principal. We write Cp for a class whose principal is p. Each method M consists of a set of \nlabeled code blocks. We assume that the set of labels of a method contains a special label entry to indicate \nthe entry point of the method. Each method M in a class is implicitly owned by the principal associated \nto the class to which it belongs. We write Mp if M belongs to a class Cp. A code block B is a sequence \nof instructions terminated with return or goto. acc(n) pushes the nth value of a stack on top of the \nstack. This is added to make the set of instruction non triv\u00adial, and does not have much signi.cance \nto our type system. priv corresponds to doPrivileged in the JAVA access control architec\u00adture. If the \nblock is of the form priv(p)\u00b7B and the access policy allows current principal to use p, then the current \nprivilege set is extended with p so that B can use it. We only consider methods and ignore object .elds. \nA .eld can be regarded as a special form of a method, and our access control mechanism for method carries \nover to .elds. In Java, a class .le contains explicit type declarations of the meth\u00adods. We represent \nthese type declaration by class speci.cation T whose syntax is given blow. T := {c1 =methods,\u00b7\u00b7\u00b7,cn =methods} \nmethods := {m1 =.1 .t1,\u00b7\u00b7\u00b7,mn =.n .tn} This is an extra input to the type system in type-checking a class, \nand not a static environment for typing derivation. A static environment used in the type system is a \nstatic class envi\u00adronment (ranged over by C ) describing the static information about (already veri.ed) \nset of existing classes. It describes for each class its method types (augmented with privileges). The \nsyntax of class environments is de.ned below. C := {c1 =M1,\u00b7\u00b7\u00b7,cn =Mn} .1.n M := {m1 =.1 .t1,\u00b7\u00b7\u00b7,mn =.n \n.tn}. := 0/ | t\u00b7. t := int | c . is a stack type which is a sequence of types, and the leftmost element \ncorresponds to the stack top. 3.2 The type system Corresponding to the structure of JVMsec, the type \nsystem consists of typing relations for code blocks, methods, and classes. We de.ne them in that order. \nBlock typing. As outlined in Section 2, the type system for blocks is de.ned as a proof system to derive \na judgment of the form: .,., p . B : t relative to a given class environment C and an access policy A. \nC is of the form C0 .{c =M }, where C0 is the class environment describing all the existing classes and \n{c =M } describes the types of methods of the current class. This structure re.ects the mutu\u00adally recursive \nnature of the set of methods of a class de.nition. In addition to those two environments, we need to \nintroduce a label environment L to describe the types of the set of code blocks to which B belongs. This \nis necessary due to mutually recursive block de.nitions in a method induced by label references. A label \nen\u00advironment has the form {l1: .1,.1, p . t,\u00b7\u00b7\u00b7,ln : .n,.n, p. t}where l1,\u00b7\u00b7\u00b7,ln is the set of labels \nof the blocks. Since bindings of labels and classes are static, there is no rule that changes C or L. \nFor this reason, in de.ning each typing rule, we treat C and L as global variables. The set of typing \nrules is given in Figure 1. The rules for invoke and priv realize static access control. The other rules \nare essentially the same as those in [5]. To invoke a method of type t. . t, a caller must have at least \nall the privi\u00adleges in .. For a simple type discipline such as that of the lambda calculus, this would \nbe suf.cient. However, since, in JVMsec, the method actually called is determined at runtime based on \nthe run\u00adtime class of the receiver object, this constraint must therefore be checked against all the \npossible methods that may be called. The condition .i . . for each i in the rule for invoke guarantees \nthis constraint for each possible method. The auxiliary function lookupAll(c,m) traverses the subclass \nof class c and returns the set of classes that de.ne a method m. The rule for priv(p) adds p to the current \nprivilege set for B, if the principal of B has access privilege p under the access policy A. Method typing. \nA method consists of a set of code blocks. A method M is well typed if each block in M is well typed. \nThis relation is de.ned below. C I Mp : L .. for each l .Dom(Mp), following conditions hold: L(l)=.,., \np. t, C , L I.,., p . Mp(l) : t , and . .A(p) . . A(p)re.ects the property that the privileges each code \nblock may use must not surpass the set of allowable privileges granted by the access policy A. Since \nthe type of a method is the type of the entry block, we de.ne method typing as follows. C I Mp : .. .t \n.. there exists some L such that C IMp : L and C , L I.,., p . Mp.entry : t Class typing. Using these \nde.nition, typing of a class Cp with respect to a class environment C0 of existing classes is de.ned \nas follows. C0,T ICp : M .. for each m .Dom(Cp), following conditions hold: C =C0 .{c =M }, C ICp.c.m \n: M .c.m, =.. M .c.m .t and T.c.m =. .t A well typed class Cp named c with type M under C0 yields an \nextended class environment C0 .{c =M }. 3.3 Example of program and its typing We show an example of \ntype derivation using a simple program. Let IO be an existing system class having privilege FRead for \nreading .les, and readFile be a native method de.ned in the class, which takes a .le name and returns \na content of the .le as a string. Sup\u00ad {FRead} pose the type of readFile is declared as str . str. This \ntype indicates that privilege FRead is required to read .les through this method. This condition is statically \nenforced by the typing rule for method invocation. To enable any user without FRead to read a public \n.le, a trusted user with FRead can de.ne the following class using priv. class safeClass { readFooFile() \n: str -> str = { new(IO) sconst(\"/public/foofile\") priv(FRead) invoke(IO,readFile) return } } sconst(s) \nis an instruction which pushes a string s onto the stack and has a typing rule similar to iconst(n). \nAny user should be able to call readFooFile, even if he or she doesn t have FRead privilege. This is \nachieved by our type system. Let trusted be the princi\u00adpal of the class safeClass such that FRead . A(trusted). \nThe type system deduce the following typing for the body of method readFooFile. {FRead},str\u00b70/,trusted \n. return : str {FRead},str\u00b7IO\u00b70/,trusted . invoke(IO,read) : str 0/,str\u00b7IO\u00b70/,trusted . priv(Read) : \nstr 0/,IO\u00b70/,trusted . sconst( /public/foofile ) : str 0/,0/,trusted . new(IO) : str 0/ From this type \nderivation, readFooFile is given type void .str. This means that no privilege is required to invoke it. \n  4 Operational Semantics and Type Soundness In order to show that the type system just de.ned properly \nenforces the desired access control, we de.ne an operational semantics that models Java-style dynamic \nstack inspection, and show the sound\u00adness of the type system with respect to the operational semantics. \n .,t\u00b7., p . return : t.,., p . goto(l) : t (if L(l)=.. ,., p . t . ....) .,(..n)\u00b7., p . B : t.,int\u00b7., \np . B : t.,t\u00b7t\u00b7., p . B : t .,., p . acc(n)\u00b7B : t.,., p . iconst(n)\u00b7B : t.,t\u00b7., p . dup\u00b7B : t .,., p \n. B : t.,c\u00b7., p . B : t (if L(l)=.. ,., p . t . ....) .,int\u00b7., p . ifeq(l)\u00b7B : t.,., p . new(c)\u00b7B : t \n.,t1\u00b7., p . B : t {c1,\u00b7\u00b7\u00b7,cn}=lookupAll(c,m) .i (if .1 .t1 =C .ci.m, .0 <: .1 , c0 <: c and .i .. for \neach i) .,.0\u00b7c0\u00b7., p . invoke(c, m)\u00b7B : t p\u00b7.,., p . B : t.,., p . B : t (if p .A(p)) (if p ./A(p)) \n.,., p . priv(p)\u00b7B : t.,., p . priv(p)\u00b7B : t Figure 1. Typing rules for code block B 4.1 Operational \nsemantics Since semantics of a method in a class depends on other methods of the class and those of existing \nclasses, the operational semantics is de.ned relative to a dynamic class environment (ranged over by \n.) of the form: . =.0 .{c =Cp} where .0 is a dynamic class environment for existing classes whose static \ninformation is described in a static class environment C0 used in the type system, and c is the current \nclass. Since C0 is a class environment for already veri.ed classes, the op\u00aderational semantics for a \nclass is de.ned under the assumption that method bodies in .0 satis.es the static constraints described \nin C0. To model this situation, we assume that each method in .0 acts as an opaque function satisfying \nthe corresponding typing constraint in C0, whose precise condition will be given when we prove the type \nsoundness theorem. To emphasize the distinction between the method bodies in the current class (for which \nthe semantics is being de.ned) and those in .0 modeled by opaque functions in existing classes, we write \n..c.m =PreChecked(f )if m is a method in an existing class, and write ..c.m =Code(M)if m is a method \nin the current class. The operational semantics is de.ned by specifying for each instruc\u00adtion I, its \neffect as a transition rule on machine states using a dy\u00adnamic class environment ., a static class environment \nC0 for exist\u00ading classes, and a class speci.cation T describing the types of the methods. T is necessary \nto check the type of the current method. A machine state has the form: (P, S,Mp{B}, D), h P is a dynamic \nprivilege set, which represents the set of privileges that the block B can currently use. S is an operand \nstack, which is a sequence of runtime value (ranged over by v). Following [13], we model access violation \nby a special runtime value secfail.If an access violation occurs at runtime, the machine terminates with \nthis special value. Introduction of this special value is necessary to distinguish it from type error, \nwhich causes the machine to stop prematurely. An ordinary runtime value is either an integer n or a heap \naddress r. Mp{B} indicates that the machine is executing the .rst instruction of block B belonging to \nmethod Mp. h is a heap, which is a function from heap address (ranged over by r) to object instances \nof the form O c of class c. Since we omitted object .elds, the contents of an object instance is empty. \nD is a dump, which is a sequence of saved method frames of the form (P,S, Mp{B}). A state transition \nrule is of the form C0,.,T I(P, S,Mp{I\u00b7B}, D),h -. (P. ,S. ,M.p.{B.},D.),h. indicating that I transforms \nthe machine state (P,S,Mp{I \u00b7B}, D),h ,M.p. to (P. ,S.{B.},D.),h. under C0,.,T. The set of transition \nrules is given in Figure 2 (omitting the context C0,.,T which are not changed during the execution.) \nThe function lookup(c,m) used in the rule for invoke locates the class which is the closest super class \nof c that de.nes a method m. Instruction new creates an initialized new object. The only instruction \nwhich may causes the security error is invoke. There are three cases for invoke. If the method to be \ninvoked is de.ned in the current class, then the method body is called just as in the conventional JVM. \nIf the method to be invoked is one de.ned in an existing class and the set of privileges required by \nthe method is included in the dynamic privilege set, then the method must succeeds with a value of appropriate \ntype. If the method to be invoked is de.ned in an existing class and the set of privileges required by \nthe method is not included in the dy\u00adnamic privilege set, then the method invocation is aborted and the \nsystem returns the special value secfail. This is the case of run\u00adtime access violation. The type soundness \ntheorem we shall show later guarantees that when the current privileges include the stati\u00adcally deduced \nprivileges of the method, then access violation will not happen. The observant reader may have noted \nthat the operational seman\u00adtics is based on eager semantics for security checking i.e., a new privilege \nset P is calculated at every method call by invoke. There\u00adfore, security veri.cation can be done by checking \nthe current frame without traversing the entire frame stack. Since a method call oc\u00adcur frequently, eager \nsemantics may incur high runtime overhead due to computation of P. For this reason, most implementations \nincluding JDK [8] adopt lazy semantics, where calculation of the effective privilege set is performed \nby stack inspection only when security check is actually required. The trade-off between eager and lazy \nsemantics may be important for access-control systems based on dynamic checking of privilege information. \nIt should be noted, however, that this issue is irrelevant for us. The operational semantics is de.ned \nonly to show soundness of the type system. The type soundness theorem guarantees that a type-checked \npro\u00adgram will never cause security violation. We therefore use the op\u00aderational semantics that does not \nperform any runtime access check for actual execution. Since it is proved that eager and lazy seman\u00ad \n(P, v\u00b7S,Mp{return},0/),h -. (0/,v,0/ ,0/),h (P, v\u00b7S,Mp{return},(P0,S0,Mp0 {B0})\u00b7D),h 0 -. (P0,v\u00b7S0,Mp0 \n{B0},D),h 0 (P, S,Mp{acc(n)\u00b7B},D),h -. (P,(S.n)\u00b7S,Mp{B}, D), h (P, S,Mp{iconst(n)\u00b7B},D),h -. (P,n\u00b7S, \nMp{B}, D), h (P, v\u00b7S,Mp{dup\u00b7B}, D), h -. (P, v\u00b7v\u00b7S,Mp{B}, D), h (P, 0\u00b7S,Mp{ifeq(l)\u00b7B},D),h -. (P,S,Mp{M(l)},D),h \n(P, n\u00b7S,Mp{ifeq(l)\u00b7B},D),h -. (P,S,Mp{B}, D), h if n . =0 (P, S,Mp{new(c)\u00b7B},D),h -. (P,r\u00b7S,Mp{B}, D), \nh. if h. =h{r .O c} and r ./dom(h) (P, S,Mp{goto(l)\u00b7B},D),h -. (P,S,Mp{Mp(l)},D), h (P, S1\u00b7r\u00b7S,Mp{invoke(c,m)\u00b7B},D),h \n-. (P. ,S1\u00b70/,M. p.{M. .entry}, (P,S, Mp{B})\u00b7 D), h if h(r)=O c0 , c1 =lookup(c0,m), ..c1.m =Code(M. \np. ), T.c1.m =. . t, |S1| =|.| and P. =P n A(p. ) (P, S1\u00b7r\u00b7S,Mp{invoke(c,m)\u00b7B},D),h -. (P, v\u00b7S,Mp{B}, \nD), h. if h(r)=O c0 , c1 =lookup(c0,m), ..c1.m =PreChecked(f ), C0.c1.m =... . t, |S1| =|.|, ... P, and \n(v,h. )= f (S1,h) (P, S1\u00b7r\u00b7S,Mp{invoke(c,m)\u00b7B},D),h -. (0/,secfail,0/,0/),h if h(r)=O c0 , c1 =lookup(c0,m), \n..c1.m =PreChecked(f ), C0.c1.m =... . t, |S1| =|.| and ... . P (P, S,Mp{priv(p)\u00b7B}, D), h -. (P. ,S,Mp{B}, \nD), h if p . A(p)then P. ={p}. P else P. =P Figure 2. Transition rules for instructions tics are equivalent \n[1, 3], we choose an eager one, which yields a simpler proof of the soundness theorem. We de.ne a JVMsec \nprogram to be a top-level invocation of a method of the current class by the user. To execute a method \nMp with arguments S at the top level by the user identi.ed by the prin\u00adcipal pT , the machine state is \ninitialized as follows: (PT ,S,Mp{M.entry},0/),h * where PT =A(p)n A(pT ). We write . for the re.ective \ntransitive closure of the relation . . We de.ne the top level evaluation relation pT ,C0,T,. I Mp . v \nas pT ,C0,T,. I Mp . v * .. C0,T,. I (PT ,S,Mp{M.entry},0/),h . (0/,v,0/,0/),h. indicating the fact \nthat method Mp is executed by the user of prin\u00adcipal pT and returns the value v. |=h : H .. Dom(h)=Dom(H)and \n.r . Dom(h)if h(r)=O c then c <: H(r) H |=n : int H |=r : t (if H(r)<: t) H |=S : . .. Dom(S)=Dom(.)and \nH |=S.i : ..i for each i. H,C |=0/ : t (for any t) H,C |=(P,S, Mp{B})\u00b7 D : t ... L, .., . ., . t. such \nthat C I Mp : L , H |=S : ., . . P, C , L I .,t\u00b7., p . B : t. , and H,C |=D : t. Figure 3. Typing of \nruntime values 4.2 Type soundness In order to prove the soundness theorem with respect to the opera\u00adtional \nsemantics de.ned above, we .rst de.ne typing relations for runtime structures consisting of the following: \n |=h : H (heap h has heap type H)  H |=v : t (value v has type t under H)  H |=S : . (stack S has type \n. under H)  H,C |=D : t (dump D has type t under H and C )  Heap type H is a mapping from heap addresses \nto types. This is similar to store type [11] and is needed for the soundness theorem we shall establish \nbelow to scale to heaps containing cyclic struc\u00adtures [5]. The last relation for dump D means that D \naccepts a value of t and resumes the saved computation. Figure 3 shows the def\u00adinitions of these relations. \nUsing these de.nitions, we de.ne type correctness of a machine state as follows. H,C |=(P,S, Mp{B}, D), \nh : t ...L, . ., . . such that C I Mp : L, H |=S : ., . . P, C , L I .,., p . B : t. , and H,C |=D : \nt. This de.nition says that for a machine state to be type correct, each component must be well typed \nand the set . of privileges statically deduced by the type system must be contained in the set P of privi\u00adleges \nthe block has at runtime. We also de.ne the relation I .0: C0 denoting the fact that dynamic class environment \n.0 of existing classes satis.es static class environment C0 of existing classes as follows. I . : C .. \nfor any c,m, the following conditions hold. Let PreChecked(f )=..c.m and .. . t =C .c.m.For any S,h, \nif there is some H such that |=h : H and H |= S : . then the application f (S,h) computes (h. ,v) such \nthat |=h. : H. and H.|=v : t for some extension H. of H using only the privileges in . . Let C0,.0,T \nbe a given static class environment, a given dynamic class environment, and a given class speci.cation \nsatisfying I.0: C0. Also let Cp be a given class named c such that there is some M satisfying C0,T ICp \n: M. We can now prove the following. Let C =C0 .{c =M}, . = .0 .{c =Cp}. THEOREM 1(TYPE SOUNDNESS). For \nany method Mp in Cp, if H,C I(P,S,Mp{B}, D), h then either (1) B =return and D =0/ or (2) there are some \nP.,S.,M.,p.,B.,D.,h.,H. such that ,S. ,M.p.{B.},D.),h.C, ., T I(P,S, Mp{B}, D), h -.(P. and H. ,C I(P. \n,S. ,M.p.{B.},D.),h. for some extension H. of H. PROOF. This is proved by the case analysis of the .rst \ninstruction of B, using the following simple lemma. LEMMA 1. If H |=v : t and H.is an extension of H \nthen H.|=v : t. The theorem implies the following desired property. COROLLARY 1. Let T be a given class \nspeci.cation; C0,.0 be a static class environment and a dynamic class environment of exist\u00ading classes \nsatisfying I.0: C0; let Cp be a class such that C0,T I Cp : M. Also let pT be the principal of the user. \nIf . .A(pT)for .t then if pT,C0,T,. IMp .v then v is not secfail. any . such that M.m =.. This is a direct \nconsequence of the de.nition of top-level execution and our type soundness theorem. This result says \nthat a well typed program will never cause security violation when executed with the privileges speci.ed \nin its type. We can therefore safely use a type-checked code without monitoring its resource access at \nruntime.  5 Type Inference In JVM, each method is explicitly typed but the privilege set . is not given. \nIn order to use a type system de.ned in Section 3 we need to develop a type inference algorithm. 5.1 \nThe type inference algorithm In order to de.ne a type inference algorithm, we extend types and stack \ntypes by introducing type variables (ranged over by t) and sequence variables (ranged over by d) respectively \nas follows. t :=t |int | c . :=0/ |d |t\u00b7. Type variables are bounded by a bound environment K, which \nis a mapping from a .nite set of type variables to class names or *. K(t)=c indicates that t ranges only \nover subclasses of c, and K(t)=* indicates that t has no bound. We write K I t <: c if t is a subclass \nof c under bound environment K. This relation is given as follows. K I c<: c (if c<: c) K I t <: c (if \nK(t)<: c) A (type variable) substitution (ranged over by S) is a function from a .nite subset of type \nvariables to types. We say that a substitution S respects K if for all t in Dom(K), K IS(t)<: K(t). (E \n.{(t, t)}, S)=.(E, S) (E .{(t,t)},S)=.([t/t]E,{(t,t)}.[t/t]S) (if K(t)=*) (E .{(t,c)}, S)=.([c/t]E, {(t,c)}.[c/t]S) \n(if c <: K(t)) (E .{(t1,t2)},S)=.([t2/t1]E, {(t1,t2)}.[t2/t1]S) (if K(t2)<: K(t1)) (E .{(t1,t2)},S)=.([t1/t2]E, \n{(t2,t1)}.[t1/t2]S) (if K(t1)<: K(t2)) * S ((E, 0/)=.(0/,S)) Unify(K, E)= f ailure (otherwise) Figure \n4. Uni.cation algorithm A uni.cation algorithm Unify accepts a bound environment K and a set E of pairs \nof types, and returns substitution S that respects K. Algorithm Unify is given in Figure 4. It is easily \nchecked that Unify is a uni.cation algorithm if the subclass relation <: has the property that if two \nclasses are incomparable then they have no common subclass. The set of JVM classes satis.es this property. \nHowever, if we extend JAVA-style interfaces, then a more re.ned algorithm will become necessary. In what \nfollows, we identify S with its homomorphic extension to any syntactic structures containing type variables \nand sequence variables. We also extend the language of privilege sets to include set vari\u00adables . as \nfollows. . :=P |P\u00b7. P is a (closed) set of privileges. P\u00b7. is an open set of privileges denoting the \nset consisting of privileges in P and those in the set denoted by set variable .. We sometimes write \nP .. to denote the element of this language, i.e., if . =P. then P .. =P .P. and if . =P.\u00b7. then P .. \n=(P .P.)\u00b7..A set variable substitution (ranged over by .) is a function from a .nite set of set variables \nto sets. The role of the type inference algorithm is twofold. It infers a most general typing using Unify \nfor each method body and to verify that it satis.es the type speci.cation. It also infers the minimal \nset of privileges required to execute each method. To perform the latter, the algorithm generates a set \nof inclusion constraints of the form . . .., and then solves the constraint sets to compute the mini\u00admal \nset of privileges. We use PC as a meta variable for a .nite set of inclusion constraints. We say that \na set variable substitution . satis.es PC if .(.)..(..)for any . ....PC. Figure 5 shows the main algorithm \nWC performing these steps us\u00ading a sub-algorithm WM for inferring method typing. The main algorithm takes \na static class environment C for existing classes, class de.nition Cp, and class name c, and infers the \nset of method types M of the class. It .rst generates a type skeleton containing a privilege set variable \nfor each method. It then infers a type of each method using WM, which returns a set of constraints PC. \nIts de.nition is given in Figure 6. WM .rst sets up a skeleton of each code block and makes a label environment. \nIt then infers a type of each code block using another sub-algorithm WB, which infers a typing of a code \nblock using Unify. Figure 7 gives its de.ni\u00ad WC(C,{m1 =M1 p ,\u00b7\u00b7\u00b7,mn =Mnp},c)= 0/ \u00b7.10/ \u00b7.n let M ={m1 \n=.1 . t1,\u00b7\u00b7\u00b7,mn =.n . tn} (if T.c.mi =.i .ti for each i) PC0 ={.1 .A(p),\u00b7\u00b7\u00b7,.n .A(p)}C. =C.M for each \ni do PCi =WM(C. ,M(mi),Mip ,PCi-1) end . =Solve(PCn) in .(M) Figure 5. Type inference algorithm for \nclasses .t),Mp let {l1 =B1,\u00b7\u00b7\u00b7,ln =Bn}=Mp Bentry =.,.,p . t Bi =.i,di,p . t (1 =i =n) L={l1 =B1,\u00b7\u00b7\u00b7,ln \n=Bn} S0 =0/,K0 =0/ WM(C,(..,PC)= PC0 =PC .{.1 .A(p),\u00b7\u00b7\u00b7,.n .A(p)} for each i do (S,Ki,PCi)=WB(C,Si-1(L),Si-1(Bi),Bi,Ki-1,PCi-1) \nSi =S.Si-1 end in PCn Figure 6. Type inference algorithm for methods tion. After obtaining a constraint \nset for all the methods by WM, the main algorithm solves the constraints by Solve, which returns a substitution \n. that satis.es PC. The de.nition of Solve is given in Figure 8. Note that P appearing in inclusion constraints \nis a set not contain\u00ading set variable, and expressions P1 \\P2 and P1 .P2 used in this algorithm are ordinary \nset-theoretic operations. In contrast to the constrained type system of [13], introduction of expressions \ncorre\u00adsponding to these set operations in set inclusion constraints is not required in our formalism \ndue to the simpler nature of JVMsec com\u00adpared to the lambda calculus. 5.2 Example of type inference \nWe show how the algorithm computes typing using a simple exam\u00adple. Let writeFile be a native method de.ned \nin the class IO, {FW rite} which writes a string to a .le and has type str\u00b7str . void. The following \nprogram reads a .le and writes the contents to other .le. class SomeClass { updateFoo() : str,str -> \nstr { new(IO) sconst(\"/protect/foo.txt\") new(SafeClass) invoke(SafeClass,readPublicFile) invoke(IO,writeFile) \n} } WB(C,L,(.,.,p . t),return,K,PC)= let K1 =K .{t =*} S =Unify(K1,{(.,t\u00b7d),(t,t)}) in (S,K1,PC) WB(C,L,(.,.,p \n. t),goto(l),K,PC)= let .. ,.. ,p . t. =L(l) PC1 =PC .{....} S =Unify(K,{(.,..),(t,t.)}) in (S,K,PC1) \nWB(C,L,(.,.,p . t),acc(n)\u00b7B,K,PC)= let K1 =K .{t1 =*,\u00b7\u00b7\u00b7,tn =*} S1 =Unify(K1,{(.,t1 \u00b7...\u00b7tn \u00b7d)}) (S2,K2,PC.)=WB(C,S1(L), \n S1(.,tn \u00b7.,p . t),B,K1,PC) in (S2 .S1,K2,PC.) WB(C,L,(.,.,p . t),iconst(c)\u00b7B,K,PC)= WB(C,L,(.,int\u00b7.,p \n. t),B,K,PC) WB(C,L,(.,.,p . t),dup\u00b7B,K,PC)= let K1 =K .{t =*} S1 =Unify(K1,{(.,t\u00b7d)}) (S2,K2,PC1)=WB(C,S1(L), \n S1(.,t\u00b7t\u00b7d,p . t),B,K1,PC) in (S2 .S1,K2,PC1) WB(C,L,(.,.,p . t),ifeq(l)\u00b7B,K,PC)= let .. ,.. ,p . t. \n=L(l) S1 =Unify(K,{(.,int\u00b7d)}) S2 =Unify(K,{(S1(.),..),(S1(t),t.)}) S3 =S2 .S1 (S4,K1,PC1)=WB(C,S3(L), \n S3(.,d,p . t),B,K,PC) PC2 =PC1 .{....}in (S4 .S3,K3,PC2) WB(C,L,(.,.,p . t),new(c)\u00b7B,K,PC)= WB(C,L,(.,c\u00b7.,p \n. t),B,K,PC) WB(C,L,(.,.,p . t),invoke(c,m)\u00b7B,K,PC)= let ...t. =T.c.m K1 =K .{t1 =..(1),\u00b7\u00b7\u00b7,tn =..(n),t0 \n=c} (if |..|=n) S1 =Unify(K1,{(t1\u00b7...\u00b7tn \u00b7t0 \u00b7d,.)}{c1,\u00b7\u00b7\u00b7,cn}=lookupAll(c,m) .. .i .t. =C.ci.m PC1 =PC \n.{.i ..} (for each i) (S2,K2,PC2)=WB(C,S1(L), S1(.,t.\u00b7d . t),B,K1,PC1) in (S2 .S1,K2,PC2) WB(C,L,(.,.,p \n. t),priv(p)\u00b7B,K,PC)= let .. =if p . A(p)then {p}.. else . in WB(C,L,(.. ,.,p . t),B,K,PC) Figure 7. \nType inference algorithm for blocks Solve(PC)= if isSolved(s)for all s .PC then . where .. . PC ..(.)=0/ \nelse let {.1 ..2}.PC0 =PC such that isSolved(.1 ..2)is false (.1,.. 1 ... 2)=Solve1({.1 ..2}) .2 =Solve({.. \n1 ... 2}..1(PC0)) in .2 ..1 Solve1(P1 .P2)=Failure Solve1(P1 .P2\u00b7.)=let P3 =P1 \\P2 . =[P3\u00b7../.](.. is \na fresh) in (.,P1 .(P2 .P3)\u00b7.3) Solve1(P1\u00b7. .P2)=Failure Solve1(P1\u00b7.1 .P2\u00b7.2)=let P3 =P1 \\P2 . =[P3\u00b7.3/.2](.3 \nis a .esh) in (.,P1 .(P2 .P3)\u00b7.3) isSolved(P1 .P2)=P1 .P2 isSolved(P1 .P2\u00b7.)=P1 .P2 isSolved(P1\u00b7. .P2)=P1 \n.P2 isSolved(P1\u00b7.1 .P2\u00b7.2)=P1 .P2 Figure 8. Algorithm Solve Assume that SomeClass is owned by principal \nsomebody and A is set up such that FWrite .A(somebody). For this class, WC performs the following computation. \nIt .rst {}\u00b7. creates method types M ={updateFoo =str \u00b7str . void}and the inclusion constraints PC0 = \n{. . A(somebody)}.It then obtains inclusion constraints PC ={FWrite . .,0/ . .,. . A(somebody)} by invoking \nthe function WM. Next, it calls Solve for PC. Solve .rst obtains the substitution [FWrite\u00b7../.] from \nFWrite .. and transforms PC to {FWrite .FWrite\u00b7,0/ . .. FWrite\u00b7.. ,FWrite\u00b7... FWrite}. It then returns \nthe substitution . =[FWrite\u00b7../.,0//..]. Finally, WC applies . to M and returns {FWrite} method types \n{updateFoo =str \u00b7str . void}. The constraints FWrite . . and 0/ . . in PC represent the necessary conditions \nfor invoking the method writeFile and readFooFile respectively. The substitution . satis.es these con\u00adstraints \nand . .A(somebody).If FWrite ./A(somebody), PC has no solution, and Solve reports failure. 5.3 Correctness \nof type inference For the type inference algorithm just de.ned to serve as a static veri.cation system \nfor code level access control, it must be sound with respect to the type system of JVMsec, which we shall \nestablish in this section. Another customary criteria of correctness of a type inference algo\u00adrithm is \nits completeness. For our type system, this has two aspects. One is on typings of methods of the form \n. .t and the other is on accuracy of inferred privilege sets .. The .rst aspect is sensitive to the language \nconstructs. Since JVMsec only contains explicitly typed methods and does not contain those mechanisms \nsuch as sub\u00adroutines and object initialization which have subtle interaction with type inference, the \n.rst aspect does not involve much signi.cant issues. For this reason, in this paper, we omit its discussion \nand only consider the second aspect which has signi.cant impact on the usefulness of our method. The \ninterested reader is referred to [5] which deals with type inference with polymorphic subroutines. The \nsoundness of the type inference algorithm is established by the combination of soundness results of the \ncomponents of the type inference algorithm. We .rst verify that the uni.cation algorithm correctly computes \na uni.er. LEMMA 2. Let E be a set of equations under a bound environment K.If Unify(E,K)=S then S respects \nK and S is a uni.er for E. This is veri.ed by simple inspection of each transformation rule. Using this \nproperty, we prove the soundness of WB, which is the main lemma for establishing the soundness of the \ntype inference algorithm. LEMMA 3. If WB(C,L,(.,.,p . t),B,K,PC)=(S,K. ,PC.) then for all S0, .0 such \nthat .0 ground for PC. , .0 satis.es PC, S0 ground for K. and S0 respects K, the following is deriv\u00adable: \n.0(S0(S(C))), .0(S0(S(L))) I .0(.),S0(S(.)),p . B : S0(S(t)). PROOF. This is proved by induction on B. \nThe proof proceeds by cases in terms of the .rst instruction of B. Here we only show some of them. Case \nB =return. By the de.nition of WB, K. =K .{t =*}, S =Unify(K1,{(.,t\u00b7d),(t,t)}), and PC. =PC. Let S0, \n.0 be such that .0 ground for PC, .0 satis.es PC. , S0 ground for K. and S0 respects K. By Lemma 2, S1(.)=S1(t\u00b7d) \nand S1(t)=S1(t). Then by the typing rule, we have .0(S0 .S1(C)), .0(S0 .S1(L)) I .0(.), S0 .S1(.), p \n. B : S0 .S1(t). Case B =priv(p)\u00b7B1. We only show the case for p . A(p). The other case is similar. By \nthe de.nition of WB, .. ={p}.. and (S,K. ,PC.)=WB(C,L,(.. ,.,p . t),B,K,PC). Let be .0,S0 such that .0 \nground for PC. , .0 satis.es PC, S0 ground for K. , and S0 respects K. By the induction hypothesis, .0(S0 \n.S(C)), .0(S0 .S(L))I .0(..),S0 .S(.),p . B : S0 .S(t). By the def\u00adinition of the type system, .0(S0 \n.S(C)), .0(S0 .S(L))I .0(.), S0 .S(.), p . B : S0 .S(t). Case B = invoke(c,m)\u00b7B1. By the de.nition of \nWB, ... t. = T.c.m, K1 = K .{t1 = ..(1),\u00b7\u00b7\u00b7,tn = ..(n)}, S1 = Unify(K1,{(t1\u00b7...\u00b7tn \u00b7t0 \u00b7d,.)}, {c1,\u00b7\u00b7\u00b7,cn} \n=lookupAll(c,m), .i .. . t. = C.ci.m, PC1 = PC .{.i . .}, (S2,K2,PC2)= WB(S1(C),S1(L),S1(.,t.\u00b7d,p . t,B1,K1,PC1), \nand S = S2 . S1,K. =K3,PC. =PC2. Let be .0,S0 such that .0 ground for PC2, .0 satis.es PC1, S0 ground \nfor K2, and S0 respects K1.By induction hypothesis, .0(S0 .S(C)), .0(S0 .S(L))I .0(.),S0 . S(t.\u00b7d),p \n. B : S0 .S(t). By Lemma 2, S1(t1\u00b7,...,\u00b7d)=S1(.). Then by the typing rule, .0(S0 .S(C)), .0(S0 .S(L)) \nI .0(.), S0 .S(.), p . B : S0 .S(t). Apparently, S0 respects K and .0 satis.es PC. We next show the soundness \nof the inference algorithm WM for method. LEMMA 4. If WM(C, (..=Mp : .t),Mp,PC)=PC. then C | .0(.) . \n. t for all .0 that is ground for PC and satis.es PC. Since WM simply calls WB for each block in the \nmethod, this follows from Lemma 3 with the following additional property of WB:if WB(\u00b7\u00b7\u00b7,K,\u00b7\u00b7\u00b7)=(S,K.)then \nS respects K (under K.). The following lemma shows that Solve computes the minimal so\u00adlution of a given \nconstraint set. LEMMA 5. 1. Solve terminates on all inputs. 2. If Solve(PC)=. then . satis.es PC. 3. \nIf . satis.es PC then Solve(PC)=.. such that for each . occurring in PC, ..(.)..(.).  PROOF. The .rst \nproperty follows from the facts that Solve mono\u00adtonically increases the size of constraints and that \nthere are only .nitely many privilege atoms. The second and the third properties can then be shown by \ninduction on the number of recursive calls of Solve. By combining Lemma 4 and Lemma 5, we can show the \nfollowing. THEOREM 2(SOUNDNESS OF WC). If WC(C0,Cp,c)= M then C0,T ICp : M. The following minimality \nresult with respect to privilege set follows from the de.nition of the algorithm WB and Lemma 5. THEOREM \n3. If WC(C0,Cp,c)=M and C0,T ICp : M. such that M. is equal to M except for privilege set annotations, \nthen each privilege set . in M is included in the corresponding .. in M. .  6 Extensions and discussions \nThe calculus we have considered so far can be extended in several ways to include practically useful \nfeatures. This section discusses some of them. 6.1 Inclusion of target objects One simpli.cation we have \nmade in the previous development is that a privilege p is an atom, representing some privileged opera\u00adtion. \nIn the Java access control architecture, a permission consists of a target and an action to be performed \non the target. This allows .ner access control. One way to incorporate this feature is to re.ne a privilege \np to be a term of the form F(v)where F denotes an operation name as be\u00adfore and v represents the target \nobject. Integration of those privilege terms in our type system requires several re.nements. Firstly, \nsince v denotes a possible runtime value which the static type system can only approximate, we need to \nintroduce a type attribute denoting a set of possible values. Secondly, in order to propagate this attribute \ninformation across method invocation boundary, some mechanism for abstraction over those sets of possible \nvalues is necessary. A complete access control system including these features is beyond the scope of \nthe current paper. In the following, we describe the necessary re.nement to the type system to incorporate \nthese fea\u00adtures. The syntax of the re.ned set of privileges is given below p ::= F(v) v ::= {s1,...,sn}|a \n|v .v |. s is an address of an object represented by a string such as an URL, and {s1,...,sn}denotes \na set of (possible) target objects identi.ed by the address s1,...,sn. a is a variable ranging over sets \nof target objects, and v1 .v2 denotes the union of v1 and v2. .denotes the set of all possible objects. \nv is ordered by set inclusion with .the largest element. Koved et. al. [9] have used a similar mechanism \nin their data .ow analysis. The type system can be extended to incorporate these re.ned notion of privileges. \nWe assume that the language contains string values of type str with a set of operations such as sconst(s). \nThe set of types is extended as follows. t ::=int |c |str(v) str(v)represents the subset of strings denoted \nby v. For example, str({s})represents the singleton set and str(.)represents the set of all strings. \nFor this re.ned string types, the subsumption relation is extended to include the relation generated \nby the rule: v1 .v2 str(v1)<: str(v2) The type system is re.ned to keep track of possible runtime values \nof stack entries. For example, the typing rule for sconst instruction is given as follows. .,str({s})\u00b7.,p \n. B : t .,.,p . sconst(s)\u00b7B : t The possible set of target objects ({s}in the above example) will be \npromoted through the subsumption relation above when control .ow merges. The another necessary re.nement \nis to consider a method as poly\u00admorphic with respect to the object set variables a appearing in its typing, \nand to give a polymorphic type in the style of ML s let\u00adpolymorphism. Since method is not a .rst-class \nobject, this treat\u00adment is compatible with our type system. We can adopt the tech\u00adnique of introducing \nlet-polymorphism in the JVM we have devel\u00adoped [5] for JVM subroutines. For example, a method which re\u00adceives \na .le name and opens the .le is given the following poly\u00admorphic type. {FOpen(a)} .a.(str(a). Void) When \nthis method is invoked with a parameter s, FOpen(s) privi\u00adlege is generated through ML-style type instantiation. \nWith these re.nements, the type system of JVMsec can be extended to incorporate possible target objects \nof privileged accesses. Some more efforts are needed to extend the type inference algorithm. 6.2 Adding \nother JVM features To develop a static veri.cation system for the JVM bytecode lan\u00adguage based on our \nmethod, we must extend our type system to include various other instructions of JVM. Since the type system \nis based on the logical presentation of the JVM bytecode language [5], we believe that the set of instructions \nconsidered there can be added without much dif.culty. These include instructions for lo\u00adcal variable \naccess, and for object .eld manipulation. Furthermore, the type system developed in [5] supports polymorphic \nsubroutines, whose treatment is orthogonal to typing mechanism for access con\u00adtrol presented here. So, \nour type system should extend smoothly to JVM subroutines without any additional machinery. In Java, \ncheckPermission can be used to protect object .elds. This feature is easily added by extending .eld types \nto include priv\u00adilege annotation similar to method types as in {f1: (.1,t1),..., fn : (.n,tn)} and de.ne \na typing rule for .eld manipulation as follows. .,t.\u00b7., p . B : t .,c0\u00b7., p . getfield(c, f )\u00b7B : t (if \nc0 <: c, (.. ,t.)=T.c. f and ... .) The rule for putfiled can similarly be de.ned. 6.3 Implementation \nissues In order to develop a practical access control system based on our static method, we have to consider \na number of implementation issues. We brie.y discuss some of them below. Compatibility with existing \nprograms. As we have explained ear\u00adlier, the current practice in Java access control is to dynamically \nin\u00advoking static methods checkPermission and doPrivileged sup\u00adplied as a JDK security package. A static \naccess control system should work for existing programs using these methods. One ap\u00adproach is to replace \nthese two methods with those whose intended effect is represented by their types but whose runtime effect \nis nil, and to consider doPrivileged invocation as priv instruction. Relationship with JVM runtime system. \nIn JVM, a bytecode veri.er checks the type consistency of a class .le. A security veri.cation is static \ntype-checking similar to bytecode veri.cation, so it is de\u00adsirable to unite these two veri.cation systems. \nSince our security veri.cation system is based on a type theory [5] for bytecode veri\u00ad.cation, it is \nnot hard to develop a static system which checks type consistency and security violation simultaneously. \nHowever, since the JVM bytecode veri.er is closely related to a complicated fea\u00adture such a dynamic class \nloading, development of such a integrated system requires us to modify a major part of JVM runtime system. \nA simpler strategy is to check all the class .les in a program inde\u00adpendently of JVM before executing \nthe program. Adopting this ap\u00adproach, we plan to design a veri.er as a stand alone system which reads \nan access policy .le, a target class .le, and infers types of methods in the class, and reports a security \nviolation if it is detected. Specifying privilege requirements. We also need to declare the priv\u00adilege \nset for each native method. One possible approach is to di\u00adrectly write it in a class .le which declares \na native method. An\u00adother approach is to describe it in an external .le corresponding to the class .le. \nIn this approach, a coding technique such as digital signature used in the current JDK to sign a code \nmay be required to guarantee credibility of the .le.  7 Conclusions We have developed a static access \ncontrol system for the JVM byte\u00adcode language. We have extended our earlier work of presenting the JVM \ncode language as a typed term calculus to incorporate privi\u00adlege attributes in a method type. We have \nthen de.ned an opera\u00adtional semantics that simulates JDK style runtime stack inspection, and have shown \nthat the type system is sound with respect to the operational semantics. This result guarantees that \nwe can safely omit costly runtime stack inspection. All the possible access vi\u00adolation is statically \ndetected. Another advantage of our approach is that the user can verify whether a code conforms to a \ngiven ac\u00adcess policy or nor directly without relying on explicit insertion of checkPermision. This approach \ncan therefore be used as a se\u00adcurity veri.cation system for foreign and possibly malicious code. For \nthis type system, we have develops a type inference algorithm, which achieves automatic veri.cation for \ncode-level access control. Acknowledgments The authors would like to thank Yasuharu Oda, who have helped \nin implementing the type inference algorithm and testing our methods through examples. These results \nhave been useful for better under\u00adstanding our framework. The authors also thank the anonymous referees \nfor helpful comments. 8 References [1] A. Banerjee and D. Naumann. A simple semantics and static analysis \nfor java security. CS Report AI-068-85, Stevens In\u00adstitute of Technology, 2001. [2] A. Banerjee and D.A. \nNaumann. Representation indepen\u00addence, con.nement and access control. In Proc. ACM POPL Symposium, pages \n166 177, 2002. [3] C. Fournet and A. Gordon. Stack inspection: Theory and vari\u00adants. In Proc. ACM Symposium \non Principles of Programming Languages, pages 307 318, 2002. [4] F.Pottier, C.Skalka, and S.Smith. A \nsystematic approach to static access control. In In Proc. of the 10th European Sym\u00adposium on Programming \n(ESOP 01) Springer LNCS 2028, pages 30 45, 2001. [5] T Higuchi and A Ohori. Java bytecode as a typed \nterm cal\u00adculus. In Proceedings of the conference on Principles and practice of declarative programming, \n2002. [6] A Ohori. The logical abstract machine: a Curry-Howard iso\u00admorphism for machine code. In Proceedings \nof International Symposium on Functional and Logic Programming, 1999. [7] Gunter Karjoth. An operational \nsemantics of Java 2 access control. In In Proc. IEEE Computer Security Foundations Workshop (CSFW 00), \npages 224 232, 2000. [8] L.Gong. Inside JavaTM 2 Platform Security. Addison-Wesley, 1999. [9] L. Koved, \nM. Pistoia, and A. Kershenbaum. Access Rights Analysis for Java. In Proc. ACM OOPSLA Conference, pages \n359 372, 2002. \u00b4inspection. In Proc. IEEE Symposium on Security and Pri\u00advacy, pages 246 255, 2000. [10] \nU. Erlingsson and F. Shneider. IRM enforcement of Java stack [11] X. Leroy. Polymorphic typing of an \nalgorithmic language. PhD thesis, University of Paris VII, 1992. [12] T. Lindholm and F. Yellin. The \nJava virtual machine speci.\u00adcation. Addison Wesley, second edition edition, 1999. [13] Christian Skalka \nand Scott Smith. Static enforcement of se\u00adcurity with types. In Proc. International Conference on Func\u00adtional \nProgramming(ICFP 00), pages 34 45, 2000. [14] R. Stata and M. Abadi. A type system for Java bytecode \nsub\u00adroutines. In Proc. ACM Symposium on Principles of Program\u00adming Languages, pages 149 160, 1998. [15] \nDan S.Wallach, Andrew W.Appel, and Edrard W.Felten. Safkasi:a security mechanism for language-based systems. \nACM Transactions on Software Engineering and Methodol\u00adogy, 9:341 378, 2000. [16] D.S. Wallach and E.W. \nFelten. Understanding Java stack in\u00adspection. In Proc. IEEE Symposium on Security and Privacy, pages \n52 63, 1998.  \n\t\t\t", "proc_id": "944705", "abstract": "This paper presents a static type system for JAVA Virtual Machine (JVM) code that enforces an access control mechanism similar to the one found, for example, in a JAVA implementation. In addition to verifying type consistency of a given JVM code, the type system statically verifies that the code accesses only those resources that are granted by the prescribed access policy. The type system is proved to be sound with respect to an operational semantics that enforces access control dynamically, similarly to JAVA stack inspection. This result ensures that \"well typed code cannot violate access policy.\" The paper then develops a type inference algorithm and shows that it is sound with respect to the type system and that it always infers a minimal set of access privileges. These results allows us to develop a static system for JVM access control without resorting to costly runtime stack inspection.", "authors": [{"name": "Tomoyuki Higuchi", "author_profile_id": "81100458949", "affiliation": "Japan Advanced Institute of Science and Technology, Tatsunokuchi Ishikawa, Japan", "person_id": "PP14160963", "email_address": "", "orcid_id": ""}, {"name": "Atsushi Ohori", "author_profile_id": "81100168829", "affiliation": "Japan Advanced Institute of Science and Technology, Tatsunokuchi Ishikawa, Japan", "person_id": "PP39030730", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944726", "year": "2003", "article_id": "944726", "conference": "ICFP", "title": "A static type system for JVM access control", "url": "http://dl.acm.org/citation.cfm?id=944726"}