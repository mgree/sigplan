{"article_publication_date": "08-25-2003", "fulltext": "\n A User-Centred Approach to Functions in Excel Simon Peyton Jones Alan Blackwell Margaret Burnett Microsoft \nResearch, Cambridge Cambridge University Oregon State University simonpj@microsoft.com alan.blackwell@cl.cam.ac.uk \nburnett@cs.orst.edu Abstract We describe extensions to the Excel spreadsheet that integrate user\u00adde.ned \nfunctions into the spreadsheet grid, rather than treating them as a bolt-on . Our .rst objective was \nto bring the bene.ts of additional programming language features to a system that is often not recognised \nas a programming language. Second, in a project in\u00advolving the evolution of a well-established language, \ncompatibility with previous versions is a major issue, and maintaining this com\u00adpatibility was our second \nobjective. Third and most important, the commercial success of spreadsheets is largely due to the fact \nthat many people .nd them more usable than programming languages for programming-like tasks. Thus, our \nthird objective (with result\u00ading constraints) was to maintain this usability advantage. Simply making \nExcel more like a conventional programming lan\u00adguage would not meet these objectives and constraints. \nWe have therefore taken an approach to our design work that emphasises the cognitive requirements of \nthe user as a primary design criterion. The analytic approach that we demonstrate in this project is \nbased on recent developments in the study of programming usability, in\u00adcluding the Cognitive Dimensions \nof Notations and the Attention Investment model of abstraction use. We believe that this approach is \nalso applicable to the design and extension of other programming languages and environments. Categories \nand Subject Descriptors D.3.2 [Programming Languages]: Language classi.cations Functional languages; \nD.3.3 [Programming Languages]: Lan\u00adguage constructs and features Procedures, functions and subrou\u00adtines; \nH.1.2 [Models and principles]: User/machine systems  General Terms Languages,Design Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 03, August 25 29, 2003, \nUppsala, Sweden. Copyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00 1 Introduction For many people, the \nprogramming language of choice is a spread\u00adsheet. This is especially true of people who are not employed \nas programmers, but write programs for their own use often de.ned as end-user programmers [Nar93]. An \nend-user programmer is a teacher, an engineer, a physicist, a secretary, an accountant, a man\u00adager, in \nfact almost anything except a trained programmer. These people use computers to get their job done, but \noften they are not interested in programming per se. End-user programmers outnum\u00adber professional programmers, \nand their numbers are projected to increase more rapidly; in fact, the number of end-user programmers \nin the U.S. alone is expected to reach 55 million by 2005, as com\u00adpared to only 2.75 million professional \nprogrammers [BAB+00]. These facts suggest that the spreadsheet, which is a widely used and commercially \nsuccessful end-user programming language, is also a particularly signi.cant target for the broader application \nof programming-language design principles. It may seem odd to describe a spreadsheet as a programming \nlan\u00adguage. Indeed, one of the great merits of spreadsheets is that users need not think of themselves \nas doing programming , let alone functional programming rather, they simply write formulae or build \na model . However, one can imagine printing the cells of a spreadsheet in textual form, like this: A1= \n3 A2 = A1-32 A3= A2* 5/9 and then it plainly is a (functional) program. Thought of as a pro\u00adgramming \nlanguage, though, a spreadsheet is a very strange one. In particular, it is completely .at: there are \nno functions apart from the built-in ones. Instead, the entire program is a single .at col\u00adlection of \nequations of the form variable = formula . Amazingly, end users nevertheless use spreadsheets to build \nextremely elaborate models, with many thousands of cells and formulae. Almost all of these elaborate \nmodels are constructed in part by reusing formulae from some cells in other cells via the clever spreadsheet \ncopy-and\u00adpaste techniques. From a programming language point of view, then, spreadsheets lack the most \nfundamental mechanism that we use to control com\u00adplexity: the ability to de.ne re-usable abstractions. \nIn effect, they deny to end-user programmers the most powerful weapon in our armory. Can you imagine \nprogramming in C without procedures, however clever the editor s copy-and-paste technology? In this paper, \nwe describe a possible extension to Excel that sup\u00adports user-de.ned functions (Section 4). It turns \nout that support for functions is closely associated with better support for vectors and matrices as \n.rst-class values, and we discuss that too (Section 5). The basic idea is simple. We propose that functions \nbe de.ned in terms of the formulae that are contained in a speci.ed part of the spreadsheet. The function \nsignature is de.ned by allocating some subset of the cells as function parameters. The main contribution \nof our work is not the user-de.ned function idea per se, but the large amount of detailed design required \nto inte\u00adgrate this new view of spreadsheet behaviour into an existing prod\u00aduct whose continued survival \ndepends on its genuine usefulness to humans. Because we focus on end users rather than professional program\u00admers, \nusability is a fundamental concern, so we been consciously guided by research into human-computer interaction. \nBeyond its speci.c design, our work shows how principles drawn from HCI re\u00adsearch can be applied to the \ndesign of programming environments, in a very concrete, practical way. This is important the ultimate \ngoal of all programming technology is to make people more pro\u00adductive but other documented examples \nare hard to .nd. We hope that the paper may also serve to remind the functional programming community \nof a large but mostly-ignored group of functional programmers; namely, end users. Highly-expressive pro\u00adgramming \nis particularly important for this group, so functional lan\u00adguages are especially relevant. We are in \nactive discussion with the Excel developers about the possibility of including user-de.ned functions \nin a future version of Excel. Our progress in these discussions has been encouraging, but whether we \nwill ultimately succeed in that endeavour is, of course, uncertain.  2 A user-centred approach to language \ndesign Despite the de.ciencies of spreadsheets when they are considered as programming languages, it \nis clear from their commercial suc\u00adcess that people .nd them useful and usable. This is not true to the \nsame extent of any traditional programming language. Why not? One contributing factor may be that, although \nprogramming lan\u00adguages are a channel of communication between people and com\u00adputers, most programming-language \nresearch is devoted to the com\u00adputer end of the channel. Comparatively little research considers the \npeople who do the programming [NC85]. It is our belief that programming language design projects should \nadopt a more user\u00adcentered approach, in order to maintain a sharp focus on the people who are intended \nto bene.t from the new language features or envi\u00adronments being created. This is the approach that we \nhave adopted in our own work on extending spreadsheet capabilities. The groundwork for this project comes \nfrom specialised research into the psychology of programming and empirical studies of pro\u00adgrammers (e.g. \n[BG87, CW00, DP95, GPB91, HLMC96]). It is hard, though, for a programming-language designer to .nd prac\u00adtically \nuseful guidance from such research. Individual studies in these .elds are often experimental investigations \nof relatively con\u00adstrained contexts or points of syntax, so that it can be hard to .nd empirical evidence \nthat usefully informs design decisions for new languages. Furthermore their theoretical generalizations \ntend to emphasise cognitive theories of problem solving, which are not readily applicable by programming \nlanguage designers. To address this problem, HCI researchers have developed struc\u00adtured approaches to \nconsidering human issues in programming. We single out two Cognitive Dimensions and Attention Invest\u00adment \n that have been used successfully in other recent program\u00adming language and environment design projects \n(e.g., [LGAH02, BCACA02, BBC02]). In the following sub-sections we brie.y re\u00adview these two frameworks. \n Abstraction What are the minimum and maximum levels of gradient abstraction? Can fragments be encapsulated? \nConsistency When some of the language has been learnt, how much of the rest can be inferred? Error-proneness \nDoes the design of the notation induce care\u00ad less mistakes ? Hidden depen- Is every dependency overtly \nindicated in both dencies directions? Is the indication perceptual or only symbolic? Premature com- Do \nprogrammers have to make decisions be\u00ad mitment fore they have the information they need? Progressive \nCan a partially-complete program be executed evaluation to obtain feedback on How am I doing ? Role- \nCan the reader see how each component of a expressiveness program relates to the whole? Viscosity How \nmuch effort is required to perform a sin\u00ad gle change? Visibility and juxtaposability Is every part of \nthe code simultaneously visible (assuming a large enough display), or is it at least possible to compare \nany two parts side\u00adby-side at will? If the code is dispersed, is it at least possible to know in what \norder to read it? Figure 1. Cognitive Dimensions (excerpted from [GP96]) 2.1 Cognitive Dimensions The \nCognitive Dimensions of Notations (CDs) framework dis\u00adtills knowledge from the psychology of programming \ninto a form that can help non-psychologists to assess usability at design time [GP96, BG03]. CDs are \nnot language design rules, but instead provide vocabulary that enumerates concepts important to human \nproblem solvers who are engaged in programming tasks. Many of the CDs express concepts that are already \nvery familiar to language designers, but in an informal way. As a result, they may seem ob\u00advious, but \ninformally familiar design concerns are easily forgotten when attempting to maximize other properties \nsuch as conciseness. The bene.t of CDs lies in having an explicit list of design attributes summarizing \nempirical evidence about programming language or environment attributes important to human problem solving \n which can be checked and referred to throughout a design project. Our own design was guided by our use \nof the CDs framework dur\u00ading the design process. An example of a CD is consistency. Although most language \nde\u00adsigners know generally that consistency is a good thing , the con\u00adsistency dimension sharpens the \nconcept by expressing it as a ques\u00adtion: When some of the language has been learnt, how much of the rest \ncan be inferred? [GP96]. Expressed in this way, the con\u00adsistency dimension makes a point that is particularly \nrelevant to our project, because it is a key to end users likelihood of successfully using user-de.ned \nfunctions in spreadsheets. Another example is viscosity: the amount of effort required to make a small \nchange to the information structure. For example, a lan\u00adguage that lacks procedural or functional abstraction \nis highly vis\u00adcous, because code must be repeated. This means that changing the code later takes work, \nbecause all of its repeated locations must be changed. Figure 1 summarises the CDs that we use in this \npaper. We use them in a formative (before-the-fact) way, to inform our design while it is taking shape, \nby raising warnings when a design decision is poten\u00adtially at odds with research from cognitive principles \nof program\u00adming. Of course, Cognitive Dimensions cannot prove that no such problems remain. Eventually, \ncomplementary devices aimed at summative (after-the-fact) evaluation, such as empirical studies, are \nalso needed. 2.2 Attention Investment The Attention Investment model of abstraction use analyses the \nac\u00adtions that will be taken by a programmer in terms of investments of attentional effort [Bla02]. Here \nis the idea. Programmers have a .nite supply of time to spend concentrating on their work, or atten\u00adtion, \nto invest. They will invest their effort in activities for which their expected payoff exceeds the cost, \nunless the risk is too great. The cost of the investment is the amount of attention by the user that \nmust be devoted to accomplishing a task. The expected payoff from that investment will be some saving \nof attentional effort in the future, such as by achieving a good abstract formulation to reduce the amount \nof effort required to cope with similar problems. The perceived risk is the extent to which the user \nbelieves the invest\u00adment will not produce the payoff, or that it will lead to even more costs that are \nnot yet apparent. This simple investment model, when applied at multiple levels of granularity, can model \nmany of the actions and decisions made dur\u00ading programming tasks. The model has been validated in a cog\u00adnitive \nsimulation of programmer behaviour for .ne-grain decisions [Bla02], and there is evidence that it is \neffective in practical lan\u00adguage design [BB02, BBC02]. As with the CDs framework, most language designers \nhave an in\u00adtuitive understanding of these issues. The model s value for our work has been in making these \npsychological concerns explicit, so that we can analyse and justify design decisions. As an intellectual \ntool for language designers, a strength of the Attention Investment model is its generality, which allows \nit to provide insights not pro\u00adduced by the more speci.c CD framework. On the other hand, the concrete \nenumeration of issues in CDs is more prescriptive of spe\u00adci.c problems to consider, and provides sharper \nquestions for lan\u00adguage designers. For this reason, we consider the two approaches to be complementary \nintellectual tools, and use them both in the work described here.  3 The user-centred case for functions \nOur goal is to extend Excel by making it easier for end users to de.ne and re-use their own libraries \nof domain-speci.c functions. Is this a good idea in the .rst place? After all, spreadsheets have evolved \nover a good number of years, so maybe the status quo is near-optimum. In this section we make the case \nfor user-de.ned functions, using the language of Attention Investment to consider potential payoffs and \ncosts from a human productivity standpoint. 3.1 What are the payoffs? Users will invest effort if they \nforesee a reasonable payoff. First we must consider the potential actual payoffs. Whether our target \nau\u00addience will perceive these payoffs will be discussed in the relevant sections that follow. For programming \nlanguage folk it is not too hard to see what the actual payoffs of user-de.ned functions might be: Avoid \nrepetition. Suppose a user repeatedly types a formula such as IF(A6 = 0, ,A6), which blanks out zero \nvalues. This repeated work is tiresome. Even worse, if instead of A6 the user wants a formula such as \nSUM(D1:E9) * 2, it would have to be duplicated in the IF formula. User-de.ned functions enable them to \nidentify, name, and re-use code that they use again and again: thus BLANK ZERO(A6), or BLANK ZERO(SUM(D1:E9) \n* 2). Reduce errors during maintenance. Excel encourages copy\u00adand-paste of complex formulae; but if \na copied formula must be modi.ed later, all the places it was copied before must be found and updated, \nwhich is error-prone (see Figure 1). A named function encapsulates the formula, thereby protecting against \nthat source of risk. It also reduces the user s attentional cost by reducing viscosity (resistance to \nchange), because the encapsulated formula needs to be changed in only one place. Our interview with an \nauditor at a major accounting .rm revealed that he considers the problems of error proneness to be quite \nsevere: I will remind you that in 6 years work, checking literally hundreds of business-critical models, \n... my team have never failed to .nd errors. Real estate management. A function call takes up only one \ncell to invoke, even if the function s de.nition spans many cells. This provides a natural way to save \nreal estate on the invoking sheet. Real estate management is clearly important in prac\u00adtice: Excel has \na great deal of support for it (hiding rows and columns, collapsing groups, and so on). Encapsulate and \nre-use domain-speci.c expertise. User-de.ned functions directly support re-use. Local domain experts \ncan create libraries of functions, tailored to their particular application and context, that can be \nre-used by their colleagues. Our interview with another customer revealed the high potential he ascribed \nto this bene.t: If we can crack the ability to reuse blocks of code it will be immensely valuable, both \nwithin a spreadsheet to curb repetition, and between spreadsheets too in the form of standard libraries. \n Intellectual property protection. While function bodies can be manifest, they do not have to be. User-de.ned \nfunctions pro\u00advide an easy way to encapsulate and distribute intellectual property. Performance. Behind \nthe scenes, a function can be represented as an expression tree, compiled to byte code, JITted to machine \ncode, or whatever, with substantial performance bene.ts. In\u00adterviews have revealed that for certain important \nuser groups (notably in .nance) performance is critical. More generally, the goal is simply to provide \nend users with the same complexity-management tools that we take for granted as pro\u00adfessional programmers. \n 3.2 What are the costs? User-de.ned functions are, in fact, already available in Excel; all you need \ndo is de.ne your function in Visual Basic1! The trouble 1Earlier versions of Excel supported user-de.ned \nfunctions via so-called XLM macros , not to be confused with what Excel cur\u00adrently calls a macro . XLM \nmacros looked super.cially more fa\u00admiliar than Visual Basic to a spreadsheet user, because the macro \ncode was laid out on a grid of cells. The semantics of the grid was rather different to an ordinary worksheet: \nit was in fact an imperative programming language, with sequential evaluation and a program counter, \nbut with Excel s formula language as a sub\u00adlanguage. The attention-investment cost was still high, albeit \nnot as high as learning Visual Basic. In fact, XLM macros are still available (right-click on a worksheet \ntab, select Insert... and pick Excel 4.0 macro sheet ), but they are not documented or encour\u00adaged. is \nthat the cost (in terms of attention investment) is very high. The programming paradigm is different \n(imperative instead of declar\u00adative); the notation is different (block of text instead of a grid of cells); \nthe programming environment is different and complex (Vi\u00adsual Studio); the debugging model is different \nand less accessible (debugging in Excel means looking at values that are continuously displayed in intermediate \ncells, while debugging in Visual Basic means managing the Visual Studio debugger). These differences \nlead to high learning costs. One of our meetings with Excel users contributed further insights into additional \ncosts in the real world: Excel already has the oppor\u00adtunity to package up oft-repeated calculations as \nVisual Basic func\u00adtions. However, what you are proposing is much to be preferred... One [advantage] is \nperformance; VB functions can be rather slow. ... VB functions break the audit trail; not all of their \nbehaviour is determined by their parameters, as they can retrieve data from cells other than through \nthe parameter list. Debugging VB functions re\u00adquires programming skills; yours requires more standard \nspread\u00adsheeting skills. With costs like these it is hardly surprising that many users never make the \ninvestment.  3.3 Costs vs payoffs: our target audience Our design lowers the total costs, but not to \nzero. In order to under\u00adstand the costs of our design, it is .rst necessary to identify which of the \nlearning cost elements are zero, i.e., the prerequisite skill set expected of the intended audience [YBDZ97]. \nA prerequisite is both an asset and a barrier designers can build design features on the prerequisites, \nbut people who do not have the prerequisites should not be expected to succeed at tasks that require \nthose pre\u00adrequisites. For our design, the prerequisites are these: users should be (1) comfortable with \nusing a variety of built-in functions, not just the in.x operators; (2) comfortable using Excel s copy/paste \nor replicate operations, in which a formula is systematically altered to suit its new location; and (3) \nable to use more than one worksheet in a workbook2. The .rst and the third items provide the scaffold\u00ading \nupon which our approach rests. The second item is tied with increasing the attention payoff, because \nit is in this item where the long-term maintenance costs of these users current procedures can be reduced. \nSome people use Excel for nothing more than managing and print\u00ading a list of information. Others know \nhow to use very simple for\u00admulae, such as = SUM(A1:A10), but nothing more. Our design has little to offer \nthese groups, because the payoff (approximately zero) is lower than the learning costs of the prerequisites. \nOur primary target audience is moderate users those who under\u00adstand the spreadsheet paradigm fairly \nthoroughly. Not only have they already mastered the prerequisites, but they also tackle more ambitious \nand long-lived applications than does the .rst group, so the payoff is greater. Advanced users can also \nbene.t. Advanced users are those who understand Visual Basic and use it to write functions they call \nfrom Excel formulae. Our design will be valuable for them if it enables them to accomplish, at lower \ncost or lower risk, some tasks that previously required Visual Basic. 2In Excel, a .le contains a workbook; \na workbook consists of one or more worksheets, each of which has up to 256 columns and an arbitrary number \nof rows. Using multiple worksheets makes it easier to avoid logically separate computations bumping into \neach other .  Figure 2. A function instance sheet (bottom) and its invocation site (top)  4 User-de.ned \nfunctions in Excel How, then, should user-de.ned functions be added to Excel? In this section, we show \nhow the CDs and the model of attention invest\u00adment revealed the answers to a number of language design \nissues that arose in attempting to answer this question. 4.1 Applying the consistency CD Recall from \nFigure 1, the consistency CD is expressed as When some of the language has been learnt, how much of the \nrest can be inferred? Since we would like our target audience, whose prereq\u00aduisite skills we enumerated \nin Section 3.3, to be able to infer (have a low-cost way of learning) how to create, view, and modify, \na user\u00adde.ned function, applying the consistency CD is critical. We ap\u00adplied it by establishing the following \nground rule, which is the key distinguishing feature of our design, relative to any commercially\u00addeployed \nalternatives. (We discuss related work in Section 6.) The implementation of a function must be de.ned \nby a spreadsheet, because that is the only computational paradigm understood by our target audience. \n In keeping with this ground rule, in our design a function imple\u00admentation is given by a worksheet, \nwhich we call a function in\u00adstance sheet, or sometimes just function instance for short. As the prerequisites \nlist of Section 3.2 has already established, our tar\u00adget users bring to the table an understanding of \nthe idea of multiple worksheets, and that worksheets can be linked by writing a formula in one worksheet \nthat refers to a cell in another. To be consistent with these prerequisites, our design makes a function \nsheet look and behave much like a linked worksheet. Figure 2 shows an example. The upper worksheet is \nan ordinary worksheet. Cell C3 contains an invocation of a user-de.ned func\u00adtion F2C, which converts \ntemperatures in Fahrenheit to Centigrade. The implementation of F2C is given by a function instance sheet, \nshown below in the same .gure3. The input parameter lands in cell B1 of the F2C function instance; cell \nB2 contains an intermediate value, while the .nal result is computed in B3. The fact that that B1 contains \nthe input and B3 the result is also speci.ed in the interface panel that appears at the bottom of every \nfunction instance, which 3Excel already has facilities to show multiple worksheets one above the other. \nde.nes the external interface to the function. Notice, too, that the input cell B1 contains the formula \n= Sheet1!B3, which makes ex\u00adplicit where the function instance gets its input from, using Excel s existing \nnotation for cross-sheet links. Cells A1 - A3 contain com\u00admentary written by the user. From the .gure \nit is clear that user-de.ned functions are like spread\u00adsheets in appearance. The consistency CD makes \nclear that they must evaluate like spreadsheets too. Thus, all values are continu\u00adously calculated and \ndisplayed. If the user changes the value in B3 of the calling sheet, not only is the new result of the \ninvocation cal\u00adculated and displayed in C3, but the values in each cell of the F2C sheet are also updated \nwith their new values. Similarly, any change to the F2C sheet is immediately re.ected by re-calculation. \nTo maintain consistency with other worksheets, function instance sheets can also contain formatting, \nfunny column widths, fancy bor\u00adders, charts, and whatever, all of which may help someone looking at the \ninternals of the function. In short, an underlying principle behind every design choice has been consistency \nin every way pos\u00adsible between function instance sheets and other worksheets. This consistency helps \nto align the users perceived costs and risks of functions with the actual costs and risks. For example, \na function sheet s immediate recalculation sends a visual message to the user, that these sheets are \nlike the ordinary worksheets to which the user is accustomed. For consistency with built-in functions, \na user-de.ned function has exactly the same status as a built-in function, once de.ned. For ex\u00adample, \nExcel s existing function-entry wizard (a little fx button to the left of the formula bar) pops up a \nmenu of possible functions, organised by category; when one is chosen, a second dialogue pops up with \na box for each parameter, each with its name, and an ac\u00adcompanying summary of what the function does. \nIn our design, all of this works the same with user-de.ned functions as with the built-ins. What does \nthe consistency CD imply about recursive functions, so dear to the hearts of functional programmers? \nWhile recursion still makes sense in the spreadsheet paradigm [BAD+01], it is much less useful than in \nmainstream functional languages: in the absence of algebraic data types, the only inductive type is integers \n and one can iterate over integers using arrays, much as in APL (Sec\u00adtion 5)4. Further, recursion would \nthreaten consistency with the linked-worksheet model, because the number of linked worksheets would be \ndata-dependent. Lastly, recursion leads to deeper invoca\u00adtion stacks, which translates into more function \nsheets potentially cluttering up the workspace, each element of which adds very little new information \nto the human problem solver. 4Excel also supports another, dangerous form of iteration, via circular \nformulae (e.g. A1 = A1 + 1). This sort of recursion utterly breaks Excel s basic functional paradigm, \nbecause each re\u00adcalculation sweep computes a fresh iteration, so the value of each cell changes over \ntime. Our proposals do not make this technique safer, nor do they intefere with it. In short, recursion \nthreatens consistency and potentially adds attention-investment costs without adding corresponding payoffs. \nFor these reasons, in our design we chose not to support recursive user-de.ned functions5. This decision \nwas not taken lightly, but is a conscious prioritisation of usability over generality. 4.2 Visibility \nissues Role expressiveness and hidden dependencies are two CDs whose in.uences on our design choices \ncan be seen in Figure 2. Excel al\u00adready does a nice job of expressing each cell s role in a calculation \nwith its color-coded rectangles; we extend this technique to make clear the roles of actual/formal parameters \nand the return value. Hidden dependencies ( Is every dependency overtly indicated in both directions? \n) are something of an issue in the commercial version of Excel in the presence of linked worksheets, \nbecause the data.ow arrows work only for references within the same spread\u00adsheet. In our design, data.ow \narrows can connect linked work\u00adsheets, as shown in the .gure. As the .gure shows, these two de\u00advices \nmake explicit the role of the new function relative to the other worksheets. The visibility CD emphasizes \nthe importance of every part of the program being simultaneously visible (assuming a large enough display). \nThe side-by-side aspect of juxtaposability (discussed in [GP96]) also brings out the importance to human \nproblem solvers of being able to display related items side-by-side. Since cells val\u00adues and their formulae \nare clearly related, in our design it is possible to view formulae and values together, side by side, \nas shown in Fig\u00adure 2. Further, following from the visibility aspect of this CD, in our design we allow \ndisplay of formulae and values simultaneously in all visible cells, not just one cell at a time. (Excel \ncurrently al\u00adlows viewing of all cells values with only one cell s formula, or all cells formulae with \nonly one cell s value, and the formula is displayed in a separate window pane away from the values.) \n 4.3 Applying the premature commitment CD In programming languages for professional programmers, pro\u00adgrammers \n(1) .rst realize they want to de.ne a function, (2) then they de.ne that function, and (3) .nally they \ninvoke the function. Step (1) must occur before step (2), which must occur before step (3). But our target \naudience does not necessarily possess the knowledge that tells them they should de.ne a user-de.ned function \n re\u00adcall there is nothing in their prerequisites list about prior experience with user-de.ned functions. \nAny design that required the above se\u00adquence would be ignoring the premature commitment CD, which warns \nabout requiring an audience to make a decision before they have the information to do so. As this CD \nmakes clear, since the above sequence is unlikely to be followed by our target audience, our design must \ninstead support a sequence that does not require such premature commitment. Therefore, the sequence we \nsupport is this: (1) the user has already written some code (formulae) that works well, (2) the user \ndecides the code needs to be reused or repeated, (3) the user discovers a low-cost low-risk way to reuse \nthe existing code through user-de.ned functions, and (4) the user acts upon the discovery by converting \ntheir existing code to a user\u00adde.ned function, which is automatically invoked, when sensible, where the \nexisting code used to be. 5Can the user create a recursive function by accident? As in all other formula \nedits, if the user attempts to enter a recursive, or even mutually recursive formula, the system must \nattempt to compute the answer. In the process of doing so, if the system re-invokes the same function \nname, it can stop computing and reject the newly entered formula. To support this sequence, we allow \nthe user to start with the code they have written in these two ways: Start from a formula in a single \ncell, or Start from an existing ordinary worksheet range of cells. Note that neither case requires the \nuser to know in advance that she is going to create a function; rather we provide ways for her to take \nher work so far and encapsulate it. To create a function from a formula in a single cell, the user brings \nup the cell s property menu (with a right-click) and selects Make a function using this formula . This \naction creates a new function sheet, displayed in a second window. Thus, the user s actual cost is low: \na right-click to pop up the property menu and select the option. (Users will encounter this option when \nthey have other reasons to pop up the cell s property menu.) Their risk of losing their invested effort \nin creating the previous formula is also low, since the answer in the cell remains the same. The wording \nof this menu option has been deliberately chosen to be non-destructive in an attempt to communicate this \nlow risk, and the fact that there are no ellipses or sub-menus attempts to communicate the low cost. \nIn creating the new function, the system automatically guesses the number and order of parameters based \non the formula, and replaces the original formula by an invocation of the new function, whose name is \nprovisionally just UNTITLED . The number and order of parameters is necessarily a guess; for example, \nin the formula (A6- 32) * 9/5 are there four parameters (A6, 32, 9, and 5), three, two, or just one (A6)? \nOr perhaps there is just one parameter (A6 - 32). The system can make a reasonable guess, but there is \nno way to be sure. In any case, the user can readily .x up the guess by editing the interface (Section \n4.6). The other way to create a function is from a larger portion of an existing worksheet. To do so, \nthe user selects a range of cells, right\u00adclicks, and selects Make a copy into a function . The original \nrange is left unchanged, but is also copied into a new function sheet. Again, the system guesses inputs \nand outputs, this time based on dependencies in the range, and the user edits the result. Initially, \nthere is no invocation of the new function. The consistency CD arises again here, this time in opposition \nto concepts from Attention Investment. Clearly it is not consistent that our design for generating a \nfunction from a range of cells makes a copy, leaves the original unchanged, and does not invoke the new \nfunction whereas generating a function from a single cell actu\u00adally replaces the original formula with \na call to the new function. However, the user s perception of cost and of risk could both be adversely \naffected if an entire range of cells formulae were to dis\u00adappear and be replaced with a single call to \nanother sheet. Fur\u00adther, the likelihood of correctness of the system s guesses of inputs and outputs \nis lower, which means the user would have to patch up cell relationships without having the original \nversion with which to compare. (While an undo button could rescue the user from such functions that seem \nwrong, it cannot make the use of functions seem less costly instead, it simply makes it easy for the \nuser to decide not to go forward with functions.) In essence, the cost of consis\u00adtency is too high in \nthis case, in terms of both the user s attention cost and their possible perception of the risk involved \nin using func\u00adtions.  4.4 Applying the abstraction gradient CD In programming languages we are accustomed \nto distinguishing be\u00adtween a function de.nition (which we see in our editor) and a func\u00adtion invocation \n(which we only see in our debugger, as the transient contents of a stack frame). A function de.nition \nis abstract, in the sense that it does not include any actual data from a speci.c instance of invocation. \nThis means that, when writing a function, program\u00admers have to model (in their heads or on paper) the \nactual data that will be present when the function is invoked. This modeling process is an additional \nattention cost [Bla02], and causes problems for end users working with functions in other languages. \nThese cognitive challenges are described by the CD of abstraction gradient. In contrast, Figure 2 involves \nno de.nition/invocation distinction. There, the F2C function is shown not as an abstract de.nition, but \nas an actual instance of the function being invoked. This function instance is populated with live data \noriginating from a speci.c in\u00advocation site the cell where the function is called (the name of the actual \ninvoking cell is in the interface panel). If there are many in\u00advocations to F2C then, conceptually at \nleast, there are many copies of the F2C worksheet, each with the same layout and formulae, but populated \nwith different data. There is no such thing as the de.ni\u00adtion sheet for a function; every function instance \nis populated with data from somewhere. This means that the user can immediately see the effect of any \nchange on some set of concrete data. This feature is analogous to the object-oriented prototype/instance \nmodel, in which the func\u00adtional equivalent of a class is de.ned via a prototype object, from which additional \ncopies (instances) can be made. Perhaps the best known language following this model is Self [US87]. \nThe pro\u00adtotype/instance paradigm, like our function instances, reduces the user s attention cost by reducing \nthe abstraction gradient. The user s experience of these function instances is very similar to that of \nlinked worksheets, bringing the bene.ts of a low learn\u00ading cost from this consistency, but it raises \nsome interesting design questions: If there are thousands of invocations of a function, how can we avoid \noverwhelming the user with thousands of worksheets (Section 4.5)?  If only function instances are displayed, \nhow can one edit the function de.nition (Section 4.6)?  What are the implications for debugging functions \n(Sec\u00adtion 4.7)?  4.5 Managing visibility costs Our design greatly increases the amount and kind of \nlogic visible in worksheets, and with that increased visibility comes the increased attention cost of \nmanaging the display. For example, when each function instance is displayed as a worksheet, there may \nbe a great many worksheets active at once. How can the user see just the ones she wants? Excel can display \nmultiple windows simultaneously, inside the overall Excel frame. In each window, Excel displays one work\u00adsheet \nat a time. The user can select which worksheet is displayed in a window by clicking on that sheet s named \ntab. For example, Figure 2 shows a 2-window display, in each of which a different sheet has been selected. \nThe obvious model is to have a named tab for each function instance (since they are meant to be like \nworksheets), but that leads to two immediate problems. First, there are just too many of them; with a \nbit of copy-and-paste, it is easy to create thousands of function invocations. Second, and more subtly, \nit is hard to name the func\u00adtion instances in concrete terms, what should we display on the function \ninstance s tab to identify it? Clearly the name of the func\u00adtion alone is not unique; nor is the name \ntogether with the call site, because the call site s sheet will have the same naming problem if it too \nis a function instance. We must provide low-cost ways for the user to navigate this sea Figure 3. A \nfunction that calls another function of function instances. We do so by providing, for every function \ninstance, (a) a direct link from a cell to the function instance(s) invoked by the formula in that cell, \n(b) a direct link from a function instance to the formula that invoked it, and (c) a direct connection \nbetween instances of the same function. More speci.cally, given an invocation tree (or call tree) of \nfunction instances, the user can navigate in the following ways. Navigating down the tree. Suppose that \na cell (on any sheet either an ordinary sheet or a function instance) has a formula contain\u00ading an invocation \nof a function Foo. The user selects the cell and requests6 the function instance sheet for a call in \nthat cell; in re\u00adsponse, the sheet appears below the invoking sheet. For example, if only the top sheet \nof Figure 2 had been visible, and the user then in\u00adteracted in this way with cell C3, the screen would \nappear as shown in the .gure. Navigating up the tree. Given a function instance sheet, how does the user \n.nd where in the invocation tree that sheet is? That ques\u00adtion is answered by looking at the function \ninstance s summary in\u00adterface panel, which is always displayed at the bottom of the sheet. It says explicitly \nwhere the function is invoked from; for example Called from A3 of Sheet1 , or Called from B7 of function \nFoo . In the latter case, a popup-menu triangle appears next to Called from , which brings up the entire \nstack of Called from speci.ca\u00adtions, all the way up to an ordinary function sheet. Selecting any member \nof this stack causes it to be displayed in a new window, now above the current one, thereby navigating \nup the invocation tree. Again following the local tree navigation metaphor, the im\u00admediate invoker can \nbe displayed by a single click on the Called 6Via a button or right clicking and select show sheet for \nFoo . from... link. Figure 3 gives an example of nested function invo\u00adcation, showing the popup menu \npopped up in the CircArea sheet. This menu also allows the user to locate a particular function in\u00adstance \nin the invocation tree, alleviating the lost in hyperspace problem. Excel s usual behaviour when one \nclicks on a tab is for the speci.ed worksheet to replace the one currently displayed. When navigating \nthe call tree, however, it is very desirable to show the user both both the function s de.nition and \nits context of use at the same time the CD of visibility/juxtaposability again. In our design, therefore, \nwhen navigating down the tree, the current worksheet slides up the display, and the speci.ed function \ninstance is shown in a second window below it. Dually, when navigating up the tree, the current worksheet \nslides down, and the invoking sheet is displayed above it. Function instances still have a tab, like \nother worksheets, but the tab displays only the name of the function. Clicking on the tab brings the \nmost recently-viewed instance of that function to the front (without any window-shifting; this is just \nthe normal click\u00adon-tab behaviour). So, in effect, all the instances of a particular function share a \nsingle tab. Jumping across the tree. What if the user wants to explore more than one part of the invocation \ntree at once? If those parts involve different functions, he can just click the tab of the appropriate \nfunc\u00adtion. If he wants to see them side-by-side, he can use Excel s .ne existing support for juxtaposability \nby adding new windows. If the two parts involve different instances of the same function, matters are \nnot so clear, because there is only one tab for that func\u00adtion. We deal with this case by adding a drop-down \nmenu to the function tab, which gives access to recently visited instances of the function, identi.ed \n(albeit perhaps ambiguously7) by their immedi\u00adate call site. 4.6 Applying the hidden dependencies CD \nThe hidden dependencies CD rises to particular importance when we consider the issue of change. This \nCD calls attention to the dan\u00adger of unintended consequences when users make changes without full awareness \nof the dependencies involved. The hidden depen\u00addencies CD suggests that a way to head off such problems \nis to make dependencies explicit. In this section, we show how our de\u00adsign acts upon this suggestion \nin two change situations: changing a function s implementation and changing a function s interface. First, \nconsider changes to a function s implementation. Obviously, the way the user edits the function s implementation \nis simply to change the cells on one of the function s instances, but when hap\u00adpens to the other instances? \n(Recall, there is no master copy of the function; every worksheet is simply an instance, of equal stature \nas all the other instances.) When one makes a recurrent appointment in an electronic diary, and then \ntries to modify it, a pop-up dialogue box shows up saying Do you want to alter just this appointment, \nor the whole series? In our design, function editing works in the same way. If the user tries to modify \na function instance, a pop-up box asks whether she wants to modify all the invocations to the function \nin the same way (the default), or whether she wants to create a special-purpose copy of the function \nfor this particular invocation. (If there is only one invo\u00adcation of the function, a common case when \ndeveloping a function, the modify this one or all? question is not asked at all.) Asking 7The potential \nambiguity is like the Alt-Tab display through which the Windows operating system offers rapid, but ambiguous, \nnavigation to running applications. the user explicitly whether she intends to make a global change, \ndraws her attention to and gives her control over the depen\u00addencies impacted by the change. If the \nuser asks to modify all invocations of the function, the func\u00adtion instance becomes open especially for \nmultiple-instance editing (with visual feedback to that effect) so that the same question is not asked \nrepeatedly, which would greatly raise attention costs. If the user asks to modify just the current invocation, \nthe function is au\u00adtomatically renamed, because it is now a genuinely new function, distinct from the \noriginal. Second, consider changes to a function s interface for example, to add a parameter, or to \nchange the name of the function. The user s mechanics are straightforward: the Edit button on the in\u00adterface \npanel allows the interface to be edited, by bringing up a dialogue box that shows the complete interface \n(which includes the function s name, information about each parameter, devices to add or remove parameters, \ndocumentation and help text, etc.) However, how the system should respond if the function has existing \ninvoca\u00adtions is not always so straightforward. If the user has changed the function s name, or the order \nof its pa\u00adrameters, the system s response is simply to make the same change at each invocation site. \nDeleting a parameter can work the same way. Adding a parameter is more problematic because heuristics \nwould be needed, and any wrong guesses could invisibly intro\u00adduce bugs without the user realizing the \nextent of changes being made at multiple locations, including locations not visible on the screen. Even \none such occurrence could greatly increase the user s costs and perception of risk. To avoid this problem, \nin the case of adding parameters, the invocation sites are .agged as broken (e.g. Foo(A2, 7) becomes \nFoo(A2,??,7)). For this approach to be useful, broken instances must be easy for the user to .nd. Excel \nhas a way to select8, and then visit, cells with certain properties (hold\u00ading an error value, holding \na boolean formula, etc). In our design, the same technique is used to .nd cells with broken invocations, \nand also cells that invoke a particular function. Any of these invo\u00adcations that do not get .xed that \ninvoke non-existent functions or have the wrong number of parameters will result in error values, which \nare Excel s equivalent of raising exceptions. Such exceptions explicitly inform the user of dependencies \nrequiring attention due to the interface changes.  4.7 Applying the progressive evaluation CD In other \nprogramming languages, a particular function invocation may exist only .eetingly during the execution \nof the program. Con\u00adsiderable planning (and its corresponding attention cost) may be required to halt \nthe program in a state that exhibits the fault; and even that often reveals merely that a different (often \nearlier) pro\u00adgram state must be captured. The CD known as progressive evaluation points the way to a \nsolu\u00adtion that avoids these costs, namely to automatically re.ect incre\u00admentally the speci.c values in \neach visible function instance result\u00ading from every formula edit. The progressive evaluation CD de\u00adscribes \nthis incrementality, and research shows that it is of critical importance to novice users [GP96]. Thus, \nin our design, debugging functions is, like any other kind of debugging in spreadsheets, an activity \nthat can begin as soon as the code-building process begins, while the program is still incomplete. Even \nhalf-complete functions contain live data that is continuously kept up to date. Obviously, this is quite \nunlike conventional debuggers: there is no notion of stepping forward or setting breakpoints ; the program\u00adming \nmodel is simply a static tree of linked worksheets, all simulta\u00ad 8This facility is not well known: Edit/GoTo.../Special.. \n neously active and up-to-date. For example, if the user should won\u00adder why the invocation F2C(50) gives \nthe result 10, he can look at the intermediate values that are always displayed in the F2C in\u00adstance \nfor that call, as in Figure 2. As this example illustrates, in our design, the live data in a function \ninstance is persistent9. Indeed, the entire invocation tree is persis\u00adtent, so that the user can view \nany number of function instances in the tree simultaneously. (That is why we generally use the term invocation \nrather than call ; it avoids the here-today-and-gone\u00adtomorrow implications of the latter term.) For example, \nFigure 3 shows a three-window view, showing the entire invocation tree for a small program. The absence \nof recursion facilitates navigation of the invocation tree: (a) its structure does not depend on the \ninput data, and (b) repetition is expressed through matrix operations (Sec\u00adtion 5) which do not clutter \nthe invocation tree, rather than through recursion, which would. Debugging functional programs has received \nquite a bit of atten\u00adtion from the programming-language community, both for strict languages [Lie84, \nFFF+97, TA90] and lazy ones [HO85, Nil98, SR97]. Some of these proceed by working backwards from an er\u00adroneous \nresult (algorithmic debugging); others work forward by allowing the user to step into redexes that she \nidenti.es. All make strenuous efforts to present program fragments in their origi\u00adnal source form. Our \ndebugging model has a very different .avour to any of these, because there is no mode change between \nwriting or modifying a program, and debugging it. Changes to the source are immediately re.ected in changes \nof the execution. Every interme\u00addiate value is readily accessible, surrounded with any comments, re\u00adlated \nvalues, or other context, that the programmer originally wrote. Overall, the integration of debugging \nwith programming is so com\u00adplete that users may not even regard it as a separate activity. This integration \nhelps to align the perceived costs of working with user\u00adde.ned functions with the actual costs. The use \nof progressive evaluation does not mean that spreadsheets are any more correct than other programs! Much \nresearch (surveyed in [Pan98]), has shown that spreadsheets are typically riddled with errors, and users \nwildly over-estimate the reliability of their spread\u00adsheet models. Approaches have been proposed to help \naddress these problems [RLDB98, IMCZ98, Dav96], and these approaches are directly applicable in the context \nof Excel-with-functions.  5 Matrix values in spreadsheets It may not seem obvious that there is any \nneed for a matrix type in a spreadsheet. The spreadsheet itself is very clearly a visual represen\u00adtation \nof a matrix, and the conventional way of using spreadsheets is to divide the plane into individual patches, \neach holding a one-or two-dimensional collection of data values. Functions change the picture, though, \nas the consistency CD makes clear. The issue is consistency of user-de.ned functions with built\u00adins. \nConsider the built-in SUM function. It takes a vector or ma\u00adtrix as its argument; thus SUM(A1:A10) or \nSUM(A1:D10). Since built-in functions in Excel already take matrices as arguments, user\u00adde.ned ones ought \nto do so too. The next question is how. Consider a user-de.ned function to com\u00adpute the sum of the squares \nof the elements of a vector. Where on the function instance sheet should the input vector reside? It \ncould take up the .rst row, perhaps, but (a) we do not want to specify in the function s de.nition the \nsize of the vector, (because the built-ins 9Persistent in the user model, that is. The implementation \ncan, of course, cache or recompute function instance data on demand using any caching strategy. accept \nmatrices of arbitrary size), and (b) we might like a function to work on matrices and there is only room \nfor one unbounded ma\u00adtrix on a worksheet! The obvious solution is to allow an input vector (or matrix) \nto live in a single cell. Values in Excel carry dynamic type information for example, strings, numbers \nand error values are distinguishable. All that is required is to add an extra run-time type, namely ma\u00adtrix. \nWe deliberately use terminology that is semantically oriented ( vector , matrix ) rather than implementation-oriented \n( array ). Excel already supports matrix values in so-called array formulae , but that support relies \nupon explicit size information in every refer\u00adence to and propagation of the array of values, which we \nhave al\u00adready pointed out violates consistency with built-in functions. Our design extends Excel by making \nmatrices truly .rst-class citizens that support consistency. The idea of matrices as .rst-class values, \ntogether with a rich library of functions that operate over such values, was .rst popularised by APL, \nbut has been widely used since in languages as diverse as High-Performance Fortran and Haskell, among \nmany others. The trick, of course, is how to incorporate them smoothly into Excel in a way that will \nbe actually used by our target audience of moderate users (Section 3.3). 5.1 The ground rules The two \ncognitive dimensions of consistency and error proneness, along with the Attention Investment notions \nof cost and risk, led to our basic design choices: Consistency: Any formula can have a matrix as its \nvalue.  Consistency: Matrices are two-dimensional, in keeping with Excel s two-dimensional paradigm. \n(However, a matrix ele\u00adment can be of any type, including a matrix, and this offers much of the power \nof N-dimensional matrices.)  Consistency: A vector is just a special case of a matrix (1xN or Nx1). \nThis means that horizontal vectors are not the same as vertical vectors, which is consistent with users \nexperience of working with rows and columns in spreadsheets.  Error proneness, cost, risk: Because of \nExcel s default of treating empty cells as zero-valued cells for some functions, there are likely to \nbe subtle differences between doing some kinds of matrix operations with a 1x1 matrix as versus with \na constant. To avoid the risk of subtle, hard-to-.nd errors that could arise, we do not de.ne a 1x1 matrix \nto be the same as a scalar. However, we also do not want to impose upon the user the seemingly arbitrary \ncost of turning scalars into 1x1 matri\u00adces. Thus, a scalar is implicitly promoted to be a 1x1 matrix \nin any context where a matrix is required. For example, con\u00adsider a function BESIDE which combines two \nmatrices side\u00adby-side into a bigger matrix. The formula BESIDE(1, B1:B2) works .ne, even though 1 is \nnot a matrix; it is simply pro\u00admoted to a 1x1 matrix.   5.2 Reducing perceived costs and risks in working \nwith matrices The user is not required to have the time and inclination to go ex\u00adploring for matrix features \nin order to eventually discover matrices. (Recall that interest in exploring new features was not one \nof the prerequisites we included in de.ning our target audience.) Rather, a key to our design is that \nmatrix values are likely to be automati\u00adcally created when the user starts creating his or her own functions. \nFor example, if a cell contains the formula = SUM(A1:A5)/4, and the user uses the Make a function from \nthis formula technique described in Section 4.3, then the newly-created function will auto- Figure 4. \nA worksheet that manipulates vectors. matically have a vector input parameter (A1:A5) landing in its \ninput cell. This provides a low-cost entry point into the use of matrix values. Once this event has occurred, \nwe would like the user s perception to be that the risks involved are low. Figure 4 will serve as an \nexample to discuss the steps we have taken toward this goal. Figure 4 shows a function MyAvg that might \nform part of a teacher s grading application. It takes a vector of marks (input cell A1) and a vector \nof weights (input cell A2), and computes the weighted sum of the marks (result cell A6). Cell A3 also \ncontains a vector, the result of multiplying the marks by the weights element-wise. The formula = SUM(A3) \nin cell A4 adds up the elements of the vector argument to SUM, namely the vector in A3. The invocation \non Sheet1 (not shown) would look like = MyAvg(A1: A5,{1,2,2, 1,2}), as can be seen from the formulae \nin the input cells of MyAvg. (The notation {1, 2,2,1,2} is Excel s existing notation for a literal vector \nvalue.) A key to reducing perceived risk is to help the user understand the meaning of the current state. \n(Dropping the users into a state they do not understand is likely to increase their perception of risk, \nwhich could send them directly to the undo button.) Thus, following the CD of role expressiveness, the \nroles of the matrix values in the function are explained to the user in two ways. First, the panel at \nthe bottom shows the overall role of the matrix values in this function. Second, any cell that contains \na matrix value, such as cells A1,A2,A3, gives a visual cue to its contents. Figure 4 gives an example \nof one possible cue, in which the cell contents shows the .rst few values, together with an arrowhead \nsuggesting more values. Hovering the mouse over the cell brings up a scrollable .oating panel, much like \nthat for a comment, that allows the user to examine (but not modify) the value of the matrix. This, too, \nis shown in Figure 4. 5.3 A potential risk: trapped in a matrix From a risk perspective, we do not want \nthe gathering of a group of values into a matrix to mean that the propagations and results of these values \ncan never again be spread out over a range of cells. For example, in Figure 4, the values of range = \nSheet1!A1:A5 have been gathered into a single cell = MyAvg!A1. If the range had been quite large (e.g., \n= Sheet1!A1:A100), most values would not be visible, except by scrolling the .oating panel. If it were \nnot possible to translate the matrix value back to a range of cells, users would be restricted as to \nhow they could view not only that matrix, but also all future matrix values propagated from the original. \nSince the uses of all future propagations cannot be predicted, this would be a clear case of the CD premature \ncommitment, requiring people to make decisions before they have all the necessary information. To avoid \nthis potential risk, we allow matrix values to be spread over a range of cells. More precisely, a range \nof cells may be given a single, matrix-valued formula, whose value is then spread across the range. For \nexample A1:A10 contains a horizontal vector value. To spread out a value over a range of cells, our syntax \nis this: se\u00adlect a range of cells, such as A1:A10, and type a formula, such as = B1:B12. (This is the \nequivalent of the strictly textual syntax of A1:A10 = B1:B12.) The value denoted by this formula (= B1:B12) \nis then spread out over the selected cells (A1:A10). If the value is too small, the unused cells are \nblank; if it is too big, the excess values are not shown (and indeed are not accessible). When hovering \nthe mouse over a range of cells that share a single formula in this way, the range highlights. If the \nrange is too small to .t the matrix value, the appropriate border(s) of the highlighted range are given \na ragged edge to indicate the non-visible values. One can then drag a handle in the corner to resize \nthe range, thereby showing more or fewer elements of the matrix.  6 Related work 6.1 Other approaches \nto functions in spreadsheets Excel today provides user-de.ned functions by allowing the user to write \na function in Visual Basic. We will refer to this a trapdoor approach, because it is simply an exit from \nthe usual language to a pre-existing one from the world of traditional programmers. Several research \nsystems have supported functions in spreadsheets. Except for the Forms family (discussed next), they \nare all either imperative or trapdoors. Examples of trapdoors that are also im\u00adperative include Penguims \n[Hud94], Action Graphics [HM90], SIV [CRB+98], Spreadsheet for Images [Lev94]. Prograph [SCB96] is similar \nexcept that the trapdoor goes the other way: one takes a trapdoor out of Prograph into a spreadsheet \n(with imperatives in it). C32 [Mye91] uses a semi-declarative approach via a trapdoor into Lisp. (By \nsemi-declarative, we mean that it is declarative to the same extent that Lisp itself is.) The notion \nof declarative functions as multiple sheets was .rst in\u00adtroduced by Forms [Amb87]. Although Forms itself \nwas a short\u00adlived language, its concept of functions as multiple sheets survived in the later members \nof this family of languages. The concept of how to support functions as multiple sheets was extensively \ndevel\u00adoped in Forms/3 [BA94, BAD+01], and this language in.uenced our Excel extension. However, research \nsystems have the luxury of not having to support existing communities or real-world needs. In light of \nthe realities introduced by these factors, the Excel extensions described here differ from previous research \nin a number of signi.cant ways. First, previous systems did not address creating a function from a pre\u00adexisting \nformula or spreadsheet. Rather, the notion was that a user would explicitly de.ne a function by building \na spreadsheet from scratch. De.ning functions from pre-existing formulae or sheets is critical for creating \na gentle migration path, because it allows legacy Excel workbooks to be gradually transformed, one function \nat a time, as repeated code is discovered. Second, previous research did not deal with some of the important \nscalability issues that related to usability, such as how to locate one of many functions and instances \nof the same functions. Scalability is often the critical point that determines whether solutions that \nlook .ne on toy academic problems can be truly useful. Because of its practical importance, this has \nbeen an important issue in the design of the Excel extension. Finally, there is support in the Forms/3 \napproach to functions for some features that are speci.cally not included in the Excel ex\u00adtension. Two \nof the most noticeable such features are automatic generalization of function calls and support for recursion. \nNeither of these features is expected to be of importance to our target audi\u00adence, and we have elected \nnot to include them. 6.2 Other usability techniques Empirical evaluation (or a usability study ) is \na reasonably com\u00admon approach to the evaluation of new user interface designs. Many research evaluations \nin HCI rely on controlled experiments, where user performance on an experimental task can be compared \nfor al\u00adternative interfaces. The problem for programming language de\u00adsign is how to select suitably representative \ntasks, re.ecting both the scale and variety of potential programs that might be created. Empirical studies \nthat address such broad questions are generally too expensive to inform a design like ours during its \nevolution, al\u00adthough they have value in a summative (after-the-fact) role. We do intend to follow standard \nMicrosoft practice in conducting usabil\u00adity studies of our design before it is brought to market. We \nconsider that this is an important reality check for any innovation. Empirically based design. A few \nresearchers have followed an ap\u00adproach in which empirical studies were conducted before the main design, \ntesting speci.c experimental hypotheses rather than gen\u00aderal measures of utility. Examples of this approach \ninclude the Hands language [PMM02] and SWYN [Bla01]. The similarity to our work is philosophical in \ntheir work and ours, the emphasis is on the human from the very outset of the design process. However, \nthese projects do not involve existing languages intended for pro\u00adduction use, and the experiments isolate \nfactors of interest rather than evaluating their contribution to a larger system. This means that the \nresearch process can be rather simpler than the constraints we face. Nevertheless, as most such research \nis published, we have been able to take advantage of .ndings from experimental studies testing aspects \nof Attention Investment, Cognitive Dimensions, and novel spreadsheet systems. Language design heuristics. \nA popular alternative to expensive em\u00adpirical studies is Heuristic Evaluation [NM90]. Summaries of good \npractice and of results from previous research are systematically compared to a new design, in order \nto apply the lessons from things that worked well, or badly, in the past. Heuristic evaluation is not \nnormally applied to programming languages, but an exception is the reference manual compiled by Pane \nand Myers collecting usability factors in programming language design [PM96]. They concen\u00adtrated on factors \nthat are relevant to novice programmers, mainly because this population is seen as suffering more severely \nwhen programming languages are hard to use. The techniques brie.y surveyed in this section concentrate \non eval\u00aduating and improving speci.c features of a language or program\u00adming environment. In our case, \nwe wanted to approach the problem from .rst principles, with usability concerns driving our whole ap\u00adproach \nto the design, rather than the more common approach, which is to create a .rst-cut design based only \non generic consideration of user concerns, that is then used as a target for more speci.c usabil\u00adity \nre.nements based on empirical or heuristic methods. For that reason, we chose techniques that focused \non the cognitive needs of programmers, rather than focusing on aspects of languages or interfaces. Attention \nInvestment does this at a very abstract level, addressing the cognitive demands of the programming task \nitself. Cognitive Dimensions applies those demands in speci.c ways in order to anticipate usability problems. \nWe have found the com\u00adbination to be an effective approach for taking human issues into account in the \ndesign of programming languages.  7 Status of implementation and empirical work We have implemented \nseveral demonstration of concept proto\u00adtypes that concentrate mostly on the front end of the features \nwe have described, i.e., the aspects the user sees. The prototypes are: (1) a set of Excel macros (written \nin Excel s Visual Basic for Applications) that implements many of the features of user\u00adde.ned functions \nand matrices but for a limited example; (2) a PowerPoint mock-up that demonstrates functionality through \nPow-erPoint s event-oriented animation features; and (3) a prototype in Macromedia Director that implements \na smaller subset of the fea\u00adtures than the Excel macro implementation but for a larger range of examples. \nNone of these prototypes is adequate for use in a real application or for experimental evaluation, because \nso much user interaction with Excel relies on seamless recalculation in response to any ex\u00adploratory \nuser action. The behind-the-scenes aspects that is, the proper evaluation semantics of sheet instantiation \nand recalcula\u00adtion can use many of the methods that have been fully imple\u00admented in Forms/3, which can \nthus be regarded as a standalone prototype for those aspects. The Forms/3 implementation has been the \nsetting for numerous empirical studies with human subjects (c.f. [BAD+01, BCACA02], but Forms/3 s front-end \naspects differ from those presented here, so the Forms/3 empirical work is only a pre\u00adcursor of empirical \nstudies that would evaluate the approach de\u00adscribed in this paper.  8 Conclusion We have presented a \ndesign process in which we started from a popular, but limited, end-user programming paradigm (the spread\u00adsheet), \nand extended it to provide some of the capabilities of general purpose programming languages (user de.ned \nfunctions and ma\u00adtrices). We have not approached our work as a generic language design exercise. For \nexample, we have explicitly chosen not to support some standard aspects of the functional paradigm, such \nas recursion. Instead, we have made design tradeoffs that give .rst priority to the cognitive requirements \nof the spreadsheet users. The analytic approach that we have taken in this design process is based on \nrecent developments in the study of programming usabil\u00adity, including the cognitive dimensions of notations \nframework, and the attention investment model of abstraction use. Both provide a systematic description \nof design criteria that are intuitively famil\u00adiar, but usually applied only in an ad-hoc way by programming \nlan\u00adguage designers. We have used these criteria to establish and review priorities in our design choices. \nWe believe that this approach is applicable not only to end-user programmers (who are generally likely \nto have more dif.culty learning and using new programming languages), but also to the design and extension \nof programming languages and environments for professional programmers. This project is unusual as a \nprogramming language research project: not only because of the extent to which it highlights user concerns, \nbut also in that it applies programming language insights to a prod\u00aduct not normally considered as a \nprogramming language. The exer\u00adcise is also distinctive with regard to other research in programming \nlanguage usability, because we are working to evolve the design of a well-established language in practical \nuse, rather than starting from scratch with the design of a new language for research purposes. We believe \nputting human concerns at the forefront of language design will become increasingly important. The ability \nto inte\u00adgrate programming language principles with human problem solv\u00ading principles when evolving established \nprogramming systems may in the future be the factor that differentiates successful applied programming \nlanguage design research and practice.  9 References [Amb87] A Ambler. Forms: Expanding the visualness \nof sheet languages. In Workshop on Visual Languages, Linkoping, Sweden, August 1987. [BA94] M Burnett \nand A Ambler. Interactive visual data abstraction in a declarative visual programming lan\u00ad guage. Journal \nof Visual Languages and Computing, 5:29 60, March 1994. [BAB+00] B Boehm, A Abts, S Brown, B Chulani, \nE Clark, R Horowitz, D Madachy, Reifer, and B Steece. Soft\u00ad ware Cost Esimation with COCOMO II. Prentice \nHall PTR, Upper Saddle River, NJ, 2000. [BAD+01] Margaret Burnett, John Atwood, Rebecca Walpole Djang, \nHerkimer Gottfried, James Reichwein, and Sherry Yang. Forms/3: A .rst-order visual lan\u00ad guage to explore \nthe boundaries of the spreadsheet paradigm. Journal of Functional Programming, 11:155 206, March 2001. \n[BB02] AF Blackwell and M Burnett. Applying attention investment to end-user programming. In HCC 02 [HCC02], \npages 28 30. [BBC02] L Beckwith, M Burnett, and C Cook. Reason\u00ad ing about many-to-many requirement relationships \nin spreadsheets. In HCC 02 [HCC02], pages 149 157. [BCACA02] M Burnett, N Cao, M Arredondo-Castro, and \nJ At\u00adwood. End-user programming of time as an ordi\u00adnary dimension in grid-oriented visual programming \nlanguages. Journal of Visual Languages and Comput\u00ading, 13(4):421 447, August 2002. [BG87] P. Brown and \nJ. Gould. Experimental study of people creating spreadsheets. ACM Transactions on Of.ce Information Systems, \n5:258 272, 1987. [BG03] AF Blackwell and TRG Green. Notational systems the cognitive dimensions of notations \nframework. In JM Carroll, editor, HCI Models, Theories, and Frameworks: Toward an Interdisciplinary Science. \nMorgan Kaufmann, 2003. [Bla01] A Blackwell. See what you need: helping end users to build abstractions. \nJournal of Visual Languages and Computing, 5:475 499, October 2001. [Bla02] AF Blackwell. First steps \nin programming: A ra\u00adtionale for attention investment models. In HCC 02 [HCC02], pages 2 10. [CRB+98] \nE Chi, J Riedl, P Barry, P Konstan, and J Konstan. Principles for information visualization spreadsheets. \nIEEE Computer Graphics and Applications, pages 30 38, July 1998. [CW00] C. Corritore and S. Wiedenbeck. \nDirection and scope of comprehension-related activities by proce\u00addural and object-oriented programmers: \nAn empir\u00adical study. In International Workshop on Program Comprehension, pages 139 148, Limerick, Ireland, \nJune 2000. [Dav96] JS Davis. Tools for spreadsheet auditing. Interna\u00adtional Journal of Human-Computer \nStudies, 45:429 442, 1996. [DP95] Joseph Dumas and Paige Parsons. Discovering the [Nar93] [NC85] [Nil98] \nway programmers think about new programming en\u00ad vironments. Communications of the ACM, 38:45 56, June \n1995. [FFF+97] R Findler, C Flanagan, M Flatt, S Krishnamurthi, and M Felleisen. DrScheme: A Pedagogic \nProgramming Environment for Scheme. In PLILP 97 [PLI97], pages 369 388. [GP96] TRG Green and M Petre. \nUsability analysis of vi\u00ad sual programming environments: a cognitive di\u00ad mensions framework. Journal \nof Visual Languages and Computing, 7:131 174, 1996. [GPB91] T. Green, M. Petre, and R. Bellamy. Comprehensi\u00ad \nbility of visual and textual programs: A test of su\u00ad perlativism against the match-mismatch conjecture. \nIn Empirical Studies of Programmers: Fourth Work\u00ad shop, New Brunswick, New Jersey, pages 121 146. Ablex, \nDecember 1991. [HCC02] IEEE Conference on Human-Centric Computing Languages and Environments, Arlington. \nIEEE Com\u00ad puter Society, September 2002. [HLMC96] Christopher M. Hoadley, Marcia C. Linn, Lydia M. Mann, \nand Michael J. Clancy. When, why and how do novice programmers reuse code? In Empiri\u00ad cal Studies of \nProgrammers: Sixth Workshop. Ablex, 1996. [HM90] C Hughes and J Moshell. Action Graphics: A spreadsheet-based \nlanguage for animated simulation. In T Ichikawa, E Jungert, and R Korfhage, editors, Visual Languages \nand Applications, pages 203 235. Plenum Publishing, 1990. [HO85] CV Hall and JT O Donnell. Debugging \nin a side\u00ad effect-free programming environment. In Proc ACM Symposium on Language Issues and Programming \nEnvironments. ACM, Seattle, January 1985. [Hud94] S Hudson. User interface speci.cation using an en\u00ad \nhanced spreadsheet model. ACM Transactions on Graphics, 13:209 239, July 1994. [IMCZ98] Takeo Igarashi, \nJock Mackinlay, Bay-Wei Chang, and Polle Zellweger. Fluid visualization of spread\u00ad sheet structures. \nIn IEEE Symposium on Visual Lan\u00ad guages, Halifax, Nova Scotia, pages 118 125. IEEE, September 1998. [Lev94] \nM Levoy. Spreadsheet for images. Computer Graph\u00ad ics, 28:139 146, 1994. [LGAH02] Y. Li, J. Grundy, R. \nAmor, and J. Hosking. A data mapping speci.cation environment using a concrete business form-based metaphor. \nIn HCC 02 [HCC02], pages 158 166. [Lie84] H Lieberman. Steps toward better debugging tools for LISP. \nIn ACM Symposium on Lisp and Functional Programming (LFP 84), pages 247 255. ACM, 1984. [Mye91] B Myers. \nGraphical techniques in a spreadsheet for specifying user interfaces. In ACM Conference on Human Factors \nin Computing Systems, New Orleans, pages 243 249, April 1991.  [NM90] [Pan98] [PLI97] [PM96] [PMM02] \n[RLDB98] [SCB96] [SR97] [TA90] [US87] [YBDZ97] B. Nardi. A Small Matter of Programming: Perspec\u00adtives \non End User Computing. The MIT Press, Cam\u00adbridge, MA, 1993. A Newell and SK Card. The prospects for psycholog\u00adical \nscience in human-computer interaction. Human-Computer Interaction, 1:209 242, 1985. Henrik Nilsson. Declarative \nDebugging for Lazy Functional Languages. PhD thesis, Department of Computer and Information Science, \nLink\u00a8opings uni\u00adversitet, S-581 83, Link\u00a8oping, Sweden, May 1998. J Nielsen and R Molich. Heuristic evaluation \nof user interfaces. In Proceedings of ACM CHI 90 Confer\u00adence, Seattle, pages 249 256, April 1990. RR \nPanko. What we know about spreadsheet errors. Journal of End User Computing, 10:15 21, 1998. International \nSymposium on Programming Lan\u00adguages Implementations, Logics, and Programs (PLILP 97), volume 1292 of \nLecture Notes in Com\u00adputer Science. Springer Verlag, September 1997. JF Pane and BA Myers. Usability \nissues in the de\u00adsign of novice programming systems. Technical Re\u00adport CMU-CS-96-132, Carnegie Mellon \nUniversity, School of Computer Science, August 1996. J Pane, B Myers, and L Miller. Using HCI tech\u00adniques \nto design a more usable programming system. In HCC 02 [HCC02], pages 198 206. G Rothermel, L Li, C DuPuis, \nand M Burnett. What you see is what you test. In International Confer\u00adence on Software Engineering, Kyoto, \npages 198 207, April 1998. T Smedley, P Cox, and S Byrne. Expanding the util\u00adity of spreadsheets through \nthe integration of visual programming and user interface objects. In Advanced Visual Interfaces 96, Gubbio, \nItaly, pages 148 155, May 1996. J Sparud and C Runciman. Tracing lazy func\u00adtional computations using \nredex trails. In PLILP 97 [PLI97]. AP Tolmach and AW Appel. Debugging Standard ML without reverse engineering. \nIn Proc ACM Con\u00adference on Lisp and Functional Programming, Nice. ACM, June 1990. D. Ungar and R. Smith. \nSelf: The power of simplic\u00adity. ACM Conference on Object-Oriented Program\u00adming Systems, Languages, and \nApplications (OOP-SLA), pages 227 242, October 1987. S. Yang, M. Burnett, E. DeKoven, and M. Zloof. Representation \ndesign benchmarks: a design-time aid for VPL navigable static representations. Journal of Visual Languages \nand Computing, 8(5/6):563 599, Oct/Dec 1997.  \n\t\t\t", "proc_id": "944705", "abstract": "We describe extensions to the Excel spreadsheet that integrate user-defined functions into the spreadsheet grid, rather than treating them as a \"bolt-on\". Our first objective was to bring the benefits of additional programming language features to a system that is often not recognised as a programming language. Second, in a project involving the evolution of a well-established language, compatibility with previous versions is a major issue, and maintaining this compatibility was our second objective. Third and most important, the commercial success of spreadsheets is largely due to the fact that many people find them more usable than programming languages for programming-like tasks. Thus, our third objective (with resulting constraints) was to maintain this usability advantage.Simply making Excel more like a conventional programming language would not meet these objectives and constraints. We have therefore taken an approach to our design work that emphasises the cognitive requirements of the user as a primary design criterion. The analytic approach that we demonstrate in this project is based on recent developments in the study of programming usability, including the Cognitive Dimensions of Notations and the Attention Investment model of abstraction use. We believe that this approach is also applicable to the design and extension of other programming languages and environments.", "authors": [{"name": "Simon Peyton Jones", "author_profile_id": "81100271851", "affiliation": "Microsoft Research, Cambridge", "person_id": "PP43121273", "email_address": "", "orcid_id": ""}, {"name": "Alan Blackwell", "author_profile_id": "81100022210", "affiliation": "Cambridge University", "person_id": "PP55042221", "email_address": "", "orcid_id": ""}, {"name": "Margaret Burnett", "author_profile_id": "81100337865", "affiliation": "Oregon State University", "person_id": "PP55042173", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944721", "year": "2003", "article_id": "944721", "conference": "ICFP", "title": "A user-centred approach to functions in Excel", "url": "http://dl.acm.org/citation.cfm?id=944721"}