{"article_publication_date": "08-25-2003", "fulltext": "\n Discriminative Sum Types Locate the Source of Type Errors Matthias Neubauer Peter Thiemann Universit\u00a8 \nat Freiburg {neubauer,thiemann}@informatik.uni-freiburg.de Abstract We propose a type system for locating \nthe source of type errors in an applied lambda calculus with ML-style polymorphism. The system is based \non discriminative sum types known from work on soft typing with annotation subtyping and recursive types. \nThis way, type clashes can be registered in the type for later reporting. The annotations track the potential \nproducers and consumers for each value so that clashes can be traced to their cause. Every term is typeable \nin our system and type inference is decid\u00adable. A type derivation in our system describes all type errors \npresent in the program, so that a principal derivation yields a prin\u00adcipal description of all type errors \npresent. Error messages are de\u00adrived from completed type derivations. Thus, error messages are independent \nof the particular algorithm used for type inference, pro\u00advided it constructs such a derivation. Categories \nand Subject Descriptors D.3.2 [Programming Languages]: Language Classi.cations Applicative (functional) \nlanguages; D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Polymorphism; F.3.3 [Logics \nand Meanings of Programs]: Studies of Program Con\u00adstructs Type Structure General Terms Languages, Theory \n Keywords type inference, polymorphism, type errors 1 Introduction Many functional programming languages \nhave type systems which are derived from ML s type system with parametric polymor\u00adphism [22]. ML-style \npolymorphism has proved to be a practical compromise which allows for expressive polymorphic de.nitions \nwhile keeping type inference decidable. However, despite 25 years of experience with ML-style typing \nand numerous implementations of type inference algorithms for this kind of type system, programmers are \nstill struggling with the error messages reported when the inference algorithm fails. Virtually ev\u00adery \nML programmer can tell stories about type errors where it took hours to identify the actual problem with \nthe program. While initi\u00adated functional programmers seem to accept this as a fact of life to be endured \nin return for the wonderful type soundness guarantee, it makes life hard for beginners, in fact, too \nhard for some. The root of the problem lies in the operational way in which type inference algorithms \nproduce error messages. Most algorithms are based on Milner s algorithm W [22] that traverses the syntax \ntree of an expression and composes the type of the expression bottom\u00adup. At each function application \neei, the algorithm recursively computes the types t of e and ti of e. Next, it has to make sure that \nthe type of e really is a function type. Hence, the algorithm attempts to unify t with ti. \u00df, where \u00df \nis a fresh type variable. It reports a type error if this uni.cation fails. (Similar uni.cations happen \nat elimination expressions for other type constructors.) Unfortunately, the point in the expression where \nthe uni.cation fails may not even be close to the point of the actual mistake in the pro\u00adgram. For example, \nwhen processing (. f . f 1)(.y.if y 10) (1) algorithm W .rst computes the types of the subexpressions \nas . f . f 1: (int . a) . a.y.if y 10: bool . int and then tries to unify . (int . a) . a =(bool . int) \n. \u00df which results (in the worst case) in the error message Failed to unify int with bool issued at the \noutermost application in ex\u00adpression (1). Only indirectly does this message point to the actual problem, \nnamely the mismatch of the type of f s argument and its use in the body of f : Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 03, August 25 27, 2003, Uppsala, Sweden. \nCopyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00 + (. f . f 1 )(.y.if y - 10) That is, f is applied \nto an argument of type int which is pro\u00ad duced by the expression 1 + (the annotation + .ags a producer \nexpression, which is the source for some value) whereas the func\u00adtion bound to f consumes its argument \nas a bool in the context if - 1 0 (the annotation - indicates an expression used in an elimination context \nor a consumer position). Numerous attempts have been made at explaining type errors and locating their \nactual source. They range from instrumentations of algorithm W through alternative type inference algorithms \nto ap\u00adproaches relying on principal typings. Section 6 discusses a repre\u00ad sentative sample of this related \nwork. 1.1 Locating Errors with Multivocal Types In the present work, we pursue an approach based on the \ntheory of discriminative sum types, which has been developed for soft typing [7, 18, 38], and which is \nclosely related to systems with row types [35, 29]. While row types are usually indexed with record or \nvariant labels, discriminative sum types are indexed with type constructors and the component types are \nthe argument types of the constructors. Anticipating the formal de.nition in Section 3.4, the idea of \na dis\u00ad criminative sum type is that at each node of a type each type con\u00adstructor may be used at most \nonce. The unused type constructors are hidden in a row variable . and we use ; to separate different \ntype constructors. The separator ; binds weaker than every type constructor. For example, in the node \n(int;.a . .b; .1) of a type there are two components, one for the type (constructor) int and another \nfor .. The most interesting operation on discriminative sum types is uni.cation, because it must preserve \nthe above invariant. The idea here is that types uni.ed componentwise and by substituting for the row \nvariables if there is no corresponding component (as with row types). For example, uni.cation of (int;.a \n. .b; .1) with (bool; .2) results in the substitution .1 . (bool;.i) and .2 . (int;.a . .b; .i) yielding \nthe substituted term (int;.a . .b;bool;.i). An alternative view would consider each node in a discriminative \nsum type as a .nite map . from the set of type constructors to a list of type nodes, so that .(.) are \nthe arguments of type constructor .. Each type in a system of discriminative sum types may be multivo\u00adcal, \nthat is, it may have more than one top-level type constructor. The type (int; bool; .) is an example \nfor such a multivocal type where . is a (row) type variable. A type like (bool;.2) with at most one type \nconstructor is univocal. For the subexpressions of our example, type inference now yields . f . f 1: \n(((int;.1) . .2; .3) . .2;.4) .y.if y 10 : ((bool; .5) . (int;.6); .7) and uni.cation of the two types \n(((int;.1) . .2;.3) . .2; .4) . = (((bool;.5) . (int;.6);.7) . .8; .9) succeeds with the multivocal type \n(((bool;int;.10) . (int;.6);.3) . (int;.6);.4) by substituting .1 . (bool; .10), .5 . (int;.10), .2 . \n(int;.6), .7 . .3, and .9 . .4. In fact, type inference succeeds for the entire expression and computes \nthe result type (int;.6) (which is univocal, that is, there is at most one type constructor present). \nThe gain in doing so is that we can inspect the type derivation after the inference algorithm has completed \nits work: . f . f 1: (((bool;int; .10) . (int; .6);.3) . (int; .6);.4) .y.if y 10 : ((bool;int; .10) \n. (int; .6);.3) (. f . f 1)(.y.if y 10) : ((bool;int; .10) . (int; .6);.3) In particular, the two program \npoints that actually caused the prob\u00adlem also have multivocal types: f : ((bool;int;.10) . (int;.6);.3) \nf 1: (bool; int;.10) y : (bool; int;.10) f y : (bool; int;.10) However, the typing still does not relate \nenough information what exactly happened and why/if these two program points are the cul\u00adprits for the \ntype error. For that reason, each type constructor in a discriminative sum type must carry a .ow set \nannotation. A .ow set is a set of program la\u00adbels that indicate the potential sources and sinks of a \nvalue whose type carries that .ow set. Since each type constructor carries a sep\u00adarate .ow set, each \ncomponent s .ow is traced separately. There is a further distinction between source labels with superscript \n+ that indicate potential producers of a value and sink labels with super\u00adscript - that indicate potential \nconsumers of a value. Returning to our example, we .rst label each source or sink subex\u00adpression appropriately: \n[[. f .[ f ]3- [1]4+]2+]1- [.y.if [y]6- [1]7+[0]8+]5+ Looking again at any of the above types involving \nthe multivocal part (bool;int; .10), we .nd the following annotations: 6- 4+ y : (bool;int;.10) This \nannotated type indicates that the error stems from the fact the value of type int produced at program \npoint 4+ may be consumed as a value of type bool by the if expression at program point 6- . It will turn \nout that a multivocal type t is a suf.cient indicator for a type error, but further machinery is required \nto report such an error. As a .rst step, we consider the set of subexpressions whose type contains t \nor that consume a value whose type contains t. Following Haack and Wells [14], we visualize such a set \nas an expression slice where subexpressions and subcontexts that do not contribute to the multivocal \ntype are blanked out using ellipses (..). In the example, the expression slice associated with (bool6- \n; int4+ ;.10) is [[. f .[ f ]3- [1]4+]2+]1- [.y.if [y]6- (..)(..)]5+ The proposed error message for this \nexpression is the above slice with additional highlighting of the offending consumers and pro\u00adducers \nas detailed in Section 2.4. In Section 2, we elaborate on the additional features, annotation subtyping \nand recursive types, required to turn type inference for discriminative sum types into a practically \nuseful framework for locating type errors. We motivate these extensions with examples. 1.2 Contributions \nWe have designed a type system with discriminative sum types that enables the precise localization of \nthe causes of type errors. The type system is a conservative extension of the Hindley/Milner type system \nwith parametric polymorphism. It is inspired by work on soft typing and row types and it inherits many \nof its properties: type inference is decidable, even in the presence of annota\u00adtion subtyping and recursive \ntypes;  the type inference algorithm can produce a principal type derivation; we view this principal \ntype derivation as a prin\u00adcipal description of the type errors in the term;  type errors are reported \nby interpreting the completed type derivation, hence they are independent of the type inference algorithm \nused to compute them.  The technical contributions of the paper are the following. Starting from an \napplied lambda calculus, we de.ne a type system with dis\u00adcriminative sum types and ML-style polymorphism, \nwhich is pa\u00adrameterized over a certain style of constraint systems, and prove subject reduction. Then \nwe extend the calculus with labeling and establish the correctness of the data .ow information in the \n.ow set annotations by proving subject reduction for the labeled calcu\u00adlus in the type system with simple \nannotations and with annotation subtyping. We show that this information is valid also for the orig\u00adinal, \nunlabeled calculus by relating the labeled and the unlabeled calculus via a reduction correspondence. \nFurther, we prove that our system is a conservative extension of ML and, conversely, charac\u00adterize those \ntype derivations that give rise to an ML type derivation. There is a prototype implementation of the \ntype inference algorithm with annotation subtyping for an applied lambda calculus. 1.3 Overview In the \nfollowing Section, we explain the additional features annota\u00adtion subtyping and recursive types. Section \n3 contains the theoreti\u00ad cal basis of our system. It introduces the labeled calculus .L, a type system \nwith discriminative sum types and ML-style polymorphism, and states some technical results. Section 4 \ndiscusses extensions that are required to make the system amenable to a full program\u00adming language. Section \n5 contains some notes on our prototype implementation. Finally, we discuss related work in Section 6 \nand conclude.  2 Locating Type Errors The example in the introduction has given some .avor of the kind \nof error messages that can be extracted from our type system. How\u00adever, the example is chosen so that \nit does not exert the full power of the system. Further features, in particular annotation subtyping \nand recursive types are needed. The following examples motivate them and show how error messages can \nbe extracted from typings in the respective extended system. 2.1 Annotation Subtyping In the .ow sets \nattached to each type constructor, the type system performs a .ow analysis that tracks the sources (producers, \nintro\u00adductions) and the sinks (consumers, eliminations) of all values. An\u00adnotation subtyping increases \nthe precision of that analysis by mod\u00adeling the direction of the data .ow. For the monomorphic case, \nsimilar type systems have been shown to be equivalent in power to 0CFA [16, 26]. 2.1.1 Flowing Forwards \nConsider the following example expression: .x.(x,if true (if true [true]1+[0]2+) x) (2) Both conditionals \nhave type (int2+ ; bool1+ ;.) indicating that their value is either the boolean introduced at point 1+ \nor the integer introduced at point 2+. Unfortunately, the same type (including the annotation) is also \ninferred for the variable x which cannot assume either of these values in the given expression. This \nso-called poisoning is a well-known phenomenon of equation-based .ow analysis. It is due to the analysis \nequating the result types of both branches of the outer conditional. These equations induce an arti.cial \nbackwards .ow that can never happen during execution of the program. The remedy is to move from an equation-based \nsystem to a subtyping-based system. To this end, we rely on a subtyping rela\u00adtion of .ow-annotated types \nthat preserves the structure of the types and only affects the annotations. In the example expression \n(2), this approach leads to the following typings: [true]1+ : (int; bool1+ ;.) [0]2+ : (int2+ ;bool;.) \n2+ 1+ if true [true]1+[0]2+ : (int;bool; .) x : (int; bool ; .) 2+ 1+ if true (if true [true]1+[0]2+) \nx : (int;bool; .) These typings seem to indicate that while x is affected by the type error it actually \ndoes not contribute to it because its multivocal type is not inhabited (its .ow sets are empty). However, \nthis infer\u00adence is not correct in general as we shall see in Section 2.1.3 below. Hence, we report the \ntype error as the slice .x.(..)(x,if (..)(if (..)[true]1+[0]2+) x). 2.1.2 Flowing Backwards The above \nexample demonstrates an error caused by an expression that might evaluate to values of different type. \nThe typing correctly tracks the values .owing forward from their introduction to the offending expression. \nHowever, the dual situation where two subexpressions want to con\u00adsume the same value at different types \nalso gives rise to a type error. Since there may be no producer in the expression, it is necessary to \ntrack the consumers, too. Contrary to information about pro\u00adducers of values, the information about consumers \nof values .ows backwards, towards the source of the value. Hence, the subtyping relation transports consumer \nlabels from right to left , so that the subtype always has more consumer labels than the supertype. Here \nis an example that demonstrates the backward .ow of con\u00adsumer labels in action: .x.(if [x]2- [0]4+[1]5+ \n, [x]6- [1]8+) In this expression, x is used in two different elimination contexts, once as a boolean \nand once as a function. Hence, its typing is 2- 8+ x : (bool;((int; .1) .6- .2); .0). Since only the \ntop-level of this type is multivocal, the only subex\u00adpressions concerned with the error are 2- and 6- \nand the occur\u00adrences of the variable x. Hence, the offending slice is .x.(..)(if [x]2- (..)(..),[x]6- \n(..)). 2.1.3 Inhabitation The next example demonstrates that inhabitation of an expression s multivocal \ntype is not always a good indicator for the role of that expression in a type error. .x..y.(if true x \n[0]4+ ,if true xy,if true y [false]5+) Here are the typings of the interesting subexpressions: x : (bool;int;.x) \n y : (bool;int;.y)  if true x [0]4+ : (bool;int4+ ;.1) if true xy : (bool;int;.2) if true y [false]5+ \n: (bool5+ ;int;.3) Although the type of the second subexpression, if true xy, is un\u00adinhabited, this subexpression \nis clearly contributing to the type error in an essential way. In fact, all subexpressions, except the \ncondi\u00adtions, are essential for obtaining a type error in this case. Hence, we refrain from using inhabitation \nof a multivocal type as an indicator whether a subexpression participates in a type error. How\u00adever, \nit makes sense to indicate the degree of inhabitation visually, since observing changes in inhabitation \ncan be helpful in certain cases (cf. the example in Section 2.1.1).  2.2 Recursive Types The standard \nimplementation of Hindley/Milner-style type infer\u00adence fails at programs like [ f ]0+[x : xs]1- =[add \n([ f ]2- xs) ([ f ]3- x)]5+ The reason for this failure is that x must have type a and type list a at \nthe same time. However, x could be assigned the re\u00adcursive type \u00b5a.list a, which is theoretically sound. \nAlthough ML-style type inference with recursive types is feasible, the result\u00ading types are often unintuitive. \nFor that reason, the standard algo\u00adrithm rules out recursive types by using a uni.cation algorithm with \noccur-check . However, a type system to investigate type errors must be able to give a type to the above \nterm so that a suitable error message can be extracted from the typing. Hence our system includes recursive \ntypes and it assigns the type ,2- ,3- 5+ 1- f : (. .0+(int;.2); .0) where . =(list.; .1). How much information \ncan be extracted from this typing? 1. Since . refers to itself, we can deduce that the standard infer\u00adence \nalgorithm reports an occurs-check error. 2. The type constructor list that is involved in the recursive \ndef\u00adinition is annotated with 1-, indicating that the pattern match\u00ading on f s argument contributes to \nthe problem. 3. By examining the rest of the typing derivation, we .nd that  x : . and xs : ., that \nis, only the typing of the context add [][] does not involve the type .. Hence, the offending slice in \nthe de.nition of f is [ f ]0+[x : xs]1- =(..) ([ f ]2- xs, [ f ]3- x) which exactly pinpoints the source \nof the problem. In this case, the typing does not involve a multivocal type. Hence, we must de.ne which \nnode of the type causes the error. Our choice is the header node of the loop, indicated by the variable \n. in the example. In the example, function f only serves as a mediator because the recursive type does \nnot appear at the top-level of f s type. Our reporting phase will indicate this difference visually. \n 2.3 Flow Classes The examples above only contain one type error at a time. When more than one error \nis present in a program, it is not obvious which occurrences of multivocal types belong together. For \nexample, con\u00adsider an expression that contains two copies of expression (2). Each copy has a number of \nsubexpressions of type (int ; bool; .), where the association to a particular consumer or producer is \nnot obvious because the .ow sets in the type are empty. What is needed is an additional classi.cation \nof type nodes into equivalence classes. To this end, each expression and each type node is equipped with \na .ow-class label. The expression [e], at\u00adtaches its .ow-class label , to the top-level node of e s type. \nA .ow-class label behaves differently than a source or a sink label. It is propagated equationally, like \nthe type structure itself, ignoring the direction of data .ow. With this set-up a .ow-class label , records \nin the type that a value of this type may be passed through by an expression with this label. For example, \nin [let x =[42]1+ in [x]2]3 the []2 and the []3 attach .ow-class labels to the type constructor int, \nso that the type of [x]2 is (int1+ ,2,3; .) (remember that .ow\u00adclass labels are propagated equationally, \nthat is, they go forwards and backwards), which is also the type of the whole expression. In this way, \neach node in a type has a set of .ow-class labels at\u00adtached to it. Since propagation of these labels \nis equation-based, these sets are either disjoint or equal for any given pair of nodes. Hence, the sets \nof .ow-class labels induce a partition on the set of type nodes. Moreover, all members of the same partition \nrepresent the same underlying type (after erasure of all .ow annotations). 2.4 Collecting and Reporting \nType Errors Our proposed overall procedure for a type error reporting tool is derived from the above \ndiscussion. It works in two phases, a col\u00adlecting phase and a reporting phase. The collection phase has \nthe following tasks: 1. Decorate the expression with producer and consumer labels as well as with .ow-class \nlabels. All these labels must be distinct so that there is a mapping from the set of labels to the set \nof subexpressions occurrences in the original expression. 2. Perform type inference for the system proposed \nin this paper. The algorithm does not matter as long as it computes a map\u00adping that maps each label to \nthe type of the subexpression at that label. 3. During a traversal of all types of all subexpressions, \ncollect the following set E of sets of .ow-class labels: if a type that contains a node t so that either \nt is multivocal or t is the header of a recursive type, then R . E where R is the set of all .ow\u00adclass \nlabels in the node t. The set R is the scope of the error and t the offender.  At this point, each element \nof E corresponds to a type error that must be .xed separately. The reporting phase picks an element R \n. E and extracts a slice from the original expression that contains all subexpressions whose type contains \na node marked with R, or  that are consumer expressions where the consumed type con\u00adtains a node marked \nwith R.  With the slice it shows a general description, for example, re\u00adcursive type , consumer/consumer \ncon.ict , consumer/producer con.ict , etc, that is derived from the offenders in the type of the slice. \nFurthermore, it highlights each subexpression e of the slice by taking into account the following questions \n(depending on the programmer s settings): Does the offender occur at the top-level of e s type? If not, \nthis indicates that e is merely transmitting the offense.  What is the degree of inhabitation of the \noffender s type? That is, how many sources and sinks appear in its .ow sets? Im\u00adportant hints can be \ndrawn from changes in inhabitation.  Is e a consumer or a producer involved in the top-level of the \noffending type?  All this information can be readily extracted from the .ow sets in a typing in our \nsystem. In each of the examples in this section, the procedure leads exactly to the slices reported. \n 3 Formal System Our term language consists of .-terms with constants and a let\u00adexpression. Variables \nx . Var Constants c . Const Terms e ::= c | x | ee | .x.e | let x = e in e We adopt Barendregt s variable \nconvention [5] and identify a\u00ad i equivalent terms e and ei by writing e = e. The notation FV(e) denotes \nthe set of free variables in e, and e[x := ei] denotes the re\u00adsult of substituting the free occurrences \nof x in e by ei . 3.1 The calculi .let and .let,bool We generate calculi by notions of reduction. The \nfollowing two relations de.ne the notions of \u00df-and let-reduction: i (\u00df)(.x. e) e-. e[x := ei] (let) let \nx = ei in e -. e[x := ei] For each notion of reduction r, -.r denotes the compatible one\u00adstep reduction \nof r, - . r is the re.exive, transitive closure of -.r, and = r is the smallest equivalence relation \ngenerated by - . r [5]. The .let-calculus has no constants and is generated by R = {\u00df,let}. The calculus \n.let,bool extend the calculus .let by adding the three constants true, false, and if representing the \nintroduction and elimination constructs for booleans. The following two additional reduction rules de.ne \ntheir operational behavior: (if.1) if true e2 e3 -. e2 (if.2) if false e2 e3 -. e3 We recall the following \nknown property of .let and .let,bool. FACT 1. The calculi .let and .let,bool are con.uent. 3.2 The labeled \ncalculus .L To identify certain subterms of a term and trace their .ow during a sequence of reductions \nas discussed above, we introduce a new labeled .-calculus inspired by labeled reductions of Barendregt \n[5] and Abadi et al. [1]. We distinguish different kinds of labels: Source Labels ,+ . Lab+ Sink Labels \n,-. Lab- Class Labels , . Lab Sets of Class Labels L . P(Lab) Type Constructors . . TyCon The sets Lab+ \n, Lab-, and Lab are disjoint. Source labels, ,+ . Lab+, are attached to introduction expressions (like \n. or true) and trace the .ow of produced values. Sink labels, ,-. Lab- , are attached to elimination \ncontexts (like the .rst subexpression of function application or the condition of a conditional) and \ntrace the attraction towards a consumer. Class labels are propagated equa\u00adtionally, that is, they .ow \nboth forwards and backwards. Sets of class labels are denoted by L, and type constructors are denoted \nby . . TyCon where we assume that bool,.. TyCon. The calculus .L has three additional families of labeling \nconstants. The constant [].,,+ labels an expression that introduces a type constructor . with the source \nlabel ,+ .  The constant [].,,- labels a context that eliminates a type con\u00adstructor . with the sink \nlabel ,- .  The constant []L annotates an expression with a set of class labels L.  We usually write \n[e]L instead of the juxtaposition []Le. Sometimes we use the meta variable a to indicate an annotated \nterm. Six notions of reduction deal with labeling constants: (L.union) [[e]L1 ]L2 -. [e]L1.L2 (L.swap) \n[[e].,,+]L -. [[e]L].,,+ (L.elim) -. e [[e].,,+ 1 ].,,- 2 (L.lam)[.x.e]L -. .x.e (L.true)[true]L -. true \n(L.false)[false]L -. false The L.union rule collapses two consecutive labelings of an expres\u00adsion into \none labeling by merging their label sets. The L.swap rule lets source labels ,+ travel outwards over \na set of other labels L. If a source labeling ,+ with constructor annotation . hits a sink la\u00ad 1 beling \n,- with the same constructor annotation ., they cancel each 2 other by the L.elim rule. The rules L.lam, \nL.true, and L.false move a labeling out of the way by removing it completely. The labeled .L-calculus \nenjoys the same fundamental theorem as the unlabeled calculi: PROPOSITION 1. The calculus .L is con.uent. \nPROOF. All critical pairs are joinable. Hence, the lemma follows using Theorem 6.2.4 of [4] and Proposition \n3.3.5 of [5]. An unlabeled term e can be labeled in many ways, but not all label\u00ad x . [x]L e1 . ei e2 \n. ei 12 i i e1 e2 . [[e1].,,- e2]L i e . e .x.e . [[.x.ei].,,+]L e1 . ei e2 . ei 12 ii let x = e1 in \ne2 . [let x = e1 in e2]L true . [[true]bool,,+]L false . [[false]bool,,+]L iii e1 . ee2 . ee3 . e 123 \ni ii if e1 e2 e3 . [if [e1]bool,,- e2 e3]L Figure 1. Labeling ings make sense. The relation e . a (de.ned \nin Figure 1) speci.es how an unlabeled term e can be annotated with labels resulting in a sensibly labeled \ncounterpart a. The relation guarantees that every subterm of e carries a .ow-class label in a,  every \nintroduction of type constructor . is annotated with a source label for ., and  every elimination of \ntype constructor . is annotated with a sink label for kind ..  LEMMA 1. (Basic Properties of Labeling) \n If e . a, then a = [ai]L for some ai and L.  If e . [a]L1 , then e . [a]L2 .  If e1 . a1, and e2 . \na2, then e1[x := e2] . a1[x := a2].  With erase(a), we denote the unlabeled term obtained by remov\u00ading \nall labelings from a. The unlabeled calculus .let,bool and its labeled counterpart .L correspond in the \nfollowing way: PROPOSITION 2. (Simulation) i If e -. ei, and e . a, then a - . ai for some ai with ei \n. a. If e . a, and a -. ai, then e - . erase(ai).  3.3 The Damas-Milner Type System We .rst recapitulate \nDamas and Milner s type system for Mini-ML [11, 9]. The types, type schemes, and type assumptions are: \nType Variables a . TyVar Types t ::= a | . t1 ...tn Type Schemes s ::= .a.t Type Assumptions A ::= \u00b7| \nA,x : tx ./A where a ranges over a set of type variables. Type schemes are identi.ed modulo a-equivalence, \nand we write A(x) for the type assigned to x in A. The type system of Mini-ML is de.ned by the deduction \nsystem in Figure 2. It constructs proofs for the type judgment A fDM e : t stating that the term e has \ntype t under type assumptions A. T (c) ' t A fDM c : t A(x) ' t A fDM x : t A fDM e1: t2 . t1 A fDM \ne2: t2 A fDM e1 e2: t1 A, x : t2 fDM e : t1 A fDM .x.e : t2 . t1 (A,t1) fgen A fDM e1: t1 DMs A,x : \ns fDM e2: t2 A fDM let x = e1 in e2: t2 Figure 2. Typing rules of Mini-ML The deduction rules rely on \nthe notions of type instantiation and type generalization: DEFINITION 1. (Instantiation) A type t is \nan instance of a type scheme s, written s ' t, if there is a substitution for the bound vari\u00adables of \ns yielding t. DEFINITION 2. (Generalization) A type scheme is a generaliza\u00ad gen tion of type t under \nsome type assumptions A, written (A,t) fDM .a.t, if for all a . a, a . FV(A). The type system is parameterized \nover a function T that maps each constant c . Const to a closed type scheme. For example, for .let,bool \nthe function T should map the constants involving booleans as follows: true : bool false : bool if : \n.a.bool . a . a . a 3.4 Discriminative Sum Types with Con\u00adstraints This section explains the technical \nfoundations of our type system based on discriminative sum types, .ow-set annotations, and recur\u00adsive \ntypes. Constraints are also needed to describe the propagation of .ow-set annotations. Since two different \nconstraint languages are required, we start by abstracting over the constraint system. This yields a \ngeneral framework for program analysis using con\u00adstrained types with discriminative sums. We rely on \nan abstract no\u00adtion of constraint system which is similar to Jones s predicates [19] and Odersky et al. \ns notion of constraints [25]. DEFINITION 3. (Constraint System) A constraint system over a type language \nis a structure (O,f) where O is a constraints lan\u00adguage extending a type language and f is an entailment \nrelation f. P(O) \u00d7 P(O), such that the following holds: (i) C . D f C, (ii) if C1 f C2, and C2 f C3, \nthen C1 f C3, and  (iii) If C f D, then f(C) f f(D). where C and D are sets of constraints, and f is \na substitution of type variables. Hence, the entailment relation associated with a constraint system \nmust be monotone, transitive, and closed under substitutions. For notational convenience we usually write \nC,D for the union (con\u00adjunction) of two constraint sets C and D. Discriminative sum types are a variation \nof row types introduced by Wand [35] and Remy [29] originally intended for the purpose of typing records \nand variants. While row types are usually indexed with record or variant labels, discriminative sum types \nare indexed with type constructors and the component types are the argument types of the constructors. \nSimilar constructions have been used for soft typing systems [7, 18, 38]. For performing the .ow analysis \nrequired for error reporting, we annotate each type constructor in a discriminative type with a .ow set. \nRow Variables . . RowVar Set Variables . . SetVar Sets of Type Constr s T . P(TyCon) Flow Set Ann s uL \n::= .L | ,; uL.{,} ,/. L Types tT ::= .T | .ut1 ...tn;tT.{.} . ./T Type Schemes s ::= ....C . t Type \nAssumptions A ::= \u00b7| A,x : tx ./A A type tT is either a row variable .T or it consists of variants in\u00addexed \nby type constructors . which are not mentioned in T. Each variant consists of a type term .ut1 ...tn \nwhere the type constructor is annotated with a .ow set, followed by further variants which are restricted \nso that . cannot appear again. The superscript on a row variable restricts the types that may be substituted \nfor the variable. We sometimes omit the superscript, when the restriction is obvious from the context. \nEach type constructor carries a .ow set annotation u. A .ow set annotation u is a set of labels and a \nset variable .. Again, a su\u00adperscript on a .ow set annotations,uL, indicates that certain labels cannot \nappear in the .ow set. A type scheme ....C . t represents the sets of types that may be obtained from \nt by applying substitutions for the row variables . and the set variables ., restricted by a set of constraints \nC of a given constraint system (O, f). The following de.nition of substitution serves to formalize the \ninstantiation relation between a type scheme and its instance types. DEFINITION 4. (Substitution) A substitution \nf is a .nite mapping from set variables to .ow set annotations, and from row variables to types. We extend \nsubstitutions to total mappings on constraints, .ow set annotations, types, type schemes, and type assumptions \nin the usual capture-avoiding manner. DEFINITION 5. (Instantiation) A pair of a set of constraints and \na type (Ci ,ti) is an instance of the type scheme ....C . t, written s ' t, if there is a substitution \nf with domain {..} so that (Ci ,ti)= (fC, ft). The next relation describes generalizations of a type \nt with respect to a type assignment A and constraints D. DEFINITION 6. (Generalization) A pair of a constraint \nset and a type scheme, (C1,s), is a generalization of a type t with respect to a type assignment A and \nconstraints D, written (D, A,t) fgen (C1,s) with s =....C2 . t, if the following holds (i) for all a \n. . . ., a . FV(t) \\ (FV(C1) . FV(A)), (ii) C1,C2 f D and D f C1,C2.  Similar to the previous variant \nde.ned for the Damas-Milner type system, the generalization relation speci.es which type variables may \nbe quanti.ed over. In addition, it splits up the given constraint set taking into account that only a \npart without quanti.ed variables stays outside the type scheme. The following system of syntax-directed \ndeduction rules de.nes a general framework for constrained type systems with discrimina\u00adtive sum types. \nAn instance of the framework is determined by a constraint system (O,f) and a function T that de.nes \nclosed type schemes for all constants. T (c) ' (D,t) C f D C | A f c : t A(x) ' (D,t) C f D C | A f \nx : t C | A f e1: (t2 .ut1;t.) C | A f e2: t2 C | A f e1 e2: t1 C | A,x : t2 f e : t1 C | A f .x.e \n: (t2 .ut1;t.) D | A f e1: t1 (D,A,t1) fgen (C,s) C | A,x : s f e2: t2 C | A f let x = e1 in e2: t2 \n The conclusion of a deduction using those rules yields a type judg\u00adment C | A f e : t meaning that in \nthe context of constraints C and type assumptions A, the term e has type t. The rules for function application \nand for abstraction are different from the usual presentations because they only determine that the component \nfor the function type constructor . is de.ned in the type. However, they do not rule out the presence \nof other type con\u00adstructors, i.e., multivocal types. The let rule differs from the one used in HM(X) \n[25], by having a less restrictive generalization re\u00ad lation. In particular, HM(X) restricts generalization \nto abstracting only solvable constraints.1 Since the intended use of the system is prescriptive (that \nis, a program analysis setting), we can safely re\u00adstrict ourselves to constraints that are always solvable. \nThe rules for constants and variables additionally require that the constraints re\u00adsulting from the instantiation \nof the type scheme are satis.ed under the constraints present in the context. 3.5 Structural Properties \nThis section explores basic properties of the type system that are in\u00addependent of the stated operational \nsemantics. The lemmas devel\u00adoped here will later help proving several subject reduction results. The \n.rst lemma establishes that typing is stable under substitutions. LEMMA 2. (Type Instantiation) Let f \nbe a substitution. If C | A f e : t, then f(C) | f(A) f e : f(t). The next two lemmas establish the admissibility \nof weakening of typing contexts, .rst for type assignments, then for constraints. LEMMA 3. (Weakening \nof Type Assignments) If C | A f e : t, and A, Ai is a valid type assumption, then C | A,Aif e : t. LEMMA \n4. (Weakening of Constraints) If C | A f e : t,and D f C, then D | A f e : t. 1Their generalization relation \nis (D, A,t) fgen (C1 ....C2, s) in the notation of De.nition 6. The following Substitution Lemma is essential \nto show subject re\u00adduction for reductions involving substitution. The lemma also has to take into account \nthe generalization relation because type assign\u00adments register type schemes, whereas type judgments only \nassign types to terms. LEMMA 5. (Substitution Principle) If C | A, x : s,Aif e : t, and it also holds \nthat D1 | A f e, (D1,A,ti) fgen (D2,s), and C f D2, i : ti then C | A, Aif e[x := ei] : t. 3.6 Subject \nReduction for .let and .let,bool Subject Reduction holds for our generic type system if reduction preserves \ntypings. For the calculus .let subject reduction can be established independently of the choice of a \nconstraint system. THEOREM 1. (Subject Reduction for .let) If C | A f e : t, and e -. ei, then C | A \nf ei : t. Assuming the following type bindings for booleans ....(bool.;.{bool}) true : ....(bool.;.{bool}) \nfalse : ...i..(bool.;.{bool}) . .i. .i. .i if : the corresponding property also holds for the .let,bool-calculus. \nTHEOREM 2. (Subject Reduction for .let,bool) If C | A f e : t, and e -. ei, then C | A f ei : t. 3.7 \nSubject Reduction for .L with Simple Flow Constraints The .rst constraint system, called simple .ow constraints, \ntraces class labels using the following constraint language OS: Simple Flow Constraints cs ::= , . t \n| , . u A constraint , . t expresses a shallow labeling of t with ,. It means that a certain type t must \nat least have , in every set attached to its top-level type constructor. A constraint , . u means that \n, is member of the .ow set u. This is formalized by the two relations C f , . u (for annotations) and \nC f , . t (for types) de.ned as the smallest relation satisfying the following rules: C f , . u C f , \n. ,;u , = , i C f , . , i;u , . . . CC f , . uC f , . t C f , . . C f , . .ut1 ...tn;t Whenever the type \ncontains a row variable, the judgment is turned into a constraint. In contrast, set variables can always \nbe instanti\u00adated to satisfy the judgment. This formulation of constraint entail\u00adment leaves substitution \nimplicit. In an implementation, we have to add equality/substitution constraints of the form . = u. The \nnext two lemmas state some properties about the entailment re\u00adlation for simple .ow constraints. They \nare needed to prove subject reduction for the type system equipped with simple .ow constraints as constraint \nlanguage. We use the short-hand notation L . t for the set of constraints ,1 . t,...,,n . t with L ={,1,...,,n}. \nLEMMA 6. If C f L1 . t, andC f L2 . t, then C f L1 . L2 . t. LEMMA 7. If C f L . (t1 .ut2;t), then C \nf L . t1,C f L . u, C f L . t2, and C f L . t. i C f u = uC f ,; u = ,; ui - - ++ - + ,1;...;,n ; . = \n,1; ... ; ,m ;.i. C ,i . Lab- , j . Lab+ -- ++ C f ,1; ... ; , ;. = ,1;...;, ;.i nm . = .i. C C f . = \n. C f . = .i p1 ... pn = polarity(.)(.1 = i = n) C f ti =pi ti C f u = ui C f t = ti i ti C f .ut1 ...tn;t \n= .u1 ...ti ;ti n Figure 3. Entailment of Re.ned Flow Constraints We de.ne the following type bindings \nfor labeling constants. They make use of simple .ow constraints to express the occurrence of the appropriate \nlabels in .ow set annotations of the involved types. []L : ...i..{L . .}. (. ...);.i{.} .(.,;..;.{.}) \n..i (.,;..;.{.});.i{.} [].,, : ....i..i In the .rst type scheme, the constraint guarantees that the set \nof labels L is attached to the top-level node of the type substituted for .. The second type scheme does \nnot have a constraint, it just installs the (source or sink) label , on top of the type constructors \n.. Given the previous development, we may now de.ne a type system for .L that expresses .ow information \nby using the constraint sys\u00adtem of simple .ow constraints and the above type bindings. The following \nsubject reduction result shows that typing is preserved under labeled reductions of .L. THEOREM 3. (Subject \nReduction for .L) IfC | A f a : t, and a -. ai, then C | A f ai : t. 3.8 Subject Reduction for .L with \nRe.ned Flow Constraints As explained in Section 2.1.1, the .ow information gained from typings of the \ntype system using simple .ow constraints can be rather imprecise. It shares .ow information between all \noccur\u00adrences of expressions with the same type, hence the .ow informa\u00adtion of these expressions coincide. \nWe improve on this shortcoming by introducing a second, subtyping-based constraint system. The second \nconstraint system, called re.ned .ow constraints, is an extension of the .rst one. Its constraint language \nOR extends OS . Re.ned Flow Constraints cr ::= cs | u = ui| t = ti In addition to the constraints from \nOS, there are two other forms of constraints. The constraint u = ui expresses that (i) every positive \nlabel that occurs in u also occurs in ui and (ii) every negative label that occurs in ui also occurs \nin u. That is, it is subset for posi\u00adtive labels and superset for negative labels. The constraint t = \nti expresses that the .ow sets in the annotations of the types t and ti relate by =. However, the structure \nof the types t and ti is identical, the subsetting happens only on the annotation level. The entailment \nrelation f for the constraint system OR is the least relation de.ned by the rules shown in Figure 3 (again \nleaving sub\u00ad stitution implicit). It guarantees that negative labels cannot travel from left to right, \nand positive labels cannot travel from right to left. Subtyping on a row variable is either suspended \n(and turned into a constraint) or immediately satis.able in the re.exive case. Subtyping on a type constructor \ndemands that subsetting on the an\u00adnotations holds and that all arguments of the type constructor are \nin the subtype relation according to the polarity of the type construc\u00adtor. The polarity of an argument \nof a type constructor indicates whether the constructor is covariant . or contravariant . in this ar\u00adgument. \nThe polarity of the constructor, polarity(.) . {.,.}*, is a sequence of such indicators. Hence, We de.ne \nt =. ti as t = ti and t =. ti as ti= t. Satis.ability of subtyping constraints is transitive. LEMMA 8. \nIf C f t1 = t2, and C f t2 = t3, then C f t1 = t3. The following lemma enables us to prove subject reduction. \nLEMMA 9. If C f (t1 .ut2;t) = (t1 i.ui t2i ;ti), then C f t1 i= t1, C f t2 = t2i ,C f u = ui, and C f \nt = ti . Using the subtyping constraints we can re.ne the type bindings for the labeling constants. []L \n: ...i.ii..{L . .,. = .i} . (. ...i);.ii{.} [].,, : ....i..i .(.,;..;.{.}) ..i (.,;..;.{.});.i The type \nfor labeling constants for positive and negative labels is exactly the same as before. However the constraint \ngiven in the type schemes of the labeling with sets of .ow-class labels has changed. Instead of simply \nusing the same type variable for argument and result, the argument now needs to have a subtype of the \nresult. For proving subject reduction in this calculus, we must be able to weaken a type assumption to \na subtype. This property only holds for properly labeled terms. LEMMA 10. If e . a, C | A, x : ti ,Aif \na : t, andC f tii = ti, then C | A,x : tii ,Aif a : t. The second type system for .L with .ow information \nuses the sec\u00adond constraint system of re.ned .ow constraints and the new type bindings for the labeling \nconstants. Subject reduction also holds for labeling reductions of .L in this setting provided we are \ndealing with a sensibly labeled term ob\u00adtained by the labeling relation .. The labeling relation guarantees \nthat we can always coerce to supertypes. i THEOREM 4. (Subject Reduction) If e -. e,e . a, andC | A f \ni a : t, then there exists an ai such that C | A f ai : t, andei. a. 3.9 Conservativity over Mini-ML \nIn this section, we investigate the question how derivability in our system relates to derivability in \nthe Damas-Milner system, and vice versa. Clearly, our system should be conservative in the sense that \nany expression which has an ML type is also typeable in our sys\u00adtem. Since this property is trivial (recall \nthat every expression is ty\u00adpeable), we show that an ML typeable expression has a type deriva\u00adtion without \nmultivocal types in our system. Formally, the judgment V fUt (de.ned in Figure 4) characterizes such \nunivocal types. Basically, univocal types have only one de.ned type constructor in the discriminative \nsum. Further, we must guarantee that each row variable . appearing besides a single type constructor \ndoes not interfere with other free variables occurring elsewhere. Hence, the V fU .. ./V V1 fUt1 ... \nVn fU tn . ./FV(t1) . ... . FV(tn) V1 . ... .Vn .{.}fU .ut1 ...tn;.{.} Figure 4. Univocal types judgment \nV fUt states that t is a univocal type assuming there is the set of fresh row variables V available. \nUsing the judgment for univocal types we specialize the rules of the generic type system with multivocal \ntype to be able to recognize those deductions where only univocal types occur. T (c) ' (D,t) C fUD V \nfUt V n (FV(C) . FV(A)) = 0/ C | A fUc : t A(x) ' (D,t) C fUD V fUt V n (FV(C) . FV(A)) = 0/ C | A fUx \n: t C | A fUe1: (t2 .ut1; ..) C | A fUe2: t2 C | A fUe1 e2: t1 C | A,x : t2 fUe : t1 . ./(FV(C) . FV(A)) \nC | A fU .x.e : (t2 .ut1; ..) D | A fUe1: t1 (D,A,t1) fgen (C,s) C | A,x : s fUe2: t2 C | A fU let x \n= e1 in e2: t2 By construction, each term that is typeable only with univocal types is also typeable \nunder the less restrictive system with multivocal types. This property is expressed by the following \nlemma. LEMMA 11. If C | A fUe : t then C | A f e : t. Completeness is captured as follows: if there is \na Damas-Milner\u00adtyping for a term e, then there is also a typing with univocal types of a corresponding \nlabeled term a. THEOREM 5. (Completeness) If A fDM e : t, and e . a, then there exists some C,Ai ,ti \nsuch that C | AifUa : ti . Finally, the following Soundness Theorem shows that the systems fU allows \nus to identify those terms that are also typeable under the Damas-Milner type system. THEOREM 6. (Soundness) \nIf e . a and C | A fUa : t, then there exists some Ai ,ti such that AifDM e : ti . Taken together these \nresults imply that our procedure for identify\u00ading type errors by looking for multivocal types is correct. \n 4 Extensions A number of extensions are required to make the system amenable to a full-blown programming \nlanguage. Sum types, product types, and recursive data types are easy to add. For example, to analyze \nprograms with lists, we only need to .nd a sound type scheme for the list constructors. These type schemes \nlook daunting but they are straightforward to generate automatically using the V fUt judg\u00adment from Section \n3.9: .0 nil : ..0.1.0.list.0;.1 cons : ..0.1.2.3.4.5.6.0.1.2.3. (.1 .l1 +;.0 ((listl3 -;.1 .2; .5) .l2 \n+;.2 (listl4 +;.3 .3; .6);.4);.0) The generation principle of the extended type schemes for construc\u00adtors \ncan be used to generate extended type schemes from arbitrary ML type schemes (which is necessary in the \npresence of modules, libraries, etc). First, fresh row variables are added according to the judgment \nV fUt. Then, each type constructor in the ML type is assigned a fresh label (possibly re.ecting the name \nof the function and its de.ning module) with polarity de.ned by its occurrence in the type. 5 Implementation \nAt present, there is a prototype implementation of the type inference engine for re.ned .ow constraints \n(with annotation subtyping) but without recursive types. The prototype relies on a naive implemen\u00adtation \nof row uni.cation and is very inef.cient. However, there are a number of ef.ciently implemented type \ninfer\u00adence algorithms available that should be fairly straightforward to adapt to our system. Good starting \npoints would be the system of Henglein and Rehof [18], the Wallace framework of Pottier [28], and the \nsoft typing implementation of Wright [38]. The Wallace framework is probably the most advanced of these, \nit provides con\u00additional constraints, rows, and subtyping. However, it only supports polymorphic lets \nat the top-level. 6 Related Work 6.1 Alternative Type Inference Algorithms Lee and Yi [20] compare the \nerror reporting capabilities of Milner s bottom-up algorithm W , which performs uni.cation only at func\u00adtion \napplications, and a folklore variation called M , which passes the expected type in a top-down manner \nand hence requires uni.ca\u00adtion at lambda abstractions and variables. They refute the (previous) folklore \nthat M is better at error reporting than W by showing that the error behavior of both is incomparable. \nMcAdam [21] tries to avoid the bias of a particular traversal order of the syntax tree by unifying at \neach expression the substitutions collected in traversing the subexpression. Mitchell s type inference \nalgorithms [23] return an typing judgment with a type environment and the computed type. The judgment \nis computed bottom-up by unifying the types (as usual) and the type environments. Chitil [8] identi.es \nthe lack of compositionality of the usual infer\u00ad ence algorithms as one important reason, why type error \nmessages are hard to comprehend. He proposes a type inference algorithm that is essentially similar to \nMitchell s but which also treats let\u00adbound variables in a compositional way and computes principal typings. \nBased on the results of the inference algorithm Chitil de\u00ad.nes an explanation graph and provides the \nmeans to navigate it. A similar algorithm has also be proposed by Damas as algorithm T [10]. Principal \ntypings have been investigated separately, Wells [37] gives a good overview of their use in theory and \npractice. 6.2 Type Errors Wand [34] instruments uni.cation in a type inference algorithm for an implicitly \ntyped lambda calculus. Each substitution created dur\u00ading a uni.cation is annotated with the program point \n(a function application or some other elimination construct) that caused the uni\u00ad.cation. When a clash \nbetween two different type constructors is detected, the list of program points that led to each constructor \nis printed along with the location where the clash occurred. Walz and Johnson [33] also base their approach \non inspecting the uni.cation procedure. By looking for maximum .ows in graphs representing the uni.cation \nproblems they locate program points for each clash occurring during uni.cation. With their approach the \norder how uni.cation proceeds affects the .nal result of program points that are reported. Beaven and \nStansifer [6] provide detailed explanations of the types of expressions in a (partially instantiated) \ntyping derivation. In case, the typing derivation is incomplete due to a uni.cation failure, they propose \nto investigate the two types that led to the failure. Duggan and Bent [12] criticize earlier attempts \nto locate the source of type errors. They propose to provide an explanation for the uni.\u00adcation steps \ntaken by the type inference algorithm prior to the error. The form of this explanation is a graph of \nsubexpressions with their associated effect on the substitution constructed during type infer\u00adence. They \ndescribe an ef.cient uni.cation algorithm extended by gathering the information required for generating \nthe explanation. Heeren and others [15] describe a type inference engine for a Haskell subset that is \ngeared towards generating good error mes\u00adsages. Instead of committing to a particular strategy of solving \nthe equality constraints arising, they create a constraint graph during an initial traversal of the syntax \ntree. In varying the way that this graph is traversed and simpli.ed, they can simulate a number of type \nin\u00adference algorithms, including W and M . They propose a number of heuristics that generate error messages \nfrom the constraint graph. We believe that our type system provides a formal justi.cation for their constraint \ngraph and their heuristics may be adaptable to ex\u00adtract error messages from our typings. Haack and Wells \n[14] de.ne a slicing-based approach to .nding the source of a type error. They separate type inference \nin two phases, generation of equality constraints between types and con\u00adstraint solution. Each equality \nis annotated with the program point the caused the generation of the constraint. The solver propagates \nthe annotation when decomposing equalities. For a program with a type error, the generated constraint \nset is not solvable. The authors show that each minimal unsolvable subset determines a minimal program \nslice that exhibits the type error. The problem with their approach is that the notion of a minimal unsolvable \nsubset is not unique and they do not give an algorithm that enumerates all such minimal unsolvable subsets. \nIn contrast, our approach yields a prin\u00adcipal description of the type errors via the type inference algorithm \nfor multivocal types. Our slices are not determined by annotations on constraints, but rather by .ow \nlabels inferred by a .ow analysis. 6.3 Row Types R\u00b4 emy and Wand [36, 30, 31] introduce row types, the \nheart of our approach, for modeling record and variant types. They give sound and complete type inference \nalgorithms for their respective systems. Pottier [28] considers type inference for constrained type systems \nwith subtyping. His constraint logic includes conditional con\u00adstraints and rows, which clearly subsumes \nthe facilities required for inferring multivocal types. The system is phrased as an instance of the HM(X) \nframework [25], which provides the actual type infer\u00ad ence algorithm for free. Skalka and Smith [32] \nhave specialized row types to set types, which are record types with just the labels . They employ con\u00additional \nconstraints to infer precise types for the usual operations on sets. Our application does not require \nthis precision. 6.4 Soft Typing Soft typing, or dynamic typing, is a type theory geared at establish\u00ading \ntyping properties of programs in dynamically typed languages like Scheme. In such a language, each value \nis tagged with its type and each operation is guarded by a dynamic check that stops execu\u00adtion if an \nargument does not have the required type. The use of soft typing is twofold. On the one hand, the inferred \ntypes provide doc\u00adumentation to the programmer. On the other hand, an implemen\u00adtation can make use of \ninferred types to omit dynamic type checks and potentially optimize data representations by omitting \ntype tags. Our type system with multivocal types is similar to a soft typing system. However, there is \nno attempt to reconcile typings by insert\u00ading dynamic check operations. Instead, we aim at .nding the \nloca\u00adtions that would cause the insertion of a dynamic check. Hence, we view our work as complementary \nto the work on soft typing in that it could provide guidance to the users of such a system. The techniques \nused to infer soft typings are similar to the ones employed in this work. However, since one goal of \nsoft typing is the ability to omit checks, such systems also try to infer information about the absence \nof type constructors where our system is only concerned about their presence. Cartwright and Fagan [7] \nis the pioneering work in that area. Their type system includes discriminative unions, recursive types, \nand parametric polymorphism. The system and their algorithm are in\u00adspired by earlier work on subtyping \n[24] and record typing [29]. Aiken et al. [3] propose an extended soft typing system that drops the restriction \non unions and adds intersection types and conditional types. Their system provides a simpler formalism \nwith more accu\u00adrate typings. Henglein [17] de.nes a dynamic typing discipline which precisely formalizes \nthe role of the dynamic tagging and tag-check opera\u00adtions. He de.nes an equational theory for these operations \nand de\u00ad.nes a weaker rewriting theory that gives rise to optimally placed tagging and tag-check operations \nin minimal safe completions). Henglein and Rehof [18] give a framework that enables a transla\u00ad tion of \nScheme programs to ML programs. Their work extends soft typing by not just considering the elimination \nof tag checks but also the introduction of tags. It also extends it towards modularity in that program \nfragments can be type checked and translated separately. Furthermore, it guarantees minimal safe completions \nin the pres\u00adence of polymorphism. A main difference of our approach is that we need not worry about the \nplacement of tag operations because we are not interested in running the code as long as some types are \nmultivocal. However, it might be revealing to show where the tag operation would be put to narrow down \nthe cause of the error. Wright s system [38] is very similar to our multivocal types. It also extends \nHindley/Milner-style polymorphism with recursive types and discriminative unions (called tidy types). \nType constructors carry a .ag that indicates presence or absence of the constructor. In contrast, we \nare only tracking the presence of constructors but our set annotations track the sources and sinks of \ncomputed values. Flanagan and Felleisen [13] use set-based analysis to discover pro\u00ad gramming errors \nin a dynamically typed language (Scheme). The cited work provides a framework for simplifying constraints \nfor set\u00adbased analysis to the point where the analysis can be performed component-wise. The goals of \nthat work are similar, but the tools are different. 6.5 Flow Analysis From the vast literature on .ow \nanalysis, the following papers ex\u00adhibit the correspondence between .ow analysis (using abstract in\u00adterpretation \nor constraints) and annotated type systems. This corre\u00adspondence was noted independently by Palsberg \nand O Keefe [26] and Heintze [16]. The .rst work shows the equivalence of a type system with recursive \ntypes, subtyping, and T and . types with a constraint-based .ow analysis. Heintze s work relates abstract \ninterpretation-based .ow analysis with annotated type systems. It characterizes 0CFA in terms of an annotated \ntype system with sim\u00adple types and subtyping and exhibits the difference to simple typing (without subtyping) \nwhich performs an equational .ow analysis. Similar observations can be made for polyvariant .ow analysis \nand intersection types [27].  7 Conclusion We have designed a type system based on discriminative sum \ntypes with recursive types and annotation subtyping. This system pro\u00advides the essential information \nfor discovering the sources of type errors in programs with ML-style type inference. The paper estab\u00adlishes \nthe theoretical framework for the system and reports initial experiments with a prototype implementation. \nThese experiments are encouraging. In fact, all examples have been checked with the implementation. Further \nwork is needed to scale the implementa\u00adtion to a full language and to address advanced features like \nover\u00adloading, existential types, and rank-n polymorphism. Acknowledgments Thanks are due to Robert Cartwright, \nOlaf Chitil, Olivier Danvy, Fritz Henglein, John Matthews, and Didier Remy for discussion and suggestions \non the work reported in this paper. 8 References [1] Mart\u00b4in Abadi, Butler Lampson, and Jean-Jacques \nL\u00b4evy. Anal\u00adysis and caching of dependencies. In Kent Dybvig, editor, Proceedings of the 1996 International \nConference on Func\u00adtional Programming, pages 83 91, Philadelphia, PA, May 1996. ACM Press, New York. \n[2] ACM. Proc. of the 13th Annual ACM Symposium on Prin\u00adciples of Programming Languages, St. Petersburg, \nFlorida, 1986. [3] Alexander Aiken, Edward L. Wimmers, and T.K. Lakshman. Soft typing with conditional \ntypes. In Proceedings of the 1994 ACM SIGPLAN Symposium on Principles of Programming Languages, Portland, \nOR, January 1994. ACM Press. [4] Franz Baader and Tobias Nipkow. Term Rewriting and All That. Cambridge \nUniversity Press, 1998. [5] H. P. Barendregt. The Lambda Calculus Its Syntax and Semantics. North-Holland, \n1984. [6] Mike Beaven and Ryan Stansifer. Explaining type errors in polymorphic languages. ACM Letters \non Programming Lan\u00adguages and Systems, 2(4):17 30, March 1993. [7] Robert Cartwright and Mike Fagan. \nSoft typing. In Proc. Con\u00adference on Programming Language Design and Implementa\u00adtion 91, pages 278 292, \nToronto, Canada, June 1991. ACM. [8] Olaf Chitil. Compositional explanation of types and algorith\u00admic \ndebugging of type errors. In Xavier Leroy, editor, Pro\u00adceedings of the 2001 International Conference \non Functional Programming, Florence, Italy, September 2001. ACM Press, New York. [9] Dominique Cl\u00b4ement, \nJo\u00a8elle Despeyroux, Thierry Despey\u00adroux, and Gilles Kahn. A simple applicative language: Mini-ML. In \nProceedings of the 1986 ACM Conference on Lisp and Functional Programming, pages 13 27, 1986. [10] Luis \nDamas. Type Assignment in Programming Languages. PhD thesis, Computer Science Department, Edinburgh Uni\u00adversity, \n1985. report CST-33-85. [11] Luis Damas and Robin Milner. Principal type-schemes for functional programs. \nIn Proceedings of the 1982 ACM SIG-PLAN Symposium on Principles of Programming Languages, pages 207 212. \nACM Press, 1982. [12] Dominic Duggan and Frederick Bent. Explaining type infer\u00adence. Science of Computer \nProgramming, 27(1):37 83, July 1996. [13] Cormac Flanagan and Matthias Felleisen. Componential set\u00adbased \nanalysis. ACM Transactions on Programming Lan\u00adguages and Systems, 21(2):370 416, March 1999. [14] Christian \nHaack and Joe Wells. Type error slicing in implicitly typed, higher-order languages. In Proc. 12th European \nSym\u00adposium on Programming, Lecture Notes in Computer Science, Warsaw, Poland, April 2003. Springer-Verlag. \n[15] Bastiaan Heeren, Johan Jeuring, Doaitse Swierstra, and Pablo Azero Alcocer. Improving type-error \nmessages in func\u00adtional languages. Technical Report UU-CS-2002-009, In\u00adstitute of Information and Computing \nScience, University Utrecht, Netherlands, February 2002. Technical Report. [16] Nevin Heintze. Control-.ow \nanalysis and type systems. In Alan Mycroft, editor, Proceedings of the 1995 International Static Analysis \nSymposium, number 983 in Lecture Notes in Computer Science, pages 189 206, Glasgow, Scotland, September \n1995. Springer-Verlag. [17] Fritz Henglein. Dynamic typing: Syntax and proof theory. Science of Computer \nProgramming, 22:197 230, 1994. [18] Fritz Henglein and Jakob Rehof. Safe polymorphic type infer\u00adence \nfor a dynamically typed language: Translating Scheme to ML. In Simon Peyton Jones, editor, Proc. Functional \nPro\u00adgramming Languages and Computer Architecture 1995, La Jolla, CA, June 1995. ACM Press, New York. \n[19] Mark P. Jones. Quali.ed Types: Theory and Practice. Cam\u00adbridge University Press, Cambridge, UK, \n1994. [20] Oukseh Lee and Kwangkeun Yi. Proofs about a folklore let\u00adpolymorphic type inference algorithm. \nACM Transactions on Programming Languages and Systems, 20(4):707 723, 1998. [21] Bruce J. McAdam. On \nthe Uni.cation of Substitutions in Type Inference. In Kevin Hammond, Anthony J.T. Davie, and Chris Clack, \neditors, Implementation of Functional Lan\u00adguages (IFL 98), London, UK, number 1595 in Lecture Notes in \nComputer Science, pages 139 154. Springer-Verlag, September 1998. [22] Robin Milner. A theory of type \npolymorphism in program\u00adming. Journal of Computer and System Sciences, 17:348 375, 1978. [23] John Mitchell. \nFoundations for Programming Languages. MIT Press, 1996. [24] John C. Mitchell. Type inference with simple \nsubtypes. Jour\u00adnal of Functional Programming, 1(3):245 286, July 1991. [25] Martin Odersky, Martin Sulzmann, \nand Martin Wehr. Type in\u00adference with constrained types. Theory and Practice of Object Systems, 5(1):35 \n55, 1999. [26] Jens Palsberg and Patrick O Keefe. A type system equivalent to .ow analysis. In Proceedings \nof the 1995 ACM SIGPLAN Symposium on Principles of Programming Languages, pages 367 378, San Francisco, \nCA, January 1995. ACM Press. [27] Jens Palsberg and Christina Pavlopoulou. From polyvari\u00adant .ow information \nto intersection and union types. In Luca Cardelli, editor, Proc. 25th Annual ACM Symposium on Principles \nof Programming Languages, pages 197 208, San Diego, CA, USA, January 1998. ACM Press. [28] Franc\u00b8ois \nPottier. A versatile constraint-based type inference system. Nordic Journal of Computing, 7(4):312 347, \nNovem\u00adber 2000. [29] Didier R\u00b4emy. Typechecking records and variants in a natural extension of ML. In \nProc. 16th Annual ACM Symposium on Principles of Programming Languages, pages 77 88, Austin, Texas, January \n1989. ACM Press. [30] Didier Remy. \u00b4Projective ML. In Proc. 1992 ACM Confer\u00adence on Lisp and Functional \nProgramming, pages 66 75, San Francisco, California, USA, June 1992. [31] Didier R\u00b4emy. Type inference \nfor records in a natural exten\u00adsion of ML. In Carl A. Gunter and John C. Mitchell, editors, Theoretical \nAspects of Object-Oriented Programming: Types, Semantics, and Language Design. The MIT Press, 1994. [32] \nChristian Skalka and Scott Smith. Set types and applications. Electronic Notes in Theoretical Computer \nScience, 75, 2003. [33] Janet A. Walz and Gregory F. Johnson. A maximium .ow ap\u00adproach to anomaly isolation \nin uni.cation-based incremental type inference. In POPL1986 [2], pages 44 57. [34] Mitchell Wand. Finding \nthe source of type errors. In POPL1986 [2], pages 38 43. [35] Mitchell Wand. Type inference for record \nconcatenation and multiple inheritance. In Proceedings of the 1989 IEEE Sym\u00adposium on Logic in Computer \nScience, pages 92 97, Paci.c Grove, CA, June 1989. IEEE Computer Society Press. To ap\u00adpear in Information \nand Computation. [36] Mitchell Wand. Type inference for record concatenation and multiple inheritance. \nInformation and Computation, 93(1):1 15, July 1991. [37] Joseph B. Wells. The essence of principal typings. \nIn Proc. 29th Int l Coll. Automata, Languages, and Programming, number 2380 in Lecture Notes in Computer \nScience, pages 913 925. Springer-Verlag, 2002. [38] Andrew K. Wright and Robert Cartwright. A practical \nsoft type system for Scheme. ACM Transactions on Programming Languages and Systems, 19(1):87 152, January \n1997.  \n\t\t\t", "proc_id": "944705", "abstract": "We propose a type system for locating the source of type errors in an applied lambda calculus with ML-style polymorphism. The system is based on discriminative sum types---known from work on soft typing---with annotation subtyping and recursive types. This way, type clashes can be registered in the type for later reporting. The annotations track the potential producers and consumers for each value so that clashes can be traced to their cause.Every term is typeable in our system and type inference is decidable. A type derivation in our system describes all type errors present in the program, so that a principal derivation yields a principal description of all type errors present. Error messages are derived from completed type derivations. Thus, error messages are independent of the particular algorithm used for type inference, provided it constructs such a derivation.", "authors": [{"name": "Matthias Neubauer", "author_profile_id": "81100042558", "affiliation": "Universit&#228;t Freiburg", "person_id": "P343130", "email_address": "", "orcid_id": ""}, {"name": "Peter Thiemann", "author_profile_id": "81100458917", "affiliation": "Universit&#228;t Freiburg", "person_id": "PP39043747", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944708", "year": "2003", "article_id": "944708", "conference": "ICFP", "title": "Discriminative sum types locate the source of type errors", "url": "http://dl.acm.org/citation.cfm?id=944708"}