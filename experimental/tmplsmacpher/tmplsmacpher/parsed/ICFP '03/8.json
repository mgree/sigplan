{"article_publication_date": "08-25-2003", "fulltext": "\n Global Abstraction-Safe Marshalling with Hash Types James J. Leifer Gilles Peskine INRIA Rocquencourt \n{First.Last}@inria.fr Abstract Type abstraction is a key feature of ML-like languages for writ\u00ading large \nprograms. Marshalling is necessary for writing dis\u00adtributed programs, exchanging values via network byte-streams \nor persistent stores. In this paper we combine the two, developing compile-time and run-time semantics \nfor marshalling, that guaran\u00adtee abstraction-safety between separately-built programs. We obtain a namespace \nfor abstract types that is global, i.e. meaningful between programs, by hashing module declarations. \nWe examine the scenarios in which values of abstract types are communicated from one program to another, \nand ensure, by con\u00adstructing hashes appropriately, that the dynamic and static notions of type equality \nmirror each other. We use singleton kinds to ex\u00adpress abstraction in the static semantics; abstraction \nis tracked in the dynamic semantics by coloured brackets. These allow us to prove preservation, erasure, \nand coincidence results. We argue that our proposal is a good basis for extensions to existing ML-like \nlan\u00adguages, pragmatically straightforward for language users and for implementors. Categories and Subject \nDescriptors D.3.3 [Programming Languages]: Language Constructs and Features General Terms Languages, \nTheory, Veri.cation Keywords programming languages, ML, type theory, abstract types, marshalling, serialisation, \nmodules, singleton kinds, hash\u00ading, distributed programming, lambda calculus 1. Introduction Problem \nType abstraction is a basic tool for modular program\u00adming, allowing the programmer to separate the interface \nand the implementation of an abstract data type, and to limit the scope in which the implementation details \nare visible. Work on ML-style module systems, including [19, 21, 11, 17], has led to expres\u00adsive language \nconstructs for controlling abstraction, with modules (structures) that can export abstract types, and \nalso parameterised modules (functors); they have rich notions of type equality to deal with generativity \nand sharing. This work has largely been in the non-distributed context, concerned only with isolated \nexecutions of single programs. There, build-time type checking suf.ces to guar\u00adantee both type-safety \nand abstraction-safety the property that values of an abstract type can only be inspected or constructed \nby the code of its de.nition, and hence that any invariants of this code Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 03, August 25 29, 2003, Uppsala, Sweden. \nCopyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00.  Peter Sewell Keith Wansbrough University of Cambridge \n {First.Last}@cl.cam.ac.uk hold of all values. At run-time, type information can be erased. In the distributed \nsetting, abstraction-safety is more subtle. One may need to exchange values between multiple executions \nof the same build, between executions of different builds of the same sources, and between executions \nof builds of different sources (sharing some modules, perhaps, but not all). This interaction might be \nby network communication or via a persistent store; in either case, some run-time check is clearly needed \nto guarantee safety. For abstraction-safety, it does not suf.ce to check only the underlying representation \ntype; intuitively, we need also that the sender and receiver have compatible invariants. This can be \nen\u00adforced by requiring that they have the same code, but in general, where there is only partial sharing, \nwe shall see that the design of an appropriate check is delicate. We focus in particular on language \nsupport for marshalling a value to a byte string and unmarshalling such strings back to val\u00adues. With \nthese, one can implement a variety of useful mechanisms above the standard (byte-string) primitives for \nnetwork communi\u00adcation and persistence. For example: (1) In the existing distributed languages JoCaml \n[14] and Nomadic Pict [27] a single program can dynamically distribute computations, which can then interact \nvia typed channels, but unsafe name servers are required to boot\u00adstrap connections between programs. \nType-and abstraction-safe marshalling would enable such name servers to be expressed in a safe way. (2) \nMore generally, safe marshalling would enable one to code up a variety of communication abstractions, \nsuch as typed channels with differing behaviour (asynchronous, unicast, multi\u00adcast,...), within a high-level \nlanguage; they would then be auto\u00admatically guaranteed to be safe. Contribution We present a type system \nand semantics (both compile-time and run-time) for marshalling and unmarshalling val\u00adues between separate \nprograms. Our solution: covers modules that declare abstract types, and ancillary type\u00adsharing constraints; \n involves a dynamic type-check at unmarshal time that guaran\u00adtees both type-safety and abstraction-safety; \n ensures the resulting dynamic notion of type equality coincides with the usual static notion, so that \ndistributed programming is a smooth extension of local programming;  just works in standard cases for \ninteraction between pro\u00adgrams that share some modules, without requiring any shared data beyond the source \ncode for these modules;  supports controlled abstraction-breaking, where required; and  is ef.ciently \nimplementable. It is therefore a good basis for extensions to existing ML-like lan\u00ad  guages, pragmatically \nstraightforward for language users and for implementors. Approach The basic idea of our solution is to \nconstruct a global namespace for abstract types, meaningful across all pro\u00adgrams, by hashing module declarations. \nHash types do not appear in source programs, but are constructed at compile\u00adtime. For example, consider \na module called N with the body struct type t=Trep let x=... end and the published inter\u00adface sig type \nt val x:... end. The hash h = hash(module N=struct type t=Trep let x= ... end : sig type t val x: ... \nend, t) would be constructed to give a run-time analogue of the compile\u00adtime abstract type name N.t. \nBy constructing hashes carefully, we ensure that a simple run-time syntactic type equality check, at \nunmarshal-time, corresponds to the compile-time notion of type equivalence used in type-checking. The \nstandard operational semantics for existentials forgets ab\u00adstraction. In contrast, we give a run-time \nsemantics that records which subterms can see through which abstractions using coloured brackets, adapting \na device of [10]. For example, within the code of N.x, even after it has been substituted into its usage \nsites, the type equality h ==Trep can be used. This enables us to prove type-and abstraction-preservation, \nprogress, and the coincidence result men\u00adtioned above. We prove also that an implementation may safely \nerase all coloured brackets outside hashes at run-time. Non-goals Our focus in this paper is on what \nmechanisms are required to guarantee abstraction-safety. We do not address the full ML language; instead, \nwe focus on a core language based on simply-typed .-calculus with abstract and manifest modules, al\u00adthough \nwe argue that our formal system may be cleanly extended. Dynamic rebinding of identi.ers within marshalled \nvalues is con\u00adsidered in [4]. Moreover, we are not here concerned with low\u00adlevel representations of marshalled \nvalues; we assume some .xed scheme for marshalling simply-typed values. Finally, we protect against confusion, \nnot malice. Outline We begin in Sec. 2 by examining scenarios in which val\u00adues of abstract types are \ncommunicated between programs, identi\u00adfying the desired constructs and behaviour from the programmer \ns point of view. Sec. 3 outlines our solution informally, shows why it provides the desired behaviour, \nand shows it can be implemented ef.ciently. In Sec. 4 we present a formal calculus, .hash, that covers \nthe novel aspects of our solution. It describes networks of interact\u00ading separately-built modular programs. \nIn Sec. 5 and Sec. 6 we discuss related and future work and conclude. 2. Abstraction and interaction: \nthe desired behaviour In this section we discuss the desired behaviour of marshalling in a distributed \nsetting, with a series of informal examples in an ML\u00adlike language. Our solution, in the following section, \nshows how this ideal can be achieved. We consider an ML-like language in which a program consists of \ntwo parts: .rst a sequence of module declarations, each of which can introduce abstract types; then an \nexpression (the main body of the program). We are concerned with interaction between whole programs, \nusually built separately. This interaction is via network communication, though it could equally be via \na persistent store; in either case, the underlying mechanism simply transmits byte strings. For concreteness, \nmost of our examples involve networks consisting of two machines, pauillac and glia, running pro\u00adgrams, \nsay Pa and Pb . These network con.gurations are written pauillac[Pa ] | glia[Pb ]. It then suf.ces to \nconsider a single communication channel (such as a TCP connection between .xed ports); the language has \ncommunication primitives send : string->unit receive : unit->string We can now explore the desired behaviour \nof marshal(e :T ) and unmarshal(e :T ), which marshal to and from string. 2.1 Communication The simplest \nexample is that of sending a value of a non-abstract type between separately-built programs. Consider \nthe two pro\u00adgrams P1a = send (marshal (5 : int)) P1b = print_int (unmarshal (receive ():int)) If these \nare built and then executed on the two machines the com\u00admunication and unmarshal should succeed: v pauillac[P1a \n] | glia[P1b ] 2.2 Respecting types On the other hand, if one machine sends a string that the other \nattempts to unmarshal as an int there should obviously be a run\u00adtime failure. P2a = send (marshal (\"five\":string)) \nP2b = print_int (unmarshal (receive ():int)) pauillac[P2a ] | glia[P2b ] \u00d7 To ease debugging, it is desirable \nfor that failure to occur as early as possible (at unmarshal-time rather than when the string is used \nlater) and to be trapped cleanly, raising an exception rather than giv\u00ading unpredictable behaviour. The \nimplementation must therefore send some form of type representation. The following examples explore the \nconstraints on what this must be. 2.3 Respecting abstractions Now consider an example with an abstract \ntype. Here the EvenCounter module declares a type EvenCounter.t which has a representation type of int \nbut externally is abstract, as declared in its signature. The operations of EvenCounter enforce the invari\u00adant \nthat values of EvenCounter.t are always represented by even integers. If we allowed an arbitrary integer \nto be unmarshalled as an EvenCounter.t then the abstraction, and this invariant, would be broken; the \nunmarshal should therefore fail. P3a = send (marshal(5:int)) P3b = module EvenCounter = struct sig type \nt=int type t let start=0 : val start:t let getx=x val get:t->int let up x = x+2 val up:t->t end end print_int \n(EvenCounter.get (unmarshal (receive ()):EvenCounter.t)) pauillac[P3a ] | glia[P3b ] \u00d7 Marshalling from \na different abstract type say a TripleCounter.t to EvenCounter.t should fail similarly. 2.4 Communication \nbetween completely-shared sources For communication between two instances of the same build, which therefore \nhave identical source code, the problem is relatively sim\u00adple. Below, P4 declares an abstract type IntSet.t \nof sets of inte\u00adgers, representing them as binary search trees. It makes a run-time determination of \nwhich machine it is on and then sends or receives an IntSet.t; the unmarshal should succeed. We will \ndevelop this example later suppose this .rst implementation orders subtrees by <, and has a union operation \nthat does not remove duplicate entries. P4 = module IntSet = . struct . . type t = int tree . . . let \nsingleton = singleton-code IntSetStruct let mem = mem-code . . . . ... . . end : sig . . type t . . \n. . val singleton : int -> t . . . valmem:int->t -> bool IntSetSig val empty : t . . . . valadd:int->t \n-> t . . . val union:t->t->t . . end if ...on-machine-pauillac... then send (marshal (IntSet.singleton \n17 : IntSet.t)) else if IntSet.mem 17 (unmarshal(receive():IntSet.t)) then print \"y\" else print \"n\" v \npauillac[P4 ] | glia[P4 ] By default this should still succeed even if the two machines exe\u00adcute different \nbuilds of the same source. 2.5 Communication between partially-shared sources More generally, one may \nneed communication between programs which share only some modules (perhaps ubiquitous standard li\u00adbraries, \nor application-speci.c libraries). Here P5a and P5b share the IntSet module from before, but otherwise \nhave different mod\u00adule declarations and main body expressions; their communication of an IntSet.t should \nsucceed. P5a = module IntSet = IntSetStruct :IntSetSig send (marshal (IntSet.singleton 17 : IntSet.t)) \n P5b = module IntSet = IntSetStruct :IntSetSig module M = struct let haszerox = IntSet.mem 0 x end : \nsig val haszero : IntSet.t -> bool end if M.haszero(unmarshal (receive () : IntSet.t)) then print \"y\" \nelse print \"n\" v pauillac[P5a ] | glia[P5b ] 2.6 Guaranteeing compatible invariants In the previous \nexample the two programs had syntactically iden\u00adtical IntSet implementations. Since IntSet does not depend \non any other modules, this is a suf.cient condition to guarantee that the two abstract types have compatible \ninvariants, i.e. that any value of either will be correctly acted upon by the operations of the other. \nMoreover, it can be automatically checked, whereas compatibility of invariants cannot even be stated \nwithout speci.ng the behaviour of the two modules, and would then require general theorem-proving to \nverify. Note that it would not be suf.cient to require that the two implementations use the same representation \ntype, or even to require that the implementations are (in the absence of marshalling) observationally \nequivalent. For example, suppose that IntSetStructGt is similar to IntSetStruct but orders subtrees with \n> rather than <. P6a = module IntSet = IntSetStructGt :IntSetSig send (marshal (IntSet.add 0 (IntSet.add \n1 (IntSet.add 2 IntSet.empty)) : IntSet.t)) When communicating with P5b , which contains the original \nIntSetStruct , the unmarshal should fail, as otherwise an er\u00adroneous result could be produced. pauillac[P6a \n] | glia[P5b ] \u00d7 Later we shall see that a mechanism for intentionally circumventing this restriction, \nin a controlled way, is sometimes desirable. 2.7 Respecting names (when necessary) In some cases one \nhas modules with identical implementations that nonetheless provide conceptually different abstract types, \nfor example in the Euro and Pound modules below. Unmarshalling should respect this difference, so the \nexample should fail (just as, within a single ML program, types Euro.t and Pound.t would be incompatible). \nP7a = module Euro = struct type t=int let of_intx=x ... end : sig type t val of_int : int -> t ... end \nsend (marshal (Euro.of_int 17 : Euro.t)) P7b = module Pound = struct type t=int let of_intx=x ... end \n: sig type t val of_int : int -> t ... end unmarshal (receive (): Pound.t) pauillac[P7a ] | glia[P7b \n] \u00d7 This restriction is not always useful (e.g. whether an integer set module is called IntSet or Set \nInt is likely irrelevant), so the language should support some syntactic way of indicating whether a \nmodule name is signi.cant or not. 2.8 Module dependencies Consider now modules that depend on abstract \ntypes declared by other modules. In P8a below there is a module IntSet, providing an abstract type IntSet.t, \nfollowed by a module SummedIntSet, providing an abstract type of sets of integers augmented with a run\u00adning \nsum. The expression part constructs, marshals and sends a value of the SummedIntSet.t abstract type. \nThis SummedIntSet depends on IntSet in three ways: (1) IntSet.t occurs in its rep\u00adresentation type IntSet.t \n* int; (2) IntSet.t occurs in the type of an operation in its signature; and (3) operations from IntSet \noc\u00adcur in the de.nitions of its operations. Any such dependency means that substantive changes to the \nde.nition of IntSet must propagate through to give distinct SummedIntSet.t types. On the other hand, \nany module declarations that are not (transitively) depended upon should have no effect on SummedIntSet.t. \nFor example, consider also P8b below. It has exactly the same text as SummedIntSet but a different implementation \nof IntSet suppose IntSetStruct has a different representation type from IntSetStruct , or the same representation \nbut incompati\u00adble invariants, or different externally-observable behaviour. The P8a and P8b SummedIntSet.t \ntypes should be incompatible, so the unmarshal should fail. P8a = module IntSet = IntSetStruct :IntSetSig \nmodule SummedIntSet = struct type t = IntSet.t * int let empty = (IntSet.empty,0) let sum (x,y) = y \n... end : sig type t val empty : t val singleton : int -> t val sum:t->int val to_intset:t-> IntSet.t \n... end send(marshal((SummedIntSet.singleton 2) : SummedIntSet.t )) P8b = module IntSet = IntSetStruct \n:IntSetSig module SummedIntSet = ...same text as above... SummedIntSet.sum (unmarshal (receive () : SummedIntSet.t)) \npauillac[P8a ] | glia[P8b ] \u00d7 2.9 Mirroring local type sharing: manifest types, functors The examples \nin this and subsequent subsections are not covered by the formal calculus of Sec. 4. Nonetheless we argue \ninformally in Sec. 6.2 how they can be treated by straightforward extensions of our main techniques and \nearlier work. ML module systems include parametric modules, known as func\u00adtors, for large-scale software \nstructuring and code reuse. In the single-program world there are a number of subtle type-equality issues, \nrelated to how generative functors are, and how one can ex\u00adpress type sharing constraints [21, 17, 11, \n28]. Our marshalling primitives should correctly re.ect these subtleties in inter-program communication. \nFor example, the module SummedIntSet above, which explic\u00aditly references IntSet, might be re-expressed \nin terms of a functor F which takes any argument structure U with interface IntSetSig and builds a SummedIntSet: \nmodule IntSet = IntSetStruct :IntSetSig module F = functor (U:IntSetSig )-> struct type t=U.t*int ... \nend : sig type t ... end module SummedIntSet = F(IntSet) The functor F generates an abstract type, so \nwe must consider when that type should be compatible with others. If two separate pro\u00adgrams contain this \npreamble, they should be able to exchange val\u00adues of their respective SummedIntSet.t types. This mirrors \nthe behaviour of OCaml s applicative functors [18], in which another instance of the application F(IntSet) \nwithin the same program would have a type compatible with SummedIntSet.t. Should the functorised and \nnon-functorised (P8a ) SummedIntSet.t be compatible? Again following existing module systems, we should \nmake them incompatible, as otherwise static type equality would depend on module substitution. Type sharing \nallows functors to express type equalities between their argument and result; unmarshalling should respect \nthese static type equalities. The example F below constructs a type t but, in contrast to F, does not \nmake that type abstract; instead it makes it manifestly equal to the product of its argument type U.t \nand int. module F = functor (U:IntSetSig )-> struct type t=U.t*int ... end : sig type t=U.t*int ... end \nThe application of F to a module IntSet creates a static type equality F (IntSet).t==IntSet.t*int, which \nshould also be admitted at run-time. 2.10 Breaking abstractions (simple bidirectional case) In ongoing \nsoftware evolution, implementations of an abstract type may need to be changed, to .x bugs or add functionality, \nwhile values of that type exist on other machines or in a persistent store. It is often impractical to \nsimultaneously upgrade all machines to a new implementation version. A simple case is that in which the \nrepresentation of the abstract type is unchanged and where the programmer asserts that the two versions \nhave compatible invariants, so it is legitimate to exchange values in both directions. This may be the \ncase even if the two are not identical, e.g. for an ef.ciency improvement or bug .x. Here there should \nbe some mechanism for forcing the old and new types to be identical, breaking the Sec. 2.6 restriction. \nFor example, consider the improved IntSetStructDeDup implementation below, in which the operations are \nsimilar to IntSetStruct , the only difference being that union removes du\u00adplicates. The compiler cannot \nverify that IntSetStructDeDup has all the semantic properties that the programmer requires of IntSetStruct \n. Hence we provide a way of explicitly declar\u00ading that these modules provide compatible types. In P10a \nbe\u00adlow, IntSet .t is made equal to IntSet.t by the strong coercion ...with t =! IntSet.t. The compiler \nchecks only that the old and new types have compatible representations (here int tree), but should respect \nfurther abstractions within those representation types. This is based on our earlier work of [26]. P10a \n= module IntSet = IntSetStruct :IntSetSig module IntSet = . struct . . . type t = int tree IntSetStructDeDup \n ...improved operations... . . . end : IntSetSig with t =! IntSet.t send (marshal (IntSet .singleton \n17 : IntSet .t)) P10b = module IntSet = IntSetStruct :IntSetSig if IntSet.mem 0 (unmarshal(receive():IntSet.t)) \nthen print \"y\" else print \"n\" v pauillac[P10a ] | glia[P10b ] 2.11 Breaking abstractions (directed \ncase) In the more complex case where the old and new invariants are not compatible, or where the two \nrepresentation types differ, the pro\u00adgrammer will have to write an upgrade function. The same strong \ncoercion can be used to make this possible. For example, suppose we have a program that uses stored values \nof IntSetStruct and we wish to upgrade both the implementa\u00adtion and the stored values, changing the representation \ntype from binary search trees to red-black trees. The new implementation would have a module declaration: \nmodule IntSet2 = . struct . . . type t = int rbtree IntSetStructRBT ... . . . end : IntSetSig A program \nto upgrade the stored values can be expressed as below, with an Upgrade module that has both types, coerced \nrespectively to be equal to the old and new abstract types. (We are not proposing machinery to automatically \napply the upgrade function.) module IntSet = IntSetStruct :IntSetSig module IntSet2 = IntSetStructRBT \n: IntSetSig module Upgrade = struct type t1 = int tree type t2 = int rbtree let upgrade = ... end : sig \ntype t1 type t2 val upgrade : t1 -> t2 end with t1 =! Intset.t and t2 =! Intset2.t ...map Upgrade.upgrade \nover the stored values... Note that the coercion does not require the signature of Upgrade to coincide \nwith those of IntSet and IntSet2. The compiler only checks that IntSet.t is represented by int tree and \nIntSet2.t by int rbtree. 2.12 Forcing generativity Dually, sometimes it is desirable to force a type \nchange between builds even when the code remains identical, to prevent confusion between old and new \ncommunicated values. For example, one may have several distributed deployments of the same application \nwhich should be kept logically isolated. 2.13 E.ectful module initialisation In our previous examples \nthe components of modules are all values. Generalising this to arbitrary expressions (as ML does), an \nabstract type de.nition can be dependent on some computation with side effects. For example, consider \nan NCounter module that reads its step value from standard input when initialised; the invariant of any \nin\u00adstance is then that any value of its NCounter.t is a multiple of this step. Two instances of the module \ncan obviously have differ\u00adent invariants, and so marshalling from one to another should fail. Thus each \nrun of a program containing NCounter should have an incompatible type NCounter.t.  2.14 Marshalling \nfunctions and rebinding In this paper we deal only with marshalling of closed values; the semantics ensures \nthat all module and expression declarations are substituted in before a marshal operation takes place. \nMarshalling of functions is therefore semantically straightforward. A full language should, however, \nprovide some form of dy\u00adnamic rebinding of identi.ers when they are unmarshalled, both to achieve the \ndesired semantics where local resources have dif\u00adferent behaviour in different contexts, and for performance \nreasons where much code is shared (and so should not be communicated). The paper [4] addresses dynamic \nrebinding, in the absence of type abstraction. 3. Solution: hash types as global names This section introduces \nour solution informally, from both imple\u00admentation and semantic viewpoints. As we have seen, type-safe \nand abstraction-safe unmarshalling requires some run-time type representation in marshalled values, to \npermit a dynamic type comparison. Our solution is based on the observation that hashing module de.nitions \nprovides a global namespace for abstract types: if an identical module is hashed during builds of two \ndifferent programs at different sites, the same hash will be obtained. Thus the pro\u00adgrams share names \nfor any abstract type provided they share the source code of the module that declares the type (and of \nits de\u00adpendencies); no communication (e.g. of GUIDs) is needed at build time. We regard hashes literally \nas types hashes appear as a clause in the type grammar. They do not appear in source programs, but are \ninserted during compilation; as we shall see in more detail, the compiler replaces occurrences of an \nabstract type such as IntSet.t by the hash of the de.nition of IntSet that is in scope. Semanti\u00adcally, \nwe work with ideal hashing, with a formal syntactic con\u00adstruction hash(...). Implementations would realise \nthis with an actual hash function; we discuss the low-level properties of hashes in Sec. 3.5. At run-time, \nafter this compile-time type substitution, the types in marshal(e :T ) and unmarshal(e :T ) are closed, \nwithout free module identi.ers or type variables. They can therefore be eas\u00adily represented as byte strings, \ncommunicated across the network or stored in a persistent store, and can be compared with simple string \nequality. We ensure that this dynamic equality precisely mirrors the static notion of provable type equality \nby carefully tuning the way in which hashes are generated and used; we show below that our sys\u00adtem achieves \nthis. Unmarshalling is therefore not only type-safe, but also abstraction-safe. The standard operational \nsemantics for abstract types forgets about abstraction as computation proceeds, substituting in repre\u00adsentation \ntypes and operations. Here, in contrast, we need a run\u00adtime semantics that maintains abstraction throughout, \nboth (1) so that our type preservation theorems tell us that abstractions are not broken; and (2) to \nsupport the proof that static and dynamic type equality coincide. After a module is reduced away, module \ncode (which may see through the abstract type of that module) is in\u00adtermixed with body code (which must \ntreat the type as abstract). We therefore use a syntactic construct, coloured brackets, adapted from \nthe work of [10], to delimit the regions in which different type equivalences hold. This is not purely \na proof technique, however: in some subtle cases the coloured brackets within hashes are needed in compile-time \nhash generation to correctly distinguish abstract types that would otherwise be aliased. We show that \nimplementa\u00adtions can erase coloured brackets outside hashes after compilation. 3.1 Simple examples We \nillustrate the use of hashes in a simple case by referring back to the example of Sec. 2.4, in which \na single program, P4 , was built and run on the two machines. The build process is modelled in our semantics \nby type-checking, as usual, followed by reductions that substitute out module de.nitions, inserting hashes \nas required. Hash generation is deterministic, and hence the result of building P4 on the two machines \nis identical. The program has a single module de.nition. It has a compile-time reduction as below, to \nan executable P4 . (Note that for clarity of exposition, we omit coloured brackets from all reductions \nuntil Sec. 3.3; the example reductions as stated are not all type-preserving without them.) P4 = module \nIntSet = IntSetStruct :IntSetSig if ...on-machine-pauillac... then send (marshal (IntSet.singleton 17 \n: IntSet.t)) else if IntSet.mem 17 (unmarshal(receive():IntSet.t)) then print \"y\" else print \"n\" -. c \n(compilation) if ...on-machine-pauillac... then send (marshal (singleton-code 17 : h )) else if mem-code \n17 (unmarshal (receive () : h )) then print \"y\" else print \"n\" = P4 where h = hash(module IntSet=IntSetStruct \n:IntSetSig,t). Here the de.nitions of IntSet.singleton and IntSet.mem have been substituted for their \noccurrences, and the global name h has been substituted for type IntSet.t. Notice that h is con\u00adstructed \nfrom the entire de.nition of IntSet, including the textual name IntSet, the implementation structure \nIntSetStruct , the interface IntSetSig , and the type .eld name t. In this simple example IntSet has \nno dependencies, so one can think of hashing its source text; we will discuss later the more interesting \ncase of modules with dependencies, and also the question of exactly what form the hash function takes. \nOur liberal use of substitution is, of course, a semantic device in practice compilation would use other \nrepresentations. At run-time, the two machines pauillac and glia execute their independently-compiled \ncopies of P4 . Their shared knowledge of the hash h acts as a certi.cate that they may safely share values \nof their respective abstract types IntSet.t and IntSet.t. pauillac[P4 ] | glia[P4 ] * -. (local computation \non pauillac and glia) pauillac[send(marshal(singleton-code 17:h ))] | glia[if mem-code 17 (unmarshal(receive():h \n)) then print \"y\" else print \"n\"] * -. (local computation on pauillac, to get v ) pauillac[send(marshalled( \nv :h ))] | glia[if mem-code 17 (unmarshal(receive():h )) then print \"y\" else print \"n\"] -. (communication) \n pauillac[ () ] | glia[if mem-code 17 (unmarshal(marshalled(v :h ):h )) then print \"y\" else print \"n\"] \n-. (on glia: dynamic type check h =h , succeeds) pauillac[ () ] | glia[if mem-code 17 v then print \"y\" \nelse print \"n\"] * -. (on glia: computation, prints \"y\") pauillac[ () ] | glia[ () ] Ultimately, only \nstrings may be communicated across a network. The notation marshalled (v :T ) denotes a string literal \ncontain\u00ading representations of value v and its type T . This is only mean\u00adingful, and only used, where \nv and T are both closed. Notice that the dynamic check is simple: just that the type h sent from pauillac \nis identical to the type h written into the unmarshal on glia at compile time. Yet, by virtue of the \ncon\u00adstruction of these hashes, this is suf.cient to guarantee both type\u00adsafety and abstraction-safety. \nConsider now the programs of Sec. 2.1 2.7. How do hashes of modules provide the desired behaviour? In \nthe case of con\u00adcrete types, the comparison is obvious. For P1 , int=int; for P2 , string.do we have \nint=h .As we =int; for P3 , for no hash h have already seen, in the P4 case the two programs share an \niden\u00adtical hash h .For P5 ,in P5a and P5b the computed hash h for IntSet.t is identical (in fact the \nsame h as above). Thus the h substituted for IntSet.t in P5a s call to marshal will be identi\u00adcal to \nthat in P5b s call to unmarshal, and the communication will again succeed, exactly as we desire. Although \nP6a (Sec. 2.6) contains a type IntSet.t, it is clear that the hash h of the modi.ed module IntSet differs \nfrom the hash h of the original module, correctly re.ecting the difference in the modules behaviour. \nThe two programs will, correctly, be unable to communicate; an exception will be raised at the point \nof the unmarshal. The example of Sec. 2.7 shows why one might wish the textual name (in general, the \npath) of a module to be included in its hash, along with the module body. The two modules Euro and Pound \nare identical in all but name, and so a hash that did not include the name would treat them as interchangeable, \nclearly leading to dangerous economic confusion, and furthermore differing from the usual se\u00admantics \nof ML-like languages. On the other hand, the programmer should also be able to specify that a name is \nnot to be considered part of the module s identity. This can be done simply by having an additional form \nof module declaration, module*N=... , for which hashing uses a canonical name *, not admissible in source \nprograms, instead of the actual name N. In this simple scheme both sender and receiver must use the * \nd form, of course.  3.2 Module dependencies The example of Sec. 2.8 shows that the same module text \nde.nes a different abstract type if its dependencies change, which means that the hash of a module must \ndepend on the hashes of its depen\u00addencies. In our substitutive reduction semantics, type dependen\u00adcies \nare handled automatically: we have substituted hashes for any types of earlier modules before constructing \nthe hash of a module that depends on them. We shall see how term dependencies are also automatically \ntaken into account. Consider the following (a simpli.cation of P8a ): module A=struct type t=bool let \nx=true end : sig type t val x:t end module B=struct type t=A.t*int let x=(A.x,3) end : sig type t val \nx:t end send (marshal (B.x : B.t)) -. c (compilation) module B=struct type t=h *int let x=(true,3) end \n: sig type t val x:t end send (marshal (B.x : B.t)) -. c (compilation) send (marshal ((true,3) : h )) \nwhere h = hash ( module A=struct type t=bool let x=true end : sig type t val x:t end,t) h = hash ( module \nB=struct type t=h *int let x=(true,3) end : sig type t val x:t end,t) Here the hash h for B is constructed \nafter the hash h for A has been substituted for A.t, and after the term part true has been sub\u00adstituted \nfor A.x. It is clear that if A changed, h would change, and so h would change. This would still be true \nin the (unlikely) case that B mentions A.t but not A.x. We must also ensure h depends on h in the (common) \ncase that B mentioned A.x but not A.t, i.e. where A is used in B only to implement an internal computation. \nThe coloured brackets of the following section will conveniently suf.ce for this.  3.3 Abstraction-preserving \nreduction Some reductions in Sec. 3.1, 3.2 require non-standard type equali\u00adties to make them type-preserving. \nFor example, to type the inter\u00admediate state in Sec. 3.2 we must have (true,3) of type h *int, hence \nwe need a type equality identifying h with its representation type bool. We could allow this type equality \nto be used anywhere, but instead prefer to delimit more precisely which subterms can see through any \nparticular abstraction. We introduce coloured brack\u00adets, adapted from the work of [10], during module \nreduction. In the previous example, the .rst reduction will actually replace (A.x, 3) by ([true]hh ,3) \ninstead of just (true,3). The brackets serve two purposes. First, the lower annotation (the colour) is \na hash h , indi\u00adcating that the additional type equivalence h == bool is available when typing the inside \nof the bracketed expression. This equiva\u00adlence is drawn from the structure of h , viz. h =hash(module \nA= struct type t=bool...end:...,t). Thus, inside the brack\u00adets we have true:h . Second, the upper h annotation \nis the type of the bracketed expression as seen from the outside, thus reduction is type preserving. \n(One would often have a more complex type in the upper annotation, not just a hash, e.g. [(true,3)]hh \n*int .) The reduction semantics of our formal system moves brackets around as required to ensure that \nabstraction is preserved through\u00adout reduction, and so our type preservation result (Thm. 4.1) covers \nabstraction. If we did not use brackets but allowed hash type equal\u00adities to be used freely, abstraction \nwould become invisible after re\u00adduction. The use of brackets also simpli.es the statement of our result \nrelating static and dynamic type equality (Thm. 4.7). More\u00adover, when compiling a module that refers \nto a term .eld of a previ\u00adous one, the presence of brackets ensures that the hash of the later module \ndoes indeed depend on the hash of the earlier module. 3.4 Modest implementation demands Few changes \nare required in an ML-like language to support the strategy outlined above. Thm. 4.5 shows that type \nchecking is decidable and that hashes play no role in compile-time type-checking of source code. In par\u00adticular, \nwe can use traditional type checking and inference algo\u00adrithms essentially unchanged. Compile-time reduction \nonly builds hashes, without ever looking inside one. Run-time reduction only ever compares hashes by \nstring equality. Thm. 4.6 shows that almost all coloured brackets and type infor\u00admation can be erased \nbefore run-time, with the exception of course of marshal and unmarshal type annotations, and brackets \nwithin hashes. ML-like languages usually support separate compilation of mod\u00adules. Typically, a compilation \nphase takes a module and the signa\u00adtures of the modules it imports and generates code parameterised by \nthese dependencies. For .hash, the compilation phase would also generate a hash parameterised by the \nhashes of the imported modules, in other words a hash-to-hash function. An appropriate compositional \nimplementation of hashing must be used to make these ef.ciently representable. Typically, linking instantiates \nthe parameterised code with jumps to the code of previous modules. For .hash, the linking phase would \ndo two further things. First, it would patch the type annotations for marshal and unmarshal in the code \nby replacing references to module types by their hashes. Second, it would calculate the hash of the module \nby applying the hash-to-hash function (generated by compilation) to the hashes of previous modules. \n 3.5 Low-level details of hashes In our semantics, we work with ideal hashing, taking a free con\u00adstructor \nhash(...) which can be applied to elements of the ab\u00adstract syntax. We can think of hash as a function \nwhose injectivity guarantees abstraction-safety. To avoid communicating large quan\u00adtities of source code, \nan implementation would reify hash with a .xed-length hash function, giving a safety guarantee that is \nonly as strong as the probability of the absense of collisions. This must be chosen so that (1) collisions \nare rare, and (2) hashes are not too costly to compute. Both MD5 (RFC1321, 128-bit) and SHA-1 (RFC3174, \n160-bit) are suf.ciently cheap, and may be considered random functions for this application [24]. Let \nus consider the likelihood of colli\u00adsions. For n abstract types and N possible hash values, the prob\u00adability \nof a collision is approximately n 2/2N. Pessimistically as\u00adsuming 1010 programmers in the world, writing \n300 lines of code per day with one abstract type per 100 loc, the probability of a col\u00adlision in a century \nof abstract types (using MD5) would then be (1015)2/2129 10-9. This is much less than the probability \nof a cosmic-ray-induced processor error in this period. It may be desirable to have an absolute guarantee \nof type-safety, while accepting probabilistic abstraction-safety. To achieve this, one could pair hashes \nwith the corresponding underlying represen\u00adtation types. At the other extreme, one could accept a probabilistic \nguarantee even at simple types, by sending only a hash of the mar\u00adshalled type. These choices must depend \non a risk assessment. Note that our proposal is aiming to protect only against acci\u00addental errors during \nprogramming and software deployment, not against malicious attack, and so we are not concerned with de\u00adliberate \nsearches for collisions. Protecting against spoofed mes\u00adsages requires largely orthogonal techniques, \ne.g. message signa\u00adtures and/or encryption, that are not in the scope of this paper. Moreover, we do \nnot address the problem of communication be\u00adtween untrusting peers, where one must check not just that \nthe type advertised by the peer is compatible with the local type, but also the validity of the byte \nstring s claim to represent a value of the advertised type (see, e.g., [23]). We hash elements of the \nabstract syntax, not concrete syntax, for two reasons. Firstly, it ensures hashes are not dependent on, \ne.g., the choice of newline or newline/CR, or on comments. Secondly, it .ts well with the rest of the \nsemantics recall we must calculate hashes of modules that are the results of module substitutions. In \npractice optimised calculations would be possible, without requir\u00ading the explicit construction of canonical \nrepresentatives of abstract syntax elements. Hashing abstract syntax, which we take up to alpha-equivalence, \nhas the (benign) consequence that abstract type equality is not de\u00adpendent on the names of function parameters. \nWe have both inter\u00adnal (alpha-convertible) and external module names in the seman\u00adtics; external names \nmust be meaningful between programs. 4. Formal system Our calculus describes networks of machines. Each \nmachine exe\u00adcutes a program; a program consists of a sequence of module dec\u00adlarations followed by an \nexpression. The expression language con\u00adsists of a simply-typed call-by-value .-calculus with module \n.eld references, marshalling, and communication of strings. Consider a program containing a module declaring \nan abstract type. There is an abstraction boundary between the module s body and the rest of the program. \nInside the boundary, the type s repre\u00adsentation is visible; thus the type is said to be transparent. \nOutside, the type s representation is not visible, thus the type is opaque. Our calculus tracks this \nabstraction boundary as reduction pro\u00adceeds. Compilation replaces the abstract type by a hash h and wraps \nthe code e that comes from inside the module de.nition with coloured brackets decorated by h,as in [e]Th \n. The distinction be\u00adtween opaque and transparent views is therefore witnessed by the brackets: inside \nthe brackets, we view h as transparent; when out\u00adside h is opaque. In order to express this distinction \nin our inference rules, we dec\u00adorate each judgement with a colour hm,as in E fhm e:T . The colour has \none of two forms: it can be a hash h, in which case h is transparent and all other hashes are opaque; \nor it can be the empty colour , in which case all hashes are opaque. The reader is referred to the companion \ntechnical report [16] for the full semantics of the calculus and proofs of results. 4.1 Relation to the \ninformal discussion For brevity, we take a module language in which structures are type/term pairs, rather \nthan general dependent records from the earlier informal development. The following table summarises \nthe correspondence between the informal and formal module syntax. struct type t = T0 let y= v end . [T0, \nv ] sig typet valy: T end . [X :Type, T ] sig typet= T1 val y: T end . [X :Eq(T1), T] We split module \nnames into two parts, an external name N and an alpha-convertible name U . We write module declarations \nas module NU = M :S in m, where U binds in m and N nei\u00adther binds nor is subject to binding. The user \nwould write only one identi.er, which would be used for both. External names play no role in the static \ntype system; they are used in hash construction and hence in dynamic type checks. The formal system omits \n=! coercions and run-time generativ\u00adity, which should be straightforward extensions. Functors are also \nomitted, though we include most of the technical machinery they require, expressing abstract and manifest \ntypes in signatures us\u00ading singleton kinds. In Sec. 6.2 we propose extensions for treating these omissions. \n 4.2 Syntax We let x, X and U range over expression, type and module vari\u00adables. Networks: n ::= 0 | \nm | n|n Machines (whole programs): m ::= e | module NU = M :S in m (U binds in m) Modules: M ::= [T, \nv ] structure (v is a value) S ::= [X :K , T] signature (X binds in T) Types: T ::= UNIT | INT | STRING \nbase types | X | T . T | T * ... * T variable, function, product | U .TYPE type part of a module .......................................................... \n| h hash Hashes: h ::= hash(N , M :[X :Type, T ]) hash hm ::= h | colour ( hash maybe ) Kinds: K ::= \nType kind of all types | Eq(T ) kind of types statically equal to T Expressions: e ::= () | n unit, integers \n| (e, ..., e) | proji e tuple, projection | x | .x:T .e | ee lambda calculus (x binds in e) | U .term \nvalue part of a module | mar (e:T ) marshalling primitive | unmar e:T unmarshalling primitive | ! e | \n? send and receive ....................................................... | marshalled (e:T ) result \nof marshalling | UnmarFailure exception caused by unmar | [e]T hm coloured bracket User source programs \nare closed terms of the m grammar which do not contain any of the constructs below the dotted lines. \nValues v hm are indexed by a colour. They are de.ned formally below; they include usual .-calculus values, \nmarshalled (v :T ) and necessary brackets around values. For closed v , the value marshalled (v :T ) \nis a string, the sequence of bits that repre\u00adsents the value v and the type T. We work up to alpha-conversion. \nWe write substitutions as fol\u00adlows: { x. e} A replaces x by e in A; we also de.ne substitutions on module \ncomponents, as in { U .TYPE. T , U .term. e} A.  4.3 Static and dynamic semantics The static type system \nfor programs has judgements for subkind\u00ading, type equality, and subsignaturing relations. Module structures \nM and names U have signatures S, expressions and machines have types T , and types have kinds K . The \nsystem also de.nes correct\u00adness of colours hm, environments E, kinds K , and signatures S. E f hm K <: \nK ' E f hm T == T ' E f hm S <: S' E f hm M :SE f hm U :SE f hm e:T E f m:TE fhm T :K f hm ok E f hm \nok E f hm K ok E f hm S ok The typing rules are largely standard; the novel rules will be ex\u00adplained \nbelow. Recall that judgements are annotated by a colour hm, i.e. an optional hash the idea being that \nderivations of judge\u00adments annotated by a hash h can make use of the equality between the abstract type \nh and its implementation. Type environments may contain bindings for module, type and expression variables. \nEarlier variables bind in later types, kinds and signatures. E ::= nil | E, x:T | E, X :K | E, U :S Static \ntyping of networks, f n ok, simply means that all machines are well-formed. We de.ne compile-time reductions \nm -. c m' of machines (performed after type checking), and run-time reductions e -. hm e' and n -. n' \nfor expressions and networks. 4.3.1 Singleton kinds Following [17, 11, 28], we use singleton kinds to \nhandle abstract and concrete signatures in a uniform way. We have two families of kinds: Type is the \nkind of all types; and, for any type T , Eq(T ) is the singleton kind of all types that are provably \nequal to T . A module consists of a structure [T0, v ] and a signature [X :K , T ]. The structure has \na representation type T0 and a value v  think of a tuple of operations. This v must have the type { \nX . T0} T , and the implementation type T0 must have the kind K . This is made precise by the following \nrule: E f hm T0:KE, X :K f hm T :Type E f hm v :T ' E, X :Eq(T0) f hm T ' == T (MS.struct) E f hm [T0, \nv ]:[X :K , T ] For an abstract module we have K = Type, revealing no in\u00adformation about the representation \ntype, whereas for a concrete module, commonly K = Eq(T0), revealing it. This is captured with the type \nequality relation: in the context of a module dec\u00adlaration module NU = M :[X :K , T ] in , one can use \nthe path U .TYPE to refer to the type part of the module. If it is con\u00adcrete, with K = Eq(T0), one can \nfurther use the type equality U .TYPE == T0, whereas if it is abstract U .TYPE is typically not equal \nto any other type. The subkinding relation K <: K ' places Type above all sin\u00adgleton kinds. This is used \nto de.ne subsignaturing and hence, using subsumption, allows a concrete module can be used as if it had \nan abstract signature. 4.3.2 Hash formation, type equality of hashes At run-time, we need globally meaningful \ntype names for abstract types, corresponding to the U .TYPE paths used in compile-time type checking. \nWe construct these global names by hashing (well\u00adtyped) closed abstract modules, together with the associated \nexter\u00adnal name. f [T0, v ]:[X :Type, T ] (hmok.hash) f hash(N , [T0, v ]:[X :Type, T ]) ok As explained \ninformally earlier, judgements annotated by a hash permit an additional type equality: under the colour \nh = hash(N , [T0, v ]:[X :Type, T ]), h is equal to its implementa\u00adtion T0: E f h ok (Teq.hash) E f h \nh == T0 These two rules examine the internal structure of hashes, which might be thought to be computationally \nproblematic. However, while they are semantically necessary, they play no role in user program type-checking \n(Thm. 4.5) or in execution. 4.3.3 Compile-time reduction and coloured brackets Module reduction constructs \nthe type representations that will be used at run-time in marshalling and unmarshalling. Reducing a concrete \nmodule is simple: we replace references to its type com\u00adponent by its manifest type, and references to \nits term component by the value inside the module. module NU =[T0, v ]:[X :Eq(T1), T ] in m -. c { U \n.TYPE. T1, U .term. v } m When it comes to abstract types, things are more interest\u00ading. Given an abstract \nmodule declaration module NU = [T0, v ]:[X :Type, T ], we normally have no way of referring to its type \nother than by name, i.e. U .TYPE. However U is not mean\u00adingful on other machines, which motivates the \nintroduction of the hash of the module, i.e. h = hash(N , [T0, v ]:[X :Type, T ]). Then module reduction \nreplaces references to the type component by h. References to the term component are replaced by the \nvalue suitably protected by h-coloured brackets, which embody the ab\u00adstraction boundary around the module \ns body as discussed above. module NU =[T0, v ]:[X :Type, T ] in m {X .h}T -. c { U .TYPE. h, U .term. \n[v ]} m h In general, in a bracket expression [e]T the lower annota\u00ad hm , tion hm is a colour that indicates \nwhat type equalities may be used to type e.If hm = hash(N , [T0, v ]:[X :Type, T ]), then the equality \nhm == T0 is available when typing e, through (Teq.hash) (Sec. 4.3.2). If hm = , e is typable without \nany extra equalities. The upper annotation T is the externally visible type of e. The following rule \n(the only typing rule that mentions brackets) shows this colour change formally. E f hm. T :Type E f \nhm e:T (eT.col) [e]T E f hm. hm :T  4.3.4 Expression reduction Expression reduction is based on a standard \ncall-by-value .\u00adcalculus semantics. In this subsection, we give the function ap\u00adplication rule and bracket-pushing \nrules. In later subsections, we show the rules for marshalling and communication. As we show in Thm. \n4.6, brackets can be erased before run\u00adtime reduction. However, the brackets presence is necessary for \ntype preservation (Thm. 4.1). Given their presence, we need reduc\u00adtion rules to push them inwards so \nthat the brackets do not in\u00adterfere with computationally signi.cant reductions (Thm. 4.3). To describe \nthe bracket pushing rules, and to achieve type preserva\u00adtion, it is necessary to index the reduction \nrelation, class of values, and reduction contexts by colours. We write v hm for a value of colour hm. \nBrackets may appear in a value when used to build a value of an abstract type out of a value of the corresponding \nimplementation type, for example [3]hh , where the implementation type of h is INT. hm hmhm v ::= n | \n() | (v , ..., v ) | .x:T .e h1 ]h1 | marshalled (v :T) | [v where h1 . = hm h1 The following bookkeeping \nrules push brackets with manifestly decomposable types inside expressions, and remove them where not \nnecessary. [n]INT -. hm n hm. [()]UNIT -. hm () hm. hm hmT1*...*Tj hm ]T1 hm Tj [(v1 , ..., vj )] -. \nhm ([v1 hm. , ..., [vj ] hm. hm. ) [.x:T .e]T.T. hm } e]T ' -. hm .x:T .[{ x. [x]T. hm. hm. :T )]STRING \n[marshalled (v -. hm marshalled (v :T ) hm. h1 ]h1 ]h1 h1 ]h1 [[v -. hm [v .. if h1 = h2 . h2 = hm h1 \nh2 h1 hm1 ]h2 hm1 [v hm1 -. hm v if hm1 = hm . hm1 = Function application introduces brackets to protect \nthe argument, since the formal parameter may itself be used under a bracket in the body of the function. \nThis is a variant of [10], where the formal parameter has to be used at the colour of the function itself. \nhm hmT (.x:T .e) v -. hm { x. [v ]hm } e  4.3.5 Marshalling As in [1], mar (e:T ) tags the value of \ne with a type annota\u00adtion T , producing a result of type STRING. The dual construct unmar e:T produces \na value of type T , which the type tag in e must (dynamically) match. E f hm e:T (eT.mar) E f hm mar \n(e:T ):STRING E f hm T :Type E f hm e:STRING (eT.unmar) E f hm (unmar e:T ):T There is a subtlety here: \nin the conclusion of (eT.mar), the fact that e has the type T may require the extra type equal\u00adity provided \nby hm. Hence we introduce marshalled (e ' :T ), which requires the argument to be not only closed but \ntypable in , i.e. everywhere. Reduction transforms mar (v hm :T ) into hm ]T marshalled ([v hm :T ), \nwhere the brackets serve to ensure that any type equality provided by hm is always available to type \nv hm (even after sending the marshalled value to another machine). hm hm Note that before reducing mar \n(v :T ), both v and T will have been closed by substitution. hm hmT mar (v :T ) -. hm marshalled ([v \n]hm :T ) E f hm ok f e:T (eT.marshalled) E f hm marshalled (e:T ):STRING The unmarshalling of a string \n.rst extracts the type tag T from the string and compares it with the tag for the expected type T ' . \nSince T is a valid type for v in , it is also one in hm. The type tags T and T ' are compared by syntactic \nequality: if the types match, the original value is extracted from the string; otherwise an exception \nis raised. This dynamic type equivalence is closely related to static equivalence (Thm. 4.7). unmar (marshalled \n(v :T ):T ' ) -. hm v if T = T ' -. hm UnmarFailure otherwise 4.3.6 Programs and networks A machine \nconsists of a series of module declarations followed by an expression. Each module declaration may refer \nto the previous ones. E f T :Type E f M :SE, U :S f m:T (mT.let) E f (module NU = M :S in m):T A \nnetwork is a parallel juxtaposition of machines. Note that each machine has its own environment: there \nis no explicit scope that encompasses more than one machine. f n1 ok f n2 ok f m:UNIT (nok.par) (nok.mach) \nf n1 | n2 ok f m ok We assume that there is a single channel, which carries values of type STRING. The \nexpression ! e sends the value of e over that channel, and ? reads a value from that channel. Communication \nis straightforward as all the work required to make values and types intercomprehensible is done by the \nmarshalling apparatus; for suit\u00adable evaluation contexts CC and CC we have just the rule hm1 hm2 below, \nwriting context application with a dot. hm1 hm1 CC hm1 .! v | CC hm1 .() | CC hm2 .? -. CC hm2 .v \n  4.4 Results First, our calculus enjoys type preservation and progress properties. Theorem 4.1 (type \npreservation for compile-time, expression, and network reduction) if m -. c m ' and f m:T then f m \n' :T;  if e -. hm e ' and f hm e:T then f hm e ' :T ; and  if n -. n ' and f n ok then f n ' ok.  \nTheorem 4.2 (progress for compile-time reduction) If f m:UNIT then either m is an expression; or  \nm reduces, i.e. there exists m ' such that m -. c m ' . Moreover, compile-time reduction is terminating. \n Theorem 4.3 (progress for expressions) If f hm e:T then one of the following holds: hm ; e is a value, \ni.e. there exists v hm such that e = v  e reduces, i.e. there exists e ' such that e -. hm e ' ;  e \nis blocked waiting for I/O, i.e. there exists CC hm and e ' hm2 = CC hm ' = CC hm such that e hm2 .! \ne or e hm2 .?;or e has thrown an exception, i.e. there exists CC hm such that hm2 e hm2 .UnmarFailure. \n = CC hm In addition, we have proved a normalisation result for expres\u00adsions, showing that the rules \nfor coloured brackets do not introduce any divergencies. Both compile-time machine reduction and run-time \nexpression reduction are deterministic (network reduction is not, of course): Theorem 4.4 (determinacy \nfor compile-time and expression re\u00adduction) ' '' ''' If m -. c m and m -. c m then m = m ; and ' '' ''' \nif e -. hm e and e -. hm e then e = e . For static type checking: Theorem 4.5 (decidability of type checking) \nType checking is decidable. Furthermore, user source programs can be typed by derivations involving no \nhashes or coloured brackets. At run-time, all type annotations except those on mar , marshalled , and \nunmar can be erased. Moreover, all coloured brackets can be erased except for those that occur within \na hash within one of those remaining annotations. More precisely, we de.ne erase(e) to be e with all \ntype annotations and brackets erased except that the type annotations on mar , marshalled , and unmar \nare left unchanged. We de.ne ---. to be like erase -. hm by taking the erase-image of the left-and right-hand \nsides of each rule (and removing rules that would become e ---. e). erase Theorem 4.6 (erasure preserves \nreduction outcomes) Assume f e:T . We have that e -. e ' implies .1' erase(e) ---. erase(e ). Conversely, \nerase(e) ---. e0 im\u00ad erase erase '' plies that there exists e such that erase(e ' )= e0 and e -. ;1 e \n. Note that brackets are needed in module reduction, to keep track of a module s ancestors as we build \nits hash. Finally we show that, under reasonable conditions, static and dy\u00adnamic type equality coincide. \nLet D be a module declaration con\u00adtext: module N0U0 = M0:S0 in ...module Nj Uj = Mj :Sj in in the user \nsource language (with no brackets or hashes). Consider a machine D.C .e for some expression context C \nand an expression e =(unmar (mar (e0:T0):T1)). One would like this dynamic type check to succeed if and \nonly if T0 and T1 are statically prov\u00adably equal, i.e. iff U0:S0, ..., Uj :Sj f T0 == T1. Write sD for \nthe accumulated substitution de.ned by the module reduction rules for D (we omit an explicit de.nition \nfor lack of space). The dynamic check is then sD T0 = sD T1.We have: Theorem 4.7 (coincidence between \ndynamic and static type checking) Suppose that D.C .e is well formed (i.e. f D.C .e:UNIT), that it contains \nno hashes, and that its external names N0 , ..., Nj are distinct. Let E = U0:S0, ..., Uj :Sj be the associated \nenvironment. Assume that T0 and T1 contain no hashes and E f Ti:Type for i =0, 1. Then E f T0 == T1 \niff sD T0 = sD T1. The requirement that the external names N0 , ..., Nj be distinct rules out the rather \npathological programs in which there are two module de.nitions with the same name, one shadowing the \nother, which have identical structures, signatures, and dependencies. The exclusion of hashes is automatic \nfor user source programs. One can imagine stronger theorems, relating type equality be\u00adtween two programs \nthat share a common (DAG-)pre.x of module de.nitions, but their statements become rather elaborate. 5. \nRelated work Modules and generativity There is an extensive literature on ML-style modules, including \n[19, 21, 11, 17, 28, 7], much of it discussing subtle questions of generativity versus applicativity. \nTo our knowledge, however, none deals with the inter-program case. In [26], fresh type names are generated \nduring call-by-value mod\u00adule reduction, with .-binders that can extrude across distributed scope. This \nallows inter-program sharing, and also a with! coer\u00ad cion, but at the pragmatically-awkward cost of requiring \nparticular object .les to be shared. Type dynamic Our marshal and unmarshal operations are essentially \nconstructors and destructors for values of dynamic type; mar is just dynamic, and unmar is a restricted \nform of typecase. Our dynamic values have type STRING, emphasising that they may be communicated readily. \nType Dynamic was .rst formalised by Abadi et al. [1, 2], who also gives a historical survey. Intensional \npolymorphism [12, 31] permits run-time type analysis of all values. Marshalling abstract types The problem \nof marshalling val\u00adues of abstract (existential) type has not been satisfactorily ad\u00addressed theoretically \nbefore. In several systems, abstract types are run-or build-time generative, so that two executions or \nbuilds of the same source will yield distinct types. While communication within such a program can be \nabstraction-safe, successful communication between builds can only be at the representation type, and \nhence abstraction-unsafe. This is true, for instance, of [2], TMAL [8], Modula-3 [6, 5], Alice [3], and \nthe typed-channel languages listed below. Weirich [32] exposes an existential s representation type to \ntype analysis, permitting a type-safe polytypic marshalling function to be written. As future work we \nhope to expose our global type names at term level (cf. [13]), permitting an abstraction-safe poly\u00adtypic \nmarshalling function to be written. Furuse and Weis [9] argue for ignoring abstraction, checking representation \ntypes only. A number of programming languages feature some form of built\u00adin marshalling (pickling, serialisation, \netc.): for example Modula-3, Alice, Java, .NET, and OCaml. Most of these languages serialise the type \nalong with the value in order to permit a check at unmar\u00adshal time, and represent the type by a hash. \nLanguages differ, how\u00adever, in exactly what is hashed i.e., in what is considered when deciding type \nequality. In Modula-3, abstract types are made opaque by branding, which may be either by a literal string \n(analogous to an external name) or a compiler-generated unique identi.er. The latter are unique within \na program but not necessarily related between programs, so explicit brands must be used for inter-program \ncommunication; however, they do not guarantee abstraction-safety for that case. Revelation can be used \nto make an abstraction transparent. In Alice, abstract type creation is run-time generative, meaning \nthat abstract types from different executions are always distinct. This vacuous abstraction-safety forces \nthe use of representation types for pickling between different programs. In Java serialisation [29], \nclass equivalence is on fully-quali.ed class name, the representation type of all .elds, and the types \nof all non-private methods; the implementation is not considered in type equality. A strong coercion \n(Sec. 2.10) is provided (although compatibility of representation types is not checked until unmar\u00adshal \ntime). In .NET serialisation [20], class equivalence is on the textual name along with the implementation \nof the entire assembly in which it is de.ned (a single DLL or EXE, which may comprise many source .les). \nThis guarantees data structure invariants are maintained, as in our approach; however, we work on the \nmuch .ner scale of individual modules, and furthermore we require only source code to be shared, not \nobject .les. OCaml [22] does no typechecking for marshalling at all, and hence is not even type-safe. \nWhen unmarshalling a function, it veri.es (by a hash) that the communicating builds are identical, thus \nallowing the code pointers of all closures to be communicated literally. Coloured brackets Coloured brackets \nwere introduced in [33, 10]; we differ in that we permit a variable to occur in a colour other than the \none where it is de.ned. Our proofs are harder, our \u00df-rule has to introduce extra brackets, but our brackets \ncarry only a single optional hash, rather than a list of hashes. Rossberg [25], like us, is concerned \nto preserve the opacity of abstract types under reduction due to the presence of typecase. His coercions \nserve the same purpose as our brackets, but his use of the closed-scope open construct instead of dot \nnotation prevents any possibility of sharing values of abstract type between instances. Typed channels \nSeveral languages, e.g. JoCaml [14], Nomadic Pict [27], Facile [30, 15], implement typed channels. These \nper\u00admit type-and abstraction-safe communication once the channel is established. Establishing a channel \nat an abstract type, however, re\u00adquires the endpoints somehow to share the type already; in the case \nthat the endpoints reside in different programs or instances, this re\u00adquires an unsafe cast, usually \nperformed (outside the language) by a name server. 6. Conclusions and future work 6.1 Summary We have \nproposed a novel and expressive design for guarantee\u00ading type-and abstraction-safe marshalling of data \nsent between distributed ML programs, that can uniformly treat manifest, ab\u00adstract, and generative types. \nThe key technical idea is to use hashes of module declarations as globally-meaningful type names, which \nare inserted at compile-time and then compared dynamically when unmarshalling. We add coloured brackets \nto delimit the abstrac\u00adtion boundary within which hashes are transparent, tracking these brackets through \nthe reductions so as to achieve type and abstrac\u00adtion preservation. Our proposal is a smooth extension \nof existing ML-like languages: type checking is unchanged, most type infor\u00admation can be erased before \nrun-time, and the dynamic type check closely mirrors static ML type equivalence. 6.2 Future work In \nthe future, we aim to broaden our solution to be applicable to full-scale languages. The following extensions \nwill be required to cope with the ex\u00adamples in Sec. 2.9 2.13. The strong coercion (Sec. 2.10 and 2.11) \nused for forcing an abstract type to have the same hash as an earlier module, has a simple compile-time \nimplementation: check the rep\u00adresentation types of the two are provably equal, then simply reuse the \nhash of the earlier module as the type name for the new. This requires the compiler to keep a mapping \nfrom hashes to representa\u00adtion types, which is straightforward. Programmer-requested gener\u00adativity (Sec. \n2.12) can be dealt with in an implementation by gen\u00aderating a fresh global name (say a random bit string \nof the same length as hashes) at compile time; its semantics can be modelled by .-binding. Both this \nand the strong coercion are very similar to the constructs in our earlier work [26]. Side-effect-induced \ngener\u00adativity (Sec. 2.13) requires a way to identify simple pure compu\u00adtations in structure bodies that \nthe programmer can easily under\u00adstand; abstract types of structures with pure computations should be \nhashes, whereas those of structures with effectful computations should have freshly-generated names. \nFunctors (Sec. 2.9) are a more substantial extension, but, at least for a restricted but useful class, \nshould be straightforward. Consider .rst-order applicative functors [18] and module expressions that \nare either (i) an explicit structure, possibly multiply-abstracted, or (ii) pure, i.e. constructed from \nmodule identi.ers, abstraction and application. These give rise to functions from hashes to hashes; applying \nthese functions gives run-time representations of the compile-time path-based type names. Other substantial \nextensions also need to be considered. Depen\u00addent record structures, i.e. module structures with multiple \n.elds also appear in this paper s informal examples; they should be con\u00adceptually straightforward. Parametric \nand substructuring polymor\u00adphism within the dynamic check would allow receivers to accept a more general \ntype than that offered by the sender. This is a more substantial extension; it will be a challenge to \nminimise the transmitted type information required for these dynamic subtype checks. One may want to \nrebind (Sec. 2.14) identi.ers within a transmitted value to avoid the overhead of sending code already \navailable at the other end, or to obtain location-speci.c behaviour; here we aim to integrate hash types \nwith [4]. Marshalling reference cells exhibits related problems: should the reference be rebound, made \nremote, or duplicated? More generally, one must consider values mentioning other machine resources: screens, \n.les. . . We wish to integrate our work with existing systems for dis\u00adtributed programming which have \nstatically typed channels for nor\u00admal operation but no safe way of initiating communication, such as \nJoCaml [14] and Nomadic Pict [27]. We also wish to test the ex\u00adpressiveness of our marshalling primitives \nby using them to write libraries for safe distributed communication and persistence. Acknowledgments \nWe acknowledge support from a Royal Society University Research Fellowship (Sewell), EPSRC grant GRN24872 \n(Wansbrough), EC FET-GC project IST-2001-33234 PEPITO, and APPSEM 2. The authors thank Georges Gonthier, \nJean-Jacques L\u00b4evy, Luc Maranget, and the anonymous referees for their suggestions. 7. REFERENCES [1] \nM. Abadi, L. Cardelli, B. Pierce, and G. Plotkin. Dynamic typing in a statically typed language. ACM \nTOPLAS, 13(2):237 268, 1991. [2] M. Abadi, L. Cardelli, B. Pierce, and D. R\u00b4emy. Dynamic typing in polymorphic \nlanguages. J. Functional Programming, 5(1):111 130, 1995. [3] T. Alice Project. Alice manual: Pickling. \nhttp://www.ps.uni-sb.de/alice/manual/pickling.html, 2003. [4] G. Bierman, M. Hicks, P. Sewell, G. Stoyle, \nand K. Wansbrough. Dynamic rebinding for marshalling and update, with destruct-time .. In Proc. ICFP \n2003, 2003. Full version available as UCAM-CL-TR-568. http://www.cl.cam.ac.uk/~pes20/. [5] A. Birrell, \nG. Nelson, S. Owicki, and E. Wobber. Network objects. Software Practice &#38; Experience, 25(S4):87 \n130, 1995. Available in slightly different form as SRC-115 revised. [6] A. Z. Broder et al. Fingerprint.i3. \nhttp://research.compaq.com/SRC/m3sources/html/ fingerprint/src/Fingerprint.i3.html, 1994. [7] D. Dreyer, \nK. Crary, and R. Harper. A type system for higher-order modules. In Proc. 30th POPL, New Orleans, pages \n236 249, 2003. [8] D. Duggan. Type-safe linking with recursive DLLs and shared libraries. ACM TOPLAS, \n24(6):711 804, 2002. [9] J. Furuse and P. Weis. Entr\u00b4 ees/sorties de valeurs en Caml. In J. Francophones \ndes Langages Applicatifs, 2000. [10] D. Grossman, G. Morrisett, and S. Zdancewic. Syntactic type abstraction. \nACM TOPLAS, 22(6):1037 1080, 2000. [11] R. Harper and M. Lillibridge. A type-theoretic approach to higher-order \nmodules with sharing. In Proc. 21st POPL, 1994. [12] R. Harper and G. Morrisett. Compiling polymorphism \nusing intensional type analysis. In Proc. 22nd POPL, pages 130 141, 1995. [13] M. Hicks, S. Weirich, \nand K. Crary. Safe and .exible dynamic linking of native code. In Proc. 3rd Workshop on Types in Compilation, \npages 147 176, 2000. [14] JoCaml. http://pauillac.inria.fr/jocaml/. [15] F. Knabe. Language Support for \nMobile Agents. PhD thesis, Carnegie Mellon University, Dec. 1995. [16] J. J. Leifer, G. Peskine, P. Sewell, \nand K. Wansbrough. Global abstraction-safe marshalling with hash types. Technical Report RR-4851, INRIA \nRocquencourt, 2003. Available from http://pauillac.inria.fr/~leifer/research.html. Also published as \nUCAM-CL-TR-569. [17] X. Leroy. Manifest types, modules, and separate compilation. In Proc. 21st POPL, \npages 109 122, 1994. [18] X. Leroy. Applicative functors and fully transparent higher-order modules. \nIn Proc. 22nd POPL, pages 142 153, 1995. [19] D. MacQueen. Modules for Standard ML. In Proc. 1984 ACM \nSymp. LISP and Func. Prog., pages 198 207, 1984. [20] Microsoft Corporation. .NET Framework developer \ns guide: Serializing objects. http://msdn.microsoft.com/library/ en-us/cpguide/html/cpovrserializingobjects.asp, \n2001. [21] R. Milner, M. Tofte, and R. Harper. The De.nition of Standard ML. MIT Press, 1990. [22] Objective \nCaml. http://caml.inria.fr. [23] B. Pierce and E. Sumii. Relating cryptography and polymorphism. http://web.yl.is.s.u-tokyo.ac.jp/~sumii/pub/, \nJuly 16 2000. Substantially revised version to appear in J. Comp. Security. [24] M. J. B. Robshaw. On \nrecent results for MD2, MD4 and MD5. RSA Laboratories Bulletin, (4), Nov. 12 1996. [25] A. Rossberg. \nDynamic opacity for abstract types. Technical report, Programming Systems Lab, Universit\u00a8at des Saarlandes, \n2002. http: //www.ps.uni-sb.de/Papers/abstracts/opaque.html. [26] P. Sewell. Modules, abstract types, \nand distributed versioning. In Proc. 28th POPL, pages 236 247, 2001. [27] P. Sewell, P. T. Wojciechowski, \nand B. C. Pierce. Location-independent communication for mobile agents: a two-level architecture. In \nInternet Programming Languages, LNCS 1686, pages 1 31, 1999. [28] C. A. Stone and R. Harper. Deciding \ntype equivalence in a language with singleton kinds. In Proc. 27th POPL, pages 214 227, 2000. [29] Sun \nMicrosystems. Java object serialization speci.cation 1.4.4. http: //java.sun.com/j2se/1.4.1/docs/guide/serialization/, \n2002. [30] B. Thomsen, L. Leth, and T.-M. Kuo. A Facile tutorial. In CONCUR 96, LNCS 1119, pages 278 \n298, 1996. [31] S. Weirich. Type-safe cast: Functional pearl. In Proc. ICFP, Montreal, pages 58 67, 2000. \n[32] S. Weirich. Higher-order intensional type analysis. In Proc. 11th ESOP, LNCS 2305, Grenoble, France, \n2002. [33] S. Zdancewic, D. Grossman, and G. Morrisett. Principals in programming languages: A syntactic \nproof technique. In Proc. ICFP, Paris, pages 197 207, Sep 1999. $Revision: 1.212 $ $Date: 2003/06/25 \n14:38:47 $    \n\t\t\t", "proc_id": "944705", "abstract": "Type abstraction is a key feature of ML-like languages for writing large programs. Marshalling is necessary for writing distributed programs, exchanging values via network byte-streams or persistent stores. In this paper we combine the two, developing compile-time and run-time semantics for marshalling, that guarantee abstraction-safety between separately-built programs. We obtain a namespace for abstract types that is global, i.e. meaningful between programs, by hashing module declarations. We examine the scenarios in which values of abstract types are communicated from one program to another, and ensure, by constructing hashes appropriately, that the dynamic and static notions of type equality mirror each other. We use singleton kinds to express abstraction in the static semantics; abstraction is tracked in the dynamic semantics by coloured brackets. These allow us to prove preservation, erasure, and coincidence results. We argue that our proposal is a good basis for extensions to existing ML-like languages, pragmatically straightforward for language users and for implementors.", "authors": [{"name": "James J. Leifer", "author_profile_id": "81337490961", "affiliation": "INRIA Rocquencourt", "person_id": "PP43121732", "email_address": "", "orcid_id": ""}, {"name": "Gilles Peskine", "author_profile_id": "81337492671", "affiliation": "INRIA Rocquencourt", "person_id": "PP37028139", "email_address": "", "orcid_id": ""}, {"name": "Peter Sewell", "author_profile_id": "81100511814", "affiliation": "University of Cambridge", "person_id": "PP14177906", "email_address": "", "orcid_id": ""}, {"name": "Keith Wansbrough", "author_profile_id": "81100225284", "affiliation": "University of Cambridge", "person_id": "PP38023996", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944714", "year": "2003", "article_id": "944714", "conference": "ICFP", "title": "Global abstraction-safe marshalling with hash types", "url": "http://dl.acm.org/citation.cfm?id=944714"}