{"article_publication_date": "08-25-2003", "fulltext": "\n An Effective Theory of Type Re.nements Yitzhak Mandelbaum David Walker * Robert Harper Princeton University \nPrinceton University Carnegie Mellon University ABSTRACT We develop an explicit two level system that \nallows program\u00admers to reason about the behavior of e.ectful programs. The .rst level is an ordinary \nML-style type system, which confers standard properties on program behavior. The second level is a conservative \nextension of the .rst that uses a logic of type re.nements to checkmore precise properties of program \nbe\u00adhavior. Our logic is a fragment of intuitionistic linear logic, which gives programmers the ability \nto reason locally about changes of program state. We provide a generic resource se\u00admantics for our logic \nas well as a sound, decidable, syntactic re.nement-checking system. We also prove that re.nements give \nrise to an optimization principle for programs. Finally, we illustrate the power of our system through \na number of examples.  Categories and Subject Descriptors D.3.1 [Programming Languages] : Formal De.nitions \nand Theory semantics; F.3.1 [Logic and Meanings of Programs] : Specifying and Verifying and Reasoning \nabout Programs pre-and post-conditions, invariants; F.3.2 [Logic and Mean\u00adings of Programs] : Semantics \nof Programming Languages operational semantics General Terms Languages, Design, Theory  Keywords E.ectful \nComputation, Type Re.nement, Linear Logic, Lo\u00adcal Reasoning, Type Theory * Supported in part by NSF Trusted \nComputing grant CCR\u00ad0208601, NSF Career grant CCR-0238328 (Programming Languages for Secure and Reliable \nComponent Software) and a generous gift from Microsoft Research. Supported by the National Science Foundation \nunder grant CCR-0204248: Type Re.nements from September 1, 2002 until August 31, 2005. Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 03, August \n25 29, 2003, Uppsala, Sweden. Copyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00. 1. INTRODUCTION One \nof the major goals of programming language design is to allow programmers to express and enforce properties \nof the execution behavior of programs. Conventional type systems, especially those with polymorphism \nand abstract types, provide a simple yet remarkably e.ective means of specifying program properties. \nHowever, there remain many properties which, while apparent at compile-time, cannot be checked using \nconventional type systems. For this reason, there has been substantial interest in the formulation of \nre.nements of conventional types that al\u00adlow programmers to specify such properties. For example, Davies \nand Pfenning [6] show how to extend ML with in\u00adtersection types and domain-speci.c predicates, and Xi \nand Pfenning [39] popularized the use of singleton types. They also present compelling applications including \nstatic array\u00adbounds checking [38]. A separate research thread has shown how to use type\u00adand-e.ect to \ncheckproperties of programs involving state. These properties include safe region-based memory manage\u00adment \n[35], safe locking [11], and the correctness of correspon\u00addence assertions for communication protocols \n[15]. However, neither re.nement types nor the many type-and\u00ade.ect systems attempt to provide a general-purpose \nlogical frameworkfor reasoning about e.ectful computations. Xi and Pfenning s dependent type system and \nrelated work[8, 2, 5, 6] only seekto capture properties of values and pure computations, rather than \nproperties of e.ectful computa\u00adtions. For example, they are unable to describe protocols that require \ne.ectful functions to be used in a speci.ed or\u00adder. Therefore, these systems cannot be used to enforce \nimportant invariants such as the fact that a lockbe held before a data structure is accessed or that \na .le is opened before being read or closed. On the other hand, with few exceptions, type-and-e.ect systems, \nwhich clearly take state into account, have focused on applying the type-and-e.ect methodology to solve \nspeci.c problems, rather than on sup\u00adporting a parameterized theory and general-purpose logic for encoding \ndomain-speci.c program invariants. We propose a new system of type re.nements that al\u00adlows the programmer \nto reason about program values and state in a uni.ed manner, without being tied to a partic\u00adular problem \narea. A type re.nement combines a detailed description of the value produced by a computation with a \nformula describing the state of program resources after the computation s execution. The formula is written \nin a general logic for reasoning about state, whose atomic pred\u00adicates are determined by the programmer. \nWe extend our system to higher-order functions by including state pre-and post-conditions in re.nements \nof function types. Our workcan be seen as a continuation of earlier workon re.nement types, as well as \na general language in which to design and use type-and-e.ect systems. It also serves to pro\u00advide a semantic \nframeworkfor understanding practical work in this area such as the Vault programming language [7]. Overall, \nthe goal of our research is to provide a general, ro\u00adbust and extensible theory of type re.nements that \ncaptures sound techniques for local reasoning about program state. We describe the main contributions \nof our system below. A Two-Level System Based on Conservative Extension. We formalize the notion of a \ntype re.nement and construct a two level system for checking properties of programs. The .rst level involves \nsimple type checking and the second level introduces our logic of re.nements for reasoning about pro\u00adgram \nproperties that cannot be captured by conventional types. We establish a formal correspondence between \ntypes, which de.ne the structure of a language, and re.nements, which de.ne domain-speci.c properties \nof programs written in a language. Only Denney [8] has explicitly considered such a two level system \nin the past, but he restricted his attention to pure computations. We are careful to ensure that type \nre.nements are a con\u00adservative extension of types. In other words, type re.ne\u00adments re.ne the information \nprovided by the underlying, conventional type system rather than replace it with some\u00adthing di.erent. \nThe principle of conservative extension makes it possible for programmers to add type re.nements gradu\u00adally \nto legacy programs or to developing programs, to make these programs more robust. A Parameterized Theory. \nThe computational lambda cal\u00adculus [21] serves as our basic linguistic framework. We pa\u00adrameterize this \nbase language with a set of abstract base types, e.ectful operators over these types, and possible worlds. \nConsequently, our theorems hold for a very rich set of possi\u00adble e.ects and e.ectful computations. In \naddition, we have separated our central type-checking rules from the speci.cs of the logic of re.nements. \nOur theorems will hold for a variety of fragments of linear logic and we conjecture that similar substructural \nlogics can be used in its place with little or no modi.cation to the core system. Support for Local Reasoning. \nIt is essential thatitbe possible to focus attention on a single facet of program state without explicit \nreference to any others. For example, we may wish to reason about an I/O protocol separately from a locking \nprotocol or a state protocol. Moreover, we may wish to reason separately about two di.erent instances \nof the same state protocol. Formalisms based on classical logic are only sound for global reasoning about \nthe entire state of a program. Not only is this unworkable as a practical matter, it is incompatible \nwith modularity, which is essential for all but the simplest programs. To support modularity it is necessary \nto employ a logic for local reasoning about independent facets of a program s state [18, 27, 32]. Non-linear \nlogic does not permit local rea\u00adsoning, essentially because it validates the structural prin\u00adciples of \nweakening and contraction. Substructural logics, such as Linear Logic [14], or Bunched Implications (BI) \n[26, 18], do not validate these principles, and so are good candi\u00addates for a logic supporting local \nreasoning. We employ a fragment of linear logic that is adequate for many practical purposes. For local \nreasoning to be sound, the underlying e.ectful operators in the language must in fact act locally. More \nprecisely, we have identi.ed a crucial locality condition on ef\u00adfectful operators that is necessary for \nsoundness in the pres\u00adence of local reasoning. We have proven the soundness of re.nement checking in \nthe presence of this locality condi\u00adtion. The soundness of re.nement checking not only pro\u00advides a means \nfor checking certain correctness criteria, it also entails an optimization principle for e.ectful operators. \nA Decidable System of Type Re.nements. While we focus in this paper on a declarative presentation of \nour system of type re.nements, we have developed a decidable, algorith\u00admic re.nement-checking system \nand proven it both sound and complete. A key aspect of the algorithmic system is the introduction of \nre.nement annotations to the syntax of the language. These annotations allow the programmer to guide \nthe checker so that it may search for type-re.nement derivations in a deterministic fashion. A Semantics \nfor an Important Fragment of Vault. We provide a number of examples to demonstrate the expres\u00adsiveness \nof our system. Based on these examples, our re.ne\u00adments appear to subsume the state-logic used in the \nVault programming language [7] (although our idealized language does not contain the array of data structures \npresent in Vault, nor the specialized type-inference techniques). Hence, our system suggests a semantics \nfor an important fragment of Vault. A Simple Example: File Access Before digging in to the technical \ndetails of our framework, we present a simple example that introduces a number of important concepts. \nThe example revolves around enforc\u00ading a simple resource usage protocol for .le access and the following \ninterface de.nes the types of each operation over .les. fnew :String . File fopen :File . unit fclose:File \n. unit fwrite:(File, String). unit Informally, the protocol for using these operators requires that a \n.le must be open before being written or closed, and should be closed before the program terminates. \nHowever, the interface, as presented, has no way to enforce this pro\u00adtocol. We demonstrate this point \nwith a short function and use of that function that type checkbut do not meet the requirements of the \n.le interface. The key problem is that the function makes an informal assumption about its argu\u00adments \nand the assumption is not satis.ed before the function is used. The example is written in a syntax similar \nto that of Java. Note that header and footer are intended as strings de.ned elsewhere in the program. \n//fmustbeopen saveEntry(f:File, entry:String) : unit { fwrite(f, header); fwrite(f, entry); fwrite(f, \nfooter); } . . . File myFile = fnew( data.txt ); saveEntry(myFile, myString); // Error: f not open. To \naddress this type of problem, we begin by specializ\u00ading the .le interface with type re.nements that express \nthe access protocol mentioned above. fnew :(String; 1) -.[f : File](Its(f); closed(f)) fopen :(Its(f); \nclosed(f)) -(unit; open(f)) fclose:(Its(f); open(f)) . (unit; closed(f)) fwrite:(Its(f),String; open(f)) \n-(unit; open(f)) In the re.ned interface, the function arguments now have two components. The .rst component \nis either a re.ne\u00adment that corresponds to a conventional type or a more speci.c singleton type that \nspeci.es the exact value of the argument. The second component is a logical formula that describes the \nstate of the system. Function results also have two components, with the added detail that results can \nbe existentially quanti.ed, as is the case with fnew.Note that all re.nements are implicitly universally \nquanti.ed over the free variables in the re.nement. For example, fopen is im\u00adplicitly quanti.ed with \n.[f: File]. Two kinds of formulas appear in the example: predicates and the formula 1. As a precondition, \n1 states that the function requires, and therefore a.ects, none of the exist\u00ading state. As a postcondition \nit states that the function produces no state. We can now explain the re.ned interface. The operator \nfnew takes a String (the .le name) and requires no existing state. It returns some File object f and \nassures that f is initially closed. fopen takes a particular f and changes its state from closed to open. \nfclose does the reverse. Finally, fwrite requires that f be open, but does not change any state relating \nto f. Next, we add type re.nements to the saveEntry function and its use, and see how a re.nement checker \nwould catch the protocol violation. Notice how we can now formally checkwhat was previously an informal \nassumption. saveEntry(f:File, entry:String; open(f)): (unit; open(f)) { fwrite(f, header); // State: \nopen(f) fwrite(f, entry); // State: open(f) fwrite(f, footer); // State: open(f) } . . . File myFile \n= fnew( data.txt ); // State: closed(f) saveEntry(myFile, myString); // Error: closed(f) != open(f) Finally, \nwe .x the use of saveEntry by inserting a call to fopen in the appropriate place, as shown below: File \nmyFile = fnew( data.txt ); // State: closed(f) fopen(myFile); // State: open(f) saveEntry(myFile, myString); \n// State: open(f) Our logic of re.nements is much richer than the simple fragment we have used in this \nexample as it includes all of the multiplicative and additive connectives of linear logic and some restricted \nuses of the modality ! . For some more sophisticated examples, the reader may wish to skip ahead to section \n4. In the next section, we introduce our parameterized base language and its conventional type system \n(Section 2). In Section 3, we provide the syntax for general .rst-order re\u00ad.nements and provide a semantics \nfor world (state) re.ne\u00adments. Next, we give a declarative account of re.nement checking and discuss \nhow the declarative account is con\u00adverted to an algorithmic one. Finally, we show that our re.nements \nare a conservative extension of the underlying type system, state the main soundness theorems relating \nto our system and discuss how re.ned operators may be opti\u00admized. In the last section, we indicate our \ncurrent research directions and comment further on related work. Finally, due to space considerations, \nwe have omitted from this paper the proofs of our theorems as well as a number of details that were not \ncritical to the presentation of our work. Readers are encouraged to see our companion techni\u00adcal report \n[20] for complete details.  2. BASE LANGUAGE We use Moggi s computational .-calculus [21] as a ba\u00adsic \nlinguistic framework, as reformulated by Pfenning and Davies [29]. The frameworkis enriched with recursive \nfunc\u00adtions and a base type of booleans. In order to consider a variety of di.erent sorts of e.ects, we \nparameterize the lan\u00adguage by a collection of abstract types a, constants cwith type a and a set of multi-ary \noperators o over these abstract types. 2.1 Abstract Syntax The abstract syntax of the language is de.ned \nby the fol\u00adlowing grammar: Types A ::= a | Bool | A1 . A2 | A1 -A2 Var s X ::= x | y | ... Values V ::= \nX | c| true | false | .(X).M | fun X (X1:A1): A2 is E Terms M ::= V | if Mthen M1 else M2 | M(M1) Exp \ns E ::= M | o(M1,...,Mk) | let Xbe E1 in E2 end | app(M,M1) | if Mthen E1 else E2 The binding conventions \nare as expected; we identify ex\u00adpressions up to consistent renaming of bound variables. The type A1 . \nA2 is the type of pure functions, which always terminate without e.ect, and the type A1 -A2 is the type \nof impure functions, which may not terminate and may have an e.ect when applied. 2.2 Abstract Resources \nOur language is parameterized by a set of abstract, e.ect\u00adful operators, which manipulate some abstract \nresource or set of resources. We may reason about an instance of the language by specifying an interface \nfor and implementation of these operators and resources. In the future, we intend to extend our language \nwith a full-.edged module system and an internal means of de.ning new resources. We summarize the language \nparameters in Figure 1. An interface S de.nes a set of abstract types B,a set of con\u00adstants C, and a \nset of operators O. The interface also pro\u00advides a signature SA that gives types to the constants and \noperators. When we come to checking re.nements, we will do so with respect to a set of predicates P,an \ninterface Sp to specify the types of predicate arguments and .nally, a signature Sf to de.ne the re.nements \nof each constant or operator. An implementation M =(W,T ) de.nes a set W of worlds w, and a transition \nfunction T between these worlds that speci.es the behavior of the operators over constants of the appropriate \ntypes. Aworld w is a pair (Per(w),Eph(w)) where Per(w)is a set of persistent facts and Eph(w) is a multiset \nof ephemeral Interface Contents B Base Types Constant Names O Operator Names SA Constant and Operator \nTypes P Predicates Sp Predicate Types Sf Constant and Operator Re.nements Implementation Meaning W Worlds \nPer(w) w s Persistent Facts Eph(w) w s Ephemeral Facts T (o) o s Behavior Figure 1: Language Parameters \nfacts. The persistent facts of a world w will remain true in all worlds that can be reached through a \ncomputation starting with w. The ephemeral facts of a world may or may not hold in its future worlds. \nThe notation w1+w2 denotes a world containing the union of the persistent facts from w1 and w2, and the \nmulti-set union of ephemeral facts from w1 and w2. If an operator is given type a1,...,an -a by an interface, \nthen the transition function T (o) is a total function from a sequence of constants with types a1,...,an \nand world wto a ' constant with type a and world w.We use the symbol -to note that while these operators \nalways terminate, they may have e.ects on the world. We require that these functions act monotonically \non the persistent facts in the world. In ' other words, if T (o)(c1,...,cn; w)=(c; w)then Per(w) . ' \nPer(w). The transition function T (o)mustalso obeya locality condition. In general, it may only have \nan e.ect on a part of the world, rather than the entire world. Most operators that one would like to \nde.ne obey this locality condition. However, some useful operators do not. For example, in our system, \nprogrammers may not reason statically about a function such as gc(roots ), which deletes all resources \nexcept the resources referenced from the variable roots. We defer a formal explanation of this condition \nto Section 3.5 where we prove the soundness of re.nement checking. Example: File Access (continued). \nWe now consider pa\u00adrameterizing the language with the .le access primitives shown earlier in Section \n1. We require three base types: a type for .les File,for data String and the unit type unit. Our constants \ninclude a countable set of .le handles and data (we use metavariables f and d to range over each of these \nsets, respectively) and a unit value (). The signature SA provides the types for the operations and constants. \nT (fnew)((); w) =(f; w') where Eph(w')= Eph(w)+ {closed(f)} and f . Eph(w) T (fopen)(f; w) = ((); w') \nif w = w'' + {closed(f)} and Eph(w')= Eph(w'')+ {open(f)} T (fopen)(f; w) = ((); w) if w '' + {closed(f)} \n= w T (fclose)(f; w) = ((); w') if w = w'' + {open(f)} and Eph(w')= Eph(w'')+ {closed(f)} T (fclose)(f; \nw) = ((); w) if w '' + {open(f)} = w Figure 2: Transition Function of File Operators SA(()) = unit SA(f)= \nFile SA(d)= String SA(fnew)= unit -File SA(fopen)= File -unit SA(fclose)= File -unit SA(fwrite)=(File, \nString) -unit The set of predicates P is exactly the predicates closed and open from our earlier example. \nIn the implementation component, we must specify the set of worlds and the behavior of the operators. \nNotice that there are no persistent predicates, and so the persistent set of any world is always empty. \nHowever, once a .le f is initialized with a call to fnew,either open(f)or closed(f) will be in the ephemeral \nfacts any future world. Therefore, the W of the implementation is the countably in.nite set of worlds \nw,where Per(w)= \u00d8 and Eph(w) describes a set of .les that are all either open or closed, but not both. \nThe transition function T speci.es the dynamic semantics for each operator and is shown in Figure 2. \nNote that the side condition f . Eph(w) indicates that f does not appear in any of the predicates in \nEph(w) (i.e. f is fresh ). A key aspect of our de.nition of T is that each of the op\u00aderators are de.ned \nto be total functions on the entire domain of worlds. If they were not total functions we would be un\u00adable \nto prove a generic soundness theorem for our language. Later (see Section 3.7), we will prove an optimization \nprinci\u00adple that allows programmers to replace these total functions with the appropriate partial functions \nwhen their program has the necessary re.nement. 2.3 Semantics Since our base language semantics is almost \nentirely stan\u00addard, we merely state the forms of the various judgments. Complete details can be found \nin our companion technical report [20]. The static semantics is given by the following two judge\u00adment \nforms. G hM M : A Term M has type A in G G hE E : A Expression E has type A in G The meta-variable G \nranges over .nite functions from vari\u00adables x to types A. The dynamic semantics is given by the following \ntwo eval\u00ad b SA(c)= a or c:a .b uation judgements. bbb b fBool Bool b fa a b fIts(c) a M .V the term M \nevaluates to value V E@ w .V @ w ' in w the expression E evaluates to V and changes to w ' The following \nrule de.nes evaluation for e.ectful operators using the language parameter T. Mi .ci (for 1 =i=n) T(o)(c1,...,cn; \nw)= c ' ; w ' o(M1,...,Mn)@ w .c@ w ' (D-E-Op) Aside from this rule, the dynamic semantics is entirely \nstan\u00addard. The language as a whole satis.es the standard type safety theorem [20].  3. REFINEMENTS In \norder to de.ne and checkfurther, more speci.c, prop\u00aderties of values and computations than supported \nby the type system alone, we introduce a logic of re.nements that may be layered on top of the computational \nlambda calculus described in the previous section. 3.1 Syntax Our logic contains three classes of re.nements. \nA term re.nement is a predicate over a type, describing a more speci.c property of a term than a type \nalone. A world re\u00ad.nement is a formula describing the (implicit) state of a world. An expression re.nement \nis a predicate over both the type of an expression and the state of the world after the expression is \nexecuted. The table below describes the syntax of term, world and expression re.nements. Binding b ::= \nc:a Term Refs f ::= a |Bool |Its(c) |p Function Refs p ::= f1 .f2 |(f; .) -. |.b\u00b7p World Refs . ::= p(c1,...,cn) \n|!p(c1,...,cn) | 1 |.1 ..2 |.1 -.2 | T|.1 &#38; .2 |0 |.1 ..2 Expr. Refs . ::= .[bb](f; .) Since we are \nconcentrating on properties of e.ectful com\u00adputations, we have chosen a minimalist logic of term re.ne\u00adments. \nThere is a re.nement that corresponds to each type in the base language as well as singleton types denoted \nIts(c). Partial functions are re.ned in order to specify a precondi\u00adtion for the state of the world on \ninput and a postcondition consisting of an expression re.nement. The precondition for a partial function \ncould also have been an (existentially quanti.ed) expression re.nement, but this extension pro\u00advides \nno gain in expressive power. We allow function re\u00ad.nements to be pre.xed with .rst-order universal quanti.\u00adcation. \nThe world re.nements consist of the multiplicative-additive fragment of linear logic augmented with intuitionistic \npred\u00adicates !p(c1,...,cn). The connectives 1, .and -form the multiplicative fragment of the logic whereas \nthe connectives T,&#38;, 0,and . are known as the additives. Both . and &#38; are forms of conjunction. \nIntuitively, a world can be de\u00adscribed by the formula .1 ..2 if it can be split into two disjoint parts \nsuch that one part can be described by .1 and the other part can be described by .2. On the other hand, \na world satis.es .1&#38;.2 if it can be described by both bb ff1 A1 bb ff2 A2 bb ff1 A1 bb f.2 E A2 bb \nb ff1 .f2 A1 .A2 b f(f1; .1) -.2 A1 -A2 bb, c:a fp A bb ff A bb, c:a f.[bb1](f; .) E A bbbb b f.c:a \u00b7p \nAb f(f; .) E Ab f.[c:a,b1](f; .) E A Figure 3: A Re.nement of a Type .1 and .2 simultaneously. The formulas \n1 and T are the identities for . and &#38; respectively. The formula . is a disjunction and 0 is its \nidentity. When bb is the empty sequence in some expression re.ne\u00adment .[bb](f; .), we often use the abbreviation \n(f; .). We use the notation FV(f) to denote the set of free variables appearing in the term re.nement \nf. We use a correspond\u00ading notation for world and expression re.nements. We use the notation [c ' /b]X \nto denote capture-avoiding substitution of c ' for c in term or world re.nement X when b=(c:a)and SA(c \n' )= a. We extend this notation to substitution for a '' ' sequence of bindings as in [c1,...,cn/bb]X \nor [bb /bb]X.In ei\u00ad ther case, constants substituted for variables must have the correct type and the \nsequences must have the same length or else the substitution is unde.ned. We also extend substi\u00adtution \nto persistent and ephemeral contexts in the ordinary way. Every re.nement re.nes a particular type. To \nformalize this relationship, we de.ne two new judgments bb hf A and bb h. E A, which indicate that a \nterm or expression re.nement re.nes the type A given the set of bindings bb. Figure 3 de.nes these relations. \nBelow, we present a lemma stating that any re.nement re.nes a unique type. Lemma 1 If bbhf A1 and bb \nhf A2 then A1 = A2.  If bbh. E A1 and bb h. E A2 then A1 = A2.  Finally, for every type A, there is \na trivial re.nement triv(A) that re.nes it. triv(Bool)= Bool triv(a)= a triv(A1 .A2)= triv(A1) .triv(A2) \ntriv(A1 -A2)=(triv(A1); T) -(triv(A2); T) 3.2 Semantics of Re.nements We were inspired to de.ne a semantics \nfor our world re\u00ad.nements by the workof Ishtiaq and O Hearn [18]. The semantics appears in Figure 4. \nThe model (world) w used in the semantics is that described earlier in section 2.2. The fragment of the \nlogic without the modality ! is an instance of Simon Ambler s resource semantics [1, p. 30-32]. It relies \nupon an abstract relation ;which de.nes the relationship between primitive facts. For example, in a system \ncontain\u00ading arithmetic predicates such as less(x,y), the relation would include less(x,3) ;less(x,5). \nIn most of our examples, the w 1. if and only if . = p(c1,...,cn), Eph(w)= {X} and X .p(c1,...,cn) \n . =!p(c1,...,cn), X . Per(w)and X .p(c1,...,cn)and Eph(w)= \u00d8  . = 1 and Eph(w)= \u00d8  . = .1 ..2 and \nthere exist w1,w2, such that w = w1 + w2 and w1 1.1 and w2 1.2  . = .1 -.2 and for all worlds w1 such \nthat w1 1.1, w1 + w 1.2  . = T (and no other conditions need be satis.ed)  . = .1 &#38; .2 and w 1.1 \nand w 1.2  . = 0 and false (this re.nement can never be satis.ed).  . = .1 ..2 and either w 1.1 or \nw 1.2.  w 1.i. Per(w) . .. w 1\u00b7 i. Eph(w)= \u00d8. w 1.1,...,.n i. there exist w1,...,wn such that  w = \nw1 + \u00b7\u00b7\u00b7+ wn and  w1 1.1,...,wn 1.n.  w 1.;. i. w 1.and w 1.. Figure 4: Semantics of World Re.nements \nand Con\u00adtexts relation ;will simply be the identity relation. In other words, our predicates are usually \nleft uninterpreted. The semantics of world re.nements is extended to closed persistent contexts . (lists \nof predicates p(bc)) and ephemeral contexts . (lists of world re.nements), and appears in Fig\u00adure 4. \nWe treat both kinds of contexts as equivalent up to reordering of their elements.1 We will show later \nthat linear logical entailment is sound with respect to our semantics. However, as noted by Am\u00adbler [1, \np. 32], there is no sense in which linear logical rea\u00adsoning is complete with respect to this semantics. \nDespite this de.ciency, linear logic has proven to be very useful for many applications. We leave de.nition \nof a sound and com\u00adplete logic for our resource semantics to future work. 3.3 Declarative Re.nement-Checking \nIn this section, we give a declarative account of how to checkthat a (possibly open) term or expression \nhas a given re.nement. Re.nement checking of open terms will occur within a context of the following \nform. Whenever we con\u00adsider the semantics of re.nements or re.nement checking, we presuppose that the \nvalues, terms and expressions in ques\u00adtion are well-formed with an appropriate type. Persistent Ctxt \n.:: = \u00b7|.,c:a |.,x:f|.,p(bc) Ephemeral Ctxt .:: = \u00b7|.,. Furthermore, we de.ne a derivative form of context, \n.b to be a vector, bb, consisting of all elements in . of the form c:a. Persistent contexts are constrained \nso that the variables c and x appear at most once to the left of any : in the con\u00adtext and no variables \nc may shadow any of the constants in C. When necessary, we will implicitly alpha-vary bound 1When we \nextend . to open contexts which include constant declarations, reordering must respect the dependencies \nin\u00adtroduced by such declarations (see Section 3.3). fS ok Signature S is well-formed f. ok Context . \nis well-formed . f . ok Context . is well-formed in . . f f ok Re.nement f is well-formed in . . f . \nok World ref. . is well-formed in . . f . ok Expression ref. . is well-formed in . . \u00bbM M : f Term M \nhas re.nement f in . .; . \u00bbE E : . Expression E has ref. . in .; . ' ' .; f=.M f Term re.nement f entails \nf in . .; . =.W . Context . entails . in . ' ' .; .; . =.E . Expression ref. . entails . in .; . .; \n. (.i;.i)n Context .; . reduces to the context list (.i;.i)n in one step .; . * (.i;.i)n Context .; . \nreduces to the context list (.i;.i)n in 0 or more steps Figure 5: Re.nement-Checking Judgments variables \nto maintain this invariant. We treat contexts that di.er only in the order of the elements as equivalent \nand do not distinguish them (provided both contexts in question are well formed; in other words, reordering \nmust respect dependencies.). Occasionally, we call the persistent context unrestricted and the ephemeral \ncontext linear. Both contrac\u00adtion and weakening hold for the unrestricted context while neither of these \nstructural properties holds for the linear context. Declarative re.nement checking is formulated using \nthe judgment forms in Figure 5. All but the .rst judgment are implicitly parameterized by a .xed, well-formed \ninterface S. The .rst six judgments in the list are relatively standard. They simply checkthat each sort \nof type or context is well\u00adformed in the context .. This checkamounts to the fact that constants and \nvariables that appear in a type or context appear bound previously in the context or in the signature. \nThe formal rules appear in the technical report. The next two judgments form the heart of the system. \nThey checkterms and expressions to ensure that they have appropriate re.nements. The term re.nement-checking \nrules may be found in Figure 6. We point out a few impor\u00adtant details. In rule (R-T-Const) constants \nc are given very precise singleton types, following workby Xi and Pfen\u00adning [39]. Also, rule (R-T-TApp)does \nnot consider the case that the function in an application has a polymorphic re.nement. This possibility \nis taken care of by the (R-T-Sub) rule, which instantiates universal quanti.ers implicitly. Such instantiations \ncan be resolved by standard .rst-order uni.cation. Furthermore, rule (R-T-If) does not checkthat the \n.rst term M has a boolean re.nement, because we as\u00adsume that re.nement checking is preceded by ordinary \ntype checking. The expression re.nement-checking rules appear in Fig\u00adure 7. Rule (R-E-Term) de.nes the \ninterface between pure and e.ectful computations. As pure terms neither require nor produce state, they \nare checked in an empty ephemeral context and given the world re.nement 1. Weuse the(R-E-Sub) rule (discussed \nin more detail below) to properly check terms within a non-empty ephemeral context. The rule for checking \noperators requires that we guess a sequence of con\u00ad .,x: f \u00bbM x : f (R-T-Var) c.Dom(Sf) . \u00bbM c: Its(c) \n(R-T-Const) . \u00bbM true : Bool (R-T-True) . \u00bbM false : Bool (R-T-False) .b, bb ff1 A ., bb,x:f1 \u00bbM M : \nf2 ., bb ff1 ok (f = .bb\u00b7f1 .f2) . \u00bbM .(x:A).M : f (R-T-Lam) .b ffA1 -A . ff ok .,x:f,bb,x1:f1; .1 \u00bbE \nE : . (f = .b\u00b7(f1; .1) -.) b . \u00bbM fun x (x1:A1): Ais E : f (R-T-Fun) . \u00bbM M1 : f . \u00bbM M2 : f . \u00bbM if \nMthen M1 else M2 : f (R-T-If) . \u00bbM M : f1 .f2 . \u00bbM M1 : f1 . \u00bbM M(M1): f2 (R-T-TApp) ' . \u00bbM M : f .; \nf=.M f ' . \u00bbM M : f (R-T-Sub) Figure 6: Re.nement-Checking for Terms stants to substitute for the polymorphic \nparameters in the operator re.nement. Given this substitution, we checkthat operator arguments may be \ngiven re.nements equal to their corresponding formal parameter. There are three expression checking rules \nthat are not syntax-directed. (R-E-Sub) merits special attention as it is the key to local reasoning. \nThe rule splits the context into two disjoint parts, .1 and .2,where .1 is used to checkthe expression \nE,and .2 passes through unused. As a result, the computation may be written in ignorance of the total \nglobal state. It need only know how to process the local state in .1. In fact, in the case that .1 is \nempty, the computation may be completely pure. Additionally, (R\u00adE-Sub) serves as a conventional subsumption \nrule in which we checkthat one expression re.nement entails the other. (R-E-Cut) is the logical cut rule: \nIf we can prove some intermediary result (.) which in turn makes it possible to demonstrate our .nal \ngoal (E : .) then we should be able to prove our .nal goal from our original premises. Since . contains \nlinear hypotheses that must not be duplicated, we split the context into two parts .1 and .2, one part \nfor each premise in the rule. Finally, since proofs in substructural logics require careful manipulation \nof the context, we introduce a new rule (R-E-Context) to control context evolution during type check\u00ading. \nThis rule depends upon the judgment .; . .(.i;.i)n which encodes the action of all natural left rules \nfrom the sequent calculus for linear logic. The notation (.i;.i)n stands for a list of (possibly zero) \ncontexts (.1;.1), ..., . \u00bbM M : f .; \u00b7\u00bbE M :(f,1) (R-E-Term) . \u00bbM Mi :[bc/bb]fi (for 1 =i =n) (Sf(o)= \n.b\u00b7(f1,...,fn; .1) -.)b .; [bc/bb].1 \u00bbE o(M1,...,Mn):[bc/bb]. (R-E-Op) .; . \u00bbE E1 : .1 .,b1,x:f1; .1 \n\u00bbE E2 : .2 b (bb1 .FV(.2)) (.1 = .[bb1](f1; .1)) .; . \u00bbE let xbe E1 in E2 end : .2 (R-E-Let) . \u00bbM M \n:(f1; .1) -. . \u00bbM M1 : f1 .; .1 \u00bbE app(M,M1): . (R-E-PApp) .; . \u00bbE E1 : . .; . \u00bbE E2 : . .; . \u00bbE if Mthen \nE1 else E2 : . (R-E-If) .; . * (.i;.i)n .i;.i \u00bbE E : . (for 1 =i =n) .; . \u00bbE E : . (R-E-Context) .; \n.2 =.W . .; .1,. \u00bbE E : . .; .1,.2 \u00bbE E : . (R-E-Cut) .; .1 \u00bbE E : . .; .2; . =.E . ' .; .1,.2 \u00bbE E : \n. ' (R-E-Sub) Figure 7: Re.nement-Checking for Expressions (.n;.n). We speci.cally use the word reduces \nsince every valid judgment of this form reduces the number of connec\u00adtives in the context when read from \nleft to right. Most of the rules produce one context. However, the rule for dis\u00adjunction produces two \ncontexts (and E must have the same re.nement in both of them) and the rule for falsehood pro\u00adduces no \ncontext (and we can choose any well-formed expres\u00adsion re.nement for E without further checking). We \nextend the one-step context reduction judgment to its re.exive and transitive closure, which we denote \n.; . . * (.i;.i)n. The last .ve judgments involved in re.nement checking specify the logical component \nof the system. We have al\u00adready discussed the context reduction judgments. This judg\u00adment is combined \nwith the right rules from the sequent cal\u00adculus and the cut rule in the judgment .; . =.W . to provide \na full proof system for our fragment of linear logic. The judgment .; f =.M is the corresponding proof \nsys\u00ad f ' tem for term re.nements. Notice that these rules do not depend upon the linear context .. Since \nterms are pure, their re.nements should not depend upon ephemeral state. Finally, the judgment for expression \nre.nement entailment .; .; . =.E . ' combines the world and term proof systems with rules for existentials. \nThese judgments are formally de.ned in Figures 8, 9, 10 and 11. 3.4 Algorithmic Re.nement-Checking We \nhave developed an algorithmic re.nement-checking system that is both sound and complete with respect \nto the .; a =.M a (L-T-Base) .; Bool =.M Bool (L-T-Bool) .; Its(c)=.M Its(c) (L-T-Its) SA(c)= a or .(c)= \na .; Its(c)=.M a (L-T-ItsBase) ' '' .; f =.M f1 .; f2 =.M f . f f ok 1 21 '' .; f1 .f2 =.M f1 .f2 (L-T-TArr) \n'' ' .; f1 =.M f1 .; .1 =.W .1 .; \u00b7; . =.E . '' . ff ok . f . ok 11 '' ' .; (f1; .1) -. =.M (f1; .1) \n-. (L-T-PArr) ' .; [c ' /c:a]p =.M p ' .; .c:a \u00b7p =.M p (L-T-AllL) ' .,c:a; p =.M p ' .; p =.M .c:a \u00b7p \n(L-T-AllR) Figure 8: Entailment for Term Re.nements .; .,!p(c1,...,cn) .,p(c1,...,cn); . (CR-!) .; .,1 \n.; . (CR-1) .; .,.1 ..2 .; .,.1,.2 (CR-MAnd) .; .1 =.W .1 .; .1,.2,.1 -.2 .; .2,.2 (CR-Imp) .; .,.1 \n&#38; .2 .; .,.1 (CR-And1) .; .,.1 &#38; .2 .; .,.2 (CR-And2) .; .,0 (CR-Zero) .; .,.1 ..2 (.; .,.1),(.; \n.,.2) (CR-Or) .; . * .; . (CR*-Reflex) .;. (.j ;.j)m .j;.j * (.jk ;.jk )nj (for 1 =j = m) .; . * (.1k \n;.1k )n1 ,\u00b7\u00b7\u00b7 ,(.mk ;.mk )nm (CR*-Trans) Figure 9: Context Reduction and Its Closure .; . =.W . (L-E-Hyp) \n.,p(c1,...,cn); \u00b7=.W !p(c1,...,cn) (L-E-!R) .; \u00b7=.W 1 (L-E-1R) .; .1 =.W .1 .; .2 =.W .2 .; .1,.2 =.W \n.1 ..2 (L-E-MAndR) .; .,.1 =.W .2 . f.1 ok .; . =.W .1 -.2 (L-E-ImpR) .; . =.W T (L-E-TR) .; . =.W .1 \n.; . =.W .2 .; . =.W .1 &#38; .2 (L-E-AndR) .; . =.W .1 .; . =.W .1 ..2 (L-E-OrR1) .; . =.W .2 .; . =.W \n.1 ..2 (L-E-OrR2) .; . (.i;.i)n .i;.i =.W . (for 1 =i =n) .;. =.W . (L-E-Left) .; .2 =.W .1 .; .1,.1 \n=.W . .; .1,.2 =.W . (L-E-Cut) Figure 10: Entailment for World Re.nements '' .; f=.M f .; .,. =.W . '' \n.; .; (f; .)=.E (f ; . ) (L-ER-Base) .; .; . =.E [c ' /c:a].[bb](f; .) b .; .; . =.E .[c:a,b](f; .) \n(L-ER-ExistsR) .,c:a;.; .[bb](f; .)=.E . .; .; .[c:a,b](f; .)=.E . (L-ER-ExistsL) b Figure 11: Entailment \nfor Expression Re.nements system presented above. There is one typing rule for each expression or term \nconstruct and all premises in the rules are fully determined, except those of the context-reduction judgment. \nWe developed the system in two steps, outlined below. The .rst step is cut elimination. We eliminate \nthe two cut rules (the cut rule for expression re.nement-checking and the cut rule for linear logic entailment) \nand show that the resulting system is sound and complete with respect to the original re.nement-checking \nspeci.cation. We carry out the proof by modifying and extending the logical cut elimination proof in \nearlier workby Pfenning [28]. In the second step we eliminate the subsumption rule and introduce annotations \nin order to eliminate two criti\u00adcal sources of non-determinism present in the previous sys\u00adtem. The .rst \nsource is the non-syntax-directedness of the subsumption rule. We therefore incorporate the subsump\u00adtion \nrule into the language in a syntax-directed manner, and modify the expression rules so that the context-splitting \nof the subsumption rule is deterministic. The second source of non-determinism is the need for the re.nement-checker \nto guess the re.nement of a given term or expression when the re.nement cannot be deduced. We therefore \nintroduce type re.nement annotations into the lan\u00adguage, allowing the programmer to supply the checker \nwith the missing re.nement. In order to reduce the annotation burden, we have de.ned a bi-directional \nre.nement checking algorithm. The essence of this system is the introduction of two new re.nement-checking \njudgments: one for re.nement inference and one for re.nement checking. The former judg\u00adment infers a \nre.nement for the given term or expression and produces it as an output. The latter judgment takes a \nre.nement as input and checks the given term or expression against the re.nement. Our system also requires \na second form of annotation to guide the use of the context rule in expressions. Essentially, these annotations \nspecify when the re.nement-checker must use the disjunctive left rule, which, when applied, causes the \nannotated expression to be rechecked in two di.erent logical contexts. Rechecking the program text has \nthe potential to be very expensive, so we place this facility under the control of the programmer. For \na more detailed explanation of our type checking algorithm and full proofs of soundness and completeness \nwith respect to the declarative system, we refer the reader to our technical report [20]. The algorithmic \nre.nement-checking system is decidable modulo the three following aspects of the system: 1. Resolution \nof .rst-order existential variables. 2. Resource management. 3. Theorem proving in .rst-order MALL. \n These sources of nondeterminism do not cause the system to be undecidable, as each can be solved independently \n(and has in the past). First, resolution of .rst-order existential variables can be done via either explicit \ninstantiation or uni\u00ad.cation. Second, we must solve the resource, or context, management problem. This \nproblem includes the issue of deciding how to split a linear context into parts in multi\u00adplicative rules \nsuch as the .-right rule, (L-E-MAndR), and (R-E-Sub). There are several known approaches to e.\u00adcient \nresource management in linear logic [3]. Third, theo\u00adrem proving in the multiplicative-additive fragment \nof lin\u00adear logic (MALL) has been proven decidable [19]. However, while our system is decidable, .nding \nan e.cient decision procedure for all three of the above problems will be chal\u00adlenging. We believe that \nfurther investigation should be done in the setting of a practical implementation. 3.5 Soundness The \nproof of soundness of re.nement checking requires the following soundness condition on the primitive \noperators. Condition 2 (Soundness of Primitives) Suppose Sf(o)= .bb1 \u00b7((f1,1,...,f1,n; .1) ..[bb2](f2; \n.2)) If w ..; [bc1/bb1].1,and for 1 =i=n, . .M ci ' :[cb1/bb1]f1,i, '' '' and T(o)(c1,...,cn; w+ u)= \nc ; w then there exist . ' and cb2 such that 1. w ' = w '' + u; 2. . ' .M c ' :[cb2/bb2][cb1/bb1]f2; \n 3. w '' .. ' ;[cb2/bb2][cb1/bb1].2. 4. . .. '  Informally, this condition states that the operator \nmust be\u00adhave as predicted by its type re.nement, and, importantly, can have no e.ect on a part of the \nworld that is not speci.ed in the precondition of its re.nement. Above, w satis.es the precondition of \no s re.nement. Consequently, no extension, u, of the world may be modi.ed during the operation of o at \nworld w+ u. The following lemma expresses the relationship between our world semantics and logical judgments, \nstating that log\u00adical deduction respects the semantics of formulas. Lemma 3 (Soundness of Logical Judgments) \nIf w ..; . and .;. =.W . then w ... Finally, we may state and prove our re.nement preserva\u00adtion theorem. \nTheorem 4(Re.nement Preservation) 1. If . .M M : f and M .V then . .M V : f. 2. If .; . .E E : .[bb](f; \n.), w ..; .,and E@ w+ u . V @ w ' , then there exist . ' and bcsuch that . ' .M V :  ' '' '' [bc/bb]f, \nw = w + u, . .. ' and w .. ' ;[bc/bb].. The following canonical forms theorem expresses the prop\u00aderties \nof values that re.nement checking provides. Theorem 5 (Re.nement Canonical Forms) If \u00b7h V : A and . .M \nV : f (with . containing only bindings and predicates) then one of the following holds: 1. f= Bool and \nV = true or V = false; 2. f= Its(c) and V = c; 3. f= a, V = c and SA(c)= a; b  4. f= .b\u00b7f1 .f2 and \nV = .(x1:A1).M; b  5. f= .b\u00b7(f1; .1) -. and V = fun x(x1:A1): A2 is E.  3.6 Conservative Extension \nTo capture the notion that re.nements are a conservative extension of the type system, we present the \ntheorems below. The .rst theorem states that any re.nement given to a term (or expression) in our re.nement \nchecking system will always re.ne the type given to the term (or expression) in the type checking system. \nIn this theorem, we de.ne type(.) as the typing context G mapping all variables x .Dom(.) to the type \nre.ned by their re.nement in .. That is, if x:f .. and .b hfA then x:A .G. Theorem 6 If . .M M : f and \ntype(.) hM M : A then .b hfA. Similarly, if .; . .E E : . and type(.) hE E : A then .b h.A. The next \ntheorem states that for any well-typed term, M (or expression, E), with type A, there exists a re.nement\u00adchecking \nderivation for which M (E) has the trivial type asso\u00adciated with A. That is, any well-typed term (expression) \ncan also be shown to be well-re.ned. In this theorem, trivG(G) is de.ned as the persistent context mapping \nelements x .G to the trivial re.nement of their type in G. Also, trivS(SA) is de.ned as the re.nement \ninterface containing the trivial re.nements of the elements of SA. Theorem 7 If G hM M : A and Sf = trivS(SA) \nthen trivG(G) .M M : triv(A). Similarly, if G hE E : A and Sf = trivS(SA) then trivG(G); T.E E :(triv(A); \nT). 3.7 Optimization As well as helping programmers document and checktheir programs for additional \ncorrectness criteria, re.nements pro\u00advide language or library implementors with a sound opti\u00admization \nprinciple. When programs are checked to deter\u00admine their re.ned type, implementors may replace the to\u00adtal \nfunction, T(o), implementing operator o, with a partial function, T(o), that is only de.ned on the re.ned \ndomain given by the re.nement signature Sf. To be precise, we de.ne the optimized function T(o)as follows. \n T (o)(c1,...,cn; w)= T (o)(c1,...,cn; w) if Sf(o)= .bb\u00b7 (f1,...,fn; .) -., w 1.; [bc/bb]. and . \u00bbM ci \n:[bc/bb]fi for 1 = i = n T (o)(c1,...,cn; w) = unde.ned otherwise We use the notation . to denote the \noptimized evaluation of expressions with the transition function T replaced by T (that is, all operator \nimplementations replaced by their op\u00adtimized versions). We are able to prove that optimized and unoptimized \nevaluation are equivalent and therefore that it is safe for implementors to replace operator implementations \nwith their optimized version. Theorem 8 (Optimization) If .; . .E E : . and w ..; . then E @ w .V @ w \n' if and only if E @ w. V @ w ' .  4. EXAMPLES In this section, we provide a number of examples that \ndemonstrate the expressive power of our language. Our tech\u00adnical report presents several more examples \nincluding ML\u00adstyle integer references, alias types and recursion counts. We omit leading universal quanti.ers \nin our examples as they may easily be inferred in a manner similar to the way the Twelf system [30] infers \nleading quanti.ers. 4.1 File Access Modes We can extend our .le I/O example from the introduc\u00adtion by \ntracking the access modes of open .les and checking them before calling the read or write operators. \nWe add the following access modes to our signature and change open to a binary predicate over .le names \nand access modes. If open(f, a) is true at a particular program point, then .le f is open in access mode \na. r : Mode Read Access w : Mode Write Access rw : Mode Read and Write Access open :(File, Mode) .prop \nOpen Predicate  Below are the modi.ed fopen and fwrite operators as well as a new fread operator. The \nre.nement of fopen now captures the access mode a passed to fopen in the open predicate. In the re.nements \nof fread and fwrite, we let writeable(f)and readable(f) abbreviate open(f, w) . open(f, rw)and open(f, \nr) .open(f, rw), respectively. We use the &#38; connective in the re.nement of fread in order to simultaneously \nensure that f is readable before a call to fread and that whatever the access mode, it is preserved across \nthe call. The &#38; in the re.nement of fwrite serves a parallel purpose. fopen :(Its(f), Its(a); closed(f)) \n-(unit; open(f, a)) fread :(Its(f); open(f, a)&#38; readable(f)) \u00ad(String; open(f, a)) fwrite:(Its(f), \nString; open(f, a)&#38; writeable(f)) \u00ad(unit; open(f, a)) 4.2 File Buffering To demonstrate the utility \nof persistent predicates, we add to our original .le-I/O example support for layering a bu.er on top \nof a .le. We introduce three new predicates for this example: bfs(b, f) to indicate that a bu.er b bu.ers \na .le f; . and u. to conservatively estimate whether a bu.er is .ushed or un.ushed (that is, contains \nunwritten data). bfs :(Bu.er, File) .prop Bu.ers Relation . :(Bu.er) .prop Flushed Predicate u. :(Bu.er) \n.prop Un.ushed Predicate Correct use of a bu.er requires that the .le beneath the bu.er be open when \na program attempts to write to that bu.er and that the bu.er is .ushed before being freed. We enforce \nthe .rst requirement in two steps. First, upon cre\u00adating a new bu.er b over a .le f, we assert a persistent \nfact bfs(b, f), indicating that b bu.ers f. Next, when attempt\u00ading to write to a bu.er b,we checkthat \nb bu.ers some .le f and that f is open. As bfs is invariant over the lifetime of a given bu.er, it is \nnatural to represent it as a persistent fact. In addition, doing so allows us to reuse the fact with\u00adout \nexplicitly preserving it and forget about it once it is no longer needed. Below is the bu.er interface. \nCalling bnew on a .le f creates a new, .ushed bu.er over that .le. Calling bwrite on a bu.er b acts as \nexpected, but requires that the .le bu.ered by b be open, although b can be either .ushed or un.ushed. \nIn either case, we conservatively estimate that b is not .ushed upon return from bwrite. The operator \nbflush .ushes a bu.er, changing its state from u. to .. Finally, bfree takes a .ushed bu.er and frees \nit. bnew :(Its(f); 1) -.[b : Bu.er](Its(b); !bfs(b, f) . .(b)) bwrite:(Its(b); !bfs(b, f) . open(f) . \n(.(b) . u.(b))) \u00ad ((); open(f) . u.(b)) bflush:(Its(b); u.(b)) -((); .(b)) bfree :(Its(b); .(b)) -((); \n1) 4.3 Interrupt Levels For their study of Windows device drivers, DeLine and Fahndrich extend Vault \nwith a special mechanism for spec\u00adifying capability states which are arranged in a partial order [7]. \nThey use the partial order and bounded quanti.\u00adcation to specify preconditions on kernel functions. Here \nwe give an alternate encoding and reason logically about the same kernel functions and their preconditions. \nFirst, we assume a signature with abstract constants that correspond to each interrupt level and also \na predicate L over these levels. If L(c) is true at a particular program point then the program executes \nat interrupt level c at that point. pass : level Passive Level apc : level APC Level dis : level Dispatch \nLevel dirql : level DIRQL Level L : level . prop Level Predicate Next we consider a variety of kernel \nfunctions and their type re.nements. First, the KeSetPriorityThread function requires that the program \nbe at Passive Level when it is called and also returns in Passive Level. The function takes arguments \nwith type thread and pr, which we assume are de.ned in the current signature. KeSetPriorityThread: (thread, \npr; L(pass)) -(pr; L(pass)) Function KeReleaseSemaphore is somewhat more complex since it may be called \nin Passive, APC or Dispatch level and it preserves its level across the call. We let less(dis) abbreviate \nthe formula L(pass) . L(apc) . L(dis). KeReleaseSemaphore: (sem, pr, long; L(l) . (L(l) -less(dis))) \n-(pr; L(l)) Finally, KeAcquireSpinLock also must be called in one of three states. However, it returns \nin the Dispatch state and also returns an object representing the initial state (l)that the function \nwas called in. KeAcquireSpinLock: (sem, pr, long; L(l).(L(l) -less(dis))) -(Its(l); L(dis))  5. DISCUSSION \n5.1 Related Work A number of researchers have recently proposed strate\u00adgies for checking that programs \nsatisfy sophisticated safety properties. Each system brings some strengths and some weaknesses when compared \nwith our own. Here are some of the most closely related systems. Re.nement Types. Our initial inspiration \nfor this project was derived from workon re.nement types by Davies and Pfenning[6] and Denney [8] and \nthe practical dependent types proposed by Xi and Pfenning [38, 39]. Each of these authors proposed to \nsophisticated type systems that are able to specify many program properties well beyond the range of \nconventional type systems such as those for Java or ML. However, none of these groups considered the \nephemeral properties that we are able to specify and check. Safe Languages. CCured [24], CQual [13], \nCyclone [16], ESC [9, 12], and Vault [7, 10] are all languages designed to verify particular safety properties. \nCCured concentrates on showing the safety of mostly unannotated C programs; Cyclone allows programmers \nto specify safe stackand re\u00adgion memory allocation; ESC facilitates program debugging by allowing programmers \nto state invariants of various sorts and uses theorem proving technology to checkthem; and Vault and \nCQual make it possible to check resource usage protocols. Vault has been applied to veri.cation of safety \nconditions in device drivers and CQual has been applied to .nd locking bugs in the Linux kernel. One \nsigni.cant dif\u00adference between our workand the others is that we have chosen to use a general substructural \nlogic to encode pro\u00adgram properties. Vault is the most similar since its type system is derived from \nthe capability calculus [36] and alias types [34, 37], which is also an inspiration for this work. However, \nthe capability logic is somewhat ad hoc whereas we base our type system directly on linear logic. As \nfar as we are aware, the semantics of Vault has not been fully for\u00admalized. We hope this workis an e.ective \nstarting point in that endeavour. Igarashi and Kobayashi s resource usage analysis [17] is another piece \nof workin this vein. They de.ne a complex type system that keeps track of the uses of resources. They \nhave a general trace-based semantics as opposed to our possible worlds-style resource semantics. It is \ndi.cult to compare the expressive power of our two proposals precisely as the set of formulas involved \nis quite di.erent. They have some interesting modal operators and a recursion operator, but their logic \nis propositional whereas ours is .rst-order. Proof-Carrying Type Systems. Shao et al. [33] and Crary \nand Vanderwaart [4] have both developed powerful type lan\u00adguages that include a fully general logical \nframeworkwithin the type structure. Both languages were inspired by Nec\u00adula and Lee s workon proof carrying \ncode [23, 22] and are designed as a very general frameworkfor coupling low-level programs with their \nproofs of safety. In contrast, our lan\u00adguage is intended to be a high-level language for program\u00admers. \nHence, the design space is quite di.erent. Our spec\u00adi.cation language is less general than either of \nthese, but it does not require programmers to write explicit proofs that their programs satisfy the safety \nproperties in question. Moreover, neither of these logics contain the full complement of linear logic \ns left-asynchronous connectives (1, ., 0, ., .), which we .nd the most useful in our applications. Hoare \nLogic. Recent e.orts on the reasoning about point\u00aders in Hoare logic [18, 31] by Ishtiaq, O Hearn and \nReynolds, provided guidance in construction of our semantic model of re.nements. However, they use bunched \nlogic in their workwhereas we use a subset of linear logic. One impor\u00adtant di.erence between the logics \nis that linear logic con\u00adtains the modality !, which we use to reason about persistent facts. A notion \nof persistence seems essential to allow one to reason about values, which, by their nature, remain un\u00adchanged \nthroughout the computation. Also, since our work is based on type theory, it naturally applies to higher-order \nprograms, which is not the case for Hoare logic. Moreover, programmers who use Hoare logic have no automated \nsup\u00adport whereas our system has a decidable type checking al\u00adgorithm. 5.2 Future Work There are many \ndirections for future work. We have be\u00adgun to investigate the following issues. Our most immediate concern \nis the development of an implementation of the ideas presented in this paper. One of the authors (Mandelbaum) \nhas developed a preliminary implementation for small core subset of Java. The current implementation \nis built using Polyglot [25], an extensible compiler infrastructure for Java, and allows programmers \nto reason with a minimalist subset of the logic that includes 1, .and T. We are currently de\u00adveloping \na surface language based on ML that incorporates all of the features presented in this paper. One of \nthe limitations of the current proposal is the in\u00adability to checkthe membership of an ephemeral fact \nin the ephemeral context while preserving the other facts in that context. For example, consider a function \nwriteBoth that takes two .le arguments and writes to both of them. Below is a possible re.nement of such \na function: writeBoth : (Its(f), Its(g); open(f) .open(g)) \u00ad((); open(f) .open(g)) However, this re.nement \nprecludes the possibility that f and g are equal, as open(f) .open(g) describes two dis\u00adtinct facts. \nTherefore, writeBoth cannot be passed the same .le for both of its arguments. An alternative precondition, \n(open(f) .T)&#38;(open(g) .T), does not depend on the dis\u00adtinctness of f and g but fails to preserve \ninformation about the remaining members of the ephemeral context, due to the imprecision of T. One solution \nto this problem would be to provide a way to view an ephemeral fact as temporarily persistent, as we \ncan checkthe membership of a fact in the persistent con\u00adtext while preserving the remaining persistent \nfacts. Then, we could successfully checkcalls to writeBoth with aliased arguments based on the following \nre.nement: writeBoth : (Its(f), Its(g); !open(f) .!open(g)) -((); 1) We are investigating a sharing principle, \nsimilar to the world-splitting allowed by the subsumption rule, that would provide a safe method of viewing \nephemeral facts as tem\u00adporarily persistent. An alternative solution would be to add a limited form of \nsecond-order quanti.cation to the logic. We could then re.ne writeBoth as follows: writeBoth : (Its(f), \nIts(g); (open(f) .T)&#38;(open(g) .T)&#38; w) \u00ad((); w) In essence, the re.nement checks that open(f)and \nopen(g) are members of the world w, while ensuring that w is pre\u00adserved. The next item of interest to \nus is the encoding of type-and\u00ade.ect systems in our language. We believe that our language provides a \ngeneral frameworkin which to encode many type\u00adand-e.ect systems. Based on the encoding shown above, we \nhave devised a translation from a variant of a well-known type-and-e.ect system concerning locktypes \nfor static en\u00adforcement of mutual exclusion [11], into our language (ex\u00adtended with second-order quanti.cation). \nWe thereby show that our re.nements are at least as powerful. Our transla\u00adtion also helps us understand \nthe connection between types and e.ects and recent research on sophisticated substruc\u00adtural type systems \nsuch as the one implemented in Vault [7]. Finally, our language is parameterized by a single inter\u00adface \nand implementation that enables us to consider reason\u00adingabout avariety of di.erent sortsofe.ects. The \nnext step in the development of this project is to extend the language with an advanced module system \nthat allows programmers to de.ne their own logical safety policies and to reason com\u00adpositionally about \ntheir programs. Acknowledgments David Walker would like to thank Frank Pfenning for teach\u00ading him about \nthe structure of linear logic without Frank s instruction, it would have been impossible to write this \npa\u00adper. We would like to thank Nate Nystrom, Michael Clark\u00adson and Andrew Myers, the implementers of \nPolyglot [25], for giving us access to their software. Polyglot dramatically increased the speed at which \nwe were able to develop a pre\u00adliminary implementation of our ideas for Java. We are also very grateful \nto Dan Grossman, who gave us some impor\u00adtant feedbackon an earlier draft of this paper. Finally, we would \nlike to thank the anonymous reviewers for their help\u00adful comments. In particular, we thankthem for bringing \nto our attention the writeBoth example, discussed in the previous section.  6. REFERENCES [1] Simon \nAmbler. First-order Linear Logic in Symmetric Monoidal Closed Categories. PhD thesis, University of Edinburgh, \n1991. [2] Leonart Augustsson. Cayenne a language with dependent types. In ACM International Conference \non Functional Programming, pages 239 250, Baltimore, September 1999. ACM Press. [3] Iliano Cervesato, \nJoshua S. Hodas, and Frank Pfenning. E.cient resource management for linear logic proof search. In Proceedings \nof the Fifth International Workshop on Extensions of Logic Programming ELP 96, pages 67 81, Leipzig, \nGermany, March 1996. [4] Karl Crary and Joe Vanderwaart. An expressive, scalable type theory for certi.ed \ncode. In ACM International Conference on Functional Programming, Pittsburgh, October 2002. ACM Press. \n [5] Karl Crary and Stephanie Weirich. Flexible type analysis. In ACM International Conference on Functional \nProgramming, pages 233 248, Paris, September 1999. [6] Rowan Davies and Frank Pfenning. Intersection \ntypes and computational e.ects. In ACM International Conference on Functional Programming, pages 198 \n208, Montreal, September 2000. ACM Press. [7] Rob Deline and Manuel F\u00a8ahndrich. Enforcing high-level \nprotocols in low-level software. In ACM Conference on Programming Language Design and Implementation,pages \n59 69, Snowbird, Utah, June 2001. ACM Press. [8] Ewen Denney. A Theory of Program Re.nement.PhD thesis, \nUniversity of Edinburgh, Edinburgh, 1998. [9] David L. Detlefs. An overview of the extended static checking \nsystem. In The First Workshop on Formal Methods in Software Practice, pages 1 9. ACM(SIGSOFT), January \n1996. [10] Manuel F\u00a8ahndrich and Rob Deline. Adoption and focus: Practical linear types for imperative \nprogramming. In ACM Conference on Programming Language Design and Implementation, pages 13 24, Berlin, \nJune 2002. ACM Press. [11] Cormac Flanagan and Martin Abadi. Types for safe locking. In S.D. Swierstra, \neditor, Lecture Notes in Computer Science, volume 1576, pages 91 108, Amsterdam, March 1999. Springer-Verlag. \nAppeared in the Eighth European Symposium on Programming. [12] Cormac Flanagan, Rustan Leino, Mark Lillibridge, \nGreg Nelsonand James Saxes, and Raymie Stata. Extended static checking for java. In ACM Conference on \nProgramming Language Design and Implementation, Berlin, June 2002. ACM Press. [13] Je.rey Foster, Tachio \nTerauchi, and Alex Aiken. Flow-sensitive type quali.ers. In ACM Conference on Programming Language Design \nand Implementation, Berlin, June 2002. ACM Press. [14] Jean-Yves Girard. Linear logic. Theoretical Computer \nScience, 50:1 102, 1987. [15] Andrew Gordon and Alan Je.rey. Typing correspondence assertions for communication \nprotocols. In Mathematical Foundations of Programming Semantics 17. Elsevier, 2001. [16] Dan Grossman, \nGreg Morrisett, Trevor Jim, Michael Hicks, Yanling Wang, and James Cheney. Region-based memory management \nin cyclone. In ACM Conference on Programming Language Design and Implementation, Berlin, June 2002. ACM \nPress. [17] Atsushi Igarashi and Naoki Kobayashi. Resource usage analysis. In ACM Symposium on Principles \nof Programming Languages, pages 331 342, Portland, Oregon, January 2002. ACM Press. [18] Samin Ishtiaq \nand Peter O Hearn. BI as an assertion language for mutable data structures. In Twenty-Eighth ACM Symposium \non Principles of Programming Languages, pages 14 26, London, UK, January 2001. [19] Patrick Lincoln and \nAndre Scedrov. First-order linear logic without modalities is NEXPTIME-hard. Theoretical Computer Science, \n135:139 154, 1994. [20] Yitzhak Mandelbaum, David Walker, and Robert Harper. An e.ective theory of type \nre.nements. Technical Report TR-656-02, Princeton University, December 2002. [21] Eugenio Moggi. Notions \nof computation and monads. Information and Computation, 93:55 92, 1991. [22] George Necula. Proof-carrying \ncode. In Twenty-Fourth ACM Symposium on Principles of Programming Languages, pages 106 119, Paris, 1997. \n[23] George Necula and Peter Lee. Safe kernel extensions without run-time checking. In Proceedings of \nOperating System Design and Implementation, pages 229 243, Seattle, October 1996. [24] George C. Necula, \nScott McPeak, and Westley Weimer. Ccured: Type-safe retro.tting of legacy code. In ACM Symposium on Principles \nof Programming Languages, London, January 2002. ACM Press. [25] Nathaniel Nystrom, Michael Clarkson, \nand Andrew C. Myers. Polyglot: An extensible compiler framework for java. In 12th International Conference \non Compiler Construction, April 2003. to appear. [26] Peter O Hearn and David Pym. The logic of bunched \nimplications. Bulletin of Symbolic Logic, 5(2):215 244, 1999. [27] Peter O Hearn, John C. Reynolds, and \nHongseok Yang. Local reasoning about programs that alter data structures. In CSL 01, pages 1 19, Paris, \n2001. [28] Frank Pfenning. Structural cut elimination in linear logic. Technical Report CMU-CS-94-222, \nDepartment of Computer Science, Carnegie Mellon University, December 1994. [29] Frank Pfenning and Rowan \nDavies. A judgmental reconstruction of modal logic. Mathematical Structures in Computer Science, 11(4):511 \n540, 2001. [30] Frank Pfenning and Carsten Sch\u00a8urmann. system description: Twelf a metalogical framework \nfor deductive systems. In H. Ganzinger, editor, Proceedings of the 16th International Conference on Automated \nDeduction, number 1632 in LNAI, pages 202 206, Trento, Italy, July 1999. Springer-Verlag. [31] John C. \nReynolds. Intuitionistic reasoning about shared mutable data structure. In Millennial perspectives in \ncomputer science, Palgrove, 2000. [32] John C. Reynolds. Separation logic: A logic for shared mutable \ndata structures. In Symposium on Logic in Computer Science 02, pages 55 74, 2002. [33] Zhong Shao, Bratin \nSaha, Valery Trifonov, and Nikolaos Papaspyrou. A type system for certi.ed binaries. In ACM Symposium \non Principles of Programming Languages, London, January 2002. ACM Press. [34] Frederick Smith, David \nWalker, and Greg Morrisett. Alias types. In European Symposium on Programming, pages 366 381, Berlin, \nMarch 2000. [35] Mads Tofte and Jean-Pierre Talpin. Region-based memory management. Information and Computation, \n132(2):109 176, 1997. [36] David Walker, Karl Crary, and Greg Morrisett. Typed memory management in a \ncalculus of capabilities. ACM Transactions on Programming Languages and Systems, 22(4):701 771, May 2000. \n[37] David Walker and Greg Morrisett. Alias types for recursive data structures. In Workshop on Types \nin Compilation, Montreal, September 2000. [38] Hongwei Xi and Frank Pfenning. Eliminating array bound \nchecking through dependent types. In ACM Conference on Programming Language Design and Implementation,pages \n249 257, Montreal, June 1998. [39] Hongwei Xi and Frank Pfenning. Dependent types in practical programming. \nIn Twenty-Sixth ACM Symposium on Principles of Programming Languages, pages 214 227, San Antonio, TX, \nJanuary 1999.  \n\t\t\t", "proc_id": "944705", "abstract": "We develop an explicit two level system that allows programmers to reason about the behavior of effectful programs. The first level is an ordinary ML-style type system, which confers standard properties on program behavior. The second level is a conservative extension of the first that uses a <i>logic of type refinements</i> to check more precise properties of program behavior. Our logic is a fragment of intuitionistic linear logic, which gives programmers the ability to reason <i>locally</i> about changes of program state. We provide a generic resource semantics for our logic as well as a sound, decidable, syntactic refinement-checking system. We also prove that refinements give rise to an optimization principle for programs. Finally, we illustrate the power of our system through a number of examples.", "authors": [{"name": "Yitzhak Mandelbaum", "author_profile_id": "81100175667", "affiliation": "Princeton University, Princeton, NJ", "person_id": "PP14071519", "email_address": "", "orcid_id": ""}, {"name": "David Walker", "author_profile_id": "81100426485", "affiliation": "Princeton University, Princeton, NJ", "person_id": "PP18001632", "email_address": "", "orcid_id": ""}, {"name": "Robert Harper", "author_profile_id": "81100140064", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39029370", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944725", "year": "2003", "article_id": "944725", "conference": "ICFP", "title": "An effective theory of type refinements", "url": "http://dl.acm.org/citation.cfm?id=944725"}