{"article_publication_date": "08-25-2003", "fulltext": "\n eDuce: An XML-Centric General-Purpose Language V\u00e9ronique Benzaken Giuseppe Castagna Alain Frisch LRI, \n(CNRS) CNRS, D\u00e9partement d Informatique D\u00e9partement d Informatique Universit\u00e9 Paris-Sud \u00c9cole Normale \nSup\u00e9rieure \u00c9cole Normale Sup\u00e9rieure 91405 Orsay, France 45 rue d Ulm, Paris, France 45 rue d Ulm, Paris, \nFrance Veronique.Benzaken@lri.fr Giuseppe.Castagna@ens.fr Alain.Frisch@ens.fr Abstract. We present the \nfunctional language eDuce, discuss some design issues, and show its adequacy for working with XML docu\u00adments. \nDistinctive features of eDuce are a powerful pattern match\u00ading, .rst class functions, overloaded functions, \na very rich type sys\u00adtem (arrows, sequences, pairs, records, intersections, unions, dif\u00adferences), precise \ntype inference for patterns and error localization, and a natural interpretation of types as sets of \nvalues. We also out\u00adline some important implementation issues; in particular, a dispatch algorithm that \ndemonstrates how static type information can be used to obtain very ef.cient compilation schemas. Categories \nand Subject Descriptors: D.3.0 [Programming Lan\u00adguages]: General; D.3.2 [Programming Languages]: Language \nClassi.cations Applicative (functional) languages General Terms: Languages Keywords: XML, XML-processing, \ntype systems, CDuce 1. Introduction eDuce is a general purpose typed functional programming lan\u00adguage, \nwhose design is targeted to XML applications. The work on eDuce started two years ago from an attempt \nto overtake some limitations of XDuce [11] following three directions: Type system. XDuce demonstrates \nthe adequacy of some spe\u00adci.c features (regular expression types and type-based patterns) to XML applications, \nbut we believe that these features could be integrated in a less speci.c language. Indeed, as the interface \nbe\u00adtween a XDuce-like language and a mainstream language neces\u00adsarily looses most of the type information, \nwe aim at minimizing the interactions between eDuce and external languages by allow\u00ading to de.ne complex \napplications directly in eDuce. To this end, we extended XDuce type system by introducing less XML speci.c \ntype constructions: products, records, general Boolean connectives (union, intersection, difference), \nand arrow types (.rst-class functions), continuing and prolongating the se\u00admantic approach to de.ne subtyping \nthat was initiated by XDuce. On a practical side, we implemented a type-checker that gives precise localization \nof error messages and exhibits samples to demonstrate type checking failure.  Language design. We added \nlanguage constructions that we be\u00adlieve to be useful for XML or general purpose processing such as overloaded \nfunctions (to allow code sharing and code reuse), iter-  Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. ICFP 03, August 25 29, 2003, Uppsala, Sweden. \nCopyright 2003 ACM 1-58113-756-7/03/0008 ...$5.00. ators on sequences and trees and several extensions \nof the pattern algebra (in particular to allow extraction of non-consecutive sub\u00adsequences). We studied \nprecise typing for these constructions. We also made several small design decisions that turn out to \nbe very practical. For instance, XML tags are eDuce .rst-class ex\u00adpressions (which allows computing on \ntags), and strings are noth\u00ading but sequences of characters (this allows the use of regular ex\u00adpression \ntypes and patterns on strings; also, when concatenating two sequences containing characters and XML elements, \nthe two strings at the boundary are automatically concatenated). Run-time system. We tackled the problem \nof executing eDuce programs ef.ciently. The key issue is the implementation of pat\u00adtern matching. To \nthis end, we use a new kind of deterministic tree automata which is a combination of top-down and bottom-up \nautomata, and we developed a compilation schema (from patterns to automata) that uses static type information \nto avoid unneces\u00adsary computation at runtime. This allows the programmer to use a much more declarative \nstyle in patterns without degrading per\u00adformances. This article focuses on language design, shows its \nadequacy to write applications that handle, transform, and query XML documents, and sketches solutions \nto implementation issues. To keep the presen\u00adtation short, we just present some highlights of the language. \nThe homepage for eDuce, http://www.due.org/, includes other references, an online interactive prototype \n(where the reader can test eDuce and check all the examples presented here), a user s manual, many eDuce \nprograms (larger and more compelling than the ones presented here), and the eDuce distribution (the whole \nsite is gener\u00adated by a 330-loc eDuce program that transforms the XML content description into XHTML: \nthe complete source code is included in the eDuce distribution). Theoretical foundations of the eDuce \ns type system can be found in [8]. Related Work The closest work to ours is, of course, XDuce from which \neDuce borrows many key features, such as, among others, regular expres\u00adsion types, type-based pattern \nmatching, the semantic inclusion of XML types, the type inference for patterns, the use of recursive \npat\u00adterns. The previous section mentions in which directions the work on eDuce extends XDuce. Since the \ncore de.nition of eDuce was published in [8] both languages evolved in parallel. Independently from us, \nHaruo Ho\u00adsoya implemented in XDuce the support for exact typing of non\u00adtail variables, by using a different \napproach based on automata [10]. Together with Makoto Murata [13] he also de.ned and extended XDuce types \nto handle XML attributes in a quite different way from the one we de.ned for eDuce (i.e., extensible \nrecords). We believe that the expressive power of the two solutions is comparable, but Hosoya and Murata \ns solution is able to express compactly depen\u00addencies between attributes and elements (while we have \nto expand those dependencies using union types), and they addressed algorith\u00admic issues to avoid exponential \nexplosion. However, their algorithm for evaluating a pattern on a sequence uses a .rst rewriting pass \non the automaton, which requires fully materializing this automaton and does not seem compatible with \nour current ef.cient compilation al\u00adgorithm (likewise, Hosoya had to remove pattern optimization from \nXDuce to incorporate the new attribute support). The ongoing work on XDuce has a constant in.uence on \nours and some of our future plans include adapting to eDuce some of Hosoya s insightful ideas on sequence \ntransformations. eDuce is not the only project that started from or was deeply in\u00ad.uenced by XDuce. Among \nthe projects inspired by XDuce those closest to eDuce are Xtatic [9] and XQuery [3, 7]. The goals for \nXtatic and eDuce are similar in that they both try to integrate XDuce features in a larger design and \nless XML-speci.c language. eDuce builds on the functional .avour of XDuce and extends it to a full-.edged \nfunctional language, whereas Xtatic goes toward OO principles and combines XDuce types with the class \nhier\u00adarchy of a host language, namely C#. The integration of XDuce and C# in Xtatic is smooth and elegant \nboth on the language side (thanks to the introduction of a special Seq class, and a clever treatment \nof the concatenation) and on the implementation side (by resorting to an encoding technique reminiscent \nof Pizza s homogeneous transla\u00adtion [16]). Xtatic and eDuce both have to face the problem of com\u00adbining \nXDuce s semantic de.nition of subtyping with a richer type algebra. Xtatic s solution is simpler as it \nrelies on named typing for C# classes, where eDuce has to tackle classical issues when dealing with set-theoretic \ninterpretation of arrow types. On a less theoreti\u00adcal side, eDuce and Xtatic share many design decisions, \nincluding syntactic choices and small decisions mentioned in the Introduction such as .rst-class XML \ntags and strings as sequences of characters. eDuce and Xtatic designs also have noticeable differences; \namong them is that in eDuce we avoid the strati.cation of the type algebra between XML types and non-XML \ntypes and this permits the use of pattern matching also for non-XML data structures (such as pairs or \nrecords). For what concerns implementation issues Levin studied ef.cient pattern matching implementation \nfor Xtatic [15]. He con\u00adcentrates on the de.nition of a generic kind of matching automata and target \nlanguage suitable as back-ends for pattern matching. Our work is quite orthogonal, as we focus on optimization \nmade possi\u00adble by static type information. It should be possible to express our compilation algorithm \nin term of their matching automata. As for expressivity, our algorithm supports in addition ambiguous \npatterns (disambiguated with .rst match policy), non-linear capture variables (even when under repetition \noperators), and XML attributes (imple\u00admented as records in eDuce). XQuery is mainly aimed at performing \nqueries on XML docu\u00adments. Since the XQuery type system took its inspiration from XDu\u00adce s one, it is \nnot surprising to .nd a lot of similarities with eDuce. To perform queries XQuery adds to XDuce a for \nloop (which can be simulated by eDuce s transform iteration on sequences) as well as support for XPath, \nwhile it removes complex pattern matching with regular expression patterns and, recently, structural \ntyping (re\u00adplaced by named typing as in XML Schema [17], so as to avoid tree automata to check subtyping \nor validate documents). Support\u00ading XPath s upward axis yields a copy semantics which is unusual in functional \nlanguages: when an element is created in XQuery, its content has to be copied, while in eDuce, an XML \nsubtree can be shared by different documents. The rapidly growing importance of XML has given rise to \nmany other works related to XML processing. Due to lack of space, we decided to focus only on the projects \nclosest to eDuce. For an overview of other works and a thorough comparison of these with the XDuce/eDuce \napproach we refer the reader to [11]. 2. A sample session Let us write and comment on a sample eDuce \nprogram. First, we declare some types1: type ParentBook = <parentbook>[Person*] type Person = FPerson \n| MPerson type FPerson = <person gender=\"F\">[ Name Children (Tel | Email)*] type MPerson = <person gender=\"M\">[ \nName Children (Tel | Email)*] type Name = <name>[ PCDATA ] type Children = <children>[Person*] type Tel \n= <tel kind=?\"home\"|\"work\">[ 0 -- 9 + - ? 0 -- 9 +] type Echar = a -- z | A -- Z | _ | 0 -- 9 type Email= \n<email>[ Echar+ ( . Echar+)* @ Echar+ ( . Echar+)+ ] The type ParentBook describes XML documents that \nstore informa\u00adtion of persons. A tag <tag attr1=...; attr2=...; ...> followed by a sequence type denotes \nan XML document type. Sequence types classify ordered lists of heterogeneous elements and they are denoted \nby square brackets [...]that enclose regular expressions over types (note that a regular expression over \ntypes is not a type, it just de\u00adscribes the content of a sequence type, therefore if it is not enclosed \nin square brackets it is meaningless). The de.nitions above state that a ParentBook element is formed \nby a possibly empty sequence of persons. A person is either of type FPerson or MPerson accord\u00ading to \nthe value of the gender attribute. An equivalent de.nition for Person would thus be: <person gender=\"F\"|\"M\">[ \nName Children (Tel | Email)*]. A person element is composed of a sequence formed by a name element, a \nchildren element, and zero or more telephone and e-mail elements, in this order. Name elements contain \nstrings. These are encoded as sequences of characters. The PCDATA keyword is equiv\u00adalent to the regexp \nChar*, then String, [Char*], [PCDATA], [PCDATA* PCDATA], ..., are all equivalent notations. Children \nare composed of zero or more Person elements. Telephone elements have an optional (as indicated by =?) \nstring attribute whose value is either home or work and they are formed by a single string of two non-empty \nsequences of numeric characters separated by an optional dash char\u00adacter. Had we wanted to state that \na phone number is an integer with at least 5 digits (of course this is meaningful only if no phone number \nstarts with 0) we would have used an interval type as in <tel kind=?\"home\"|\"work\">[10000--*], where * \nhere denotes +0. Echar is the type of characters in e-mail addresses. It is used in the regular expression \nde.ning Email to precisely constrain the form of the ad\u00addresses. An XML document satisfying these constraints \nis shown in the left column of Figure 1. If the document is stored in the .le parents.xm1, it can be \nloaded with the built-in operator load__xml, assigned to a local variable par\u00adents, and immediately checked \nto be of the ParentBook type: let parents = match (load_xml \"parents.xml\") with I(x &#38; ParentBook) \n-> x I_ -> raise \"Wrong type!\" When this declaration is entered interactively the system answers: |-parents \n: ParentBook which indicates that the type checker remembers that parents is of type ParentBook. To obtain \nit, the value resulting from the load op\u00aderation is matched against the pattern x &#38; ParentBook. The \n&#38;-pattern denotes the simultaneous application of two sub-patterns and it suc\u00adceeds if both sub-patterns \ndo. In our example the value is matched against the variable x which always succeeds and binds the value \nto x and against the type ParentBook which succeeds only if the value has the given type. If the &#38;-pattern \nfails (i.e., if the result of the load is not of type ParentBook), then the value is matched against \nthe pattern _ which always succeeds ( _ denotes the type of all values, 1(Duce distribution includes \ndtd2cduce, a program that can be used to trans\u00adlate DTDs into (Duce s types. Support for XML Schema validation \nhas been recently implemented and is in alpha testing (see \u00a7 6). <?xml version=\"1.0\"?> <parentbook> <person \ngender=\"F\"> <name>Clara</name> <children> <person gender=\"M\"> <name>P\u00e5l Andr\u00e9</name> <children/> </person> \n</children> <email>clara@lri.fr</email> <tel>314-1592654</tel> </person> <person gender=\"M\"> <name> Bob \n</name> <children> <person gender=\"F\"> <name>Alice</name> <children/> </person> <person gender=\"M\"> <name>Anne</name> \n<children> <person gender=\"M\"> <name>Charlie</name> <children/> </person> </children> </person> </children> \n<tel kind=\"work\">271828</tel> <tel kind=\"home\">66260</tel> </person> </parentbook> let parents : ParentBook \n= <parentbook>[ <person gender=\"F\">[ <name>\"Clara\" <children>[ <person gender=\"M\">[ <name>[ P\u00e5l Andr\u00e9 \n] <children>[] ] ] <email>[ clara@lri.fr ] <tel>\"314-1592654\" ] <person gender=\"M\">[ <name>\"Bob\" <children>[ \n<person gender=\"F\">[ <name>\"Alice\" <children>[] ] <person gender=\"M\">[ <name>\"Anne\" <children>[ <person \ngender=\"M\">[ <name>\"Charlie\" <children>[] ] ] ] ] <tel kind=\"work\">\"271828\" <tel kind=\"home\">\"66260\" \n] ] Figure 1: XML and eDuce so every value matched against it succeeds) and raises an exception (this \ncould be caught by a try...with... construction). The right column in the .gure above represents the \nbinding of the variable parents to the same document written directly as a eDuce value. The type annotation \n(... : ParentBook) is optional, but, in general, it allows an earlier detection of type errors. Sequence \nvalues are denoted by the list of elements enclosed in square brackets and separated by blank spaces. \nFor the purpose of the example we used different notations to denote strings since in eDuce \"xyz\", [ \nxyz ], [ x y z ], [ xy z ], and [ x yz ] de.ne the same string literal (see \u00a73.2). Note also that \nthe \"P\u00e5l Andr\u00e9\" string is accepted since eDuce supports Unicode characters. A .rst example of transformation \nis names, which extracts the sequences of all names of parents in a ParentBook element: let names (ParentBook \n-> [Name*]) <parentbook>x -> (map x with <person>[ n _*] -> n) The name of the transformation is followed \nby an interface that states that names is a function from ParentBook elements to (possi\u00adbly empty) sequences \nof Name elements. This is obtained by match\u00ading the argument of the function against the pattern <parentbook> \nx which binds x to the sequence of person elements forming the par\u00adentbook. The operator map applies \nthe transformation de.ned by the subsequent pattern matching to each element of a sequence (in this case \nx). Here map returns the sequence obtained by replacing each person in x by its Name element. Note that \nwe use the pattern <per\u00adson>[ n __*] to match the person elements: n matches (and captures) the Name \nelement that is, the .rst element of the sequence , __* matches (and discards) the sequence of elements \nthat follow, and <person> matches the tag of the person (although the latter contains an attribute). \nThe interface and the type de.nitions ensure that the tags will be the expected ones, so we could optimize \nthe code by de.ning a body that skips the check of the tags: <__> x -> (map x with <__>[ n __*] -> n). \nHowever this optimization would be useless since it is already done by the implementation (see \u00a7 5) and, \nof course, it would make the code less readable. If instead of extracting the list of all parents we \nwanted to extract the sublist containing only parents with exactly two children, then we had to replace \ntransform for map: let names2 (ParentBook -> [Name*]) <parentbook> x -> transform x with <person>[ n \n<children>[Person Person] _*] -> [n] While map must be applicable to all the elements of a sequence, \ntransform .lters only those that make its pattern succeed. The right\u00adhand sides return sequences which \nare concatenated in the .nal re\u00adsult. In this case transform returns the names only of those persons \nthat match the pattern <person>[ n <children>[Person Person] __*]. Here again, the implementation compiles \nthis pattern exactly as <__>[ n<__>[____] __*], and in particular avoids checking that sub-elements of \n<children> are of type Person when static-typing enforces this property. These .rst examples already \nshow the essence of eDuce s pat\u00adterns: all a pattern can do is to decompose values into subcompo\u00adnents \nthat are either captured by a variable or checked against a type. The previous functions return only \nthe names of the outer persons of a ParentBook element. If we want to capture all the name elements in \nit we have to recursively apply names to the sequence of children: let names (ParentBook -> [Name*]) \n<parentbook> x -> transform x with <person> [ n <children>c _*] -> [n]@(names <parentbook>c) where @ \ndenotes the concatenation of sequences. Note that in order to recursively call the function on the sequence \nof children we have to include it in a ParentBook element. A more elegant way to obtain the same behavior \nis to specify that names can be applied both to ParentBook elements and to Children elements, that is, \nto the union of the two types denoted by (ParentBook|Children): let names ( ParentBook|Children -> [Name*] \n) <_>x -> transform x with <person>[ n c _*] -> [n]@(names c) Note here the use of the pattern <__> at \nthe beginning of the body which makes it possible for the function to work both on ParentBook and on \nChildren elements. In all these functions we have used the pattern __* to match, and thus discard, the \nrest of a sequence. This is nothing but a particular regular expression over types. Type regexps can \nbe used in patterns to match subsequences of a value. For instance the pattern <per\u00adson>[ ____ Tel+] \nmatches all person elements that specify no Email element and at least one Tel element. It may be useful \nto bind the se\u00adquence captured by a (pattern) regular expression to a variable. But since a regexp is \nnot a type, we cannot write, say, x&#38;Tel+.So we introduce a special notation x::Rto bind x to the \nsequence matched by the type regular expression R. For instance: let domain (Email->String) <_>[ _*? \nd::(Echar+ . Echar+) ] -> d returns the last two parts of the domain of an e-mail (the *? is an ungreedy \nversion of *, see \u00a73.6 ). If these ::-captures are used inside the scope of the regular expression operators \n*or +, or if the same variable appears several times in a regular expression, then the vari\u00adable is bound \nto the concatenation of all the corresponding matches. This is one of the distinctive and powerful characteristics \nof eDuce, since it allows to de.ne patterns that in a single match capture sub\u00adsequences of non-consecutive \nelements. For instance: type PhoneItem = {name = String; phones = [String*]} let agendaitem (Person -> \nPhoneItem) <person>[<name>n _ (t::Tel | _)*] -> { name = n ; phones = map t with <tel> s ->s } transforms \na person element into a record value with two .elds con\u00adtaining the element s name and the list of all \nthe phone numbers. This is obtained thanks to the pattern (t::Tel | __)* that binds to t the sequence \nof all Tel elements appearing in the person. By the same rationale the pattern (w::<tel kind=\"work\">__ \n| t::<tel kind=?\"home\">__ | e::<email>__)* partitions the (Tel | Email)* sequence into three subsequences, \nbind\u00ading the list of work phone numbers to w, the list of other numbers to t, and the list of e-mails \nto e. Alternative patterns | follow a .rst match policy (the second pattern is matched only if the .rst \nfails). Thus we can write a shorter pattern that (applied to (Tel | Email)* se\u00adquences) is equivalent: \n(w::<tel kind=\"work\">__ | t::Tel | e::__)*. Both patterns are compiled into (w::<tel kind=\"work\">__ | \nt::<tel>__ | e::__)*, since checking the tag suf.ces to determine if the element is of type Tel. Storing \nphone numbers in integers rather than in strings requires minimal modi.cations. It suf.ces to use a pattern \nregular expression to strip off the possible occurrence of a dash: let agendaitem2 (Person -> {name=String; \nphones=[Int*]}) <person>[ <name>n _ (t::Tel|_)* ] -> { name = n; phones = map t with <tel>[(s:: 0 -- \n9 |_)*] -> int_of s } In this case s extracts the subsequence formed only by numerical characters, therefore \nint__of s cannot fail because s has type [ 0 -- 9 + ] (otherwise, the system would have issued a warning)2. \nConsider the type PhoneBook = <phonebook>[PhoneItem*].If we add a new pattern matching branch in the \nde.nition of the function names, we make it work both with ParentBook and PhoneBook ele\u00adments. This yields \nthe following overloaded function: let names3 (ParentBook -> [Name*] ; PhoneBook->[String*]) I<parentbook> \nx -> map x with <person>[ n _* ] -> n I<phonebook> x -> map x with { name=n } -> n The overloaded nature \nof names3 is expressed by its interface, which states that when the function is applied to a ParentBook \nelement it returns a list of names, while if applied to a PhoneBook element it returns a list of strings. \nWe can factorize the two branches in a unique alternative pattern: let names4 (ParentBook -> [Name*] \n; PhoneBook->[String*]) <_>x->mapxwith(<person>[n _*]|{name=n})->n The interface ensures that the two \nrepresentations will never mix. 3. Presentation of the eDuce language 3.1 The type algebra eDuce type \nalgebra has no speci.c constructor for sequences and regular expression types. The constructions we used \nin the previ\u00adous section are encoded, as shown in \u00a73.2, in the core type algebra formed by the following \ntypes: three native scalar types, Int, Char, and Atom (atoms are symbolic constants of the form idwhere \nidis an arbitrary identi.er) and two type constants Empty and Any (the latter is also written , especially \nin patterns) that denote respectively the empty (i.e., the smallest) and the universal (i.e., the largest) \ntype;  types constructors: record types {a1=t1;...;an=tn}, prod\u00aduct types (t1,t2), functional types \n(t1->t2), and XML types <t1t2>t3(where t1,t2,t3specify respectively the possible tags, attribute sets, \nand element contents);  Boolean connectives: intersection t1&#38; t2, union t1| t2and differ\u00adence t1\\ \nt2;  singleton types: for any scalar or constructed (non-functional) value v, vis itself a type (for \ninstance, nil denotes the type of empty sequences, while 18 is the type of the integer 18);  2Actually \nthe type system deduces for s the following type [ 0 -- 9 + 0 -- 9 +] (subtype of the former) since there \nalways are at least two digits. recursive types: they are de.ned by recursive toplevel declara\u00adtions \nor by the syntax Twhere T1= t1and ... and Tn = tn, where Tand Ti s are type identi.ers (that is, identi.ers \nstarting by a capital letter). In eDuce, types have a set-theoretic interpretation: a type is the set \nof all values (i.e. closed irreducible expressions: roughly, expres\u00adsions that are neither applications, \nnor .eld selections, nor matching expressions; sometimes we use the word result instead of value ) that \nhave that type. For example, the type (t1,t2)is the set of all expressions (v1,v2)where viis a value \nof type ti; similarly t1 >t2 is the set of all closed functional expressions funf(s1;...;sn)e that have \ntype t1 >t2. This interpretation of types is the basis of eDuce type system: the programmer must rely \non it to understand all the type constructions and type equivalences of the system. For example, the \ndifference of two types contains all the values that are contained in the .rst type but not in the second, \nthe union of two types is formed by all the values of each type, and the intersection of, say, an arrow \nand a record is equivalent to (in the sense that it has the same interpretation as) the empty type. In \nparticular, subtyping is just set inclusion: a type is a subtype of another if the latter contains all \nthe values that are in the former (for more details see [8]). Records. There are two different kinds \nof record types: the open record type, denoted by {a1=t1;...;an=tn}, that classi.es records in which \nthe .elds labeled aiare present with the prescribed type, but other .elds may also appear, and the closed \nrecord type, denoted by {Ia1=t1;...;an=tnI}, which forbids any label other than the ai s 3. It is also \npossible (both for open and for closed record types) to specify optional .elds: the syntax ai=?tistates \nthat the ai.eld may be absent, but when it is present, it must have type ti. There is a lot of natural \nsubtyping and equivalence relations that hold for record types, like for instance {Ia=tI}:{a=t},or {a1=t1;a2=t2}:{a1=t1}&#38;{a2=t2},or \n{Ia1=t1;a2=?t2I}: {Ia1=t1I}I{Ia1=t1;a2=t2I}, where : :; once more, they all can be deduced from the set \ntheoretic interpretation of record types as sets of record values. Scalars. We took special care of \nthe de.nition and implementation of scalar types: integers have arbitrary precision (we believe that \nin XML ap\u00adplications, it is more important to have exact results than to optimize intensive numerical \ncomputations), and Char represents the whole Unicode character set. Moreover, we have subtypes of Int \nand Char, namely intervals of the form i--jwhere i,jare two integer literals or two character literals, \naccordingly. We can specify for instance that the month attribute of some XML element is an integer between \n1 and 12.  3.2 Encoded types Sequences. As in Lisp, sequences are encoded by pairs and an atom nil repre\u00adsenting \nthe empty sequence: a sequence of values v1v2...vnis written in eDuce as [v1v2...vn], but actually this \nis syn\u00adtactic sugar for (v1,(v2(...,(vn, nil)...))). 3There is a subtlety about singleton record types. \nFor instance, the type {x= 3}, being open, contains all the records that have .eld x=3 and maybe other \n.elds too. The singleton type corresponding to the value {x=3} must be written {| x = 3 |}. We have chosen \nthe same notation for record values and open record types because we believe that open record types are \nmuch more useful in programming than closed ones. In the sample section we saw that regular expressions \non types can be used to de.ne new sequence types. Once more, this is just syntactic sugar since the sequence \ntypes are, in reality, de.ned by combining Boolean type connectives and recursive types. For in\u00adstance, \nthe [Int*] type used in the function agendaitem2 is de.ned as T where T = (Int,T) | nil. Strings. Although \nstrings are nothing but a special case of sequences, the intensive use of this datatype in XML documents \nmakes them worth special care. The main design choice we made for strings is to not have String as a \nnative basic type; it is encoded as [Char*]. This seemed to us necessary for dealing with real world \nXML documents where strings often alternate with XML (e.g. XHTML) elements (simply consider <i> this \n</i> example). Having String as a basic type would be problematic, because no automatic concatenation \nwould be performed.4 Instead, by considering strings as sequences of charac\u00adters, [ simply consider \n<i>[ this ] example ] is equivalent to [ simply consider <i>[ this ] example ] (both equivalent to the \nsequence with all characters separated). Of course, for sequences formed only by character literals, \nwe allow the more classical double quote notation (values of XML attributes often fall into this case). \nWe paid special attention to the implementation of strings for which we use a com\u00adpact representation \nas long as possible and convert it to a sequence of characters only when necessary, and always transparently \nto the user (see \u00a75).  3.3 XML elements Although in eDuce the type <t1t2>t3is primitive and the ti s \ncan range over all types, in practice, when working with XML doc\u00aduments, t1is usually an atom, t2a record \ntype, and t3a sequence type. Thus XML types are conceptually encoded in terms of atoms, records and pairs \nand their introduction as a new type constructor is only justi.ed by the need to avoid possible interferences. \nThat said, it is still important to notice that the type system does not restrict the possible values \nin tag position to being atoms. For in\u00adstance, it is possible to use pairs to simulate namespaces; the \nnames\u00adpace could be denoted by another atom (namespace normalization), or by a string (namespace URI): \n<( xhtml, li)>[ ] or <(\"http://...\", li)>[ ], and although the introduction of some syntax speci.c to \nnamespaces is surely needed5, in its current de.nition eDuce can already handle XML namespaces. An XML \nelement, <tag a1=v1...an =vn>elem-seq </tag>,is written in eDuce as <tag {a1=v1;...;an =vn}>[elem-seq]. \nWhen appearing in tags, the back-quote of atoms and the curly brackets of records may be omitted: <a \nhref=\"click.htm\"; target=\"__top\">[ Click here ] We applied this convention to all the examples of the \nsample session (the same notations apply to types as shown by the same examples). An XML element construction \nhas three \"holes\": the tag, the at\u00adtribute record, and the content although they can actually be .lled \nwith any arbitrary expression, as in: let tag = a in let link = { href = \"...\" } in let c = \"Click\" in \n<(tag) (link)>c or as in the two following functions let del_target (Link -> Link) <t (r)>x -> <t (r\\ \ntarget)>x let add_target (Link -> Link) <t (r)>x -> <t (r+{target= \"__top\"})>x 4This is a classical problem: \nXML parsers do not usually guarantee that text nodes represent maximal textual portions of the documents; \nthey are free to split adjacent characters into several text nodes 5In the next version of (Duce we plan \nto introduce a speci.c notation such as <xhtml:li>[ ], and adapt XML primitives (load__xml,...) to be \nnamespace\u00adcompliant. that respectively remove and add some target attribute to an HTML element (r\\ eremoves \nthe e.eld from r, if any, while r+r'denotes the destructive addition of the .elds of r'to those of r). \nIt is possible to restrict the authorized attribute names by using a closed record type instead of the \ndefault open type; for instance, an element of type type Tel2 = <tel {| kind=?\"home\"|\"work\" |}>[ 0 -- \n9 + - ? 0 -- 9 +] may only have a kind attribute and no other. Similarly we can also specify that a speci.c \nattribute must be absent: type TelNokind = <tel kind=?Empty>[ 0 -- 9 + - ? 0 -- 9 +] which can be read: \nwhenever the attribute kind is present, its value must be of type Empty ; as there is no such value, \nthis means that the attribute kind cannot be present. 3.4 Overloaded functions The simplest form for \na toplevel function declaration is let j(t->s)x->e in which the body of a function is formed by a single \nbranch x->e of pattern matching. As we have seen in the previous sections, the body of a function may \nbe formed by several branches with complex patterns. The interface (t->s)speci.es a constraint on the \nbehavior of the function to be checked by the type system: when applied to an argument of type t, the \nfunction returns a result of type s. In general the interface of a function may specify several such \nconstraints, as the names3 example (\u00a72). The general form of a toplevel function declaration is indeed: \nlet fun j(t1->s1;...;tn->sn)Ip1->e1I...Ipm->em (the .rst vertical bar and the fun keyword are optional). \nSuch a function accepts arguments of type (t1I...Itn); it has all the types ti->si, and, thus, it also \nhas their intersection (t1->s1&#38;...&#38;tn->sn). The use of several arrow types in an interface serves \nto give the function a more precise type. We can roughly distinguish two differ\u00adent uses of multiple \narrow types in an interface: 1. when each arrow type speci.es the behavior of a different piece of code \nforming the body of the function, the compound interface serves to specify the overloaded behavior of \nthe function. This is the case for the function below let add ( (Int,Int)->Int ; (String,String)->String \n) | (x &#38; Int, y &#38; Int) -> x+y | (x &#38; String, y &#38; String) -> x@y where each arrow type \nin the interface refers to a different branch of the body. 2. when the arrow types specify different \nbehavior for the same code, then the compound interface serves to give a more precise descrip\u00adtion of \nthe behavior of the function. An example is the function names4 from \u00a72. There is no clear separation \nbetween these two situations since, in general, an overloaded function has body branches that specify \nbe\u00adhaviors of different arrow types of the interface but share some com\u00admon portions of the code. Let \nus examine a more complex example. We want to transform the representation of persons introduced in \u00a72, \nusing different tags <man> and <woman> instead of the gender attribute and, conversely, using an attribute \ninstead of an element for the name. We also want to distinguish the children of a person into two different \nsequences, one of sons, composed of men (i.e. elements tagged by <man>), and the other of daughters, \ncomposed of women. Of course we also want to apply this transformation recursively to the children of \na person. In practice, we want to de.ne a function split of type Person >(Man | Woman) where Man and \nWoman are the types: type Man = <man name=String>[ Sons Daughters ] type Woman = <woman name=String>[ \nSons Daughters ] type Sons = <sons>[ Man* ] type Daughters = <daughters>[ Woman* ] Here is a possible \nway to implement such a transformation: let split (MPerson -> Man ; FPerson -> Woman) <_ gender=g>[ <_>n \n<children>[(mc::MPerson | fc::FPerson)*] _*] -> let tag = match g with \"F\" -> woman | \"M\" -> man in let \ns = map mc with x -> split x in let d = map fc with x -> split x in <(tag) name=n>[ <sons>s <daughters>d \n] The function split is declared to be an overloaded function that, when applied to a MPerson, returns \nan element of type Man and that, when applied to a FPerson, returns an element of type Woman. The body \nis composed of a single pattern matching whose pattern binds four variables: g is bound to the gender \nof the argument of the function, n is bound to its name, mc is bound to the sequence of all children \nthat are of type MPerson, and fc is bound to the sequence of all chil\u00addren that are of type FPerson. \nOn the next line we de.ne tag to be man or woman according to the value of g. Then we apply split recursively \nto the elements of mc and fc. Here is the use of overload\u00ading: since mc is of type [MPerson*], then by \nthe overloaded type of split we can deduce that s is of type [Man*]; similarly we deduce for d the type \n[Woman*]. From this the type checker deduces that the expressions <sons>s and <daughters>d are of type \nSons and Daugh\u00adters, and therefore it returns for the split function the type (MPerson -> Man) &#38; \n(FPerson -> Woman). Note that the use of overloading here is critical: although split also has type Person \n->(Man | Woman) (since split is of type MPerson->Man &#38; FPerson->Woman, which is a subtype), had we \ndeclared split of that type, the function would not have type-checked: in the recursive calls we would \nhave been able to deduce for s and for d the type [ (Man | Woman)* ], which is not enough to type-check \nthe result. If, for example, we wanted to de.ne the same transformation in XDuce we would need .rst to \napply a .l\u00adter (that is our transform) to the children so as to separate male from females (while in \neDuce we obtain it simply by a pattern) and then resort to two auxiliary functions that have nearly the \nsame de.nition and differ only on their type, one being of type MPerson > Man, the other of type FPerson \n> Woman. The same transformation can be elegantly de.ned in XSLT with a moderate nloc increase, but only \nat the expense of loosing static type safety and type based optimization: see Section 5 for preliminary \nbenchmarks. 3.5 Higher-order functions In eDuce all functions, including the overloaded ones, are .rst \nclass expressions. This means that a function can be fed to or re\u00adturned by a so-called higher-order \nfunction. The syntax for a lo\u00adcal function is the same as a toplevel function declaration, that is fun \nj(t1->s1;...;tn->sn)..., the only difference being that jcan be omitted if the function is not recursive. \nNote that, using subtyp\u00ading, such a function can be used wherever a function of type, say t1-> s1or t1&#38;tn-> \ns1&#38;sn, is expected. Higher-order functions improve code reusability by sharing com\u00admon code and providing \nspecialized parts as functional arguments. In the setting of XML applications, a typical use would be \nto param\u00adeterize a generic printing function (that displays documents of some DTD to XHTML) by providing \nspecialized functions to print various subparts of the documents (for instance, one of these functions \ncould be in charge of displaying dates in a format chosen by the user). Another use of .rst-class functions \nwe have in mind (and we are going to implement) is a web application server that runs eDuce scripts. \nInstead of producing XHTML pages, the scripts would gen\u00aderate a variant of XHTML with eDuce code replacing \n<input> ele\u00adments. For instance, instead of <input type=submit ...>, the scripts would directly generate \na function (seen as a .rst class value) that has to be triggered when the user clicks on the button; \nthis function can use identi.ers bound to form-.elds as normal eDuce variables. The web application server \nwould transform this pseudo-XML doc\u00adument with embedded eDuce functions to a real XML document before \nsending it to the client, and storing in its internal tables the eDuce functions to be called. At the \nnext HTTP request, it would call the function corresponding to the button the user pressed. The advantage \nof such an approach is twofold: thanks to static typing we know that the value handled by the transformation \nhas the correct type and, more importantly, the web administrator no longer has to maintain CGI programs \nconsistent with the HTML pages since this is already done by the server. This example demonstrates the \nuse of .rst-class functions embedded in XML documents, in particular it addresses the same problems as \n(and for some aspects it extends) the JWIG approach [5]. The latter uses XML templates, that is, valid \ndocuments embedded with gaps that are to be .lled by other templates (whereas we propose to embed higher \norder function or any other eDuce expression), and relies on global data .ow analy\u00adsis to statically \nenforce both the validity of the generated XHTML and the correspondence between generated forms and received \n.elds (whereas we plan to use the current eDuce s type system to check it). Since the advantages of higher-order \nprogramming are well-known to the functional programming language community (and space is limited) we \nwill not elaborate further. The lack of .rst-class func\u00adtions in XML languages has been identi.ed in \nseveral papers [12, 7] and our semantic approach to subtyping [8] has succeeded in mixing classical arrow \ntypes and XML types. 3.6 Pattern matching Pattern matching is one of eDuce s key features. Although \nit re\u00adsembles ML s, it is much more powerful, as it allows one to express in a single pattern a complex \nprocessing that can dynamically check both the structure and the type of the matched values. We already \nsaw examples of pattern matching forming the body of a function declaration. As in ML, in eDuce there \nis a standalone pattern-matching expression match ewith p1->e1| ... | pn->en. Lo\u00adcal binding let p=e1in \ne2is just syntactic sugar for match e1with p-> e2 A pattern either matches or rejects a value; when it \nmatches, it binds its capture variables to the corresponding parts of the value and the computation continues \nwith the body of the branch. Other\u00adwise, control is passed to the next branch. This is a simple descrip\u00adtion \nof the behavior of pattern matching, but the actual implementa\u00adtion uses less naive and more ef.cient \nalgorithms to simulate it. For instance, we designed an algorithm that uses a single (partial) traver\u00adsal \non the value to dispatch on the correct branch, and bene.ts from static typing information to avoid redundant \nchecks (see \u00a75). Capture variables and deconstructors. As in ML, a variable, say x, is a pattern that \naccepts and binds every value to x. A pair pattern (p1,p2)accepts every value of the form (v1,v2)where \nvimatches pi. If a variable x appears both in p1and in p2, then each pattern pibinds x to some value \nvi'; the se\u00admantics is here to bind the pair (v1' ,v2' )to x for the whole pattern. For instance, a pattern \nmatching branch (x,(y,x)) -> (x,y) is equivalent to (x1,(y,x2)) -> ((x1,x2),y). Similarly (x,(x,(y,x))) \n-> (x,y) is equiva\u00adlent to (x1,(x2,(y,x3))) -> ((x1,(x2,x3)),y). More interesting examples showing the \nexpressiveness of this construction in the presence of recursive patterns will be presented later in \nthis paper. Record patterns are of the form {a1=p1;...;an =pn}and {Ia1=p1;...;an =pnI}: the former matches \nevery record with at least the .elds aiwhose content matches piwhile the latter matches records formed \nexactly by the ai.elds and whose content matches pi. We use the same convention that we used for types \nand allow omitting curly brackets for open records occurring in tags. However, contrary to pair patterns, \nwe do not allow multiple occurrences of a variable in a record pattern. Type constraint and conjunction. \nEvery type can be used as a pattern. The semantics of such a pattern is to accept only values of that \ntype and creates no bind\u00ading.6 This is particularly useful because in eDuce a type may re.ect precise \nconstraints on the values (structure and content). Note that scalar constants can also be used as patterns, \nas they are a special case of type constraints with singleton type. The wild-card type __ is simply \nan alternative notation for the type constant Any and as such it matches every value. To combine a type \nconstraint and a capture variable, one can use the conjunction operator &#38; for patterns, as in (x \n&#38; Int). The seman\u00adtics of the conjunction in a pattern is to check both sub-patterns and merge their \nrespective sets of bindings. Since the two patterns of a conjunction must have disjoint sets of capture \nvariables, no con.ict can arise during the merging. Alternative and default value. There is also an \nalternative (disjunction) operator p| qwith .rst match policy: it .rst tries to match the pattern p, \nand if it fails, it tries with q; the two patterns must have the same set of capture variables. Alternative \npatterns are often used in conjunction with the pattern (x := c), where c is an arbitrary scalar or constructed \nconstant, which provides a default value for a capture variable. Recursive patterns. Recursive patterns \nuse the same syntax as recursive types: Pwhere P1=p1and ... and Pn =pnwith PP1...Pnbeing variables rang\u00ading \nover pattern identi.ers (i.e. identi.ers starting by a capital letter). Recursive patterns allow one \nto express complex extraction of infor\u00admation from the matched value. For instance, consider the pattern \nP whereP =(x&#38;Int, _ )|(__,P); it extracts from a sequence the .rst element of type Int (recall that \nsequences are encoded with pairs). The order is important, because the pattern P where P = (__, P) | \n(x &#38; Int, __) extracts the last element of type Int. A pattern may also extract and reconstruct a \nsubsequence, using the convention described before that when a capture variable appears on both sides \nof a pair pattern, the two values bound to this variable are paired together. For instance, P whereP=(x&#38; \nInt, P)| (__, P)| (x := nil) extracts all the elements of type Int from a sequence (x is bound to the \nsequence containing them) and the pattern P where P = (x &#38; Int, (x &#38; Int, _ ))|(__, P) extracts \nthe .rst pair of consecutive integers. Regular expression patterns. eDuce provides syntactic sugar for \nde.ning patterns working on sequences with regular expressions built from patterns, usual regular expression \noperators, and sequence capture variables of the form x::R(where Ris a pattern regular expression). 6Conversely, \nevery pattern without capture variables is a type, which moti\u00advated our choice to use the same notation \nfor constructors common to types and patterns. For instance, the term (1,2) in a pattern position can \nbe inter\u00adpreted (i)as a type constraint where the type is the constructed constant (1,2), (ii)as a type \nconstraint where the type is the product type of the two scalar constants 1 and 2,or (iii)as a pair pattern \nformed by two type constraints, 1 and 2. All these interpretations yield the same semantics. Therefore, \nthe use of the same constructors for types and patterns reduces the number of possible denotations for \nthe same (from a semantic viewpoint) pattern: had we used a different syntax for product types, say, \nt1x t2, then we would have had two denotations, i.e. (1,2) and 1x2, for the same pattern. The same reason \nmotivates our choice of denoting record types by {a1=t1;...;an=tn} rather than by the more common {a1:t1;...;an:tn}. \nRegular expression operators *, +, ? are greedy in the sense that they try to match as many times as \npossible. Ungreedy versions *?, +? and ?? are also provided; the difference in the compilation scheme \nis just a matter of order in alternative patterns. For instance, [__* (x &#38; Int) __*] is compiled \nto P where P = (__,P) | (x &#38; Int, __) while [__*? (x &#38; Int) __*] is compiled to P where P = (x \n&#38; Int, __) | (__,P). Let us detail the compilation of an example with a sequence cap\u00adture variable: \n[__*? d::(Echar+ . Echar+) ]. The .rst step is to propagate the variable down to simple patterns: [__*? \n(d::Echar)+ (d:: . ) (d::Echar)+ ], which is then compiled to the recursive pattern: P where P = (d &#38; \nEchar, Q) | (_,P) and Q = (d &#38; Echar, Q) | (d &#38; . , (d &#38; Echar, R)) and R = (d &#38; Echar, \nR) | (d &#38; nil) The (d &#38; nil) pattern above has a double purpose: it checks that the end of the \nmatched sequence has been reached, and it binds d to nil, to create the end of the new sequence. Note \nthe difference between [ x&#38;Int ] and [ x::Int ]. Both patterns accept sequences formed of a single \ninteger i, but the .rst one binds ito x, whereas the second one binds to x the sequence [i]. A mix of \ngreedy and ungreedy operators with the .rst match pol\u00adicy of alternate patterns allows the de.nition \nof powerful extractions. For instance, one can de.ne a function that for a given person returns the .rst \nwork phone number if any, otherwise the last e-mail, if any, otherwise any telephone number, or the string \n\"no contact\": let preferred_contact(Person->String) <_>[__( _*? <tel kind=\"work\">x) | (_* <email>x) | \n<tel>x ] -> x | _ -> \"no contact\" (note that <tel>x does not need to be preceded by any wildcard pat\u00adtern \nas it is the only possible remaining case).  3.7 Extra support for sequences and queries Although there \nis no special support for sequences in the core type and pattern algebras (regular expression types and \npatterns are just syntactic sugar), eDuce provides some language constructions to support them. Map, \ntransform, and xtransform. eDuce features a construction map ewith p1->e1| ... | pn->en. The expression \nemust evaluate to a sequence, and each of its ele\u00adments will go through the pattern matching and get \ntransformed by the .rst matching branch. Static typing ensures the existence of such a branch. The typing \nof map is very precise, even when working with heterogeneous sequences, since it keeps track of the order \nof the elements in the input sequence, as shown by this example that uses the function split de.ned in \nSection 3.4 let f ([ MPerson* FPerson* ] -> [ Man* Woman* ]) s -> map s with x -> split x The type system \nis able to infer that the result of the map has type [ Man* Woman* ]. If the argument had type [ MPerson? \nFPerson+ ], the type inferred for the result would be [ Man? Woman+ ]. This precision in typing is out \nof reach of the user-de.nable polymorphic map function in ML; even with parametric polymorphism incorpo\u00adrated \nto eDuce (we have already started studying it), this built-in map would probably not be user-de.nable \n(because its very precise typing closely characterizes its complex behavior). The map construction does \nnot affect the length of the sequence, since each element is mapped to a single element. It is often \nuseful not only to map the elements of a sequence but also to .lter them, for which eDuce provides a \nvariant of map, written transform, where each branch of the pattern returns a (possibly empty) sequence, \nand all the returned sequences, for each element in the source sequence, are concatenated together. There \nis an implicit default branch __->[] added on at the end so that unmatched elements are discarded. Our \ntransform is very similar to the for of [7]: their generic loop for xin e1return e2can be simply translated \nto transform e1with x->e2. The last special sequence operator is xtransform, which works on (sequences \nof) XML trees. It matches the patterns against the root element of each XML tree and, if it fails, it \nrecursively applies itself to the sequence of sons of the root. Thanks to xtransform a function that \nputs in boldface all the links of an XHTML document can be simply de.ned as: let bold(x:[Xhtml]):[Xhtml]=xtransform \nx with <a (y)>t -> [ <a (y)>[<b>t] ] (note the use of the variable y to preserve the attributes, e.g. \nhref, rel, target,..., of the link). Note that without xtransform we would be obliged to iterate on the \nwhole DTD of XHTML. In short, xtransform combines the .exibility of XSLT template programming with the \nprecise static typing and ef.cient compilation of eDuce s transform. Queries. eDuce was designed by \nrecasting some XML speci.c features from XDuce in a more general setting of higher-order and over\u00adloaded \nfunctional languages. But it turns out that a small set of ex\u00adtra constructions can also endow it with \nquery-like facilities that are standard in the database world: projection, selection, and join.7 As we \nmentioned above, our transform generalizes the for iteration from [7]. As in [7], the projection operator \ndenoted by / can be de.ned from this construction: if eis a eDuce sequence expression and tis a type, \nthen e/tis syntactic sugar for:8 transform ewith <__>c -> transform c with (x &#38; t) -> [x] This new \nsyntax can be used to obtain a notation close to XPath [6]: [parents]/<parentbook>__/ <person>__/<children>__/<person>__/<tel \nkind=\"home\">__ returns the sequence of all home phone numbers of children in our parents base (thanks \nto static typing we could have used __/__ in the path instead of <parentbook>__/<person>__ as no ambiguity \nis possible). The function names2 in \u00a72 implements exactly the same query. But while the use of transform \nsomewhat freezes the implementation, the more declarative nature of path expressions spots out the places \nin the code where query optimization (using for instance equiva\u00adlences similar to those mentioned in \n[7]) should be applied. More generally, we are currently adding to the algorithmic con\u00adstructions of \neDuce a set of more declarative query-like construc\u00adtions amenable to optimization techniques. In particular, \nwe are cur\u00adrently adding classical select-from-where expressions but where the from clause can take advantage \nof the powerful eDuce s pattern alge\u00adbra. Since order in from clauses is left unspeci.ed, the system \nwill be free to apply algebraic and/or cost-model based optimizations and/or use available indexes to \nimplement joins ef.ciently.  4. Types The type system is at the core of eDuce. The whole language was \nconceived and designed around it. From a practical point of view, the most interesting and useful characteristic \nof the type system is the semantic interpretation we described before, in which a type is nothing but \na set of values denoted by some syntactic expression9. 7The fact that (Duce can implement such constructions \nis not surprising: any Turing-complete language can do it. The point is that, instead of de.ning a .xed \nimplementation of these constructions, one can use the semantic foun\u00addations of (Duce to obtain different \nimplementations and natural (insofar as semantic) transformations that pave the way to query optimization.8We \ncan take advantage of the fact that in (Duce a single pattern can ex\u00adtract all the elements of a given \ntype, to de.ne the following more compact encoding: transform ewith <__>[ (x::t|__)*] -> x 9Of course, \nevery type system induces a set-theoretic interpretation of types as sets of values. The point is that \n(Duce s type system is built on such an interpretation. As a result, the subtyping relation of (Duce \nis both sound and complete w.r.t. set-inclusion, whereas in other type systems only soundness holds (that \nis, if a type tis a subtype of sthen all the values in tare also in s, This simple intuition is all is \nneeded to grasp the semantics of the eDuce s type system and, in particular, of: Subtyping: subtyping \nis de.ned as the inclusion of sets of values: a type tis a subtype of sif and only if every value which \nhas type thas also type s; when this does not hold, the type system can always exhibit a sample of type \ntbut not of type s.  Boolean connectives: Boolean connectives in the type algebra are interpreted simply \nas their set-theoretic counterpart on sets of val\u00adues: intersection &#38;, union |, and difference \\ \nare the usual set the\u00adoretic operations.  Type equivalences: two types are equivalent if and only if \nall the values in the former are values in the latter and vice-versa. For example: [ Int (String Int)* \n] :[ (Int String)* Int ].  It is important to understand types since they are pervasive in eDuce. In \nparticular, pattern matching can be basically seen as dynamic dis\u00adpatch on types, combined with information \nextraction, which gives eDuce a type-driven semantics reminiscent of object-oriented lan\u00adguages, since \noverloaded functions can mimic dynamic dispatch on method invocations. Note however that a class based \napproach (map\u00adping each XML element type to a class) would be infeasible since the standard dispatch \nmechanism in OO-languages is much less power\u00adful than pattern matching (which can look for and extract \ninforma\u00adtion deep inside the value). By keeping the methods separate from the objects, we also get the \nequivalent of multi-methods (dispatch on the type of all the arguments, not just on the type of a distinguished \nself ). Besides this dynamic function, types play also a major role in the static counterpart of the \nlanguage. Type correctness of all eDuce transformations can be statically ensured. This is an important \npoint: although many type systems have been proposed for XML docu\u00adments (DTD, XML-Schema, RELAX NG, ...), \nmost XML applica\u00adtions are still written in languages (e.g. XSLT) that, unlike XDuce or eDuce, cannot \nensure that a program will only produce XML docu\u00adments of the expected type. Furthermore, in XDuce/eDuce, \npattern matching has exact type inference, in the sense that the typing al\u00adgorithm assigns to each capture \nvariable exactly the set of all values it may capture. This yields a very precise static type system \nthat provides a better description of the dynamic behavior of programs. Finally, types play an important \nrole in the compiler back-end. The type-driven computation raises interesting issues about the exe\u00adcution \nmodel of eDuce and opens the door to type-aware compila\u00adtion schemas and type-driven optimizations that \nwe hint at in \u00a75. 4.1 Highlights of the type system Since eDuce type system relies on interpreting types \nas sets of values, it is important to explain how values are typed. Apart from function values, this \nis straightforward, so we will focus on the typ\u00ading rule for functions. In order to simplify the presentation, \nwe split it into two rules, a subrule for typing function bodies (these are lists of pattern matching \nbranches) whose derivation is then used in the typing rule for functions. Pattern matching (function \nbodies). Let Bdenote the sequence of branches p1->e1| ... | pn->en. The rule below derives the typing \njudgment rHtlB s, meaning matching a value of type tagainst the sequence of branches Bal\u00adways succeeds \nand every possible result is of type s . (ti 5 \\ \\ pi-1 t\\ pi5 ) p15 &#38; t: ! | | ! rdH: (tilpi p1 \npneisi . rHtlB {iIt. ?Empty} si but the converse does not hold). Let us look at this rule in detail. \nThe matched value is of type t. The left premise checks that the pattern matching is exhaustive; for \neach pattern pi, pi! is a type that represents exactly all the values that are matched by pi. The exhaustivity \ncondition states that every value that belongs to tmust be accepted by some pattern. Now we have to type-check \neach branch. At runtime, when the branch pi->eiis considered, one already knows that the value has been \nrejected by all the previous patterns p1...pi-1; if the branch succeeds, one also knows that the value \nis of type pi! . So, when type-checking the expression of the i-th branch, one knows that the value is \nof type ti, that is to say, of type tand of type pi! but not of any of the types p1! ...pi-1! . Now we \ntype-check the body eiof the branch; to do so, one must collect some type information about the variables \nbound by pi. This is the purpose of (tilpid:it is a typing environment that associates to each variable \nxin pia type that collects all the values that can be bound to xby matching some value of type tiagainst \npi. It is evident that all the magic of type inference resides in the operators p! and (tlpd. These operators \nwere introduced in [8]. Their de.nition re.ects their intuitive semantics and is also used to derive \nthe algorithms that compute them. In the next section exam\u00adples are given to illustrate some complex \ncomputations performed by these algorithms. The result of the pattern matching will be the result of \none of the branches that can potentially be used. This is expressed by taking the union of the result \ntype of each branch isuch that tiis not empty (the . notation stands for s1| ...|sn); indeed, if tiis \nempty, the i=1..nsibranch cannot be selected, and the corresponding siis not included in the union. \nFunctions. How useful are unused branches (i.e., those with ti:Empty)ina pattern matching ? The answer \nis in the typing rule for functions: (tt1->s1&#38;&#38;tn->sn) rj:tHtilBUi:si rHfun j(t1->s1;...;tn->sn)B:t \nThe type system simply checks all the constraints given in the in\u00adterface (because the function can call \nitself recursively, when typing the body we record in the type environment that jis a function of the \ntype given by the interface). So the body is type-checked several times and for some type tiit may be \nthe case that some branch in B is not used. Let us illustrate this with a simple example: fun (Int -> \nInt; String -> String) IInt -> 42 I(x &#38; String) -> x When type-checking the body for the constraint \nString -> String, the .rst branch is not used, and even though its return type is not empty (it is 42, \nwhich is the type assigned to the constant 42), it must not be taken into account to check the constraint. \nThis is not a minor point: not considering the return type of un\u00adused branches is the main difference \nbetween dynamic overloading and type-case (or equivalently the dynamitypes of [1]). The latter always \nreturns the union of the result types of all the branches and, as such, it is not able to discriminate \ndifferent input types. From the point of view of the programmer, it is quite easy to de\u00adtermine the type \nof a function value: it is simply the intersection of all the types speci.ed in its interface.  4.2 \nPattern type inference: examples We saw that p! and (tlpdare at the core of the type system. They are \nde.ned as the smallest solution of some set of equations (there may be several solutions when considering \nrecursive patterns). These de.nitions are quite straightforward, re.ecting the intuitive semantics of \nthe operators. For example, p! is de.ned by the fol\u00ad lowing set of equations x! Any p1|p2! p1! | p2! \n t! t p1&#38;p2! p1! &#38; p2! (x:=)! Any (p1,p2)! ( p1! , p2! ) which simply states that a pattern \nformed by a variable matches (the type formed by) all values, that a pattern type matches all the values \nit contains, that an alternative pattern matches the union of the types matched by each pattern, and \nso on. Recursive patterns are handled by considering their in.nite unfolding which, thanks to regularity, \ngenerate by the equations only .nite systems. Other data construc\u00adtors (records, XML elements) are treated \nlike pairs. The same intu\u00adition guides the de.nition of (tlpd. For example: (tlxd(xd t (tl(p1|p2dd(xd((t&#38; \np1! dlp1d(xd|((t\\p1! dlp2d(xd . . . states that when we match the pattern xagainst values ranging over \nthe type t, the values captured by xwill be exactly those in t. Sim\u00adilarly when we match values ranging \nover tagainst an alternative pattern, the values captured by a variable xwill be those captured by xwhen \nthe .rst pattern is matched against those values of tthat are accepted by p1, and those captured by xwhen \nthe second pattern is matched against the values in tthat are accepted by p2but not by p1 (see the appendix \nof [8] for the rest of the de.nitions). The most important result for these de.nitions is that the equations \nabove can be used to de.ne two algorithms that compute p! and (tlpd. Rather than going into the details \nof the algorithms, we prefer to give some examples that show the subtlety of the computation they are \nrequired to perform. Consider again the pattern P where P = ((x &#38; Int) , P) | ( _ , P) | (x:= nil) \nthat extracts all the integers occurring in a sequence10. In the table below we show the types of all \nvalues that are captured by the variable x of the pattern P when this latter is matched against (values \nranging over) different types. The typing of patterns, pat\u00ad t (tlPd(xd [Int String Int] [Int Int] [Int \n| String] [Int?] [Int* String Int] [Int+] [Int+ String Int] [Int+ Int] [(0..10)+ String] [(0..10)+] [(Int \nString)+] [Int+] tern matching, and functions is essentially all is needed to un\u00adderstand how the type \nalgorithm works, as the remaining rules are straightforward. The only ex\u00adception to that are the typing \nof the constructions map, transform, and xtransform which need to compute the transformations of regular \nexpressions (over types) and for which the same techniques as those of [7] are used.  5. Implementation \nIn this section we brie.y highlight some important implementa\u00adtion issues and solutions speci.c to our \napproach. We have devel\u00adoped a prototype in Objective Caml; it compiles when needed pat\u00adtern matchings \nto an internal automaton-like representation ( just\u00adin-time ). Despite the interpretative overhead, it \nexhibits satisfactory performances. Typing eDuce programs is theoretically complex (the subtyping relation \nitself is already exponential in the size of involved types), and it is indeed possible to .nd short \nprograms that kill the type-checker (as it is the case for ML, for instance). In designing eDuce we put \nthe emphasis on the expressiveness of the language and the ef.ciency of the produced code, accepting \nthe theoretical complexity of type-checking. XDuce has proved that type systems 10More precisely, if \nP is matched against a sequence L, then x is bound to the subsequence of Lcontaining all the integers \nin Lin the order in which they appear. for XML programs with regular expression types are workable, and \nour prototype gives us con.dence that eDuce s new features will be too. In the future, we plan to develop \na compiler for eDuce, and perform serious benchmarking and performance tests. Preliminary benchmarks \non our prototype (see below) are encouraging. Localization of error messages. We formalized the static \ntype checking of eDuce programs in [8], using the classical presentation of a type system with bottom-up \ninference rules. It is well-known that for a type-checking failure, direct implementation of such rules \ncannot provide well-localized error messages. For instance, consider fun f(t->s) p1->e1| p2->e2, where \ne1turns out not to be of type s. The typing rule that triggers the error is the one for abstractions. \nSince it sees the body branches as black-boxes, it cannot localize the error on e1but only on the whole \nfunction expression. A different example is given by the ap\u00adplication of a function of type, say, Xhtml \n-> Xhtml to the document <html>[<head>[ ] <bdy>[ ] ]. The typo in the last tag makes the typ\u00ading of the \napplication fail, and a bottom-up algorithm is not precise enough to track the misspelled <bdy>. The \nsolution is to type-check programs with a mixed top-down and bottom-up algorithm. In particular, we have \nadopted a tech\u00adnique that types expressions by propagating a constraint through the abstract syntax tree, \nfrom the root to the leaves. This constraint gives an upper-bound on the resulting type for the sub-expressions \nwhich catches errors earlier and localizes them precisely. This solution is highly effective when coupled \nwith the eDuce typing as the latter is very precise and, quite interestingly (although not unexpectedly), \ntyping precision induces a similar precision in error localization. In the .rst example, our prototype \nlocalizes an error somewhere in e1 (depending on where the error is), and in the second it localizes \nit in the tag <bdy> (highlighted in red on the screen) and emits an error message stating that it should \nbe <body>. This precision of error lo\u00adcalization combined with the eDuce capacity to exhibit a value \nof the expected type not matching the de.nition produces very infor\u00admative error messages. We invite \nthe reader to test this issue on the online prototype or on the eDuce distribution. Formally, the type \nsystem with propagation of constraint is de\u00ad.ned by a typing relation rHelt:s, where ris the typing envi\u00adronment, \nethe expression to type-check, tthe constraint and sthe resulting type, which must be a subtype of t. \nFor instance, the typing rule for pairs is: rHe1l71(td:t1rHe2l72t.(td:t2 rH(e1e2dlt:(t1t2d where 71represents \nthe set-theoretic .rst projection (71(tdis the smallest solution Tto t:(TAnyd) and 72t.(tdrepresents \nthe best re.nement of the constraint knowing a more precise type for e1(it is de.ned as the largest solution \nTto (t1Td:t). For instance, if t (<a>__,<a>__) | (<b>__,<b>__), and e(<a>[ ],<b>[ ]), the error will \nbe localized on <b>[ ] which is type-checked with the constraint <a>__. Implementation of typing algorithms. \nIn [8], we de.ned a high-level speci.cation of a subtyping algo\u00adrithm by a notion of coinductive simulation \nthat characterizes empty types (tis a subtype of sif the difference type t\\ sis empty). Many optimizations \nand subtle implementation techniques can be applied in order to move from this speci.cation to a practical \nalgorithm, in\u00adcluding those mentioned in [14] (for the informed reader, note that their algorithm can \nbe easily improved by caching negative results in a destructive structure, since they cannot be invalidated \neven under different assumptions). The algorithm in [14] uses a top-down ap\u00adproach to avoid exponential \nexplosion (due to the presence of union types); however, it requires backtracking and is thus suboptimal \nwith respect to its theoretical complexity (and backtracking prevents the use a persistent data structure). \nOur implementation uses instead an ef.cient local solver for monotonic Boolean constraints that we de\u00adveloped \nfor the occasion. It is always as ef.cient as the backtracking top-down approach, both theoretically \nand in practice (we imple\u00admented both). We conjecture that it guarantees optimal theoretical complexity \nas well. The set-theoretic denotational foundation of eDuce is a primary source for studying implementation \nissues since quite often simple set-theoretic observations allow important optimizations. For in\u00adstance, \nthe type (t,s)\\(t1,s1)\\ ...\\(tn,sn)often appears in the execution of the typing algorithm. A naive development, \nconsist\u00ad '' ' ing of the repeated use of the rule (t,s)\\(t,s)=(t\\ t,s)I (t,s\\ s ' )would systematically \nyield 2nterms. To avoid this ex\u00adponential explosion, we noticed that the result can be written as (t\\ \nt1\\ ...\\ tn,s)I(t&#38; t1,s\\ s1)I...I(t&#38; tn,s\\ sn) provided that the ti s are pairwise non-intersecting \n(the formula can be further simpli.ed by erasing empty terms). It is always possible to enforce the condition \nby splitting some of the titypes. For the general case, we fall back to 2n, but in practice we are closer \nto the linear case. Checking or enforcing the condition requires many ap\u00adplications of the subtyping \nalgorithm, but our results have shown that is it worthwhile. This kind of split and distribute technique \ncan be found in several places of our implementation and is reminiscent of analogous techniques mentioned \nin [13] for Boolean algorithms. Pattern-matching compilation, type-driven optimizations. eDuce type \nchecking is not just a preliminary veri.cation. We believe that static typing is key for designing an \nef.cient execution model for eDuce (and XML languages in general). To grasp the idea, consider two types \nA and B and the function: fun (<a>[A+|B+] -> Int) | <a>[A+] -> 0 | <a>[B+] -> 1 A naive compilation schema \nwould yield the following behavior. It will .rst check whether the .rst pattern matches the argument. \nTo do this, it will: (idcheck that it is an XML element of the form <a>c and (iidrun through c to verify \nthat it is a non-empty sequence of elements of type A (checking that an element is of type A may be very \nexpensive if A represents for instance a complex DTD). If this fails, it will try the second branch and \ndo all these tests again with B. The argument may be run through completely several times. There are \nmany useless tests; .rst, it is known statically that the argument is necessarily an XML element with \ntag a, so there is no need to check this. Also, the content c must be a non-empty sequence whose elements \nare either all of type A or all of type B. To determine the situation, simply look at the .rst element \nand perform some tests to discriminate between A and B (for instance, if A = <x>[...] and B = <y>[...], \nlooking at the head tag is suf.cient, so the match could be compiled as <__>[<x>____*] ->0|__-> 1). Using \nthese optimizations, only a small part of the argument is looked at (and just once). In general, a naive \napproach to compiling pattern matching may yield multiple runs and backtracking through the matched value. \nForgetting for a moment functions and records, values can be seen as binary trees, and types simply represent \nregular tree languages. It is a well-known fact that such tree languages can be recognized by deterministic \nbottom-up tree automata; this indicates that back\u00adtracking can be eliminated. It is possible to adapt \nthe theory of tree automata to handle the full range of eDuce patterns (with capture variables) and values. \nHowever, determinization may create huge and intractable automata (number of states and transition function); \nthis is due to the fact that such automata perform a uniform compu\u00adtation, disregarding the current position \nin the tree. When matching a pair (v1v2d, different computations can be performed on v1and v2(each with \na smaller automaton), but classical bottom-up tree au\u00adtomata do not have this .exibility. Also, to help \npattern matching, we want to take static type information about the matched value into account. This \ncan be combined with the previous remark: when matching (v1v2d, one can start, for example, with v1; \naccording to the result of this computation, we get more information about the (dynamic) type of the \nmatched value, which can simplify the work on v2: for instance, if we statically know that (v1v2dhas \ntype (t1,t2) |(s1,s2) with non-intersecting types t1and s1, and if the computation on v1tells us that \nv1has type t1, then we know that v2has neces\u00adsarily the type t2, and no further check is required. By \nusing static type information, it is thus possible not only to avoid backtracking, but also to avoid \nchecking whole parts of the matched value. This is particularly useful when working with tag-coupled \ndocument types (as DTD types) where the tag of an XML element already provides a lot of information about \nits content. We have designed and implemented an ef.cient compilation sche\u00adma that incorporates all these \noptimizations. Lack of space and com\u00adplexity of the algorithms keep us from describing them here, and \nthey will be presented in a future publication (but see the online extended version of this paper for \nan outline). Let us just state one interesting property: the compilation schema is semantic with respect \nto types, in the sense that the produced code does not depend on the syntax of the types that appear \nin patterns, but only on their interpretation. Therefore, there is no need to simplify types for instance \nby ap\u00adplying any of the many type equivalences before producing code, since such simpli.cations are all \ninternalized in the compilation schema itself. Representation of run-time values. In eDuce, patterns \ncheck at runtime whether a value has a speci.c type. Hence one must be able to distinguish ef.ciently \nthe represen\u00adtation of say, a pair value, an integer value, and a record value. In our prototype values \nare implemented by an OCaml sum type: type value = Pair of value*value | Char of int | Integer of ... \n| ... . This gives us the possibility to introduce derived forms of runtime values in order to optimize \nspeci.c cases that cannot be easily de\u00adtected at compile-time. When a derived form is inspected, it can \nbe dynamically coerced to its canonical representation. For instance, in eDuce, character strings are \nconceptually sequences of Unicode characters: the value [ AB <x>[ ] ] is represented as Pair(Char 65, \nPair(Char 66, Xml(...))). In order to avoid the allocation of many se\u00adquence cells (pairs) for long strings, \nwe have added to the sum type for values a special form for strings (actually, we have several forms \ncorresponding to different internal encodings), namely, type value = ... | String of int * string * value \nwhere the integer points to the beginning of the string in the buffer of characters at the second argument, \nand the third argument corre\u00adsponds to the rest of the sequence (the nil atom in case of a sequence with \nonly characters). The value above can thus be represented more compactly as String(0,\"AB\", Xml(...)) \n; when this value is inspected by a pattern, it is seen as Pair(Char 65, String(1,\"AB\", Xml(...))) (the \nOCaml string buffer \"AB\" is not copied). The idea is to work with the compact representation as long \nas the string is not inspected. Another example of special form is a lazy version of the concate\u00adnation \noperator @ for sequences; indeed, it is not unusual to build a long sequence by extending it repeatedly \nto the right. The canon\u00adical representation of sequences requires copying the .rst argument of @, and \nthis may yield a quadratic behavior where a linear one is expected. The solution is to delay the computation \nof @ until the result is actually inspected; the binary tree with @ nodes can then be ef.ciently linearized. \nOf course, these derived forms are completely transparent to the programmer, and they do not affect the \nsemantics of the language.  Benchmarks. We performed preliminary benchmarks to evaluate eDuce s per\u00adformance \nand validate our type-driven approach for compiling pat\u00adtern matching.11 In this section, we present \na comparison between eDuce and an XSLT processor (the xs1tproprogram from Gnome libxslt library). The \ntables below display execution time in seconds (user time as reported by the Unix timecommand) for several \nsizes of input XML documents and several implementations of the same transformation. The execution times \nwe give for eDuce programs include the times of XML parsing, type-checking, and validation of the input \ndocuments, while the times for XSLT programs include only XML parsing time (since XSLT is untyped). The \ntransformation addrbookis a simple .ltering of .at XML documents. In order to test the effectiveness \nof eDuce type-driven optimization we performed some auto-benchmarking by testing dif\u00adferent eDuce programs \nimplementing the same transformation. In particular we considered two different versions of the transformation \naddrbook, one that uses explicit recursion to implement the traver\u00adsal of the document and a second that \nuses instead the transform con\u00adstruction; furthermore for each version we considered a variant (de\u00adnoted \nby opt ) which was optimized by hand by replacing dynamic type checking by minimal tests on tags. addrbook \n0.1 Mb 0.5 Mb 1.2 Mb 6 Mb 12 Mb eDuce1 eDuce1 opt eDuce2 eDuce2 opt 0.11 0.11 0.11 0.11 0.33 0.33 0.32 \n0.32 0.65 0.64 0.61 0.61 3.36 3.39 2.95 2.96 7.15 7.14 5.85 5.83 XSLT 0.08 0.38 0.76 3.74 7.38 The second \ntransformation we considered is a simpli.ed version of the sp1itfunction in \u00a73.4. The .rst eDuce version \nuses the stan\u00addard pattern <person gender=g>[ <name>n <children>[(mc::MPerson | fc::FPerson)*] ]. The \nsecond one uses the hand-optimized pattern <__ gender=g>[ <__>n <__>[(mc::<__ gender=\"M\">__ | fc::__)*] \n]. The third eDuce version duplicates the main function to avoid overload\u00ading and useless computations \non tags. The two XSLT versions use slightly different styles (two templates, or a single template with \ncomputations on the tag). sp1it 60Kb 0.3 Mb 0.6 Mb 2.5 Mb 5.2 Mb eDuce 1 eDuce 2 eDuce 3 0.10 0.11 0.10 \n0.30 0.30 0.29 0.52 0.50 0.49 1.92 1.92 1.85 3.95 3.92 3.81 XSLT 1 XSLT 2 0.15 0.18 0.79 0.93 1.42 1.68 \n5.95 6.90 12.85 14.33 Although preliminary, these benchmarks already allow us to draw some conclusions. \nFirst of all, eDuce exhibits good performances: eDuce programs are usually faster than equivalent XSLT \ntransfor\u00ad mations (using a quite ef.cient XSLT processor written in C) and on the .les of the tests they \nshow execution times which are linear in the size of data. Compiling eDuce programs will remove interpretative \noverhead and type-checking from runtime, and so we expect some further improvements. Also, in a real \nusage scenario, several trans\u00ad formations will be composed in a single eDuce program to avoid parsing/validating/printing \nof intermediate XML documents. Secondly, the negligible difference of execution times between normal \nand hand-optimized versions of eDuce programs demon\u00ad strates the effectiveness of the type-driven compilation \napproach and the uselessness of hand-coded optimization. This means that eDuce s runtime avoids the burden \nof coding optimizing patterns, and allows the programmer to use a more declarative and robust style of \npro\u00ad 11The test machine was an Athlon 750 with 128 Mbytes of RAM. The code of all benchmarks is available \nat http://www.due.org/benh.html. gramming. Finally, we want to stress that none of the examples we used \nin the benchmarks above exploits the full power of eDuce s type-based optimization: in all these examples \nthe only possible gain brought by eDuce s optimization came from avoiding useless tests of tag names; \nhowever the examples are so compact that eDuce s opti\u00admization could not be used to ignore whole subtrees \nof the input documents. Since the latter is the case in which eDuce runtime sys\u00adtem is expected to succeed \nbest, we expect that in real-case use the advantage of using eDuce will be even more evident also in \nterms of pure performance. We do not include in this benchmark section a comparison with XDuce because \nXDuce has not been optimized for runtime. As for type-checking an aspect we cannot compare with XSLT \ncomplex transformations seem to be type-checked signi.cantly faster in eDuce than in XDuce (for instance, \na simpli.ed version of htm121atex from the XDuce distribution takes 0.44s for eDuce, versus 9.40s for \nXDuce 0.4.0, 1.33s for XDuce 0.2.4, and 18.30s for XDuce 0.2.4 with pattern optimization turned on). \nWe are currently performing more extensive benchmarking and comparing performances with respect to XSLT \nand XQuery. We plan to report complete results on eDuce site s benchmark pages.  6. Conclusions and \nongoing work eDuce is an extension of XDuce with a richer set of basic types (Char, String, Int, intervals) \nand of constructed types (open and closed records, intersections, differences, singletons), while adding \nto the language overloaded and higher order functions, powerful sequence extracting patterns, records, \nand tags as .rst-class expressions. It is important to notice that this is obtained smoothly by using \na very small core of semantically de.ned key features [8] . eDuce also re\u00adlies on a theoretic construction \nquite different from that of XDuce and this construction had a deep impact on the implementation of the \nlanguage itself and on the typing and subtyping algorithms. A separate article to present them is in \npreparation. We have also begun formally studying security issues of eDuce with preliminary results available \non the eDuce web site. As for language, we have just .nished implementing and we are presently testing \nXML Schema integration and validation. This is obtained by importing schemas into eDuce types and by \nvalidating eDuce expressions against them. This greatly simpli.es the typed import of XML documents which \ncan then be treated by using the eDuce data model (in XQuery the choice was made to work directly on \nXML Schema data model). We are also implementing the query language we hinted at in Sec\u00adtion 3.7, developing \nsimple logical optimizations and benchmark\u00ading it against the Bell-labs XQuery implementation [2] using \nthe XQuery Use Cases (http://www.w3.org/TR/xmlquery-use-cases/) as testbed. We expect to present results \nand merge the CVS branch into the main eDuce branch before the end of the year. We are also currently \nstudying a module system that supports in\u00adcremental programming via cross-module specialization. The \nbasic idea can be understood by considering the toplevel de.nition of the function add given in Section \n3.4. A new let fun declaration for add would hide the older one. We are experimenting with a specializing \ndeclaration let method add ((Char,String)->String) (x,y) ->[x] @ y where the new de.nition specializes \nthe de.nition of add in the sense that it is as if we had de.ned from the beginning add as follows let \nfun add ((Char,String)->String; (Int,Int)->Int; (String,String)->String) | (x &#38; Char, y &#38; String) \n-> [x !y] | (x &#38; Int, y &#38; Int) -> x+y | (x &#38; String, y &#38; String) -> x@y Such de.nitions \ncan be smoothly encoded in the core of eDuce by a combination of dynamic scoping and a technique similar \nto the one used for Java s parasitic methods [4]; an incremental programming style can then be obtained \nby allowing cross module specialization of the form let method SomeModule.add . . . . Besides studying \nthe module system and query language exten\u00adsions we have hinted at in this paper, future plans include \nthe study of polymorphic, lazy, and reference types, the exploration of inter\u00adactions with other languages \nand type systems (typically for using existing libraries) and the development of tools for better interfacing \neDuce with XML tools and standards. Acknowledgments. We want to warmly thank Dario Colazzo, Haruo Hosoya, \nStijn Vansummeren, J\u00e9r\u00f4me Vouillon, and Philip Wadler for the useful and constant feedback on this work, \nPietro Di Lena for his help with XSLT, Stefano Zacchiroli for his work on XML Schema, Abigail Pope for \nproof-reading this paper, and the ICFP referees whose remarks greatly contributed to improve the presentation \nof this article. Very special thanks go to Benli Pierce for sheparding this work and for the many useful \nsuggestions, discussions, inputs on this and other topics. References [1] M. Abadi, L. Cardelli, B. Pierce, \nand G. Plotkin. Dynamic typing in a statically typed language. ACM TOPLAS, 13(2):237 268, April 1991. \n[2] Bell-labs. Galax. http://db.bell-labs.om/galax/. [3] S. Boag, D. Chamberlin, M. Fernandez, D. Florescu, \nJ. Robie, J. Sim\u00e9on, and M. Stefanescu. XQuery 1.0: An XML Query Language. W3C Working Draft, http://www.w3.org/TR/xquery/, \n2003. [4] J. Boyland and G. Castagna. Parasitic methods: Implementation of multi-methods for Java. In \nOOPSLA 97, 32(10), pages 66 76, 1997. [5] A. Christensen, A. M\u00f8ller, and M. Schwartzbach. Extending Java \nfor high-level web service construction. ACM TOPLAS, 2003. To appear. [6] J. Clark and S. DeRose. XML \nPath Language (XPath). W3C Recommendation, http://www.w3.org/TR/xpath/, 1999. [7] Mary Fern\u00e1ndez, J\u00e9r\u00f4me \nSim\u00e9on, and Philip Wadler. An algebra for XML query. In FST&#38;TCS, LNCS n. 1974, pages 11 45, 2000. \n[8] A. Frisch, G. Castagna, and V. Benzaken. Semantic Subtyping. In 17th IEEE Symp. on Logic in Computer \nScience, pages 137 146, 2002. [9] V. Gapayev and B.C. Pierce. Regular object types. In Proceedings of \nthe 10th workshop FOOL, 2003. [10] H. Hosoya. Regular expressions pattern matching: a simpler design. \nUnpublished manuscript, February 2003. [11] H. Hosoya and B. Pierce. XDuce: A typed XML processing language. \nACM TOIT, 2003. To appear. http://xdue.soureforge.net/. [12] Haruo Hosoya. Regular Expression Types for \nXML. PhD thesis, The University of Tokyo, 2001. [13] Haruo Hosoya and Makoto Murata. Validation and boolean \noperations for attribute-element constraints. In PLAN-X, 2002. [14] H. Hosoya, J. Vouillon, and B. Pierce. \nRegular expression types for XML. In Proc. of ICFP 00, SIGPLAN Notices 35(9), 2000. [15] Michael Y. Levin. \nMatching automata for regular patterns. Tech. rep., 2003. http://www.is.upenn.edu/-bpiere/xtati/. [16] \nM. Odersky and P. Wadler. Pizza into Java: Translating theory into practice. In Proc. of 24th ACM POPL, \n1997. [17] J. Sim\u00e9on and P. Wadler. The essence of XML. In Proc. of 30th ACM POPL, 2003.  A.1 Syntax \nof eDuce Patterns p:: x capture Names l T type constraint XNames complying with the XML recommendationC*)but \nl X pattern variable starting by an upper case literal l p&#38; p conjunction Variables lpl p alternative \nxNames complying with the XML recommendationC*)but l (p,p) pair starting by a colon, an underscore, or \na lower case literal l{ pp} p XML pattern l{ pe(pd} p XML friendly Constants l { e(pd} open record :: \nnna signed integer ' ' l{| e(pd|} closed record l aaa unicode literal l[ r] sequences Atoms l(x:=) default \na::' Xl' x l pwhere Xpand ...and Xprecursion Base types Functions B::String lInt lChar lBool j::fun \nx(p: T ...p: T):T e lfun x(T - T;...;T - T) p- el ...l p- e Singleton types S::al Expressions e:: constant \nTypes la atom T ::B base types lx variable lS singleton lj function lT l T union le1e2 application lT \n&#38; T intersection l(e1,e2) pair lT \\ T difference l{ ee} e XML element lT - T functions l{ ee(ed} \ne XML friendly l{ TT } T XML tree lo e pre.x operator l{ T e(Td} T XML friendly leop e in.x operator \nlX type variable l{ e(ed} record lT where XT and ...and XT recursion le. .x .eld select l{ e(Td} open \nrecord le\\ x .eld remove l{| e(Td|} closed record l[ s]] sequences l[[ R]] sequences l el T projection \nl l--l interval l (e: Td coercion l Empty empty type l let pein e let l Any all values l let p: T ein \ne coerced let l all values lif ethen eelse e if__then__else lraise e raise exception Attribute list \nltry ewith p- el ...l p- etrap exception e(ad::E empty attribute list lmatch ewith p- el ...l p- ematch \n lxa mandatory attribute lmap ewith p- el ...l p- emap lx ? a optional attribute ltransform ewith p- \nel ...l p- e.lter le; e list of aattributes lxtransform ewith p- el ...l p- eXML-tree transf Interval \nlimit Pre.x operators l:: l* o ::load__xml | load__html | load__.le | load__.le__utf8 lprint | print__xml \n| print__xml__utf8 Type regular expressions l dump__to__.le | dump__to__.le__utf8 R::TlRl RlRRlRpo l \nint__of | string__of | atom__of | .atten Pattern regular expressions In.x operators r:: pl(x:: rdlrl \nrlrrlrpo op :: l+ l* l ldiv l mod ll l l l  Sequence content s::Elel!elss Post.x operators po ::? l+ \nl* l?? l+? l* ? C*)http://www.w3.org/TR/REC-xml#NT-Name Conventions: we write [PCDATA] for [Char*], \nwrite [ xy z ] or [ x yz ] or [ xyz ] or \"xyz\" for [ x y z ], and write< x> and < X< x> and > for< \n< X> >. Also, let f(...)... and let fun f(...)... are both allowed instead of let f= fun f(...)... . \nThe types String and Bool are de.ned as [Char*] and true | false, respectively. \n\t\t\t", "proc_id": "944705", "abstract": "<i>We present the functional language CDuce, discuss some design issues, and show its adequacy for working with XML documents. Distinctive features of CDuce are a powerful pattern matching, first class functions, overloaded functions, a very rich type system (arrows, sequences, pairs, records, intersections, unions, differences), precise type inference for patterns and error localization, and a natural interpretation of types as sets of values. We also outline some important implementation issues; in particular, a dispatch algorithm that demonstrates how static type information can be used to obtain very efficient compilation schemas.</i>.", "authors": [{"name": "V&#233;ronique Benzaken", "author_profile_id": "81100297082", "affiliation": "Universit&#233; Paris-Sud, Orsay, France", "person_id": "P639769", "email_address": "", "orcid_id": ""}, {"name": "Giuseppe Castagna", "author_profile_id": "81100388576", "affiliation": "CNRS, D&#233;partement d'Informatique, Paris, France", "person_id": "PP31040104", "email_address": "", "orcid_id": ""}, {"name": "Alain Frisch", "author_profile_id": "81100574832", "affiliation": "CNRS, D&#233;partement d'Informatique, Paris, France", "person_id": "PP17010293", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/944705.944711", "year": "2003", "article_id": "944711", "conference": "ICFP", "title": "CDuce: an XML-centric general-purpose language", "url": "http://dl.acm.org/citation.cfm?id=944711"}