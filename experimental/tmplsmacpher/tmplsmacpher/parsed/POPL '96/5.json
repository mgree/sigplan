{"article_publication_date": "01-01-1996", "fulltext": "\n Using Parameterizecl Signatures to Express Modular Structure hla~li P. Jones Department of Computer \nScience, University of Nottingham, University Park, Nottingham NG7 2RD, England. mpj@cs. nott .ac. uk \nhttp :Ilvuw .CS .nott . ac .uk/Department/St aff/mpj/ Abstract Module systems are a powerful, practical \ntool for manag\u00ading the complexity of large software systems. Previous at\u00adtempts to formulate a type-theoretic \nfoundation for modular programming have been based on existential, dependent, or manifest types. These \napproaches can be distinguished by their use of different quantifiers to package the operations that \na module exports together with appropriate implemen\u00adtation types. In each case, the underlying type theory \nis simple and elegant, but significant and sometimes complex extensions are needed to account for features \nthat are im\u00adportant in practical systems, such as separate compilation and propagation of type information \nbetween modules. This paper presents a simple type-theoretic framework for modular programming using \nparameterized signatures. The use of quantifiers is treated as a necessary, but inde\u00adpendent concern. \nUsing familiar concepts of polymorphism, the resulting module system is easy to understand and ad\u00ad mits \ntrue separate compilation. It is also very powerful, supporting high-order, polymorphic, and first-class \nmodules without further extension. 1 Introduction Large scale software development obtains significant \nbene\u00adfits from the ability to break programs into collections of modules, each of which can be designed, \nimplemented and understood as individual, often reusable, components. For\u00admal studies of the theoretical \nfoundations for modular pro\u00adgramming provide valuable insights into the design of mo~e powerful, and \nmore effective module systems for practical programming languages. During the past decade, there have \nbeen several attempts to provide type-theoretic foundations for modular program\u00adming [23, 16, 21, 7, \n22, 27, 1, 6, 13, 15, 3]. The main propos\u00adals can be distinguished by their use of different constructs \nto describe the type of a module. To illustrate these alterna\u00adtives, suppose that we wish to construct \na complex number Permission to make rligital/hard copies of all or part of this material for personal \nor classroom use is granted without fee provided that the copies are not made or distributed for profit \nor commercial advantage, the copy\u00adright notice, the title of the publication and its date appear, and \nnotice is given that copyright is by permission of the ACM, Inc. To copy otherwise, to republish, to \npost on servers or to redistribute to lists, requires specific permission and/or fee. POPL 96, St. Petersburg \nFLA USA 01996 ACM 0-89791-769-3195101. .$3.50 package that provides a collection of operations: type \nComplex c = { rn!iCart, mkPolar :: Float --+ Float -+ c; re, im :: c -i Float; mag, phase :: c+ Float \n;...} There are three established methods for packaging a collec\u00adtion of operations like this together \nwith a suitable imple\u00admentation type: Existential types (opaque, or weak sums) [23, 5]. In a module of \ntype 3c. Complex c, the existential quantifier conceals the identity of the implementation type c by \nmaking it abstract. This approach allows packages to be treated as first-class values and is fully compatible \nwith separate compilation. However, for the purposes of modular programming, existential are often too \ngood at hiding implementation types because they do not allow adequate propagation of type infor\u00admation \nbetween packages [16]. Dependent types (transparent, or strong sums) [18, 16, 21]. A module of type Xc. \nCornptex c is rep\u00adresented by a pair (~, M) containing the type r used to represent complex numbers and \nan implementation M of type Complex ~ for the complex number opera\u00adtors. The ability to include type \ncomponents in mod\u00adules makes this approach very powerful too powerful in fact to permit compile-time \ntype checking without careful restrictions and extensions to ensure a suitable phase distinction [~] \nand to support features like shar\u00ad ing [14]. Even then, it is still not possible to support true separate \ncompilation [2] or to use modules as first\u00adclass values [22, 12]. Manifest types (translucent sums) [6, \n13] are an attempt to b~idge the gap between the weak and strong sum approaches described above. A module \ntype 3 c = r. Complex c is much like an existential, ex\u00adcept that it exposes the fact that a particular \nimple\u00admentation type r was chosen. An extra rule in the type system can be used to make the implementation \ntype abstract by coercing a manifest type to a stan\u00addard existential. IVe should also mention the treatment \nof modules in Stan\u00addard ML (SML) which provides one of the most powerful module systems in widespread \nuse. The overall design is of\u00adten explained iu te~ms of dependent types, but it is not easy to discern \ntheir use in the formal definition [20]. Instead, the definition uses a semantics based on f~eshly genelated \ntokens called stamps to account for the concepts of sharing and generativity. This approach works well \nas a method for the specification and implementation of a type checker, but seems too operational for \nother purposes. In addition, it h~s proved to be (remarkably difficult to modify or extend ) [6]. The \nadvantages and disadvantages of each of the three approaches described above will be described in more \ndetail in the following section. The important point to note for now is that, in each case, the type \nof a module, package or structure is given by an expression of the form Qt.j(t) for some parameterized \nsignature f(t) and some quantifier Q. Many of the complications that we have referred to above are caused \nby the fact that these quantifiers can be overly protective , limiting the ability to propagate type \ninforma\u00adtion between modules. In this paper, we show how parameterized signatures such as Complex c can \nbe used as the types of modules, treating quantifiers as a separate concern. The result is a simple, \nyet powerful type system for modular program\u00adming. Of course, we still need a mechanism like existential \nquantification to support the ciefinition and use of abstract datatypes, but this can be dealt with in \ndifferent ways and need not be so closely tied to individual modules. Polynlor\u00adphism, represented by \nuniversal quantification, is anothel important part of the type system that allows us: To express sharing \nconstraints and to describe the prop\u00adagation of type information. b To reflect the independence of the \nimplementation of a parameterized module from the implementation of its parameters. e To ailow the definition \nof Dolvmorrd~ic modules. a use\u00adful feature that is not per mi~ted in ShfL [II]. We believe that the use \nof polymorphism is natural and easy to understand, particularly for programmers who are already familiar \nwith the type systems of the core languages of SML, Haskell, or similar languages. Another important \nbenefit of parameterized signatures is that they ensure a clear separation between static and dynamic \nsemantics; the type system allows a programmer to associate a given module with a particular collection \nof types, but module values do not include type components. As a result, we do not have to worry about \nthe problems of establishing a phase distinction, and true separate conlpila\u00ad tion is possible because \nthe way that a module can be usecl is completely specified by its signature. This also means that modules \ncan be treated as first-class values. The remaining sections of this paper are as follows. VI e begin \nin Section 2 with a more detailed analysis of previ\u00ad ous attempts to provide a type-theoretic basis for \nmodular programming. This helps to understand the strengths and weaknesses of the different approaches \nand to ciarify our own goals in the design of a module system. Section 3 describes how parameterized \nsignatures fit into the picture and gives some examples to illustrate their use. A formal presentation \nof the type system is presented in Section 4. Concerns about the suitability of a type system using parameterized \nsigna\u00ad tures as a basis for modular programming are acfclressed in Section 5. Finally, Section 6 concludes \nwith pointers to fw ture work. 2 Background and nlotivation In our introductory comments, we have already \nmentioned several previous attempts to provide a type-theoretic foun\u00addation for modular programming. \nIn this section, we take a more detailed look at each of these proposals, explaining how the design of \neach system has been motivated by the strengths and weaknesses of its ancestors. Our aim is to provide \na survey of related work, and motivation for the use of parameterized signatures. All of this work rests \non fundamental assumptions about the nature and purpose of module systems. Certainly, it would be wrong \nto regard a particular type system as a basis for modular programming unless it provides some, if not \nall, of the following: c A mechanism to support separate compilation and some form of namespace management. \ne A mechanism to enable the decomposition of large pro\u00adgrams into small, reusable units in a way that \nis resis\u00adtant to small changes in the program. A mechanism for defining abstractions. Throughout this \npaper, we argue that the use of parame\u00adterizeci signatures is consistent with such goals. Support for \nseparate compilation is ensured by maintaining a clear sep\u00adaration between types and values, while effective \nprogram decomposition is supported by the use of higher-order and nested polymorphism. Powerful abstractions \ncan be defined using parametrized structures. The system does not pro\u00advide a built-in notion of abstract \ndatatypes but, instead, allows this to be dealt with using other methods. 2.1 Existential types One way \nto formalize the process of hiding the implemen\u00ad tation of an abstract datatype is to use an existential \ntype [23, 5]: type ComplexPkg = Ic. Complex c. Informally, the existential typing indicates that there \nis a type c with operations of type Complex c defined on it. At the same time, it prohibits a programmer \nfrom making any assumptions about the implementation type. Formally, the properties of existeutials are \ndescribed by typing rules, based on stal~dard logical rules for existential quantifiers. The following \nrule is often described as an introduction rule because it introduces a new occurrence of the 3 quantifier \nin the conclusion: r Rkf: [r /t]r  r I-JI: (3f.rJ Note that the implementation type # for the abstract \ntype is discarcied and does not appear anywhere in the conclusion. The requirement that N has a polymorphic \ntype in the following elimination rule ensures that we do not make any assumptions about the now-hidcien \nil~ll>lel~lelltatioll type; N behaves uniformly for all choices of t: rt-~f ,af.r rk N ,vt. T ~ t~ ~vtr \n) r t-open M in N :r Existential types completely hide the identity of inlplemen\u00adtation types. For example, \nthe types c and c in the body of the following expression cannot be identified, even though they come \nfrom the same term cpx of type ComplexPkg: open cpx in Ac. Ax : C ompler c. open cpx in Ac .Ay : Complex \nc . ... To further emphasize this behaviour, suppose that we want to define a package of complex number \narithmetic, con\u00adstructed from an arbitrary implementation of complex num\u00adbers. The obvious way to describe \nthis is to use a function: compArith :: ComplexPkg -+ A rithPkg compArith cpx = open cpx in Ac. Ap : \nComplex c. {add=. ..} where: type ArithPkg = 3a. Arith a type Arith a = {add :: a-a-o; n eg :: a-a;.., \n } Given an implementation cpx of type CornplexPkg, we can use the expression compArith cpx to obtain \na package for arithmetic on complex numbers. Unfortunately, this has no practical use because the typing \nrules for existential make it impossible to construct any values to which the add and neg functions of \nthe resulting package can be applied! The type system does not capture the equivalence of the type of \ncomplex numbers used in cpx and the type of values that can be manipulated by co9npA rith cpx. An alternative \napproach to existential typing, using dot notation in place of the open construct described above, has \nbeen investigated by Cardelli and Leroy [4]. The dot notation allows us to identify the implementation \ntypes of two packages if they have the same name . This avoids the first problem illustrated above, but \nnot the second. Dot notation is also limited by the unavoidably conservative no\u00adtions of same name that \nare needed to ensure decidability of type checking, aud is not very well-behaved under simple program \ntransformations. 2.2 Dependent types Motivated by problems with existential types, MacQueen [16] argued \nthat dependent types provide a better basis for modular programming. In this framework, structures ale \nrepresented by pairs (~, M) containing both a type compo\u00adnent r and a term M whose type may depend on \nthe choice of r. Structures of this form can be viewed as elements of a dependent sum type, described \ninformally by: Xt.j(t)= {(r,M) [M has type j(~) }. The typing rules for dependent sums are standard \n(see [18], for example) and can be written in the form:  r FA4:[~ /qr r t-M, (Zt,f(t)) r * (r ,~): (zt.T) \nr t-snd M : f(f.st M) The introduction rule on the left is very similal to the cor\u00adresponding rule for \nexistential except that the implemen\u00adtation type, r , is captured in the structure (r , M} in the conclusion. \nThe elimination rule on the right indicates that, if AI is a structure of type Xt.f(t),the second compo\u00ad \nthen nent, .snd M, of M has type f(jst M), where fst M is the first component of M. Informally, dependent \nsums are more powerful than existential because of this ability to name the type component fstM of a \nstructure M. However, this also means that the type component of a structure is no longer abstract. In \na sense, a simple treatment of modules using depen\u00addent types is actually too powerful for practical \nsystems because it interferes with separate compilation. More pre\u00adcisely, it makes it more difficult \nto separate compile-time type-checking from run-time evaluation. To illustrate this, we recast the previous \ndefinitions of complex number and arithmetic types using dependent sums to obtain: type ConzplexPkg \n= E cpx. Complex cpx type ArithPkg = Xa. Arith a compArith :; ComplexPkg -+ ArtthPkg compArith c = (Me, \n{add=}) The comp.4r~th function is an example of a parameterized module, or a functor in the terminology \nof SML. At first glance, this definition suffers from the same problems as the previous version using \nexisteutials; the type ComplexPkg + A rithPkg does not reflect the fact that the type components of the \nargument and result structures are the same. How\u00adever, this information can be obtained by carrying out \na limited degree of evaluation during type checkhlg. For ex\u00adample, if c = (r, M), then: fst(comp.4r!th \nC) = jst (T, { add= . ..}) = r. To ensule that static type checking is possible, it is im\u00adportant to \ndistinguish compile-time evaluation of this kind from arbitrary run-time execution of a program. Unfortu\u00adnately, \ntreating a functor as a function of type (Xs.~(s)) + (Zt.g( t)) does not reflect this separation; in \ngeneral, a type of this form may include elements in which the type com\u00adponent of the result depends \non the value component of the argument. As an alternative, Harper, Mitchell and Moggi [7, 24] have shown \nthat a suitable phase distinction can be established by modelling functors from Xs.f(s) to Xt. g(t) as \nvalues of type Zh. (Vs.f(s) g(h(s))) where h ranges over functions from types to types, and describes \nthe compile\u00adtime part of the functor. As the example above shows, it is sometimes necessary to inspect \nthe implementation of a structure to find the value of a type component. Not surprisingly, this means \nthat it is impossible to provide true separate compilation for SML [2]. Even the smartest ~ecompilation \nscheme proposed by Shao and Appel [26] does not permit true separate compi\u00adlation because it delays some \ntype checking, and hence the detection of some type errors, to link-time. The need for type sharing constraints \nin functor defini\u00adtions is motivated by similar problems. Formal parameters cannot be inspected at compile-time \nbecause their actuaf values are not finown until compile time. Instead, identities between type components \nmust be written explicitly using sharing equations. Further extensions to the basic theory of depend \ne]it, types ale needed to deal with this and other ideas inducting genelativit. v, polymorphism, abstraction, \nhigher\u00adorder mod ales, and modules as first-class values. 70 2.3 Manifest types values; for example, \nas function arguments. It is well Recent proposals for translucent sums by Harper and Lillib\u00adridge [6] \nand manifest t~pes by Leroy [13] provide a compro\u00admise between existential typing and dependent sums, \nallow\u00ading the programmer to include additional type information in the signature for a structure. For \nthese systems, we use an introduction rule of the form: Notice that, unlike the previous cases, the implementation \ntype r appears in the inferred type although this can be hidden by coercing it to a standard existential \ntype: Manifest types provide good support for abstraction and separate compilation, although the underlying \ntheories seem quite complex. One of the main technical problems has been the difficulty in providing \nsufficiently general ancf accurate types to capture the jully transparent behaviour of higher\u00adorder functors \nthat is predicted by operational frameworks [27, 17]. In recent work, Leroy has shown how a calculus \nof manifest types can be modified to avoid this problem [15]. His solution requires an extension of the \ntype language to include functor application, further blurring the distinction between types and terms; \nthat is, between static and cly \u00ad namic semantics. This work, and an alternative solution, are discussed \nin more detail in the next section. Parametrized Signatures In each of the approaches described above, \nthe type of a module is given by an expression of the form Qt.~( t) whete ~(t) is a signature, parametrized \nby t,and Q is a cluantifier. The goal of this paper is to show that we can use parame\u00adtrized signatures \nlike ~(t) as building blocks for a module type system and treat quantifiers as a separate issue. For \npractical reasons, it is common to group relatecl func\u00adtions together in a single structure mapping variables \nto values, It follows that a parameterized siguature ?(t) will usually be a record type pairing variable \nnames with appro\u00adpriate type schemes. There are two important aspects of our approach that distinguish \nit from other attempts to use record types to explain modular structure (for example, tile work of Aponte \n[I]): Higher-order polymorphism: In the general case, we wilJ want to use both types and type constructors \nas signature parameters. This is easily dealt with using a kind system as will be discussed in Section \n4. There is no additional burden on the programmer to supply explicit kind information, because this \ncan be inferred automatically from a program text. We already have considerable experience with such \nsystems from work with constructor classes [10] which uses the same ideas; we know that they work well \nin practice.  Nested polymorphism: In the general case, we will want to be able to define structures \nwith polyn~orphic components and to use these structures as first-class  known that standard techniques \nfor type inference do not allow function arguments with polymorphic types. Fortunately, it is fairly \neasy to deal with this in our system, first, by allowing the programmer to supply explicit type information, \nand second, because the use of polymorphism is clearly signaled by the presence of record types. This \nsubject is discussed in more detail in Section 4.4. We can illustrate the use of both of these features \nwith the following signature which provides a representation for mon\u00adads [28]: type Monad m = { btncl \n:: Va. #b. m a+ (a+ m b)-m b; unit :: Va. a_ ma} Note that the kind inference mechanisms referred to \nabove can be used to infer that the parameter m of the Monad signature is a uuary type constructor, while \nthe universally quantified variables a and b in the type of bind represent arbitrary types. 3.1 Polymorphism \nand sharing With the examples of previous sections in mind, we might use a structure of type Complex \nc as an implementation of complex numbers, and structures with types of the form A rifh a to describe \nthe implementation of arithmetic opera\u00adtions on values of type a. The compArith function discussed in \nsome detail abo\\,e can iiow be treated as a polymorphic fuuction: comp.:lrith :: Vt. Complex t+ Arith \nt comp.4rtth cpx = . . . Because the salne variable, t,appeals as a parameter to both the Complex and \nArith signatures, it is clear that the type of values that the arithmetic operations in the result can \nbe applied to is the same as the type of complex num\u00adbers that are provided as an argument; this achieves \nmuch the same result as a type sharing constraint in SML. In ad\u00addition, the fact that tis universally \nquantified ensures that we do not make any assumptions about the implementation of complex numbers. Thus \npolymorphism is useful as a way of expressing the independence of the implementation of a module from \nthe implementation of its imports. Parametrized signatures can also be used to express in\u00adformation about \nthe propagation of type information in ways that are not possible with sharing equations in SML. For \nexample, ill his origilial work on manifest types [13], Leroy comments on the difficulty of handling \na higher-order func\u00adtor: signat.uue S = sig type t;...end f unctor apply(fuuctor ~(r:,$): S structure \na:S):S =fa  The problem here is finding a way to propagate information about the relationship between \nthe tcomponents of the ar\u00adgilrnent ancl result, structures of f, This example has been fu uther addressed \ni]~ recent \\vork on full transparency and higher-ordc,r moclules [s, 15]. Leroy s solution is to use \na manifest type to specify that the t compolient of a structure aPP~Yj a is the same as the t component \nof f a; this requites an extension to allow the use of functor applications in type expressions. There \nis actually another way to solve this problem, as can be seen using parameterized signatures: signature \nS t = sig ... end functor applg(functor f(rc:S t):S u structure a:S t):S u =ja Here, the t component \nfrom theoriginal code is represented by a parameter of the signature S. The definition of the aPphJ functor \nis polymorphic in the variables tand U, and this captures the desired relationship between the types \nof the arguments and result of apply in a direct and concise manner. As a further comment, notice that, \nbecause struc\u00adtures can now be used as first-class values, there is no need to make a distinction between \nfnnctors and ordinary func\u00adtion definitions. In fact, we could have defined apply as an ordinary function: \n:: Va.Vb. (a b)-+ a+ b applyfx = fx aPply If we have already defined structures i and b, of types S \nInt and S l?ool, respectively, then we can use either versiou of apply to determine that apply (Jz. x) \nz has type S Int, and that apply (Ax. b) i has type S Bool. Another advantage of a module system based \non pal an\u00adeterized signatures is the ability to provide a simple treat\u00adment for the definition and use \nof modules with polymorphic types. Recent work by Kahrs [11] shows that simple folms of polymorphism \nthat can be used in the core language of SML are not permitted in the module language. I<ahrs gives examples \nto show why polymorphism at the module level is useful and shows how it can be supported by extending \nthe language with a new, general construct for describing the binding position of type variables. (In \nfact, this same con\u00adstruct could also be used as another alternative to Leloy s recent proposals [15] \nto handle the rIpp/y funct,or discussed above. ) We can illustrate the basic idea by observiug that the \ntype component t in any SML structule matching the signature: signature 1 = sig type t id :: t+t end \nmust be fixed to some specific type, t. As a result, it, is impossible to define a structure .s that \nmatches 1 and sLlch that s. id is the polymorphic identity function. Fortunately, this problem does \nnot occur in our frame\u00adwork and a direct translation of the exalnple here ( and of those in Kahrs paper) \nyields the desired form of polylT~o~\u00adphism without any further work. The corresponding paranl\u00adeterized \nsignature is just: typelt = {td::t-+t} and we can define a structure: 9 :: Vt.I t 9= struct id = Jx. \nx end Not only does this structure have a polymorphic type we can also use the value s.td as a polymorphic \nidentity function of type Vt. t -t.For reasons of space, we have been forced to restrict our attention \nto a very simple example; we refer the reader to Kahrs paper [I 1] for more compelling applications of \nthis form of polymorphism. 3.2 Relationship with manifest types The use of parametrized signatures is \nclosely related to the system of manifest types described in Section 2.3. To un\u00adderstand this comment, \nwe should think of a manifest type of the form 3t = r.r as a kind of local definition , mnch as if it \nhad been written let t= r in r , or as a convenient notation for the result of a substitution [~/t]/. \nNow let us repeat the rule for S-introduction and the rule for coercing a manifest type to an emstential, \nboth of which were discussed in pret,ious sections: r t-M; (3t = ~ .~) r I-M, [r /t]T r EM, (st.r) r \nI-M: (3t.r) From our current perspective, these rules are the same! With this observation in mind, it \nmight appear that we have noth\u00ading to gain by adding manifest types to a type system that afreacly includes \nexistential. However, there are two reasons why such a claim could be considered as misleading: b For \nthe purposes of the underlying type theory, some form of CIUantification is necessary in the proposed \ncal\u00adculi for manifest types and translucent sums to ac\u00adcount for the inclusion of type components in \nmodule values. This is at odds with our approach, which does not allow modules to contain type components. \nOne may a~gue that the syntax for manifest types is better suited to modular programming because it avoids \nthe awkwardness of large numbers of parame\u00adters, and may require fewer changes to the source of a plogram \nif a particular module is changed, for exam\u00adple, by adding type components. However, as we de\u00adscribe \nin Section 5.1, exactly the same benefits can be obtainecl in a simple and elegant fashion with param\u00adet,e[ized \nsign at nres by packaging groups of parameters into recorcl-like structures. Another advantage, in theory, \nof the manifest type no\u00adtation is that a type like at = r.r- might be much more concise and readable \nthan the expanded form [r/t]if r- ~ is a complex type expression or if tappears severaf times in r . \n.Agaiu, in practice, this is not a serious issue because the languages that we are interested in (for \nexample, SML and Haskell) already include facil\u00adities for defining type abbreviations or synonyms, and \nthese can be used to achieve the desired effect.  3.3 Simple Examples SO far, we have discussed the \nmotivation and theoretical ~. pects of parametrized signatures without many examples to show how corresponding \nstructures might be defined. Not surprisingly, there are several different notations that we might chose \nfrom. For the purposes of this paper, and to facilitate easy comparison, we will adopt a SML-like syn\u00adtax. \nHowever, to emphasize the distinction between static and dynamic semantics, we separate out type declarations \nand value definitions, in the style of Haskell. Also, because structures are first-class values and there \nis no distinction between the module and core languages, we can omit the (now redundant) structure and \nfuuctor keywords. It is useful to start with a comparison between local def\u00adinitions (let bindings) and \nstructures: let decls struct in expr decls end The collection of declarations, decls, introduced in \neach of these expressions will be type-checked in exactly the same way. The only difference is that, \nin a let construct the declared values are used immediately in the body expr, while in a structure they \nare packaged up for later use. First, here is an implementation of complex numbers us\u00ading the standard \nCartesian representation: rect Cpx :: Complex (Float, Float) rectCpx = struct mkCart x y = (rjv) mkPolar \nr 0 = (rcos O,rsind) re (x, y) = x . . . end As it stands, the implementation type of rectCpx is captured \nexplicitly in its type. Later, in Section 5.s, we will describe how to make this type abstract, either \ncompletely by ri\u00adsing an existential, or partially by giving it a name without revealing how it is implemented. \nThe next example is a fragment of the defiuitiou of the compArith function, which can be used to construct \na com\u00adplex arithmetic package from an arbitrary complex number package: compArith :: Complex t Arzth \nt compArith c = Struct plus, 21 22 = c.mk Cart (c. re Z1 + c.re z2) (c.zm Z1 + c.i/71 22) ... end Finally, \nthe following definition specifies the structule of the list monad: listMonad :: Monad List listMonad \n= struct unitx = [x] (x: XS) bind f ~ .fI.z-t+(zs bind<f) [] bind f end All of the examples given here \nshould seem straightforward \u00adaud, of course, that is just what we want! Formal development This section \nprovides a brief formal description], of the type system that is put forward in this paper as a basis \nfor mocl\u00ad ular programming. 4.1 Kinds and constructors To support hi~her-order polymorphism, we need \nto allow the use of variables in type expressions to represent, not just arbitrary types, but also type \nconstructors. Following standard techniques, we use a system of kinds, K, to distin\u00adguish between different \nforms of type constructor: .. the kinci of all (monotypes K ; :1 -k, junction kinds Intuitively, the \nkind xl _ KZ represents constructors that take a constructor of kind ~1 and return a constructor of kind \nHZ. For each kind K, we have a collection of constructors CK (including constructor variables CVK) of \nkind K given by: c. ;:= ~. constants / as variables Kt-% .6 applications I :Xt::ut }L signatures, K = \n* Other than requiring that the function space constructor _ be included as an element of C*-*-*, we \ndo not make auy assulnption about the constructor constants x-in the grammar above. The s~nlbol u ranges \nover the set of type schemes de\u00adscribed ~)j~ the glaln mat : .._ T .. c monotgpes ::= Vati ,IS polymorphic \ntypes Ir Note that this corresponds very closely to the way that most type expressions are already wlitteu \nin Haskell. For exam\u00ad ple, Lzst a is an application of the constructor constant List to the constructor \nvariable a. In addition, each constructor constant has a corresponding kind. For example, writing ( ) \nfor the function space constructor and (,) for pairing we have: Int, Float, () :: * Ltst :: *-* ( )1 \n(!) :: *-*+* The syntax for constructors also includes expressions of the form {r, ::a, } of kind *, \nwhich is intended as a convenient ab\u00adbreviation for record types of the form {m ::u1; . ; xn::a~}. 1 \nhese will be used primarily to assign types to structure val\u00adues. Note the use of type schemes rather \nthan simple types; this allows the system to support structures with polymor\u00adphic components. We should \nalso mention that it would be possible, in theory, to encocle module types as tuples without introducing \nthe extra syntax for records. However, labelled tup]es are pe~ haps more convenient in practice, and \nwe have chosen to reflect this directly in our formulation of the type system. Type checker implementations \nusually include tests to ensule that type expressions are well-formed, for example, th~t a particuk)r \nconstructor is supplied with an appropri\u00adate number of arguments. In the current setting, this can be \nreformulated as the task of checking that a constructor exp~essioa has kind *. The apparent mismatch \nbetween the explicitly kinded constructor expressions specified above and the inlplicit kiuding used \nin examples can be resolved by a process of kind inference; that is, by using standard tech\u00adniques to \ninfer kinds for user defined constructors without the need for ]>rograllllner-stlI>plied kind annotations. \nThe salne a[)proach has beeu used with considerable success in both the theory and p,actice of constructor \nclasses [10]. 4.2 Terms For the purposes of this paper, it is sufficient to resttict our attention to \na simple A-calculus, extended with two con\u00adstructs, one for building structures, and another for selecting \nstructure components: M ::= X uariableg MM application [ AX.M abstraction \\ letx=MinlV local clefinttton \n] M.x selectzon I struct x, = AI, end structures The index notation in the last line of this grammar \nis used to reflect the fact that a structure may have multiple conl\u00ad ponents.  4.3 Typing rules With \nthe definitions of the previous sections in place, we can use standard notation to specify the typing \nrules of our system in Figure 1. Note the use of the symbols T and u to restrict the application of certain \nrules to types or type schemes, respectively. The condition that aK @ C h (.4 ) in (x:u)c A (var) Akx:u \nAt-E:r -r At-F :T (-E) AkEF:T Ax, x:r t-E:r (~1) At-E:u .4r, x:uk F:T (let) A1-(letz=Eill F):r At-E:{q:: \na,) ({}E) Ah Ej:ul forallj ({}1) A1-struct x, = E, end : {~, :: u, } AI-E: VCY .U CE C (VE) A + E : [c \n/aK]a AI-E:u a @CV(A) (VI) A E E : VCY .a Figure 1: Typing rules rule (W) is necessary to avoid universal \nquantification ovel a variable that is constrained by the type assignment A; tile expression CV(A) denotes \nthe set of all constructor vari\u00ad ables appearing free in A, 4.4 Type inference Although it really has \nlittle to do with the design of a n~od\u00adule system itself, some readers may be concerned about the effects \nof adding higher-order and nested polymorpl~ism to the type system of a language that is based on the \nuse of type inference. In fact, the first of these, does not cause any difficulty at all because we have \nused a weak form of higher-order polymorphism that avoids the undecidability of higher-order unification. \nThe second, nested polymorphism, requires some form of explicit type information (although nothing more \nthan would be required in an appropriate ex\u00adtension of SML ). 4.4.1 Use of explicit type information \nThe need for explicit type information in programs using records will aheacfy be familiar to SML programmers; \nthe definition of SML requires that the shape of any record a complete list of its fields-can be determined \nat compile\u00adtime. What we have described here is a natural generaliza\u00adtion of this; we require not only \nthe names of all of the fields, but also the types for every field that is referenced. Type annotations \nare not necessary in many simple ex\u00adamples. For example, the following program type checks without any \nadditional type information: j .r = Struct 112 = [~1 U=.c end , y= m.h (m. h rn. u) where m =f!l In \nthis ewe, we can calculate the following types for the components in the structure value in the definition \nof j:   h :: Vt.t--+ [t] ~1 ::a where a is the type of the argument r. Thus: ~ :: Va.a -{h :: Vt.t \n[t]; u :: a} Incl it folloIvs that II has type da.u -[[a]]. [n practice, explicil type mlllotatlons are \nonly required [01 the cfeflnition of lecursive or mutually recursive struc\u00adtures (tvhich are not permitted \nby the SiYf L module sys\u00adtem ) or for functions that manipulate structure values (cor\u00adresponding to ShfL \nfuuctor definitions where explicit type information is also required in Sk IL, or to higher-order or \nfirst-class modules which are not supported by SML). For example, the type signature accompanying the \nfollowing def\u00adinition cannot be onlittecl: mclke Unit ::a, J{oncld m + m a makeUn2t J u = 11.untt x \nOn the other hand, we are flee to stole values of some type lfot~ad m in data stmctules such as lists \nand to use many hig, her order functions, for example Az. map (makeU nit z), without further type annotations. \nSonle may question the need for explicit type information in a language that is based on a Hindley-Milner \ntype system, but we do not believe that this will have any significant impact on programmers: e ,Some \nform of explicit type information is already nec\u00ad essary in many languages based on Hindley-Milner typ\u00ad \ning, FOI example, this inclncles the overloading mecha\u00ad nisms of Haskell; the treatment of records, arithmetic, \nand stluct,ures ill Sk[L; anti the notations used to de\u00ad fine new datatypes in each language.  Explicit \ntype annotations are only recluirecl in situa\u00adtions where they would already be required by pro\u00adgrams \nusing the ShfL module system, 01 in programs that cannot be written with SML modules.  Des~ite the fact \nthat it is not necessarv. the use of typ~ annotations in implicitly typed langiages like hfL and Haskell \nis widely recognized as good programming style , and many programmers already routinely in\u00adclude type \ndeclarations in their source code. The type assigned to a value serves as a useful form of program documentation. \nIn addition, this gives a simple way to check that the programmer-supplied type signatures, reflecting \nintentions about the way an object will be used, are consistent with the types obtainecl by type inference. \n  It is important to find a formal mechanism that can be used to describe when additional type information \nis re\u00adquired for a given program, and to indicate what form it should take. This can already be achieved \nby selecting a particular implementation of the type inference algorithm. However, this risks over-specification \nand we would prefer to find a more abstract, and less operational alternative. 5 Concerns about modularity \nIn addition to formal concerns, there are a number of prag\u00admatic issues that must be addressed in the \ndesign of a mod\u00adule system. We claim that the system of parametrized structures presented here is suitable \nas a module system, but our current prototype is not, sufficiently complete to have allowed us to obtain \npractical experience with it on a large scale programming project. The aim of this section is to do the \nnext best thing by discussing a number of is\u00adsues that have been suggested as important properties for \nmodule systems, and showing how they are dealt ~vitb in tile framework of this paper. 5.1 Signature parameters \nand sharing It is easy to find applications of SML that use modules with fairly large numbers of type \ncomponents; being fo~ced to specify a value for every parameter of the correspoudiug signature in our \nframework would be awkward and i]lcon\u00advenient. The SML notation, and in particular sharing con\u00adstraints, \nare also more robust in the sense that, if extra type components are added to a signature, then we do \nuot neces\u00adsarily have to modify the program as we might, for example, to add an extra parameter to each \nuse of a paramete~ized signature. In fact, if we package parameters together in records, then parameterized \nsignatures can offer the same advan\u00adtages. The only change that we need to make to the formal development \nin Section 4 is to add new syntax for records of constructors: .. K ... .. [ {tt::Kt} record kt n ds \nC6 ::= ... I c{tt::%}~ selection, if K = K, I {t, = Cwj construction,,,= {f,::tit} It is important to \nunderstand the difference bct~veen recolds of constructors { t$ = C Z } and signatnr es {zl: :m~}, both \nof ~vllicll can appear ill types; this is reflected by the fact that the two expressions will be assigned \ndifferent kinds. With this approach, sharing constraints can be under\u00adstood as a form of qualified type \n[9]: pI-og :: (r.x = ..y) + SIG r -SIG s The constraint (r-. x = s. y) appearing here indicates that \nthe x and ~ fields of r and s, respectively, must be equal. Note that we do not need to mention any other \nfields of the r and s records, or even to know that there are any other fields. Another interesting observation \nis that the type of prog does not make any references to term language constructs. This would not be \ntrue in ShIL where the names of functor parameters serve an additional role as labels for the signa\u00adtures \nappearing in a type. This also helps to explain the problems of typing the apptg frrnctor in Section \n3.1 because there is no obvious label for the signature of the result of aPPIYmg ~ to z m the definition: \nf LUICtOL c{pplg(functor ~(x:S):S structure a:S):S =~a IVith our approach, each signature has an obvious \nlabel; the record of constructors that are used as its parameters, As we have already seen, this makes \nit easy to assign a useful and general type to ulJp/y without any extensions to the lal~guage. 5.2 Type \ncomponents In the system that we have been describing in this paper, modules do not inclucle type components. \nInstead, we use siguature parameters to capture relationships between struc\u00adture components and implementation \ntypes. This is a signif\u00adicant departure from some of the previous work, for exam\u00adple, in systems based \non dependent types where type com\u00adponents plrLy a central role. However, we argue that much can be accomplished \nwithout type components. This, we be\u00adlieve, is also more in the spirit of the Hindley-Milner type system. \nFor example, in Milner s o~iginal work [19], types are used as a purely semantic notion, representing \nsubsets of a sernautic domainl not, as any concrete form of value, A key observation is that type definitions \nwithin a mod\u00adule ca~l he lifted to the top-level. For example, consider the followiiig SAIL fragment: \nstructure s = Struct type T = Irlt data List a = Nil ] Cons a (List a) . . . cud Despite appearances, \ntl~e type synonym T and the type con\u00adstructor list are not local to the definition ofs. At any point \nin the program where s is in scope, these type constructors can be accessed by the names s. T and s. \nList, respectively. Rena]ning any references to these types and their corwtruc\u00adtors in the body of s, \nwe can lift these definitions to the top-level, to obtain the following definitions: type s.T = Jnt data \ns.List (1 = s. Nil [ s. Cons a (s. List a) StrLlCtLIr6! .S = . . . In effect, all that the datatype \ndefinitions in the origiuzl SML program accomplish is to define top-level datat.~pes iu which the type \nand value constructor names are decorated with the name of the structure in which they are detiueci. \nIn some situations, renaming is not sufficient to allow type definitions to be lifted to the top-level. \nFOI example, the List datatype in the following functor definition involves a free variable , the type \nz. T, a component of the argument structure x: functor f(z:SIG) : SIG = struct data List = Nil \\ Cons \nz.T Lut ... end The solution in this case is to add an extra parameter to the datatype definition before \nmoving it to the top-level, as shown in the following code fragment. This is just a form of A-1ifting \n[8,25]: data f.List t = f.Nzl 1: $.$;S t f.List f - SIG (f. L,st t) fx . Notice how the parameterized \nsignatures in the type for ~ capture the relationship between the t}~pes involved ill the argument x \nand those involved in the result f .r. Because the form of higher-order polymorphism described in Sectiou \n4. I allows type constructors to be used as both signature and datatype parameters, the same technique \ncan be used to deal with type constructor components of fnnctor algumeuts. In SML, the two functor definitions \nabove ale not ecluiv\u00adalent; SML adopts a notion of generativity, producing a uew type constructor each \ntime the functor is applied to an ar\u00adgument. Thus two definitions: structure s] = f(z) structure sz = \nf(x) will produce structures with incomparable type components. In truth, when we use an SML functor \nto generate ?L uetv datatype, we are in fact constructing a new instance of a fixed datatype, which is \nthen hidden, in essence, by a form of existential quantification. Thele is no way to express the List \ntype produced by applying f to an appropriate algu\u00adment structure in the notation of SML, so we are forced \nto package up instantiation of the actual implementation type, f ..List, and hiding of the resulting \ntype as a single operation. Lifting type definitions to the top-level allows us to ex\u00adpress the type \ncomponents of the result of functor applica\u00adtions; for the example above, if r has type SIG t, then both \nS1 and S2 have type SIG (f. List t). \\\\ e are then free to treat the question of whether we wish to conceal \nthese inl\u00adplementation types as a separate concern. Various methods fok achieving this are described \nili the I\\ext smtiol,. Abstraction In the context of module systems, the telm abstraction is used to \nto describe the ability to hicle information about the implementation of a module and to protect it against \nmisuse, This is an important feature in practical systems but the use of parameterized signatures described \nin this paper does not, itself provide any way of constructing an abstlact datatype. III fact,, \\ve regard \nthis as a distinct advantage because it JI1OWS us to tleat the issue of abstraction as a separate collcelu. \nIJor example, one possibility is to include support for existential types, perhaps using the approach \ndescribed in Section 2.1, or the dot-notation [4], or the combination of type inference and existential \ntyping that has been explored by L&#38;ufer [12]. However, we have also seen that existential types are \nnot always appropriate. Fortunately, it is also possible to extend the language in a modular fashion \nwith constructs that al\u00adlow the programmer to provide a name for a datatype but to restrict the scope \nof its constructors and selectors to a p~rticulzr collection of bindings. This is essentially what the \nabstype construct used in several different languages achieves, and is closely related to the concept \nof Skolemiza\u00adtion in predicate logic. Note that this does not require any changes to the underlying type \ntheory and is perhaps best dealt with at the level of compilation units rather than the core language. \nWe believe t,hzt both of these approaches are useful in their own right,. However, neither coincides \nexactly with the form of abstract datatypes provided by generativity in SML which falls someivhere between \nthe two extremes of named and existentially quantified abstract datatypes. It seems unlikely that, there \nis a modular extension of our system that provides exactly the same form of abstraction as SML. 6 Conclusion \nThcle ale a uunlber of proposals for type-theoretic founda\u00adtions. of modular programming. Some of these \nsystems are very polverful, but require significant and complex extension and modification to account \nfol features that are useful in practice. Our work shows that the ever-increasing complexity that we \nhave seen in recent WO1k to formalize module systems can be avoiJed and that other, simple, expressive, \nand viable options are available. In this paper, we have plesented a simple type system that p[ovides: \ne SuppoLt for hi~her-order polymorphism. * Support for structures with polymorphic components. e .A clear \nsepal atiou between static and dynamic seman\u00adtics. This leads to a module system in which: * Stluctules \nare first-class values. e Higher-order modules (i.e., first-class functors) are ad\u00admitted. * Polymorphic \nnlodules and structures may be defined, * ~, ue bcpal ate co,npilatiou is possible.  e Parametric polymorphism \nplays a major role, making the systeln easier to learn for programmers who are al\u00ad~eady familiar with \nthe core languages of SML, Haskell or similar languages. By contrast) none of these is possible with \nthe SML module system. One of the main topics for future research is to investi\u00adgate the role of implicit \nsnbsumption; that is, the ability to discard elements from a structure as a result of siguatule matching \nin SML. We believe that this can be accomplished using a simple form of subtyping, guided by type annota\u00adtions, \nor otherwise by extending the system with a nlech\u00adanism for controlling the set of bindings that are \nexported from a structure. Acknowledgements Some of the ideas presented in this paper we~e developed \nwhile the author was a member of the Department of Com\u00adputer Science, Yale University, supported in part \nby a grant from ARPA, contract number NOO014-91-J-4043. Thanks to Paul Hudak, Sheng Liang, Bob Harper, \nColin Taylor and, in particular, Dan Rabin, Xavier Leroy, and Graham Hutton for their valuable comments \nand sugges\u00adtions during the development of the ideas presented in this paper. Thanks also to Paul Hudak, \nLinda Joyce and Chih-Ping Chen for their help in preparing the original submis\u00adsion. References [1] Maria \nVirginia Aponte. Extending record typing to type parametric modules with sharing. III Proceedings 20th \nSymposium on Principles of Progranii7ztng Lan\u00adguages. ACM, January 1993. [2] Andrew W. Appel and David \nB. MacQueen. Separate compilation for Standard NIL. In Conference on Pro\u00adgramming Language Design and \nIt71j>Jer>leiztc&#38;tion, Or\u00adlando, FL, June 1994. [3] Sandip K. Biswas. Higher-order functors with \ntranspar\u00adent signatures. In Conference recorcl of POPL 95: ~?nd ACM SIG PLAN-SIGA CT Symposzum on Prlnctplrs \nof Programming Languages. ACM, Jannaly 1995. [4] Luca Cardelli and Xavier Leroy. Abstract types and the \ndot notation. Technical Report report 56, DEC SRC, 1990. [5] Luca Cardelli and Peter Wegner. On nncferstandillg \ntypes, data abstraction, and polymorphism. Comput~ng Surveys, 17(4), December 1985. [6] Robert Harper \nand Mark Lillibridge. A type-t, hcoretic approach to higher-order modules with sharing, In C o/~\u00adjer-ence \nrecord of POPL 94: tlst .4 C:lf SIGPL.4 !V-SIGA CT Symposium on Principles of Programnung Languages, \npages 123 137, Portland, OR, January 1994. [7] Robert Harper, John C. Mitchell, and Eugenio Moggi. Higher-order \nmodules and the phase distinction. Iu Conference record of the Seventeenth .4nnual ACM Symposium on principles \nof programming Lclnguages, pages 341 354, San Francisco, CA, January 1990. [8] T. Johnsson. Lambda lifting: \ntransforming programs to recursive equations. In Jouannaud, eclitor, Proceed\u00adings of the IFIP conference \non Functional Progranlmlng Languages and Computer .4rch~tecture, pages 190-205, New York, 1985. Springer-Verlag. \nLecture Notes il~ Computer Science, 201. [9] Mzrli P. Jones. Quclltfied Types: Theory and Prac\u00adt~ce. \nPhD thesis, Programming Research Group, Ox\u00adforci University Computing Laboratory, July 1992. Pub\u00adlished \nby Cambridge University Press, November 1994. [10]hlarli P. Jones. A system of constructor classes: over\u00adloading \nand implicit higher-order polymorphism. .lour\u00adnal of Functional Programming, 5(l), January 1995. [11]Stefau \nKahrs. First-class polymorphism for ML. In D. Sanuella, editor, Programming languages and sys\u00adtems -ESOP \n9J, New York, April 1994. Springer-Verlag. Lecture Notes in Computer Science, 788. [Iz] I<onstantiu \nL&#38;ufer and Martin Odersky. An exten\u00adsion of ML with first-class abstract types. In ACM SIGPLA N Workshop \non ML and its Applications, San Francisco, June 1992. [13] Xavier Leroy. Manifest types, modules and \nseparate compilation. In Conference record of POPL 94: .21st ACM SIGPLA N-SIG.4 CT Symposium on Principles \nof Progran~m~ng Languages, pages 109-122, Portland, OR, January 1991. [14] Xavier Leroy. A syntactic \ntheory of type generativity and sharing. In Record of the 1994 ACM SIGPLAN iVorkshop on ML and its Applications, \nOrlando, FL, June 1994. [15] Xavier Leroy. Applicative functors and fully trans\u00adparent, hig]ler-order \nmodules. In Conference record of POPL 95: 22nd A CM SIGPL.4 N-SIGA CT Symposium on Principles of Programming \nLanguages. ACM, Jan\u00aduary 1995. [16] David hiacQueeu. Using clepeuclent types to express modular structure, \nIn f.?thACM Annual S~mposium orl Prtrlc tplcs of Progromrnmg languages, pages 277 ?86, St. Petersburg \nBeach, FL, January 1986. [17] David B. MacQueeu and Mads Tofte. A semantics for higher-order functors. \nIu D. Saunella, editor, Program\u00adming languages and systems ESOP 94, New York, April 1994. Springer-Verlag. \nLecture Notes in Com\u00adputer Science, 788. [18] Per Martin-Lof. Constructive mathematics and com\u00adputer \nprogramming. In Logic, Methodology and Philos\u00adophy of S,-tencer VL North Holland, Amsterdam, 1982. [19] \nR. Milller. A theory of type polymorphism in program\u00adming. .Tournal of Computer and Sgstem Sciences, \n17(3), 1978. [20] Robin Milner. Macls Tofte, and Robert Harper. The definitzor~ oj S/andor-d JIL. The \nMIT Press, 1990. [21] John hlit,chell and Robert Harper. The essence of ML. In F,f//lee,,th A C,V S~nlposlunl \non PrinciJdes of Pro\u00adjian~r]~tng Longuages, San Diego, CA, January 1988. John Mitchell, Sigurd Meldal, \nand Neel Madhav. An extension of Stmdarcl hiL modules with subtyping and inheritance, In Conference record \nof the Eighteenth An\u00adrruol ACM Synlposiuln on Principles of Programming Lanouages, Oliando, FL, January \n1991. [~~1 [23] John C. Mitchell and Gordon D. Plotkin. Abstract types have existential type. ACM Transactions \non Pro\u00adgramming Languages and Systems, 10(3):470-502, July 1988. [24] Eugenio Moggi. A category-theoretic \naccount of pro\u00adgram modules. In Summer conference on category the\u00adory and computer science, pages 101 \n117, New York, 1989. Springer-Verlag. Lecture Notes in Computer Sci\u00adence, 389. [25] S.L. Peyton Jones. \nThe implementation of junctional programming languages. Prentice Hall, 1987. [26] Z. Shao and A. Appel. \nSmartest recompilation. In Pro\u00adceedings 20th Symposium on Principles of Programming Languages. ACM, January \n1993. [27] Mads Tofte. Principal signatures for higher-order pro\u00adgram modules. In Conference record of \nthe Nineteenth annual ACM SIG PLAN-SIGACT symposium on Prin\u00adciples of Programming Languages, January \n1992. [28] P. Wadler. The essence of functional programming (in\u00advited talk). In Conference record of \nthe Nineteenth an\u00adnual ACM SIG PLAN-SIGACT symposium on Princi\u00adples of Programming Languages, pages 1 \n14, Jan 1992.  \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Mark P. Jones", "author_profile_id": "81100557950", "affiliation": "Department of Computer Science, University of Nottingham, University Park, Nottingham NG7 2RD, England", "person_id": "PP31081344", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237731", "year": "1996", "article_id": "237731", "conference": "POPL", "title": "Using parameterized signatures to express modular structure", "url": "http://dl.acm.org/citation.cfm?id=237731"}