{"article_publication_date": "01-01-1996", "fulltext": "\n Linearity and the Pi-Calculus Naoki Kobayashi Benjamin C. Pierce David N. Turner University of Tokyo \nUniversity of Cambridge University of Glasgow koba@is .s. u-tokyo .ac. jp bcplOOO@cl .cam. ac. uk dnttldcs \n.gla. ac .uk Abstract The economy and flexibility y of the pi-calculus make it attrac\u00adtive both as an \nobject of theoretical study and as a basis for concurrent language design and implementation. However, \nsuch generality has a cost: encoding higher-level features like functional compnt ation in pi-calculus \nthrows away poten\u00adtially useful information. We show how a linear type system can be used to recover \nimportant static information about a process s behaviour. In particular, we can guarantee that two processes \ncommunicating over a linear channel cannot interfere wit h other communicant ing processes. This enables \nmore aggressive optimisation of communications over linear channels and allows useful refinements to \nthe usual notions of process equivalence for pi-calculus. After developing standard results such as soundness \nof typing, we focus on equivalences, adapting the standard no\u00adtion of barbed bisimulation to the linear \nsetting and showing how reductions on linear channels induce a useful partial confluence > of process \nbehaviors. Introduction A long line of formal systems, from Hewitt s Actors [Hew77, Agh86] to modern \nprocess calculi like Milner, Parrow, and Walker s pi-calculus [MP W92, Mi191], have popularized the idea \nthat a range of concurrent programming idioms can be modeled by simple processes exchanging messages \non chan\u00adnels. Besides their immediate applications in specification and verification of concurrent systems, \nthese calculi have been used as the basis for concurrency features in numer\u00adous programming languages \n(e.g. [Car86, GMP89, Rep91]), as foundations for theoretical study of language features like concurrent \nobjects (e.g. [Jon93, Wa195, HT91, Vas94, KY94, KY95] ), and more recently as core programming languages \nin their own right [PT95a, PT95b, FG96]. The small set of message-passing primitives used by the pi-calculus \nmakes it attractive both as an object of theoret\u00adical study and as a basis for language design and implemen\u00adt \nat ion. However, such generality has a cost: the pi-calculus is an extremely low-level notation. and \nencoding higher-level features (such as functional computation) in pi-calculus can Permission to make \ndigital/hard copies of all or pan of this material for personal or classroom use is granted without fee \nprovided that the copies are not made or distributed for pro~t or commercial advantage, the copy\u00adright \nnotice, the title of the publication and its date appear, and notice is given rhat copyright is by permission \nof the ACM, Inc. To copy otherwise, to republish, to peat on servers or to redistribute to lists, requires \nspecific permiaaion and/or fee. POPL 96, St. Petersburg FLA USA @ 1996 ACM 0-89791-769-3/95/01. .$3.50 \nthrow away potent ially useful information. A common re\u00adsponse to this observation is to consider larger \ncalculi with, for example, functions as prirnit ives. This ensures, at some cost in parsimony, that functions \ncan be compiled efficiently and that the expected high-level rules for reasoning (either formally or \ninformally) actually apply. A more radical ap\u00admoach the one we are exdoriuz here is to avoid adding \n. . new primitives and instead recover information about sp e\u00adcial modes of usage from static type information. \n1.1 Encoding functional computation The following example illustrates how one can encode func\u00adtions and \nfunction application (cf. [Mi190, San93]) in a pure message-passing calculus, and also highlights some \nof the Ditfalls of such encodinm. . Suppose that pluso;e is a communication channel and that there is \nsome running process that repeatedly reads pairs [i, r] from plusone, with i a number and r a channel, \nand resBonds in each case bv sending the value L + 1 on r. (Numb&#38;s can themselves b; implemented \nusing processes and channels, but that need not concern us here. ) We may sBeak of the channel vlusone \nas the location > of the incre\u00admenting process, since plusone is the only means by which other processes \ncan refer to it. To build another function us\u00ading this one, suppose we are given another channel plustwo \nto serve as the location for the new process. We create a process that repeatedly reads pairs [j, s] \nfrom plustwo and uses plusone twice, returning the final result, J + 2, along the channel s: plustwo? \n[j, s]. (V rl, r2) ( piusone![j, r~] I? ,?[k]. pksone![k.r~] \\r-,?[i].s![z]) The replicated input expression \nplus two? [j, s]. describes a process that, each time it receives a pair [j, s] on the chan\u00adnel pkstwo, \nstarts a fresh copy of its body running in par\u00adallel with all the other processes in the system. Each \ncopy of the body (i.e., each invocation of the function) creates two fresh channels, r-l and rZ, using \nthe channel-creation operator v. Then it sends the message [j, rl] on the channel plus one (written piusone![j, \nr-l]) and, in parallel, waits to re\u00adceive a response k on the continuation channel rl (written rl ? [k]. \n. ). When this arrives, it sends the message [k, rz] on plus one and waits for the response 1 along r2. \nFinally, it 358 sends 1 back along the continuation channel s to the original caller. In this example, \nwe used the convention that a function is a process reading messages from some channel ,f, while callers \nof the function are processes that send messages on j. Unfortunately, there is nothing in the pi-calculus \nnotation that prevents another process from disrupting this protocol, either maliciously or accidentally, \nby reading from f instead of writing to it. The asymmetry of roles between function and caller has been \nlost. This lack of structure can lead to errors in more complex programs, and blocks many useful opt \nimitations and program transforrnat ions.  1.2 Arit ies and polarities The simplest, type systems for \nthe pi-calculus [Mi191] just track the arities of channels. in order to prevent situations where the \ntuple of arguments provided by a sender is not the same width as the tuple of bound variables in the \nreceiver, as in z![y. s] I r?[c(, b, c]. P. Each channel z is assigned a type of the form ~ [Tl, . . \n. , Tn]. read channel carrying T1, . . . . T,, . describing the number of values in each message sent \nalong r, as well as their types. For example, the channel pkstwo would be given the type ~[lfunt. $[Nwm]], \nsince it is used to communicate Dairs. where the first element is a number and the second is a channel \nthat is used to send a single number. This type system can be extended in many ways, for instance by \nadding polymorphism [Gay93, VH93, Tur95, LW95b]. Of more interest here, however, is the possibil\u00adity \nof refining it so that the types of channels carry more information about how they are used. For example, \nwe can straightforwardly capture the poiarity {or directionality y ) of communications on channels like \nplustwo by introducing two new channel types: ! [TI, . T.] for channels that (in a given context) can \nonly be used to send tuples of type [TI, , T.], and ? [Tl, . . , T ] for channels that can only be used \nto re\u00adceive [Tl. . Z n]-tuples [PS93, 0de95]. From the point of view of the process implementing the \nincrement function, the type of plusone now becomes ?[lfunt, ![NunL]] that is, it can only be used to \nread messages, wh-ere each message must consist of a number and a channel that can be used to send a \nresponse. From the point of view of the users of this function, p(usone has type ![Nunz, ![NunL]]: it \ncan only be used to send messages, and each message must again con\u00adsist of a number and a channel that \ncan be used for sending numbers. This refinement is not only useful for preventing pro\u00ad gramming mist \nakes; it also yields more powerful techniques for reasoning about programs. For example, in an early \ndraft of [Mi190], Milner had proposed two encodings of the call-by-value lambda-calculus into the pi-calculus. \nUnfor\u00ad tunately, the simpler of the two encodings turned out not to preserve beta-equivalence, because \nof the possibility that the external environment might use channels generated by the encoding in the \nwrong direction [San92]. Pierce and Sangiorgi [PS93] showed how the validity of beta-reduction could \nbe established by typing the encoding using input\u00ad only and output-only channels. In essence, refining \nthe type system reduces the number of contexts in which a given pro\u00ad cess can correctly be placed, thus \nmaking it easier for two processes to be equivalent. However, sore> useful information cannot be captured \nby simple polarized channel types. For example, we cannot express the fact that the result channel that \nis passed to plusone is used just once. Without this information, we are not just ified in replacing \nour plus two example with a more efficient tail-call optimized form: plustwo? [j,s]. (v r) (plwsone!~, \nr] I r?[k], plusone![k, s]) To see that this version does not have the same behavior as the original \nin all contexts, imagine that the increment pro\u00adcess actually signals twice on its result channel. The \ntail-call optimized implement ation above makes this fact visible to its own caller, generating two messages \non the result chan\u00adnel s. whereas the original implementation sends just one message on s. 1.3 Linear \ntypes We propose here a more refined pi-calculus type system, in which channel types have not only polarities, \nwhich deter\u00admine the directions in which thev can be used. but also mul\u00adtiplicities. which control how \nm&#38;ry times they can be used. For example, the type !1 [Nun] describes a channel that can be used \nexactly once to send a message containing a num\u00adber, while ! [iVunL] describes a channel that can be \nused any number of times. In a pi-calculus with linear channel types. we can take the type of plusone \nand plTLstwo, from the point of view of callers, to be !U [Num, !1 [Num]], captur\u00ading the fact that each \nof them can be invoked any nnrnber of times but that the result channel in each invocation is only used \nonce. Under this more accurate typing, the orig\u00adinal and tail-call oDtimized. versions of our .v~ustwo \nexamnle. are provably equivalent in the sense that they behave the same in all well-typed contexts, as \nwe show in Section 6.2. Actually, the refined typings of plusone and plustwo are in\u00adst antes of a general \nobservation: using techniques similar to those in [Tnr95, PS93]. it is easy to show that every result \nchannel used in the pi-calculus encoding of a lambda-term can be assigned a linear type. Not only are \nsome useful equivalences gained in the pres\u00adence of linear types; even the mechanics of reasoning about \nrwocesses can be au~mented, since (in the absence of non\u00ad~ocal operators Iike choice) two processes communicating \nover a linear channel can neither interfere with nor be af\u00adfected by other communicating processes. This \nstands in sharp contrast to the usual situation in the pi-calculus. where the possibility that two senders \ncan be in competition for one receiver or vice versa introduces an essential element of non-determinism. \nThe expression z! [Y] [ .~![s] / .r ?[CL].a! [ ] can reduce either to .r![c] I y![ ] or to .r![y] I ;! \n[ ], and these cannot be reduced further so as to reach a common point. On the other hand, there can \nnever be two senders or two receivers on a linear channel, and so such race conditions can never arise. \nIndeed. linear communicant ions exhibit a r)art ia~ co TL\u00adjluence property reminiscent of the Chnrch-Ross&#38; \nproperty of the lambda-calculus. as we show in Section 4.4. Linear typing potentially enables a variety \nof compiler optimizations. The impact of these optimizatiorls in prac\u00adtice is not yet clear, but work \nis underway on evaluating several in a compiler for a linear variant of Pitt. a program\u00adming language \nbased on the pi-calculus [P T95a. PT95b]. For example, the implementation of communication on a linear \nchannel can be simdifiecl from the current Pitt implementa\u00adtion, since a linear channel can only be in \none of two states when a communication occurs: there may be either zero or one processes of opposite \npolarity waiting to communicate. 359 but never more than one and never another one of the same polarity. \nIn addition, the heap space allocated to a linear channel can immediately be re-used by the receiver \nafter a communicant ion, instead of being reclaimed by garbage col\u00adlection. Linear channel types can \nalso help detect common pro\u00adgramming mistakes. For example, it is often the case that a process must \nsignal on some channel to indicate that it is leaving a critical section. Suppose c is the channel upon \non which we are supposed to signal completion. If the critical section is complex, it is easy to forget \nto signal completion on c. or to simal twice on c. However. if c is given a liuear type. our typing rules \nwill ensure that c is used exactly once. Note that we must be slightly careful about what ex\u00adactly once \nmeans here: typing is preserved by reduction (cf. Section 4.3 ), so a process containing exactly one \nuse of c must either communicate on c and evolve to a process that cannot use c. or else make some other \nsteD. and become a process that still contains one use of c, or else do nothing at all. This guarantees \nthat c will never be used twice. but not that c will eventually be used. since the subprocess in which \nc occurs might diverge or deadlock before it act nally com\u00admunicates on c. For example, the process (VZ \n:$0 [ ] ) :? [ ]. c![ ] creates a fresh channel ;, reads from it, and then sends on c. Since z is fresh, \nthere can never be any sender on ~, and the send on c will never be reached. This possibility of partzal \ndeadlock or divergence in the pi-calculus gives linear typing a slightly different force than in lambda-calculus, \nwhere a linear value must be used unless the whole program fails to yield any result. 1.4 Overview Our \ngoals in this paper are (1) a precise definition of a pi\u00adcalculus with linear types and (2) formal justifications \nof the claims sketched here about typing and program equiva\u00adlences. The novel aspects of this development \nare the techni\u00adcal treatment of linear channel types (which. since they have both input and output ends, \nactuaily comprise two linear capabilities) and, more importantly, the study of behavioral equivalences \nin the presence of linear types. After introducing some notational conventions in Sec\u00adtion 2, we define \nthe typing relation (Section 3) and show that it is preserved by reduction (Section 4); along the way, \nwe remark on properties such as confluence. In Section 5, we adapt the standard notion of barbed congruence \nto the present setting. Section 6 extends the results on strong barbed congruence to the more useful \nweak case, which is used to prove the two versions of plustwo equivalent. Sec\u00adtion 7 discusses related \nwork and Section 8 sketches several variations on the system studied here. Proofs omitted in this summary \ncan be found in an accompanying technical report [KPT95]. 2 Notational Preliminaries The operators introduced \nin the examples above constitute a fragment of the polyadic pi-calculus [Mi191], omitting the choice \nand mat thing operators (as in Milner s mini pi-calculus [Mi190]) and using only asynchronous communication \n(as in Honda and Tokoro s v-calculus [HT91] ). We have argued elsewhere for the pragmatic virtues of \nthis calculus [PT95a], but many oft he techniques we develop should be applicable to any similar system. \n(Of course, the behavioral properties studied in later sections are sensitive to the exact choice of \ncalculus; in particular. partial confluence of linear communi\u00adcations fails in the presence of a general \nchoice operator. ) We also provide booleans and conditional expressions as primi\u00adtives, since their typing \nbehavior interacts with linearity in a slightly special way. 2.1 Syntax The metavariable nt ranges over \nthe muhplzczties 1 and w. The metavariable p ranges over polardzes. Formally, these are subsets of the \nset of capabilities {~, o}, but for readability we use the abbreviations $ = {/, o}, ! = {o}, ? = {i}, \nand I = {}. The set of types is: T ::= pJJ channel types booleans For example, the type !1 [BooZl (i.e. \n{0}1 [Boo!) describes a channel that can be used exactly once to send a message containing a boolean, \nwhile $1 [Boo! describes a channel that can be used once for input and once for output. For brevity, \nsequences of types, etc. are written ~ instead of T1, . . . , T.. A type of the form pl [~], where p \n# 1, is called lnnzted. All other types are unlzmited. An example of an unlimited type is !~ [BOO1, !1 \n[Boo~], which describes a channel upon which we can send any number of messages, but where the compo\u00adnents \nof each message must be a boolean and a linear output channel. The set of process expressions is: P ::= \nPIQ parallel composition r![ij] output atom Z ?[j]. P input prefix I ?*[j]. P replicated input (z/x :T) \nP channel creation if .r then P else Q conditional To avoid writing too many parentheses. we give v \na higher precedence than I and make the bodies of inputs extend as far to the right as possible, so that \nz?*[]. (vy:l [])z![] / y![] means .z?*[]. (((vy: ~W[]) .r![]) I y![]). The inert process is defined as \nO = (vr:$@):z![]. The free and bound variables of a process expression are defined in the usual way, \nwith .Z having scope P in (UX : T) P and jj having scope P in z?[ij]. P and z? [fj]. P.  2.2 Type environments \nA type environment 1? is a set of bindings of distinct vari\u00ad ables to types, containing at least the \nbindings true : Bool and false: BOOL By convention, we write type environments as .z1 : TI, . . . , x~ \n: T~ or just .i:~, omitting the bindings of the booleans. The domain of a type environment, writ\u00adten \ndom(17), is the set of variables it binds. Type envi\u00adronments are extended with bindings for new variables \nby writing I , z : T or 17, i:T. We write I (z) = T to mean that I = 1 1, z : T for some 171. A type \nenvironment is unlimited if each of its bindings is. We always consider a process relative to a particular \ntype environment, whose domain must cent ain all the free vari\u00adables of the process. We regard names \nof bound variables as inessential and perform silent alpha-conversion as neces \u00adsary to ensure that the \nname of a bound variable is always different from the names of free variables and other bound variables. \n360 2.3 Operations on types The defined below, co mbmatton as follows T1 + T2 is of two types (in all \ncases undefined): TI other and T2, than written those T1 men + tio T2. ned is Bool+ BOO~ = Bool Pw[g+ \nr [q = (P u q) g l pl[T]+yl [z ] = (puq)l [T] ifp Rq=O Similarly. the difference of two types T1 and \nT2, written TI T2,is: Bool BOO! = Bool pd [~] q [T] = pw [7] ifq~p pl[T] ql [~] = (p\\q)l [~] ifq<p \nNote that T T is not necessarily a type with I polarity: we use to remove a single tmtance of a capability: \nif the capability can be used an unlimited number of times i.e., if the type is Bool or an unlimited \nchannel type then it is unchanged by the operation. The + operator is extended pointwise to type environ\u00adments \nwit h equal domains: (rl, r: T1)+(r2,2: T2)=(r1+r2),.t:(T1 +T2) We also use + and to add and remove \ncapabilities from a single existing binding in an environment. When 17 = I , z: U.wewriteI +z: Ttomeanr,~ \n:( U+ T)udr-x:T to mean I , .r : (~ T). To account for the effect of using up a value of type T, we write \nT T for the remnant of T. The set of remnants of a type environment A, written Reins(A), comprises all \nthe type environments that can be obtained from A by replacing some subset ,CI : T1, . . . ,X. : T. of \nits bindings by their remnants .C1 : T1 T1, . . . , Xn : Tn Tn. 3 Typing Our linear channel types are \ninspired by Girard s linear logic [Gir87, GLT89], a resource conscious refinement of classical logic, \nand by numerous proposals for functional lan\u00ad guages based on linear logic (e.g. [Abr93, Wad91, Bak92, \nMac94, TWM95] ). A crucial element in these systems is the careful treatment of the typing environments \nunder which expressions are judged to be well typed. For example, to form a pair of two values L, and \nu, under some type environ\u00adment ?J in a linear lambda-calculus, we do not simply check that v and w are \nwell typed in I : rt-t, clJ-r~u)ew r E(t),z(l)Gv x w Inst eacl, we split the type environment in the \nconclusion into two parts, representing the resources consumed by v and w separately: rlkt]cv r2Ewew \nrl +r2 I-(L1,tL)) G t x w Similarly, in a linear type system for the pi-calculus, we must split the type \nenvironment in the rule for parallel conlPosi\u00adtion, (E-PAR) so that typing P I Q consumes the sum of \nthe resources used in the proofs that P and Q are well typed. (We only consider instances of this rule \nscheme where 1 1 + 1 2 is well defined. ) The typing judgement r k P thus acquires additional force: \nP is well typed under the typing assumptions in r and, moreover, uses each linear capability in ?7 just \nonce. Like some linear type systems, we omit the rule of dere \u00ad hction from linear logic. which allows \nan unlimited chan\u00ad nel to be coerced to a linear one. If our type systenl had a sub t yping relation. \nwe would similarly ban the coercion pw [~] < pl [f]. The worlds of linear and unlimited values are never \nallowed to mix. Our typing rules differ in one other technical detail from the usual formulations of \nlinear logics and type systems. Normally, when a type environment is -split . only those variable bindings \nthat are actually used in the right and left sub derivations are included in the respective bhalves of \nr. For example, to check r: !l[], y:! [] E z![] I ~![], we check r: !l[] 1-z![] and y:!l[] ~ y![]. We \nfind it clearer to split type environments by removing just capabilities, leav\u00ad ing variable bindings \nin place> so that the combination op\u00ad erator + is always applied to environments with equal do\u00ad mains. \nTo type z![]~y![] in the environment .Z : !l [], y: !l [], wecheckz-![]in z:! [], y:ll[]andy![] in.r:ll \n[], y:!l[]. To ensure that all the linear bindings in the environment get used somewhere, we check at \nall the leaves of the tYP\u00ad ing derivation i.e., at all inst antes of the typing rule for output expressions \n that all the remaining bindings in the current environment have either rnultiplicit y w or polait y \nI: 17 unlimited (E-OLTT) r+ .t:Y[T] + ij:T t-.V![j] That is, if all the bindings in r are unlimited, \nthen .z![~] is well typed in r augmented (in case z or any of the ij are linear) with the capabilities \nconsumed by the output itself. Note that the capabilities expressed by the types ~ are consumed by the \noutput, since the arguments ij are being passed to the receiver of the communication. Conversely, an \ninput expression is well typed if its body is well typed in an environment where the capability to input \nfrom .r has been removed (if it is linear) and the capabilities associated with the values s to be read \nfrom .r have been added. r, 5:T t-P (E-IN) r+z:?~[T] t-.z?[q. P The rule for replicated input is nearly \nthe same, except that the type of z must be unlimited and, since the body may be instant i at ed many \ntimes, we must ensure that the common part of the type environment does not contain any linear bindings. \nr, ::+ I-P 17 unlimited ( E-RIN) r+X:?@[T] t-.t?*[E]. P The rule for v-expressions adds the given type \nfor .r to the type environment. The side-condition verifies that the sup\u00adplied type is a reasonable one \nfor a channel declaration (i.e. not Bool and not a type that would allow only input or only output, which \nwould be silly). 361 (E-NEw) The rule for checking conditional expressions is a little dif\u00adferent from \nthe others (it corresponds to one of the additive operators of linear logic, while the rest of our operators \nbe\u00adlong to the multiplicative part). We know that the then and else parts of an if-clause will never \nboth be executed. so any linear bindings in the environment should be used up by both parts, instead \nof being allocated to one part or the other. rkpl rkpz (E-IF) r + b: Boolt-if b then PI else PZ The typing \nrelation r 1-P, then, is the least relation closed under the foregoing rules. A process well typed under \nI is called a r-process. Although we are not concerned with algorithmic issues in this paper, it is worth \nnoting that these rules give rise to a typechecking algorithm in a fairly straightforward way. Instead \nof guessing how to split the capabilities in the environment in rules like E-PAR, we pass the whole envi\u00adronment \nto the lefthand premise, crossing off capabilities as they are used up and passing whatever is left to \nthe right\u00adhand premise. There is some cost associated with checking the 1? unlimited side conditions, \nbut a few simple tricks keep this small in practice. 4 Operational Semantics Following [Mi191], the operational \nsemantics of processes is presented in two steps. First, we define a structural congru\u00adence relation \nP D Q, capturing the fact that, for example, the order of the branches in a parallel composition has \nno effect on its behavior. Then we define a reduction relation r > P -+ Q, specifying how processes evolve \nthrough com\u00admunications between their subprocesses. 4.1 Structural congruence Structural congruence plays \nan important technical role in simplifying the definition of the reduction relation. For ex\u00ad ample. we \nintend that both the process z![] 1.z?[ ]. P and the process z? [ ]. P I z! [ ] reduce to P. Since these \ntwo will be structurally congruent, it suffices to write the reduction rule only for the first case and \nto stipulate, in general, that if P contains some possibility of communication, then so does any expression \nstructurally congruent to P. For experts, our structural congruence relation is identical to the usual \none. except that we drop some garbage collection rules. The first two structural congruence rules state \nthat I is commutative and associative. PIQEQIP (P IQ)l R~Pl(Q R) (S-ASSOC) The third rule is called .~cope \nxtTuszon in the pi-calculus literature: (vz:T)P IQa(vz:T)(P IQ) z not free in Q (S-EXTR) Informally, \nit says that the scope of the channel .r, which starts out private to the process P. can be extended \nto in\u00adclude Q. The side-condition ensures that Q does not aLready have a free channel named .r. (This \ncondition can always be satisfied by renaming r, if necessary, before applying the scope extrusion rule. \n) For example, the process ((v~:l~[]) a![z])lw?[c].:![] may be transformed to (v.t:~d[]) (U)![Z ] I w?[z]. \n2![]) Finally, for technical convenience, we allow adj scent channel bindings to be switched: (v.z:T)(vY:U)P \nE (vY:U)(VZ:T)P z # Y (S-SWITCH) Formally, the relation D is the least congruence closed under these \nfour rules, meaning that P s Q if Q can be obtained by applying the rules any number of times, in either \ndirection, to arbitrary subexpressions of P. 4.1.1 Lemma: If P E Q, then 17t-P if I t-Q. 4.1.2 Definition: \nA process (v~:~) (PI I . . I P~) is in nor\u00admal form if PI, , Pm are guarded processes, where a pro\u00adcess \nis guarded if it is an input, output, replicated input. or conditional. 4.1.3 Lemma: For any process \nP there is some Q in nor\u00admal form such that P -Q. Proof: By the associativity and commutativity of I \nand the fact that any (vi:~) not guarded by an input can be moved to the outside of the expression using \nS-EXTR. D 4.1.4 Lemma: If the processes (vt:~) (Pl I . . . I Pn) and ... (z&#38;ti)(Q, I I Q~) u normal&#38;ms \nthat are both struc\u00ad turally congruent to P, then .ii:T is a permutation of j:~, m = n, and, for some \npermutation Q;, , Q;, of Ql, , Q~, P,~Qjforl<Z <n. Proof: Structural congruence neither introduces nor \nelim\u00adinates guarded subexpressions or v-bindings, and does not move subexpressions across input prefixes. \nD 4.2 Reduction The pi-calculus reduction relation is usually written P -+ Q, meaning that P can evolve \nto Q by making a single, atomic step of communication. We use the same basic rela\u00adtion, but annotate \nit with some extra information that we need later for stating properties of the semantics. We write rkp \n_ Q, where 17 is a, type environment (to remind ourselves that we are interested in reduction of well-typed \nprocesses, and so that we can see the way communication uses up capabilities of linear channels), m is \na multiplicity tag (recording whether the communication that leads from P to Q occurs on a linear or \nan unlimited channel), and a can be either the name of a channel, indicating where the communication \noccurs, or else the special tag r, indicat\u00ad ing that the channel on which the cornmunicat ion occurs \nis bound by a v that is not in scope at this point. 362 The most important reduction rule is the one \nfor com\u00admunicant ion. In an environment where x has a channel type of multiplicity y rn, the parallel \ncomposition of an output and an input on x can evolve to the body of the input-process with the arguments \nto the output substituted for the formal parameters. We record m and .Z on the arrow. r,.t:$~ [T] I-d[j] \nI.T?[;].P = [j/;]P (R-COM) Similarly, an output in parallel with a replicated input can reduce to the \nappropriate instance of the body of the in\u00adput plus a fresh copy of the replicated input itself, ready \nto consume fnrt her outputs on z. r,.T:I [T] 1-T![j][$?*[;]. P = [ij/qP[.r?*[z]. P (R-RCohl) If P can \nreduce to Q in isolation, then it can still do so when it is placed in parallel with some other process \n1?: rlkp =Q (R-PAR) rl+r,~pl~= Q\\R Similarly, if P reduces to Q, then it can still do so when placed \nunder a v. However. because of our extra annota\u00adtions, we must divide this rule into two cases. If the \nchannel bound by the v is the very channel r on which the communi\u00adcantion in P has occurred, then we \nchange the label x on the arrow to r and change the polarity of the type of .r in the v-binding to its \nremainder ; this has the effect of changing its polarity to I if its multiplicity is linear, and has \nno effect if its multiplicity is unlimited. I , x: TkPa Q (R-NEw1) rE(vl:T)Pa (vz:T 7 )Q On the other \nhand, if the communication in P occurs on some other channel, then we simply pass the labels through \nthe v unaltered. r,x:T 1-P ~Q x#a (R-NEw2) rt-(v.t:T)PJa (v.r :T) Q An if-expression reduces to either \nits then-branch or its else\u00adbranch. depending on its guard. 171-if true then P else Q ~ P (R-IFT) I k \nif false then P else Q ~ Q (R-IFF) Finally, if P can be rearranged to some P using the struc\u00ad tural congruence \nlaws so that a communication is possible in P , then the same communication is possible in P. p~p r~p \n-Q Qr~Q (R-CONG) rkp =Q When we want to be explicit about the typing environ\u00adment in force after a reduction \nhas occurred, we write 17 F P ~ P i I , where ifa=~ r(= r r r:r(z) ifct=z. { That is, if the label on \nthe arrow is ~, then the binder of the channel x on which the communication occurred is within P and \nthere is nothing to do; on the other hand, if the label is .x, then we must remove an instance of the \ntype of .Z from the capabilities in 17. Asnsual,w ewriteI t-P-+*Qorr EP---i*Q+I to show that P reduces \nto Q in zero or more steps.  4.3 Type soundness The sine qua non of an operational semantics for a typed \nlanguage is that well-typedness must be preserved under re\u00adduction. 4.3.1 Theorem [Subject Reduction]: \nIf 171-P and I E P ~P -i I , then lt P-P . Because our operational semantics is careful to cross out \nlinear capabilities as it uses them, the subject reduc\u00adtion theorem together with the following theorem \nimplies that linear channels are used at most once (in addition to the standard observation that there \ncan never be any arity mismatch during the execution of a well-typed program). We use the shorthand { \n/Q} to stand for either nothing or a parallel composition with a process Q. 4.3.2 Theorem [Run-t ime \nsafety]: A well-typed process cent ains no immediate possibilities for communicant ion fail\u00adure or misuse \nof capabilities. More formally, if r E P and P D (vti:~) (Q{ I R}) then: 1!If Q is an input .r![yl,. \n. . ,~~]lx?[zl,.. . ,u~].Ql or a replicated input .Z![yl, . . . , y~] I X?*[Z1) . . , s~]. Ql, then m \n= n and the binding of z (in either P or I ) has polarity ~. 2. If Q = z![j], then the binding of x has \na polarity in\u00adcluding !. 3 If Q = z?[jj]. QI, then the binding of x has a polarity including ?. 4. If \nQ = z![~] I x![i]. then the binding of ~ has multiplic\u00adity U. 5. If Q = (z?[j]. QI ) I (x?[2]. Q2 ), \nthen the binding of z has multiplicity y u.  6 If Q = x?* [ij]. QI, then the binding of z has multiplic\u00adityy \nw. Finally, it is worth mentioning that the type annota\u00adtions and other labels in this semantics are \nused just for bookkeeping, and do not play any role in determining the possible behaviors of well-typed \nprocess expressions. 4.3.3 Theorem: On well-typed processes, our operational semantics allows the same \nreductions as the standard un\u00adtyped semantics (which can be obtained from ours by eras\u00ading all types, \ntype environments, and labels on arrows). 363  4.4 Partial confluence We now come to the first results \nthat show how linearity affects reasoning about program behavior. The first the\u00adorem below says that \ncommunication on a linear channel is deterministic. The second says: If P is a process that contains \ntwo possible communications. one of which is on a linear channel, then they may be performed in either \nor\u00ad der to reach the same result. In a word, linear reduction is confluent with respect to all other \nreductions. 4.4.1 Theorem: If r 1-P ~ Qand17t-PSR, then QE R. 4.4.2 Theorem [Partial confluence]: If \nr 1-P and 17 b P a P + P, then, for any Q, m, and /3 such that r~pa Q + A and P ~ Q, there is some R \nsuch that AkQ~ Rand I FP %R. The proofs of 4.4.1 and 4.4.2, which occupy the rest of this section. may \nsafely be skipped on a first reading. We begin with one technical lemma. 4.4.3 Lemma: If r E P S P , \nthen there are Q, Q such that one of the following holds, 1.Q = (vti:l~ ) (x![;] I r?[j]. Q,{ I R}) and \nQ = (l/ti, w ) ([ Z/j]Ql{ I R})> where, if w, = z, then Jt ( = LV, JI~,, and otherwise w: =w,; 2. Q \n= (vtirfi~)(z![~] I z?*[~]. QI{ I R}) and Q = (vti:w)([3/i]Q, I z? [j]. QI{ IR}); 3. Q = (vzi,:l~~) \n(if true then QI else Q,{ I R}) and Q = (v~I:W (Ql{ \\ I?}); or 4. Q = (vti:l~) (if fatse then QI else \nQ,{\\ R}) and Q = (vti:viv)(Q2{ I R});  and such that P=Q,P =Q , and rt-Q% Q is derivable without using \nR-CONG. Proof: From the fact that R-CONG and R-NEw 2 can be permuted after the other rules and successive \napplications of R-CO NC; can be combined into one R-CONG. 1 Proof of Theorem 4.4.1: By the reduction \nrules, 17(z) = ~ [~]. From171-P 5 Q and Lemma 4.4.3. P D (vti:ti ) (z![j] 1.r?[3]. Pl{ 1P,}) and Q = \n(vfi:li7) ([j/z] P,{ I P,}). Also, from r F P 5 R and Lemma 4.4.3. P E (vii :li~ ) (r![j ] I.Z?[;]. \nP;{ [P;}) and R D (vi :1~ ) ([~/~]P{{ I P;}). We can assume. without loss of generality. that (vti:l~)(.r![j] \nI .r?[;]. P,{ I P,}) and (vti :w )(z![i] lz?[~]. P{{ I P:}) are normal forms, b ecanse otherwise we can \nobtain normal forms of Pz, P; and then move the v to the outside. By Lemma 4.1.4, iix~~ is a permutation \nof ti :li~ . Moreover, let P;=R1/. ] R,, for guarded processes RI,... , R~. Then either z?[E]. PI -z?[;]. \nP; or .r?[5]. PI s R, for some i, The latter case cannot happen; R, must be in the form z?[ii]. R{, but \nthis contradicts the fact that r k (Vd:li ) (d[j] ]r7[;]. P; I P;) and 17(z) = ll[T]. Therefore, we obtain \n.z?[z]. PI = z?[~]. P;. Similarly, we have Z! [j] D z![~], which implies Q = (vti:l~) ([i//:] <I{ I P2}) \n= (vti :w ) ([J/: ] P;{/ P;}) = R, as required. D Proof of Theorem 4.4.2: Suppose that * and \u00adboth come \nfrom communications with unreplicated inputs. (The cases for replicated input and conditional are similar.) \nFrom the assumption and Lemma 4.4.3, P D (vti:Ti) (x![~] \\.r?[:]. P, I P,) P = (Vti:ti ) ([j/E]P, I \nP,) P a (vii:o) (v![j] I ,?[J]. P3 I P4) Q ~ (vii:ti ) ([~/~]P, IP, ) where W( = W_, W , if w, = .t, \nand otherwise w ; = W,, and where the binding of z in 17 or tixt~ is 11 [~], Also, U: = U, U, if u = \nv, otherwise U; = U,. We can assume, without loss of generality, both (vti,:~~) (z![J] I z?[z]. PI I \nP2) and (vti:~) (v![~] I u?[~]. P, \\ P.) are in normal forms, From the assumption P ~ Q, we have z # \nv. because otherwise by Lemma 4.1.4 and the linearity of x, we have x ![j] ~ ~,![~], ~?[~], PI ~ z?[~], \nP3, P2 D PJ, from which we obtain P D Q. By Lemma 4.1.4, P2 ~ v![~]lv?[~].P~lR, I . . . lR~ P, = .r![ij]/.r?[Z]. \nP; lR~ I . . lR&#38; Pl~P~,Pz~P~,R,~R~(l<l<n) and ti,:ti is a permutation of ii:~T. Let R = (v&#38;liV \n) ([ij/s]PI I [~/;]P, IR, I . . . I R~), where tt~~ = W, W, if w, = .r or w, = u. and otherwise W; =W,. \nThen, AkQ~ R.and I EP % R. D 5 Strong Bisimilarity Our final task is to formalize process equivalence \nin the presence of linear types, ao that we can check that equiv\u00ad alences like those claimed in the int \nroduct ion really hold. We adapt Milner and Sangiorgi s notion of barbed bisimilu\u00ad latton [MS92. San92], \nwhich is suited to the job for several reasons. First, it is naturally a relation on typed processes, \nwhich is crucial here. Second, it is a fairly modular defini\u00ad tion, in the sense that barbed bisimilarities \nfor many differ\u00ad ent calculi can be formulated almost identically; this facili\u00ad tates comparison and \nhelps give confidence that the defini\u00ad tion is natural. And finally, like all varieties of bisimilarity, \n364 it comes with a conductive proof technique. We begin by establishing the basic theory of strong bisimilarity \nin this section; Section 6 extends the results developed here to the more useful case of weak bisimilarit,y. \n 5.1 Basic definitions We begin by defining what tests can be made of a process by an external observer. \nrelative to a certain type environ\u00adment r. 5.1.1 Definition: We say that P exhibits the barb a under \ntype environment I , written P lJ~, if P has the immediate possibility of performing an input or output \naction on the channel a and if the type of a in I is such that the observer can supply the other side \nof the communication i.e., if it is not the case that a is linear and both its input and output capabilities \nare used by P. Formally, P o~ T iff one of the following holds 1. P ~ (v.i:fi) (a![j]{ [ Q}) and either \nT = pw[l? ] or T =  ! [~l; or 2. P D (v.t:~r) ((a?[y]. R.){ \\Q}) and either T = pk[~] or T= ?l[~]: \nor 3. P = (u.i:ti) ((ct? [j].11){ I Q}).  In each case. bnr assumption that all bound variables have \ndistinct names ensures that the channel a cannot be one of the ?. Experts should note that this definition \nof barbs agrees wit h the standard one for the full pi-calculus. Since we are working with an asynchronous \nfragment here, with output atoms instead of output prefixes, we do not actually need to allow observation \nof inputs: we could drop clauses 2 and 3 of the definition and obtain a notion of ob servat ion closer \nto what processes can see about each other. We conjecture that the theory developed in the rest of the \npaper would not be affected by this change. Next, we say that two processes are bisimilar if t hey have \nthe same sets of observable actions and if. for each step that one can make, the other can make a step \nand reach a state that is again bisimilar. The only slight complication is that we cannot require that \nthe two processes be well typed in exactly the same tvDe environment. since each linear communication \nremoves .. capabilities from the type environment and we want to allow the possibility that two processes \nare bisimilar even though they may use up their linear resources in different orders. We deal with this \nby allowing the two to be typed in dif\u00ad ferent environments, provided that both environments can be obtained \nby removing capabilities from some common environment. Formallv. we first define what it means for an \narbitrarv . relation on pairs of processes (and associated type environ\u00ad ments) to be a bisimulation. \nTwo processes are then said to be bisimilar if they are related by some bisimulation. Re\u00ad call that R \nems(A) is the set of environments obtained from A by changing some bindings in A of the form z : pi [~] \nto .c:[l [T]. 5.1.2 Definition [Strong barbed bisimulation]: A rela\u00ad tion l?~ { ((AP, P). (AQ, Q)) / \nAP, AQ E Rem.s(A) AAPFP AAQEQ} is a A-bisimulation if, whenever ((AP, P), (AQ, Q)) E 7?, 1.P.lj~ iff \nQJJ~; 2. Api-P-+ P 4A>imphes AQ FQ+Q +A~ and (( A~, P ), (A~, Q )) c R for some Q : and 3. AQk QbQ d \nA~implies Ap FP--+P -IA> and (( A~, P ), (A~i Q )) E R-for some P .  Two A-remnant processes P and Q \nare A-bzstmdar, written P AA Q, if (( AP. P), (AQ, Q)) G R for some AP, AQ E Reins(A) and some A-bisirnulation \nR. By itself, barbed bisirnulation is a rather weak relation. In order to make it interesting, we need \nto close it under substitution and parallel composition. The resulting rela\u00adtion, called barbed congruence, \nwill later be seen to be a full congruence for all of the other process constructors. 5.1.3 Definition: \nGiven two type environments A and I . a A-17-substitution a is a function from dorn(A) to dorn(I ) such \nthat, for each y c dom(I ). the type r(~) can be written as (Xrc~O~(~)~.(Z)cVA(z)) + U for some unlimited \nCT. Intuitively. a A-17 substitution is one that, whenever it maps some channels XI, . . . , r,, G dom(A) \nto the mrne channel y c dom(I ), ensures that v has at least the combination of the capabilities of the \nj. 5.2 Congruence 5.2.1 Definition: P and Q are A-p? econ.gruent, written P W: Q, if, for any A-17 \nsubstitution a and @ F R such that @ + r is well-defined. R I UP ~e+r R I uQ. That is, Ni is the largest \nbisimulation closed under well-typed substi\u00adtutions and parallel composition. Two A-processes P and Q \nare A-congruent, written P WA Q, if l W! Q. That is, two processes are congruent if they are precongruent \nand are well typed in the same type environment. As a simDle examde, it is easv to check that the Dro\u00ad \n. cesses .c![] I g![] I z?[]. y?[]. o and .~![] I y![] I y?[]..z?[]. O are con\u00adgruent under--the environment \nA = z : ~ [], y: 11 []. (And that thev are not cormruent under the environment A = z:Iw[], y : Io[].) \nFortunately, closing under parallel composition and sub\u00adstitution is enough: if two processes are congruent, \nthen placing them in any process context again yields congruent processes. 5.2.2 Theorem [Congruence]: \nThe relation WA is pre\u00adserved by all the process constructors. 365 6 Weak 13isirnilarity 2. Ap E P -+ \nP -i A; implies AQ l--Q --+ Q i A~, with p D P , Q s Q , and (( A~, P ), (A~, Q )) c As usual, the definitions \nof strong barbed bisirnulation and 7?. for some P , Q , Q ; and congruence have a more useful, but somewhat \nmore com\u00adplex, counterpart, called weak bwtmulatzon, where we drop 3. AQ 1-Q + Q i A~ implies AP 1-P \n-+ P -1 A;, the requirement that the two processes being compared must with P s P , Q = Q , and (( A~, \nP ), (A~, Q )) c proceed in lock-step and instead allow each to take zero or 1? for some P , P , Q . \nmany steps to match a single step of the other. The main result in this section is Example 6.2.3, which \nformalizes the Two A-remnant Drocesses P and 0 are weak A-bisimilar claim in the introduction that the \ntwo versions of the plus-up to~. if AP, A~ 6 Renl.s(A) and~(Ap, P), (AQ, Q)) E 7? two process are behaviorally \nequivalent. where 1? is a weak A-bisimulation up to D . 6.1.4 Lemma: P and Q are weakly A-bisimilar \niff they are 6.1 Definitions weakly A-bisimilar up to E. The definitions of weak barbs. weak bisimulation, \nand weak When we prove that the given two processes are weakly congmence are obtained from the strong \nones in the stan\u00ad barbed bisimilar, it is often hard to compare weak barbs dard way. The weak barbs \nof a process are the strong barbs since we need to consider all the possible reduction sequences. of \nall of its derivatives. Weak bisimulation (P ~~ Q) is The following theorem allows us to compare strong \nbarbs in\u00ad obtained by replacing the second ---i in clauses (2) and (3) stead of weak barbs, which substantially \nsimplifies proofs of of Definition 5.1.1 with its reflexive, transitive closure, + . weak barbed bisimilarity. \nLet Barbs~ (P) be the set of strong Weak precongruence (.P =~ Q) and congruence (P ~. Q) barbs of P, \nand WBarbsL(P) the set of weak barbs of P. are formed by closing under substitution and parallel com\u00adposition. \nThe refined definitions read as follows: 6,1.5 Theorem: A relation 6.1.1 Definition [Weak barbed bisimulation]: \nA rela-7?~ { ((AP, P), (AQ, Q)) tion \\ AP, AQ c Reins(A) 1? ~ { ((Ap, P), (AQ, Q)) AAP F-P I Ap, A~ c \nRem.s(A) AAQ+Q} AAP F-P AAQ !-Q} is a weak A-buzm.ulation if, whenever ((AP, P), (AQ, Q)) c 7?, is a \nweak A-bzsimulation if, whenever ((AP, P), (AQ, Q)) G l?, 1. Barb~*(P) Q WBarb.sA(Q) and Ba~6sA(Q) ~ \nWBarbs* (P) l. Apb P~*P U~iff A~l-Q--i*Q u:; 2. Apk P--i P 4A~implies AQ l-Q--+* Q +A~ 2. Apk P+ P -i \nA>implies AQk Q-+ Q AA~ and (( A~, P ), (A~, Q )) c 1? for some Q ; and and (( Aj, P ), (A~, Q )) c R. \nfor some Q ; and 3. AQk Q+~ -i A~implies AP FP-+*P -IA> 3. AQl-Q~Q +A~implies Ap kP-*P +A~ and (( A \np, P ), (A~, Q )) c 13 for some P . and (( A~, P ), (A~, Q )) < %? for some P . Proof: It suffices to \nshow that if ((AP, P), (AQ, Q)) ~ Two A-remnant processes P and Q are weakly A-bisinzilaT, R, then WBarbs~(P) \n= WBarbsA(Q). Suppose that a c written P &#38;~ Q, if the pair ((AP, P), (AQ, Q)) ~ 1? for WBaTbsA (P). \nThen there is some P such that Ap E P --i* some Ap, AQ G Reins(A) and weak A-bisimulation R. P + A> and \na E Barbs~(P ). By condition 2, there is a matching reduction sequence AQ k Q --i Q 4 A; with 6.1.2 Definition: \nTwo A-remnant processes P and Q are (( A>, P ), (A&#38;, Q )) c 7?. By condition 1, a c WBarbsA(Q ). \nweakly A-precongruent, written P %; Q, if for any A-A substitution a and r H R such that I + A is well-defined, \nSince WBarbsA(Q ) ~ WBarbs~(Q), we know that a is in WBarbsA (Q), and so WBarb$A(P) ~ WBarbs~(Q). Simi-R \nI UP &#38;r+LI R I uQ. Two A-processes P and Q are weakly larly, WBa&#38;A (P) ~ WBarbsA (Q ). 1 A-congruent, \nwritten P Z&#38; Q, if P z; Q.  6.1.6 Theorem: XA is a congruence. In the arguments that follow, it \nis convenient to use weak bisimulation up to ~ to prove that two processes Now the partial confluence \nof linear reduction (Theo\u00adare bisimilar, instead of using &#38;~ directly. rem 4.4.2) can be expressed \nin a more useful way: 6.1.3 Definition [Weak BisimuIation up to ~]: 6.1.7 Theorem: If A E P &#38; Q, \nthen P XI Q. A relation This theorem essentially says that linear reduction does not R < { ((AP, P), \n(AQ, Q)) change the weak precongruence class of a process, so that, [ Ap, AQERem.s(A) A Apl-P A AQl_Q} \n to show that P %. Q, itsuffices to show that P and Q are is a weak A-bisimulation up to G if, both well \ntyped in A and P XI Q for some linear reduct whenever ((AP. P), (AQ, Q)) ~ 7?, P of P. (In the case of \na linear r-reduction, we just need to show that P and Q are congruent.) We use the next lemma l. Apk \nP~*P U$ iff AQl-Q~*Q Q$; to prove the theorem. 366 6.1.8 Lemma: If 17 F P. r + P a P , 17 c Rern~(A), \nand P ~$, then P J,&#38;. Proof of Theorem 6.1.7: Suppose that u is a A-A sub\u00adstitution and I k R, with \nI +A well-defined. Then r+ A t\u00adl,(u, T/r)o RIuP ~ R \\ oQ. Therefore, we must show that if AFPZ Q. then \nP &#38;* Q. Let 7? = {(( A , Q ), (A , Q )) lA\\Q-*Q +A AQ ~Q } u {(( A , P ), (A , Q )) IA EP---+*+A+A \n AA +P ~ Q <A } We show that %? is a weak A-bisimulation. Since the first set in the definition of 7? \nis itself a weak A-bisimulation, it suffices to check only the case ((A!, P ), (Ah, Q )) c {((A , P ), \n(A , Q )) I A t-P --+ P +A and A E P A Q -i A }. 1. We must show that l?arbs~ (P ) ~ WBa~bs~ (Q ) and \nBurZIsa(Q ) ~ WBaTbSA(P ). Suppose that Q U$. Then. A F P ~ Q .@. Conversely, if P .l&#38;, then Q v: \nby Lemma 6.1.8 and A 1-P ~ Q . 2. Consider any reduction A~ E P % P . If P z Q . then it is matched \nby Ah 1-Q --+* Q . Otherwise, by Theorem 4.4.2, there is some Q such that A! 1\u00adpll &#38; Q 4A; and A&#38; \nEQ Z Q . There\u00ad fore, the reduction is matched by A~ 1-Q ~ Q and (( A~, P ), (A~, Q )) cR. 3. If A~l--Q \n+Q 4A~, then A~ kP % Q * Q -i A: and ((A&#38;, Q ), (A&#38;, Q )) appears in ??.. D  6.2 Application \nWe now apply the foregoing theory to show that the two ver\u00adsions of the plus-two process presented in \nthe introduction are weakly congruent. These processes are nontrivial, and the proof of their equivalence \nrequires some care; we begin by introducing two technical lemmas to help structure the argument. 6.2.1 \nLemma: If P &#38;~ Q and A c Rems(I ), then P &#38;r Q. We write 17 -H-x: T to mean either l?, z: T if \nz @ clorn(I ) or I +.z:T if r c dom(r). 6.2.2 Lemma: If A,y:!l [&#38;] F P and A -H-r:!l[~] is well \ndefined, then  [~/dp ~A+J.!l[?,(w:r[m)(Pl ?J?[Z].2![2]). 6.2.3 Example: Let r= Phdluo~.?W[Num, !1 [Num]], \nphone: !ti[Num, !1 [Num]]. Then the two versions of the plus-two process given in the introduction are \nweakly congruent. Proof: Let A = plusone: !ti[Num, !1 [Num]], s : !1 [Num], k : Num. By Theorem 6.1.6, \nit suffices to show that (VT: ~ [Num]) (ptusone![k, T] I T?[l]. s![[]) %~ plwone![k. s]. Because both \nside of processes are well-typed under A, it suffices to show that (m: $ [Num]) (phsone![k, T] I T?[l]. \ns![i]) xi plu.sone![k, s]. Moreover, because substitution can only rename variables (note that all bindings \nin A are incompatible with each other), it suffices to show that if @ 1-Q and @ + A is WC1l defined, \nthen $1I (m: $l[Num]) (phsone![k, r-]/r?[2].s![1]) =~+A Q I plusone![k, s]. We show that R = {((@ +A, \nQ I (m: ~ [Num]) (phssone![k, r] [ T?[l]. s![1])), (@ + A, Q I plusone![k, s])) J@ FQ+* Q +@} u %3+A \nis a weak (0 + A)-bisimulation up to D , from which the desired result follows, since ((~ + A, Q I (m: \nJ [Ntsm]) (plusone![k, r] I T?[l].s![l])), (~+ A, Q Iplusone![k, s])) c R. Take the pair ((@ + A, Q I \n(m: ~l[Num]) (plusone![k, r] I r?[l]. s![Z])), (@ + A, Q Iplusone![k, s])) from the first part of R. \nWe check the three conditions in Theorem 6.1.5. I. Barbse+A(Q I (vr: ~l[.Mum])(phone! [k, r]/T?[l].s![l])) \n= BadMe+A(Q ) U {plusone} = Barbse+~(Q I plusone![k, s]) 2. Consider any reduction from Q I (VT: ~ [Num]) \n(plusone![k, r] I r?[l]. s![1])) to R. There are two possibilities: either the reduction occurs inside \nQ , or an interaction occurs between Q and (VT: 11 [Num]) (plusone![k-, r] I r?[l]. s![I]). In the former \ncase. R D Q I (vr: $ [Num]) (phssone![k, r] I T?[Z].S![l] ) @ >Q +Q . This reduction is matched by ~ \n + At-Q [ plusone![k, s] A Q I plusone![k, s]. In the latter case, reduction occurs on the channel phtsone: \nQ E (v&#38;~V) (plusone?[n, t].P 10) R s (vtil:ti ) (UT: $ [Num]) ([k/n, ~/t]P I O \\ r?[l]. s![t]) 367 \nThen the reduction is matched by E) + A E Q I pksone![k, s] --+ (Uti:ti -) ([k/?7, s/t]P  I o) = [s/7-] \n(uti:ll) ([k/n, r/t]P [ O) because (vti:ll ) (vr: $ [Nu7n]) ([k/n, r/t]P [ O I r?[l].s[l]) &#38;@/+ A_,i,L,o.e \n(Vivlv) ([k/?2, s/t]P / o) by Lemma6 .2.2, which implies (vti:Ji )(m : ~1[fVti7n])r/t]P I O \\ 7-?[1].s[1]) \n([k/n, &#38;@+*(Z/titm)([k/rL5/t]P\\ o) by Lemma 6.2.1. 3. Consider any reduction El + A E Q I ph,sone![k, \ns] -+ R. There are again two cases: either reduction oc\u00adcurs inside Q , or interaction occurs between \nQ and pluscme![k, s]. In the former case, R ~ Q I piasone![k, s] and 0 k Q -+ Q . This is matched by: \n@ + A k Q I (vr: ~l[Num]) (phuone![k, r] 17 ?[1]. s![1]) + Q I (w: I [Num]) (plasone![k, r] lr?[~]. s![l]). \nThe argument for the latter case is similar to part (2). These three conditions imply that 7? is a weak \n( @+ A)\u00adbisimulation up to -. D Related Work The spur for our work came from a paper by Takeuchi, Honda, \namd Kubo [THK94] describing a modified pi-calculus whose svntax guarantees that certain channels are \nshared between just t~o processes. The motivating intuitions be\u00adhind this calculus have the flavor of \na type system, suggest\u00ading that one might achieve the same effect in a standard pi-calculus by introducing \na refined type system instead of altering the syntax. (In fact. earlier work by Honda [Hon93] did adopt \na type-theoretic perspective related to ours. ) Our type system shares a good deal with linear type syst \nems for lambda-calculi and related programming lan\u00adguages [Abr93, Wad91, Hod92, Bak92, Mac94, TWM95], \nIn particular, linear typing has recently been proposed as a framework for syntactic control of interference \nin sequential programming languages (cf. [OTPT95] ). In the world of process calculi, there have been \nsev\u00ad eral papers on analyzing channel usage using eflect sys \u00adtens. Nielson and Nielson [NN95] proposed \na method for inferring the maximum usages of channels by applying the effect system for CML [NN94], while \nKobayashi, Nakade, and Youezawa [KNY95] proposed a method for approxi\u00admating the number of receivers \nthat can ever try to read from a channel simultaneously, which in particular can be used to detect channels \nwhose maximum queue length is 1. Our type-based analysis and these effect-based analy\u00adses both seem to \nhave advantages and disadvantages. The effect -based met hods can znf er usage information, whereas currently \nour type system only checks consistency of the usage information it is given. On the other hand, in ap\u00adproaches \nbased on effect analysis, channel usage is analyzed with respect to regions, which may be aliased to \nan in\u00adfinite number of channels, degrading the accuracy of the analysis. Alt bough Kobayashi et al. tried \nto overcome this defect to some degree, the resulting analysis is difficult, and some algorithmic aspects \n(especially time complexity) are left open. Abramsky, Gay, and Nagarajan [AGN94, GN95] describe a typed \ncalculus of synchronous processes. Although their calculus ensures deadlock-freedom. its expressive power \nis much more limited than ours in the sense that there must be exactly one sender and receiver for each \nchannel, and mobility (passing channels as data along channels) cannot be exmessed. F;nally, a type system \nreminiscent of ours though not explicitly incorporating the notion of linearity has been developed \nby Steffen and Nestmann [SN95] for the purpose of analyzing confluence in pi-calculus processes arising \nin the semantics of concurrent object-oriented programs. (The same problem has been tackled by Liu and \nWalker using purely semantic techniques [LW95a]. ) Our analysis is also related to the one used by Niehren \n[Nie96] to guarantee uni\u00adform confluence in a pi-calculus fragment with only repli\u00adcated inputs. 8 Variants \nand Extensions We have focused here on a fragment of the original polyadic r-calculus of [Mi191], omitting \noutput guards (processes of the form z![ij] P), and the choice operator +. Although our type system and \nreduction semantics can easily be extended to the full m-calculus, some of the results we developed must \nbe treated carefully. For example, in the presence of output guards, Example 6.2.3 is not valid. (However, \nif we allow output guards only wit h nonlinea~ channels, the example does remain valid. ) Similarly, \nif we add choice to our cal\u00ad culus. Theorems 4.4.2 and 6.1.7 do not hold. but we can recover them by \nallowing choice only on processes guarded by nonlinear communications. A great variety of other resource-aware \ntype systems, tracking different kinds of usage information, can be formu\u00ad lated using similar techniques. \nIndeed, many of these sys\u00ad tems can actually be encoded in our simple system of linear types. One trivial \nvariant of the present system is obtained by replacing linear by o,fine channels, which must be used \nd most once instead of exactly once. Since, as we have seen. it is actuallv . . Dossible to throw awav \nlinem channels without using them (by placing them in a deadlocked subprocess), the linear and affine \nvariants of the system have nearly iden\u00ad tical properties. One advantage of the affine variant is that \nit allows garbage collection: if the process (v.r : ~W[~]) z?[J]. Q is well typed in some context 17, \ntheu O is well typed in the same context. A more interesting variant introduces a type of replicated \nchannels, which can be used arbitrarily often for output but only allow a single, replicated input. Communicant \nion on replicated channels enjoys the same partial confluence prop\u00ad ert y as linear communication. We \nconj ect m-e that this prop\u00ad erty can be used to show, for example, that /3-reduction pre\u00ad serves weak \ncongruence in the encoding of the call-by-value A-calculus. To handle replicated channels formally. we \nin\u00ad troduce a new multiplicity T (either replacing or augmenting 368 the linear multiplicity 1). Wedefine \nthe operator +for the new multiplicity by p [7]+q [T] =(p Uq)r[7] ifi@ pnq and modify the side conditions \nof the rules E-IN and E-RIN as follows: r, 2@ t-P m#r (E-IN) r+ T:?~[r] t-T?[;].P r,@ t-P 17 unlimited \nm=rorw (E-RIN) r+r:?m[T]EX?*[q. P Another variation on linear channels is linearized chan\u00adnels, which \ncan be used multiple times but only in a sequen\u00adtial manner: an output r! [j]. P can reuse z again for \noutput in P, while an input z?[jj] .P can reuse z for input in P. Linearized channels can be encoded \nusing linear channels and recursive types. Write ~ [~] for the type of linearized channels repeatedly \ncarrying tuples of type T. This type is encoded as follows in terms of linear types: [~ [i]] = ] [T, \n! [], (p<Y. ? [T. !l[], l-])] That is, a linearized channel is encoded as a linear chan\u00ad nel carrying \ntuples with types T plus two extra parameters: a channel used to trigger the continuation of the output \n(needed because we are translating from a language with output guards to one without) and another channel \nof nearly the same type as the originzd linearized channel (more pre\u00ad cisely, of the type of the input \nend of the original linearized channel ), which replaces the original in the continuation of both sender \nand receiver. Input and output expressions on a linearized channel .x c ~* [~] are encoded as follows: \n[.r![j]. P] = (v.r : [f*[T]]) (UC: $1[]) .c![ij, c, .T ] ] c?[]. [[.r /T]P] [r?[j]. P] = .r?[j, c, 1 \n]. (C![] I [[r /X]P]) Linearized channel types can be viewed as a variant on a fragment of Honda s types \nfor dyadic interaction [Hon93]. Combining the intuitions behind replicated and linearized channel types \nyields another important usage analysis, which Milner calls unique handling [Mi191]: a channel is uniquely \nhandled if it has a single replicated receiver and, at any given moment. at most one sender. That is, \nthe capability to send must be explicitly passed from one client to another, so there can never be any \ncontention between clients for access to the service provided by the receiver. Of course, there is no \nreason in principle why our analY\u00adses should distinguish only between zero, one, and arbitrar\u00adily many \nuses of a channel: we could just as well introduce the additional multiplicities 2, 3, etc. But, at least \nin our present experiment al testbed (the Pitt language), there are few benefits to be gained from this \nrefinement: profiling of Pitt programs indicates that the great majority of channels are either used \nunfoundedly or linearly. This is largely due to the fact that functions are literally compiled as processes \nin Pitt, so a very large number of channels are used either as locations of functions or as result channels. \nApplying any of these type systems to a full-scale pro\u00adgramming language raises a number of pragmatic \nissues. Al\u00adthough typechecking (even, with some help from program\u00admer annotations, partial type inference \n) is relatively unprob\u00adlematic, it is quite difficult to add linear type information without cluttering \nthe language with extra distinctions that the programmer must explicitly bear in mind. Work is un\u00adderway \non exploring these issues in a linear variant of Pitt. Acknowledgements Kobayashi is partially supported \nby Grant-in-Aid for Scien\u00ad tific Research of Japan No, 06452389 and 07780232. Pierce is supported by \nEPSRC grant GR/K 38403. Turner is sup\u00ad ported by EPSRC grant GR/J 527099 ( Save space with linear types \n). We have profited from lively discussions with Robin Milner, Phil Wadler, and the Monday Interruption \nClub at Cambridge. C6dric Fournet, gave us useful com\u00ad ments on an earlier draft. References [Abr93] \nSamson Abramsky. Computational interpret a\u00adtions of linear logic. Theoretical Computer ScZ\u00adence, 111(1 \n2):3 57. April 12 1993. [Agh86] Gul A. Agha. Actors: a Model of Concurrent Computation m Distributed \nSystems. MIT Press, Cambridge, MA. 1986. [AGN94] Samson Abramsky, Simon J. Gay, and R. Na\u00adgarajan, Interaction \ncategories and the founda\u00adtions of typed concurrent programming. In De\u00adductzve Progrum Design: Proceedings \nof the 1994 Marldoberdorf Summe, School, NATO ASI Se\u00adries F. Springer-Verlag. 1994. [Bak92] Henry G. \nBaker. Lively linear lisp look ma, no garbage! ACM Sigplan Notates. 27(8):89 98. 1992. [Car86] Luca \nCardelli. Amber. In Guy Cousineau, Pierre-Louis Curien, and Bernard Robinet, ed\u00aditors, Combinators and \nFun.cttonal Prograrnmtn,g Languages, pages 21 47. Springer-Verlag, 1986. Lecture Notes in Computer Science \nNo. 242. [FG96] C6dric Fournet and Georges Gonthier. The re\u00adflexive chemical abstract machine and the \njoin-Calculus . In Principles of Programming Lan\u00adguages, January 1996. [Gay93] Simon J. Gay. A sort inference \nalgorithm for the polyadic ~-calculus. In Proceedings of the Twen\u00adtieth ACM Symposium on Principles of \nPTogTam\u00adnung Languages, Jannary 1993. [Gir87] Jean-Yves Girard. Linear logic. Theoretical Computer .$ \nczence, 50:1-102.1987. [GLT89] Jean-Yves Girard, Yves Lafont, and Paul Tay\u00adlor. Proofs and Types, volume \n7 of Cambridge Tracts m Theoretical Computer Science. Cam\u00adbridge University Press. Cambridge, 1989. [GMP89] \nAlessandro Giacalone. Prateek Mishra. and San\u00adjiva Prasad. Facile: A Symmetric Integration of Concurrent \nand Functional Programming. In\u00adternational Journal of parallel Programming, 18(2):121-160, 1989. 369 \n[GN95] Simon Gay and Rajagopal Nagarajan. A typed calculus of synchronous processes. In Proceed\u00adings \nof IEEE Symposium on Logzc m Computer Science, 1995. [Hew77] C. Hewitt. Viewing control structures as \npat\u00adterns of passing messages. Arti.cial Intelligence, 8:323-364, 1977. [Hod92] J. S. Hodas. Lolli: An \nextension of AProlog with linear cent ext management. In D. Miller, edi\u00adtor, Workshop on the A Prolog \nProgTanzming Lan\u00adguage, pages 159 168, Philadelphia, Pennsylva\u00adnia, August 1992. [Hon93] Kohei Honda, \nTypes for dydadic interaction. In CONCUR 93, volume 715 of Lecture Notes in Computer Sczence, pages 509-523.1993. \n[HT91] Kohei Honda and Mario Tokoro. An object calculus for asynchronous communicant ion. In Pierre America, \neditor, Proceedings of the Eu\u00adropean Conference on Ob~ect -Oriented Program\u00adming (ECOOP), volume 512 \nof Lecture Notes m Computer Sczence, Geneva CH, 1991. Springer-Verlag , Berlin, Heidelberg, New York, \nTokyo. [Jon93] Cliff B. Jones. A pi-calculus semantics for an object-based design notation. In E. Best, \neditor, Proceedings of CONCUR 99, LNCS 715, pages 158 172. Springer-Verlag, 1993. [KNY95] Naoki Kobayashi, \nMotoki Nakade, and Akinori Yonezawa. Stat ic analysis of communication for asynchronous concurrent programming \nlan\u00adguages. In Second Internaizona~ Statzc Anal\u00adysis Symposium (SAS 95), volume 983 of Lec\u00adture Notes \nm Computer Science. pages 225-242. Springer-Verlag, 1995. [KPT95] Naoki Kobayashi, Benjamin C. Pierce, \nand David N. Turner. Linearity and the pi-calculus, 1995. Technical report, Department of Informa\u00adtion \nScience, University of Tokyo and Computer Laboratory, University of Cambridge. [KY94] Naoki Kobayashi \nand Akinori Yonezawa. Type\u00adtheoretic foundations for concurrent object\u00adoriented programming. In Proceedzn.g. \nof ACM SIGPLAN Con~erence on Object-Orzented Pro\u00adgramming Systems, Languages, and Applications (O OPSLA \n94). pages 31-45, 1994. [KY95] Naoki Kobayashi and Akinori Yonezawa. To\u00adwards foundations for concurrent \nobject-oriented programming types and language design . TheoTy and Pr-actzce of Object Systems, John \nWiley &#38; Sons. 1995. to appear. [LW95a] Xinxin Liu and David Walker. Confluence of pro\u00adcesses and \nsystems of objects. In Proceedings of CAAP 95, pages 217-231. Springer, 1995. [LW95b] Xinxin Liu and \nDavid Walker. A polymorphic type system for the polyadic ~-calculus. In CON-CUR 95: Concurrency Theory, \npages 103-116. Springer, 1995. [Mac94] [Mi190] [Mi191] [MPW92] [MS92] [Nie96] [NN94] [NN95] [Ode95] \n[OTPT95] [PS93] Ian Mackie. Lilac: A functional programming language based on linear logic. Journal of \nFunctional PTogrammmg, 4(4) :395 433, October 1994. Robin Milner. Functions as processes. Research Report \n1154, INRIA, Sofia Antipolis, 1990. Final version in Journal of Mathematical Structures an Computer Science \n2(2):119-141, 1992. Robin Milner. The polyadic m-calculus: a tuto\u00adrial. Technical Report ECS LFCS 91 \n180, Lab\u00adoratory for Foundations of Computer Science, Department of Computer Science, University of Edinburgh, \nUK, October 1991. Proceedings of the International Summer School on Logic and Algeb7a of Specification, \nMarktoberdorf, August 1991. Reprinted in Logzc and A~gebTa of Spec\u00adification, ed. F. L. Bauer, W. Brauer, \nand H. Schwichtenberg, Springer-Verlag, 1993. R. Milner, J. Parrow, and D. Walker. A calculus of mobile \nprocesses (Parts I and II). Information and Computation, 100:1 77, 1992. R. Milner and D. Sangiorgi Barbed \nbisimula\u00adtion. In W. Kuich. editor, 19th ICALP, volume 623 of LectuTe Notes in Computer .$ czence, pages \n685-695. Springer Verlag, 1992. Joachim Niehren. Functional computation as concurrent computation. In \nPrmczp /es of Pro\u00adgrammmg Languages. January 1996. Hanne Rlis Nielson and Flemming Nielson. Higher-order \nconcurrent programs with finite communication topology. In PToceedmgs of POPL 94: 21st ACM SIGPLAN-SIGA \nCT Sym\u00adposium on Prnzctples of Programmmg Lan\u00adguages, PoTtland, @-egon, pages 84 97, January 1994. Hanne \nRiis Nielson and Flemming Nielson. Static and dynamic processor allocation for higher-order concurrent \nlanguages. In TAP-SOFT 95: Theory and PTactice of Software De\u00advelopment, volume 915 of Lecture Notes \nin Com\u00adputer Sczence, pages 590 604. Springer-Verlag, 1995. Martin Odersky. Polarized name passing. In \nProc. FST &#38; TCS, LNCS. Springer Verlag, De\u00adcember 1995. P. W. O Hearn, M. Takayama, A. J. Power, \nand R. D. Tennent. Syntactic control of interference revisited. In MFPS XI. conference on Mathe\u00admatical \nFoundations of PTogTam Semanttcs. vol\u00adume 1 of Electromc Notes in Theoretical Com\u00adputeT Sczence. Elsevier. \nMarch 1995. Benjamin Pierce and Davide Sangiorgi. Typing and subtyping for mobile processes, In Logzc \ntn Computer Sczence. 1993. Full version to ap\u00ad pear in Mathematical Structures in Computer Sctence. \n370 [PT95a] Benjamin C. Pierce and David N. Turner. Con\u00adcurrent objects in a process calculus. In Takayasu \nIto and Akinori Yonezawa, editors, Theory and PTactice of Parallel Programming (TPPP), Sendai, Japan \n(Nov. 1994), number 907in Lec\u00adture Notes in Computer Science, pages 187 215. Springer-Verlag, April 1995. \n[PT95b] Benjamin C. Pierce and David N. Turner. Pitt: A programming language based on the pi\u00adcalculus. \nTo appear, 1995. [Rep91] John Reppy. CML: A higher-order concurrent language. In Programming Language \nDesign and Implementation, pages 293 259, SIGPLAN, ACM, June 1991. [San92] Davide Sangiorgi. Expressing \nMobility m PTo\u00adce.ss Algebras: First-Order and Higher-Order Paradigms. PhD thesis, Department of Com\u00adputer \nScience, University of Edinburgh, 1992. [San93] Davide tions tional Sangiorgi. as processes. Conference \nAn investigation In Proc. Ninth on the Mathematical into func-Interna-Foun\u00ad dations of Programming Semantics \n(MFPS 93), volume 802 of Lecture Notes in computer Sci\u00adence, pages 143 159. Springer Verlag. 1993. [SN95] \nMartin Steffen and Uwe confluence. Interner Bericht formatik VII, Universitat 1995. Nestmann. Typing \nIMMD7-xx/95, In-Erlangen-Nurnberg, [THK94] Kaku Kubo. typing pages Notes Takeuchi, Kohei Honda, and Makoto \nAn interaction-based language and its system. In proceedings of PARLE 94, 398 413. Springer-Verlag, 1994. \nLecture in Computer Science number 817. [Tur95] David N. Turner. The n-calulus: morphism and implementation. \ning Ph.D. thesis, LFCS, University Types, poly\u00ad1995. Forthcom\u00adof Edinburgh. [TWM95] David N Turner, Philip \nWadler, and Christizm Mossin. Once upon a type. In Functional Pro\u00adgramming Languages and Computer Architec\u00adture, \nSan Diego, California, 1995. [Vas94] Vasco T. Vasconcelos. Typed concurrent ob\u00adjects. In Proceedings \nof the Eighth EUTO-pean Conference on. Object\u00adoriented %ogram\u00adming (ECO OP), volume 821 of Lecture Notes \nin Computer Science, pages 100 1 17. Springer-Verlag, July 1994. [VH93] Vasco T. Vasconcelos and Kohei \nHonda. Princi\u00adpal typing schemes in a polyadic pi-calculus. In Proceedings of CONCUR 93, July 1993. Also \navailable as Keio University Report CS-92-004. [Wad91] Philip Wadler. Is there a use for linear logic? \nIn Proceedings of A CM Symposzurn on Partial Eval\u00aduation and Semantics-Based PTogram Manipula\u00adtion, pages \n255 273. 1991. [Wa195] David mation Walker. Objects and Computation, in the ~-calculus. 116:253 271, \nInfor\u00ad1995. \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Naoki Kobayashi", "author_profile_id": "81100603931", "affiliation": "University of Tokyo", "person_id": "PP39074467", "email_address": "", "orcid_id": ""}, {"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "University of Cambridge", "person_id": "PP14111353", "email_address": "", "orcid_id": ""}, {"name": "David N. Turner", "author_profile_id": "81100229526", "affiliation": "University of Glasgow", "person_id": "PP31033046", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237804", "year": "1996", "article_id": "237804", "conference": "POPL", "title": "Linearity and the pi-calculus", "url": "http://dl.acm.org/citation.cfm?id=237804"}