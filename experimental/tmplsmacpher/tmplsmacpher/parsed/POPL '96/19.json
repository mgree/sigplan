{"article_publication_date": "01-01-1996", "fulltext": "\n Steven M. Kurlander Charles N. Fischer* University of Wisconsin Madisont Abstract Past register allocators \nhave applied heuristics to allocate registers at the local, global, and interprocedural levels. This \npaper presents a polynomial time interprocedural register allo cater that models the cost of al lo cat \ning registers to pro\u00ad cedures and spilling registers across calls. To find the min\u00ad imum cost allocation, \nour allocator maps solutions from a dual network flow problem that can be solved in polynomial time. \nExperiments show that our interprocedural register allocator can yield significant improvements in execution \ntime. Introduction Effectively using registers can significantly decrease the ex\u00adecution time of a program. \nCommon policy in current com\u00adpilers using only intraprocedural register allocation is to spill at call \nsites registers that might be used by both the caller and callee[CHKW86]. The goal of rmterprocedural \nregister allocation is to min\u00adimize execution time given the register requirements of in\u00addividual procedures \nin a program. Based on these require\u00adments, an interprocedural register allocator selects which registers \nare available to each procedure and, correspond\u00adingly, around which calls registers are spilled. An inter\u00adprocedurai \nalIocator aims to spill registers across infrequent calls (or not at all). This paper presents both a \nsave-free interprocedural reg\u00adister allocator (which never spills registers across calls), and an interprocedural \nregister allocator that spills registers as necessary across calls. Our save-free allocator models the \ncost of allocating registers to procedures and finds a mini\u00admum cost allocation. A profile is used to \nestimate the benefit of allocating different levels of registers to each procedure. Our interprocedural \nregister allocator that spills regis\u00adters across calls minimizes the cost of allocating registers to \nprocedures as well as spill cost. The cost of spdling a register This work was supported by NSF grants \nCCR-9122267 and CCR\u00ads!50.5922 t AUtllOrs, ~~dress: Dept of Computer Sciences, 121O w Dayton St . Mzdison, \nWI 53706. Email {smk,fiscller}&#38;s.wise.edu Permission to make digital/hard copies of all or part of \nthis material for personal or classroom use is granted without fee provided that the copies are not made \nor distributed for profit or commercial advantage, the copy\u00adright notice, the title of the publication \nand its date appear, and notice is given that copyright is by permission of the ACM, Inc. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires specific permission and/or fee. \nPOPL 96, St. Petersburg FLA USA @1996 ACM 0-89791-769-3/95/01. .$3.50 across a call is a function of \nthe call s frequency, Register spilling allows registers to be reassigned along a path in the call graph \nwhen profitable. To generate a save-free interprocedural register alloca\u00adtion of a call graph, we use \nCameron s algorithm for finding a maximum weight k-antichain in a partially ordered set [Cam85]. To find \na maximum weight k-antichain, Cameron maps solutions from a dual minimum cost flow probleml, A dual minimum \ncost flow problem can be transformed into a minimum cost flow problem and solved in polynomial time. \nIn Section 4, we generalize our allocation model to allow for register spilling across calls. To find \nthese allocations, we map solutions from a more general dual minimum cost flow problem. Our approach \ncan be used with conventional compilers that translate one procedure at a time. Each procedure may be \ntranslated using any of the well-known, high-quality, intraprocedural register allocators [B CKT89] [CK91] \n[Pl?92]. Then using profile information our minimum cost interpro\u00adcedural register allocator determines \nhow many registers each procedure will be given and where spills will be placed. A minimum cost interprocedural \nregister allocation may not allocate registers to all locals in a procedure. For each of these procedures, \nan intraprocedural register allocator will generate a revised allocation using the procedure s inter\u00adprocedurally \nallocated registers and the temporary registers available to each procedure. The algorithm we describe \ncan be part of a more general interprocedural register allocator. Such an interprocedural allocator can \nselect global candidates to be allocated reg\u00adisters across procedure calls. In addition, an interprocedu\u00adral \nallocator need not follow a predefine parameter passing convention. This allows the allocator to pass \nadditional pa\u00adrameters in registers as well as to choose which registers to use (the registers selected \nneed not always be caller-save). 2 Related Work Past interprocedural register allocators have relied \non heuris\u00adtics. Wall [Wa186] observes that two procedures that are not simultaneously active can share \nthe same registers for their locals. With this in mind. Wall groups locals that can be Cameron refers \nfo the dual minimum cost flow problem as a. dual tramportation systen? of linear inequalities. When we \ntransform this clual problem into the primal problem, tile ne%work flow graph is uot bipartite and, thus, \ntbe ~rinlal problem is not a transportation prob\u00adlem However, the primal problem is a minimum cost flow \nproblem. We, therefore, refer to the dual rLs a dual minimum cost flow problem. assigned a common register. \nThe locals of a procedure are always placed in different groups than those of its descen\u00addants and ancestors \nin a call graph. In addition, each in\u00adterprocedurally shared global is placed in a singleton group, as \nglobals are allocated registers throughout the entire pro\u00adgram. Groups are then allocated registers based \non the total frequency in which their members are referenced. Walls al\u00adlocator may not find the best \nallocation with respect to his model, since he allows locals infrequently referenced to be grouped together \nwith locals frequently referenced. Steenkiste and Hennessy [SH89] design an interprocedu\u00adral register \nallocator for LISP programs. Their approach allocates registers to locals in a bottom-up fashion over \nthe call graph. Since the,y find that LISP programs tend to spend their time in the leaf procedures of \na call graph, their method first allocates registers in the leaves lVhile registers are available, a \nprocedure is assigned registers that are not already assigned to its descendants in the call graph. When \nthe registers are exhausted, they switch to an intraprocerlu\u00adral allocation, This approach may introduce \nregister spilling around calls in frequently executed procedures near the top of a call graph. The approach \nwe propose avoids register spilling across frequently executed calls. Santhanam and Odnert [S090] perform \ninterprocedural register allocation over clusters of frequently executed pro\u00adcedures. Their heuristic \naims to move spill code to the root node of a cluster. The approach we propose examines the en\u00adttre call \ngraph to generate a minimum cost allocation spilling registers as inexpensively as possible. 3 Save-free \nInterprocedural Register Allo\u00adcation In this section, we describe a save-free interprocedural reg\u00adister \nallocator that determines the number of registers to al\u00adlocate to the locals of each procedure for acyclic \ncall graphs (cycles in call graphs normally force sa~ es across recursive calls). Our solution is based \non Cameron s algorithm for finding a maximum weight k-antichain in a partially ordered set, [Clam85]. \nIn Section 4, we generalize our allocation model to compute a minimum cost allocation that may include \nreg\u00adister spilling across calls in (possibly cyclic) call graphs. For-each procedure, we assume an intraprocedural \nregis\u00adter allocator has already grouped locals that can be assigned the same register. We refer to each \ngroup as a regtster can\u00addzdate. An interprocedural register allocator selects which candidates are allocated \nregisters. Each procedure has a few temporary registers available. Locals assigned these reg\u00adisters do \nnot require interprocedurally allocated registers. These locals are correctly allocated at register allocation \ntime. Initially, we assume that a register candidates is live across all calls in a procedure. However, \nin Section 6 we distingmsh between candidates not live across calls and can\u00addidates live across one or \nmore calls. Our interprocedural register allocator may give fewer registers to a procedure than the number \nof candidates it has. An intraprocedural register allocator can produce a vahd allocation when given \nfewer registers. The mtraproce\u00addural Tegister allocator will spill values internally as neces\u00adsary. IV{. \nassume there is a positive benefit associated with allocating a register to a register candidate. As \nmore can\u00addidates are allocated registers the benefit of the allocation increases (and, equivalently, \nthe cost associated with the allocation decreases). In our interprocedural register allo\u00adcation, a benefit \nestimates the decrease in loads and stores from allocating a register to a candidate. Given k regis\u00adters, \nour save-free interprocedural register allocator selects an allocation in which the benefits of register \nallocated can\u00addidates sum to a maximum (across all procedures). That is, registers are given to procedures \nthat benefit the most, 3.1 Defining a partial ordering on the can\u00ad didates of a call graph Let G = (P, \n,?3) be an acyclic call graph, where P is a set of procedures and E is a set of call edges. We represent \nthe calls from procedure p. c P to P., c P as a single edge in the call graph. Let S be the set of register \ncandidates in P. For procedure P. c P, let C(P,, ) be the set of register candidates in Po. We define \nthe following partial order (~) on candidates in an acyclic call graph such that there is an ordering \nbe\u00adtween two candidates if and only if they cannot be assigned the same register in a save-free interprocedural \nregister al\u00adlocation: 1.In the partial order, assume the relation between can\u00addidates in a procedure \nis an arbitrary chain; that is, there is an ordering between every two candidates in the same procedure. \n2. Let c, &#38; C(P,, ), CW c C(PW), and P,, # PW. If there is ., ,, a path from procedure P to PW, then \nc? ~ CU. For Ci,Cj E,S,c, Ec1isdefined as~i~CJand c,# Cj. Given (1) and (2), there is an ordering only \nbetween two candidates of the same procedure or between candidates in separate procedures connected along \na path in the acyclic call graph. Thus, either CU c CW or CW E c,, for candidates c~, c,, E S if and \nonly if cU, and c. cannot be assigned the same register in the call graph. In Figure 1(a), procedure \nP,,, has two candidates, p and q, and procedure Pc has two candidates t and v. A partial order on the \ncandidates in the call graph appears in (b). We assume the ordering between p and q is q c p and the \nordering between t and v is v c t. Since Pu calls P,., q c m and p K m, and since P,, calls P,z,v c m \nand tCm. Throughout Section 3, we assume (~) refers to the par\u00adtial order defined by (1) and (2). 3.2 \nInterference Graphs Let 7 be a set on which there is some partial order. Define a comparability digraph \nD(T) as having an edge from u to v when u is less than v in the partial order [Cam85]. If q is the set \nof candidates of a call graph G and the partial order is ( ~), then D(S) is the interference graph for \na save-fre~ interprocedural register allocation of G. if there is an edge between CU and c., in D(,$), \nthen either c, and c,, are can\u00addidates in the same procedure, or c,, and c, are candidates in procedures \nalong a path m the call graph. Candidates c,, and c,, cannot be assigned the same re.gmter. Since a partial \norder defines the interference relatlon blJ\u00adtween candidates m a save-free mterprocedurai register allo\u00adcation, \nthe interference graph 1s translt,ive. The interference graph for mtraprocedural register allocation, \nhowever, can Partial Order on Candidates in G Pw (a) (b) Figure 1: An example call graph, allowing \nfor multiple candidates in a procedure, and a partial order on the candidates of the call graph be non-transitive[ \nCha82]. In an intraprocedural register al-then a maximum weight k-antichain in S corresponds to a location, \ntwo live ranges that interfere are assigned different k-register save-free interprocedural register allocation \nwhose registers. Assume live ranges la and lb interfere and live elements sum to the maximum benefit; \nthat is, a save-free ranges lfi and 1. interfere. Live range la does not necessar-mimmum cost interprocedural \nregister allocation using at ily interfere with lc. In a save-free interprocedural register most k registers. \nallocation, if procedure P calls P, and Pw calls Pz, then In Figure 2(c), assume k = 2 antichains. .4mong \nthe execution will normally return to P.. To avoid overwriting possible allocations of candidates to \nantichains, the choice the registers hve across a call, candidates in P , PW, and Pr with the greatest \nbenefit allocates candidate m to an an\u00ad are all assigned different registers. tichain (Az), and candidates \nq and tto an antichain (Al). Figure 2 displays a call graph G, the partial order (~) Each antichain maps \nto an arbitrary, but different register. on the set of candidates, S, of G, and the comparability In \nFigure 2(a), m is assigned register TZ, and q and t are as\u00addigraph D(S). The number below a candidate \nis the benefit signed register rl. Since candidates p and 7J are not allocated of allocating a register \nto that candidate. Since q E p and registers, an intraprocedural register allocator will spill reg\u00ad p \nc m, there is an edge in D(S) between q and p, p and m, isters as necessary in procedures PW and Pz to \ngenerate a and q and m. These three candidates can never be assigned valid register allocation. the same \nregister. Candidate tcan be assigned the same register as p or q, as there is no edge joining either \nt and p ortand q. 3.4 Finding a maximum weight k-antichain sequence 3.3 Antichains A k-antichain can \nbe partitioned into a k-antichain sequence. A k-antichain sequence A = (Al,. ., , Ak), where A, ~ S, \nWe call a set of nodes in a digraph independent if none of and if c, 6 AP, CJ E Aq, and c, c c,?, then \np < q [Cam85]. the nodes in the set are joined by an edge. Let S be a Each A,, 1 < i ~ k, corresponds \nto an antichain if c, K c~. set and assume some partial order on S. An unticham in then c, and Cj cannot \nbe members of the same antichain. S is an independent set of nodes in II(S). For example, Given the 2-antichain \n{q, t, m}, and the partial order t E m in Figure 2(c), {p, t}, {p, v}, and {q, v} are antichains, as \nand q c m, then antichain Al = {q, t} and Az = {m}, as the candidates in each set are not joined by \nan edge in the shown in Figure 2(c). comparability digraph. A k-anticham is the union of at most Given \npartial order (~) on a set of candidates in a call k antichains [Cam85]. Both {p, t, q, v} and {p, t, \nv} are 2\u00adgraph G, we can view each antichain A,, as an abstract ant Ichains. register R,. An abstract \nregister is an equivalence class of Let S be the set of candidates of a call graph G and candidates that \ncan be assigned the same register. Each assume partial order (~) on S. II(S) represents an interfer\u00ad \nabstract register maps to a different hardware register. ence graph for a save-free interprocedural register \nallocation Let CU c C(PO), CW E C(PU, ), and assume CW c cl-there of G and, thus, the candidates of an \nantichain in D(S) can is a call path from P. to PW or Pu = PW. Assume we assign be assigned the same \nregister. A k-anticham in D(S) is a set registers to candidates m a topological ordering over the of \ncandidates that can be allocated using at most k registers partial order if CW E CV, then we visit c,, \nbefore CW. If we in G. assign register l%. to c,,, then CW can only be assigned register Assume each \nregister candidate CJ c S has a positive l?p, such that O < p < q. This register ordering models the \ninteger wel,ghting, Wj. Let (~) be a partial order on S. If sequence in which antichains are assigned \nto candidates. V+ is the benefit of allocating a register to candidate CJ ~ Call graph G Partial Order \non Comparability Digraph Candidates in G 1 t (rl) (a) Figure 2: A call graph G, a partial order on the \ncandidates To find a maximum weight k-antichain sequence in a partially ordered set, we solve the following \ndual minimum cost flow problem[Cam85]. Dual Variables 1> ~J OrcJ s Constraints A.1 forcj CS, OSXJ, gJ \n~k. A.2 if c%,cl E S and c%c cl, then x, +yJ ~ k. A.3 forcJ6S, zJ+yJ~k+l. Ob]ectwe Function  A.4 Maximize \n~C, ~~ W3 * (xj + y~). For each candidate in c1 ~ S, there is a pair of integer dual variables, XJ and \nyj, and an integer weight w~ >0 in the dual minimum cost flow problem. A solution to this dual minimum \ncost flow problem maximizes the objective function A.4, given the constraints A. 1 A.3 on the dual vari\u00adables. \nWhereas a minimum cost flow problem minimizes an objective function, a dual minimum cost flow problem \nmaxi\u00admizes an objective function. If a candidate Cf is allocated to an antichain, the variable XJ will \nspecify the antichain that Cj is assigned. The variable yj constrains the value of z, for c, C CJ to \nprevent both candidates c, and CJ from being assigned to the same antichain, Figure 3(a) shows a call \ngraph G. Let S be the set of candidates in G. A representation of the partial order on S appears in (b). \nBased on this partial order, a representa\u00adtion of the dual minimum cost flow problem appears in (c). \nEach node represents a dual variable. Solid edges represent constraint A.2. Dashed edges represent constraint \nA.3. Intuitively, a correspondence exists between a maximum weight k-antichain sequence and assignments \nto the dual variables of the dual minimum cost flow problem. In solu\u00adtions to the dual minimum cost flow \nproblem, one can prove that for c, ~ S, ZJ+ y, = k+ 1or XJ+ yj = k [Cam85]. If zj + yj = k + 1, then \nwe map C3 to the antichain whose number in the sequence equals the value of XJ. Otherwise, if Zf + yj \n= k, c: is not mapped to an antichain. Assume that (a) ZJ+ yj = k+ 1, and let c, E CJ. By constraint \nA.2, (b) x,+ yj < k. Equations (a) and (b) imply (b) (c) in G, and the comparability digraph of the \ncandidates in G. that x, < xl. Assume z] = h. We map cj to antichain Ak. All candidates c, c Cj can only \nmap to antichains Am, O<m <h. Let ZJ + yj = k for Cj 6 S. If c, E CJ, then by constraint A.2, X, + yj \n< k. Thus, x, s XJ. Assume XJ = h. Thus, we do not map Cj to antichain Ah, as c, may be mapped to Ah. \nCandidates c, and C3 can never share the same antichain. There exists a l-l and onto mapping (a bijection) \nfrom maximum weight k-antichain sequences to solutions of the dual minimum cost flow problem above. A \nsolution to the dual minimum cost flow problem is represented by a se\u00adquence of tuples z = ((xl, yl), \n. . . . (xlsl,ylsl)). Let Q (k, S) be the maximum weight k-antichain se\u00ad quences in S, and let P (k, \nS) be the solutions to the dual minimum cost flow problem. For .4 E Q* (k, S) there is a bi\u00adjection z(A) \nonto z c F * (k, S), and for .z ~ P+ (k, S), there is an inverse function A(z) [Cam85]. A(z) maps z c \nP (k, S) onto a maximum weight k-antichain sequence (A I,... , A~). Mapping A(z) is defined as (AI(z),..., \nA~(.z)). For 1 s p s k, Ap(z), which maps candidates to antichain Ap, is defined as Ap(z)={ct lz, =p; \nzi+yi=k+ l}. If the dual variables z, and y, sum to k + 1,then candidate c1 is mapped to the antichain \nwhose number in the sequence equals the value of x,. Assume z ~ P*(k, S) and A(z) = A G Q (k, S). The \nobjective function A.4 maximizes ~CJ es WJ * (aJ + yj ). If X7 +yJ = k+ 1, then CJ is mapped to an antichain; \notherwise, Z3 + Y7 = k and C$ is not mapped to an antichain. Thus, Xj + yj k = 1 if c~ is mapped to \nan antichain; otherwise, Zj + yj k = O. The value of the objective function for solution z, therefore, \ndiffers from the weight of maximum weight k-ant i chain sequence A by a constant.  3.5 Example Figure \n4(a) shows the partial order on the candidates of call graph G of Figure 3. Candidates along a path must \nbe assigned to distinct abstract registers. Let Rp and Rq be Call graph G Partial Order on Dual Mincost \nFlow Problem Candidates in G based on the Partial Order (a) (b) (c) Figure 3: Example call graph G, graph \nof a partial order on the candidates in G, and the dual minimum cost flow problem with respect to the \npartial order. Each node in the dual minimum cost flow problem represents an integer-valued dual variable, \nand each edge represents a constraint between two dual variables. The constant above an edge is the integer \nupper bound in the corresponding constraint. Partial Order on Dual Mincost Flow Problem Candidates in \nG m k+l ( R7J Xm =2  Y~.1 6 &#38; o kk k+l t Xp=l  yp=l x~=l _kL ._ Yt=z (RI) 35 0 k kk k ~~ v \n(RI) q Xq=l k+l Yq=2 Xv. o k+l Yv=z .  41 ;0 oo (a) (b) Figure 4: Partial order on candidates in G, \nand graph of dual minimum cost flow problem for G abstract registers. If c, c CJ, c, E RP, and CJ c Rq, \nthen p<q. .4 register allocation and assignment using two registers appears in Figure 4(a). Candidate \nm is assigned register RZ, and q and tare assigned register RI. This register allocation has the maximum \nbenefit. Figure 4(b) shows the the graph of the dual minimum cost flow problem based on the partial order \n(a) for k = 2 registers. The solution in (b) can be mapped to the solution in (a). Since zn +y~ = k+1,and \nz~ = 2,candidate m maps to register Rz. As Xg +yq = k+ 1 and Zq = 1, q maps to RI. Similarly, candidate \nt maps to RI, since zt + yi = k + 1 and Zt=1.SincevEt,z. =O.As z.+yu=k,candidate v is not mapped to a \nregister. 4 Interprocedural Register Allocation with Spilling In this section, we consider an interprocedural \nregister allo\u00adcation that allows for register spilling across calls. The call graph can now be cyclic \n(save-free allocations are gener\u00adally not possible for cyclic call graphs). As in the save-free approach, \nwe assume a benefit associated with allocating registers to procedures, but now we also assume a cost \nasso\u00adciated with spilling registers across calls. The cost of spilling a register is two (for a load \nand a store) times the frequency of the calls represented by the edge. To find an allocation with maximum \nbenefit, we again map solutions from a dual minimum cost flow problem. Let call graph G = (P, E), where \nP is a set of proce\u00addures and E is a set of call edges. For P. c P, let C(PV ) represent the set of local \nregister candidates in P., and let C(P) represent the set of local candidates in all procedures in the \ncall graph, For a procedure P., let IN(PV ) be the set of call edges incident on P., and let OUT(PV ) \nbe the set of outgoing call edges from P.. In the save-free approach, if there is an ordering between \ntwo candidates, then they cannot be assigned the same reg\u00adist er. However, since registers are now spilled \nas necessary around calls, if CU c C(PV ), CU ~ C(PW ) and Pu calls Pw, then CU may be assigned the same \nregister as CU. We, there\u00adfore. now assume a partial order that only relates candidates in the same procedure, \nas these candidates can never be as\u00adsigned the same register. The ordering among the candi\u00addates in a \nprocedure is a chain, as in (1) of Section 3.1. We refer to this partial order as (~) throughout Section \n4. Since partial order (C) only relates candidates in the same procedure, there is an ordering between \nq and m in Figure 5. Let q E m. We represent this ordering by an undirected edge between q and m. For \nt c C(P2), t~ t. Let an abstract register Rh, 1 ~ h ~ k, be a set com\u00adposed of candidates assigned that \nregister. Each abstract register is mapped to a hardware register after interprocedu\u00adral register allocation. \nLet R be the sequence (RI, . . . . R~). To model spills along the edges of a call graph, two in\u00adteger \nvariables are introduced for each edge. For ej 6 E, the variable ~ree.in~ represents the number of unallocated \nregisters on entrance to edge ej, and the variable ~ree.outj represents the number of unallocated registers \non exit from edge eJ. The number of registers spilled along edge eJ is, therefore, free.outj ~ree_inf. \nLet ~ree.in be the se\u00adquence (free.in,, . . . . free_inl E[ ) and free.out be the se\u00ad quence (~ree.-outl, \n. . . . ~ree.outl~l). Call graph G Figure 5: Example call graph G. A partial order exists only among \ncandidates in each procedure. Assume k registers are available for an interprocedural register allocation. \nAllowing for register spilling along the call edges, an interprocedural register allocation J for a call \ngraph G is represented by 1 = (R, free-in, free-out), and has the following constraints and maximization \nfunction: Constraints 1.1 for el c E, free-inj s freesutj. 1.2 for ej E E, O S free-inj, free-outl ~ \nk. 1.3 if c~ 6 RP, c, c C(PU), and e] E IN(PU), then p ~ free.outj. 1.4 if ci c RP, ci G C(PU), and ej \nE OUT(PV), then p > free-in~. 1.5 if e, c IN(PV) and e, 6 OUT(PO), then f ree-outJ z free -in,. 1.6 let \nCi,cj c C(PU). if c, 6 Rp, cl G RQ, and c, E C3, then p< q. Maximization Function  1.7 maximize ~ C,elJ;=, \nR, \u00adx s * (f ree-outj free-inj ) eJ6E J Constraints 1.1 -1.6 define how registers are spilled along \nthe call edges and consumed within procedures. Constraint 1.1 states that the number of free registers \non exit from a call edge is greater than or equal to the number of free reg\u00adisters on entry to that edge \n(the difference is the number of registers spilled along the edge). Constraint 1.2 bounds the number \nof free registers on entrance to and exit from an edge by the number of registers available for allocation. \nCon\u00adstraint 1.3 asserts that if candidate c, is assigned to register RP, then there must be at least \np registers free on entry to the procedure from each incoming edge (ci is assigned one of the free registers). \nSimilarly, 1.4 asserts that if c, is assigned to register RP, then there must be fewer than p registers \nfree upon exit from the procedure along each outgoing call edge. By L5, there cannot be more registers \nupon exiting a procedure than there are upon entering it (all saving is done on the edges). Dual Varvables \nCall graph G 1 reg!ster ava!lable (z,, y, for c, C C(P)), (r,, t, for e, E E) o m (R,) 1 ~ free_in ~ \n= O free_ln, = O et e3 (spill RI) (spill R,) 1 free_out, = 1 2&#38; Q ~~ = &#38; free_m z= 1 4 free_out \nz = 1 0c1 (R,) P3 3 h Figure 6: Interprocedural register allocation of call graph G. Two candidates \nc,, Cj c C(PO ) cannot be assigned the same register. By 1.6, registers are assigned in a decreasing \nsequence within a procedure. If candidates c, and c1 are both allocated registers in procedure P. and \nc, c C3, then the register assigned to c, occurs before the register assigned to CJ in the sequence. \nAs in the case for save-free interpro\u00adcedural register allocation, if there is no register spilling, \nregisters are assigned in a decreasing sequence across calls. Assume CL,E C(PU), CW G C (PW), and Pu \ncalls PW (we model the call as edge ej in the call graph). If CUis assigned register RF, then by constraint \n1.4, there are fewer than p registers free on entry to e~ (~ree.znj < p). Assume no registers are spilled \naround the call. Thus, free.outj = free.inj in 1.1. If CW is assigned register Rq, then by constraint \n1.3, q < free.outj. Therefore, since free-outj = free-inj and free-in, <p, then q <p, Each candidate \nC3 E C(P) has a positive integer weight, UJj. Each call edge eJ E E has a positive integer cost, SJ, \nfor spilling a register, and spills free. outj free-inj registers. Assume ej is the call edge from PV \nto PW. Abstract register R,, i ~ f ree_znJ, is available on exit from P . By constraint 1.3, register \nR,,, z ~ ~ree-outj is available to candidates in PW. Our algorithm spills register R, along edge e] if \nfree.in~ <2 ~ free.outJ. We want to find a k-register interprocedural register allo\u00adcation that maximizes \nfunction 1.7. Since spilling decreases the value of 1.7, candidates are assigned a spilled register only \nif the sum of their weights is at least as large as the cost of spilling that register. Figure 6 presents \nan interprocedural register allocation assuming one available register. The number below each candidate \nis the benefit of allocating that candidate a reg\u00adister. The number below a call edge is the cost of \nspilling a register on that edge. Candidate m is assigned register RI Since the benefit of allocating \na register to p is Iess than the spill cost along edge el, p is not allocated a register. However, the \nbenefit of allocating a register to q exceeds the spill cost along edge el (but not the spill cost along \nedge e~ ). Thus, register RI is spilled along edge el, and RI is assigned to q. Since the cost of spilling \na register along edge Constraints D.1 D.2 D.3 D,4 D.5 D.6 D.7 D.8 Ob]ecttve Functton  D.9 Maximize ~ \nC,6C(P)W3 * (X3 +YJ) + LGE% * (rf +~~) Figure 7: Dual minimum cost flow problem whose solutions are mapped \nto an mterprocedural register allocation with spilling. es is less than the benefit of allocating a register \nto n, RI is spilled along es and assigned to n. 4.1 Finding a Minimum Cost Allocation To find a minimum \ncost interprocedural register allocation for a call graph, we solve the dual minimum cost flow prob\u00adlem \nof Figure 7. In this dual minimum cost flow problem, there is a pair of integer dual variables (z,, y,) \nfor each candidate c, E C(P) and a pair of integer dual variables (T1, tj ) for each edge ej E E. As \nbefore, for c, E C(P), integer w, > 0 represents the benefit of allocating a register to a candidate. \nFor e~ ~ E, integer s~ > 0 represents the cost of spilling a register on edge ej in the call graph. As \nin the save-free approach if z, +y, = k +1, then candidate c, will be assigned the register whose value \nis z,. For ej E E, rj represents the number of free registers on entry to edge e~, and tjrepresents the \nnumber of registers allocated on exit from ej. For ej c IN(PC), ti constrains the registers that can \nbe allocated to candidates in procedure P= (constraint D.,5), the number of free registers on outgoing \nedges from PC (constraint D.7), and the number of free registers on entry to ej (constraint D.8). Also, \ncandidates in P. constrain the number of free registers on outgoing edges from P. (constraint D.6). We \ndefine zy to be the sequence of tuples ((~i, yl), . . . (~lC(P)l IYIC(P)l)), and rt to be the sequence \nof tuples ((rl, tl),... >(~lEl, tEl)). A solution to the dual minimum cost flow problem is repre\u00adsented \nby tuple z = (zy, rt). For a call graph G on which we define partial order (~), and given k registers, \nlet P (k, G) be solutions to the dual minimum cost flow problem of Fig\u00adure 7. Let Q* (k, G) be solutions \nto interprocedural register allocation with spilling. In [Kur95], we prove that there ex\u00adists a bijection \nz(1), from 16 Q* (k, G) onto z 6 P (k, G), and an inverse function 1(z) for z c P* (k, G). I(z) is defined \nbelow. . I(z) = (R(z), f7-ee-in(2), free-out(z)). eforl~h~k, R~(Z)={Cj IZ] +lJj k+l, Zf h,., ~C(P)}; \n R(z) = (RI(Z),... ,Rk(2)). E for ej E E, free.inj (z) = rj; free.in(,3) = (free-inl (2), . . . . free-in~l \n(.z)). o for e~ E E, free.outj (z) = k tj; free-out(z) = (f7-ee_outl (z),..., f7-ee_outl~l (z)). For \nz c P* (k, G), function 1(z) maps z to an interproce\u00addural register allocation defined as (R, free-in, \nfree-out). Functions R(z), free.in(z), and free-out(z) map to se\u00adquences R, free_irz, and jree_out, respectively. \nRh (z) maps candidate CJ to register Rk if XJ + yj = k + 1 and XJ = h. For ej E E, free_inJ (z) maps \nthe value of variable rj to free-inj. For ej E E, free_outJ (z) maps k tlto free-outj. The variable tj, \ntherefore, represents the number of unavail\u00adable registers on exit from edge e~. The number of register \nspills along edge ej is free-outj free.-inj = k tj rj. The number of registers spilled along an edge \nincludes those not free on entry to the edge (k rj ) but made available on exit from the the edge (k \n rJ tj).Thus, rj + tj is the number of registers not spilled along edge ej. Constraints D. 1 -D.3 of \nFigure 7 are similar to con\u00adstraints A.1 A.3 of the dual minimum cost flow problem for a save-free allocation. \nAs in the dual minimum cost flow problem of Section 3, if z c P* (k, S), then for c, c C(P), Zj+yj = \nk or ZJ+VJ = .k+l. Assume (a) XJ+YJ = k+l and c, L C3. If c, E CJ, then by constraint D.2, (b) Z, + yj \n~ k. Equations (a) and (b) imply z, < X3 and, thus, c, and CJ can never be assigned the same register. \nConstraint D.4 bounds the value of TJ and tffor e] ~E by the number of available registers. By constraint \nD.5, for ej E IN(PU ), k tj bounds the number of registers available to candidates in C(PU ). For c, \nE C(PU ), assume z, +u, = k+ 1 and a, = p. Candidate c, is mapped to register RP. By constraint D.5, \nx, ~ k tj.Mapping I(z) assigns free-out~ the value k t].Thus, p ~ free.outl, which is constraint 1.3 \nin our definition of an interprocedural register allocation. By constraint D.6, the value of k y, for \nc, c C(PU ) bounds the value of r~ for ej E OUT(PU ). Mapping 1(.z) assigns free-in] the value of r]. \nThus, k y, bounds the number of free registers on entrance to ej. Assume Z* + y~ = k + 1 and z, = p. \nCandidate c~ is mapped to register RP. By D.6, rj + y, ~ k. Thus, rj < z,. Since 1(z) maps the value \nof r~ to free_inj and z, = p; therefore, free_inj < p, which is constraint 1.4. By constraint D.7, k \n tjbounds r, for ej < IN(PU ) and e, c OUT(PU). By D.7, r, s k tj.By mapping 1(z), free_inz ~ f Tee-outl, \nwhich is constraint 1.5. By constraint D.8, for e~ c E, r, + t, < k. As mentioned above, ri + ttis the \nnumber of registers not spilled along et. ASr,+t, s k,then r, < k t,.Applying mapping I(z), f Tee-in, \ns fr.emd,, wh~ch is constraint 1.1. The objective function D.9 is and the maximization function 1.7 \nis The value of the objective function for z c P* (k, G) (D.9) and the value of the maximization function \nfor 1(z) = 1 c Q* (k, G) (1.7) differ by a constant. As in Section 3, by sub\u00adtracting the constant ZC, \n~C(P1 k * WJ from ~C, ~C(P1 WJ * (z, + y,) in D.9 yields (a) ~ ,,e~(pj wj * ($f +yJ k). Since Xl + y] \n k = 1 if CJ is mapped to a register and, other\u00adwise, X3 + yj k = O, equation (a) is equal in value \nto Xc, eu:=l ~t W3 in 17 Moreover, for eJ E E, (b) rj + tjin D.9 is the num\u00adber of registers not spilled \nalong ej, and (c) ( f ree..outJ f ree_inJ ) in 1.7 is the negative of the number of registers spilled \nalong ef. Thus, r~ + tj k= (f ree.-outj f ree-.irzj ). As (b) and (c) differ by the constant k, ~e, \nE E S3* (rJ + tj) in D.9 differs from ~ ~ =E SJ * (free-outJ ~ree_i7zj ) in ) 1.7 by the constant \n~, CE s, * k. J   4.2 Example Figure 8(a) shows call graph G of Figure 6 with the same in\u00adterprocedural \nregister allocation. Variable allot, represents the register that c, may be assigned. Only one register \nis available. Register Rl is assigned to m, q, and n and spilled along edges el and e3. Figure 8(b) displays \nthe graph of the dual minimum cost flow problem for G. There is a pair of nodes for each candi\u00addate and \ncall edge in G. For clarity, variable zi is renamed allocz for Ci c C(P). Since mapping 1(z) for e, ~ \nE assigns f ree_in, the value of r,, we rename r, in (b) as free-in,. The dashed edges in Figure 8(b) \nrepresent constraints between pairs of nodes and solid edges represent constraints between nodes from \nseparate pairs. The k or k + 1 along an edge represents the bound in the corresponding constraint. Assume \nk = 1 in Figure 8(b). Since alloc~ + Y~ = k + 1, and by constraint D.5, free.inl + y~ S k, then f ree_inl \n< alloc~. Since the number of available registers decreases from 1 to O, we assign candidate m to register \nRI (atloc~ = 1). As there are O free registers on entrance to el (free-inl = O) and O unavailable registers \non exit from el (t 1 = O), then the number of register spills a~ong el is k tl free_inl = 1.Therefore, \ncandidate p may be as\u00adsigned register R1, as allocP = 1. Since ailocP + 9P = k, P is not allocated a \nregister. Since p is not allocated a register, there is a register free on entry to ez (f ree.-inz = \n1).By constraint D.8, f ree.-im + t2 ~ k. Thus, tz = O there are O unavailable registers out of e~. Candidate \nQ is allocated a register, as ulloc~ +yg = k +1. A register is spilled along es, since k free-ins -t3 \n= 1. This register is assigned to n. The register allocation and assignment of (b) correctly corresponds \nto the allocation and assignment described in (a). 1 reg[steravailable dIOCm = 1 m (R,) 1 ~ K31 free_in \n1= O free_in ~= O VT e3 (SpiII R,) el (spill RI) free_out 1=1 2 1 free_out ~= 1 allocp =1 ~ n allocn \n= 1 P~ cJ (R,) 2 1  pl /0 )3 free_m2=l ez free_out2=l 4 allocq = I ~ @l)A P3 ~ o (a) Figure8: Example \ncall graph Gandgraph representation 5 Complexity For p candidates and edges in a call graph, the number \nof dual variables in the dual minimum cost flow problem of Sec\u00adtion 4 is O(p). However, the number of \nconstraints between dual variables is 0(p2 ), as a dual variable for a candidate or edge can have constraints \nwith O(p) other dual variables. Our dual minimum cost flow problem can be transformed into an unconstrained \nminimum cost flow problem, in which there are O(p) nodes and O(p2) arcs. Letting n be the number of nodes \nand m be the number of arcs, an unconstrained minimum cost flow problem can be solved in O(n log n(m \n+n log n) [Or193], which is indepen\u00addent of k, WJ, and SJ in our dual minimum cost flow problem. The \ncomplexity of solving our minimum cost flow problem is, therefore, O((p log p (pz + p log p)), which \nis 0(p3 log p). 6 Liveness Before performing interprocedural register allocation, we can modify the \ncall graph to avoid spilling registers assigned to candidates not live across any call. Our interprocedural \nreg\u00adister allocation model assumes that a candidate live across a call is live across all calls. In a \nprocedure, let L be the set of candidates that are live across a call, and let NL be the set of candidates \nnot live across any call. In each procedure, we move the can\u00addidates in NL below the candidates L in \nthe partial order. Constraints are not added between the candidates in NL and the outgoing edges of the \nprocedure. All candidates in the procedure compete for registers as before, but as there are no constraints \nbetween the outgoing edges from the pro\u00adcedure and the candidates in NL, the registers assigned to these \ncandidates are not spilled. In Figure 9, we assume candidates m and n are not live across the call to \nPZ. In (b), m and n are moved below q in the partial order. By moving m and n below q, q is now assigned \nR3, and m and n are assigned 1% and RI. Since Dual Mincost Flow Problem k = 1 reg!ster free_in3.0 J \nt3=o k ~ Yn=lallOCn .1 +L -0 (D) of thedual minimum cost flow problem for G. ! (R3) m (R3) PI (R2) q \n1 n(R2) e m (RI) n u (R2) q (~+ % (spill R,) P2 e v (Rl) (spill R2) B u (R2) P2 v (Rl) i (.) (b) Figure \n9: By distinguishing between candidates live and not live across calls, fewer registers are spilled. \nwe also remove the constraints between candidates m and n and edge e, we can assjgn w. and w in P2 the \nsame registers as m and n, without spilling registers across the call, 7 Library Routines We assume \nthat library routines have been pre-compiled us\u00ading a caller-save/ callee-save convention for spilling \nregisters across calls[CHKW86]. Any caller-save register live across a call to a library routine must \nbe spilled across the call. To allow for pre-compiled library routines, we create a pseudo library routine \nthat allocates the abstract registers that we will map to the pre-defined caller-save registers. All \nprocedures that call library routines have a call edge to this pseudo library routine. As all caller-save \nregisters are allo\u00adcated in this pseudo routine, a caller-save register live across a call to this routine \nwill be spilled. Assume there are n caller-save registers and k total reg\u00ad isters. Since abstract registers \nare assigned in a decreas\u00ading sequence, we let abstract registers RI, . . . . Rn map to the caller-save \nregisters. Only if more than k n registers are live across the call to the pseudo library routine will \na caller-save register be spilled. To ensure that the n candi\u00addates in the library routine are assigned \nabstract registers RI,. . . . R., we modify the dual minimum cost flow problem in Figure 7 such that \nz, = Z; z, + ~, = k + 1 for candidates c,, 1 < i ~ n, allocated in the pseudo library routine. 8 Indirect \nCalls Indirect calls use the same caller-save/callee-save convention followed by library routines. When \nbuilding a call graph, we assume that each procedure that can perform an indirect call can invoke any \naliased procedure. The number of call edges representing indirect calls would, therefore, be the product \nof the number of routines that can make an indirect call and the number of aliased routines. Since we \nassume a fixed calling convention it is not nec\u00adessary to include these call edges. Instead, we add a \ncall edge from a routine making an indirect call to the pseudo library routine. Caller-save registers \nallocated by the proce\u00addure making an indirect call must be spilled around the call. We remove the call \nedges incident on the aliased routines (for simplicity all indirect and non-indirect calls to aliased \nroutines will use the fixed calling convention), and add one call edge eJ from a newly generated pseudo \nprocedure to the aliased routine. We assign the number of caller-save registers, n, to dual variable \nrJ, the number of registers free on entry to edge e~ as defined by the dual minimum cost flow problem \nof Figure 7. Registers can be spilled along efl (spilled on entry to the aliased routine), as the number \nof register spills, k rj tj, along ej can be positive. 9 Implementation We generate code for a DECstation \n5000/125, with MIPS R3000/R3010 processors. We assume that three general purpose integer registers, two \ngeneral purpose floating-point registers, and the pre-defined parameter registers are work registers \nthat are not allocated interprocedurally and hence are available to each routine. We use profile information \nto compute the number of calls between each procedure and the number of instructions executed in each \nprocedure. Profile information is gath\u00adered using qpt[BL92]. When profiling, benchmarks are run on input \nyielding short execution times, except for bench\u00admark nasa7, in which we have only one input file. Since \nthe profiled code is compiled using only an intraprocedural register allocator, some variables live across \ncalls may not be allocated a register because of an insufficient number of callee-save registers. To \naccurately determine the number of references to registers that can be live across a call, we modified \ngcc[Sta93] to return the number of register refer\u00adences assuming the non-work registers are callee-save. \nWe let the general-purpose registers that are non-work registers represent candidates in our interprocedural \nregister alloca\u00adtion algorithm, and their number of register references scaled using profile information \nrepresents the candidates weight. After generating an interprocedural register allocation, the registers \navailable to each procedure and the spills across Figure 10: Execution-time improvement from adding our \nminimum cost interprocedural register allocator with spills and Steenkiste and Hennessy s bottom-up interprocedural \nregister allocator to gee. Execution-time Improvement benchmark Mmtmum Cost Steenkiste and Hennessy compress \n1.4% -0.2% doduc 4.6% 4.2% eqntott o% 0; espresso 8.7% 7.3% fpppp 3.9% 3.0% gcc 8.3% 1.1% nasa7 0.2% \n-0.1% Sc 10.7% 7.4% suite 2.8% 1.7% [ xiisp 11.2% -3.2% 1 each call are written to a file. Gcc reads \nthis file to generate a register allocation. We assume that library routines have been pre-compiled using \na caller-save/calIee-save convention for spilling registers around calls. In some benchmarks, a procedure \nthat is not called when profiling with one input is called when using another. If a procedure is not \ncalled, we have no information on the frequency in which its candidates are referenced. We opti\u00admistically \nallocate registers to these procedures candidates as follows. We increase all zero edge frequencies to \none. As\u00adsume the total spill cost along incoming and outgoing edges of a procedure is j. Register candidates \nin a procedure called zero times are assigned a benefit of 1 + j. Since the cost of spilling a register \non entry to and exit from a procedure is less than the benefit of allocating a register to a candidate, \nthese candidates are always allocated a register. Figure 10 compares the execution-time improvement of \nadding our minimum cost interprocedural register allocator with spills with Steenkiste and Hennessy s \nbottom-up inter\u00adprocedural register aIlocator[SH89] to gee. The benchmarks are compiled at optimization \nlevel 02 with loop-unrolling enabled. Results from a sample of SPEC92 benchmarks are presented. Both \ninterprocedural register allocators find a significant improvement on benchmark doduc, as this bench\u00admark \nhas procedures with many registers live across calls. An interprocedural register allocator can generate \nan alloca\u00adtion that spills fewer registers across calls than an intrapro\u00adcedural register allocator. \nBenchmark eqntott shows no im\u00adprovement for either allocator, as most of its execution is in a leaf procedure. \nBenchmark zlisp shows a large improvement for our al\u00adlocator as it has small, frequently called routines. \nHowever, running Steenkiste and Hennessy s bottom-up register al\u00adlocator results in a worse allocation \nthan an intraprocedu\u00adral register allocation. Benchmark xlzsp has many routines at the bottom of the \ncall graph called less frequently than routines higher in the call graph. With a bottom-up alloca\u00adtion, \nregisters are spilled across the more frequently executed calls. Steenkiste and Hennessy[SH89] note that \na better in\u00adterprocedural register allocation can be generated by adding register spills in infrequently \nexecuted procedures in the bot\u00adtom of the call graph and then performing a bottom-up allo\u00adcation assuming \nthese routines are allocated zero registers. floatmg-pomt ~ tnteger jloating-pomt znteger com nress \n16 n 31 <. 0.1%. . . 0.3% . . ...~. -.. . 1I 1 1 j doduc ii 176 27; < 0.1% 0.2% eantott I I o I I78 \nI 0.1% 0.8% .. .1g~I t ! I espresso 361 1 1,604 0.6% 2.9% fDDDD 13 36 52 < 0.1% < 0.1% .... gcc 1,451 \n4 3,204 0.7% 4.3% nasa7 23 23 168 < 0.1% < 0.170 Sc 154 18 344 0.2% 1.2% spice 142 158 626 0.1% 0.2% \nxlisp 357 5 507 1.2% 2.3% Figure 11: The time for solving the minimum cost flow problem for the floating-point \nand integer candidates as a percentage of the m-o~ram s compilation time without interprocedural register \nallocation. The number of procedures and the number of .= integer and floating-p oint candidates are \nalso shown. To solve the dual minimum cost flow problem for in-References terprocedural register allocation \nwith spills, the problem is transformed into a minimum cost flow problem. Solutions [BCKT89] Preston \nBriggs, Keith D. Cooper, Ken Kennedy, to the minimum cost flow problem are found using the pri-and Linda \nTorczon. Coloring heuristics for reg\u00admal network simplex method [Zak95]. Though the primal ister allocation. \nIn Proceedings of the ACM SIG\u00adnetwork simplex method is exponential in the worst case, PLAN 89 Conference \non Programmmg Lan\u00adwe found it faster in practice than a polynomial time dual guage Deszgn and Implementation, \npages 275 network simplex algorithm available to us. Figure 11 shows 284, July 1989. the percentage of \ntime spent running the network simplex [BL92] Thomas Ball and James R. Larus. Optimally method as a \npercentage of the total compilation time with\u00adprofiling and tracing programs. In l+-oceed\u00ad out interprocedural \nregister allocation. For each benchmark, mgs of the Nineteenth Annual ACM Sympostum we solve two minimum \ncost flow problems, one with inte\u00adon Prmczples of Programmmg Languages, pages ger candidates and one \nwith floatmg-point candidates. The 59 70, January 1992. number of procedures in each benchmark appears \nin column 2. Columns 3 and 4 show the number of available candidates [Cam85] Kathie Cameron. Antichain \nsequences. Order, for interprocecfural register allocation. As mentioned earlier, 2(3):249-255, 1985, \nwork registers are not included as candidates, Interestingly, espresso, gee, and zlzsp have few floating-point \ncandidates, [Cha82] Gregory J. Chaitin. Register allocation and but since they have a larger call graph \nthan benchmarks, spilling via graph coloring. In Proceedings of doduc, fpppp, and space, all of which \nhave more floating-the ACM SIGPLAN 82 Symposzum on Com \u00adpoint candidates, mm-e time is spent finding \na solution as a pder Construction, pages 98-105, 1982. percentage of the total compilation time. [CHKW86] \nF. Chow, M. Himmelstein, E. Killian, and L. Weber. Engineering a RISC compiler sys\u00ad10 Conclusions tem. \nIn Proceedings COMPCON, pages 132 137, March 1986. Past interprocedural register allocators have used \nheuristics to determine the registers to allocate to each procedure and [CK91] David Callahan and Brian \nKoblenz. Register al\u00adto spill around each call. We have presented a polynomial location via hierarchical \ngraph coloring. In Pro\u00adtime interprocedural register allocator that uses a model of ceedings of the ACM \nSIGPLAN 91 Conference cost to represent possible allocations. Our allocator finds on Programmmg Language \nDes~gn and Imple \u00ada minimum cost allocation for allocating registers to each mentutzon, pages 192 203, \nJune 1991. procedure and spilling registers around each call. This al\u00ad [Kur95] Steven M. Kurlander. Interprocedural \nReg\u00ad locator is fast in practice and can yield significant run-time uter Allocation. PhD thesis, University \nof Improvements, Wisconsin Madison, 1995. In preparation. [Or193] James B. Orlin. A faster strongly polynomial \n 11 Acknowledgements minimum cost flow algorithm. Operations Re\u00ad search, 41(2):377 387, 1993. We would \nlike to thank Professor Robert Meyer and Armand Zakarian for answering our questions on network optimiza\u00ad[PF92] \nTodd A. Proebsting and Charles hi. Fischer. tion problems. Armand Zakarian wrote the network solver \nProbabilistic register allocation. In Proceed\u00adused to test our interprocedural register allocator. Harish \n ings of the ACM SIGPLAN 92 Conference on Patil and the anonymous referees provided helpful comments \nProgramming Language Design and Implemen\u00adto improve the content of this paper. tation, June 1992. [SH89] \nPeter A. Steenkiste and John L. Hennessy. A simple interprocedural register allocation algo\u00adrithm and \nits effectiveness for LISP. Transac\u00adtson.s on Programming Languages and Systems, pages 1-30, January \n1989. [s090] Vatsa Santhanam and Daryl Odnert. Register allocation across procedure and module bound\u00adaries. \nIn Proceedings of SIGPLAN 90 Confer\u00adence on Programmmg Language Destgn and Im\u00adplementation, pages 28 \n39, June 1990. [Sta93] Richard M. Stallman. lJsmg and Porting CC. Free Software Foundation, October GNU \n1993. [Wa186] David W. Wall. Global register allocation at link-time. In Proceedings of SIGPLAN 86 Sym\u00adposium \non Compder Constructionj pages 264\u00ad275, July 1986. [Zak95] Armand IJniversit 1995. Zakarian. Private \ncommunication. y of Wisconsin Madison, February  \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Steven M. Kurlander", "author_profile_id": "81100041498", "affiliation": "Dept of Computer Sciences, 1210 W Dayton St. Madison, WI", "person_id": "P270048", "email_address": "", "orcid_id": ""}, {"name": "Charles N. Fischer", "author_profile_id": "81100312451", "affiliation": "Dept of Computer Sciences, 1210 W Dayton St. Madison, WI", "person_id": "P43394", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237780", "year": "1996", "article_id": "237780", "conference": "POPL", "title": "Minimum cost interprocedural register allocation", "url": "http://dl.acm.org/citation.cfm?id=237780"}