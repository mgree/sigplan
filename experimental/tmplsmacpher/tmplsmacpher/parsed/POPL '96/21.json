{"article_publication_date": "01-01-1996", "fulltext": "\n A Modal Analysis of Staged Computation Rowan Davies* and Frank Pfenningt Department of Computer Science \nCarnegie Mellon University Pittsburgh, PA 15213, U.S.A. rowan(i)cs.cmu.edu and fp@cs.cmu.edu Abstract \nWe show that a type system based on the intuitionistic modal logic S4 provides an expressive framework \nfor specify\u00ading and analyzing computation stages in the context of func\u00adtional languages. Our main technical \nresult is a conservative embedding of Nielson &#38; Nielson s two-level functional lan\u00adguage in our language \nMini-MLn, thus proving that binding\u00adtime correctness is equivalent to modal correctness on this fragment. \nIn addition Mini-MLa can also express immedi\u00ad ate evaluation and sharing of code across multiple stages, \nthus supporting run-time code generation as well as partial evaluation, Introduction Dividing a computation \ninto separate stages is a common in\u00adformal technique in the derivation of algorithms. For exam\u00adple, instead \nof matching a string against a regular expression we may first compile a regular expression into a finite \nau\u00adtomaton and then execute the automaton on a given string. Partial evaluation divides the computation \ninto two stages based on the early availability of some function arguments. Binding-time analysis statically \ndetermines what part of the computation may be carried out in the first phase, and what part remains \nto be done in the second phase. It often takes considerable ingenuity to write programs in such a way \nthat they exhibit proper binding-time sepa\u00adration, that is, that all computation pertaining to the stat\u00adically \navailable arguments can in fact be carried out. From a programmer s point of view it is therefore desirable \nto declare the expected binding-time separation and obtain constructive feedback when the computation \nmay not be staged as expected. This suggests that the binding-time properties of a function should be \nexpressed in a prescrip\u00ad This work was partly supported by a Hackett Studentship from the University \nof Western Austraha Part of this work was completed during a vlslt by the first author to BRICS (Basic \nResearch in Com\u00ad puter Science, Centre of the Damsh National Research Foundation) tThis Ivork was sponsored \nm part by the Advanced Research Projects Agency (ARPA) , CSTO, under the t]tle The Fox Project: Advanced \nDevelopment of Systems Software , ARPA Order No 8313, Issued by ESD/AVS under Contract No F19628 91 C \n0168 Permission to make digitrd/hard copies of all or part of this material for personal or classroom \nuse is granted without fee provided that the copies are not made or distributed for pro$ or co~ereial \nadvantage, the copy\u00ad n.ght notice, the .tltle ,of tie pub!ic?tlon and Its date appear, and notice is \ng]ven tha~copyright ISby pernmwon of the ACM, Inc. To copy otherwise, to repubhsh, to post on servers \nor to redistribute to lists, requires specific permission and/or fee. POPL, 96, St. Petersburg FLA USA \n@ 1996 ACM &#38;89791 -769.3 \\95/01 ..$3,50 tive type system, and that binding-time analysis should be \na form of type checking. The work on t we-level func\u00adtional languages [NN92] and some work on partial \nevaluation ( e.g. [GJ91, Hen91]) shows that this view is indeed possible and fruitful. Up to now these \ntype systems have been motivated algo\u00adnthmiccdlg, that is, they are explicitly designed to support specialization. \nIn this paper we show that they can also be motivated logically, and that the proper logical system for \nexpressing computation stages is the intuitionistic variant of the modal logic S4. This observation immediately \ngives rise to a natural generalization of standard binding-time anal\u00adysis by allowing multiple computation \nstages, initiation of successor stages, and sharing of code across multiple stages, Such extensions are \nnormally considered external issues. For example, Jones [Jon91] describes a typed framework for such \nconcepts, but only at the level of operations on whole pro\u00adgrams. Our framework instead provides these \noperations within the language of programs. One of our conclusions is that when we extend the Curry-Howard \nisomorphism between proofs and programs from in\u00adtuitionistic logic to the intuitionistic modal logic \nS4 we ob\u00adtain a natural and logical explanation of computation stages. Each world in the Kripke semantics \nof modal logic corre\u00adsponds to a stage in the computation. A term of type DA corresponds to code to be \nexecuted in a future stage of the computation. The modal restrictions imposed on terms of type DIA guarantee \nthat a function of type B + DIA can carry out all computation concerned with its first argument while \ngenerating the residual code of type A. We begin by considering Mini-ML~, a formulation of in\u00adtuitionistic \nmodal S4 in which the permissible operations on code and the staging of computation are represented very \nexplicitly. The presentation is new, but draws on ideas in [BdP92, PW95]. It is augmented with a fixpoint \noper\u00adator, natural numbers, and pairs and endowed with a nat\u00adural call-by-value operational semantics \nalong the lines of Mini-ML [CDDK86]. Mini-ML~ is somewhat awkward because it requires the broad syntactic \nstructuring of the program to directly re\u00adflect staging. We thus consider a more implicit formula\u00adtion \nof S4 directly motivated by its Kripke semantics fol\u00adlowing [MM94, PW95] and then augment it as before \nto form Mini-ML . With some syntactic sugar, Mini-ML is intended to serve as the basis for a conservative \nextension of ML with a practical means to express and check staging of computation. The operational semantics \nof Mini-MLn is given by a type-preserving translation to Mini-ML~ whose correctness is not entirely trivial. \n We then exhibit a simple full and faithful embeciding of Nielson &#38; Nielson s two-level language \n[NN92] in Mini-ML , providing further evidence that Mini-ML provides an in\u00ad tuitively appealing, technically \ncorrect, and logically moti\u00ad vated view of staged computation. 2 Modal Mini-ML: Explicit Formulation \nThis section presents Mini-ML~, a language that com\u00adbines some elements of Mini-ML [CDDK86] with a modal \nJ-calculus for intuitionistic S4 following ideas in [BdP92, PW95]. For the sake of simplicity Mini-ML~ \nis explicitly typed. ML-style or explicit polymorphism can also be added in a straightforward manner; \nwe omit the details here in or\u00adder to concentrate on the essential issues within the given space constraints. \nA common feature of many types of staged computation is the manipulation of code in various forms. Macro \nex\u00adpanders and partial evaluators typically manipulate source expressions, runtime code generators typically \nmanipulate object code or some form of intermediate code. Starting from a typed language such as Mini-ML \nwe thus introduce a new type constructor D, where DA represents code of tgpe A. This type remains abstract \nin the sense that we do not commit ourselves to a particular representation of code. In this way our \ntype system can support diverse applications. In the description of the operational semantics we choose \nthe usual device of representing values (including code) by corresponding source expressions. This may \nbe refined in different ways for lower-level semantics describing, for ex\u00adample, run-time code generation \nor partial evaluation. Next we have to decide which operations should be sup\u00adported on code. First, we \nshould be able to manipulate an arbitrary closed expression as code. This suggests a con\u00adstructor box \nwhere box E : DA if E :A in the empty context. This is essentially the modal rule of necessitation. The \nsecond means of constructing code is by .dstitzhon: we can substitute code for a free variable appearing \nin code to obtain code. In a meaningful type system such substitu\u00adtion must be hygienic and rename bound \nvariables if nec\u00adessary to avoid capture. The restriction that we can only substitute code (and not arbitrary \nexpressions) into code is reflected exactly in the natural deduction variant of the modal necessitation \nrule: We can infer that box E : DIA from E : A if all hypotheses of the latter derivation are of the \nform x: DB, Note that this is quite different from Moggi s computational A-calculus [Mog89] which only \ndistinguishes values from computations and does not allow us to express stage separation. Moreover, the \nintended implementation of code is intensiona[, since we wish to allow refinements of our semantics to \noptimize code, while Moggi s computations are extensional with evaluation as the only operation. Technically \nwe enforce the restriction by introducing two contexts into the typing judgement A; r F E : A. The outer \ncontext A contains variables that may be bound only to code during evaluation; l_ contains variables \nthat may be bound to arbitrary values. Only variables in A are permitted to occur free inside box expressions. \nThis presentation simpli\u00adfies that of the modal A-calculus A:U from [BdP92, PW95] by eliminating the \nneed for simultaneous substitution while preserving sub j ect reduction. The elimination construct for \nbox allows us to bind a variable x in A to code of type A, written as let box z = El in Ez. Evaluation \nof code, certainly one of the most fundamental operations, is then definable by eval -(k: DA. let box \ny= zin g) :(IJA) --+A. Note that the opposite coercion, kr:A. box x, cannot be well-typed, since x is \nan arbitrary argument and will not nec\u00adessarilyy be bound to code. Furthermore, it violates the con\u00adcept \nof stage separation since z is a static argument which we refer to dynamically (i.e., inside the box). \n2.1 Syntax Types A ::= nat[A1-+AzlAlxAzlUA Terms E ::= X IJz:A. E IEl Ez I fix z:A. E l(El,Ez)lfstElsndE \nIzIsE l(case Elofz+E~lsz+E3) lbox Elletboxz=Elin Ez Contexts F ::= [ r,x:A We use A, B for types, r, \nA for contexts, and z for vari\u00adables assuming that any variable can be declared at most once in a context. \nBound variables may be renamed tacitly. We omit leading . s from contexts. We write [E /zlEfor L,. the \nresult of substituting E for z in E, renaming bound variables as necessary in order to avoid the capture \nof free variables in E . 2.2 Typing Rules Our typing rules for the Mini-ML fragment of the explicit \nlanguage are completely standard. The problem of typing the modal fragment is well understood; we present \nhere a variant of known systems [BdP92, PW95] with two contexts as motivated above. E has type A in modal \ncontext A; I PE:A A and non-modal context 17. Our system has the property that a valid term has a unique \ntype and typing derivation. A-calculus Fragment z:A inr tr2e-lvar A;(r, z:A) F E :B tpe-[am A; f Fk:A. \nE: A-+B A;r FEl:A+B A;r FE2:A tpe-app A; I FE1E2:B Mini-ML Fragment Mini-ML Fragment A; I PE1 ,Al A;rt3E2:A2 \ntpe_par A;l?P (E1, Ez) :A1 x.42 zi; r~E:.41Xfi2 A;r PE:Alx A2 tpe-fst tpesnd A;r Ffst E:Al A;ll Psnd \nE:A2 A; I FE:nat tpe-z tpe.s A;r Fz:nat A;r FsE:nat A;r FE1:nat A;17&#38;E2:A A;(17, c:nat)FE3:A A; I \nP(case Elofz+-E21sx+E3) :A Modal Fragment z:A inA tpe-gvar A;17Pr:A A;. PE:A tpe-box A;r Pbox E:DA A;17PEl \n:CIA (A, z: A); rPE, : B tpe-let_box A;!JFlet boxx=Elin E2:B The elimination rule for D, tpe-let-box, \nis the only one that introduces variables into the modal context.  2.3 Operational Semantics The Mini-ML \nfragment of our system has a standard call\u00adby-value operational semantics, For the modal part, we represent \ncode for E simply by box E, making the least commitment as to possible lower-level Implementations. Values \nV ::= /kr:A. E I(Vi, VZ) ]z Is V Ibox E. We evaluate let box x = El in EZ by substituting the code generated \nby evaluating El for x in EZ and then evaluating E2. The code generated by El may then be evaluated during \nthe evaluation of EZ as necessary. E + V Expression E evaluates to value V. A-calculus Fragment ev-lam \nAx:A. E c-+ ~x:A. E [fix x. E/x]E C+ V ev-flx fixx. Eq\\r El c-+VI Ez V Vz ev-pair (E,, E2) % (V,, V2) \nEYV ev-s sEc-+s V El+z Ez+l ev-case-z (case Elofz+E21sz+E,)+V ElqsV{ [V(/x]Ea % V ev-case-s (case Elofz+-E21sz+E,)+V \nModal Fragment ev-box boxE<box E E, -box E: [E{/x]Ez ~ V2 ev-let-box let box x= El in E2 C+V2 As usual, \nthe critical step in the proof of type preserva\u00adtion or subject reduction is a substitution lemma. Due \nto the modal contexts its form is slightly unusual, so we state it here explicitly. Other standard properties \nsuch as weakening are completely straightforward. Lemma 1 (Substitution) 1. If A;r PEl:Aand A;(r, ~: \nA) FE2:B then A;r F [E1/x]E2 : B.  2. If A;. FEl:Aand (A, x: A); rFEz:B then A;r F [E1/x]E2 : B.  \nProofi By standard, straight-forward inductions on the typing derivations for EZ. 1 Theorem 2 (Ileterminacy \nand Type Preservation) i. IfE Y V then V is avalue. 2. IfE+ VandE+ ~ then L =~ (modulo renaming of bound \nuarzables). 3. If EVVand.; PE: At hen .;. FV:A. Proofi By inductions over the structure of the derivation \nD of E + V. The cases for the non-modal part are completely standard. The cases for ev -box are trivial \nand those for ev -let -box are straightforward for properties 1 and 2. We thus show only the ev-let-box \ncase in the proof of property 3. Case: We have VI ~= El+ box E: [E{ /x]?, q V, ev-let-box letboxx=ElinEzv \nVz and, by inversion on the derivation of E : A, &#38;l &#38;2 .;PEl:n A z:A; .FeEz :B tpe-let.box .;. \nFletboxx=E1in E2:B Then we apply the induction hypothesis to D1 and tl to deduce that .; F box E; : \nDI.4. Now, again by inversion, the derivation of this judgment must have the form D; .;. ~@:A tpe-box \n.; FboxE:: CIA Then, from the substitution lemma applied to D; and f~ we deduce that .; . F [E; /z]E2 \n: B. We can then use 222 and the induction hypothesis to deduce that .; ~ V2 : B, as required. D We can \nnow justify the claim that the type system of Mini-ML~ captures the separation of a computation into \nstages. We follow the basic criteria for correctness of [Pa193] in which a modular proof of correctness \nfor binding-time analyzes was presented. Suppose that .; F E :c!A and E ~ V. By 1and 3we have V -box \nE . Thus the result consists only of residual code to be executed in the next stage. Further, by the \nmodal restrictions, only terms enclosed by box constructors are ever substituted into other box constructors. \nAs a result, the parts of the original program E not enclosed by any box constructor can be designated \nstatic since they will not appear in the residual code E . Further, the body of a box constructor can \nbe considered dynamic in the sense that we do not evaluate underneath the box constructor. The only way \nfor evaluation to proceed to the body of the box constructor is using the variable bound by a let box \nelimination construct to indicate where the delayed computation should be performed. 2.4 Example: The \nPower Function in Ex\u00ad plicit Form We now define the power function in Mini-ML~ in such a way that has \ntype nat ~ Dl(nat -+ nat), assuming a closed term times :nat -+ nat -+ nat (definable in the Mini-ML \nfrag\u00adment in the standard way). power = fix p:nat + D(nat + nat). An:nat. case f2 ofz + box (Az:nat. \ns z) [ sm+letboxg=prnin box (Az:nat. hmes x (gz))  The type nat ~ 0( nat ~ nat) expresses that power \nevaluates everything that depends on the first argument of type nat (the exponent) and returns residual \ncode of type D( nat + nat). Indeed, we calculate with our operational semantics: power z + box (k:nat. \ns z) power (s z) c-+ box (Az:nat. tzmes z ((kr:nat. s z)x)) power (s (s z)) c-+ box (Jz:nat. times z \n((k:nat. hmes z ((knat. s z)z))x)) Modulo some trivial redices of variables for variables, this is the \nresult we would expect from the partial evaluation of the power function. 2.5 Implementation Issues \nThe operational semantics of Mini-ML~ may be imple\u00admented by a translation into pure Mini-ML, by the \nmap\u00adping: DA + unit+ A box E + Au:unit. E let box x = El in Ez + (Az :unit + A. [z ()/z]Ez) El. It may \nthen appear that the modal fragment of Mini-ML~ is redundant. Note, however, that the type unit -A does \nnot express any binding-time properties, while DA does. It is precisely this distinction which makes \nMini-ML~ inter\u00adest ing: The type checker will reject programs which may execute correctly, but for which \nthe desired binding-time separation is violated. Without the modal operator, this property cannot be \nexpressed and consequently not checked. The intended im~lementation method would be to in\u00adt erpret DA \nas a datatype representing code that calculates a value of type .4. The representation must support sub\u00adstitution \nof one code fragment into another, as required by the ev-let-box rule. If the code is machine code, this \nnat\u00adurally leads to the idea of templates, as used in run-time code generation (see [KEH93]). For many \napplications this code would instead be source expressions or some intermedi\u00adate language, thus allowing \noptimization after code substitu\u00adtion. The deferred compilation approach described in [LL94] would provide \na more sophisticated implementation, sup\u00adporting fast run-time generation of optimized code. 3 Modal \nMini-ML: Implicit Formulation We now define Mini-ML , an implicit formulation of modal Mini-ML following \nthe pure system ~+ D in [PW95]. The main advantage of this system over the explicit language is that \naltering the staging of a computation often only re\u00adquires the insertion or deletion of modal constructors. \nIn contrast, Mini-ML~ requires that the strut ture of the pro\u00adgram exactly mirror the staging, since \nthe only way to refer to results from a previous stage is using variables that are bound to code outside \nthe enclosing box constructor. Using let (a derived form in our fragment) to bind code variables we can \nstill express staging more explicitly in Mini-ML if we prefer; it is now a matter of style rather than \na property enforced in the language. Another motivation for Mini-MLn is that it can be di\u00adrectly related \nto the two-level A-calculus (see Section 4) which would be much more difficult for Mini-ML~. Fur\u00adther, \nMini-ML is very similar to the quasi-quoting and eval mechanisms in LISP, which appear to be relatively \nintuitive in practice. We believe that with some syntactic sugar along the lines of Scheme s backquote \nand comma notation (as in the regular expression example in Section 5.3), Mini-ML would be a practical \nand theoretically well-founded basis for an extension of Standard ML. The operational semantics of the \nnew system is given in terms of a type-preserving compilation to Mini-ML~ which resembles the proof of \nequivalence between J:Q and }+U given in [PW95]. Besides the differences in the explicit system mentioned \nearlier, we add here a term constructor pop. This means that typing derivations for valid terms are unique \nand the compilation from implicit to explicit terms is deterministic, avoiding some unpleasant problems \nconcern\u00ading coherence. The intuition for this system comes from the multiple\u00adworld or Kripke semantics \nfor modal logic [Kri63]. We think of a world as representing a stage of the computation. Com\u00adputation \nis postponed to another stage by applying the box operator to a term M to generate code. Code may be \nused in the current stage with the unbox operator, or in any @ture stage by repeated application of the \npop operator. These correspond to reflexivity and transitivity of the ac\u00adcessibility relation between \nworlds in the Kripke semantics, further motivating our choice of the particular modal logic S4. For some \napplications, such as the two-level A-calculus, weaker modal Iogics such as K are sufficient, as described \nin Section 4.4. It may be helpful to consider the modal fragment of the implicit language to be a statically \ntyped analog to the quasiquote mechanism in Scheme. Then box corresponds to quasiquote ( ) and unbox \n(pop .) to unquote (,). unbox alone corresponds to eval, while pop alone corre\u00adsponds to quoting an expression \ngenerated with unquote. Note however that this analogy can also sometimes be mis\u00adleading, and the actual \nbehavior of code is closer to the quotations of a semantically rationalized dialect of Lisp called 2-Lisp \n[Smi84]. 3.1 Syntax Types A ::= Terms M ::= Contexts Context Stacks  3.2 Typing Rules In this section \nwe present typing rules for Mini-ML using context stacks. The typing judgement has the form: Term A4 \nhas type A in localw;rpfvf:~ context r under stack V. Intuitively, each element A of the context stack \nV cor\u00adresponds to a computation stage. The variables declared in A are the ones whose values will be \navailable during the corresponding evaluation phase. When we encounter a term box M during typing we \nenter a new evaluation stage, since M will be frozen during evaluation of the current stage. In this \nnew phase, we are not allowed to refer to variables of the prior phases, since they may not be available \nwhen M is un\u00adfrozen using unbox. Thus, variables may only be looked up in the current, context r (rule \ntpi.var) which is initialized as empty when we enter the body of a box (rule tpi.box). How\u00adever, code \ngenerated in the current or earlier stages may be used, which is represented by the rules tpi_un box \nand tpi_pop, A-calculus Fragment x:A in r U;(r,.cA) P M:B tpi-var tpi-lam Uf; rPz:A 4T;rPk:A. M:A+B \n w;r~~:~-+~ Q;r PN, A tpi=pp Q;r PMN:B Mini-ML Fragment W;(r, mA) P M :A tpi-fix Q;r Ffixz:A. M:A W;r \nPMl :AI U7;rPMz:Az tpi_pair W;r P(M1, M2):A1x A2 Q;r PM: Alx Az Q;r PM: A1x A2 tpi -fst tpi-snd Q;r \nPfst M:A1 Q;r Psnd M:A2 Q;r PM:nattpi-z tpis V;17Fz:nat W;r PsM:nat Q; I PM1 :nat V;r PMZ:A V;(r, z:nat)PM3:A \ntpi_case Ql; rP(case Mlofz+-M21sz~M3) :.4 Modal Fragment U/; r;. PM:A IU; rPM:OA tpl.-box tpi-unbox Q;r \nPbox M:OA W;r P unbox M : A Q; APM:uA tpi-pop Q; A;lT?pop M:UA 3.3 Examples in Implicit Form We now \nshow how we can define the power function in Mini-ML in a simpler form than in Mini-ML~, though still \nwith type nat + D(nat + nat). We use unbox, M as syn\u00ad tactic sugar for unbox (pop M). power ~ fix p:nat \ns D(nat + nat). An:nat. case n of z + box (Az:nat. s z) 1 s m + box (k:nat. times x (unbox, (pm) z)) \n As another example, we show how to define a function of type nat ~ Dnat that returns a box ed copy of \nits argument: M++Rb E ~@nat = fix~:nat -+ Dnat. k:nat. case x Of Z ~boxz I s z + box (s (unbox, (.f z \n))) .4 similar term of type A + DIA that returns a box ed copy of its argument exists exactly when every \n+ in .4 is enclosed by a D. This justifies the inclusion of the Jift prim\u00aditive for base types in two-level \nlanguages such as in [GJ91] and, in a more realistic version of our language, we would also include it \nas a primitive. 3.4 Translation to Explicit Language We do not define an operational semantics for Mini-MLa \ndi\u00adrectly; instead we depend upon a translation to Mini-ML~. This translation recursively extracts terms \ninside n nested pop constructors and binds their translation to new vari\u00adables, bound with a let box \noutside the nth enclosing box constructor. Variables thus bound occur exactly once. The compilation from \nimplicit to explicit terms is per\u00adhaps most easily described and understood if we restrict pop to occur \nonly immediately underneath an unbox or another pop. On the pure fragment terms then follow the grammar \nTerms M ::= x Ikc:A. M IMl Mz Ibox M Iunbox P Pops P::= Mlpop P The extension to the full language including \nrecursion is te\u00addious but straightforward. Any term can be transformed to one satisfying our restriction \nby replacing isolated occur\u00adrences of pop M by box (unbox (pop (pop M))). We also define environments \nand stacks which bind patterns of the form box x to explicit terms E. Environments ::= .lp, boxz=E Environment \nStacks ~ ::= . I R; p We abstract over an environment by means of nested let box expressions. Let(.)(E) \n= E Let(p, box z = E )(E) = Let(p)(let box z = E in E) The merge operation on environment stacks just \nappends the corresponding environments: .IR=R[. =R (Rl; /m) I (R2; P2)= (RI IR2); (Pi, P2) There are \ntwo primary judgments: M e+ R b E M compiles to term E under stack R P ++X R b p P compiles to environment \np under stack R binding x On the fragment we are considering they are defined by the following rules: \nP6y Rbp pr-pop POP P #-+-y(R; p) b . M*Rb E pr-t m M++y Rbboxy=E tr-var tr.lam xti. bx ~x:A. M + R b \n~Z:li. E Ml++ Rlb El Mz*RzbEz tr-app MIM2 I+ (RI [R2) bEl E2 M++(R; p)b E tr-box box M N R b Let(p)(box \nE) P~y Rbp tr.unboxy unbox P ++ R b Let(p)(y) In the rule tr-unboxv the variable g must be new, that \nis, it may not occur free in the conclusion. The environment p will always either be empty (in which \ncase y is bound in R) or a singleton of the form box y = E. Recall that in the former case, Leto(~) = \n~. The correctness proof for this translation requires defi\u00adnitions of well-typed environments and environment \nstacks. The latter ties in the context stacks of the implicit system. We use @ to range over contexts. \n~; r F p : @ Environment p satisfies (3 in contexts A and r Q7~R:A Environment stack R satisfies A under \ncontext stack V tpv-empty A;r F.:. A;r Fp:El A;r PE:n.4 -tpv-bind A;r F (p,box x = E) :(@, z:A) tpr-empty \nv~.:. Q~R:A A;r Pp:@ tpr-env W;r ~ (R; p) : (A,@) We require a few straightforward properties of environments, \nbut we explicitly state only the derived typing rule for envi\u00adronment abstractions. A;r Fp:@ (A, @); \nrFE:B tpi-env A; r P Let(p)(E) : B Theorem 3 (Correctness of Compilation) 1. For any M there exist unique \nR and E such that M++ RbE.  2. For any P and y there exwt unique R and p such that P+-#Rbp. 3. If U7; \nrPM:Aand Mi-+Rb E then for some Awe have 17~R:Aand A;r PE:A. 4. If IU;17FP :~Aand P++y Rbpthenfor some \nA  and@ wehaue*~R: Aand A;17Fp:@withy:A tn 11or G. Proofi Propositions 1 and 2 are trivial, since the \ntrans\u00adlations are defined structurally on ill with unique results (modulo renaming of bound variables, \nof course). Proposi\u00adtions 3 and 4 follow by mutual induction on the structure of the derivations of M \nE+ R b E and M *Y R b ,0. The proof requires a few simple lemmas such as weakening for he and some immediate \nproperties of RI I R2 and Let(p)(E) which we do not state here explicitly. We show only one critical \ncase in the proof of property 3. Case: z h~l + (R; p) bEl r= tr.box box All N R b Let(p)(box El) By inversion \nwe also have A = DA1 and D1 w;r; .FMl:Al D= tpi-box ll;f ~ box Ml : D.41 By induction hypothesis on \nT1 and DI we know there are A 1 and derivations VI :1 and V;r~(R; p):Al A1; .PE1:A] By inversion on VI \nwe find that Al = (A;, 8) and v; Y{ and Q~R:A~ Aj; rFp:e cTsing the derived rule for environment abstraction \nwe have fl Aj, @;. FEI:A1 q tpe-box Aj;rFp:O A~,@;rPboxEl:nAl tpi-env Al; r F Let(p)(box El) : DA1 At \nthis point the desired conclusion follows with A = A; from V{ and this derivation. D As an example of \nthe compilation, it maps the definition of power from Section 3.3 to the one in Section 2.4. Note that \nthe restructuring achieved by the compiler is similar to a staging transformation [JS86]. The operational \nsemantics induced by the translation is very different from the obvious ones defined directly on Mini-ML \n. In [MM94] a simple reduction semantics is in\u00ad troduced for a system similar to the pure fragment of \nour implicit system. It does not reflect staging, and is instead used to prove a Church-Rosser theorem \nand strong normal\u00ad ization for a pure modal A-calculus. Similarly, in [PW95] an algorithm for converting \npure modal A-terms in implicit form to long normal form is given and proven correct. This algorithm bears \nno resemblance to the staged computation achieved via Mini-ML~. We also have constructed a direct operational \nsemantics for Mini-ML generalizing [Hat95] that does capture staging, but prefer the compilation be\u00ad \ncause it makes operational properties more evident. 4 A. Two-level Language In this section we define \nMini-MLz, a two-level functional language very close to the one described in [NN92]. We then define a \nsimple translation into Mini-MLn and prove that binding-time correctness in Mini-MLz is equivalent to \nmodal correctness of the translation in Mini-ML . Our language differs slightly from [NN92] in that we \nin\u00adject all run-time types into compile-time types, instead of just function types. This follows [GJ9 \n1], where there is no such restriction. Also, we find it convenient to divide the variables and contexts \ninto run-time and compile-time. All other differences to [NN92] are due to minor differences be\u00adtween \ntheir underlying language and Mini-ML. 4.1 Syntax Terms e ::= 13 Run-time Contexts r ,:= . I r,g:r Compile-time \nContexts A ::= lA, @u  4.2 Typing Rules Run-time Typing Z:T in r tpr-var A;r~g:T A;(r, ~:72) F e :-r \ntpr-lam A;17F&#38;:T2. e:72~T A;r~el:T22T A; f Fe2 :T2 tpr-app A;r ~ el~e2 :T A;(f , &#38;:7) F e:T tpr-fix \nA;r~fiii~T.e7r A;rb el:T1 A;r Fe2:T2 tpr-pair A;r F(el, e2):71~T2  A;r ~ C : T137J A;r Fe: TIx T2 tpr_fst \ntpr.snd A;17Ffste:T1 ~irF~e:T2 A;r Fe:@ tpr-z tpr.s A;r F~:naJ A;rF~e:@ A;r FeI:naJ A;r Fe2:T A;(r, \ng:nat)Fe3:~ tpr-case A;I F(~e10f~+e2 l~~>e,):~ APe:T Term Translation down A;r Fe:r 11211 =x ll&#38;T. \ne]l = ~z:ll~ll. Ilell Compile-time Typing llel~ezll = llelll llezll l[fkKT. ell = fix z:IITII. //e\\l \n@u in A ll&#38;l)fa~ll = (Ilelll,lle211) tpc.var /lfkJ, el[ = fst hell AF~:u ll~ell = snd hell A,~:a2Fe:o \n112211ztpc_lam   W ==s Hell A F ~ij:u2. e : u2qcr ll~e,of~=+-e, l~y+-e,ll= A F el : U2=YU APe2:u2 \ntpc-app case Ilell[ of z + llezll I s x + llesll A F el&#38;e2 :u A,~uPe:g tpc.fix AFfi~u. e:u IIEII \n= unbox (POP H) 14= box 1141 AFel:al AFe2:u2 tpc-pair A F ~e1,e2~: C1FU2 Context Translation A F e \n: uI~uz A Fe :LJI~OZ tpc-fst tpc_snd 11 11= 1 1= AP~e:ul AFsnde:02 ll17,GT]/ = l[rll,z:tl~ll lA,~al \n= lAl,g:la/ AFe:nat tpcz tpcs 4.4 Equivalence of Binding Time Correct\u00ad AFZ:iEi AFEE:Ri ness and Modal \nCorrect ness AFel:fi AFe2:u A,~:=Fe3:a tpc-case In this section we state our main theorem, which is that \nAF(E5EEe1=Z~e21S~~e3) :a binding-time correctness is equivalent to modal correctness of the translation \nto Mini-ML . We write D :: (J) if D is a A;. Fe:~ derivation of judgment J. UP AFe:r Theorem 4 (Conservative \nEmbedding) Note that we remove run-time assumptions at the down 1. It hell = M then: rule, while in [NN92] \nthis is done later at the u p rule. This change is justified since by the structure of their rules, such \n(a) if D, :: (A; r P e : r) then assumptions can never be used in the compile-time deduc-we haue D, :: \n(lAl; 111 1[F M : ll~ll); tion in between. (b) if D, :: (IAI; l[rl[ F M : A) then we have D~ :: (lAl; \n111 11F e : r) with 11~11= A. 4.3 Translation to Implicit Language 2. If lel= M then: The translation \nto Mini-MLn is now very simple. We trans\u00ad(a) zjDc :: (A Fe : a) then late both run-time and compile-time \nMini-ML fragments di\u00adwe have D, :: (IAI P M : \\a/); rectly, and insert D, box , unbox and pop to represent \nthe changes bet ween phases. We define two mutually recursive (b) if D, ::(1A P M :A) then functions \nto do this: II. II is the run-time translation and I I we have Dc :: (L &#38; e : rJ) with Ial = A. is \nthe compile-time translation. We overload this notation between types, terms, and contexts. We write \ng and @ to Proofi By simultaneous induction on the definitions of hell match any term whose top constructor \nmatches the phase and Ie 1. Note that we can take advantage of strong inversion annot at ion. properties, \nsince we have exactly one typing rule for each term construct or in Mini-ML and Mini-ML2, plus the up \nType Translation and down rules to connect the l-c and Rr judgments. We only show the two cases involving \nboth definitions, since all others are easy. Note that for variables we need to rely on the phase annotations. \nCase: IIFII = unbox (pop IzI). To show part la we note that by inversion we have D; AF Z:TD. = down A;rkrz:r \n Applying part !a of the induction hypothesis to D: yields D; from which we construct IAI F g:: Dllrll \ntpi-pop = l~l;l[rl] F POP Izl : DIITII tpi-unbox IAI; Ilrll P unbox (pop IFI) : 11~11 Now, to show part \nlb we note that we can reverse the roles of the inversion and proof construction above, and use part \n2b of the induction hypothesis. Case: \\gl = box \\\\g\\l To show part 2a we note that by inversion we have \nD; A:.F~:T D. = UP AFg:T Applying part 1a of the induction hypothesis to D: yields D: from which we \nconstruct 1?: Now, to show part 2b we note that again we can reverse the roles of the inversion and \nproof construction and use part 1 b of the induction hypothesis. D The translation and proof can be \neasily generalized from a two-level language to a B-1evel language [NN92] with an infinite linear ordering. \nIn this case the image of the transla\u00adtion on well-typed terms is exactly the fragment Mini-ML~-, where \nunbox and pop are replaced by a combined construc\u00adtor unboxl. This fragment corresponds to a weaker modal \nlogic, K, in which we drop the assumption in S4 that the ac\u00adcessibility relation is reflexive and transitive \n[MM94]. Thus a corollary of the generalized theorem is that Mini-ML~. is equivalent to a B-level language, \nsince the translation is then a typing-preserving bijection. 5 Examples We now present some standard \nexamples from partial eval\u00aduation to illustrate the expressiveness of our language Mini-MLn. We use let \nx = El in EZ to introduce (non\u00adpolymorphic) top-level definitions; it may be considered as syntactic \nsugar for (,4z:A. Ez ) El. 5.1 Ackermann s Function We now present a program for calculating Ackermann \ns function that specializes to the first argument. It is based on the following program: let ackermann \n= fix acker:nat -+ nat -+ nat. Am:nat. case m of z + An:nat, sr2 I s m + ~n:nat. case n of z +-acker \nm (sz) I s n + (acker m (acker m n )) in ... Now, if we attempt to directly insert the modal con\u00adstructors \nto divide this program into two stages, we get the following: let ackermann = fix ucker:nat -+ D(nat \n-+ nat). Am:nat. case m of z + box (h:nat. sn) I s m + box (Art:nat. case n of z + (unboxl (acker m )) \n(s z) I s n + (unbox, (acker m )) ((unboxl (acker m)) nf)) in ... Unfortunately, when applied to the \nfirst argument, this function generally will not terminate. This is a common problem in partial evaluation, \nand the usual solution is to employ memoization during specialization, which works for many programs. \nHere we will simply note that the problem m this case is a recursive call to acker m while calculating \nacker m, which can be removed by adding an additional fix as follows. let ackermann = fix acker:nat ~ \nD(nat + nat). Am:nat. case m of z + box (An:nat. s n) I s m + box (fix ackm. Art:nat. case n of z + (unboxl \n(acker m )) (s z) I s n + (unbox, (acker m )) (ackm n )) in ... This function will always terminate. \nThe recursive appli\u00adcations appearing inside unbox_ 1 constructors are evaluated when the first argument \nis given. The compilation of this function to Mini-ML~ makes this more explicit: let ackermann = fix \nacker:nat + D(nat + nat), Am:nat. case m of z + box (An:nat. s n) I s m + let box f = acker m in let \nbox g = acker m in box (fix ackm. An:nat. case n Ofz +f(sz) I s n + g (ackm n )) in ... Notice that \nacker m is unnecessarily calculated twice. This would be avoided if memoization was employed during the \ncompilation or if we had explicitly bound a variable to the result of this computation. 5.2 Inner Products \nIn [GJ95] the calculation of inner products is given as an example of a program with more than two phases. \nWe now show how this example can be coded in Mini-MLn. We as\u00adsume a data type vector in the example, \nalong with a func\u00adtion szd:nat j vector ~ nat to access the elements of a vector. Then, the inner product \nexample without staging is ex\u00adpressed in Mini-ML as follows: let iprod = fix ip:nat + vector + vector \n-+ nat. An:nat. case rt of z * Av:vector. Aw:vector. z I s n + Av:vector. Aw:vector. plus (times (sub \nn u) (sub ?7,w)) (2J3?2 v 20) in ... We add in Dl, box and unbox, to get a function with three computation \nstages, which is shown in Figure 1. We assume a function lt.ft na t as defined earlier and a function \nsub :nat -+ D(vector + nat) which is a specializing version of sub, that perhaps pre-comput es some pointer \narithmetic based on the array index. We first define a staged version times of times which avoids the \nmultiplication in the spe\u00adcialization if the first argument is zero. This will speed up application of \nzprod to its third argument, particularly in the case that the second argument is a sparse vector. The \nlast four lines show how to execute the result of a specialization using unbox without pop (corresponding \nto eval in Lisp). Also, the occurrence of unboxz indicates code used at the third stage but generated \nat the first. These two aspects could not be expressed within a multi-level language. Note the erasure \nof the unbox, and box constructors in iprod leaves iprod, except that we used a different ver\u00adsion of \nmultiplication. The operational semantics of the two programs is of course quite different. 5.3 Regular \nExpression Matching We now present a program for regular expression matching that specializes to a particular \nregular expression. We use the full Standard ML language, augmented with our modal construct ors. Our \nprogram is based on the non-specializing one in Figure 2, which makes use of a continuation function \nthat is called with the remaining input if the current match\u00ading succeeds. We assume the following dat \nat ype declaration: datatype regexp = Empty I Plus of regexp * regexp I Times of regexp * regexp I Star \nof regexp I const of string Note that there is a recursive call to acc (Star(r)) in the case for acc \n(Star(r)) which we can transform using a local definition, similar to the fix introduced in the Ack\u00adermann \nfunction example. This must be done so that spe\u00adcialization with respect to the regular expression t \nerminat es. The resulting code for this case is: I acc (Star(r)) k s = let fun accStar k s = k s orelse \nacc r (fn ss =7 if s = ss then false else accStar k SS) s in accStar k s end Then, we can add in modal \nconstructors to get the staged program in Figure 3 with the following types (using $ here to represent \nD) val acc2 : regexp > $((string list -> bool) -> (string list -> bool)) val accept2 : regexp -> $(string \nlist -> bool) These types indicate that the required staging is achieved by the program. Inserting the \nmodal constructors re\u00adquires breaking up the function arguments, but is other\u00adwise relatively straightforward. \nWe use for box and \u00adforunboxl -unbox (pop.). More generally, we suggest using nforunboxn -unbox(pop \n.). Wecan nowuse our compilation to the explicit language Mini-ML~ to get an equivalently staged program. \nWe can then further translate to a program in pure Standard ML, which is stagedin the same way, but without \nthe modal an\u00adnotations, as shown in Figure 4. It is unnecessary to replace $A by unit -> Ain this case, \nsince isonlyapplied toval\u00adues. We show this program only to demonstrate the staging described by the \nthe modal annotated program. The pro\u00adgram in Mini-ML~ has the potential to be more efficient, since optimized \ncode can be generated by a sophisticated implementation. 6 Conclusion and Future Work In this paper we \nhave proposed a logical interpretation of binding times and staged computation in terms of the in\u00adtuitionistic \nmodal logic S4. We first presented an explicit language Mini-ML~ (including recursion, natural numbers, \nand pairs) anditsnatural operational semantics. We contin\u00aduedby defining an implicit language Mini-MLa \nwhich might serve as the core for an extension of a language with the complexity of Standard ML, perhaps \nwith the addition of some syntactic sugar along the lines of Lisp s backquote and comma notation. Theoperational \nsemantics of Mini-MLa is given byatype-preserving compilation to Mini-ML~. Fur\u00adther, Mini-MLn generalizes \nNielson &#38; Nielson s two-level functional language [NN92] which is demonstrated by a con\u00adservative \nembedding theorem, the main technical result of this paper. Ourinvestigation remainsat a relatively abstract \nlevel, thus providing a general framework in which various stag\u00ading mechanisms may be studied from a \nnew point of view. Concrete instances such as partial evaluation, runtime code generation, or macro expansion \nwill require some additional considerations for their effective use and efficient implemen\u00adtation. For \nexample, the two-level language we consider, Mini-ML?, is directly based on the one in [NN92]. This has \na stricter binding-time correctness criterion than used, for example, in [GJ91], even taking into account \nthat the run-time part of the latter is dynamically typed. Essen\u00adtially, this restriction may be traced \nto the fact that our underlying evaluation model applies only to closed terms, while [GJ91] requires \nmanipulation of code with free vari\u00adables. Thus, our system allows the inclusion of the unbox operator \nto evaluate closed code fragments, with no danger of encountering unbound variables. Cluck and Jtirg~nwn \n[CJ95] have presented a multi-level binding-time analysis, along with practical motivations for multi-level \npartial evaluation, and also use the less strict binding-time correctness criterion. In other work [Dav95] \nlet t2rnes :O(nat + El(nat + nat)) = box (Jm:nat. case m of z + box(An:nat. z) I sm ~box (~n:nat. tzrnesn \n(unboxl (lzftnat m)))) inlet tprod =fixtp:nat-+ D(vector~ Dl(vecto r-+ nat)). Jn:nat. case n of z +-box(Ju:vector, \nbox(Jw:vector. z)) I sn >box (~v:vector. box(~zo:vector. plus (unboxl (unbox, twnes (unboxl (sub n) v)) \n(unbox, (sub n) w)) (unboxl (unboxl (,p n ) v) w))) in let @-od3 : D(vector ~ D(vector ~ nat)) = tprod \n3 in let zprod3a : D(vector ~ nat) = unbox zprod3 [7, O, 9] in let zprod3b : D(vector -+ nat) = unbox \niprod3 [7, 8, O] in ... Figure 1: Staged code for inner product. one of the present authors has shown \nthat the O ( next ) operator from non-branching temporal logic exactly mod\u00adels this looser correctness \ncriterion. In future work we will consider how aspects of both type systems can be combined to allow \nboth manipulation of code with free variables and type-safe evaluation of code in the same language. \nSheard and Nelson [SN95] have investigated a two-level extension of Standard ML based on [NN92], with \nthe par\u00adticular aim of statically typing program generators. They show that a form of dependent types \nallow a larger class of program generators to be typed. The use of two-level pro\u00adgram generators is similar \nto using Mini-MLn to perform macro expansion, however Mini-ML D would also allow more general forms of \ncomputation staging. It is interesting to consider whether it would useful to add a form of depen\u00addent \ntypes to Mini-ML . We have shown how some standard examples of special\u00adization can be expressed in Mini-MLn. \nMore complicated examples would generally require polyvariant specialization, which could be provided \nto the programmer as a library function that memoized when generating code. Further, this approach could \nbe extended to prevent code copying during specialization. See [BW93] for a description of a re\u00adalistic \npartial evaluator for Standard ML and [JGS93] for an overview of standard techniques and examples of \npartial evaluation. Our language Mini-ML requires the insertion of the box, unbox and pop operators into \na functional program. These operators may be considered implicit coercions in a system of subtypes, where \ntype inference corresponds to a form of generalized, polyvariant binding-time analysis. Principal types \nwill only exist if we add restricted intersec\u00adtions, yielding a form of refinement types [FP91], but \nsuch a system would nonetheless raise serious coherence problems. Fractlcal experience with larger examples \nwill have to show how much inference along these lines is desirable and feasi\u00adble. We have omitted polymorphism \nin this paper, though ML-style polymorphism would only require the addition of a let construct. Variables \nthus bound would be restricted in the same way as A-bound variables. Polymorphic code could be manipulated \nby also generalizing the types of vari\u00adables bound by the let box elimination construct, with the familiar \nrestrictions required in a call-by-value setting. Ex\u00ad plicit polymorphism could also be added easily, \nfollowing work on higher-order modal logics. Further, we expect our type system to interact very well \nwith SML S module sys\u00adtem. In fact, part of our original motivation was to provide the programmer with \nmeans to specify binding-time infor\u00admation in a signature and thus propagate it beyond module boundaries. \nOur approach provides a general logically motivated framework for staged computation that includes aspects \nof both partial evaluation and run-time code generation. As such it allows efficient code to be generated \nwithin a declar\u00adative style of programming, and provides an automatic check that the intended staging \nis achieved. We have implemented a simple version of Mini-hlLn in the logic programming lan\u00adguage Elf \n[Pfe91]. To date we have only experimented with small examples, but we are planning a more realistic \nimple\u00ad ment ation to carry out larger experiments. 7 Acknowledgements We gratefully acknowledge discussions \nwith Lars Birkedal, Olivier Danvy, Jo<lle Despeyroux, Andrzej Filinski, Robert Gliick, Bob Harper, Fritz \nHenglein, Neil Jones, Jesper Jorgensen, Peter Lee, Mark Leone, Karoline Malmkj~r, Greg Morrisett, Jens \nPalsberg, Morgan Price, Michael Schwartzbach, Morten Welinder, Hao-Chi Wong and David Wright regarding \nthe subject of this paper. (* val acc : regexp -> (string list -> bool) -> (string list -> bool) *) fun \nacc (Empty) k s=k s I acc (Plus(rl,r2)) k s = acc rl k s orelse acc r2 ks I acc (Times(rl,r2)) k s = \naccrl (fn ss=>accr2kSS)s I acc (Star(r)) k s = k s orelse acc r (fn ss=>if s=ssthen false else acc (Star(r)) \nk SS) s 1 acc (Const(str)) k (x::s) = (x = str) andalso k s (* val acc3 : regexp -> (string list -> bool) \nI acc (Const(str)) k (nil) = false -> (string list -> bool) *) fun acc3 (Empty) =(fn k=>fn s=>ks (* val \naccept : regexp -> (string list > bool) *) I acc3 (plus(rl,r2)) = fun accept r s = let val al = acc3 \nrl acc r (fn nil => true I (x::l) => false) s val a2 = acc3 r2 in (fnk > fn s=>al ksorelse a2ks) Figure \n2: Unstaged regular expression matcher end I acc3 (Times(rl,r2)) = let val al = acc3 rl val a2 = acc3 \nr2 in (fnk =>fns =>al (fn ss=>a2kSS)s) end I acc3 (Star(rl)) = (* val acc2 : regexp -> $((string list \n-> bool) -> let val al = acc3 rl (string list -> bool)) *) fun acc3Star k s = fun acc2 (Empty) = fnk=>fns=>ks \nk s orelse 1 acc2 (plus(rl,r2)) = fn k => fn s => al (fn ss => if s = ss then false (acc2 rl) k s orelse \nelse acc3Star k SS) (acc2 r2) k s s I acc2 (Tirnes(rl,r2)) = fnk => fns => in (acc2 rl) (fn ss > (acc2 \nr2) k SS) s (fnk => fn s => acc2 k s) I acc2 (Star(r)) = fnk => fn s => end let fun acc2Star k s = I \nacc3 (Const(str)) = k s orelse (fnk => (fn (x::s) => (x = str) sndalso k s (acc2 r) I nil => false)) \n(fn ss > if s = ss then false else acc2Star k SS) (* val accept3 : regexp ->(string list -> bool) *) \ns fun accept3 r = in acc3 r (fn nil => true I (x::l) => false) acc2Star k s end I acc2 (Const(str)) \n= fn k => Figure 4: Pure SML staged regular expression matcher (fn (x::ss) => (x = (lift_string str)) \nandalso k ss I nil => false) (* val accept2 : regexp -> $(string list -> bool) *) fun accept2 r = (fn \ns=> (acc2 r) (fnnil => true I (x::l) > false) s Figure 3: Modally staged regular expression matcher References \n[BdP92] [BW93] [CDDK86] [Dav95] [FP91] [GJ91] [GJ95] [Hat95] [Hen91] [JC4S93] [Jon91] [JS86] Gavin Bierman \nand Valeria de Paiva. Intu\u00aditionistic necessity revisited. In Proceedings of tlse Logzc at Work Conference, \nAmsterdam, Hoi\u00adland, December 1992.  Lars Birkedal and Morten Welinder. Partial [KEH93] evaluation of \nStandard ML. Master s thesis, University of Copenhagen, Department of Com\u00adputer Science, 1993. Available \nas Technical Re\u00adport DIKU-report 93/22. Dominique C16ment, Joille Despeyroux, Thierry [Kri63] Despeyroux, \nand Gilles Kahn. A simple applica\u00adtive language: Mini-ML. In Proceedings of the 1986 Conference on LISP \nand Functional Pro\u00adgramm~ng, pages 13-27. ACM Press, 1986.  [LL94] Rowan Davies. .4 temporal-logic approach \nto binding-time analysis. Research Series RS-95\u00ad51, BRICS, Department of Computer Science, University \nof Aarhus, October 1995. Tim Freeman and Frank Pfenning. Refinement types for ML. In Proceedings of the \nSIGPLAN 91 Symposzum on Language De.wgn and lm \u00adplementatzon, Toronto, Ontario, pages 268 277. [MM94] \nACM Press, June 1991. Carsten Gomard and Neil Jones. A partial eval\u00aduat or for the untyped lambda-calculus. \nJo urn al [Mog89]o! Functional Programming, 1(1):21 69, January 1991. Robert Gluck and Jesper Jorgensen. \nEffi\u00ad cient multi-level generating extensions for pro\u00ad gram specialization. In S.D. Swierstra and [NN92]M, \nHermenegildo, editors, Programming Lan\u00ad guages, Implementations, Logtcs and Programs, pages 259 278. \nSpringer-Verlag LNCS 982, September 1995. [Pa193] John Hatcliff. Mechanically verifying the cor\u00ad rectness \nof an offline partial evaluator. In S.D. Swierstra and M. Hermenegildo, editors, [P fe91] Programmmg \nLanguages, Implementations, Log\u00ad ics and Programs. Springer-Verlag LNCS 982, September 1995. Fritz Henglein. \nEfficient type inference [PW95] for higher-order binding-time analysis. In J. Hughes, editor, Functional \nProgramming Lan\u00adguages and Computer Architecturej 5th ACM Confe re rice, pages 448 472. Springer-Verlag \nLNCS 523, 1991. [Smi84] Neil D. Jones, Carsten Gomard, and Peter Ses\u00adto ft. Partial Evaluation and Automatic \nProgram Generation. Prentice Hall, 1993. Neil D. Jones. Efficient algebraic operations on programs. \nIn T. Rus, editor, AMAST Pre-[SN95] liminary Proceedings, University of Iowa, April 1991. A version appears \nas a chapter in [JGS93]. Ulrik J@rring and William L. Scherlis. Compil\u00aders and staging transformations. \nIn Conference Record of the Thirteenth Annual ACM Sympo\u00adszum on Principles of Programming Languages, \npages 86 96, St. Petersburg Beach, Florida, Jan\u00aduary 1986. David Keppel, Susan J. Eggers, and Robert \nR. Henry. A case for runtime code generation. Technical Report TR 93-11-02, Department of Computer Science \nand Engineering, University of Washington, November 1993. Saul A. Kripke. Semantic analysis of modal \nlogic. I: Normal propositional calculi. Zeitschrifl fur Mathematische Logik und Grundlagen der Mathernattk, \n9:67-96, 1963. Mark Leone and Peter Lee. Deferred compila\u00ad tion: The automation of run-time code genera\u00ad \ntion. In Proceedings of the Workshop on Par\u00ad tial Evaluation and Semantics-based Program Mampulation \n(PEPM 94), Orlando, June 1994. An earlier version appears as Carnegie Mellon School of Computer Science \nTechnical Report CMU-CS-93-225, November 1993. Simone Martini and Andrea Masini. A com\u00adputational interpretation \nof modal proofs. In H. Wansing, editor, Proof theory of Modal Log-ZCS. Kluwer, 1994. Workshop proceedings. \nEugenio Moggi. Computational lambda calculus and monads. In Proceedings of the Fourth Sym \u00adposwm on Logzc \nin Computer Science, pages 14 23, Asilomar, California, June 1989. IEEE Com\u00adputer Society Press. Flemming \nNielson and Hanne Riis Nielson. Two- Level Functional Languages. Cambridge Univer\u00adsity Press, 1992. Jens \nPalsberg. Correctness of binding time analysis. Journal of Functional Programming, 3(3):347-363, July \n1993. Frank Pfenning. Logic programming in the LF logical framework. In G6rard Huet and Gordon Plotkin, \neditors, Logical Frameworks, pages 149\u00ad 181. Cambridge University Press, 1991. Frank Pfenning and Hao-Chi \nWong. On a modal A-calculus for S4. In S. Brookes and M. Main, editors, Proceedings of the Eleventh Conference \non Mathematical Foundations of Programming Semattcs, New Orleans, Louisiana, March 1995. Brian Cantwell \nSmith. Reflection and semantics in Lisp. In Proceedings of the Eleuenth Annual ACM Symposium on Principles \nof Programming Languages, Salt Lake City, pages 23-35. ACM, January 1984. Tim Sheard and Neal Nelson. \nType safe ab\u00adstractions using program generators. Technical Report OGI-TR-95-013, Oregon Graduate Insti\u00adtute \nof Science and Technology, Department of Computer Science, 1995.   \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Rowan Davies", "author_profile_id": "81100185069", "affiliation": "Department of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "P249790", "email_address": "", "orcid_id": ""}, {"name": "Frank Pfenning", "author_profile_id": "81100157780", "affiliation": "Department of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39030152", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237788", "year": "1996", "article_id": "237788", "conference": "POPL", "title": "A modal analysis of staged computation", "url": "http://dl.acm.org/citation.cfm?id=237788"}