{"article_publication_date": "01-01-1996", "fulltext": "\n Bisimilarity for Objects a First-Order with Subtyping Calculus of Andrew D. Gordon and Gareth University \nof Cambridge Computer http://www.cl.cam. ac.uk/users/{adg, D. Rees Laboratory gdrll}/ Abstract Bisimilarity \n(also known as [applicative blsimulation ) has attracted a good deal of attention as an operational equiv\u00adalence \nfor A-calculi. It approximates or even equals Morris\u00adstyle contextual equivalence and admits proofs of \nprogram equivalence via co-induct ion. It has an elementary construc\u00adtion from the operational defimtion \nof a language. We con\u00adsider bisimilarity for one of the typed object calculi of Abadi and Cardelli. By \ndefining a labelled transition system for the calculus m the style of Crole and Gordon and using a varia\u00adtion \nof Howe s method we establish two central results: that bisimilarity is a congruence , and that it equals \ncontextual equivalence. So two objects are bisimilar Iff no amount of programming can tell them apart. \nOur third contribution is to show that bisimilarity soundly models the equational theory of Abadi and \nCardelli. This is the first study of contextual equivalence for an object calculus and the first application \nof Howe s method to subtyping. By these re\u00adsults, we intend to demonstrate that operational methods are \na promismg new direction for the foundations of object\u00adoriented programming. Motivation Abadi and Cardelli \n(1994a, 1994b, 1994c) present a number of related calculi that formalise aspects of object-oriented programming \nlanguages, including method update (the abil\u00adity to modify the behaviour of an object by altering one \nof its methods) and object subsumption (the ability to emulate an object with an object that has more \nmethods). They give equational theories for their calculi, present a denota\u00adtional semantics based on \npartial equivalence relations for the largest calculus and show that the equational theory is sound Their \nobject calculi form an extremely simple yet clearly object-oriented setting in which to seek type systems \nthat support styles of object-oriented programming found in full-blown languages. Hence they are an important \nsubject of research. Abadi and Cardelli s goal was to study type systems for objects by abandoning complex \nencodings of objects as A- Perrnission to make digital/hard copies of all or part of this material for \npersonal or classroom use is granted without fee provided that the copies are not made or distributed \nfor profit or commercial advantage, the, copy\u00ad right notice, the title of the publication and its date \nappear, and notice is given that cop yright is by permission of the ACM, Inc. TO copY otherwise, to republish, \nto post on servers or to redistribute to lists, requires specific permission and/or fee. POPL 96, St. \nPetersburg FLA USA @199fj ACM ()..s9T9l-v69.qi95iCtl ..$3.50 terms and to study primitive objects in \ntheir own right. Our goal here is to study operational equivalence of objects in its own right, instead \nof via denotational semantics, another kind of encoding. We work with Obl <P (Abadi and Cardelli 1994c), \na first-order stateless object calculus including objects, recur\u00adsive types and a ground type of Booleans. \nWe take Morris\u00adstyle contextual equivalence (Morris 1968) to be the nat\u00adural operational equivalence \non objects: two programs are equivalent unless there is a distinguishing context of ground type such \nthat when each program is placed in the con\u00adtext, one converges but the other diverges. Following earlier \nwork on functional languages (Crole and Gordon 1995; Gor\u00addon 1995), we define a CCS-style labelled transition \nsystem for the object calculus and replay the definition of (strong) bisimilarit y from CCS. Our bisimilarity \ndescends from a line of work on operational equivalence for functional calculi be\u00adginning with Abramsky \ns applicative bisimulation (Abram\u00adsky and Ong 1993). The new elements here are subtyping and objects. \nUsing an extension of the method of Howe (1989) we prove Theorem 1, that bisimilarity is a congru\u00adence. \nTheorem 2, that bislmilarit y equals cent ext ual equiv\u00adalence, then follows easily. The quantification \nover all con\u00adtexts makes contextual equivalence hard to establish di\u00adrectly. The purpose of the labelled \ntransition system, Justi\u00adfied by Theorem 2, lS to admit CCS-style bisimulation proofs of cent extual \nequivalence. We use this style of proof a form of co-induction for our final result, Theorem 3, that \nbisim\u00adilarity soundly models all of Abadi and Cardelli s equational theorv. W; briefly examine equivalences \nbetween two example objects suggested by Abadi and Cardelli. One of the equiv\u00adalences follows by co-induction \nbut not from their equational theory. Our framework appears to be robust. Our main results continue to \nhold when we extend the pure object calculus with functions, records, variants and dynamic types. We \nleave a study of polymorphic types as future work, but see Rees (1994). 2 An object calculus The expressions \nof the Obl< . are object formation, [11 = $(zl:Al)el, . ,t~ = <(z. :An)en] (where an expression of the \nform $(z,:A, )e, is a method), method selection, a ./, and method update, a.e -e <(x:A)e, together with \nconstructs for Booleans and conditionals. We use the metavarlables z and X for variables and type variables, \nand e and E for pos\u00adsibly open expressions and types respectively. Let 1 stand 386 for finite indexing \nsets and 1 for labels, drawn from some countably infinite set. Formally, the grammars of types, E, and \nexpressions, e, are given as follows. We identify expressions and types up to a-conversion, de\u00adnoted \nby =. We write @[@/z] for the outcome of substituting phrase @ for each occurrence of (type or expression) \nvariable x in phrase +. An environment, I , is a finite list of assignments of closed types to variables, \nx:A, followed by a finite list of type vari\u00adable bounds, X<:E. Let I , X, r be short for r, X<:Top, l?. \nLet Dom(l?) be the set of variables and type variables bound or assigned in 17. The static semantics \nof the calculus con\u00adsists of five inductively defined judgments: 171-0 (the envi\u00adronment 17 is well-formed), \nE > Y (the type E is formally contractile in variable Y), r 1-E (the type expression E is well-formed), \nr 1-E <: E (the type E is a subtype of E ), and 171-e: A (the expression e has the closed type A). These \njudgments are given inductively by the rules in Tables 3, 4, 5, 6 and 7. We follow a met avariable convention \nbased on the following sets. A, B~Type ~f {Elak E} o,,bE Prog(A) Af {e Ig Fe:A} By program we specifically \nmean closed expressions con\u00adtained in Prog(A) for some A, respectively. As usual we write a: Atomean@Fa: \nAand A<: Bfor Ot-A<:B. Abadi and Cardelli discuss the Obl < ,P type system at length. A few points are \nworth noting here. Numbers, func\u00adtions, lists and so on can be encoded. Although the gram\u00admar allows \nthe type annotations on S-bound variables in an object to be distinct, if an object [-L = <(x, :Ai)e, \n]ie~ has type B, then each Ai <: B and in fact all the A, are iden\u00adtical. The contractility constraint \non recursive types im\u00adplies that any closed type can be decomposed into the form w(X1) p(X~)E where E \nis one of Top, Bool or [li:E;],er. Whenever A<: B and both A and B are object types, they must have the \nforms [1, :A~]ier and [Ij :Aj]j CJ, respectively, with J ~ 1. In other words, an object type is irwariant \nin its component types, that is, neither covariant nor contravari\u00adant. This is necessary because methods \nhave a contravariant dependence on self, and because they support both selec\u00adtion and update. Abadi and \nCardelli (1994b, 1995) develop richer type systems that address this limitation, but we do not consider \nthem here. We need the following substitution and bound weakening lemmas, which are standard. Lemma 1 \nIf r,x:A,r 1-e: B and 171-e : A, then I ,1 t\u00ade[e /x] : B. Lemma 2 If17, z:A, I k e: B and A <: A then \nI , z: A , r ~ e : B too. Abadi and Cardelli present a many-step deterministic evaluation relation, --+, \nfor Obl <,&#38;. For our purposes, it is more convenient to reformulate it as a single-step reduction \nrelation. To specify the evaluation strategy we need the following notion of a context. Let  be a distinguished \nvariable used to stand for a hole in a program. Let a cent ezt be an expression e such that the only \nfree variable, if any, is . If e is a context and a is a program, we write e[a] short for the program \ne[a/ ]. These are not variable-capturing cent exts. For each type A define the set Value(A) ~ Prog(A) \n(with typical members u, v) of values of the following forms. [1, = q(z; :B)e,],~l fold(B, v) true false \nLet Value be the set of values at any type, that is, Value = U{ Value(A) I A G Type}. The notation a \nI+ b means that a reduces to b in a single step of reduction; it is defined inductively by the follo \nwing axiom schemes (Red Select) a.lj + ej[a/zj] where a ~ [1, = ~(xi:Ai)ei]tG1 and j G 1. (Red Update) \nal, -e $(z:B)e ++ a where a -[L = ~(z;:At)et]i<l, a ~ [lY = $(x: AJ)e,l~ = $(z,:Ai)ei], cl._{3} and j \nE 1. (Red Unfold) unfold(fold(A, v))++ v (Red If True) if (true, al, az) ++ al (Red If False) if (f alse, \nal, az) + a~ with an evaluation strategy given by atib (Red Experiment) S[a] I+ t[b] where an experiment, \n&#38;, is a cent ext wit h one hole, of one of the following forms. .[ ./ e g.(x:A)e unfold( ) fold(A, \n-) if( , al, az) The relation I+ is weak in the sense that it is closed only under experiments, not arbitrary \ncontexts. There is no experiment to allow reduction under q-binders. (Red Up\u00addate) preserves the property \nthat whenever an object [/; = s(xi:A;)et],c] has type A, each At <: A and indeed all the A, s are identical. \nExperiments are just atomic evaluation contexts (Fellei\u00adsen and Friedman 1986); every program can be \ndecomposed uniquely as follows. Lemma 3 If a:A there is a unique list of experiments &#38;I,. . . . &#38;~, \nn ~ O, and value v such that a z tl[. ..&#38;n[v] . . .]. Lemma 4 The values are the normal forms of \nt-+, that is, whenever a is a program, a c Value iff -Elb(a M b). The reduction rules are deliberately \ntype independent, in the sense that although they manipulate type information contained in programs, \nthey are not contingent on the form of the types they manipulate. For instance, (Red Update) allows for \nthe type bounds, Ai, to be distinct although we know them to be identical. Hence ill-typed expressions \ncan be reduced. This is a redundancy in the dynamic semantics, but is harmless because we are only interested \nin statically typable programs. We can easily prove determinacy and subject reduction. Lemma5 Ifa+ibanda \n@c, then b=c. 387 Lemma 6 Ifa:A and a + b then b:A. As usual, let the relation +* be the reflexive and \ntransi\u00adtive closure of ++. We now recover a many-step evaluation relation, v, and three standard predicates \nas follows. 3b(a + b) a reduces a~*b&#38;7(b~) a evaluates to b 3b(a .1,1b) a converges Yb(a ** b * b \n~) a diverges not afi. We have recovered the many-step evaluation relation -++; a $ b iff F a --+ b. \nThe proof is standard. We introduced Obl < ~ without recursive programs, but we can define them using \nobjects; for example, let p(z A)e abbrewate the expression [/ = $(s: [l: A])e[S~/z]].l. We have p(z A)e \n+ e[P(~:~)e/z]. Hence there is a divergent program at every type. Let f2A be LL(z:A)z; OA * fl~ so f2Afi \nThe definability of Q* and the contractility condition on recursive types imply the following lemma. \nLemma 7 b A c Type 3al, az:A (all &#38; aj~). The results of this paper would hold for the language with\u00ad \nout contractivlty, but its presence simplifies the statement of certain results, because contractility \nrules out types with no values, such as K(X)X. Contextual equivalence We take Morris contextual equivalence \n(Morris 1968; Plot\u00adkin 1977), also known as observational congruence (Meyer and Cosmadakis 1988), to \nbe the natural operational equm\u00adalence on objects. First we introduce the idea of a rela\u00adtion between \nexpressions of matching types. Let a proved program be a pair a~ such that a:A. Let P and Q range over \nproved programs. Let Rel be the umversal relation on proved programs of the same type, given as follows. \nRel ~f {(a~, bA) I a:A &#38; b:A} We use 7? and S for subsets of Rel, that is, relations on proved programs \nthat respect typing. If 7? ~ Rel, then for any type A, define ~A = {(a, b) I (aA, bA) G R}. So the notation \na %?A b means that (aA, bA) C R. Instead of using relations on proved programs, we could have used binary \nrelations on expressions indexed by types. We use proved programs because when defining bisimilarity \nwe can work simply in the complete lattice of subsets of ReJ ordered by ~, rather than of indexed sets. \nFor each closed type A, let A-contextual equivalence, ~ ~ Rel, be the relation on proved programs given \nby the following. a ~B b iff whenever :B 1-e : A, e[a] U iff e[b] v. In other words, two programs are \nA-contextually equivalent iff their termination behaviour is the same whenever they are placed in a larger \nprogram, e, of type .4 Proposition 8 (1) Suppose there ezisi!s a context e such that :A E e : B and \nfor all programs a:A, we have au iff e[a]~. Then Eg&#38;. (2) IfA<:B then ~ ~ ~. (3) For allA, ~ ~~. \n (4) For all B, ~ ~ ~ . (5) : # = .  Proof (1) Suppose for some some type C and programs a and b, we \nhave a ;C b. We must prove that a ~G b. Suppose for some context e that :C t-e : A. By symmetry, it \nis enough to show that if e [a]$ then e [b]U. Consider the context e[e / ] satisfying :C k e[e / ]. \nB, where e is as given in the statement of the proposition. Then e[e [a]]u, and since a :C b, we have \ne[e [b]]u, hence e [b]d,i. as required. (2) A corollary of part (1), taking e s and using sub\u00adsumption. \n (3) A corollary of part (2), since A <: Top. (4) A corollary of part (l), taking e z if( , WB, VB) \nfor some value UB of type B (we know such a value must exist by Lemma 7). (5) We have ~(true &#38; O~ \nf2T0p) but true = ,., f2T0p, The former is immediate; the latter is trivial once we have Theorem 2. \n Of this family of equivalence relations, ; makes the most distinctions between programs, and =1 the \nfewest. The only substantial difference among the relations is the set of types at which termination \nis distinguishable from non\u00adtermination. In a language with call-by-value functions, we can con\u00adstruct \na context satisfying part (1) for any two types A and B, namely the application (( A(z:A)zI~) ) where \nVB is some value of type B. Hence, in a call-by-value language, all the 4 s are equal. We choose to take \n31 as our notion of operational equiv\u00adalence for this study for three reasons. First, it is the notion \nof contextual equivalence used by Plotkin (1977) and is stan\u00addard in studies of the language PCF. Second, \nit is the most generous of the A-contextual equivalences. Third, since one of our motivations is to validate \nthe equational theory of Obl < ,P, we must choose a contextual equivalence in which their equations are \nsound. In particular, the rule I 1-e. A I t-e . B (Eq Top) r\\e+e : Top must hold, so ~p is inappropriate, \nbecause it allows the ob\u00ad servation of termination behaviour at type Top. Hence it distinguishes true \nand Q at type Top, because the former 388 a Q v ~ {true, aBool 3 false} 0 (Trans Bool) A -[L,: A,],61 \n?j -~(fi)e aA + j 6 a.tj I + x:A h e : AJ q(x:A)eA ( IYans Update) A ~ p(X)E aA ~d B E E[A/x] unfold(a)~ \n(Trans Unfold) Table 1: Rules of the labelled transition system converges but the latter diverges. We \nwdl see later that (Eq programs: this reduction in size will simplify some of our proofs. Top) holds \nfor =l. ,, We divide the types of Obl< W into two classes, active Another candidate was ~, which does \nsatisfy (Eq Top) and passtve. Only Bool is active. Recursive types, object and would be the most natural \nchoice in Obl <,W without types and Top are passive. At active types a program must converge to a value \nbefore it can be observed; at passive Booleans. It is finer-grained than =l; it distinguishes [] types \na program does actions unconditionally, whether or and $2[ 1 whereas =1 identifies them. not it converges. \nThe observable actions, a E Act, take the We will define contextual equivalence, E < Rel, to stand following \nforms. for 21, and define cent extual order, ~ ~ Rel, as follows. true false I 1?-4= $(x)e unfold a LA \nb iff whenever :A k e : Boo1, These actions correspond to the actions of the labelled tran\u00ad e[a] u implies \ne[b] U too. sition system based on (Trans Exper) and (Trans Val), ex\u00adcept that true and false replace \nactions of the form if ( , Note that a=A biff a~~ band bLA a. a, b). We have erased type annot at ions \nfrom the update ac-It is easy to show two programs are contextually dis\u00adtions because they contain redundant \ninformation that will tinct: just exhibit a single context that tells them apart. in any case be erased \nby the (Red Update) rule. But to show equivalence requires a quantification over all The labelled transition \nsystem we shall work with is the contexts. The point of the next section is to characterise family of \nrelations (= I a c Act) given by the rules in contextual equivalence co-inductively as a kind of bisimi\u00adlarity, \nand hence to admit CCS-style bisimulation proofs of Table 1, such that whenever P --% Q, each of P and \nQ is a equivalence. Contextual equivalence is defined in terms of proved program. Let O be aT.~, for \nsome arbitrary program one-off tests consisting of composite contexts; bisimilarity is a:Top. The purpose \nof O is that it has no actions; after defined in terms of multiple atomic observations on objects. observing \nground data there is nothing more to observe. When proving programs equal it is often easier to consider \nWe can characterise the observable actions at each type. a series of atomic observations rather than \nall possible con-For each type A, define the set Act(A) ~ Act as follows. texts. Act(Top) = {} Act(Bool) \n= {true, false} 4 Bisimilarity Act(p(X)E) = {unfold} 4.1 Labelled transitions Act([&#38;:A,],a) = {13,,11 \n-+=g(z)eli C1 We define a labelled transition system that characterises the &#38; z:[4,:Ai],GI 1-e : \nA,} atomic observations one can make of a proved program. The notation P ~ Q means that the proved program \nP does Lemma 9 a E Act(A) iff 3a:A(aA --%). an action a to become another proved program Q. As usual \nWe can make more observations at a subtype than a we write P --% mean that there is some Q with P --% \nQ. The simplest labelled transition system to characterise supertype. contextual equivalence co-inductively \nis the following. Lemma 10 If A <: B then Act(B) ~ Act(A). : AtE:B The following is a trivial fact for \nObl < P, as BOO1 is the(TYans Exper) ~,00~~ o (Trans Val) only active type, but it holds in the extensions \nof Obl < ~ a~ L L5[a]B we have considered, in which more types are active. where an action is either \nan experiment, E, or val, and O is disjoint from the set of programs. We could prove that CCS\u00adstyle bisimilarity \naccording to this Iabelled transition system equals contextual equivalence. This is a direct generalisation \nOur labelled transition system is image-singular, in the fol\u00adof Milner s context lemma for PCF (Milner \n1977). We can lowing sense. do better than this by describing a labelled transition sys\u00adtem in which \nthere are fewer transitions available to proved Lemma 12 If P --% Q and P --% Q , then Q= Q . 389 Because \nof subsumption, the system based on (Trans Exper) and (Trans Val) is not image-singular. For example, \nthe following two transitions are derivable from (Trans Exper). d a.!B..l [/ Bool] d dTop [4. B..1] \n4.2 Definition of bi.similarity The derivation tree of a proved program P 1s the potentially infinite \ntree whose nodes are proved programs, whose arcs are labelled transitions, and which is rooted at P. \nFollow\u00ading Milner (1989), we wish to regard two proved programs as behaviorally equivalent iff their \nderivation trees are the same when we ignore the syntactic structure of the programs labelling the nodes \nand the ordering of the arcs from each node. We formalise this idea m the standard way. First define \ntwo functions [ ], ( ) p(Rel) -+ p(ReI) by [S] ~f {(P, Q) I whenever P -% P there is Q with Q ~ Q and \nP SQ } (S) = [S] n [s ]O where %?,op = {(b, a) I (a, b) ~ R-} for any binary relation IL These are \nboth monotone functions on p(ReJ). Let a relation S ~ Rel be a b%simulation iff S S (S). Let b%similarity, \nw ~ Rel, be the union of all the bisimulations. By the Tarski Knaster theorem, bisimilarity is the greatest \nfixpoint of ( ). In other words, bisimilarity is the greatest relation to satisfy the following: whenever \n(P, Q) G ReJ, P N Q iff (1) P 3P + ~Q (Q ~ Q &#38;p -Q ) If S is a bisimulation, S ~ w by defimtion \nof N; this is the co-induction principle associated with bisimilarity. We shall need the preorder form \nof bisimilarity. Let re\u00adlation S c Rel be a simulation iff S ~ [S]. Szmdarzty, ~ ~ Rel, is the greatest \nfixpoint of [ ], that is, the union of all simulations. 4.3 Basic properties of bisimilarity We can easily \nestablish the following using co-induction Proposition 13 (1) ~ is a preorder and -an equivalence relation. \n (2) -~o~ p.  = Part (2) depends on image-singularity, Lemma 12. This property fails in a nondeterministic \ncalculus such as CCS. 4.4 Bisimilarity and subtyping Whenever A <: B, we would expect that if two programs \nare equal at the subtype, A, that they will be equal at the supertype, B. To prove this, we need the \nfollowing lemma. Lemma 14 Relation {(a~,b~) I 3A(0 > A <: B &#38; a A b)} is a szmulatzon. The following \n1s a simple corollary by co-induction Proposition 15 (1) If a~~ band A <: B then a~~ b. (2) If a~~ band \nA <: B then aWB b.  In the following section we introduce the idea of a re\u00adlation being a congruence, \nand in the next we prove that bislmilarity 1s one. 4.5 Congruence and precongruence A congruence is \nan equivalence that is preserved by all con\u00adtexts. To state this formally we must begin with a few preliminary \ndefimtions. Let a substitution be a function d = al/zl, ., an/zn (n > ()) from expressions to expres\u00adsions, \nwhich substitutes programs for free variables. The application of a substitution 7 to an expression e \nis written e[F]. A substitution 8 z al/z l,. ., an/x~ is a r-closure for an environment r ~ zl:A1, . \n. . . z~ A~ iff each a,:.4,. Let a proved expression be a triple (17, e, A) such that r is closed (it \ncontains no type variable bounds; that is, it only contains assignments of closed types to program variables), \nA G Type and 17 h e : A. If the relation 7? ~ ReI then its open ezten\u00adszon, 7Z0, is the relation on proved \nexpressions such that (1 , e, A)7?0 (r , e , A ) iff A E A , I G I and e[8]7Ze [F] for all r-closures \n;. Open extension is a monotonic operator on relations bet ween programs. Lemma 16 If 7?QS then 7?0 ~ \nSO. For instance, Re1\u00b0 is the universal relation on pairs of proved expressions with matching types and \nenvironments. As a notational convention, if l?. Q ReIO we write r t-e R e : A to mean that ((17, e, \nA), (17, e , A)) c IL If 7? ~ ReIO then its compatible refinement (Gordon 1994) is the relatlon R ~ \nRel that relates two expressions if they share the same outermost syntactic constructor, and their immediate \nsub-expressions are pairwise related by %3. We say a relation %? ~ Re1\u00b0 is a precongruence iff it con\u00ad \ntains its own compatible refinement, that is, % &#38; 7?, and it satisfies the following rule, with + \nequal to Ii?. I 1-e~e :A A<:B (Eq Subsum) rt-ewe :B This definition of precongruence can easily be shown \nequiv\u00ad alent to a more conventional one based on substitution into variable-capturing contexts. If, in \naddition, a precongruence is an equivalence relation, we say it is a congruence. 4.6 Bisimilarity is \na congruence We will show that the open extension of bisimdarity is a congruence. Since bisimilarity \nis the symmetrisation of sim\u00adilarit y, Proposition 13(2), it is enough to prove that simi\u00adlarity is a \nprecongruence. We do so using a form of Howe s method (1989). We define an auxiliary relation, ~ , which \nby definition is a precongruence, and prove that ~ = S . Let the precongruence candzdate, ~ ~ Re1\u00b0, be \nthe least relation closed under the following rule. 17}e~e :A A <:A rhe ~Oe :A (Canal Def) rt-e~ e :A \n Since ~ is defined by exactly one rule, it is valid upwards, that is, whenever 17 t-e ~ e A, there is \nsome type A <: A and some expression e with I E e ~~ e : A and also r k e ~ e : A. We can easily prove \nthe following properties of ~ by standard methods. 390 [ 17 } AzL(X)E fold(A, I te:A unfold(e)) + e: \nA (Eval Fold) I Table 2: Fragment of the equational theory of Obl< P I Lemma 17 Relation ~ is reflexave, \nand the following rules Lemma 21 Contextual order, ~, is a simulation. are valid. Theorem 2 w = R. I \nte<Oe :A Proof Apply co-induction to Lemma 21 and combine ~ Eefe e ,A (Canal Shll) with Lemma 20. 17+e~ \ne :A 5 Operational adequacy r I-e S* e ,A (Canal comp) The relationship between operational semantics \nand equiv\u00ad alence in Obl < ,Y is subtle. The following facts are straight\u00ad(Canal Right) forward to state \nand prove. I &#38;e~*e :A Proposition 22 For any type A, 171-e ~*e :A 17t-e ~0e :A lT, x: Bt-el~ e\\:A \nrhea~ e~:B (1) Va, b:A(a @ b~ aWAb); (Canal Subst) r K el [e2/X] < e; [e&#38;] : A  (2) Va, v:A(a Jj-v \n~ a *A v); Moreoverj ~ is the least relat~on closed under the rules (3) Va:A(afi a a *A ~A). (Canal Comp), \n(Canal Right) and (Eq Subsum). Part (3) strengthened from * to iff is an important Unlike in previous \napplications of Howe s method, we property of equality and divergence. In the setting of the need to \nrelate ~ and subtyping. Given Lemma 14 the fol\u00adequality induced by a denotational semantics it is usually \nlowing new properties are easy to prove. known as computational adequacy (see Pitts (1994), for in-Lemma \n18 Both (Eq Subsum) and the rule stance). It does not hold at all types in Obl< ,P. Consider type Top. \nAny two programs at type Top are bisimilar, be-A<:B I , x: B, I t-etie :C cause there are no transitions \nat type Top. So true Top ~ (Eq Asm Subsum) but not truefi. 17, x: A, I + e~e :C Top is an example of \na singular type, one in which all programs are equal. Let E singular be the least predicate hold for \n* equal to 5 and to ~ . on types to satisfy the following: Top singular; X singular for any variable \nX; ,u(X)l? singular if E singular; and [1, :13,],61 The following lemma is the heart of the precongruence \nsingular if each E, singular. proof. The proof is detailed but follows the standard pat-A type is singulax \nif neither it nor any of its subexpres\u00ad tern. sions is Bool. So the type p(X) [11 :Top, 12:X] is singular \nLemma 19 Relatzon S = {(aA, a A) \\ 0 t-a ~c a : A} IS a but the type P(X) [/1 :Bool, 12:X] is not. Intuitively, \nall pro\u00adsimulation. grams are equal at a singular type because there are no Bool-contexts to tell them \napart. Theorem 1 Relation -0 M a congruence. Proposition 23 For any A, Proof By Lemma 19, S is a simulation, \nand hence S ~ ~ by co-induction. Open extension is monotone, Lemma 16, (1)A singular zfl Va, b:A(a -~ \nb); so S0 ~ so. Now ~ ~ S0 follows by (Canal Subst) and the (2) A not singular @Va:A(a ,4 flA * afi). \nreflexivity of ~ . Hence we have ~ ~ S . But (Canal Sire) provides the reverse inclusion, so in fact \n~ = so and hence The proof, which we omit, uses the fact that bisimilarityS is a precongrue~ce. By appeal \nto Proposition 13(2), .u equals contextual equivalence. Computational adequacy, is a congruence. that \na program equals Q iff it diverges, holds just at the non-singular types. 4.7 Bisimilarity equals contextual \nequivalence The proof of our main result, Theorem 2, follows the stan\u00addard pattern. Lemma 20 Both ~~~ \nand N~H. 391 6 Validating the equational theory Abadiand Cardelli (1994c) present anequational theory \nfor Obl<.~. Therrrelatlon isessentially therelatlon wQRe1\u00b0 that is inductively defined bytherules in \nTable 2, together with rules of equivalence, compatiblhty, closure under eval\u00aduation, (Eq Top) and (Eq \nSubsum). We can show that the open extension of bislmilarity is closed under the relevant equational \nrules and hence H z No Most of the Obl < w equational theory is easy to verify, The equivalence rules \nfollow for bmrndarity from Proposi\u00adtion 13(1). The congruence rules follow directly from The\u00adorem 1. \nThe evaluation rules follow from Proposition 22. (Eq Top) follows from Proposition 23 (Eq Subsum) fol\u00adlows \nfrom Lemma 18. (Eval Fold) can easily be proved by co-reduction. (Eq Sub Object) appears to be most easily \nproved via a direct proof that the two objects are contextu\u00adally equivalent. We omit the proof. Since \nNo is closed under all the rules inductively defining the equational theory, it 1s sound m the following \nsense. Theorem 3 H ~ No. Bisimilarity is no panacea witness the direct proof of (Eq Sub Object) but the \nbisimulation proofs of most of the equational rules would appear to be simpler than direct proofs of \ncontextual equivalence The reverse incluslon does not hold; see Proposition 26 below for an example. \nIn any case since the calculus pre\u00adsent ed here is Turing-powerful, no recursively enumerable equational \ntheory such as + could be complete for opera\u00adtional equivalence. 7 Example To demonstrate the power of \nthe co-inductive proof princi\u00adple, we consider an example, given in section 4.3 of Abadi and Cardelli \n(1994c) that does not follow from the equa\u00adtional theory. A jield is a degenerate method that does not \ndepend on its self parameter. Let e .l := e be short for e t &#38; 5(x:A)e for some type A such that \ne :A, and [1 = e,...] be short for [/ = g(z:A)e, ., ,], for some r not in the free variables of e. Define \na type A and two objects a and b as follows. a:A ~f [z = true, f = true] b:.4 ~f [z = true, ~ = S(S A)s \nz] Proposition 24 Not a WA b, Proof Let the context e be .z := flBOO .~. Both e[a] and e[b] are programs \nof type Bool, but e[a] ~ true whereas e[b]~ Hence the two are contextually distinct, therefore not bisimilar. \nProposition 25 a WIZ.BOO1l b. Proof Using (Eq Sub Object) we can prove both [z = true] -[z:~OOll a and \n[z = true] -[a ~ooll b, and therefore u -[z ,~ooll b by transitivity. Proposition 26 a W[f ~0011 b Proof \nLet P and Q be a[f ,0011 and b[f ,00,1 respectively. Here are all their possible transkions. (1) P ~ \nP with P ~ (a.f),OO, N trueBoo, (2) Q ~ P with P G (b.f),OO, -true,oo,. (3) P ~e~)e P with P -[z = \ntrue, f = s(~.A)el[f ,~~,1 f=$(z)e , (4) Q ---+ Q with Q w [z = true, f = d~:A)el[f,~..~l  In each \ncase, whenever P --% P there is Q with Q ~ Q and P w Q , and vice versa. Hence (P, Q) c (w) and since \n~ = (w) we have a WIf,~~~ll b. Proposition 26 does not follow from the equational theory +. We expect \nit would follow by a direct proof of contex\u00ad tual equivalence (similar to the one we needed for (Eq Sub \nObject)) but the bisimulation proof above is much simpler. 8 Other equivalence relations Our theory is \nbased on characterizing contextual equivalence as a form of bisimilarity. We considered several other \nforms of operational equivalence. 8.1 Contextual equivalence using capturing contexts In Section 3, we \ndefined contextual equivalence for closed expressions only. In extending the relatlon to open expres\u00adsions, \nwe have two choices; one is to use the relation -o, the other is to use contexts with a single hole that \ncaptures free variables; that is, we define a relation =1 as follows. for all capturing contexts C s.t. \n1/ e= e iff if C[e]:Bool and C[e ]:Bool then C.[e] J,l. df C[e ] u { In the pure object calculus Obl< \n~ we can easily show that that S1 contains contextual equivalence, but the reverse in\u00adclusion fails. \nThe only bound variables in Obl< ~ are self\u00adparameters, of object type, so Z:BOO1 1-z %1 true holds vac\u00aduously, \nbut of course z Bool E z #o true, because false/x is an z: Bool-closure. However, if the language is \nextended with a let construct at arbitrary type or with functions we can prove that the two equivalences \nare equal. Proposition 27 In the presence of funct~ons or a let con\u00ad struct, ?0 = =1.  8.2 Record-style \nbisimilarity Thinking of objects as records, we considered an equivalence, X2, that equates two objects \nif selections of them methods are pairwise bisimilar. This relation is not discriminatory enough because \nit has too narrow a notion of observation on objects. It would be correct for a record calculus, but \nlt ignores the posslbdity of method update and redirect ion through self. For example, it equates a and \nb from Section 7 at type [z, Boo1, f: Bool], but we know from Proposition 24 that they are contextually \ndistinct at that type. Abadi and Cardelli (1994c) reject a record-style semantics for their calculus \nfor similar reasons. 392 8.3 Applicative bisimuiation Howe (1989) defines a format for applicative \nbisimulation, %3, for a general class of untyped J-calculi. Here is a natural way to express this format \nin a typed setting. a %2 b iff whenever a ~ u then % s.t. bJ v .> and BEu -u A, and vice versa. Unfortunately, \nthis format is too discriminatory for this ob\u00adject calculus. It distinguishes between the two programs \na and b from Section 7 at the type [j: Bool], whereas Propo\u00adsition 26 shows they are contextually equivalent. \nTwo A\u00adcalculus functions A(z:A)e and A(x:A)e are equal if and only if e and e are equal for any expression \nof the correct type that may be substituted for z. However, for the meth\u00adods <(s: A)true and q(s:A)s. \nz to be equal, their bodies only need to be equal when particular values ofs are substituted for z, namely \nthe objects a and b themselves. 9 Related work Most prior work on the theoretical underpinnings for object\u00adoriented \nprogramming uses denotatlonal semantics (Gunter and Mitchell 1994), which provides fixpoint induction \nfor reasoning about programs. Co-induction cannot always take the place of fixpoint induction, but Mason, \nSmith, and Tal\u00adcott (1994) show how to derive fixpoint induction in a purely operational setting. Breazu-Tannen, \nGunter, and Scedrov (1990) is one of the few papers to establish computational adequacy for a denotational \nsemantics in the presence of subtyping. One conclusion of our study is that in spite of its elementary \nconstruction, bisimilarity is a useful opera\u00adtional model for an object calculus. Although much can be \ndone purely operationally, it would be worthwhile to re\u00adsearch the connections between contextual equivalence \nand the PER model for Obl< ~. Walker (1995) and Jones (1993) show how to encode ob\u00adjects in the n-calculus. \nFollowing their approach, we could translate Obl < ,P into the n-calculus, but we expect, based on Sangiorgi \n(1994), that the equivalence generated by the encoding would be finer grained than contextual equiva\u00adlence, \nAgha, Mason, Smith, and Talcott (1992) studied untyped act ors, a form of objects, with side-effects \nand con\u00adcurrency. We consider the extension of our results to the imperative object calculus of Abadi \nand Cardelli (1995) to be important future work. In the presence of dynamic state all known definitions \nof bisimilarity are finer grained than contextual equivalence (St ark 1994) but nonetheless we ex\u00adpect \nbisimilarity to be useful for imperative objects. Obl<,} is also studied by Palsberg (1994), who presents \na complete type inference algorithm. Obl < ,P is based on fixed-length objects; Mitchell, Honsell, and \nFisher (1993) have developed a ~-calculus of extensible objects. They too define a simple operational \nsemant its, analogous to our * relation. We ex\u00ad pect our theory of bisimilarity could be reworked for \ntheir calculus. We are aware of only two other studies of bisimilar\u00adit y and sub typing. Pierce and Sangiorgi \n(1995) investigate type annotations on names in the ~-calculus. Maung (1993), like us, used a labelled \ntransition system and a notion of similarity to express object properties. He proved that sim\u00adilarity \nof his objects implies a notion of substitutability. 10 Conclusion Contextual equivalence formally captures \nthe idea that two programs are equal iff no amount of programming can tell them apart. We characterised \ncontextual equivalence as a form of bisimilarity. We validated Abadi and Cardelli s equational theory. \nFurthermore, we showed that bisimilar\u00adity admits CCS-st yle proofs of equivalence, going beyond the equational \ntheory. Our work builds on previous studies of bisimilarity for functional calculi (Abramsky and Ong \n1993; Howe 1989; Crole and Gordon 1995; Gordon 1995). This is the first use of Howe s method in the presence \nof subsump\u00adtion and the first study of contextual equivalence for an ob\u00adject calculus. The chief difficulties \nwere in defining a labelled transition system that correctly dealt with method update and subsumption. \nSpace precludes their inclusion here, but our main results extend to function, dynamic, record and variant \ntypes. In all we claim that operational methods are a promising new direction for the foundations of \nobject\u00adoriented programming. Milner (1989) showed that bisimilarit y is a useful theory of concurrent \nprocesses. Analogously, our work shows that bisimilarity is a useful theory of objects with subtyping. \nWe have shown that from elementary foundations it captures intuitive operational arguments about objects. \nAcknowledgements Gordon holds a Royal Society University Research Fellow\u00adship. Rees holds an EPSRC Research \nStudentship. We thank Martin Abadi, Luca Cardelli and Andy Pitts for many useful conversations about \nthis work. References Abadi, M. and L. Cardelli (1994a, June). A semantics of object types. In Proceedings \nof the 9th IEEE Sym\u00adposium on Logic in Computer Science, pp. 332-341. IEEE Computer Society Press. Abadi, \nM. and L. Cardelli (1994 b). A theory of prim\u00aditive objects: Second-order systems. In Proceedings of \nEuropean Symposium on Programming, Volume 788 of Lecture Notes in Computer Science, pp. 1 25. Springer-Verlag. \nAbadi, M. and L. Cardelli (1994c, April). A theory of primitive objects: Untyped and first-order systems. \nIn Theoretical Aspects of Computer Software, pp. 296\u00ad 320. Springer-Verlag. Abadi, M. and L. Cardelli \n(1995). An imperative object calculus. In TAPSOFT 95: Theory and Practice of Software Development, Volume \n915 of Lecture Notes in Computer Science, pp. 471-485. Springer-Verlag. Abramsky, S. and L. Ong (1993). \nFull abstraction in the lazy lambda calculus. Information and Computa\u00adtion 105, 159 267. Available as \nTechnical Report 259, University of Cambridge Computer Laboratory. Agha, G., I. Mason, S. Smith, and \nC. Talcott (1992, Au\u00adgust 24 27,). Towards a theory of actor computation. In CONCUR 92: Third International \nConference on Concurrency Theory, Stony Brook, New York, VOL ume 630 of Lecture Notes in Computer Science, \npp. 565-579. Springer-Verlag. Breazu-Tannen, V., C. A. Gunter, and A. Scedrov (1990, June). Computing \nwith coercions. In P~oceedmgs of the 1990 ACM Conference on Lisp and Functional Programming, pp. 44 60. \n 393 Felleisen, M. and D, Friedman (1986). Control operators, the SECD-machine, and the A-calculus. In \nFormal De\u00adscrtptzon of Programmmg Concepts III, pp. 193 217. North-Holland. Gordon, A. D. (1994). Functional \nProgrammmg and In\u00adput/Output. Cambridge University Press. Gordon, A. D. (1995). Bisimilarity as a theory \nof func\u00adtional programming. In Eleventh Annual Conference on Mathematical Foundations of Programmmg Se\u00admanttcs, \nVolume 1 of Electronic Notes %n Theoretical Computer To appear. NS 95-3, Scaence. Extended Aarhus Elsevier \nversion University. Science avadable Pubhshers as BRICS B.V. Note Gunter, C. A. and J. C. Mitchell (Eds.) \n(1994). Theoret\u00ad ical Aspects of Ob~ect-Orzented Programming: Types, Semantics, and Language Deszgn. \nMIT Press, Cam\u00adbridge, Mass. Howe, D, J. (1989). Equality in lazy computation systems. In Proceedings \nof the 4th IEEE Symposium on Logac an Computer Sczence, pp. 198 203. Jones, C. (1993). A pi-calculus \nsemantics for an object\u00adbased design notation. In CONCUR 93: Fourth Inter\u00adnational Conference on Concurrency \nTheory, Volume 715 of Lecture Notes an Computer Sczence, pp. 158\u00ad 172. Springer-Verlag. Mason, I. A., \nS. F. Smith, and C. L. Talcott (1994). From operational semantics to domain theory. Submitted for publication. \nMaung, I. (1993). Simulation, subtyping and substi\u00adtutability. Technical Report UBC 93/5, Department \nof Computing, University of Brighton. Meyer, A. R. and S. S. Cosmadakis (1988, July) Seman\u00adtical paradigms: \nNotes for an invited lecture. In Pro\u00adceedings of the 3rd IEEE Sympostum on Logzc in Com\u00adputer Sczence, \npp. 236-253. Mdner, R. (1977). Fully abstract models of typed lambda\u00adcalculi. Theoretical Computer Sczence \n4, 1 23. Milner, R. (1989). Communication and Concurrency. Prentice-Hall International. Mitchell, J, \nC., F. Honsell, and K Fisher (1993). A lambda calculus of objects and method specializa\u00adtion. In Proceedings \nof the Ezghth IEEE Symposzum on Logzc in Computer Sczence, Montreal, pp 26-38. Morris, J. H. (1968, December). \nLambda-Calculus Models of Progmzmmzng Languages Ph. D. thesis, MIT. Palsberg, J. (1994). Efficient inference \nof object types. In Proceedings of the 9th IEEE Symposzum on Logzc m Computer Sctence, pp. 186-195. Pierce, \nB and D. Sangiorgi (1995). Typing and subtyp\u00ading for mobile processes. Mathematical Structures m Computer \nScience. To appear. Summary in Proceed\u00adings of the 8th IEEE Conference on Logtc m Computer Science, pp. \n376-385 (1993). Pitts, A. M. (1994). Computational adequacy via mixed inductive definitions. In Proceedings \nMathematical Crole, R. L. and A. D Gordon (1995) A sound meta\u00adlogical semantics for input/output effects. \nIn CSL 94 Computer Science Logtc, Ka-ztmterz, Poland, Septem\u00adber 1994, Volume 933 of Lecture Notes m \nComputer Sczence, pp. 339 353. Springer-Verlag. Foundations of Programmmg Semanttcs IX, New Or\u00ad leans \n1993, Volume 802 of Lecture Notes in Computer Sczence, pp. 72 82. Springer-Verlag. Plotkin, G, D. (1977). \nLCF considered as a programming language. Theoretical Computer Sczence 5, 223 255. Rees, G. (1994, April), \nObservational equivalence for a polymorphic lambda calculus. University of Cam\u00adbridge Computer Laboratory. \nhttp://www.cl.cam, ac. uk/users/gdrl 1 /equivalence. dvi. Sangiorgi, D. (1994, May). The lazy lambda \ncalculus in a concurrency scenario. Information and Computa\u00adtion 111 (l),120-153. Stark, I. D. B. (1994, \nDecember). Names and H~gher-Order Functions. Ph. D. thesis, University of Cam\u00adbridge Computer Laboratory. \nWalker, D. (1995, 1 February). Objects in the r-calculus. Information and Computation 116(2), 253-271, \n 394 rkO 01-A z$Dom(r) r 1-E X @ Dom(17) (Env ~) (Env x) (Env X<:) !zfko r, x:A 1-0 r,x<:E 1-o Table \n3: Well-formed environments x#Y E+Y X*Y Top > Y Bool > Y [&#38;:Ei]t=l > Y N(X)E > Y Table 4: Formal \ncontractility rl-E, (vzeq rtO r,x<:E, r k O (Type Object) (Type Top) r F [1, : E,], eI r K Top r,x<:E,r \nRX Type ) r, X<: Top l-E E+X rtO (Type Rec <:) = (Type Bool) r E K(X)E Table 5: Well-formed types rl-E \n17t El<:E2 rtE2<:E3 r,x<:E, r k O (Sub mans) (Sub X) IWE<:E(s b Refl) 17 FEl<, E3 r,x<:E, r tx<:E r \\ \n/i(XI)EI rt-v(X2)E2 r,Xz <: ToP, X1 <:x2 b El <:Ez (Sub Ret) r \\ ~(Xl)E1 <: P(X2)E2 Table 6: Subtyping \nrelation r,~:,4, r b o r,zt:A h ei :At (Vi c 1) A [&#38;: At]icr r + o (Val Object) r,z:,4,r F-Z:A Va \n) r t-[/, = <(zt:A)etJ,el : A r t-e: [t?i:A,]i61 j c I A = [l,: A,]ieI rl-e:A r,x:A1-e :A~ jGI (Val Select) \n(Val Update) r k e.lj : Al 17 E e.fj + q(z:A)e : A A=#(X)E rke:E[A/X] DtA A=p(X)E rl-e:A (Val Fold) (Val \nUnfold) r k fold(A, e) : A r k unfold(e) : E[A/x] 17 Fe:Al 171-Al<:A2 r+O (Val Subsumption) r +e:A2 17 \nh true :Bod val ) rFO rt-el:Bool rEe2:A 17 Re3:A (Val If) r t-fake ,BOOI val alse) rt-if(el, e2, e3):A \nTable 7: Type assignment 395  \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Andrew D. Gordon", "author_profile_id": "81100037731", "affiliation": "University of Cambridge, Computer Laboratory", "person_id": "PP15020291", "email_address": "", "orcid_id": ""}, {"name": "Gareth D. Rees", "author_profile_id": "81541317156", "affiliation": "University of Cambridge, Computer Laboratory", "person_id": "P93729", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237807", "year": "1996", "article_id": "237807", "conference": "POPL", "title": "Bisimilarity for a first-order calculus of objects with subtyping", "url": "http://dl.acm.org/citation.cfm?id=237807"}