{"article_publication_date": "01-01-1996", "fulltext": "\n Solving Sha~e-Analysis Problems in Languages with Destructive Updating Mooly Sagiv t and Thomas Repst \nReinhard Wilhelm$ University of Wisconsin Universitat des Saarlandes Abstract This paper concerns the \nstatic analysis of programs that per\u00adform destructive updating on heap-allocated storage. We give an \nalgorithm that conservatively solves this problem by using a finite shape-graph to approximate the possible \nshapes that heap-allocated structures in a program can take on. In contrast with previous work, our method \nM even accurate for certain programs that update cyclic data struc\u00adtures. For example, our method can \ndetermine that when the input to a program that searches a list and splices in a new element is a possibly \ncircular list, the output is a possibly circular list. Introduction This paper concerns the static analysis \nof programs that perform destructive updating on heap-allocated storage. It addresses problems that can \nbe looked at depending on one s point of view as pomter-analyszs problems, alias\u00adanalysis problems, \nstorage-analysts (shape-analysis) prob\u00adlems, or type-checking problems. The information obtained is useful, \nfor inst ante, for generating efficient sequential or parallel code. Throughout most of the paper, we \nwill emphasize the ap\u00adplication of our approach to shape-analysis problems. The goal of shape analysis \nis to give, for each program point, a (finite) characterization of the possible shapes that the program \ns heap-allocated data structures can have at that, point. We will illustrate our approach by means of \na running example in which we apply our analysis technique to a pro\u00adgram that uses destructive updating \noperations to reverse a list. This example also illustrates the connection between shape analysis and \ntype checking: It demonstrates how a sufficiently precise shape-analysis algorithm is able to ver\u00adify \nthat the destructive-reverse program does indeed return a list whenever its argument is a list. The application \nof *On leave from the IBM Israel Scientific Center. Part of this re\u00adsewcll was dose while visiting tile \nUniversit5t des Saarls,ndes, pw\u00adtirdly supported by SFi3 124-VLSI-Design Methods and Parallelism of tile \nDeutsclle Forscl]ul]gsgelllei]lscllaft. ts pported by a David and Lucile Packard FeHowshlp for Sci\u00ad ence \nand Engineering, by tile National Science Foundation under grant CCR-91OO424, and by tile Defense Advanced \nResearch Projects Agency under ARPA Order No. 8856 (monitored by tile Office of Naval Research under \ncontract NOO014-92-J-1937) Address Com\u00ad puter Science Department; 1210 West Dayton Stteet; Madison, WI \n53706; USA. Enmil: {sagiv,reps}Qcs.wise.edu. tAddre~~: Facllbereicll 14 Illforlllatik; 66123 Saarbrii~kel~; \nGer. many. Enmil: willlelm@cs. uni-sb de. Permission to make digital/hard copies of all or part of this \nmaterial for personal or classroom use is granted without fee provided that the copies are not made or \ndistributed for pro$t or commercial advantage, the copy\u00adright notice, the title of the pubhcatlon and \nits date appear, and notice is given that copyright is by permission of the ACM, Inc. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires specific permission and/or fee. \nPOPL 96, St. Petersburg FLA USA @1996 ACM 0-89791-769-3195101. .$3.50 our work to pointer-analysis and \nalias-analysis problems is discussed in Section 5.2. This paper develops a new shape-analysis algorithm \nthat provides conservative information about the possible shapes that heap-allocated structures in a \nprogram can take on. For certain programs including ones in which a signifi\u00adcant amount of destructive \nupdating takes place - our al\u00adgorithm is able to verify shape-preservation properties. Ex\u00adamples of such \nproperties include: (i) when the input to the program is a list, the output is (still) a list; (ii) when \nthe input to the program is a tree, the output is (still) a tree; and (iii) when the input to the program \nis a circular list, the output is a circular list. For instance, our method can determine that list-ness \nis preserved by (i) a list-reversal program that performs the reversal by destructively updat\u00ad ing the \ninput list, and (ii) a list-insert program that searches a list and splices a new element into the list. \nFurthermore, our method can determine that the list-insert program also preserves circular list-ness \n. These are rather surprising capabilities. None of the pre\u00adviously developed methods that use graphs \nto solve shape\u00adanalysis problems are capable of determining that (list-ness is preserved on these examples \n(or examples of similar com\u00adplexity) [JM81, JM82, LH88, CWZ90, Str92, PCK93]. Pre\u00advious to this paper, \nit was an open question whether such precision could ever be obtained by any method that uses graphs \nto model storage usage. Furthermore, as far as we know, no other shape-analysis/type-checking method \n(whether based on graphs or other principles [HN90, Hen90, LR91, Deu92, CBC93, Deu94]) has the ability \nto determine that circular Iist-ness is preserved by the list-insert program. What does our method do \nthat allows it to obtain such qualitatively better results on the above-mentioned programs than previous \nmethods? A detailed examination of the dif\u00adferences between our algorithm and previous algorithms is \ndeferred to Section 6; however, a brief characterization of some of the differences is as follows: . \nPrevious methods have used allocation sites to name shape\u00adnodes [JM82, CWZ90, PCK93]. Allocation-site \ninforma\u00adtion imposes a fixed partition on the memory. In con\u00adtrast, our approach deliberately drops information \nabout the concrete locatzons. There is only an indirect connec\u00adtion to the run-time locations: Shape-graph \nnodes are named using a (possibly empty) set of vartables. The variable set of a shape-graph node in \nthe shape-graph for program-point v consists of variables that, for some exe\u00adcution sequence ending at \nv, must all point to the same run-t ime 10cation. e Like other shape-analysis methods, our method clusters \ncollections of run-time locations into summary nodes. In our approach, nodes that are not pointed to \nby vari\u00adables are clustered into a single node. Chase, Wegman, and Zadeck observed that their analysis \nmethod cannot handle programs such as the list-reversal program be\u00adcause it lacks a wav to materialize \n( nun-summarize ) sum\u00admary nodes at cer~ain key points ;f the analysis [CWZ90, pp. 309]. Our shape-node \nnaming scheme allows our method to materialize copies of the summary node (as non-summary nodes) whenever \na pointer variable is assigned a previ\u00adously summarized run-time location. In the analysis of an assignment \nto a component, say z. cdr := nil, our method always removes x s cdr edges. Previous methods either \nnever remove these edges [Str92] or have some heuristics to remove such edges under cer\u00adtain conditions \n[JM81, LH88, CWZ90, PCK93]. (This un\u00adusual characteristic of our method is enabled by both the node-naming \nscheme and the rnaterialization technique.)  We use sharing information to increase the accuracy of \nthe primitive operations used by our method. More specifi\u00adcally, we keep track of shape-nodes that may \nbe the target of more than 1 pointer from the heap. For example, when a linked data structure is traversed, \nsay via a loop con\u00adtaining an assignment x := x. cdr, the sharing information is used to improve the \nprecision of the materialization op\u00aderation, which allows our algorithm to determine that z points to \na list element on every iteration. The limited form of sharing information used in [JM81, CWZ90] does \nnot allow these met hods to determine this fact.  The shape-node names also provide information that \nsome\u00adtimes p~rmits our method-to determine that a shared\u00adnode becomes unshared (e.g., this occurs in \nthe program that performs an insertion into a list). With the Chase-Wegman-Zadeck method, once a node \nis shared it re\u00admains shared forever thereafter. For programs that op\u00aderate on lists and trees, the non-graph-based \nmethod of Hendren [Hen90] is sometimes able to determine that a shared-node becomes unshared. However, \nthis method does not handle data structures that contain cycles.  An experimental implementation of \nthe analysis method has been created; the examples presented in the paper have been prepared with the \naid of this implementation. The remainder of the paper is organized as follows: Sec\u00adtion 2 introduces \nthe terminology and notation used in the rest of the paper. Section 3 presents a concrete seman\u00adtics \nfor a language with destructive updating, in terms of shape-graphs in which nodes represent run-time \nlocations. Section 4 introduces an abstract domain of static shape\u00adgraphs and shows how they can be used \nto approximate the sets of shape-graphs that arise in the collecting seman\u00adtics. Section 5 summarizes \na few extensions to our basic approach. Section 6 discusses related work. Due to space constraints, we \nhave omitted discussions of (i) other elab\u00adorations and extensions of our basic approach, (ii) a proof \nthat our abstract semantics of static shape-graphs is safe wit h respect to the concrete semantics. This \nmaterial can be found in [SRW95]. 2 Terminology and Notation 2.1 The Language We assume we are working \nwith an imperative language that meets the following general description: A program con\u00adsists of assignment \nstatements, conditional statements, loops (while, for, repeat), read statements, write statements, and \ngoto statements. 1 The language provides atomic data (e.g., lTlle treatment of procedures is discussed \nlater, in Section 5.3. integer, real, boolean, etc. ) and constructor and selector operations (e.g., \nnil, cons, car, and cdrz), together with appropriate predicates (equal, atom, and null). We assume that \na read statement reads just an atom and not an entire list, tree, or graph, A program is represented \nby a control-flow graph G = (V, .4), where V is the set of vertices and A ~ V x V is the set of arcs. \nG has a unique start vertex, which we assume has no predecessors. The other vertices oft he control-flow \ngraph represent the statements and predicates of the program in the usual way; st(w) denotes the statement, \nor predicate of vertex v. Normalization Assumptions. For expository convenience, we will assume that \nprograms have been normalized to meet the following conditions: Only one constructor or selector is performed \nper state\u00adment. e An expression cons(z, y) is executed in three steps: (i) al\u00adlocate the cons cell and \nassign it to a new temporary variable; (ii) assign z into the car component; (iii) assign y into the \ncdr component. * In each statement, the same variable does not occur on both the left-hand and right-hand \nside. * Each statement of the form 1 := r where r + nil is pre\u00adceded by an assignment of the form 1 \n:= nil.  All allocation statements are of the form z := new (as opposed to x.sel := new). Thus, for \nevery vertex v c V in which a pointer manipu\u00adlation is performed, st(v) has one of the following forms: \nx := nil, z.sel := nil, x := new, x := y, z := y.sel, or x.sel := y, where y + z. (In our implementation, \nthe work of putting a program into a form that meets these as\u00adsumptions is carried out by a preprocessor. \n) Note that the number of temporary variables that are introduced to meet these restrictions is, in the \nworst case, linear in the size of the original program. 0 The normalization assumptions are not essential, \nbut simplify the presentation. For example, the last assump\u00adtion allows us to separate the kill aspects \nof a statement (e.g., z := nil) from the gen aspects (e.g., x := y.selo, assuming x points to nil) in \nthe semantics. (See Figures 2 and 6.) Example 2.1 Figure 1 shows (a) a program that performs a list reversal \nvia destructive updating, (b) the program in normalized form, and (c) the control-flow graph of the pro\u00adgram \nin normalized form. The list initially pointed to by variable x is transformed into its reversal. After \neach it era\u00adtion, y points to the reversal of a successively longer prefix of the original list. 0 To \nsimplify the formulation of the analysis method, it will be stated for a single fixed (but arbitrary) \nprogram. The set of pointer variables in this program will be denoted by P Var. 2.2 Shape-Graphs Both \nthe concrete and abstract semantics are defined in terms of a single unified concept of shape graph , \nwhich 2Tlmougllout tbe paper, our presentation is couched in terme of tile Lisp primitives for manipulating \nheap-allocated storage. However, tl]is m not due to any basic limitation of our metl~ocl; our sllape\u00adanalysis \nalgoritlml extends readily to tile case of pointers to user\u00addefined types tl~at nave more than two fields. \n4 / x points to an unshared list / VI ~ := nil y := nil  i ,,while z # nil do ?>0I .4I M \u00ad t:=y Jy:=~ \n?J3  t := nil x := x.cdr y.cdr := t V4 t:=y I1 od 1 t ;= nil V5 y:= nil / (a) V6 Y:ix J tl := nil \n/ x Points to an unshared list */ 7 I y := nil OS1 tl := z.cdr 1while z # nil do t:=nil w z := nil t:=y \ny := nil 010 [ x :=71 y:=x J tl := nil VII y,cdr := nil tl := z.cdr 1 x := nil VIZ y. cdr~~ ~ := t~ y.cdr \n:= nil V13 tI:=nil y.cdr := t od 7J14 t:=nil tl:=nil t := nil 015 E  (b) (c) Figure 1: A program, \nthe program in normalized form, and the program s labeled control-flow graph. is defined as follows: \nDefinition 2.2 A shape-graph IS a finzte directed graph that consists of nodes, called shape-nodes, and \ntwo kinds of edges: variable-edges and selector-edges. A shape graph is represented by a pair of edge \nsets, (EV, E,), where e EU is the graph s set of variable-edges, each of whzch M of the form [x, n], \nwhere x ~ PVar and n is a shape-node. e Es is the graph s set of selector-edges, each of whzch is of \nthe form (s, sel, t), where s and t are shape-nodes, and sel c {car, cdr} We overload the symbol Ev \nto also mean the function that returns a varzable s Eu successors. That as, for z c PVarj we dejine Ev(x) \nto be E.(x) ~f {n I [x, n] c Eo}. Similarly, for a shape-node s and sel E {car, cdr}, we de\u00ad jine E.(.s, \nsel) to be Es(s, sel) ~f {t I (s, sel, t) E Es}. (The intended meaning of a use of E, or E. wdl always \nbe clear, accordzng to whether arguments am supplied or not.) Gzven SG = {Eu, E. ), we define shape. \nnodes(SG) as fol\u00ad lows: shape-nodes(SG) ~f {n I [*, n] ~ Eu} U {n I (*,*, n) c E,} U {n I (n,*,*) c E,}. \nThe class of shape-graphs zs denoted by S~. 0 Note that for a given shape-graph SG, shape_nodes(SG) is \nuniquely defined: it consists of the set of non-isolated nodes in SG (i.e., the nodes that are touched \nby at least one edge). It is for this reason that we do not explicitly list the node set when specifying \na shape-graph. The shape-graphs that arise in the concrete semantics for the language have somewhat different \ncharacteristics from the ones that arise in the abstract semantics. However, the fact that both are defined \nfrom a shared root concept (namely Definition 2.2) helps in defining the abstraction re\u00adlation that relates \nthem (see Definitions 4.4 and 4.5). In the concrete semantics, which is given in Section 3, the result \nof an execution sequence is a shape-graph that represents the state of heap-allocated storage in memory. \nIn this case, each shape-node represents a unique run-time location, and for each variable x, either \nEu (z) is a singleton set (say {n}) or it is empty. Furthermore, E. (n, car) and E, (n, cdr), which represent \nthe run-time locations pointed to by the car and cdr fields of n, are also either singleton sets or empty \n(depending on whether these fields point to allocated locations or not), Such properties are captured \nin the following definition: Definition 2.3 A shape-graph as deterministic zf (i) for every x c Pvar, \nlEo(x)/ < 1 and (ZZ) for every shape-node n and sel ~ {car, cdr}, [Es(n, sel)l < 1. The class of deter\u00ad \nmznistzc shape-graphs M denoted by DS~. 0 Finally, in several places we make use of a garbage\u00adcollection \noperation to eliminate shape-nodes that are not reachable from any of the program variables. Definition \n2.4 The functzon gc: S~ + S~ zs defined by gc((Eu, E.)) ~f (IL, Ej), where (s, sel, t) = E: ijf(s, sel, \nt) G E,, and there ezzsts [x, r] G E. such that there is a path of selector-edges zn Ea from r to s. \n0 3 The Concrete Semantics In this section, we present a concrete semantics in which deterministic shape-graphs \nare used to represent the mem\u00adory state (i.e., I)SG shape-nodes represent cons-cells ), and the meaning \nof an assignment statement is a deterministic shape-graph transformer. This concrete semantics is used \nto define a concrete collecting semantics that associates a set of possible shape-graphs with each point \nin the program. Figure 2 contains the semantic equations of the concrete semantics. The meaning of a \nstatement st is a function [st]mg: DSG + DS i7. (When examining the last four equations in Figure 2, \nbear in mind that, because of the Normalization Assumptions of Section 2.1, before each of the statements \nexecutes it is known that the left-hand side evaluates to nil. Thus, the last four equations need only \nhandle the gen aspects of the statements semantics. The kill aspects are handled by the first two equations \nof Fig\u00adure 2.) The DSG transformers listed in Figure 2 cover the six kinds of pointer-manipulation statements; \nall the other DSG transformers for predicates and for assignment state\u00adments that do not perform any \npointer manipulations are the identity function. By design, the (concrete semantics is somewhat non\u00adstandard. \nThe only part of the store that the concrete se\u00admantics keeps track of is the heap-allocated storage; \nfur\u00adthermore, it does not interpret predicates, read statements, and assignment statements that do not \nperform pointer ma\u00adnipulations. These assumptions build a small amount of ab\u00adstraction into the concrete \nsemantics. The consequence of Figure 2: The concrete semantics [st]m~: DSG -+ DS~. The shape-graph transformer \nassociated with all predicates and all assignment statements that do not perform any pointer manipulations \nis the identity function. The term nne~ denotes an operation that generates a new shape-node (i.e., a \nnew run-time location). these assumptions is that the collecting semantics may asso\u00adciate a control-flow-graph \nvertex with more concrete shape\u00adgraphs (i.e., DSL7S) than would be the case were we to start with a conventional \nconcrete semantics. (Our assumptions are patently safe, and so we will not take the space here to justify \nthem further.) For simplicity, we do not introduce any garbage-collection operations in the concrete \nsemantics to eliminate nodes from 21S~s that are not reachable from any of the program variables. Also, \ndereferences of nil pointers are ignored. They are handled in [SRW95]. We now turn to the collecting \nsemantics. For a control\u00adflow-graph vertex w E V, let paths To (v) be the set of paths in the control-flow \ngraph from start to predecessors of v. Definition 3.1 The collecting semantics cs: V + 2Dsg is defined \nas follows: Cs(v) :f { [St(wk)]nsg(.  ([st(w)lns~((o, 4)))) I [v,,... , v~] C paths To(v) } 0 4 The \nAbstract Semantics In this section, we present a shape-analysis technique that uses a restricted subset \nof shape-graphs, called statzc shape\u00adgraphs, to summarize the possible shapes that heap-allocated storage \ncan take on. Example 4.1 Suppose x points to a five-element list at the beginning of the list-reversal \nprogram. Column two of Fig\u00adure 3 shows the DSGS that arise at vertex V2. The abstract (summarized) representations \nfor the six DSGS are shown in column three. The abstract value that is computed by the abstract semantics \nis the graph shown in the iteration-4 row of column four. (In this example, this graph is exactly the \nunion of the six graphs shown in column three.) El Static shape-graphs are defined in Section 4.1, the \nab\u00adstraction function is defined in Section 4.2, and the abstract semantics is given in Section 4.3. \nThe reverse program is used as a running example. Section 4.4 explains the reasons for the accuracy of \nthe analysis method, and shows that the method is capable of handling the insertion of an element at \nan arbitrary point in a linked list. 4.1 Static Shape-Graphs Unlike the concrete shape-graphs of the \ncollecting senlan\u00adtics, the static shape-graphs of the abstract semantics are non-deterministic: E (x), \nEs (n, car), and E, (n, cdr) may each yield a set with more than one shape-node. In ad\u00addition, static \nshape-graphs are of bounded size. This is achieved by our naming scheme for shape-nodes: the name of \na shape-node is a (possibly empty) set of program vari\u00adables; in general, the abstraction function clusters \nmultiple concrete shape-nodes into a single static shape-node. Definition 4.2 A static shape-graph is \na pair (SG, is-shared), where SG is a shape-graph.  The set shape. modes(SG) is a subset of {n.x I \nX C PVar}.  zs.shared is a functaon of type shape-nodes(SG) --+ {fake, true}.  The class of stattc \nshape-graphs is denoted by SS~. 0 In the following definition, we impose an order on SSGS where SG ~ \nSG if SG1 contains more edges than SG. Definition 4.3 Let SG = (( E., E.), is-shared) and SG = ((E;, \nEl), is.shared ). We dejine the following ordering on SSG: SG ~ SG if and only t.f For every n ~ shape-nodes(SG), \nzs.shared(n) + is_shared (n).  0 The domain SS~ is a complete join semi-lattice with a join operator \nU defined by: SG U SG ~f ((EU U E;, E. U E:), is-shared V zs-shared ). 4.2 The Abstraction Function \nOur task in this section is to define the abstraction function that relates the domains 2Vsa and SSg. \nHowever, before formally defining the abstraction function in Definition 4.5, we first illustrate some \nof the semantic properties of SSGS. Column two of Figure 3 shows the DSGS that arise at vertex V2 for \nall five iterations of the loop in the list-reversal program when input-list z is a five-element list. \nColumn three shows their corresponding abstract values (i.e., SSGS). We note the following: (i) In each \nSSCJ in column three, a shape-node nz, where Z # #, represents a unique run-time location in the corresponding \nDSG in column two the location pointed to by every one of the variables in Z. However, across the collection \nof SSGS that are the abstractions of the (several different) DSGS that arise on different loop it\u00aderations, \nnz will, in general, denote different run-time locations. For example, shape-node n{z ,L, } represents \nthe run-time locations 12, [3, t4, and 15 in the DSGS that arise on iterations 1, 2, 3, and 4, respectively. \nIter. DSG a(DSG) Approx. sequence for SGU2 ((4, d), An.falw) x ++ 1\u00b01 -m+cE7 o 1112 131415 n{.} x tl \n12 13 14 15  4 1 ] :-x\u00adn{z, tl} Y* e -co 1 11 {v} x tl 14 15 t % ii n{z,il} 0 a Y ,&#38; nit} ~ \n ~ 11 n{u}2 z tl EL n{z, il} + +no d] :* n{r, tl} n~ eY y&#38; tY *t 1,9, 12 11 n{v} n{t}3 {?/} n{t} \nx tl *  =111 =ml ,, I n~ + x,+y\\, 15 n{z,tl} x t e---+ tl n{z, f~} n4 YY e-----+ tY e+-t 14 13 12 \n11 n{v} 4 n{t} n{v} n{t} n~ The fixed point has been t reached. Y etY +,~ e +13EE n{Y} nit} 5 15 14 \n13 12 11 Figure 3: Columns two and three show the DSGS and the corresponding SSGS, as mapped by ~, that \narise at vertex V2 for the five iterations of the loop in the list-reversal program, when the input r \nis a five-element list. Column four shows the SSG values that SGti2 takes on during the process of finding \nthe solution to the equations of the abstract semantics. For each of the shape-nodes in all of the SSGS, \nthe value of Zs-shw-ed is false. (ii) In contrast, shape-node nd can represent multzple mm-time locatzom \nof a single DSG. For example, in the SSG in column three of the iteration-O row, no rep\u00adresents the run-time \nlocations 12, 13, 14, and lE, of the DSG in column two. In the SSG in column three of the iteration-5 \nrow, no represents the run-time loca\u00adtions 13, 12, and 11. (iii) In different SSGS, the same run-time \nlocation may be represented by different SSG shape-nodes. For in\u00adstance, consider the SSGS in column \nthree of Figure 3 in top-to-bottom order. Location 11 is represented by shape-nodes n{n}, n{g}, nftl, \nno, n~, and n~; location 13 is represented by nd, no, n{~,tll, n{y}, n{t},andw; location 15 is represented \nby no, n~, no, n~, n{~,tl }, and n{y}. There is an important conclusion to draw from these ex\u00adamples: \nIt is incorrect to think of a shape-node as represent\u00ading a fixed partition of memory. Instead, the ideas \nto keep in mind are the following: The variable set of a shape-node in the shape\u00adgraph for program-point \nu consists of variables that, for some execution sequence ending at v, must all point to the same run-time \nlocation. By going from DSGS to SSGS, we deliberately drop information about the concrete locations, \nbut we keep information that indicates, for some ezecu\u00adtton sequence ending at v, what variables must \nall point to the same location. A consequence of this abstraction is that two different shape-nodes \nnx and ny such that .X n Y # ~ represent incompatilde configurations of variables; that is, na-and ny \ncannot possibly represent information from the same DSG. This means that the following structural invariants \nhold for the SSGS that arise in the abstraction process: Invariant (i) ( Equality-or-disjoin tness of \nedge end-points ) For all (nX, sei,nY) EE,, either X = Y or X nY = q5. For example, in the SSG in column \nfour of the iteration-4 row, the selector-edge (niul, cdr, nfil ) sat\u00adisfies {y} n {t} = ~. This SSG \ncould not contain a selector-edge such as (n{ Z}, cdr, nf~,il } ). Invariant (ii) lf is-shared(n) = true \nfor a node n,, then one or more of the following conditions must hold: (a) There exists a selector edge \nfrom no ton. Since nd can represent multiple locations, this single edge can represent two or more selector \nedges in a given DSG. (b) There exist two selector edges from different shape nodes, say, n.zl and nzz \nwhere Z1 n Z2 = # to n. In this case, there may exist a DSG that includes two se\u00adlector edges: one from \nthe run-time location pointed to by the set of variables Z1 and one from the run\u00adtime location pointed \nto by the set of variables Z2. (c) There exist two selector-edges (with different se\u00adlectors) from a \nsingle shape-node. (Figure 3 does not illustrate these conditions because none of the shape\u00adnodes are \nshared. )  Because the converse of Invariant (ii) need not hold, shar\u00ading information must be stored \nexplicitly in SSGS. For ex\u00adample, in the SSG in column three of the iteration-O row, w_shared(n4) = false \neven though there exists a selector edge from nd to itself and a selector edge from n{z} to no. In this \ncase, the fact that w-shared(nd ) = false indicates that n+ s incoming edges represent DS G edges that \ncan never simultaneously point to the same DSG node. The abstraction function a is defined in Definition \n4.5; a makes use of several auxiliary functions whose definitions are given in Definitions 4.4 and 4.5. \nDefinition 4.4 defines an operation for renaming shape-nodes. (This function will be used both in the \nabstraction function and in the abstract semantics. ) Definition 4.4 Let SG = (EV, E,) be a shape-graph, \nand let p: shape-nodes(SG) + {false, true} and f: shape.nodes(SG) + {nx I X ~ PVar} be functions. We \ndefine four projection operations wtih respect to f as follows: (Ev$f) ~f {[z, f(n)] I [z, n] c Eu} (E,.Jf) \n~f {(f(s), sel, f(t)) I (s, sel, t) ~ Es} {~lf(~)=nx} Finally, ((EU, E.), p)J f ~f (( EoJf, Es Jf), \npJf). 0 Definition 4.5 (The Abstraction Function) The func\u00adtzon as [DSG]: shape_ nodes(DSG) --+ {nx I \nA ~ PVar} M defined as follows: o+SIDSG] ~f ~r.n{ze PVarl[z,r]e E,,} The functton tnduced_is_shared [DSG] \nfrom shape_nodes(DSG) to {false, true} is defined as follows: induced. is.shared[DSG] *,t)E Es} (t) ~f[{(*,I \n>2 The abstraction function a: 2DSQ -+ SS~ is defined by: DSGGS where &#38;(DSG) ~f letDSG = gc(DSG) \nin {DSG , mduced_is_shared[DSG ]) JQ~[DSG ] 1 The core of Definition 4.5 is the operation of projection \n(~) with respect to a. [DSG ]. The function CYS[DSG ] es\u00adtablishes the relationship between the nodes \nof a DSG and their corresponding nodes in the SSG. For example, con\u00adsider the iteration-1 row of Figure \n3. In column two, DSG node 12 is pointed to by program variables z and tl and is mapped by a~[DSG ] to \nSSG node n{z,tl) (see column three). DSG nodes 1s, 14, and 15, which are not pointed to (directly) by \nany variables, are mapped to SSG node no. In general, as [DSG ] generates a finite set of SSG nodes from \nthe a priori unbounded number of DSG nodes in DSG . The projection operation then collapses the DSG onto \nthe smaller set of nodes, while preserving aspects of its structure. We say that a shape-node nx represents \na shape-node n in DSG if o+ [DSG ] (n) = nx. The function mduced..is_shared[ DSG] checks whether a node \nhas 2 or more predecessors in DSG. Because of the projection performed with respect to a, [DSG ], an \nSSG node s sharing value is true if any of the DSG nodes it rep\u00adresents has 2 or more predecessors in \nDSG . (This aspect of as [DsG ] is not illustrated by the example presented in Fig\u00adure 3.) On the other \nhand, if projection-function a, [DSG ] sets the sharing value of SSG-node nz to false, this means that \nthe DSG node (or nodes) that n,z represents all only have at most one predecessor. For example, consider \nthe x := new iteration-O represents row the of Figure run-time 3. In the locations SSG in column three, \nn~ 12, 13, 14, and 15, each of y := new t:=new which has exactly one predecessor in the DSG (see column \nx.cdr := t two). Consequently, w-shared(nd ) = jalse. Note one role of the gc operation that appears \nin the definition of~: if DSG contains agarbage shape-node that has 2 or more predecessors, this will \nbe filtered out by the gcoperation and will not affect thevalue ofzs_shared(n4). Example 4.6 Definition \n4.5 provides a way of identifying a shape-graph with a data type. Figure 5 shows the shape\u00ad graphs that \nrepresent five kinds ofdata types. Foreach DSG SGinone of the five indicated classes, ~(SG) approximates \n(~) thecorresponding graph shown in Figure5. (For the moment, ignore graph (f).) The reason why approximates \n(~) is used here is that the shape-analysis algorithm is a conservative algorithm and thus the shape-graphs \nproduced may have superfluous edges. Therefore, when the algorithm reports that a variable points to \na circular list, it may actually point to a non-circular list; however, when the algorithm reports that \na variable points to a non-circular list, it will never point to a circular list. This kind of conservative \napproximation is appropriate for use, for example, in parallelizing compilers [HNH92, HG92]. (An extension \nof our basic technique allows dejinttely circu\u00ad lar structures to be identified. See Section 5,4,) o \n 4.3 The Abstract Interpretation The abstract meaning function [ ].ss G:SSL7 + SSfJ for the pointer-manipulation \nstatements is given in Figure 6. The operations presented in Figure 6 manipulate variable-edges, selector-edges, \nand sharing information, as well as the alias information that is maintained in the shape-node names \nof SSGS. It has been shown that these SSG transformers are conservative with respect to the concrete \nsemantics defined in Figure 2 (see [SR\\V95]). The key property of the abstract semantics is that each \nabstract assignment operation crest es an SS G that conser\u00advatively covers all the possible new configurations \nof variable sets whose members all point to the same run-time location (i.e., DSG shape-node). This permits \nan unusual treatment (for a static-analysis algorithm, that is) of statements of the form z.selo := nil. \nWhen the algorithm processes such a statement, it always removes the selo edges emanating from what x \npoints to. We call this operation strong nullification. Example 4.7 Figure 4 shows a simple example that \nillus\u00adtrates strong nullification. Note that after statement y := z in the then-branch of the conditional, \nz and y point to the same run-time location. This is reflected in SG2 by the fact that x and y point \nto a single shape-node, n{z,v}. SG3 is the union of SGZ with SGI; x and y each point to two shape\u00adnodes \nin SG3. Because n{z,y} in SG3 represents only run\u00adtime locations that are pointed to by both x and y \n(which occurs only on some execution sequences), it is safe for the abstract semantics for statement \ny. cdr := nil to eliminate the edge from n{z,v} to n{~} (see SGA). Note that if rs{z} and n{z,y} were \nmerged into one shape\u00adnode in SG3, then it would not be possible to perform a strong nullification because \na run-time location pointed to by x alone does have a cdr-edge emanating from it (i.e., to the node that \ntpoints to). 0 SGI ==z t EEi !I I q.} n{t}   n{v} if then y:=z SG2 =; t n{z,v} n{t} fi G3 -E3mt \n;2 141 I I-y n{z>v} n{Y} y.cdr := nil SG4 =X t n{z} n{t}  Y x?/1 uIII Ik- n{z>Y} n{Y} Figure 4: A \nprogram that illustrates strong nullification. We now discuss the individual cases of the abstract mean\u00ading \nfunction (Figure 6), illustrating the most important fea\u00adtures using Figure 7, which shows the final \nSSGS computed for each program point by abstract interpretation of the de\u00adstructive list-reversal program. \nEach block of Figure 7 in\u00addicates the shape of memory just before the program-point label that appears \nat the bottom of the block. The text at the top of a block indicates the preceding program point (or \npoints) in the control-flow graph and the action(s) taken there. For example, 7J15 s one predecessor \nis the statement t:=nil at v14. (on first reading, it maybe helpful to skip the remainder of this section \nand proceed directly to Section 4.4, ) * For an assignment x := nil, the projection operation is used \nto rename shape-nodes by removing z from their name .. Note that this may cause what were formerly distinct \nshape-nodes to be merged. Example. In the transition between block VT and block 08 of Figure 7 the assignment \ntl := nil causes n{~,z,i, } and n{~,z} to be merged. 0 For an assignment x. seio := nil, the SSG transformer \ngiven in Figure 6 removes all of Z S selo selector-edges (what we called strong nullification above). \nThe variable set of a shape-node in the SSG for a program\u00adpoint v consists of variables that, for some \nexecution z n{ } 9  (a) A linked-list (b) A tree (c) An arbitrary graph x 11 nnil =!=-T (d) A possibly \ncyclic list (e) A possibly cyclic list (f) A possibly cyclic list of length >2 of length > 1 of length \n~ 1 (see Section 5.4) Figure 5: SSGS that represent five kinds of data types. For each of the shape-nodes \nin all of the SSGS but (c), the value of is.shared is false. In the graph (c) both nodes are shared. \nsequence ending at v, all point to the same run-time Example. See the transition between block location; \ntherefore, our met hod can always remove z s 7)6 and block v? of Figure 7. 0 selo selector-edges. 3 The \nSSG transformer for an assignment z := y.selo Example. In Figure 7, the transition be-is the most elaborate \noperation. The reason is that tween VII and v12 removes all of y s cdr selector-y.selo may point to many \nnodes, and we have to cre\u00adedges. 0 ate an SSG that conservatively covers all the possible new configurations \nof variable sets whose members all The other important aspect of the SSG transformer point to the same \nrun-time location (i.e., DSG shape\u00adfor x.selo := nil is the way information in shape-node node) after \nthe assignment. That is, if y.selo points names is used to reset the sharing information. This to n.z, \nthen we need to materialize a copy of nz is based on Invariant (ii) of the abstraction process, producing \na new node n(zu{z}) from old node nZ. as described in Section 4.2. (The resetting of sharing In defining \nthis materialization operation, the goal is information by the SSG transformer is not illustrated to \ncover conservatively all the possibilities, yet at the by the list-reversal program since IS-shared is \nfalse for same time not introduce too many superfluous edges all shape-nodes in all shape-graphs that \narise. This that prevent the abstract semantics from being able issue is discussed further at the end \nof Section 4.4.) to verify interesting properties, e.g., that a variable points to a list. o For an assignment \nx := new, a new unshared node n{z} is created. All other shape-nodes are unaffected. Examde. See the \ntransition between block . vs and block VQ of Figure 7, in which node For an assignment z := y, the shape-node \nnames are n{il ~ is materialized from no. 0 charmed to reflect the fact that whatever v was point\u00ad ing \nto before is now also pointed to by x. In addition, In what follows, let rLY be a shape-node that y \npoints new variable-edges are added to reflect the assignment to. For every node nz pointed to by y.selo, \nwe ma-Ofy to x. terialize a new node n(zuf.}) and direct the following ., edges to n = n(zu{z}): 30tl~er \nshape analyses do not Ilandle tl]is statement precisely, or handle it precisely not claiming tlmt only \nunder our metl~od certain circumstances. is somehow able to However, we are treat all statements . Old \nvariable-edges that point to rzz before the precisely . In Figure 6, tbe inevitable loss of precision \nintrinsic to assignment. (This does not occur in the transition static-analysis occurs in tile treatment \nof statements of tile form z := between block vs and block v~ of Figure 7.) g.se10 (when y points to \nn+), rather than in statements of tbe form z,selo := nil. In particular, in tl~e SSG transformer for \nz .= y.selo, . A new variable-edge from z. (See variable-edge a node-materialization operation is used \nto create shape. nodes tl]at [t,, n{,,]] in block VQ of Figure 7.) conservatively cover all tbe possible \nnew configurations of variable sets whose members all point to tile same run-time location.  A selo \nselector-edge from n>,. This edge replaces the old selo selector-edge that emanates from ny [z := nil] \nSs~(((EU, E,), ts.shm-cd)) ~f (gc(((EV [z, *], E.), zs-shared)))+Anx.n~~_~O~~ [Z.selo := nil]~Sg ((@V, \nE.), is.shured}) ~f ((Ev, Ej), ts_shared ) where E: = (Es {(nx, selo, *) \\ z ~ X}) (nd, *,n) EE: (a) \nand is.shared (n) = is-shared(n) A v %.zl, n.zz :21 nzz = q$,(nzl, *,n), (nzZ, *,n) e JZ (b) V %z : (nz, \ncar, n), (nz, cdr, n) @ E: (c) ( ) [z:= new] SS~(((13v, E.), is-shared)) ~f {(EV U {[$, n{.}]}, E.), \nis-.shared[n~r~ * fake]) 72LZUIZ}) ify C Z dcf let ((EL, EL), is-shared ) = ((Ev, ES), ts_sharecl) JAnz. \nnz [x:= y]ssg((@u, E,), is-shared)) = { otherwise in ((EL u {[x)ny] I [y, nY] c E~,}, Ej), is-shared \n) [z:= y.selo]ss~(((E~, Es), u-shred)) ~f ((E;, E~), ts-shared ) where {[z, n~zu~=~j] I z = x V [z, nz] \n~ E.} ~ = O u UYcy,(~Y,selo,nzjcE. E: = (E. {(nY, selo, *) \\ y G Y}) U UveY,(nY,selo,nz) eE~ disjoint-or-equal( \nassign (x, n~, selo, nz)) {(ny, selo,n~zu~z}j) I Y #Z} old + new U {(n(.zu{z}j,se~,nw) I (y # .ZV sel \n# selo), (nz, sel, nw) c Es} new -+ old (nfzu{~lJ, sel, n(zuixl)) \\ ((Z= Y A sel = selo) V w.-shared(nz)), \nnew -+ newassign (x, ny, selo, n,z) = u (nz, sel, nz) c Es 1} (nw, d, q,zu{.})) / (Y< W V sel # selo), \nts..shared(nz), u old -+ new (nw, sel, rLZ) E Es 1 and is_shared (nz) = is-shared (n(z {~ })) [z.selo \n:= y].ssG(((E~, E.), is-shared)) ~f {(E,,, E:), is-shared ) where E: = E. U dzsjoint.or_equa/( {(nX, \nseto, ny) / [z, nx], [Y) ny] E E.}) and is-shared (n) = zs-shared(n) V I{(n , *, 7)) ~ E., I [y, n] \nE l?,,}] > 1 disjomt-or--.equal( ).) ~f {(n~, sel, n~-) I (n.x, sel, nY) c E., X = Y V X n Y = ~} Figure \n6: The SSG meaning function [st].ssg: SS~ + SSL7 for a statement st. before the assignment (see the first \nold + new only if nz is a shared node. (See the new + new case in Figure 6 and selector-edge (n{u,~j, \ncdr, ?qtl}) case). (This also does not occur in the transition in block V9 of Figure 7.) This selector-edge \nis not between block Ws and block W9,) added by the old -+ new case when Y ~ Z, be\u00ad Selector-edges from \nother old predecessors of nz cause all directly cyclic selector-edges are handled need to be connected \nto n if they can simultane\u00adby the new + new case. ously coexist with the selo selector-edge from ny \n An edge (n, selo, n) is materialized when nY has (see the second old -+ new case). Here, we take a selo \nselector-edge to itself. (See the new + advantage of the variables in shape-node names; new case). (This \ndoes not occur in the transition in particular, a predecessor of nz that has y in its between block us \nand block VO.) name is incompatible with ny. (This does not oc\u00ad cur in the transition between block \nvs and block  Suppose there is a selector-edge (n~, selo, nz ). lx.)  When nZ has a sel selector-edge \nto itself, a selector\u00adedge (n, set, n) is materialized if (nz, sel, rLZ ) and  We also connect n to \nthe old successors of nz for all (nY, selo, n.z) represent edges that can simulta\u00ad the selector-edges \nwhere Y # Z or sel # selo (seeneously co-exist in some DSG. This can happen start vl:y := nil vlz:y. \ncdr := t x X--4 I%1 r 1 II n{z} n,, -, <i--+---l -I*J x--+ x ~1--+ tl n,, -..1 n{x,t1} ?4-+ e  t \n; 1\u00b01 n{v} n{t} VI m? v!? vs:t := nil V4: :=y v5: y := nil IIt xx qz} n{. } 1I I I /J.. 1 x-+ x e tl--+ \ntl  Tl@ =L_-Lzr + qx,t ~} wx,tl } wx,tl} wd Y+ t n{v} V4 V5 ve:y := X v7:tl := nil va: tl := x.cdr \n+ x Y wg,z} I I t nit} Q+---Q3 v? 0i3 V9 v9:x := nil VII): a := 1 vll:y. cdr := nil tl Y n{ri} n{tl} \n1 -P - II W---Q2l \u00ad VII VIZ .. V13: tl := nil v14: t:=nil z n{z} z z-+ q.} ;1 ---\u00ad n{n!t 1} Y-+0 \nY ; I*I CEFaI!l t qt} n{?f} qt} n{Y} n{v} V13 V14 V15 Figure 7: The final SSGS computed for each control-flow-graph \nvertex by abstract interpretation of the destructive list-reversal program (e.g., block V2 corresponds \nto column four of the iteration-4 row of Figure 3). For each of the shape-nodes in all of the SSGS. the \nvalue of is.shared is false. the new -+ ald case). (This does not occur in the transition between block \nV8 and block V9.) The operation dis?oint.or.equak SSIJ -+ SSL7 elimi\u00adnates selector-edges whose end-points \ndo not satisfy Invariant (i) of the abstraction process (the (equality\u00ador-disjointness property for the \nvariable-set names of selector-edge end-points described in Section 4.2). (This does not filter out any \nedges in the transition between block VX and block w.) e Finally, for an assignment z.selo := y, a selo \nselector\u00adedge is added between shape-nodes pointed to by x and shape-nodes pointed to by y In addition, \nall nodes that are pointed to by both y and a selector-edge be\u00adfore the assignment are now considered \nto be shared nodes. Example. See the transition between block VIZ and block VQ of Figure 7. 0 The abstract \nsemantics associates an SSG, SGU, with each v ~ Iz. Equationally, this can be defined as the least fixed \npoint (under the ordering defined in Definition 4.3) of the following system of equations in SG.: Given \nhow complicated the ure 6 are, the following theorem, in [SRW95], is reassuring: Theorem 4.9 (Correctness \nflow-graph vertex v, a(cs(v)) L 4.4 What the Analysis and Why semantic equations in Fig\u00adwhose proof can \nbe found Theorem) For every control-SGV. 0 Algorithm Achieves The abstract interpretation defined in \nSection 43 yields a new shape-analysis algorithm for finding out information about the possible shapes \nthat heap-allocated structures in a program can take on. For certain programs includ\u00ading ones in which \na significant amount of destructive updat\u00ading takes place this algorithm is able to verify shape\u00adpreservation \nproperties. Examples of such properties in\u00adclude: (i) when the input to the program is a list, the output \nis (still) a list; (ii) when the input to the program is a tree, the output is (still) a tree; and (iii) \nwhen the input to the program is a possibly circular list, the output is a possibly circular list. For \ninstance, we are able to conclude from the sG = ((h 0),~~.f~~se) if v = start information reported by \nthe algorithm about the list-reversal v m-omam that list-ness is m-eserved (see Fimrre 7). 1 1) u(u,.)cA[ \nt(~)n~s~(sG ) therwise { ~he algorithm is also a~le to determine t~at The least-fixed point of these \nequations can be found by iteration, starting from ((~, ~), An. false). Example 4.8 The final abstract \nvalues for all of the ver\u00ad tices of the list-reversal program s control-flow graph are shown in Figure \n7. Among other things, this information tells us is that if Z S value is a list at the beginning of the \nprogram (see block VI) then y s value is a list at the end of the program (see block VI S). Column four \nof Figure 3 shows the SSGS computed for vertex v? of the list-reversal program during the successive \niterations of the fixed-point-finding procedure. The final abstract value for vertex V2 (i.e., SGU2 ) \nis the graph shown in the iteration-4 row of column four. The elements of this graph can be interpreted \nas follows: e There are two shape-nodes that represent the head of the list that z points to: n{. } and \nntz,tl }. The former represents the situation where x points to the head of the list and tlpoints elsewhere \n(which only happens before the first iteration of the loop). The latter represents the situation where \nz and t]both point to the head of the list. Shape-node n{y} represents the head of the list that y points \nto. Shape-node n{t} represents that tpoints to, which is a sublist of the list that to. Shape-node nd \nrepresents all the run-time in the tails of the lists that x and t point to. e For each of the shape-nodes \nin the graph, the zs.shared is false. The fact that ts-.shared(no ) = reversed the list y points locations \nvalue of fake tells us a number of interesting things about the memory state (i.e., DSG) produced by \nany execution sequence that ends at vertex V2: (1) It implies that selector-edges from z and from t cannot \npoint to the same node (and consequently the tails of z and (2) Similarly, for inthetail ofxor locations \ncannot variables z and share any storage tcannot have a component in common). every pair of different \nrun-time locations t, the selector-edges from these run-time point to the same node. Consequently, t \nmust point to acyclic lists that do not in common. e list-ness is preserved by the list-insert program \ngiven in Figure 8 (which searches a list and splices a new element into the list). * circular list-ness \nis also preserved by the list-insert pro\u00ad gram. More precisely, if at program z is a possibly cyclic \nure 5(e)), then at the end of cyclic list of length ~ 2 (see see [SRW95, Appendix B]. ) It is instructive \nto consider the beginning of the in~ert list of length ~ 1 (see Fig\u00adthe program, z N a possibly Figure \n5(d)). (For details, the main reasons why the shape-analysis algorithm is able to produce accurate infor\u00admation \nabout the list-reversal program. In analyzing this program, the key issue is: HOW does the algorithm \nkeep the y list separate from the z list? There are two aspects of the algorithm that contribute to the \nsuccessful handling of this problem. Cutting the list. The more clear-cut aspect is the removal of y \ns cdr selector-edges by y. cdr := nil via strong nulli\u00adfication in the transition from block V11 to block \nVIZ in Figure 7. This cuts the y list at the head, separating the first element, n{ V}, from the tail, \nwhich z and tI point to. Materialwut%on of n{tl } from portant is the way the ment of tl down the z tion \nfrom vs to V9. At the node-materialization summary shape-node, of rqj.1 In the shape analysis of the \nsummary-node nb. Equally im\u00adalgorithm handles the advance\u00adlist by tl :=-z. cdr in the transi\u00ad OS,x. cdr \npoints to n~; however, operation causes a new non\u00ad n{fl }, to be materialized out list-reversal program, \nthere is a crucial interaction between these two aspects. Suppose, for example, that in the transition \nbetween blocks OS and V9 shape-node n{tl } was not materialized out of summary\u00adnode no, but instead variable \nt 1 was merely set to point to no, At Vll, variables t1 and x would then both point to 4Jocularly, we \nrefer to nd as tile primordial soup , and tl]e pro\u00adcess of mziterializlng a node SUC1l as 7J{tl ~ from \nn+ as ladling a node out of tile soup . nd. The removal of y s cdr selector-edges in the transition \nfrom Vll to V12 would still separate the node that y points to (n{V} ) from the list pointed to by z \nand tl (which in this case is no.). However, the very next transition, from VIZ to V2, would set y s \ncdr field to t,whose cdr field points to nd, which is what z points to. At this stage, the two lists \nare no longer known to be separate lists! Note how differently things turn out when n{~l } is ma\u00adterialized \nfrom n~ in the transition from WSto w9: At V12, tl and x point to n{n,~l }, and thus in the transition \nfrom v12 to V2 when y s cdr field is set to t,whose cdr field points to nb, x does not point to n~. Although \nnb occurs in both the tail of z and the tail of y, because Is.shared(n@) = false we know that the two \nlists cannot share any storage in common; that is, z and y must point to disjoint acyclic lists. The \ntwo operations discussed above cutting a list and advancing a pointer down a list are two of the four \nmain operations of most list-manipulation algorithms. The third and fourth common list-manipulation operations \n splicing a new element into a list and removing an element from a list can, in many cases, be handled \naccurately by our shape\u00ad analysis algorithm, even if shape-nodes tem,porarily become shared? (This is \nnot illustrated by the list-reversal program, but is discussed in the next paragraph.) This points up \nthe strength of our approach: Our algorithm handles all four of the basic list-manipulation operations \nwith a remarkable degree of precision as well as similar tree-and circular\u00adIist-manipulation operations. \nLet us now turn to the issue of how information in shape\u00adnode names can sometimes be used to reset a \nshape-node s sharing information from true to false. This ability is the main reason why our algorithm \nis able to determine that the list-insert program of Figure 8 preserves both Iist-ness and circular list-ness \n. This situation arises in the list-insert program at ver\u00ad tices v1l, vlz, and VM of the control-flow \ngraph, where the new element is spliced into the list. (We assume that at the beginning of the program \nshown in Figure 8, z points to an unshared list of length 1 or more and e points to the new element to \nbe inserted. ) The key step is the transition from VIZ : y. cdr := nil to V13. In the immediately preced\u00ading \ntransition, from VII to vl~ (see Figures 9(a) and 9(b)), e. cdr is assigned the value t,which adds a \nnew selector-edge into n{t} and causes is-shar-ed(n{i} ) to be set to true in the shape-graph for v12. \nIn the SSG transformer given in Figure 6 that covers the case of assignments of the form y. cdr := nil, \ninformation in shape-node names is used to reset the sharing information. In particular, n{t} meets none \nof the three conditions for is-shared to be true at vertex v13 and so ts-shared(n{i} ) is reset to false \nat V13. (See Figure 9(c).) Remark. It is interesting to note that if the assignment at v12 were e.cdr \n:= n% rather than y. cdr := nil, is.shm-ed(n{t} ) would be reset to false at V13, even though there would \nbe two incoming selector-edges to n{ f}: (n{2,V}, cdr, n{t} ) and (n{. ,}, cdr, n{,}). This is consistent \nwith the concrete se\u00adman~ics because the shape-node names ?Z{,,Y} and n{~,vi tell us that (n{ Z,V}, cdr, \nn{i}) and (nf~,vi, cdr, qt})are incom\u00adpatible . Because {z, y} n {z, y} # 4, we know that n{z,y} and \nn{~,vl do not represent nodes that co-exist in any DSG. This explains condition (b) in the y. cdr := \nnil case of Fig\u00adure 6. 0 y:=x J while y.cdr # nil A do VI y := nil z := y.cdr y:=z V2 Y:!x [ od J_ \nJ t := y.cdr V3 e.cdr := t + y.cdr := e V4 z:= nil t := nil i z := nil V5 z := y.cdr 1J e := nil \nJ y:= nil v6 y:= nil y L----+ V7 (a) v8 y := nil y:=~ V9 = while y. cdr # nil A do .z := nil vIo e.cdr \n:= nil z := y.cdr y := nil ?)11 e.cdr := t y:=ij s od VIZ t:=nil t := y.cdr U13 e.cdr := nil e.cdr \n:= t m4 y. cdr := nil + y.cdr := e V15 z := nil E=I 1 t:=nil z := nil V16 e := nil e := nil y := nil \nV17 y := nil v18 (b) II (c) Figure 8: A program that searches a list and splices a new element into the \nlist. 5 Extensions 5.1 Merging Shape Nodes The number of shape-nodes in an SSG is bounded by 21 v l. \nUnfortunately, for some pathological programs the number of shape-nodes can actually grow to be this \nlarge (although our limited experience to date suggests that this is unlikely to arise in practice). \nIt is possible to overcome this problem by making use of a widening operator that merges selected shape-nodes. \nBy this means, we can guarantee that a fixed point of Equation (1) of Section 4.3 can be found in polyno\u00admial \ntime; the widening operator simply has to be applied whenever necessary to limit the cardinality of shape-node \nname sets to some chosen constant. (This is similar in spirit to k-limiting [JM81], but is likely to \nproduce more accurate results because limiting the cardinality of name sets still pre\u00adserves most of \nthe structural information about the graph.) Details can be found in [SRW95]. / IY * It x6 /2 n{. } \nn{z,v} Eml,Tl n{z,y} n{e} (a) The shape-graph for vertex VI,. In this graph, is.shm-ed(n{tl) = ~ake. \nI! I n{. } (b) The shape-graph for vertex VIZ. In this graph, is_shared(n{ ~}) = true (shown in bold). \nI II I =EEle d n{z>.v} n{e} (c) The shape-graph for vertex VM. In this graph, i.s-sharecl(nftl) = false. \nFigure 9: The shape-graphs at vertices WI1, v12, and v13 in the list-insert program. These illustrate \nhow is-shared (n{,} ) is reset to false in the shape-graph for vertex 7JM. 5.2 Finding Aliases and Sharing \nIt is possible to use our shape-analysis algorithm to deter\u00admine whether two pointer variables z and \ny are possible aliases just before vertex v by testing whether z and y point to a common shape-node in \nSSG SGU. If x and y do point to a common node, we (conservatively) conclude that they may be aliases. \nIt is possible to extend this to a test of whether two access paths are may aliases , as follows: First, \nwe in\u00adstrument the original program with two additional tempo\u00adrary variables (say tl and t2) and code \nto advance tland tz down the two pointer-access paths in question. The code is inserted just before v. \nSecond, we apply our shape-analysis algorithm. Third, we look in the SSG computed for vertex v to see \nif tland tzmay be aliases. We can also use this approach to determine if there is possible sharing between \ncomponents of two heap-allocated data structures, which is precisely the kind of information needed to \nbe able to compile programs to take advantage of coarse-grained parallelism. (See [SRW95].) 5.3 Interprocedural \nAnalysis Our method can also be extended to handle procedure calls in a conservative way. Two fundamental \nproblems need to be resolved: @ Representing multiple occurrences of the same local vari\u00adable in (mutually) \nrecursive procedures. e Accounting for the different calling contexts in which a procedure can occur. \nTo approximate the local variables of recursive calls, we intro duce an extra variable z for every local \nvariable z. Vari\u00adable T is used as a representative for all copies of x in other scopes. Shape-nodes \nwhose name sets contain only barred variables are a new kind of summary node . Like n4, they can represent \nmultiple runtime locations from a single DSG. Using these ideas, we have extended the abstract semantics \nto handle procedure calls and returns. The second problem can be resolved using one of the known interprocedural \ntechniques of Sharir and Pnueli [SP81]. For example, a simple conservative solution is to consider a \nprocedure call as a goto to the called procedure and a re\u00adturn from a procedure P as a goto to all the \nstatements that follow an invocation of P. A more accurate solution can be determined by tabulating a \nshape-graph-transformation function for each procedure. 5.4 Representing Definitely Circular Struc\u00adtures \nIn the SSGS defined in Section 4.1, there are no elements that represent the fields of nodes that point \nto atoms or nil (or are uninitialized). One consequence of this is that the shape\u00adanalysis algorithm \nis only able determine rather weak data\u00adtype properties. As pointed out in Example 4.6, when the algorithm \nreports that a variable points to a circular list, it may actually point only to a non-circular list. \nThat is, the type (circular list really means (possibly circular list . By introducing three additional \nnodes, n~t~~, nil, and n.ninit, much more accurate type properties can be obtained in many cases. We \nimpose the invariant on SSGS that all fields of shape-nodes have at least one out-going selector\u00ad edge \n(possibly to n~t~~, nnil, or nuninit ) The consequence of this refinement is that this modified domain \nof SSGS is capable of representing definitely cyclic data structures. For example, with this extension \nthe SSG shown in Fig\u00ad ure 5(d) represents a definitely cyclic list of length > 2 (mod- U1Othe absence \nof edges from the car fields to n~to~ in the two shape-nodes); Figure 5(e) represents a definitely cyclic \nlist of length > 1; and Figure 5(f) represents a posstbly cyclic list of length >1. Related Work The \nshape-analysis problem was originally investigated by Reynolds for a Lisp-like language with no destructive \nup\u00addating [Rey68]. Reynolds treated the problem as one of simplifying a collection of set equations. \nA similar shape\u00adanalysis problem, but for an imperative language support\u00ading non-destructive manipulation \nof heap-allocated objects, was formulated independent ly by Jones and Muchnick, who treated the problem \nas one of solving (i.e., finding the least fixed-point of) a collection of equations using regular tree \ngrammars [JM81]. In that same paper, Jones and Muchnick also began the study of shape analysis for languages \nwzth destructive up\u00addating. To handle such languages, they formulated an anal\u00adysis method that associates \nprogram points with sets of fi\u00adnite shape-graphs.5 To guarantee that the analysis termi\u00adnates for programs \ncontaining loops, the Jones-Muchnick approach limits the length of acyclic selector paths by some chosen \nparameter k. All nodes beyond the k-horizon are clustered into a summary node. The k-limiting approach \nhas two inherent drawbacks: The analysis yields poor results for programs that ma\u00ad nipulate elements \nbeyond the k-horizon. For example, in the list-reversal program of Figure 1, little useful infor\u00ad mation \nis obtained. The analysis algorithm must model what happens when the program is applied to lists of length \ngreater than k. However, the tail of such a list will be treated (conservatively) as an arbitrary, and \npos\u00ad sibly cyclic, data structure. The analvsis mav be extremelv costlv because the number of possible \nshape-graphs is doubly exponential in k. In addition to Jones and Muchnick s work, k-limiting has also \nbeen used in a number of subsequent papers (e.g., [HPR89]). Whereas Jones and Muchnick use sets of shape-graphs \n(in [JM81]), our work follows Jones and Muchnick [JM82], Larus and Hilfinger [LH88, Lar89], Chase, Wegman, \nand Zadeck [CWZ90], and Stransky [Str92] who developed shape\u00adanalysis methods that associate each program \npoint with a single shape-graph. The use of a single shape-graph is pos\u00adsibly less accurate than a method \nbased on sets of graphs, but it leads to more compact representations, and thus is more likely to lead \nto a practical shape-analysis algorithm. Jones and Muchnick [JM82], Chase, Wegman, and Zadeck [CWZ90], \nand Stransky [Str92] present similar methods in which the shape-nodes correspond to a program s allocation \nsites. These methods are more efficient than the methods discussed earlier, both from a theoretical perspective \n[CWZ90] and from an imdementation Dermective IAW931. The algorithm presented b; C~ase, Wegman, ~nd Zadeck \nis based on the following ideas: Sharing information in the form of heap reference counts (using O, \n1, and m) is used to characterize shape-graphs that represent list structures.6  Several heuristics \nare introduced to allow several shape\u00adnodes to be maintained for each allocation site.  e When x.selo \nis assigned to and x.selo points to a shape\u00adnode that represents a unique run-time location, the selo \nIn this section, we use tile term sllape-grapll in tile generic sense, meaning my finite graph structure \nused to approximate tile shapes of run-time data structures. cTlle idea of augmenting sllape-graplls \nwith snaring information also appears in tile earlier work of Jones and Muclmick [,JM81]. selector-edges \nemanating from the shape-node that z points to are overwritten (a so-called strong update ). The Chase-Wegman-Zadeck \nalgorithm is able to identify list\u00adpreservation properties in some cases; for instance, it can determine \nthat a program that appends a list to a list pre\u00adserves list-ness . However, as noted by Chase, Wegman, \nand Zadeck, allocation-site information alone is insufficient to determine interesting facts in many \nprograms. For ex\u00adample, it cannot determine that list-ness is preserved for either the insert program \nor the reverse program. In par\u00adticular, in the reverse program, the Chase-Wegman-Zadeck algorithm reports \nthat y points to a possibly cyclic structure and that the structures that z and y point to possibly share \nelements in common. There are two major technical differences between our al\u00adgorithm and the Chase-Wegman-Zadeck \nalgorithm that lead to the improvements in accuracy obtained by our algorithm: Strong Nullification For \nan assignment x.selo := y, the Chase-Wegman-Zadeck method ordinarily performs a weak update (i.e., selector-edges \nemanating from what z points to are accumulated). It performs a strong up\u00addate only under certain specialized \nconditions. In our algorithm, because of the Normalization As\u00adsumptions of Section 2.1, an assignment \nstatement z.selo := y is transformed into two statements: z.selo := nil, followed immediately by z.selo \n:= y. When our algorithm processes the first of these statements, it (al\u00adways) removes the selo edges \nemanating from what z points to. We have called this operation strong nul\u00adlification , bv analogy with \nstrong u~date . When the ahzorithrn moce~~es the second-st~tement. it in\u00adtrodu~es selo edges that emanate \nfrom the shape-node that z points to. Taken together, the effect is to over\u00adwrite the selo edges emanating \nfrom the shape-node that x points to in other words, for a statement in the original, program of the \nform ~,selo := y, our algorithm always performs a strong update. Example. In SGS of Figure 4, n{z}, TZ{gl, \nand n{.,v} are separate nodes. Because n{c,v] represents on!y run-time locations that are pointed to \nby both z and y, it is safe for the abstract semantics to perform a strong nul\u00adlification to n{z,v} (see \nSG4). 0 The reason why it is possible for our algorithm to per\u00adform strong nullifications (and hence \nstrong updates) is because each abstract assignment operation of the abstract semantics creates an SSG \nthat conservatively covers all the possible new configurations of variable sets whose members all point \nto the same run-time lo\u00adcation (i.e., DSG shape-node). If x is in the name of an SSG shape-node n, then \nn represents a DSG node whose selo field will definitely be overwritten. Materialization In an assignment \nstatement of the form z := y.selo, our algorithm materializes new shape-nodes that conservatively cover \nall the possible new configurations of variable sets whose members all point to the same run~time location. \nFor example, when y.selo points to nd, our algorithm materializes a new node rz{z} out of n~. Furthermore, \nif z.s-s/zared(n@ ) = j alse, this in\u00adformation is used to exclude both of the two possible selector-edges \nfrom n@ to n{xl. In programs that use a loop containing an assignment x := %.cdr to traverse an unshared \nlinked list, this technique permits our method to determine that z points to an unshared list element \non every iteration. For instance, this occurs in the transition from block va to block v~ in Figure 7. \nAs explained in Section 4.4, the materialization of TZ{LI} in block V9 is one of the key aspects of our \nalgorithm that allows it to determine that the list-reversal program preserves list-ness . The Chase-Wegman-Zadeck \nalgorithm lacks a node\u00admaterialization operation (although they did recognize that the lack of one was \na stumbling block to the ac\u00ad curacy of their method [CWZ90, pp. 309]). Chase, Wegman, and Zadeck use \nreference-count values O, 1, and co, whereas we use a Boolean-valued is-shared value. However, this \ndoes not represent a significant difference be\u00adcause in our SSGS the selector-edges allow recovering \nthe distinction between O (no incoming edges) and 1 (at least one incoming selector-edge, but ts.shared \n= fake). Our method has been presented within the framework of abstract interpretation, which allows \nus to prove that the algorithm obtained is conservative with respect to the con\u00adcrete semantics. Chase, \nWegman, and Zadeck give only in\u00adformal arguments about the correctness of their algorithm. Because of \nseveral ad hoc features of the Chase-Wegman-Zadeck method, several changes would be necessary to re\u00adformulate \nit as an abstract interpretation. For inst ante, the rules they give for the join operation are complicated \nby the fact that the result of joining two shape-graphs de\u00adpends on the program point at which the operation \nis ap\u00adplied. (For this reason, join is a misnomer in the lattice\u00adtheoretic sense.) In contrast, our \njoin operation, which is essentially graph union, is the join operation in the lattice of SSGS defined \nin Section 4.1. Larus and Hilfinger [LH88, Lar89] devised a shape-analysis algorithm that is based on \nsomewhat different principles from the aforementioned work. As with our algorithm, shape\u00adnodes are labeled \nwith some auxiliary hformation. At first glance, their node-labeling scheme appears to be more gen\u00aderal \nthan ours: Whereas we use a set of varzables to label each node, they use a regular ezpresszon (limited \nto be no longer than some chosen constant k) representing pointer\u00adaccess paths that may lead to an instance \nof the node. How\u00adever, their shape-node labels do not add any information to their representation because \nthe pointer-access expressions can always be reconstructed from the graph stripped of node labels. In \ncontrast, our labels which in some sense rep\u00adresent regular expressions of length-l do contribute es\u00adsential \ninformation to our representation: When z is in t,he variable-set of shape-node nX, we know that a strong \nnul\u00adlification (and hence a strong update) can be performed on the selector-edges emanating from nx. \nIt is possible that it would be worthwhile to extend our technique to use more complicated shape-node \nnames of the kind that Larus and Hilfinger use. However, on many in\u00adteresting examples, even with our \n(length-1 labels , our al\u00adgorithm achieves greater accuracy than the Larus-Hilfinger algorithm does, \nno matter what value of k is chosen: For example, the Larus-Hilfinger algorithm is not able to deter\u00admine \nthat programs such as the list-reversal and list-insert programs preserve list-ness . There are also \nseveral algorithms for finding may aliases that are not based on shape-graphs, The most sophisticated \nones are those of Landi and Ryder [LR91] and Deutsch [Deu94] Deutsch s algorithm is particularly interesting \nbecause, for certain programs that manipulate lists, it offers a way of representing the exact (infinite \nset of) may aliases in a com\u00adpact way. It can be shown that Deutsch algorithm yields may-alias information \nfor the list-reversal program that is equivalent to that produced by the algorithm of Section 4.1. However, \nboth the Landi-Ryder and Deutsch algorithms do not determine that either (list-ness or tcircular list-ness \nis preserved by the insert program of Figure 9. The reason is that due to the lack of a strong-nullification \noperation, these algorithms cannot infer that the assignment y. cdr := nil in the program shown in Figure \n8(b) cuts the list pointed to by z (see Figures 9(b) and (c)). We do not mean to imply that our method \ndominates the Landi-Ryder and Deutsch algo\u00adrithms; there exist programs in which the Deutsch algorithm \nis more accurate than our algorithm. A different approach was taken by Hendren, who de\u00adsigned an algorithm \nthat handles only acyclic data struc\u00adtures [HN90, Hen90] Because of the choice to work with programs \nthat only manipulate acyclic structures, the al\u00adgorithm does not have to have a way of representing cycles \nconservatively. For this alias-analysis problem, she has given an efficient algorithm that manipulates \nmatrices that record access paths that are aliased. To the best of our knowledge, Hendren s algorithm \nis the only algorithm besides ours that can detect that insertion of an element into a list (respectively, \ntree) preserves the list (tree) structure. However, by design, Hendren s algorithm cannot determine such \nstructure-preservation properties for programs that handle cyclic lists. Myers presented an algorithm \nfor interprocedural bit\u00advector problems that accounts for aliasing [Mye81]. Like our shape-analysis algorithm, \nhis algorithm also keeps track of sets of aliased variables. He conjectured that in practice the sizes \nof the alias sets remain small, However, Myers s work does not handle heap-allocated storage and destructive \nupdating. Therefore, his algorithm is significantly simpler and he is even able to show that it is precise. \nIn contrast, it is undecidable to give a precise solution to our problem, even in the absence of procedure \ncalls [Lan92, Ram94]. Acknowledgments We are grateful for the helpful comments of Alain Deutsch, Christian \nFecht, and Neil Jones, Laurie Hendren provided us with extensive and very helpful information about the \ncapabilities of her analysis technique. References [AW93] U. Assmann and M. Weinhardt. Interprocedural \nHeap Analysis For Parallelizing Imperative Programs. In W. K. Giloi, S. Jahnichen, and B. D Shriver, \neditors, Programming Models For Masstuely Parollel Comput\u00aders, pages 74--82. IEEE Press, September 1993, \n[CBC93] J.-D. Choi, M. Burke, and P. Carim. Efficient flow-sensitive interprocedural computation of pointer\u00ad \ninduced aliases and side-effects. In ACM Symposium on Principles of Programming Languages, pages 232 \n245, 1993, [CWZ90] DR. Chase, M. Wegman, and F. Zadecli. Analysis of pointers and structures. In SIGPLAN \nConference on Programming Languages Destgn and Implementation, 1990, [Der194] A. Deutsch. Interprocedural \nmay-alias analysis for pointers: Beyond k-limiting, In SIGPLAN Conference on Programming Languages Design \nand Implementa\u00adtion, 1994. [Hen90] L. Hendren. Parallelizing Programs with Recursive Data Structures. \nPhD thesis, Cornell University, Jan 1990. [HG92] L. Hendren and G.R. Gao. Designing programming lan\u00adguages \nfor analyzability: A fresh look at pointer data structures. In Proceedings of the International Confer\u00adence \non Computer Languages, pages 242 251, 1992. [HN90] L. Hendren and A. Nicolau. Parallelizing programs \nwith recursive data structures. IEEE Transactions on Parallel and Lhstributed Systems, 1(1):35 47, January \n1990. [HNH92] L. Hendren, A. Nicolau, and J. Hummel. Abstrac\u00adtions for recursive pointer data structures: \nImprov\u00ading the analysis and the transformation of imperative programs. In SIGPLAN Conference on Programming \nLanguages Design and Implementation, pages 249-260, June 1992. [HPR89] S. Horwitz, P. Pfeiffer, and T. \nReps. Dependence anal\u00adysis for pointer variables. In SIGPLAN Conference on Programming Languages Design \nand Implementation, pages 28 40, 1989. [JM81] N.D. .Jones and S.S. Muchnick. Flow analysis and opti\u00admization \nof Lisp-like structures. In S.S. Muchnick and N.D. Jones, editors, Program Flow Analysis. Theory and \nApplications, chapter 4, pages 102 131. Prentice-Hall, 1981, [JM82] N.D. Jones and S.S. Muchnick. A \nflexible approach to interprocedural data flow analysis and programs with recursive data structures. \nIn ACM Symposium on Prin\u00adciples of Programmmg Languages, pages 66 74, 1982. [Lan92] W. Landi. Undecidability \nof static analysis. ACM Let\u00adters on Programming Languages and Systems, 1(4), 1992. [Lar89] J.R. Larus. \nRestructuring Symbolic Programs for Con\u00adcur-rent Execution on Multiprocessor-s. PhD thesis, Uni\u00adversity \nof California, 1989. [LH88] J.R. Larus and P.N. Hilfinger. Detecting conflicts be\u00adtween structure accesses. \nIn SIGPLAN Conference on Programming Languages Destgn and Implementation, pages 21 34, 1988. [LR91] W. \nLandi and B.G. Ryder. Pointer induced aliasing: A problem classification. In ACM Sympostum on Prtnct\u00adples \nof Programming Languages, pages 93 103, 1991. [Mye81] E.W. Myers. A precise inter-procedural data flow \nalgo\u00adrithm. In ACM Symposzum on Principles of Program\u00adming Languages, pages 219 230, 1981. [PCK93] J. \nPlevyak, A.A. Chien, and V. Karamcheti. Anal\u00adysis of dynamic structures for efficient parallel exe\u00adcution. \nIn U. BanerJee, D. Gelernter, A. Nicolau, and D. Padua, editors, Languages and Compders for Parallel \nComputing, volume 768 of Lecture Notes in Computer Science, pages 37-57, Portland, OR, August 1993. Springer-Verlag. \n[Ram94] G. Ramalingam. The rmdecidability of aliasing, ACM Transactions on Programming Languages and \nSys\u00adtems, 16(5):1467 1471, 1994. [Deu92] A. Deutsch. A storeless model for aliasing and its ab\u00adstractions \nusing finite representations of right-regular equivalence relations. In IEEE Jnterrsatiorml Confer\u00adence \non Computer Languages, pages 2 13, 1992. [Rey68] J.C. Reynolds. Automatic computation initions. In Information \nProcessing of the IFIP Congress, pages 456 461, 1968. North-Holland. of data set def\u00ad68: Proceedings \nNew York, NY, [SP81] M. Sharir and A, Pnueli. Two approaches to interpro\u00adcedural data flow analysis. \nIn S.S. Muchnick and N.D. Jones, editors, Program Flow Analysis: Theory and Applications, chapter 7, \npages 189 234. Prentice-Hall, 1981. [SRW95] M. Sagiv, T. Reps, and R. Wilhelm. Solving shape\u00adanalysis \nproblems in languages with destructive up\u00addating. Technical Report TR-1276, Computer Sci\u00adences Department, \nUniversity of Wisconsin, Madieon, WI, July 1995. Available on the WWW from URL http://www.cs.wisc. edu/trs.html. \n[Str92] J. Stransky. A lattice for abstract interpretation dynamic (Lisp-like; structures. Information \nand putation, 101(1):70-132, November 1992. of Com\u00ad  \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Mooly Sagiv", "author_profile_id": "81100150928", "affiliation": "Computer Science Department, 1210 West Dayton Street, Madison, WI and IBM Israel Scientific Center", "person_id": "PP39029858", "email_address": "", "orcid_id": ""}, {"name": "Thomas Reps", "author_profile_id": "81100117392", "affiliation": "Computer Science Department, 1210 West Dayton Street, Madison, WI", "person_id": "PP40023877", "email_address": "", "orcid_id": ""}, {"name": "Reinhard Wilhelm", "author_profile_id": "81100325916", "affiliation": "Fachbereich 14 Informatik, 66123 Saarbr&#252;cken, Germany", "person_id": "PP39037801", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237725", "year": "1996", "article_id": "237725", "conference": "POPL", "title": "Solving shape-analysis problems in languages with destructive updating", "url": "http://dl.acm.org/citation.cfm?id=237725"}