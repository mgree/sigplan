{"article_publication_date": "01-01-1996", "fulltext": "\n Typed Closure Conversion* Yasuhiko Minamidet Greg Morrisett Robert Harper Research Institute for Mathematical \nSciences School of Computer Science School of Computer Science Kyoto University Carnegie Mellon University \nCarnegie Mellon University Kyoto 606-01, Japan Pittsburgh, PA 15213 3891 Pittsburgh, PA 15213-3891 nan@kurims \n.kyoto-u. ac.jp jgmorris@cs.cmu. edu rwh@cs.cmu .edu Abstract Closure conversion is a program transformation \nused by compilers to separate code from data. Previous accounts of closure conversion use only untyped \ntarget languages. Re\u00adcent studies show that translating to tgped target languages is a useful methodology \nfor building compders, because a compder can use the types to implement efficient data rep\u00adresentations, \ncalling conventions, and tag-free garbage col\u00adlection. Furthermore, type-based translations facilitate \nse\u00adcurity and debugging through automatic type checking, as well as correctness arguments through themethod \nof logical relations, We present closure conversion as a type-directed, and type-preserving translation \nfor both the simply-typed and the polymorphic ~-calculus. Our translations are based on a simple closures \nas objects principle: higher-order func\u00adtions are viewed as objects consisting of a single method (the \ncode) and a single instance variable (the environment). In the simply-typed case, the Pierce-Turner model \nof ob\u00adject typing where objects are packages of existential type suffices. In the polymorphic case, more \ncareful tracking of type sharing is required. We exploit a variant of the Harper-Lillibridge translucent \ntype formalism to characterize the types of polymorphic closures. Introduction Closure conversion [29, \n34, 5, 17, 16, 1,39,9] is a program transformation that achieves a separation between code and This research \nwas sponsored m part by the Advanced Research Projects .Agency CSTO under the title The Fox Project: \nAdvanced Languages for Systems Software , ARPA Order No. C533, issued by ESC/ENS under Contract No. F1962S-95-C-0050, \nand in part by the National Sc]ence Foundation under Grant No. CCR.-95O2674, and in part by the Isaac \nNewton Institute for Mathematical Sciences, Cambridge, England The views and conclusions contained in \nthis document are those of the authors and should not be interpreted as representing official policies, \neither expressed or implied, of ARPA or the U.S. Government. Any opinions, findings, and conclusions \nor recommendations expressed in this material are those of the au\u00ad thors and do not necessarily reflect \nthe views of the National Science Foundation, tThi~ ~esearch V,W performed while the first author was \nvisiting the Fox Project at Carnegie Mellon Umversity. Permission to make digital/hard copies of all \nor part of thk material for personal or claasroom uae is granted without fee provided that the copies \nare notmade or distributed forprotit orcommereial advantage, tbe copy\u00adright notice, thetitle of the publication \nand ita date appear, and notice is given tbat copyright is bypermission of the ACM, Inc. Tocopyothe-i=, \ntorepubtish, toposton servers ortoredlsttibute to lists, requires specitic permission and/or fee. POPL \n96, St. Petersburg FLA USA @1996 ACM().89791_769.3 /95/() 1..$3<5() data. Functions with free variables \narereplaced bycodeab\u00adstracted on an extra environment parameter, Free variables in the body of the function \nare replaced by references to the environment. The abstract ed code is partially applied to an explicitly \nconstructed environment providing the bindings for these variables. This partial application of the code \nto its environment is in fact suspended until the function is ac\u00adtually applied to its argument; the \nsuspended application, called a closure, is a data structure consisting of a piece of pure code and a \nrepresentation of its environment. A critical decision in closure conversion is the choice of representation \nfor the environment whether to use a flat FAM-like [4], linked CAM-like [5], or hybrid representa\u00adtion \n[30]. The choice of representation is influenced by a de\u00adsire to mmimize closure creation time, the space \nconsumed by the environment, and the time to access a variable in the environment [39, 30]. An important \nproperty of closure conversion is that the representation of the environment is private to the closure, \nThis affords considerable flexibility in the representation of environments and is thus exploited to \ngood advantage by Shao and Appel [30] and Wand and Steckler [391. Previ~u~ accounts consider closure \nconversion as a trans\u00adformation to untyped terms, even if the source language is typed [34, 17, 1, 39, \n9]. This is adequate for compilers that make little or no use of types in the back end or at run time. \nHowever, when compiling typed languages, it is often advantageous to propagate type information through \neach stage of the compiler, and to make use of types at link-or even run time. For example, Leroy s representation \nanaly\u00adsis [18, 31] uses types to determine procedure calling conven\u00adtions, and Ohori s record compilation \n[25] uses a representa\u00adtion of types at run time to access components of a record. Compilation strategies \nfor polymorphic languages, such as those proposed by Morrison et d [24] and Harper and Mor\u00adrisett [14], \nrely on analyzing types at run time to support unboxed representations and non-parametric operators, \nin\u00adcluding printing and structural equality. Tag-free garbage collection [3, 37, 23] for both monomorphic \nand polymor\u00adphic programming languages relies on analyzing types at run time to determine the size and \nlayout of objects in the heap. To support any of these implementation strategies, it is necessary to \npropagate type information through clo\u00adsure conversion and into the generated code. The purpose of this \npaper is to demonstrate how this can be done in both a simply-typed and a polymorphic setting. We present \nclosure conversion as an example of a type\u00addi~ected and type-preserving translation. In general, such \ntranslations transform both a term and Its type, possibly relying on type information to guide the translation. \nThus each stage of the compder can be viewed as a type-preserving translation between typed intermediate \nlanguages. Exam\u00adples of such translations have been given by Leroy [18], Ohori [25], Harper and Ldlibrldge \n[10], and Harper and Mor\u00ad rlsett [1.4]. In contrast to type-free compilation strategies, these translations \nmake essential use of type information during translation to increase the time or space efficiency of \nprograms In additmn to the practical advantages of this ap\u00adrn-each. tv~e-directed translation also facilitates \nthe work of ~he corn~i~er writer. In particular, the typing properties of the intermediate code may be \nexplolted to give clear, concise proofs of compiler correctness through the method of logzcal relatzons \n[35, 6, 27, 32, 33]. Furthermore, the intermediate code of the compiler can be mechanically typed-checked, \nan Important debugging tool for the compiler writer. Fi\u00adnally, checkable typed intermediate languages \nare a promis\u00ading technique for ensuring safety properties of programs in a distributed environment [8, \n38] We describe closure conversion for the simply-typed J\u00adcalculus and the predicative fragment of the \npolymorphic A-calculus. In each case we present closure conversion m two stages. The first stage, called \nabstract closure conuer\u00adszon, is a type-directed translation to an intermediate lan\u00adguage with a primitive \nnotion of closures. We describe the translation as a deductive system where the choice of en\u00advironment \nrepresentations may be Independently made for each closure We argue that various representations consd\u00adered \nm the literature (such as the FAM [4] or CAM [5]), as well as hybrid representations [30], can all be \nexplained m this urnform framework. We establish the correctness of the translation once for all environment \nrepresentations, The second stage, called closure representation, is an\u00adother type-directed translation \nwhere closures are imple\u00admented m terms of generic typed A-calculus primitives. The main idea is to represent \nclosures as objects consisting of a single method (the code) and a single instance variable (the environment), \nWe show that, in the simply-typed case, Pierce and Turner s type discipline for object-or~ented pro\u00adgramming \n[26] may be used to characterize the types of clo\u00adsures. In particular, we use existential type abstraction \nto ensure the privacy of environment representation in much the same way that Pierce and Turner hide \nthe representa\u00adtion types of instance variables, In the polymorphic case, we must use a more sophisticated \ntype discipline in order to track critical type sharing relationships within the clo\u00adsure To this end, \nwe exploit a variant of the translucent type [11] (or rnantfest type [19]) formalism. Our closures as \nobjects model provides an interesting counterpoint to the more familiar objects as closures proposal \nintroduced by Reddy [28]. We prove the correctness of both the abstract closure conversion and the closure \nrepresentation stages using the method of logical relations. The mam idea is to define a type-indexed \nfamily of simulation relations that establish a correspondence between the source and target terms of \nthe translation. Once a suitable system of relations has been defined, it 1s relatively straightforward \nto prove by induction on the definition of the compilation relation that the source and target of the \ntranslation are related. From this, we may conclude that a closed program and Its translation evaluate \nto the same result. Due to lack of space, we omit the proofs of correctness here However, full details \nmay be found in the compamon technical report [21] Closure conversion is discussed in descriptions of \nvarious functional language compders [34, 17, 2, 1, 30], It is sim\u00adilar to A-1ifting [15] m that it eliminates \nfree variables in the bodies of J-abstractions but ddlers by making the rep\u00adresentation of the environment \nexplicit as a data structure, Making the environment explicit is important because it ex\u00adposes environment \nconstruction and variable lookup to an optimizer, Furthermore, Shao and Appel show that not all environment \nrepresentations are safe for space [30], and thus choosing a good environment representation is an im\u00adportant \npart of compdation. Wand and Steckler [39] have consider two optimizations of the basic closure conversion \nstrategy, called selecttve and Zzghtwezght closure conversion, and provide a correctness proof for each \nof these in an un\u00adtyped setting. Hannan [9] recasts Wand s work into a typed setting and provides correctness \nproofs for one of Wand s optimizations. Hannan s translation, like ours, 1s given as a deductive system, \nbut he does not consider the Important Issue of envu-onment representation (preferring an abstract account \ninstead), nor does he consider the typing properties of the closure-converted code. Finally) neither \nWand nor Hannan consider closure conversion under a type-passing interpretation of polymorphism, The \nremainder of this paper is organized as follows. In Section 2, we give an overview of closure conversion \nand the typing issues involved for the simply-typed J-calculus. In Section 3, we provide the details \nof our type-preserving transform for the simply-typed case. In Section 4, we give an overview of closure \nconversion and the typing Issues revolved for the predicative fragment of the polymorphic A-calculus. \nThe formal development of this conversion is given in Section 5. 2 Overview of Simply-Typed Closure Con\u00adversion \nThe main ideas of closure conversion are illustrated by con\u00adsidering the following ML program: let val \nx=1 valy=2 valz=3 valf=Aw. x+y+w in f 100 end. The function f contains free variables x and y We may \neliminate references to these variables from the body of f by abstracting an environment env and replacing \nx and y by references to the environment. In compensation, a suitable environment containing the bindings \nfor x and y must be passed to f before It IS applied. This leads to the following translation: let val \nx=1 valy=2 valz=3 val f = (Jenv. .Aw. (#x env) + (#y env) ~ w) {x=x , y=y} in f 100 end. References \nto x and y in the body of f are replaced by projections (field selections) #x and #y that access the \ncorre\u00adsponding component of the environment. Since the code for f is closed, it may be hoisted out of \nthe enclosing definition and defined at the top-level, We ignore this (hoisting phase and instead concentrate \non the process of closure conversion, In the preceding example the environment contains bind\u00adings only \nfor x and y, and is thus as small as possible. Since z 1s in scope, it is also sensible to include z \nin the environment of f, resulting in the following code: let val x=1 valy=2 valz=3 val f = (Jenv. Aw. \n(#x env) + (#y env) + w) {x=x, y=y, 2=2} in f 100 end. In the examples above, we used a flat FAM-like \n[4] rep\u00adresentation of the environment as a record with one field for each variable, Alternatively we \ncould choose a linked CAhl\u00adlike [5] representation in which each binding is a separate frame attached \nto the front of the remaining bindings This idea leads to the following translation: let val x=1 valy=2 \nvalz=3 val f = (Aenv. ~w. (#x(#link(#link env))) + (#y(#link env)) + w) {z=z, lurk={y=y, link= {x=x}}} \nin f 100 end. The linked representation facilitates environment sharing, but accessing a variable requires \nlink traversals proportional to the nesting depth of the variable in the environment. The linked representation \nalso supports constant-time closure creation, but this requires reusing the current environment. Reusing \nthe current environment can result in unnecessary bindings m the environment (such as z above), leading \nto space leaks These simple translations fail to delay the application of the code to its envmonment \nunder call-by-value evaluation. A natural representation of a delayed application or closure is an ordered \npair (code, env) consisting of the code to\u00adgether with its environment. Application of a closure to an \nargument proceeds by projecting the code part from the closure and then applying it simultaneously to \nboth the en\u00advironment and the argument according to some calling con\u00advention. For example. X=1 let val \ny=s val val 2.3 val code = ~env. ~w. #x(env) + #y(env) + w val env = {x=x, y=y} val f = (code, env) \nm (#1 f) (#2 f) 100 end.  But since code has a type of the form Tve -+ T1 + T1, where TV, is the type \nof the environment env, the closure as a whole would have type (T.e -+ -rl -+ TZ) x T.,, exposing the \ntype of the environment. As a result, this translation does not, in general, preserve types. For example, \nconsider the following ML source program with type int --+ int: let val y=1 in if true then Ax. X+y \nelse Az. z end. Closure converting this expression and representing the clo\u00adsures as pairs yields let \nval y=1 in if true then (Aenv. Ax. x + #y(env) , {y=y}) else (Aenv. Az. z, {}) end. This program fails \nto type-check because the then-clause of the conditional has type ({y:int} + int + int) x {y:int}, whereas \nthe else-clause has type ({} + int + int) x {}. If types are to be preserved by closure conversion, the \nrepresent at ion of the environment must be hidden. This may be achieved through the use of existential \ntypes [22], whose typing rules are given in Figure 1. Briefly, the pack construct packages a type ~ with \na term e, abstracting cer\u00adtain occurrences of r in the type of e as the type variable t. The open operation \nextracts the contents of a package for use within a fixed scope, holding the type component of the package \nabstract. (See Mitchell and Plotkin s article [22] for further discussion of existential types.) Using \nexistential, we may hide the type of the environ\u00adment by abstracting it from the type of the closure \nitself. Specifically, a closure of type TI + T2 is represented by a package of the form pack TV, with \n(code, env) as %e.(t.. + TI + T2) X i., with type %v,.(tv,+ T1+ n) x t.,.Applying this to the example \nof the conditional expression given above, we obtain the translation let val y=1 in if true then pack \n{y: lnt} with (,lenv. Ax. x+#y(env) , {y=y}) as 3tve. (tve + mt -+ int) X tve else pack {} With (Aenv. \nAz. Z, {}) as %.e.(tve+ int --+ int) X tve end. It is easy to see that the types of the clauses of the \ncondi\u00adtional agree, and that the translation has type ~tve. (tve + int +int) x t.,. With closures represented \nas packages of existential type, applications of the form e e are trandatd as follows. A; I 1-el:3tu \nA;r t-e : a[~/t] AkJ{t}; I kJ{z:u } t-ez : a (t@ iTV(a), t @ A) A; r Epack Twith eas 3t.u:%.c A;r Eopen \nelas twithxin ez:u Figure 1: Typing Rules for Existential open east.. with z:(tv.+n 4 T2) Xtve in (#l \nz) (#2 z) e end. That is, the package e is opened, holding the environment representation abstract, and \nthe code part is simultaneously applied to both the environment and the argument of the application. \n3 A Formal Account of Simply-Typed Clo\u00adsure Conversion In this section we present the details of closure \nconversion for the call-by-value, simply-typed ~-calculus. We break the full transformation into two \nstages, as outlined in the introduc\u00adtion. To simplify the presentation, we begin with a version of abstract \nclosure conversion that does not admit sharing of envuonments and then consider the general, shared envi\u00adronment \ncase separately Next, we give the representation of closures m terms of existential types as sketched \nm the preceding section. Finally, we prove the correctness of the translations using a logical relations \nargument. We define the syntax of the source language, A_ , as fol\u00ad lows: Types T::= b] Tl+m Ezpresstons \n e =cld~~~elelez Values ~ ::= c I ~~:~e Types consist of base types (b) and function types~. Expres\u00adsions \nconsist of constants (c) of base type, variables, abstrac\u00adtions, and applications. We use r to denote \na sequence of type bindings of the form {z1 m, . . . . z~:~~} (n. ~ O) where the z, s are distinct variables. \nThe judgement 17 E e T asserts that the expression e has type T under the type as\u00adsignment 17, and is \nderived from the standard typing rules of the simply-typed A-calculus. The dynamic semantics of the language \nis defined by judgments of the form e -v asserting that the closed expression e evaluates to the value \nv. The judgement is defined by the following standard in\u00adference rules for call-by-value evaluation: \nel % )m:~l.e ez + vz e[vz/z] % v v-v el ezb t, 3.1 Abstract Closure Conversion We define the target \nlanguage for abstract closure conver\u00ad sion, A Z , as follows. Types 7::= bI TI + TZ [(TI X XTn) Icode(Tv,, \nTl, Tz) ~ ,:= Ezp S clz/ele2/ (cl,..., en7r,(e)e)/ kv. TV,. AZTI. e I ((cl, ez)) Values v ::= C I ~Xve:Tve. \nh:T1. e / ( 01, . . . ,VrL) I (( V1, W2)) lThe results of this paper easily extend to other source types \nin\u00adcluding products and sums. In the introduction we informally presented a closure as a partial application \nof code to an enwronment, with the in\u00adtention that this application is delayed until the closure is applied \nto an argument. To make this precise we intro\u00adduce an explicit closure form, written ((e, eve)), where \ne is the code of the closure and e., is its environment Notice that closures are distinguished from applications \nof func\u00adtions to arguments, which are written in the usual way by juxtaposition. To capture the restriction \nthat the code part of a closure should be closed, we introduce a special code type, code ( r ,, TI, TZ), \nconsisting of closed terms of the form ~z.e :TV. .Ax:rl .e, which abstract both an environment and an \nargument 2. The typing rules for A Z are standard except for code and closures, whose rules are given \nas follows: {2&#38;e: Tve, HI} + e : TZ r ~ kve:Tve. k Tl. e code(TV., Tl, T2) The evaluation rules governing \nclosures are given as fol\u00adlows: elv VI e7-V9 ((cl, e2)) + ((VI, v,)) el + ((kve. Tve.k: Tl. e, VW )) \ne2 + vz e[vv, /xv., vz/x] v v elez~v When a closure is applied to an argument, the environment and the \nargument are substituted for the corresponding vari\u00adables and the body of the code is evaluated. We define \nabstract closure conversion as the type-du-ected translation from ~+ to J J given in Figure 2. We formulate \nthe translation as a deductive system with judgments of the form r;z:~ D e Q e and r;z T D I -.-+ e~e, \nwhere r and r are source type assignments, ~ M a source type, e is a source expression, and e and e~e \nare target expressions. The distinguished variable z is used to represent the argu\u00adment of the nearest \nenclosing J-abstractIon; the variables m r include this A-abstraction s free variables. The judgement \n17;x:T D e + e asserts that e is the translation of e under the assumption that I @ {z:T} E e T~ for \nsome T . The judgement r: z:~ D ~ -e~e asserts that e~, IS an expression that evaluates to the environment \ncorresponding to 17 , under the assumption that each binding in r occurs in 17 w {z:~}, The order of \nbmdmgs in 17 is important, because this determines the translation of both environments and free variables. \nIn practice, a multi-argument A-abstraction is used for code in the target language However, the polymorphic \ncase requires a more complicated construct that abstracts both values (A) and types (A) For uniformity \nwe use a curried presentation to abstract multiple arguments r; X:TDXIOel r; X:TDXn Ue.n Contezt) r;~:T \nD {ZI:71,... ,Zn:Tn} + (e,,. ... en) (rw {Z:T} E  : z) Figure 2: Simply-Typed Abstract Closure Conversion \n We use the variable z , to hold the environment argu\u00adment of the current code body. Thus, we translate \nfree vari\u00adables to projections of x., More precisely, according to rule ( env), we translate a reference \nto the free variable x, found in the ith position of the type assignment r to the ith projection of the \nvariable Zv.. On the other hand, according to rule ( arg), we translate a reference to the argument of \nthe current code body to the distinguished argument variable x. Under the assumptions 17;x :~ , we translate \nan abstrac\u00adtion ~x:~.e to a closure according to the (abs) rule. To con\u00adstruct the environment of the \nclosure, we choose a type as\u00adsignment I such that I ; z :1- D 1? + e., is derivable via the (conte$t) \nrule and r ; z:~ D e + e . In effect, these rules require that every binding in the closure s environment \nmust be in scope (z. e., in 17k, {z :~ }) and the environment is re\u00adquired to contain bindings for all \nof the free variables in the original function Jx :~. e. However, 17 may also contain bindings for variables \nthat are in scope but do not occur free in the function, Consequently, there are many choices for 17 \n, with the exact choice being influenced by time and space considerate ions. We construct the environment \nof a closure via the ( contezt) rule by translating each of the variables occurring in I (namely ZI, \n~~~, x~) to the target expressions el, . . . en. We place the resulting expressions in a tuple (el, . \n. . . en), to form the environment data structure of the closure. This representation of the environment \nhas type (71 x x r~ ), which we summarize by writing 117 1. To produce the code of the closure, we translate \nthe body of the source function under the strengthened assumptions 17 ; z :r, producing the body of the \ncode, e . We then ab\u00adstract the environment and argument, yielding the transla\u00adtion Jxve:lr l. Ax:r. \ne . Using a dummy current argument to translate an en\u00adtire closed program, it is easy to prove by induction \non the derivation of the translation that the translation preserves the type of a program. Theorem 1 \nIf@I 1-e:~ and @;z:b D em e , then @h e : r. To prove the correctness of the translation, we use a type\u00adindexed \nfamily of logical relations relating closed source ex\u00adpressions to closed target expressions (W) and \nclosed source values to closed target values (x ). The relations are defined by induction on source types \nas follows: e W~ e iff e~vande -v and V= Tut c~bc u =.l+., v iff for all w m~, v;, v WI -.2 J w; We \nextend the relation to finite source (~) and target sub\u00adstitutions (~ ), mapping variables to their respective \nclass of values. These relations are defined as follows: 7 ~{z171, ,z_ r,, },z ~ [( 01,. , on)/$ve, o/~] \nW ~(z,) x., V, for 1< i < n and -y(x) %. v. Theorem 2 Let -y WriZI.T, -y . If r w {z : T } 1-e : T and \nr;x :~ be-+e , then ~(e) -T #(e ). Thus, for a closed program of base type, evaluating the program and \nits translation yields syntactically equivalent values. 3.2 Sharing Environments Some implementations \nof functional programming languages share portions of an environment among closures in an effort to decrease \nspace and closure creation time. In this section we extend the treatment of abstract closure conversion \nto allow for shared environments. We achieve this by impos\u00ading additional structure on environments to \nallow for nested represent at ions. The type assignments in the previous section (17) consist of a fiat \nsequence of variable declarations, To provide for shared environment represent at ions, we enrich the \nstructure of type assignments to support nested type assignments as follows: @ ::= {X:7} [ (e,,...,%) \n A nested type assignment is either a single type binding or a sequence of nested type assignments. The \nenvironment corresponding to the type assignment @ has target language type 1~1, where I{z:T}I = I-and \nl(@l,...,@~)l = (l@ll X x I(3 ~ I). We can obtain a non-nested type assignment (17) from a nested type \nassignment (~) simply by dropping the extra structure. We give the most important translation rules for \nclosure conversion wit h nested environments in Figure 3; the re\u00admaining rules may be obtained from those \nin Figure 2 by replacing 17with El throughout. We use the ( env-tuple) rule to construct a nested envi\u00adronment \n(cl, . . . . em) corresponding to the type assignments @l, . . ..@~. if@; z:7D@, Qe,, forl < i < n. Weob\u00adtain \neach of the 8, and e, from the ( arg), ( env). (subenv). and (env-tuple) rules. We use the ( arg) rule \nto translate the mgument of the nearest enclosing A-abstraction as an en\u00ad vironment, and we use the ( \nenv) rule to translate the free variables of this abstraction as an environment. As before, we use the \ndistinguished variables z and Zve to hold these two values in the translation. We use the (subenv) rule \nto translate access to a type assignment nested within @ to a projection of the environment corresponding \nto G. Finally, we translate access to a variable within a type assignment via the (var) rule. (q) {3+: \nT }; H D {x:T} + x (em) @;z:T D ~+ zv, (var) @;$:T D {z : T } @; X: TDZ +e o e Subenv) (@l,..., Gn~~i~TJD~O+oe~t \n(zve)/zvel (e~v-~w~e) @;Z:7D~l+el @;a:TD(@l,. ... . @; Z. TD@n+en @m)+ (el, en), en) Figure 3: Simply-Typed \nClosure Conversion using Nested Environments As an example, consider the translation ({z,: znt}, {z2:int}); \nz :int D (k:int.d+ z,+ $,)w ((kve-i-.k(Zve)  int27-,+ m(m(zve))+ m(m(zve))> (X ,zve))) where ~ IS (int \nx (int x int)).We construct the new envi\u00adronment for the closure by pairing the current argument x and \nthe current environment z., according to the (env-tuple) rule. If we used the flat translation given \nin Figure 2, then we would have to project the values for ZI and xz out of the current environment and \nplace these values and the current argument into a newly allocated tuple. Nested type assignments are \nsufficiently flexible to han\u00addle many commonly-used environment representations. For example, the Categorical \nAbstract Machine, or CAM [5], uses a hnked list to represent the environment. This is re\u00adflected in our \nframework by restricting the shape of nested type assignments and by restricting the ( env-tuple) rule \nto [cons the current argument onto the current environment, as follows: ( CAM context) e. ::= {H} I ({3H},&#38;) \n(env-tuple) 8C,Z:T D (z: T,@c) + (z, G.,). The advantage of the CAM strategy is that the cost of the \nconscructlon of a new environment is constant. However, m the worst case, accessing values in the environment \ntakes time proportional to the length of the environment. In contrast, the FAM [4] uses flat environments \nwith no sharing. The closure conversion of Figure 2 accurately mod\u00adels the environment strategy of the \nFAM if we choose a spe\u00adcific strengthening strategy in the ( abs) rule where only the free variables \nof the function are preserved in the resulting closure s envn-onment. The advantage of the FAM environ\u00adment \nrepresentation is that the cost of variable lookup is always constant and the representation is safe \nfor space [I] according to Appel s definition. However, constructing the envu-onment for a closure takes \ntime proportional to the number of free variables m the function, and closures cannot share portions \nof their environment, Clearly, there are a variety of other strategies for form\u00ading environments. For \nexample, the shared closure strat\u00ad egy described by Appel and Shao [30] that is also safe for space can \nalso be formulated in our framework. However, to determme a good representation for each closure s envi\u00adronment \nrequires a good deal more information mcludmg an estimate as to how many times each variable is accessed, \nwhen garbage collection can occur, what garbage collection algorithm is used, etc.  3.3 Closure Represent \nat ion The purpose of abstract closure conversion is to choose an environment representation for each \nclosure and to make the construction of closures explicit. By making environments explicit, we expose \noperations that are implicit at the source level to an optimizer at the target level. In particular, \nan optimizer can elimmate redundant constructions of environ\u00adments or redundant projections from environments, \nHowever, the process of extracting the code and environ\u00adment of a closure remains an lrnphcit, atomic \noperation of the operational semantics. Hence, we cannot optimize these closure operations. For instance, \nif the same closure is re\u00adpeatedly applied in a loop, It is not possible to extract the code and environment \nonce, repeating only the application to the environment and argument within the loop. TO make such optimizat~ons \npossible, we choose a rep\u00adresentation of closures in terms of generic primitives that would, in practice, \nalready be present in the intermediate language. Specifically, with existential types, we consider defined \nby the a target following language grammar: Jq T~peS 7::= blt\\(TIX, code(~ ,,~l, .. X~z) 7_n)l I %.-r \n Exp s e ::= c ] el(ez,ea) I kV,:TVe k:~l,e I $l k .;d~ ::,1 ~ , open el as twith z:T In e~ This language \nincludes existential types and code types, but not function types; we show how to define function types \nin terms of these primitive constructs. We restrict applica\u00adtions to the form el (ez, e3) in order to \npreclude a partial application of code to Its environment; this can be seen as a speclahzed use of multi-ar \nument functions. 5 Typing Judgments for A are of the form A; 17 ~ e I\u00adwhere A 1s a list of type variables \nin scope and r IS a type assignment for variables in scope. We assume that the free type variables of \nthe types in the range of 17and the free type variables of e and ~ are contained in A The typing rules \nand evaluation rules of the language are standard (see [22] and Figure 1). We describe the closure representation \nphase in two parts. We begin by defining a translation from JC1 to As types, de\u00adnoted [71, as follows \nlb~= b I(T, x x7n)l = (IT, I x x l~nl) lcode(~y~l~~~~~~ = code(l~v.1, ITII, ITzI) = % e. (code(t ., 1~11,ITzI) \nx tv,). We translate an arrow type to a pair consisting of code and an environment, with the environment \ntype held abstract using an existential quantifier. r b e : code(7v., Tl,7-2) N-+ e r b eve : T.. --+ \ne(,, (closure) r b ((e, eve)) : rI -+ TZ w pack ITV.I with (e , e~e) as l r~ -+ ~zl (app) open e~ as \nrDel:Tl+T2we~ 17 De2:71wej 17 be1e2 :72-.-+ tvewith z:(code(tve, ITL1,[-rzl) x t e) in (TI z)(7rz z, \ne:) (Z@ hm(r)) Figure 4: Important Rules of Simply-Typed Closure Representation Next, we define the \ntranslation of Jcl terms to Jq terms in Figure 4. The judgments of the translation are of the form r \nD e : ~ -v+ e , where 17,e, and r are a JCLtype as\u00adsignment, expression, and type respectively, and e \nis a Aq expression, The interesting rules are (closure) and (app). The other rules (not shown) simply \nmap the other J=l con\u00adstructs to their Aq counterparts. We translate a closure to a pair of the code \nand the environment packed with the type of the environment. We translate an application to an open, \nextract from a package the pair of a code and an environ\u00adment, and then apply the code to the environment \nand the argument. It is easy prove that the translation preserves the type of a program up to the translation \nof the type. We do so by first extending the type translation to type assignments, setting l{x,:Tl,..., \nzn:Tn}l = {zl:lT,l,..., zn:\\Tnl}. Theorem 3/fr}e:ramir De:~-+e ,then@;lrlE e : 171. Correctness of the \ntranslation is proven using 10 ical re\u00ad $ lations between J t and A= expressions, Act and J values, \nand Act and AS substitutions, The definition of the rela\u00adtions and the proof of the correctness can be \nfound in our technical report [21]. 4 Overview of Polymorphic Closure Con\u00adversion Closure conversion \nfor a language with ML-styIe (z. e., pred\u00adicative [13] ) explicit polymorphism follows a similar pattern \nto the simply-typed case, but with two additional compli\u00adcat ions. First, we must account for free type \nvariables as well as free value variables in the code of an abstraction. Second, we must create closures \nfor both value abstractions (A-terms) and type abstractions (A-terms). In this section, we give an overview \nof the typing difficulties encountered when closure converting value abstractions; the treatment of type \nabstractions is similar (see Section 5 for details). To eliminate free occurrences of type variables \nand or\u00addinary variables from the code, we abstract with respect to a type environment and a value environment, \nreplacing free variables by references to the appropriate environment. This process results in closed \ncode that can be hoisted to the top level and shared among mu~tiple closures. The code IS partially applied \nto suitable representations of the type and value environments to form a polymorphic closure. As in the \nsimply-typed case, we need a data structure to repre\u00adsent the delayed partial application of the code \nto its type and value environments. In addition, we must abstract both the kind of the type environment \nand the type of the value environment so that their representations remain private to the closure. Without \nthe abstraction, we run into the same typing problems that we encountered in the simply-typed case. As \na running example, consider the expression Ax:tl. (x:tl, y:t2, z:int), where tl and tzare free type \nvariables and y and z are free value variables of type tzand int respectively. It is easy to check that \nthis expression has type t 1 + (t 1 x t 2 x int). To closure convert the expression, we translate it \nto the partial application let val code = Atenv :: {t,::fl,t,::fl}. Avenv : {y:#tz tenv, z:int}. Ax : \ntenv) . (x, #y venv, #z (tltlvenv) in code {tl=tl, t2=t2} {y=y, Z=Z} end. The code of the closure abstracts \na type environment t env and a value environment venv. The actual type environment {tl=tlis a record \n{t~::fl,tz::o},Q is the ,t~=tz}of kind where kind of monotypes. The actual value environment {y=y, Z=Z} \nis record with type {y: tz, z: int}. Note, however, a that this type contains a free reference to tz,which \nmust be replaced by a reference to the type environment in order to ensure that the translated code is \nclosed. We therefore ascribe the type {y: tltztenv, z: int} to the value environ\u00adment, noting that the \nprojection #tztenv is equivalent to tj when the actual type environment is as given earlier. By similar \nreasoning we assign the type #tltenv to the argu\u00adment x of the A-abstraction. It is easy to check that \nthe code of the closure has the type Oco&#38; given by the equation flcode = Vtenv::{tl::fl, t2::fl}. \n{y:W2 tenv, z:int}-+ (Ml tenv)--+((#tlx (#tztenv) Xint) . tenv) It follows that the entire let expression \nhas the type of the original term, namely t 1 + (tl x t2 x int ). Now let us consider the representation \nof the partial ap\u00adplication of code to Its type and value environments as a data structure. This data \nstructure must be mixed phase in the sense that it consists of both type and value compo\u00adnents. This \nsuggests using a package of existential type of the form ~ve, where code is as given earlier and w,.= \n{tl::fl, tz::fl} Tve = {y:#t2 t,., z:mt}. Th~s package is well-typed according to the usual rules for \nexistent lals. In contrast, consider what happens when we attempt to give the translation of the application \nof e to an argument e of type tl. Proceeding as m the simply-typed case, we in\u00adtroduce an open expression \nthat extracts the code, the type environment, and the value environment from the closure, and applies \nthe code to the environments and argument. Doing so results inthe following translation: open e as tte::P&#38; \nwith T?:u~~d~ X Tve in (#1 W) tte (#2 w) e end. Unfortunately, th~s expression is not well-typed. The \ndiffi\u00adculty is that e has type t~,whereas the expression (#l W) tt. (K2 w) has type  (#tl tte)+((#tl \ntte) x (WZ tte) xmt) . Since tt, IS abstract, the type variable tlis not equivalent to #tltt,Consequently, \nthe proposed translation of appli\u00adcation fails to type-check. One way to get around this problem is to \napply the code to the type environment before forming the closure. This yields let val c = code {tl=tl,tz=tz} \nin pack {tl=tl ,tz=tz} with (c, {y=y, z=z}) as % :: Kte .CTc x Tve end, where the type CTCis given by \nthe equation a. = {y:#t, t~., z:int}+(#tl t,.)+ ((#t]tte)X(#t2t~e)Xint)  The translation of application \ngiven above wdl work in this case because the code and the value environment both use tt. as the type \nenvironment. But this approach depends upon the very mechanism we are attemptmg to eliminate, namely \npartzal application. The partial application of the code to the type environment produces code that is \nno longer closed. Thus, the code cannot be shared among the different mstantiations of the type environment. \nOur solutlon to this issue is to constrain the code so that It can be applied to a closure s va~ue environment \nonly when it 1s also applied to the same closure s type environ\u00ad ment. This ensures that the type environment \npassed to the code and the type environment used in the construction of the closure s value environment \nare the same. Fortunately, typing constraints of this form have already been addressed by research on \nmodule systems [20, 19, 11]. Following Harper and Lillibridge [11], we use the notion of translucent \ntypes to express the desired constraint on the code. In particular, when forming the closure, we coerce \nthe code to have the trans~ucent type Vtenv = {tl=tl ,t2=t2}: :Kte {y:#t~ tenv, z:int}+(#t~ tenv)+ ((WI \ntenv) X (#t2 tenv) Xint) . This type is a super-type of the original code type ~..d. because we have \nconstrained the bound type variable tenv to be bound to a particular type, namely the type environment \nof the closure. (See Harper and Lillibridge [11] and Leroy [19] for further discussion of subtyping in \nthis setting.) This constraint ensures that this reference to the code will only be applied to the type \nenvironment of the closure. The constraint on tenv allows us to conclude that Ml tenv is equivalent to \ntland similarly, that #t2tenv is equiv\u00adalent to tz.We propagate these equivalences into the type yielding \nVtenv = ,tz=tz}: {tl=tl:Kte. {Y:tl$.z:int} -+ t,-+ (tlxtzxint). We can now form the package containing \nthe type envi\u00adronment, code, and value pack {tl=tl,tz=tz}with (code, env) as 3tte::fite. aX7_ve, where \nu is given via the equation a = Vtenv=tte : :nt. {y:#tl tte, z: int}+ (tJtltte)+((tltlX(#t2 ) Xint) , \ntte)tt. and show that this package has type %t,. :m, u x r.,. Note that a is the same as ac, (the type \nof the partial application of code to the type environment), except for the additional constrained type \nabstraction of tenv. Through the use of translucency, we have accomplished the effect of partial ap\u00adplication \nat the type-level without actually performing the application at the term-level, Opening a package e \nof type %,.:~t..a x T . to apply to an argument e of type t1yields: open e as tte::Kte, w:axrve in (*1 \nw) tte (#2 w) e end. The expression (#1 w) tte(#2 w) e has type tl + (tl tz x int), thus the entire \nexpression is well-formed. In summary, we use translucency to constrain the type of code before placing \nit in a closure We use pack to rep\u00adresent the mixed-phase data structure containing the code, type environment, \nand the value enwronment. The resulting package has a type of the form (%, :Ktevt=tte::f%,Tve-+ T, + \nT,) x TVe. To avoid the typing problems encountered in the simply \u00adtyped case, we need to hide the representations \nof the value environment and the type environment. Thus, we use pack again to abstract the kind of the \ntype environment and the type of the value environment, resulting in the following type for closures: \nCareful consideration of the foregoing discussion reveals that we only made hmited use of translucency \nThe univer\u00adsally quantified variable tenv does not occur in the scope of the abstraction once the equational \nconstraint on tenv IS propagated, We use this property to provide a substantially simpler mechanism than \nthe full translucent type calculus. In particular, we only need to capture the restriction that a polymorphic \nfunction must be applied to a specific type argument. This may be expressed by introducing a type r ~ \na consisting of functions that must be applied to the constructor T to yield a value of type u. The following \ntwo rules govern this new type constructor: Akr::K A.; I !--e: Vt::K.ff A;17Fe:7*u A;~+e:T*u[r/t] A;rker:rs \n The first rule restricts the domain of type application to the specific constructor ~, This corresponds \nto restricting the type to Vt = r.u and propagating the equivalence t = T into a. The actual type application \nfor ~ ~ a is permitted only for constructors equivalent to r. These two rules naturally come from the \nnecessity of delaying type applications for closure conversion. Using this notation, the type translation \nof ~1 -+ 73 becomes 3kte,3tve::Q.3tte:: kte. (tte =$-% + 7-1 -+ T ) x t .. The type of closures abstracts \nthe kind of the type en\u00advironment and the type of the value environment, ensuring that these may be chosen \nseparately for each closure in the system. AS in the simply-typed case, we have obtained an object oriented \nrepresentation of polymorphic closures by exploiting a combination of the type systems proposed by Pierce \nand Turner [26] for objects and by Harper and Lil\u00adhbridge [11] for modules. 5 A Formal Account of Polymorphic \nClo\u00adsure Conversion In this section, we present closure conversion for the predica\u00adtive fragment of the \nsecond order A-calculus. Thm fragment 1s sufficient to model Standard ML [13], and admits rela\u00adtively \nsimple correctness proofs based on logical relations. Our results extend to the full impredicative polymorphic \nA\u00adcalculus, but at the expense of a substantially more complex correctness argument (based on Girard \ns method of candi\u00addates [7]). We define the syntax of the source language Av as follows: Kinds ~ :;= \nQ Constructors 7::= b[t[7-l+T2 Types a ::= T 1 al -+ U2 I Vt::l$.a Expressions e ::=c I z I kc. m.e I \n~t::~.e I el e2 I e ~  Values u:= c I ~=le 1~t ~ ~ We use kinds (K) to describe constructors (~) and \ntypes (a) to describe expressions (e). There is only one kind (0) for JV et, but since subsequent languages \nhave a richer kind structure, we introduce kinds here for uniformity. Closed constructors of kind Q correspond \nto a subset of types, in particular the types that do not include quantifiers (the monotypes). Thus, \nconstructors of kind Q can be injected mto types. We leave this injection implicit and treat ~ as both \na constructor and a type A kind assignment A is a sequence that maps type vari\u00adables to kinds and is \nof the form {tl:Kl, ,t~::K~}, (n ? 0). Typing judgments are of the form A; r !-e : u where the free type \nvariables of I , e, and a are contained in the do\u00admain of A, and the free value variables of e are contained \nin the domain of r. Typing judgements are derived according to the standard typing rules of the second-order \nA-calculus (see for example [13, 14]). The most interesting rules are the introduction and elimination \nrules for quantified types: AIiJ{t::~};17Ee:a (t@lhn(A)) A;r kAt::~. e : u Vt::&#38;. A;17te:Vt::6. \nu (F TV(r) g Dorn(A)) A; 171-e ~ : m[~/t] 5.1 Abstract Closure Conversion Abstract closure conversion \nfor Av converts both A-abstractions and A-abstractions into abstract closures consisting of code, a type \nenvironment and a value environment. We consider here only flat environment representations, but note \nthat the treatment of nested environments given in Section 3 carries over to the polymorphic case. We \ndefine the syntax of the target language Jv ct as fol\u00ad lows Kinds K ::= Q\\(Klx. ,,x K2) Con s 7 ::= \nb[tl T,+ T21(Tlx.. .x Tn)l (TI,...7Tn)~X, T] Types u ::= Tlu1+a21vt::K ffl(ol x... xon)l Vcode(tte::Kt,, \n~vei 01, CTZ) [ tcode(tt,::ti~e, a ,, t::fi, a) Ezp s e ::= clxlelezlerl(el,...,en) 17r,el Att.::~te.Jz \n,:oV,.Jz:ol .e I Att,e::~t,.Jz .:oV~ At::~.e I ((cl, T,e2)) We use product kinds of the form (K1 x x \nK.) to spec\u00adify the shapes of type environments in much the same way that we use product types to specify \nthe shapes of value environments. There are two sorts of code: code corresponding to an or\u00addinary A-abstraction \nhas the form At,.: :Kt, .Azve :0,, .AZ:OI .e while code corresponding to a type abstraction has the form \nAtte: :Kt, ,Ax . :uV, .At ::K.e. The code in each case abstracts a type environment and a value environment. \nFor the Y case the code also abstracts a value argument, and for the A-case the code abstracts a type \nargument. We introduce the types vcode and tcode to distinguish the two types of code from the types \nof closures, to ensure closure conditions on code, and to preclude partial applications of code to en\u00advironments. \nThese types may be described by the following informal correspondences: vcode(tt~:fit~, u ~, al, oz ) \n% vtte:./G,.uve-i al + IS2 tcode(t~,:m., u ,,t :~, IS) = b&#38;: %~ u , + @t :f$.u. We consider code \ntypes to be polymorphic, so these types do not lie in the range of a polymorphic quantifier.3 Abstract \nclosures have the form ((cl, ~, e~)), consisting of piece of code el, a type environment T, and a value \nenviron\u00adment ez. For the typing of ~vc~ , kmd assignments (A) map type variables to kinds while type \nassignments (I ) map value variables to types. The judgments of the static semantics are as follows: \nAFT::K ~ is a well-formed constructor of kind K. At--u a is a well-formed type. AFrlzrz:K ~1 and TZ are \nequivalent constructors. AI-UIEOZ CTI and uz are equivalent types. A;~Ee:u e is a well-formed expression \nof type u. 3This restriction is relaxed in the impredicative case. The formation rules of types are \nstandard. We have to m\u00adintroduce definitional equality of constructors and types to account for projections \nof constructors from product kinds. These rules consist of the equivalence rules for projections below, \naswellas thestandard rules forequivalence and con\u00adgruence: A1--7rt(7-,,. ., Tn)s Tz::&#38; LA1-(7r,T,...,7rn \nT7::(f$lxlx Kn)x Kn) The typing rules for expressions are standard except for the rules for codes and \nclosures. These rules are definedin Figure5. Werequire that code values beclosed with respect to both \ntype variables aswellas value variables. This allows us to share the code among multiple instantiations \nof the free type variables and free value variables. We define abstract closure conversion from Jv to \nJvct by the deductive system given m Figures 6 and 7. The judge\u00ad ment Ae,,v, Aarg D a + d means that \na is the translation of u where A,.. is a kind assignment corresponding to a type environment and A.,g \n1s a kind assignment corresponding to a type argument (if any). This judgement also implic\u00aditly defines \na translation from constructors to constructors, since source-level constructors (~) are a subset of \ntypes (a) and the translation maps constructors to constructors. In translated programs the type variable \ntt, N used for type environments. The judgement A,. , Aa,g, re,,v; r~,g D e o e means e is a translation \nof e where A,nv and Aa,g are as in the type translation, and r,n. and 17a,g are type assignments corresponding \nto the value environment and value argument respectively. A type environment corresponding to A~~V and \na value environment corresponding to 17,,,. are implemented in the target language by types of the form \n\\A~,,. I and 11 ~n.I respectively, as defined below The most interesting rules are the term translations \nof value and type abstractions In each case, an appropri\u00adate type environment and value environment must \nbe con\u00adstructed as part of the closure. Thus, assignments A&#38;,,V and ri,,v must be chosen as subsets \nof the current assignments A.,,. k. A,,g and ren.., w J7.,g respectively These assignments must be chosen \nso that all of the free value variables of the terrh are contained in 17&#38;,,v and furthermore, all \nof the free type variables of the term and the value environment must be contained in &#38;v. The cluef \ntechnical difficulty in formulating these rules is that we need two type assignments, 17&#38;.v and r&#38;v, \nto de\u00adscribe the value environment of the closure, depending upon the context. The type assignment I&#38;, \n1s constructed from the context A~,,v: il~, g;17~n.; I ~,g and 1s used to build the environment e., in \nthe context in which the closure is con\u00adstructed The type assignment ~~nv is obtained from ~&#38;v via \nthe translation A~,,V; g b I&#38;. u r~,,v and corresponds to the type of the value enwronment in the \ncontext of the closure itself. This ensures that the code of the closure is closed since the type ascribed \nto the value environment ar\u00adgument does not refer to free type variables in the context where the closure \nwas created. The type correctness of the translation is proved by in\u00addllction on the derivation of the \ntranslation. The correctness of the translation maybe estabhshed us\u00ading an argument similar to that \ngiven for the simply-typed case. The restriction to predicative polymorphism signifi\u00adcantly simplifies \nthe proof. 5.2 Closure Representation We now turn to the representation of closures for the poly\u00admorphic \nlanguage. The target language for polymorphic closure representa\u00adtion, called AV>3 , is defined as follows. \nK2nds K::= klfl](KIX. .. XKn) Types a:= b]tl(al X.. .X On)l (aI, ..., c7n)17rta\\ Vt :ffa 1(71 + U2 I \nal -+CT2 I 3t :Ka I 3C.O Ezp S e ::= z Ic IAz:a.e Iel e2 IAt::m.e Ie C7I (cl,...,en)17r2el pack awith \neas a I open e as t::w with z:a In e pack Kwith eas a I open eas k with z:a in e Our translation of \nfunction types involves existential quan\u00adtifiers Since function types can instantiate a polymorphic type \nin the source language, we need to be able to mstantiate polymorphic types with existentlals in the target \nlanguage. As a consequence, the target language must be zmpredzca\u00ad twe. To simplify the language, we \nprovide general abstrac\u00adtions (J and A), instead of code types that abstract more than one argument at \na time. Since we shall have limlted need of existential kinds, we must introduce kmd variables k into \nthe language, with cor\u00adresponding kind contexts and judgments. A kind context K is simply a sequence \nof kind variables {kl, ., k~}, (n ~ O). The typing judgments of the language are as follows: K;AFc K \nuhaskind K. K; A EUI E cz ::K UI and ~z are equal types of kind K K; A;17ke:u e has type n. The formation \nrules, definitional equality rules, and typ\u00ading rules are standard except that values of polymorphic \ntype Vt:K.a maybe coerced to the spec,al type a + a[a /t], where u is a type of kmd K, as described in \nthe Section 4. The details of the typing rules are found in the companion technical report [21]. We define \nthe closure re resentation stage as a type\u00adAJ to ~v,3 directed translation from We begin by defining \na translation from source constructors and types to target type as follows: lt\\= t Ib[= 1) I(m)..., \nufi)l = (Ia,l,. Janl) In,o 1 = T,lal \\(u, x... xcTn)l = (Ia,lx... xlanl) lvcode(t::~, av,, al, az)l = \nVt:K Ia.,j + Ian + la~l ltcode(t::~, av,, S: K , m)l = Vt: K.lave\\ + VS:K . IO2I la, -+ cr21 = 3k.3to \nQ.3t:k ((t+ t. + ]a,l + Ia,l) x to) IVS:.K.CT2] = 3k.%::f2.3t::k-. ((t + to + vs::/L]o-, \\) x to) {tte::ttte};{Zve:ave,mn} \nl--e : ai? A; r E Atte::~t..AzV,:~V,.Ax:~l.e : vcode(tte::~t,,u ,,ul,uz) {tte::fite,t::{Zve:ave} t-e \nQ}; :cr A; r t-At,e::~,e.JxVe: aV..At::fl.e : tcode(tt,::~te,u e,t, u) A;17 1-el : vcode(tt.::~t,, av,,al, \nuz) A k -r : tite A;r * ez : ove[~/tte] A; r t-((cl, ~, ez)) : (m --+ m)[~/tt.] Figure 5: Typing Rules \nfor Code and Closures of Jv cl Figure 6: Polymorphic Abstract Closure Conversion: Types and Type Assignments \n(COI LSt) Am.; A.,g, r...; rug D C -C A env A arg renv;r.., D Ak,lv u Tte A.~.; A.,8; r.], ; rarg Dri,,v \nw e , 7, A en ; 0 Dr:.. -+ c ,, A:..; 0 ~ al -d (abs)  A~nv ; 0; rin ;{z:c71}De+ e /( // A env, A \narg, r env; I a,g D k:al.e -G+ ((Att~::l A~~ l. Az ~:lre,,Vl. Az:al .e , %, e ,)) A A arg, re,, ;rarg \nD AL,, -Tte A,,,.; A.,g ;re,l ;rargDr;,,. -e . en , (tabs) A;~~; 0 D r;nv -R,,, U,; {t:: Q}; r;nv, 0 \nD e-e A env >A arg, T .,, ; ~arg D At:: Cl. e + ((Atte::lA~,,V1.AxV~ :[r~,,Vl.At::Q. e ,%, e ,)) Figure \n7: Polymorphic Abstract Closure Conversion: Terms The code types are translated to the appropriate combi\u00adnation \nof target V and + types. The translation of a function type abstracts the kind of the type environment, \nk, and the type of the value environment, The type envn-onment t to. E paired with the code by using \nan existential type. Since the type of a code is mstantlated by t, only the type envi\u00adronment of the \nclosure can be given to the code. The code and the value environment are pan-cd as in the simply-typed \ncase. The translation of V has the same structure as that of an arrow type. The translation of expressions \nis summarized in Figure 8, The kind of the type environment, the type of the value en\u00advironment, and \nthe type environment are packed with the pair of the code and the value environment. In the transla\u00adtion \nof apphcatlons, the type environment is obtained from a closure by an open expression and the code and \nthe value environment are obtained by projections, Then the type environment, the value environment, \nand the argument of application are passed to the code. Type preservation is proved by induction on the \nstruc\u00adture of the translation derivation. The typing rules for a % a are essential to prove the cases \nfor the translations of closures. Theorem 5 lfA;r ~ e : cr~ e , then O;A; l17\\ ~ e Ial The correctness \nof the translation can be proven using logical relatlons as in the simply typed case. However, the definition \nof the relations 1s more complicated because of the presence of polymorphic types and types of the form \nT%(-r) m the language Jvct The relations and the proof appear in the compamon technical report [21], \n6 Summary and Conclusions We have given a type-theoretic account of ciosure conversion by defining type-directed \ntransformations for the simply\u00adtyped and polymorphic A-calculi. The types used in the target languages \nof the translations may be characterized m a natural way based on the (closures as objects prin\u00adciple. \nIn both the simply-typed and polymorphic cases of closure representation, we used Pierce-Turner-style \nexisten\u00adtial to hide the representations of environments. In the polymorphic case, we took advantage \nof Harper-Ldlibridge\u00adstyle translucency to ensure that the same type environment is used to type both \nthe code and the value environment of a ciosure, Our translations preserve types, facilitating correctness \nproofs and composition wnth other type-based translations, Furthermore, our translations provide support \nfor run-time type analysis and type-based, tag-free garbage collection. We have put the ideas in this \npaper to practical use in two separate compilers for ML. One compiler is being used to study novel approaches \nto tag-free garbage collection. The other compiler, called TIL (Typed Intermediate Lan\u00adguages), provides \na general framework for analyzing types at run time to support efficient data representations, effi\u00adcient \ncalling conventions, and [nearly tag-free garbage col\u00adlection in the presence of polymorphism [36]. Propagating \ntypes through closure conversion 1s necessary for both com\u00adpders so that types can be exammed at run \ntime. We have found that propagating types through closure conversion (and other compilation phases) \nhas an additional engineering benefit. In particular, we can automatically ver\u00adifv the type-integrity \nof each type-preserving phase in the compder. Indeed, automatic type-checking has enabled us to isolate \nand elimmate various subtle bugs m TIL. For simplicity, the current implementations of our com\u00adpilers \nuse only abstract closure conversion. However, both compilers extend this translation to avoid creation \nof clo\u00adsures for known functions m the style of Wand and Steck\u00adler [39]. In the future, we hope to use \nthe closure representa\u00adtion phase described here to further expose closure handling operations to optimization \n7 Acknowledgements We would like to thank Lars Birkedal, Andrzej Filinski, Mark Leone, Sue Older, Benjamm \nPierce, Paul Steckler, David Tarditi, and the anonymous reviewers for their many helpful comments and \nsuggestions. References [1]A. W. Appel, Compiling with Continuations. Cambridge University Press, 1992. \n[2] A. W. Appel and T. Jim. Continuation-passing, closure\u00adpassing style. In ACM Symp. on Prtnczples of \nProgramming Languages, 1989. [3] D. E. Britton. Heap storage management for the program\u00adming language \nPascal. Master s thesis, University of Arizona, 1975. [4] L, Cardelli. The functional abstract machine. \nPolymorphwm, 1(1), 1983. [5] C Cousineau, P -L Curien, and M. Mauny. The categorical abstract machine. \nIn Functional Programming Languages and Computer Architecture, pages 50 64, 1985. [6] H Friedman. Equahty \nbetween functional, In R. Parikh, editor, Logzc Colloquium 75 Norh-Holland. 1975. [7] J.-Y. Girard, Y. \nLafont, and P. Taylor, Proofs and Types, volume 7 of Cambrtdge Tracts tn Theoretical Computer Sci\u00adence. \nCambridge University Press, Cambridge, England, 1989. [8] J. Gosling. Java intermediate bytecodes, In \nACM SIG-PLAN Workshop on Intermediate Representations (IR 95), Jan. 1995 [9] J. Hannan, A type system \nfor closure conversion. In The Workshop on Types for Program Analysts, 1995, [10] R. Harper and M. Lillibridge. \nExphcit polymorphism and CPS conversion. In ACM Symp. on Principles of Program\u00adming Languages, 1993. \n[11] R. Harper and M. Lillibridge A type-theoretic approach to higher-order modules, In ACM S~mp. on \nPrtnczptes of Programming Languages, pages 123 137, 19 34. 12] R. Harper, D. MacQueen, and R. Milner \nStandard ML Technical Report ECS LFCS 86 2, Laboratory for the Foundations of Computer Science, Edinburgh \nU-niversity. Mar. 1986 13] R. Harper and J. C. Mlt,chell. On the type structure of Stan\u00addard ML ACM Transaction \non Programming Langua,qes and Systems, 15(2), 1993 14] R Harper and G. Morrisett. Compdmg polymorphism \nusing intensional type analysis In ACM Symp. on Przncaples of F rogr-ammtng Languages, pages 130 141, \n1995. [15] T. Johnsson. Lambda lifting Tkansformmg programs to re\u00adcursive equations. In Funci,tonal Programming \nLanguage and Computer Architecture, LNCS 201, pages 190 203. Springer-Verlag, 1985. A;17bel:~l-+02-+e~ \n/ A; I Dele2:u2-+ Open el as (Llpp) with y in (7rIy) &#38; A;r D e : tcode(t,e::tt~,, a(,e, t::~, A;r \nDe2:ul--+e~ kte, tve, tte : (tte ~ tve + Ian + Ic7zI x tve) (7TZy) e; a ) -+ e A;r D e., : CTV.w e~, \n(tapp) in Figure 8: Polymorphic [16] R. Kelsey and P. Hudak. Realistic compilation by program translation \ndetailed summary . In ACM Symp. on Prm\u00adcaples of Progr-ammzng Languages, pages 281 292, 1989. [17] D. \nKranz et al. Orbit: An optimizing compiler for Scheme, In Proc. oj the SIGPLAN 86 Symp. on Compder Construc\u00adtion, \n1986. [18] X. Leroy, Unboxed objects and polymorphic typing, In ACM Symp. on Principles of Programming \nLanguages, 1992. [19] X. Leroy. Manifest types, modules, and separate compila\u00adtion. In ACM Symp. on Prmczples \nof Programming Lan\u00ad tcZ) A; ---+fit., [avel, Ir[ with (e , e~e) as I dt::fi.a[ 17D ((e, -r, eve)) : Vt::fi.a2pack \n A;r D e : dt::fi. crd e A; 17De T :u[r/t] + open e as ki.,tv,,tt, guages, pages 109 122, 1994. [20] \nD. MacQueen. Modules for Conf. Lisp and Functional 1984. Revised version appears [21] Y. Minamide, G. \nMorrisett, conversion. Technical Report Computer Science, Carnegie Standard ML. In Proc. ACM Programmmg, \npages 198-207, in [12]. and R. Harper. Typed closure CMU CS 95 171, School of Mellon University, July \n1995. [22] J. C. Mitchell and G. D. Plotkin. Abstract types have exis\u00adtential type. ACM Transaction \non Programming Languages and Systems, 10(3), 1988. [23] G. Morrisett, M. Felleisen, and R. Harper. Abstract \nmodels of memory management. In Functional Programming Lan\u00adguages and Computer Architecture, pages 66-77, \nJune 1995. [24] R. Morrison, A. Dearle, R. Connor, and A. L. Brown. An ad hoc approach to the implementation \nof polymorphism. ACM Transaction on Program,mmg Languages and Systems, 13(3), 1991. [25] A. Ohori. A \ncompilation method for ML-style polymorphic record calculi. In ACM Symp. on Principles of Programmmg \nLanguages, 1992. [26] B. C Pierce and D. N. Turner. Simple type-theoretic foun\u00addations for object-oriented \nprogramming. Journal oj Func\u00adtional Programming, 4(2):207 247, Apr. 1994. A preliminary version appeared \nin Principles of Programming Languages, 1993, and as University of Edinburgh technical report ECS\u00adLFCS-92-225, \nunder the title Object-Oriented Program\u00adming Without Recursive Types . [27] G. D. Plotkin. Lambda-definability \nin the full type hierarchy. In To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism. \nAcademic Press, 1980. [28] U. S. Reddy. Objects as closures. In Proc. ACM Conj. Lisp and Functional Programming, \n1988. [29] J. C. Reynolds. Definitional interpreters for higher-order programming languages. In Proceedings \nof the Annual ACM Conference, pages 717 740, 1972. with y :(&#38; + &#38; + Vt::tt.lal x k) (7rl y) t~e \n(TZ y) [Tl Closure Representation [30] Z. Shao and A. W. Appel. Space-efficient closure represen\u00adtations. \nIn Proc. ACM Conj. Lwp and Functional Program\u00adming, 1994. [31] Z. Shao and A. W. Appel. A type-based \ncompiler for Stan\u00addard ML. In Programming Language Design and Its tmple\u00admenation, pages 116 129, 1995. \n[32] R. Statman. Completeness, invariance, and lambda\u00addefinability. Journal of Symbolic Logic, 47:17-26, \n1982. [33] R. Statman. Logical relations and the typed A-calculus. ln\u00adformatton and Control, 65, 1985. \n[34] G. L. Steele Jr. Rabbit: A compiler for Scheme. Master s thesis, MIT, 1978. [35] W. W. Tait. IntensionaI \ninterpretation of functional of finite type. Journal of Symboltc Logic, 32(2), 1967. [36] D. Tarditi, \nG. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. TIL: A type-directed optimizing compiler for \nML. Technical report, School of Computer Science, Carnegie Mellon University, Oct. 1995. To appear. [37] \nA. Tolmach. Tag-free garbage collection using explicit type parameters. In Proc. ACM Conf. Lisp and Functional \nPro\u00adgrammmg, pages 1-11, June 1994. [38] R. Wahbe, S. Lucco, T. Anderson, and S. Graham, Efficient software-based \nfault isolation. In 14th ACM Symposium on Operatzng Systems Prmczples, Dec. 1993. [39] M. Wand and P. \nSteckler. Selective and lightweight closure conversion. In ACM Symp. on Principles of Programming Languages, \n1994. \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Yasuhiko Minamide", "author_profile_id": "81100225818", "affiliation": "Research Institute for Mathematical Sciences, Kyoto University, Kyoto 606-01, Japan", "person_id": "P304920", "email_address": "", "orcid_id": ""}, {"name": "Greg Morrisett", "author_profile_id": "81339518683", "affiliation": "School of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP43136279", "email_address": "", "orcid_id": ""}, {"name": "Robert Harper", "author_profile_id": "81100140064", "affiliation": "School of Computer Science, Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39029370", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237791", "year": "1996", "article_id": "237791", "conference": "POPL", "title": "Typed closure conversion", "url": "http://dl.acm.org/citation.cfm?id=237791"}