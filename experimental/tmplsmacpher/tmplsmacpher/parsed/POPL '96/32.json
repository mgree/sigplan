{"article_publication_date": "01-01-1996", "fulltext": "\n An Interpretation of Objects and Object Types Martin Abadi Luca Cardelli Digital Systems Research Center \nDigital Systems Research Center ma@pa. dec. com luca@pa. dec. com Ramesh Viswanathant Isaac Newton Institute \nfor Mathematical Sciences R. Viswauathan@newt on. cam. ac .uk Abstract We present an interpretation of \ntyped object-oriented con\u00ad cepts in terms of well-understood, purely procedural con\u00ad cepts. More precisely, \nwe give a compositional subtype\u00ad preserving translation of a basic object calculus supporting method \ninvocation, functional method update, and subtyp\u00ad ing, into the polymorphic ~-calculus with recursive \ntypes and subtyping. The translation techniques apply also to an imperative version of the object calculus \nwhich includes in\u00ad place method update and object cloning. Finally, the trans\u00ad lation easily extends \nto Self types and other interesting object-oriented constructs. 1 Introduction Object-oriented programming \nlanguages have introduced nu\u00ad merous ideas, structures, and techniques. Although these contributions \nare not always conceptually clear (or even sound), they are often original and useful. One of the most \n basic contributions is the notion of self the operations asso\u00ad ciated with an object (its methods) can \nrefer to the object as self, and invoke other operations by indirecting through self, with dynamic dispatch. \nA related contribution is the notion of subsurnptton: an object can be replaced (subsumed by) any object \nthat supports the same or more operations; in typed languages, subsumption is systematized in rules for \nsubclasszng and subtyptng. Object-oriented programming is not limited to object\u00ad oriented languages. \nOne can emulate objects in some proce\u00ad dural languages, such as Scheme and C. So it is possible that, \n despite its originality, object-oriented programming can be reduced to procedural programming. Such \na reduction 1s not straightforward. Interesting difficulties arise at the level of types: the most natural \ndefinition of objects as records of functions (the self-applzcatzon semantzcs [Kam88]) does not validate \nthe expected subtypings, so subsumption is blocked. Address: Digital Systems Research Center, 130 Lytton \nAvenue, Palo Alto, California 943o1, U.S.A. Supported by NSF Grant CC R-9303099 and a Rosenbaum Fel\u00ad \nlowship. Address Isaac Newton Institute for Mathematical Sciences, 20 Clarkson Road, Cambridge, CB3 OEH, \nU.K. Permission to make digital/hard copies of all or part of this material for personal or classroom \nuse is granted without fee provided that the copies are not made or distributed for profit or commercial \nadvantage, the copy\u00adright notice, the title of the publication and its date appear, and notice is given \nthat cop yright is by permission of the ACM, Inc. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires specific permission andlor fee. PQPL 96, St. Petersburg FLA USA \n@ 1996 ACM 0.s9791-769-3/95 /01 ..$3.50 In this paper we develop an interpretation of object\u00adoriented \nprogramming in terms of procedural programming (specifically, in terms of a fairly standard J-calculus \nwith subtyping). We show a translation of objects into records of functions, and a translation of object \ntypes into types built up from record types, existential types, and recursive types. These ingredients \nshould not be surprising, but their combi\u00adnation is new. The translation is faithful in that it respects \noperational semantics, typing rules, and subtyping rules; it yields a syntactic proof of soundness for \nthose rules. In order to make this interpretation both manageable and precise, we develop it in the context \nof object calculi [AC94b], Object calculi are formalisms analogous to A\u00adcalculi, based on objects rather \nthan on functions. Their only primitives are objects, method invocation, method up\u00addate, and (for imperative \ncalculi) cloning. Method update is the most unusual of these, but forms of method update do appear in \nseveral languages [Lie81, And92, Tai92, MGV92, MMPN93, ALBC+93) App93, Car95]. The primitives are quite \nexpressive: they allow representations of both class\u00adbased and object-based notions, for example classes, \nsub\u00adclasses, protection, prototyping, and mode switching, When typed, object calculi include a subtyping \nrelation and a sub\u00adsumption rule. We believe that our interpretation of objects is com\u00adpelling for several \nreasons. First, it makes precise the vague intuition that objects have something to do with abstract \ndata types and re\u00adcursive types. That intuition has been important in previous works that studied A-calculi \nwith subtyping and used them to emulate objects to various extents (see the next section). The target \ncalculus of our trans\u00adlation is the result of those previous works. The translation is sufficiently complicated \nto confirm that objects provide a useful abstraction mdependent of procedural concepts. On the other \nhand, it 1s simple enough to serve as an explanation of objects in terms of well-understood constructs. \nFinally, the translation is not limited to one particular object calculus. With some modifications, it \napplies both to functional and imperative execution models; and it can be adapted to account for Self \ntypes and structural rules [AC95b], which are operationally sound but unsound in common denotational \nmodels In the next section we review some of the background, describing related works, and give an informal \noverview of our interpretation. Section 3 defines a first version of the translation precisely; Section \n4 gives an imperative transla\u00adtion; Section 5 deals with additional type constructs. 2 Informal Review \nand Overview We first review a basic untyped object calculus [AC94b] since we use its notation in what \nfollows, In this calcu\u00adlus, an object [11 = ~(zl)bl, . . . . in = ~(zn)bn] is a collec\u00adtion of methods \n~(zl)bl, . . . . ~(z~)b~ with respective names 11,. ... in; the method bodies are bl, . . , b~, and the \nvari\u00adableszl, ..., Z. denote self. The order of the methods does not matter. The only operations on objects \nare method invocation and method update. If o is the object [11 = g(zl)bl, . . . . 1~ = r(z~)b~], then \nthe invocation of its method 1,, written o.1,, consists in replacing o for xi in bi; the method update \no.1, + ~(z)b yields an object like o but where we have 1, = ~(z)b. For now, we take the update construct \nto be functional, that is, to create a new object. Fields (in\u00adst ante variables) are easily expressible \nas methods that do not use their self parameters. This untyped calculus is the basis for a first-order \ncalcu\u00adlus with subtyping, called Obl<,. In Obl <, an object type [11 : B1, ..,, 1~ : B~] is the type \nof objects which have meth\u00adods 11, . . ., 1% that, when invoked, result in values of types i31, . . . \n. Bn respectively. A characteristic of object-oriented languages is that an object with more methods \ncan be used wherever an object with fewer methods is expected. In Obl<,, this is supported through a \nsubtyping relation <:. An object type with more methods is a subtype of an object type with fewer methods \nprovided that the common methods have exactly the same result types; for example, [11 : B1, 12 : B2] \n<: [11, Bl] for any types B1 and Bz. The self-application semantics [Kam88] provides a sat\u00adisfactory \nexplanation of untyped objects as records of func\u00adtions. Let us write {11 = al, . . . L = an} for the \nrecord with fields 11,. ... 1~ with al, , an as values; a ~1 for extracting the field 1 of record a; \nand a ~1 := b for updating the field 1 of record a to be b. In the self-application semantics, a method \nis a function of its self parameter; an object is a record of such functions; met hod invocation is field \nselection plus self\u00adapplication; method update is record update: This interpretation respects the operational \nbehavior of both method invocation and method update. Unfortunately, the self-application semantics does \nnot extend to typed systems such as Obl <,. In particular, it does not validate the essential subtypings \nbetween object types. Following the self-application semantics, one would naturally interpret the object \ntype A ~ [1, : B, =l ] as a recursive record type, the solution to the type equation: A = {1, : A-B, \nl n} where {1, : C, =l m} denotes the evident record type. Be\u00adcause of the contravariant occurrences \nof the object type A, we do not obtain subtypings valid in Obl<, such as [11 : BI,12 : Bz]<:[JI : B,]. \nIn part because of this difficulty, there have been several other interpret at ions of objects. Most \nof them were defined as ways of emulating objects in procedural settings, rather than as precise translations, \nso it is somewhat hard to give a full account of their scope. In short, many of them con\u00adtributed interesting \nand useful techniques but they all suf\u00adfer from limitations. The recursive-record semantics [Car88] validates \nthe expected subtypings, but it does not model method update (or even field update); the generator seman\u00adtics \n[CO089] deals with update, at the cost of separating objects from object generators. The existential \ninterpreta\u00adtion of [PT94, HP95] also validates the expected subtyp\u00adings, and models class-based constructs \nwhere methods and fields are rigidly separated and it is only the fields that can be updated; unfortunately, \nthe translation of objects is type-directed, and rather elaborate. An imperative in\u00adterrxetation (ESTZ951 \ncan solve the m oblems. of the self\u00adapplication semantics with judicious side-effects; its main limitation \nis that it does not model the cloning construct of object-based imperative languages. Finally, some inter\u00adpretations \ngive up on subtyping altogether, and reduce it to coercion functions [AC94a, R6m94]; the coercion functions \nare cumbersome, destroy the flavor of the original programs, and preclude an explanation of object subtyping \nin terms of more primitive subt yping relations. At this point, a possible conclusion is that it is easy \nto understand the computational behavior of obiects. but that ./ their desired typing and subtyping \nproperties make them fundamentally different from records and functions. It was this view that originally \nled to the formulation of object cal\u00adculi. Our interpretation of objects, which we discuss next, sheds \nsome new light on this matter. It does provide a rather complete account of objects in terms of records \nand functions. It applies both to class-based and object-based constructs, places no restrictions on \nmethod update, and val\u00adidates the expected subtypings. On the other hand, because it is not straightforward, \nit does not remove the usefulness of object calculi as a setting for studying object-oriented concepts, \nIn this paper we develop translations of several object calculi into ~-calculi. The translations are \nfaithful in that they respect the operational semantics, typing rules, and subtyping rules of the object \ncalculi. The first translation maps Obl <, into F< ,W, the polymorphic ~-calculus with subtyping and \nrecursive types; we preview this translation next, explaining informally how it treats types. Consider \na type A -[11 : B1, . . . . 1~ : B~]. Because of subsumption, an object o containing additional methods \nbe\u00adsides 11, . . . ,1. can be an element of A. If we think of the true type of o as the type listing \nall its methods, then the type A only partially reveals the true type of o; what is publicly visible \nare only the methods 11, . . . . 1,., We there\u00adfore take the translation A* of an object type A to be \na type abstraction with representation type the true type of the ob\u00adject. Using the notation 3( X<:C)B \nfor a type abstraction with an interface B and an unknown representation type X that is a subtype of \nC, we define A* as a recursive type, with the following equation: A* = 3( X<: A*){1; : (X-B;) e n, self \n: X} (1) The subtyping assumption X< :A* for the representation type expresses that the true type is \nknown to be a subtype Table 1: Operational Semantics of Oblz, and F< ~ If a-[1, =<(z, :A)b,{z, } l ], \nObl<. (Eval Select) a.lj (Eval Update) al, + <(z : A )b (Eval Beta) (Eval Beta2) (Eval Record Select) \nF<+ (Eval Unfold) (Eval Unpack) open c as .Y<:A, where c = pack of the object type. The field 1~ 1 is \nthe method 1, treated as a function of self. The field l~p(i provides the ability to update method 1, \ngiven a new method that is a function of self, it returns a new object. The field self is the object \nitself with all its methods (including the private ones); through self, the methods 11, . . . . in can \naccess methods not listed in the interface. Each of the ingredients in this translation is necessary. \nIn particular, the use of existential types in addition to re\u00ad cursive types is essential for getting \nthe desired subtypings. Similarly, it is essential to model method update via a field l~p l: if method \nupdate were modeled by an update of the field @ then this would leave the field se~ unaffected, so the \noperational semantics would be distorted. In the next section we detail this translation of Obl <.. In \nSection 4, we consider an imperative version of the trans\u00adlation, which deals correctly with cloning \nbut is in some ways simpler than the functional one thanks to side-effects. In Section 5, we show that \nthe translation of Obl<. can be extended to account for richer object-type constructs with Self types \nand variance annotations. 3 Interpretation of an Object Calculus with Functional Upclate In this section, \nwe describe the translation of the object cal\u00adculus Obl< into the functional calculus F< P. In Sections \n3.1 and 3.2, we briefly describe the calculi Obl c and F< ~, and in Section 3.3, we detail the translation \nof Obl<. into F< ,W. The precise typing rules for the two calculi are given in Appendices A and B. 3.1 \nAn Object Calculus: Obl<, The types of Obl< are generated by the grammar: A,B ::= TOP I [1; :Bi =1 ] \n where n ~ O. The type Top is the supertype of all types and [L : Bt 1 n ] is the type of objects with \nmethods L returning results of type B,. The terms of the calculus are similar to those of the untyped \ncalculus described in Section 2 except that g-bound variables have type annotations: a,b ::= x I[1,= \n<(z, :A)b, ln] [a.1 Ia.1 -+ <(z :A)b j E1. ..n + b]{.} + [1, = <(z: A)b, 1, = ~(x, : A)bi ~{ }-{ }] \n (J(r : A)b{z})(a) -+ b{a} (A(X<:A)b{X})(A ) w b{ A } {1, = b, e } ~ 1, + bj forj~l. ..n unfold(fold(A, \na)) + a z :B{X} in d{X, z} :D -+ cl{C, b{C}} X<:A = C with b{X} : I? {X} A subset of the terms generated \nby this grammar are iden\u00ad tified as well-typed terms by a set of typing rules described in Appendix A. \nThe rules are used to derive judgments of the form E k 3, where Y is an assertion and E is an en\u00ad vironment \ndescribing assumptions about the free variables in Y. The assertion o means that E is a well-formed en\u00ad \nvironment, A means that A is a well-formed type, A< :B means that A is a subtype of B, and a : A means \nthat a is a well-formed term of type A. An important rule, (Sub Object), states that A is a subtype of \nA if A has all the method names given in A and moreover the result types of these methods are exactly \nthe same in A and A (so object types are invariant in their component types). The operational semantics \nis defined via a reduction sys\u00adtem; it is free of side-effects. The primitive redexes given in Table \n1 correspond to method invocation and method up\u00addate; we write b{z} to distinguish a variable z that \nmay oc\u00adcur free in b, and b{a} for the result of replacing z with a in b once z is clear from context. \nThe one-step reduction relation --+0 is the congruence closure of * (t. e., we can reduce any subterm \nthat is a redex); the many-step reduction relation ~o is the reflexive, transitive closure of +0. We \ndefine results to be terms of the form [L = ~(m, : A)b, =l ]; we say that a closed term a converges, \nand write a .1,10,if there exists a result v such that a ++ ~ u. 3.2 A Functional Calculus: F<:p The \nsystem F<,, is the standard extension of System F with recursive types and subtyping. While records and \nexisten\u00adtially quantified types are encodable in terms of the other constructs of F< ,P, we present them \nas primitive for sim\u00adplicity, System F<:P is defined in detail in Appendix B; in this section, we describe \ninformally some of its constructs. Records are collections of fields with associated values; the only \noperation on records is field extraction (written T 1). The basic types are function types and record \ntypes. A record type {1, : B, e } lists the field names and the types of the values associated with \nthem. Record types are covariant in their component types. We use the recursive type p(X)B{X} to denote \na solution to the type equation X = B{X} where X could occur free in B. The isomor\u00adphism between ~(X)B{X} \nand its unfolding B{p(X)B{X}} is given by the constructs fold and unfold: if a is of type p(X)13{X} then \nunfold(a) is of the unfolded type, and if b is of the unfolded type then fold(p(X)B{X}, a) is of type \n p(x)l?{x}. The existentially quantified type 3( X<: A)B{X} is the type of a term a (roughly) if there \nexists a type C that is a subtype of A for which a is a term of type B{C }. More formally, given a term \na of type B{C }, the term pack X <: A= Cwitha: B{X} has type 3( X<: A) B{ X}. What we achieve by packing \na in a term of type 3(X< :A)B{X} is the hiding of information about the type C at which a realizes 3( \nX<: A) B{ X}. (Recall that data abstractions have existential types [MP88]. ) Given a term c of type \n3(X< :A)B{X}, we can access its inside by writing the term open c as X<:A, y : 13{X} in d : D, where \nX stands for the representation type and y for the inside . We can use X and y in d but the typing rules \nensure that d can\u00adnot assume any information about X other than that it is a subtype of A, and the type \nD specified for d must not depend on the representation type X, i. e., X cannot occur free in D. Table \n1 specifies reduction for F< W. The one-step reduc\u00adtion relation f is the congruence closure of w, and \nf is the reflexive, transitive closure of ---+ ~, As for Obl <,, we distinguish certain terms as results; \nthe set of results, de\u00adfined in Appendix B, includes A-abstractions and records. We say that a closed \nterm o. converges, and write a .lj.f, if there exists a result v such that a . Using recursive types, \nwe can easfl~ define a (call-by\u00adname) fixed point operator. It is also routine to define letrec; we write \nletrec ~(zl : Al) ~. . (an : An) : B = b in c to denote a recursive definition of a function f of type \nAl-+ ~. +A~+B, used in the term c. 3.3 Translation We are now ready to describe the translation of Obl<. \ninto F< ,P. The translation is in two parts. The first part is a translation of types which maps every \ntype A of Obl <, to a type A* of F< W and is defined by induction on the structure of types in Obl<,. \nTop = Top [Jt , B, t~l...n ] * = p(Y)3(x<:Y) {1; , (X+ljy) =1 ~, l:P<~: (4y+B; )+x tel...%, self : X} \n The interpretation of object types given here is the same as that of Section 2, but here we use a p \nrather than an equation (Equation (1) ) for defining the existential type re\u00adcursively. Note that in \nthe translation of the object type A=[li:Bi E ], the field 1/ 6 makes the type A* covariant in B; and \nthe field 1~] ~ makes it contravariant in B:. Our interpretation thus explains the invariance of object \ntypes in their component types as arising from a covariance due to invocation and a contravariance due \nto update. The key consequence of our translation of object types is that it gives the expected subtypings. \nMore formally, we use the translation of types to define a mapping E* for environments, and establish \nTheorem 3.1 which states that well-formed types of Obl <, get mapped to well-formed types of F<, P and \nthat the subtyping judgments of Oblz, are preserved by the translation. Theorem 3.1 1. If E 1-0 is derwable \nin Obl<,, then E* R o as dertvable in F<.P. 2. If E k A w der~vable m Obl<,, then E* t A* as deriv\u00adable \nin F<,W. 3. IfE &#38; A<:B is derivable in Obl<,, then E* 1-A*<:B*  .. is derivable in F<,P. The second \npart of the translation is for terms. To make the main ideas in the translation of terms transpar\u00adent, \nwe first informally explain the results of the translation as untyped J-terms, omitting the type annotations \nassoci\u00adated with using recursive and existential types; we make the details precise later. Informally, \nevery term a of Obl<, is mapped to its meaning, ((a)), which is a J-term. Apart from the typing restrictions \nimposed by the recursive and existen\u00adtial types, the translation of an object type is a record type with \ntwo fields l~el and l~r (~ for each method 1, and a field self. The field l~ei is the method 1, treated \nas a function of self, and the field l~ud returns a new object when applied to a new method treated as \na function of self. With this understanding, the translations of method invocation and update are straightforward. \n((a.lj)) = ((a)) ~1~ (((a)) ~seZf) ((a.lj -+ <(z) b)) = ((a)) ~1~ (J(z) ((b))) The most delicate part \nof the translation of terms is that for objects. This may be expected since we did not do any\u00adthing computationally \ninteresting so far we just delegated responsibility to the fields l~el and l~P ~ provided by the in\u00adterface \nof objects. To understand the translation of objects, it is instructive to consider first an incorrect \nattempt, which will also explain the presence of the field 1~~. Suppose we chose not to have the field \nl~r [l in the record interface for objects and instead modeled method update by an update of the field \nl~ t, i.e., for an object o -[1, = ~(z,)b, ~l ], we would have that ((0.i, + s(z) b)) = ((0)) t; := A(z)((b)) \n(wrong) Invoking a method lj of o would still be interpreted as ex\u00adtracting the l~ i field and applying \nit to the field self. Since the object o is a record with field 1~ ~ equal to the method b, treated as \na function of its self parameter, and since method invocation is modeled by application to the field \nself, the field self then has to be the object itself. We arrive at the following recursive definition \nfor ((o)): ((o)) = {1~ = J(z,)((b,)) e n, self= ((o))} (wrong) The problem with this (functional) interpretation \nof objects is that when a method gets updated the object changes but since we only update the field 13 \nof the record, this change is not reflected in the field self and consequently we lose the dynamic binding \nof self. Thus, if some other method uses lJ in its body, then its invocation modeled by application Table \n2: Translation of Obl <, into F< ~ ((z)).kj = z (([Lt= r(z, : A)b, ~=1 n ]))E = l;:ly(yte (f, : A*-B~) \n(f. : A*_ B;) : A* = pack X<:A* = A* with {1~ ~ = f, =l , l; [l = /\\(g : A*~l?:) create (fl) . . (f, \n]) (g) (f,+l) ., (fn) =l , Sdf = CTWak (fl) (fn)} : CA{ X}) in create (~(zl : A*)((bl))E,~l.A) (J($n \n: A*)((b~))E)~~.A) where A = [1, : B, =l ] ((a.1))~ = open unfold(((a))~) as X<: L1,B, z : {1 : (X-+B*), \nself : X} in (z l l)(z self) : b where B = (E, a)l ((at ~ ,(z : A)b))E = open unfold(((a))~) as X<.A \n, y : CA{X} in (y l P~)(~(z : X)((b)) ~,ZA) : A* to the field set~ would not see the result of the update. \nSo, an important idea in the context of our translation is that method update is not modeled as record \nupdate. The second idea to glean from this flawed attempt is that defining the object itself recursively \nwould not reflect the computational behavior of objects accurately. Intuitively, update has no chance \nof working once the recursion freezes self to be the state of the object at the time of creation, t. \ne., if recursion is used too soon. (Those familiar with the recursive-record interpretation [Car88] may \nnote that the source of its prob\u00adlems in modeling method update can also be traced to the early use of \nrecursion. ) The solution is to define not the object itself recursively, but the dependence of the object \non its methods recursively. That is, we define a function create that when applied to n methods, returns \nan object with those n methods and it is the definition of create that is recursive. An object can then \nbe defined by the application of create to its methods, as follows: We now define the translation notations, \nmore precisely. We use Notation: 1.For any object type A ~ [L F< P type CA {X} with free of terms with \ntyping the following notation. : B, El m], we define variable X: an\u00adthe Cd{.Y} ~ {1: ] : (X-+ l! Pd : \n(X-+ s elf : X} B:) =l B;)_X , 61 , 2. For any method name 1 and Obl <. type B, we define the F<,W \ntype L1,B by: Lt,B ~ w(Y)3(X<:Y){l ~ : (X~B*), self : X} 3. SupDose. for anv term a and environment \nE. that E k a: ~. .,l:B ,. ~.] is provable in Obl<,. Then by the minimum-types property of Obl< [AC94b] \nand by the invariance of object types, we have that if E > a : [.,.,1 : B ,...] then B ~ B . So we let \n@,a)l be the unique type Bsuchthat E \\ a : [...,1:B, ...] is provable if it exists, and be undefined \notherwise,  For any term a in Obl <. and environment E, Table 2 defines a term ((a))E of F< ,W. The \ntranslation proceeds by induction on the structure of a. In particular, the translation of a judgement \nE \\ a : A does not depend on its derivation in Ob 1< , and consequently, we can avoid coherence issues \nin our proofs. The inclusion of the environment E in defining the meaning of a term arises for purely \ntechnical reasons. It is to give the necessary type annotations in the translation of method invocation, \nIf we had omitted type annotations from the target calculus or put more type information in the syntax \nof the term for method invocation, we could have defined the meaning of the term without any dependence \non the environment. Some remarks regarding the translation of terms are in order. The translation of \nmethod invocation explains the presence of the field self in the translation of object types: using x \ninstead of x self would not lead to a typable re\u00ad sult. In the translation of method update, the use \nof J(z : X) ((b))~,a.A Is motivated by the reduction rule (Eval Up\u00ad date) which asserts: ([L = {(z. \n: A)bt 1 +ti].l, @ {(z: A )b) --i [lj=<(z A)b,... ] with A instead of A in the type annotation of x \nin the updated object. The use of J(z : A*) ((b)) E,.. A instead of J(z : X) ((b)) ~,c .,l would be acceptable \nfrom the point of view of typing but would not fit with the rule (Eval Update).  400 The following theorem \nstates that our translation pre\u00adserves typing judgments and the computational behavior of terms. Theorem \n3.2 1. If E k a :A M derwable in Obl<: then E* t ((a))E : A* is derivable in F<,W. 2. If E 1-a : A is \nderivable in Obl<, and a Ob then ((a)) ~-~((b))E  The translation can serve as a basis for validating \nrea\u00adsoning principles for objects from reasoning principles for functions. In particular, we can prove \nthat two objects are equivalent by showing that their translations are equivalent. We have been able \nto check a few non-trivial object equiv\u00adalences in this manner. This proof method is not complete, because \nthe translation is not fully abstract; however, it is sound, because the translation is computationally \nadequate, as we show next. Let a and b be two closed Obl<, terms of type A. We say that a and b are operationally \nequivalent at type A, and write a =0 b : A, if we have that C[a] &#38; if and only if C[b] &#38; for \nany context c[.] which is well-typed assuming the hole [,] is of type A, We define the relation of opera\u00adtional \nequivalence similarly for F< ,P, and write a =~ b : A. The first part of the following theorem states \nthat the trans\u00adlation is comput ationally adequate; the second part, which is a corollary of the first, \nstates that if two Obl <, terms have operationally equivalent translations then they are op\u00aderationally \nequivalent. Theorem 3.3 Assume that Ot-a : A and 0 t-b : A are de\u00adrivable m Obl<,. Then: 1. a &#38; Zf \nand only zf ((a)). d,l~. 2. If ((a))O -f ((b)). : A* then a so b : A.  In summary, there are three \nkey ideas in the translation. The first is that interpreting an object type as a recursive type abstraction \ngives the desired subtypings. The second is to model method invocation not as application to the object \nitself, but rather to a field self which holds the current value of the object. And finally, by splitting \neach method into a field for invocation and a field for update and by using recursion in a function that \ncreates objects, we obtain dynamic binding. 4 Interpretation of an Imperative Object Calculus In this \nsection, we show how the ideas embodied in the trans\u00adlation described in Section 3 are also useful to \nthe interpre\u00adtation of imperative object-oriented constructs. Our formal setting is the imperative object \ncalculus of [AC95a]. 4.1 An Imperative Object Calculus The terms of the untyped imperative object calculus \nare generated by the grammar: As the previous calculus, this imperative calculus has terms corresponding \nto objects, method invocation, and method update. However, the operational semantics is imperative in \nthat method names denote locations where the closures of the corresponding methods are stored and method \nupdate is done in place. Thus, method update has a side-effect of changing the object rather than returning \na new object. In addition, we have two new primitives: (1) clone(a) returns a shallow copy of the object \na, i. e., an object with the same method suite as a stored in fresh memory locations; (2) the let construct \nevaluates a term, binds it to a variable, and then evaluates a second term with that variable in scope. \nSequential evaluation (;) and eagerly evaluated fields can be defined from let. The type system is given \nin Appendix C; it is an extension of that of Obl<,.  4.2 Translation We translate the imperative object \ncalculus into an impera\u00adtive version of F< ,Y, which here we describe informally. The syntax of this \nimperative version extends that of F< ,W wit h field update for records (written a. 1 := b) and with \nan unini\u00adtialized value of each type (written nii(l?)). Because of the presence of field update, record \ntypes must be invariant in their components. The operational semantics of the impera\u00adtive version is \nsignificantly different from that of F< ~ in two respects: (1) The field names in records now denote \nmemory locations and field update is done in place. It is therefore more accurate to think of a record \nas a collection of mem\u00adory locations rather than as a collection of values. (2) In the mesence of side-effects. \none needs to fix an evaluation order: we assume call-by-value evaluation for the target calculus. Then \nlet a = a in b can be defined as (J(z) b)(a), and a; b can be defined as (J(.z)b)(a) for some z not free \nin b. The main departure from the translation described in Section 3.3 is that. in the imperative settirm. \nwe do not sdit a method into two distinct &#38;elds correspo~ding to met~od invocation and method update. \nRecall that the essential rea\u00adson for the split in the functional case was that the field self would \nnot detect the change to a method if method update was modeled by record update of the field corresponding \nto the method. However. in the rmesence of imperative. features . in the target calculus, we can use \nthe field self to store a pointer to the record itself (that is the meaning of the ob\u00adject), thus ensuring \nthat any changes to the other fields of the record are reflected in self. The translation of types uses \nthe ideas described in Sec\u00adtion 2. In addition, we include a cloning function in the public interface \nof an object. For types we therefore have: Top = Top [1, : B, e n]* = w(Y)3(X<:Y) {li , (X+B~) e , clone \n: {}+X, self : X} The distinction between the fields self and clone is that the former contains a pointer \nto the record itself while the latter returns a shallow copy of the record (under a dummy ab\u00adstraction). \nWe need to distinguish the two since, in method invocation, one must apply the method to the object rather \nthan to a shallow copy of the object. As before, the use of a recursive type abstraction yields the desired \nsubt ypings. 401 Table 3: Translation of the Imperative Object Calculus (Sketch) ((z)) = z (([1, = r(cc,)b, \n ~ n ])) = letrec create (f,) ,.. (fn) = let z = {L = f, =l , clone = ml, self = nd] in z ckme := \nJ(z)create (2 11) (.Z . L); z . self := z; z . self in create (J(zl)((bl)) . (J(z~)((b~))) ((a.lj)) = \nlet z = ((a)) in (Z 1,)(z self) ((al e ~(z) b)) = let y = ((u)) in y 1, := ~(~)((b)) ((clone(a))) = (((a)) \nckme)({}) ((let z = a in b)) = let z = ((a)) in ((b)) We give the precise definition of the translation \nof terms below. For now, we refer to Table 3 which states the transla\u00adtion omitting type annotations \nin terms. In the translation of an object, we declare a skeletal record structure z where the fields \nclone and self are uninitialized, and then update these fields so that they can point circularly to the \nrecord structure. Note that we retained the idea of defining a create function recursively rather than \nthe object itself recursively. This is necessary for cloning to return the correct copy of the object \nafter updates; if we had defined the object recur\u00adsively, then clone would have been frozen to return \na shallow copy of the state of the object at the time of its creation. (Cf. the semantics of [ESTZ95], \nwhich does not accommo\u00addate cloning.) In our translation, the field clone is defined to be an abstraction \nso that the application of create termi\u00adnates under call-by-value evaluation. Method invocation is interpreted \nin the same way as in the functional case while method update is interpreted as record update. Cloning \nis interpreted as an application of the field clone to a dummy argument (the empty record). The precise \ndefinition of the translation of terms, in Ta\u00ad ble 4, relies on the following notation: Notation: Cyp{x} \n~ {1, : (X+ B:) =  n, clone : {}+X, self : X} 2. For any method name 1 and type B, we let: L/~ ~ p(Y)3(X<:Y){l \n: (X+B*), self : X} 3. The type Mzn Z y (E, a) 1s the minimum type of a in environment E, z e., the \ntype A such that E + a : A is provable if and only if E t-A<: A ; it is undefined if a is not typable \nin E. The type (E, a)l is as in Section  3.3. We can prove a soundness theorem for this translation. \nWe omit it from this paper since its statement requires lengthy definitions detailing and relating the \noperational se\u00admantics of the imperative calculi.  5 Extensions to Richer Object Types In this section, \nwe consider richer typing disciplines for ob\u00adjects: variance annotations, Self types, and structural \nrules (all described in [AC95b]); we show how our translation ex\u00adtends to account for them. In Section \n5.1, we begin by giving an overview of these typing disciplines and an informal de\u00adscription of our interpretation \nfor them. In Section 5.2, we describe an enriched object calculus more precisely. Finally, in Section \n5.3, we give a translation of this object calculus. 5.1 Preview  Variance Annotations Variance annotations \nare an extension to object types; they are symbols (+, , 0 ) attached to method names in object types. \nThe annotation 1+ indicates that method 1 is only invocable, 1 indicates it is only updatable, and 1\u00b0 \nindicates that it is both. These annotations allow finer protection on the access of methods, and give \ndesirable subtyping prop\u00aderties. Object types are covariant in the types of their + components, contravariant \nin the types of their compo\u00adnents, and invariant in the types of their 0 components. Variance annotations \nnaturally fit in the framework of our interpretation. Namely, we can translate object types to the same \nrecursive type abstractions with both record components 1 [, l p~ for a method 1\u00b0; only the 1 I compo\u00adnent \nfor 1+; an d only the 1 ~~ component for 1-.  Self Types The Self-type construct yields flexible typing \nfor objects with methods that return objects of the type of self. Ex\u00ad tending the notation for object \ntypes, we write obj(x)[h : Bt{x} G ] where Obj binds a type variable X that can occur covari\u00ad antly \nin the result types B,; intuitively the variable X stands for the type of self, called the Self type. \nA longer object type is still a subtype of a shorter one: Obj (X)[L B. l n+-] <: Obj(X)[L : B, 1 m] Recall \nthat in the translation of simple object types given by Equation 1 we viewed the representation type \nas the true Table 4: Translation of the Imperative Object Calculus ((~))E = ~ (([~a = ((z, , A)bi ~el...n \n]))~ = letrec create (jI : A*--+Bf) . . . (jn : A*-+B~) : A* = let z : C~p{A*} = {1, = f, l n, clone \n= nzl({}-iA*), self in ,2 ~ clone := J(z : {}) create (z ~11) . . (z . in); z . self := fold(A*, pack \nX<: A* = A* with z : C~~P{X}); z . self in create (~(zl : A*)((bl))~,ml,A) . . . (~(z~ : A*)((b~))E,~w,A) \nwhere A s [1, : B, eln] = nil(A*)} ((a.1))~ = open unfoid(((a))~) in (z . 1) (z self) where B = (E, a)l \nas : B* X<:L&#38;,z : {1 : (X+B*), self : X} ((a./ + <(a: A)b))~ = open unfold(((a))~) in fold(A*, pack \nX <: with y . lj as X<:A*, y : Cr{X} A* = X := )(z : X)((b))~,r.~ : C~~z {X }) : A* ((clone(a)))~ = open \nunfold(((a))~) in (x clone)({}) where A = A4in7 y(E, as X<: a) A*, z : CP{X} ((let z : A =a in b))~ = \nlet 2: A* = ((a))E in ((b)) E,.,A type of an object. We take this true type to be the Self type; therefore, \nfor A -Obj(X)[L : B,{X} eln], we let: A = 3( X<: A*){1;C1 : X-+ B;{X} l , l;P 1 : (X+l?; {x})+x ~~1~, \nself : X} With this straightforward extension, our interpretation ac\u00adcounts for Self types. Structural \nRules While the subtyping rules for object types assert that a longer object type is a subtype of a shorter \nobject type, structural rules arise as consequence of the stronger struc\u00adtural assumption that the only \nsubtypes of an object type are longer object types. An example of such a structural rule, using the simple \nobject types of Obl<,, is the follow\u00ading modification of the rule (Val Update) of Table 8: (Struct Val \nUpdate) For A -[1,:B, elm] EEC<:A Eka:C E,x:Ckb:B, Et-a.lj~~(x:C)b:C  In our interpretation, structural \nassumptions on object types are reflected as structural assumptions on recursive types. Specifically, \nstructural rules for object types are vali\u00addated if we strengthen the target calculus with a structural \nrule for recursive types: (Struct VaJ Unfold) E t-C<: V(X)B{X} E E a :C E > unfold(a) : B{C} The rule \n(Struct Val Unfold) can be seen as a consequence of assuming that any subtype of a recursive type arises \nthrough the reflexivity rule ((Sub Refl) of Table 7) or the subtyping rule for recursive types ((Sub \nRet) of Table 9). For example, suppose that E F C<:p(X).B{X} because of (Sub Ret). Then C is of the form \nK(X) B {X} and if E k a : C then E k unfold(a) : B {C}. Further, we have that E, Y <: Top, X<:Y k B {X}<:B{Y}. \nIn particular, since E t-C< :C, using C for both X and Y we get that E t-B {C} <:B{C} and using subsumption \nwe get the con\u00adsequent of the rule (Struct Val Unfold). We can see informally how the rule (Struct Val \nUpdate) is validated thanks to (Struct Val Unfold). Assume that E 1-C*<:A* and E K ((a)) : C*. Using \nthe definition of A* as a recursive type and applying (Struct Val Unfold), we can conclude that: E + \nunfold(((a))) : 3( X<: C*){. ,l~i : (.. )+X,...} I,,><i The result of an update is of type C* , since \nlJ returns a result of type X and X<: C*. In contrast, with the weaker, non-structural rule (Val Unfold) \nof F< ,P (Table 9), we can conclude only that E t-unfold(((a))) : 3( X<: A*){. . .} and the result of \nthe update has to be given the weaker type A*. 5.2 An Enriched Object Calculus The calculus Ob ~ is an \nextension of Obl <, with variance annotations, Self types, and structural rules. Like the se\u00admantics \nof Obl<,, the semantics of Ob~ is free of side\u00adeffects. The types of Ob~ are generated by the grammar: \nA,B ::= X I Top I Obj(X)[l; vi : Bi{X} l n] where v, 6 {+, , }. As described in Section 5.1, Obj binds \nthe Self type, and the variance annotation v, specifies the operations permissible on method 1,. Table \n5: Operational Semantics of Ob~ If a - obj(X =A)[L =<(z, : X) b,{ X,z, } =l ], j = I...n (Eval Select) \nall - bj{A, a} (Eval Update) al, + (Y<: A , y : Y)<(z : Y)b{Y, y} N obj(X = A)[t, = <(z : X)b{X, a}, \nL = <(Z, : x) f)t + ~}-{ }] Because of Self types, the term syntax of Ob~ is slightly different from \nthat of Obl<.: An object has the form obj(X = A)[l. = <(z, : X)b, ~lm] with X standing for the Self type. \nMethod update is written a.1 s (Y<:A, y : Y)<(z : Y)b where A is a known type for a, Y denotes the Self \ntype of o,, ~ is bound to the object being updated (a), and z is the usual self parameter in method b, \nThe parameter y is useful because it is given type Y while a has the weaker type A, The typing rules \nfor Ob~ are structural. They appear in Appendix D. The operational semantics is defined via a reduction \nsys\u00adtem whose redexes are given in Table 5. In the rule for method update, note that the object a gets \nsubstituted for the parameter v. Apart from this, the only difference from the ~orrespond{ng riles of \nObl < is the type propagation the actual type of self gets substituted for the formal type parameter \nX standing for the Self type. We denote the many-step reduction relation for Ob~ by ., 5.3 Translation \nWe translate Ob~ into an extension F~!~ of F< P; this extension has the same operational semantics as \nF< ~ but includes a structural rule, namely the rule (Struct Val Un\u00adfold) of Section 5.1. The translation \nof types combines the ideas for variance annotations and for Self types described in Section 5.1   \nx =x TOD* = Tov p(Y)3(x<:Y){(Lv, : Bt{.Y})t ~l n ~ where the fields (l, v, : B;{X} )t are defined by \ncase analysis on the variance annotation v, as follows: (i: : B.{X})t = (l: : B,{ X})t, (l~ : B,{X})t \n~ We define the translation of environments as in Section 3.3, with the additional clause (E, X<: A)* \n= E*, X<: A*, The following theorem states that well-formed environ\u00adments are mapp~d to well-formed environments, \nthat well\u00adformed types are mapped to well-formed types, and that the translation preserves subtyping \njudgments, Theorem 5.1 1. IfE \\ o M dertvable an Ob~~, then E* k o M derivable in F< ~, and a forttort \nxn F~v. 2. If E + A w derwable in Ob ~, then E* + A* M dertv\u00adable tn I?<.P, and a forttorz in l?~ p. \n 3. If E E A<:B M dertvable an Ob~, then E* t A*<:B* is derivable tn F< ~, and a fortiori in lj~ p. \n We give the translation of terms in Table 6, using the following not ation: Notation: 1. For A -Obj \n(X)[l, vz : Bt{X}], we define: Cfi {x} : {(ttz/t : B.{x})f =1 ~, self : X} 2. For a type A, environment \nE, and method name 1, we define the Ob~~ type (A, E)l as follows. If A \u00adObj(X)[. . . ,lv : B{X},. . \n.], then (A, E)i is B{ X}. If A ~ X (a type variable) and E ~ E , X<: A , E , then (A, E)l is (A , E \n)t, In all other cases (e.g., for A E Top), (A, E)l is undefined, 3. As in Section 4.2, the type Min \nTy(E, a) is the mini\u00admum type of a in environment E, (We can prove that such a minimum type exists in \nOb~T , )  If we omit type annotations then the translation of terms is basically the same as that described \nfor Obl < The main novelty of the translation is that it shows that we can attach suitable type annotations \nto the untyped terms described in Section 3.3 so that well-typed terms of Ob~T get mapped to well-typed \nterms of F~!A. The following theorem states that the translation preserves typing judgments and com\u00ad \nputational behavior. Theorem 5.2 1. IfE \\ a : A ZS derzvable zn Ob~~ then E* K ((o,))~ : A* M derivable \nm F~W, 2. If E k a : A M dertvable an Ob ~ and a_O. b then ((a)).  f((b))E 404 Table 6: Translation \nof Ob~ into F~P ((Z))E = x ((obj(X = A)[l; = ~(q : X)b;{X} 6 ]))E = letrec create (jl : A*-B~{A*}) \n. . . (f. : A*~B~{A }) : A* = fold (A*, pack X<:A* = A* ~l~h {1:,1 = f, ,61.. ~, Z;pd = A(g : A*~B~{A*}) \ncreate (fl) . . ~ (.ft-1) (9) (ft+l) self = create (fl) (fn)} : C~{.Y}) in create (A(zl : A*)((bl{A}))~,Zl \nA) . . (~(a~ : A*)((b~. where A -Obj(X)[l, v, : B,{X} cl n] ((CZ.l))E = open UnfOld(((a))E) as .Y<:A*, \nz : {1 ( : (X--+ B*{X}), self : X} in (z 1 ~)(z . se~) : B*{ A*} where A = Mzn Ty(E, G), I?{X} = (A, \nE)l ((cz.1+ (Y<:A, y : Y)<(x : Y)b))~ = open unfold(((a))~) as X<: A*, z: {lUP(l : (x~B*{X})-X, self \n: X} where B = (A, E)l Conclusions We have presented a new interpretation of objects and ob\u00adject types \nthat preserves subt yping and behavior; its basic idea works for both functional and imperative semantics. \nOur interpretation is more general than previous solutions in that it handles object-based constructs \nsuch as cloning and method update, as well as the common class-based con\u00adstructs. Moreover, it is simpler \nthan other proposals in the sense of being syntax-directed. It is the first interpretation of this kind. \nOur interpretation offers insights into the nature of ob\u00adjects. It describes, in principle, a type-safe \nway of coding objects in procedural languages. However, as is the case even with more limited interpretations, \nit cannot be used in actual programming practice because of its pragmatic com\u00adplexity. This fact confirms \nthe commonly held belief that object-oriented languages differ significantly from procedu\u00adral languages \nin practical expressive power. References [AC94a] M. Abadi and Luca Cardelli A semantics of object types. \nIn Proceedings of the Ninth Annual Sympo \u00adsmm on Logzc m Computer Science, pages 332 341, July 1994. \n[AC94b] M. Abadi and Luca Cardelli. A theory of primitive objects: Untyped and first-order systems. In \nThe\u00adoTetzcal Aspects of ComputeT Software, pages 296 320. Springer-Verlag, April 1994. [AC95a] M. Abadi \nand L. Cardelh. An imperatwe object cal\u00adculus: Basic typing and soundness. In SIPL 95 Pvoceedzngs of \nthe Second ACM SIGPLAN Wovk \u00adshop on State in Programming Languages. Tech\u00adnical Report UIUCDCS-R-95-1900, \nDepartment of Computer Science, University of Illinois at Urbana-Champaign, January 1995. [AC95b] Martin \nAbadi and Luca Cardelli. An imperative ob-Ject calculus. In P D Mosses, M Nielsen, and MI. Schwartzbach, \neditors, TAPSOFT 95: Theory and Practice of Software Development, pages 471-485. Springer-Verlag LNCS \n915, May 1995 [ALBC+93] O. Agesen, C. Chambers L. Bak, B.W. Chang, U. Hoizle, J. Maloney, R.B. Smith, \nD. Ungar, an: M, Wolczko. The Self 3.0 programmer s ;eference manual. Sun Microsystems, 1993, [And92] \nB. Andersen. Ellie: a general, fine-grained, first\u00adclass, object-based language. Journal of Object Or\u00adiented \nProgramming, 5(2),35 42, 1992. [App93] Apple Computer, Inc. Apple, The NewtonScvipt Programming Language, \n1993. [Car88] L. Cardelli. A semantics of multiple inheritance. In\u00adformation and Computation, 76:138-164, \n1988, Spe\u00adcial issue devoted to Symp. on Semantics of Data Types, Sophia-Antipolis (France), 1984, [Car95] \nL. Cardelh. A language with distributed scope. In Conference Record of the Twenty-Second An\u00adnual ACM \nSymposium on Principles of Progr-am\u00adming Languages, 1995. [CO089] W.R. Cook. A Denotational Semantics \nof Inhe?+ tance. PhD thesis, Brown Umversity, 1989. [ESTZ95] J. Eifrig, S. Smith, V. Trifonov, and A. \nZwarico. An interpretation of typed 00P in a language with state Lzsp and Symbolic Computation, 1995. \nTo appear. [HP95] Martin Hofmann and Benjamin Pierce A unify\u00ading type-theoretic framework for objects \nJournal of Functional F wgrammtng, 1995. To appear. Previous version appeared in the Symposium on Theoretical \nAspects of Computer Science, 1994 (pages 251-262). [Kam88] S. Kamin. Inheritance in Smalltalk-80: a denota\u00adtional \ndefinition. In ACM Symp. Pnnczples of Pro\u00adgramming Languages, pages 80 87, 1988. [Lie81] H Lieberman. \nA preview of Actl. Technical Report AI Memo No 625, MIT, 1981. [MGV92] B.A Myers, D.A Giuse, and B. Vander \nZanden. Declarative programming in a prototype-instance 405 system: object-oriented programming without \nwrit\u00ading methods. In Proc. 00 PS.LA 92, pages 184 200, 1992. [MMPN93] O.L. Madsen, B. Moller-Pedersen, \nand K, Nygaard. Ob~ect-ortented programming in the Beta program\u00adming language Addison-Wesley, 1993 [MP88] \nJ.C. Mitchell and G.D. Plotkm. Abstract types have existential types, ACM Trans. on Programming Languages \nand Systems, 10(3):470 502, 1988. Pre\u00adliminary version appeared in Proc. 12th ACM Symp. on Principles \nof Programmmg Languages, 1985. [PT94] Benjamin C. Pierce and David N. Turner. Simple type-theoretic foundations \nfor object-oriented pro\u00adgramming. Journal of Functional Programming, 4(2):207-248, 1994. [R6m94] D. R6my. \nProgramming Objects with ML-ART, an extension to ML with Abstract and Record types. In Theoretical Aspects \nof Computer SoftwaTe Springer-Verlag, April 1994. [Tai92] A. Taivalsaari. Kevo, a prototype-based object\u00adoriented \nlanguage based on concatenation and mod\u00adule operations. Technical Report LACIR 92-02, Uni\u00adversity of \nVictoria, 1992. Appendix In this appendix we summarize several calculi, giving both grammars and rules. \nWe often use assertions of the form EFZ Vi~l . . . n to indicate n hypotheses; by convention, this means \nE 1-0 when n = O. A The Obl<. Calculus The calculus Obl<. consists of the rules given in Tables 7 and \n8. It has the following syntax: Environments E::= OIE, Z:A Types A,B ::= Top I [Zi : Bt El ] Variables \nX>Y Terms a,b ::= z I [L = s(2, :A)b, l ] I a.1 \\ a.1 + <(z :A)b Results v ::= [1, = <(at : A)b; e ] \n El The F<:P Calculus The calculus F<.P consists of the rules given in Tables 7 and 9. It has the following \nsyntax: Environments E ::= OIE, X: AI E, X<:A Type Variables X, Y Types A,B, C ::= X I Top \\ A--+B I \n{1, : B, e m} [ p(X)A I V(X<:A)B \\ 3( X<:A)B Variables X)Y Terms a,b,c, d ::= x I}(z :A)b Ia(b) I{1, \n= b, l n} Ia 1 I fold(A, b) I unfold(a) I A(X<:A)b I b(A) [ pack X<:A = C with b : B{X} lopencas X<: \nA,x:Bind:D Results ::= A(z : A)b I {li = bi 61 } v I fold(A, v) I J(X<:A)b I pack X<:A = C with b : B{X} \nOther definitions of the set of results could be adopted. The one given here is convenient for our adequacy \ntheorem; it is however not particularly compelling. Fortunately our techniques are not too sensitive \nto changes in the definition of the set of results. C The Imperative Variant of Obl<, The typed imperative \nobject calculus contains all the rules of Obl<. (described in Appendix A) and contains the typ\u00ading rules \ngiven in Table 10 for its additional terms. As for Obl <., we can prove a minimum-types property for \nthe typed imperative calculus. (This is a convenient departure from the original calculus of [AC95a]: \nthe terms described here contain more type information. ) The syntax is: Environments E::= OIE, Z:A Types \nA,B ::= TOp I [t, : B, =ln] Variables X)Y Terms a,b ::= z \\ [~i = S(Z, :A)b, l ] Ia.1 Ia.1 + <(z :A)b \nI clone(a) lletc:A=ainb D The Ob$ Calculus The calculus Ob~ consists of the rules given in Table 7, \nthe rules (Env X), (Type X), (Sub X) given in Table 9, and the rules of Table 11. It has the following \nsyntax: Environments E ::= O\\ E, X: AI E, X<:A Type Variables X, Y Types A,B ::= X I Top I Obj(X)[l,v, \n: B, ln] with v, ~ {+, ,0} Variables X>Y Terms a,b ::= z I obj(X=A)[l, =q(z, :X)b, sl n] 1 U,.1 I al&#38; \n(Y<A,y : Y)<(z : Y)b 406 Table 7: Common Typing Rules Environments Subtyping EkA Ek A<:B El- B<:C (Sub \nRefl) EkA<:A (Sub Trans) EI-A<:C Eka:A EkA<:B (Val Subsmp) Eka:B Top (Type Top) E~ET~p (Sub TOP) E hEA~T.p \n Table 8: Additional Typing Rules for Obl < 407 Table 9: Additional Typing Rules for F< ~ Types E , X<:A, \nE b O (Type X) (Type +) E , X<:A, E k X EFB, Vi C1. ..n (Type Record) (Type Ret)Et-{1, : B, =l n} E, \nX<:AFB (Type All) (Type Exists) E + V(X<:A)B Subtyping E , X<:A, E 1-0 Et-A <:A Ek B<:B (Sub X) (Sub \n+)E , X<:A, E k X<A E # A* B<: A ~B EkB, <:B~, di~l. ,,n EkB~, Vi En+l. ..n+m (Sub Record) E+ {1, : B, \n1 n+ }<:{1, : B; e n} E ~ p(X)A E + w(Y)B E, Y<: Top, X<:Y t-A<:B (Sub Ret) E + K(X) A<:p(Y)B EkA <:A \nE) X<.A E B<:B E k A<:A E, X<:A K B<:B (Sub All) (Sub Exists)E t-V(X<:A)B<:V(X<: A )B E t-3( X<: A) B<:3(X<:A \n)B Term Typings E,x:Akb:B E+ b:A+B Eka:A(Val Fun) (Val Appl) E + ~(X : A)b A-+B E+ b(a):B Ekb, :B, Viel. \n,,n (Val Record) E&#38; {1, = b% El n} : {1, :B, = } Eba:{l, :B, =l } (Val Record Select) Ekall:BJ \n g~ n E+ b: B{A} (Val Fold) E + fold(A, b) :A A - ( X)B{X} EFb:A (Val Unfold) E + unfold(b) : B{A} \n A + ~( Y)B{x} E, X<: Akb:B E+ b :V(X<:A)B E+ A <:A (Val Fun2) (Val App12) E h A(X<:A)IJ : V(X<:A)B \nE!-b(A ) : B{ A } E F C<:A E 1-b{C} :B{ C } (Val Pack) E 1-pack X<:A = C with b{X} : B{ A } : 3( X<: \nA)B{X} E\\c:3(X<:A)B EFD E, X<: A,x:Bkd:D (Val Open) E+(open .as X<: A,x. Bind: D): D Table 10: Additional \nTyping Rules for the Imperative Calculus 408 Table 11: Additional Typing Rules for Ob~ Variance Subtypings \no (Sub Covariant) E K ~~~ B<~+>\\O } (Sub Contravariant) E E ~~ ~B<~_>\\ } EFB (Sub Invariant) E t- l?<: \nB Object Types and Subtyping E, X<: Topt-B, {X} Viel... n + , 0}, B, ~ovariant in x (Type Object) Z \nie{,E + Obj(X)[l;vi : B~ e n] (Sub Object) For A = Obj(X)[tiv; : B;{X} G +m], A = Obj(X)[t,v: : B:{X} \ne ] E, Y<:A 1-v, B,{ Y}<:v(B~{Y} Vi c 1.. .n E t-A<:A Term Typings E)z, :A1-b,{A}:B, {A} Vi~l... n \n(Val Object) A = Obj(X)[Lv, : B,{X} ~ln] E K obj(x = A)[l, = f(z, : X)bt{X} 61 ] : A (Struct Val Select) \nFor A = Obj(X)[Lv, : 13{X} 1 ], v, G $+~o~<:fi,l . . . n E!-a:A E t-a.l$ : Bj{A} (Struct Val Update) \nFor A = Obj(X)[Lv, : B,{X} G n],v, ~ {-, o}, j E 1.. .n Eka:A EHA<:A E, Y<: A,y:Y, z: Y+ b: Bj{Y} E E \nal, @ (Y<:A, y :Y)r(z :Y)b :A  \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Mart&#237;n Abadi", "author_profile_id": "81100547147", "affiliation": "Digital Systems Research Center, 130 Lytton Avenue, Palo Alto, California", "person_id": "PP39047996", "email_address": "", "orcid_id": ""}, {"name": "Luca Cardelli", "author_profile_id": "81100123805", "affiliation": "Digital Systems Research Center, 130 Lytton Avenue, Palo Alto, California", "person_id": "PP39028545", "email_address": "", "orcid_id": ""}, {"name": "Ramesh Viswanathan", "author_profile_id": "81100159127", "affiliation": "Isaac Newton Institute for Mathematical Sciences, 20 Clarkson Road, Cambridge, CB3 0EH, U.K.", "person_id": "PP14065569", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237809", "year": "1996", "article_id": "237809", "conference": "POPL", "title": "An interpretation of objects and object types", "url": "http://dl.acm.org/citation.cfm?id=237809"}