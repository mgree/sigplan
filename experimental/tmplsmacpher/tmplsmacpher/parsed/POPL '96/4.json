{"article_publication_date": "01-01-1996", "fulltext": "\n Putting Type Annotations to Work Martin Odersky Konstantin Laufer Department of Computer Science Department \nof Mathematical Sciences University of Karlsruhe Loyola University Chicago 76128 Karlsruhe, Germany Chicago, \nIllinois 60626, USA odersky@ira.uka. de laufer@math.luc. edu Abstract We study an extension of the Hindley/Milner \nsystem with explicit type scheme annotations and type decla\u00ad rations. The system can express polymorphic \nfunction arguments, user-defined data types with abstract com\u00ad ponents, and structure types with polymorphic \nfields. More generally, all programs of the polymorphic lambda calculus can be encoded by a translation \nbetween typ\u00ad ing derivations. We show that type reconstruction in this system can be reduced to the decidable \nproblem of first-order unification under a mixed prefix. Introduction Two of the most important cornerstones \nof type theory for programming languages are the Hindley/Milner sys\u00adtem and the second-order polymorphic \nA-calculus. This paper tries to explore some of the design space between them. The Hindley/Milner system \n[hIi178] extends the simply-typed A-calculus with polymorphic let-bound identifiers. It thus adds considerable \nexpressive power yet retains the property that no type annotations in programs are needed, since most \ngeneral types can be inferred [DM82]. This property has made the Hind\u00adley/Milner system very appealing \nas a basis of type systems for programming languages. By contrast, the second-order polymorphic A\u00adcalculus \nF2 [C,ir71, Rey74] allows polymorphic types everywhere, but requires explicit annotations of both argument \ntypes and type instantiations. The general problem of typechecking without type annotations is undecidable \n[We194], but there have been several ap\u00ad proaches towards type reconstruction where some type information \nis given. These generally fall into two cat- Permission to make digital/hard copies of all or part of \nthis material for personal or classroom use is granted without fee provided that the copies are not made \nor dktributed for profit or commercial advantage, the copy\u00ad right notice, the title of the publication \nand its date appear, and notice is given that copyright is by permission of the ACM, Inc. To copy otherwise, \nto republisb, to post on servers or to redistribute to lists, requires specific permission and/or fee. \nPOPL 96, St. Petersburg FLA USA @ 1996 ACM 0-89791..769.3/95/01. .$3.50 egories. Curry-style reconstruction \nfills in polymorphic abstractions and applications together with type an\u00adnotations. This style of reconstruction \nis complicated by the lack of principal types in F2. The proposed schemes all have rather complex inference \nrules with cumbersome conversions between declared and inferred types [McC84, 0G89]. By contrast, Church-style \nre\u00adconstruction requires the position of type abstractions and applications to be indicated in the original \nsource. This style of reconstruction (also called partial type reconstruction [Boe89]) was shown to be \nreducible to higher-order unification [Pfe88]. Even though Church\u00adstyle reconstruction is thus undecidable \nin general, this result opens up the possibility for semi-decision proce\u00addures that work well in practice. \nOn the other hand, the position of a polymorphic application has to be in\u00addicated explicitly in the source, \nwhich leads to a rather unfamiliar coding style, at least for programmers used to the Hindley/Milner \nsystem. Recently there have been several approaches towards extending the Hindley/Milner system with \nsome form of embedded quantifiers without going all the way to the polymorphic ~-calculus. For instance, \nLaunch\u00adbury and Peyton Jones have presented an elegant type system for syntactic control of interference \n[LPar] that uses second-order universal quantification. Perry [Per90] and Laufer and Odersky [L094] have \nstudied existential quantification in algebraic datatypes, which yields a Hindley/Milner style version \nof Mitchell and Plotkin s abstract types [M P88]. This style of existen\u00adtial quantification has been \nimplemented in compilers for Hope [Per90], Haskell [Aug94] and CAML [MP93]. R6my [R6m94] has extended \nLaufer and Odersky s sys\u00adtem with universal quantification in datatypes, so that objects with polymorphic \nmethods can be expressed. Jones [Jon95] has investigated record types with poly\u00admorphic elements as a \nway to capture essential aspects of module systems. A proposal along these lines has been accepted for \ninclusion in Haskell 1.3. It, seems that a combination of all of the above sys\u00adtems, while feasible, \nwould be rather unwieldy, Fortun\u00adately, it turns out that it is good enough to consider as a generalization \na far simpler type system that captures the extensions commonalities and expresses their dif\u00adferences \nvia encodings. The extensions all have in com\u00admon that some form of explicit type information is re\u00adquired. \nFor instance, Laufer and Odersky s and R6my s systems restrict existential quantification to the com\u00adponents \nof explicitly declared datatypes, while Jones restricts universal quantification to fields of explicitly \ndeclared record types. Here we study a type system that allows (but does not require) explicit type scheme \nannotations for func\u00adtion arguments. The idea is that a formal function pa\u00adrameter is polymorphic only \nif annotated with a type scheme; otherwise the parameter is monomorphic, i.e. it has a type, not a type \nscheme, As an important special case we admit a rudimentary form of user-defined data type declaration \nthat introduces a value constructor with a single, possibly polymorphic argument. Finally, we also allow \ntype scheme annotations for expressions. Note that this is roughly the kind of type annota\u00adtions that \nmost programming languages offer or require. The crucial extension of this paper is that annotations \nand declarations can refer to polymorphic type schemes instead of just types. The ramifications of this \nsimple idea are quite substantial. We can express polymorphic function arguments by annotating the argument \nwith a type scheme, We can express data types and record types by their usual Church encodings in a type-correct \nway. By slightly modifying these Church encodings, we can also express existentially or universally quan\u00adtified \ncomponent types of records and data types, thereby subsuming the type systems of Perry, Laufer and Odersky, \nR6my, and Jones. The en\u00adcodings give us principal type properties and type inference algorithms for these \nsystems for free . Unlike the situation in the simply typed A-calculus [Mor68] or ML [Mi178], it is no \nlonger possible to reduce type inference to a simple Herbrand uni\u00adfication problem. We need to consider \ninstead the problem of finding a most general substitution that makes one type scheme an instance of \nan\u00adother. We show here that this problem is reducible to the problem of first-order unification under \na mixed prefix [Mi192], which is decidable. Decid\u00adability holds because we still admit only types and \nnot type schemes in the range of substitutions otherwise the problem would be equivalent to semi-unification, \nwhich is undecidable [KTU89]. Unlike the situation in F2, we still maintain a stratification between \ntypes and type schemes. A universally quantified variable can be instantiated only to types, never to \ntype schemes. We get back the full power of F2 in an indirect way, by allowing type schemes as components \nof explicitly declared data types. We show that we can encode all of F2 by providing type declarations \nfor all polymorphic types in a given F2 program. This shows that our typing discipline provides essentially \nthe same ca\u00adpabilities as Fp, even though the encoding in Fp does not support a formal comparison of \nexpres\u00adsive power in the sense of Felleisen [Fe190] since it fails to be compositional. Our typing discipline \nis a conservative extension of the Hindley/Milner system. Every typable program in that system continues \nto be typable. This holds also if type annotations in the style of ML or Haskell are added to Hindley/Milner. \nWe were able to show principal type properties and soundness and completeness of type inference fully \nanalogous to the results stated by Damas and Milner [DM82]. Since the engineering issues of ML-like programming \nlanguages and type checkers are by now well understood, we believe that this makes our system promising \nas a practical kernel language on which type-systematic extensions of ML or Haskell can be based. The \nrest of this paper is organized as follows. Sec\u00adtion 2 presents our type system. Section 3 shows how \nprevious polymorphic extensions of ML can be em\u00adbedded in it. Section 4 discusses an encoding of the \npolymorphic A-calculus. Section 5 states the most gen\u00aderal instantiation problem and presents an algorithm \nto solve it. Section 6 presents a type inference algorithm. Section 7 concludes. 2 The Type System Figure \n1 presents the abstract syntax of our kernel lan\u00adguage, Exp: cr. As in the Hindley/Milner system, we \ndistinguish between types, which cannot contain quan\u00adtification over type variables, and type schemes, \nwhich can. Compared to Milner s language Exp there are two extensions that can be considered independently, \nbut that are most useful in combination. One extension considers type annotations for formal arguments \nand expressions; the other considers type declarations. Type Scheme Annotations Type scheme annotations \ncan be applied to formal ar\u00adguments in A-abstractions k: a.e and to expressions e: u. Annotations with \ntypes are common in program\u00adming languages that build on the Hindley/Milner sys\u00adtem. For instance, map \n= Af: a --+ b. ~xs: [a] case xs of ,.. declares the argument types of function map in terms of two type \nvariables a and b. By generalizing over these Variables xlYl~ Type Constructors T Expressions e .zl Ax. \ne~ee lletx=ein e Exp terms ~ Ax:a.el e:u annotated terms IT type injection , T-1 type projection I newtype \nT al . . . CYn = a in e type declaration Type variables ~l~>y Types T CYIT1+T2 lTrl. ..rn Type schemes \nU = Tlal+azlb a. a Figure 1: Abstract syntax. Figure 2: Instance rules for type schemes. (Taut) r,x:utx:a \nI , T:~t-T:cr I t-T:~-TF rtT-l:T?--+u (Proj) (Gen) r h rt~:v~.u e: o (a ~ftv(r)) I t-e:O 111-e:d t-c7 \n<(T (Sub) (Lambda) r. rz.x:rbe:ff t-~x.e:~+a I te:c-+d I kee :d I t-.e :a (Apply) (TypedLambda) rt-(e:a):a \n(Typed) (Let) I . te:u rx.x:u I cl-let.z=eine :d F-e :u rT,T: d7Z.c4TZ rT t newtype &#38; TE=uine:cr \n e:u (Newtype) Figure 3: Typing rules. type variables we then obtain the usual polymorphic type scheme \nfor map: map: Va.Vb.(a + b) + [a] + [b]. What is new here is the ability to annotate with type schemes \ninstead of types. For instance, it is now possi\u00adble to write f [g: vC.[c] + Int) = g [ hello ] ~ g [1,2]. \nAs a consequence, a type scheme may now form part of a larger type scheme. For instance, f s most general \ntype scheme would be (Vc.[c] + Int) + Int. We therefore have to give up Hindley/Milner s restric\u00adtion \nthat quantifiers may occur only at the outermost level of a type scheme and have to admit type schemes \nsuch as al -+ UZ. An immediate consequence is that we have to refine the generic instance relation [DM82] \nif we want to get principal types for the system with annotations. Consider the function Ax: Int. [ ]. \nTwo derivable type schemes for this function are Va.lnt + [a] and Int + Va.[a]. None of these type schemes \nis a generic instance of the other. Furthermore, there is no third type scheme that has both of these \ntype schemes as generic instances. But using the relation (<) defined in Figure 2, we get Int + Va. [a] \nas the more general of both type schemes. The relation (<) implements a form of subtyping for type schemes. \nRule [V <) together with subsumption is equivalent to the quantifier elimination rule of the Hindley/Milner \nsystem. Rule (< V) allows us to re\u00adquantify a type scheme. Functions over type schemes are handled by \nthe standard contravariance rule (+). As usual, we identify type schemes that are instances of each other. \nThe relation (~) is a subrelation of Mitchell s con\u00ad tainment relation [Mit90] and hence is validated \nby all type inference models. For type schemes that have quantifiers only at the outermost level, (<) \nis the in\u00ad verse of the generic instance relation given by Damas and Milner [D M82], We changed the direction \nof (<) sign to stay in line with Mitchell s containment relation, which corresponds to the semantic intuition \nof subtyp\u00ad ing as set inclusion. (<) has the following useful properties. Proposition 2.1 Let a and a \nbe type schemes and let 0 be a substitution. If !--a < &#38; then t-Oa < 19a . Proposition 2.2 (<) is \ntransitive. Proof Sketch: Assume that al ~ uz and D2 < U3. We show al < U3 by an induction on the sum \nof the depths of the proof trees for cl < az and Oz < ma. Proposi\u00adtion 2.1 is used for the case where \nthe last rule in the proof of al < CTZ is an application of rule (< Y). 0 The typing rules, given in \nFigure 3, largely follow the Hindley/Milner system. The two main differences are both motivated by the \npossible occurrence of quanti\u00adfiers at all levels in a type scheme. First, it is necessary to consider \ntype schemes instead of types in the con\u00adclusion of each typing rule, since type schemes cannot always \nbe reconstructed using generalization at the out\u00adermost level. Second, Hindley/Milner s elimination rule \nfor outermost quantifiers is replaced by a more general subsumption rule, which takes into account the \ninstance relation (<) on type schemes. Type annotations alone are sufficient for expressing polymorphic \nfunction arguments. But one shortcoming of this system remains: the resulting second-order poly\u00admorphic \nfunctions cannot be arguments of polymorphic functions themselves, since this would require an in\u00adstantiation \nof a type variable to a type scheme. For instance, the following code would not be type-correct: map \nf [length, const O]. The problem is that the type variable a in map s type cannot be instantiated to \nthe type scheme Vc. [c]+lnt. We circumvent this problem by providing a way to package a type scheme in \nan explicitly declared data type. Type Declarations A type declaration newtype T al . . . an = u in e \ncor\u00ad responds to a simple form of an algebraic data type declaration with a single unary constructor. \nEach type TT1 . . . ~,z thus introduced is different from [r;/ai]a. The type constructor T may be used \nanywhere, includ\u00ad ing in the type scheme LT. We require that every type constructor is declared at most \nonce in a program (this is not enforced by the typing rules). We often use the shorthand @ or T for vectors \nof type variables or types. A similar declaration in Haskell would be data T al . . an = T elemtype. \nWe generalize Haskell in that elemtype may be an arbi\u00ad trary type scheme instead of a type. The Haskell \nsyntax above makes explicit our con\u00advention that T doubles up as an injection function that maps values \nof the component type to values of type T 7. For every new type constructor T there is also a projection \nfunction T-1, which is an inverse of the in\u00adjection T. By contrast, projection in HaskeH is implicit \nin the meaning of case expressions. Instead of Haskell s case tof Tx+e we would write letx= T-l tine. \nWith the help of type declarations we can now code our problematic example as follows. newtype List Fun \n= VC. [C] + Int in let fg = let g = ListFun-l g in g [ hello ] -F g [1,2] in map f [ListFun length, ListFun \n(const O)]. But much more is possible. For once, newtype declara\u00adtions are sufficient to express data \ntypes with general products and sums by their usual Church encodings, combined with explicit injection \nand projection opera\u00adtions. For instance, the type of pairs with a constructor mkpair and selectors fst \nand snd would be coded as fol\u00adlows. newtype Pair a b = b c. (a + b ---+c) -+ c in let mkpair xy= Pair \nAk.k xy in let fst p = Pair-l p Ax. Ay.x in let snd p = Pair-l p Ax.Ay.y in Note that the Pair type expands \ninto a type scheme, not a type. Therefore, we could not apply the same tech\u00adnique in languages like ML \nor Haskell, which admit only types on the right hand sides of data type declarations. A second example \nencodes the list type, using the List type constructor recursively. newtype List a = Vb. b -+ (a -J List \na ---+b) + b in let nil = List An. Ac. n inlet cons xxs = List AnAccxxs in A case expression like case \nxs of { nil * e] lconsyysae~} would then be coded as List-l xs el Ay, Ays.e2. Of course, in an actual \nprogramming language we would assume that product and sum types are defin\u00adable directly, without the \nneed for Church encodings. The existence of the encodings ensures in this case that the additional language \nconstructs require no essential additions to the type system after all, we could typecheck by encoding \nfirst and then using our kernel language. In the next section, we apply this program to some polymorphic \nextensions of the Hindley/Milner system. ~ Extensions In this section, we show how some previous exten\u00adsions \nof Hindley/Milner with embedded quantifiers can be expressed in our system. In particular, we deal with \nLaufer and Odersky s version of abstract types [L094] and with Jones s version of polymorphic struc\u00adtures \n[Jon95]. A system equivalent in expressiveness to R6my s [R6m94] can then be obtained by combining both \nextensions. Abstract Types We consider a set of global data type declarations data DE = /ilrl I.. .lknrn \n(1) Here D is a data type constructor, and kl, . . . . k~ are value constructors. Conceptually, a data \ntype construc\u00adtor is a special instance of a type constructor T, whereas value constructors k form a \nseparate alphabet. As in [L094] we adopt the convention that any type variables in one of the ri that \ndo not appear in @ are existentially quantified. By contrast, in ML or Haskell such type variables would \nbe disallowed. Example 3.1 The following declares a type of lists with heterogeneous elements. Each element \nconsists of some value and a function that maps this value to an integer key. The type of the value may \nvary from element to element. data KeyList = KNil \\ KCons ((a, a + Int), Key List) A function that finds \nthe maximal key can then be written as follows: maxkey xs = case xs of { KNil ~ minint I KCons ((y, f), \nys) ~ f y maxi maxkey ys } Slightly modifying our treatment of lists in the last sec\u00adtion, this program \nis translated into Exp: u as follows. newtype Key List = Vb. b--+ (b a.((a, a-+lnt), Key List) + b) -+ \nb in let KNil = KeyList An, }c: Va.((a, a+lnt), Key List) + b n in let KCons x xs = KeyList An.Ac: da \n((a, a+lnt), Key List) --+ b, c (x, XS) in let maxkey xs = Key List-lxs minint A((y, f), ys).f y max \nmaxkey ys Note that the implied existential quantifier for the type variable a in the definition of Key \nList turns into a second rank universal quantifier in Key List s translation. For the general case we \naugment our kernel language Ezp: c with value constructors and case expressions. e .. .. . . . [k I caseeof \n{k~z~ *e, ] . ..lknzn *en} Let Exp: c+3 be the term-language thus defined. Given a data type declaration \n(1), let /3, = ftv(~l )\\~ for i = 1,....n. Then the following typing rules are equivalent to the treatment \nin [L094]. (AbsI) r t-ki:VE.Vz.~i+D~ (i=l, . . ..n) rt-e:DT r f k,: ~~.T~ + DT (i=l, . . ..n) (AbsE) \nr F ~xi.ei : d~.~~ + ~ ftv(7-) n~ = 0 I t-case eof{klzl +ell. ..lknzn *en}:~ Let t-= be the relation \nthat results from adding these rules to those in Figure 3. We now give an encoding (=) of Exp: c+3 in \nEzp: a that preserves typability. For the constructors and case expressions that correspond to a data \ntype declaration (1), we define: k? = ii (i=l, ....n) where each ki is a new variable, case eof {klzl \n+ el I., .Iknxn s en}q = ~- e= (Azl.e~) . . . (Azn.e~). We extend (3) homomorphically to all other expres\u00adsions. \nFinally, we add for every data type declaration of form (1) the global declarations below, where ~ is \na fresh type variable. newtype D @ = Vy. (V~. rl y) + ...+ (v~.7-n + ~) + -y in let k, = Ax. D (Ayl:V~l. \nrl -~. ... . Ayn: v~.7n + -(.yiz) (i=l, . . ..n) Then we have: Proposition 3.2 For all typotheses r, \nterms e and type schemes u k Exp: u+ 3, rl-3e:0@1 1-e3: cr. Proof: An easy comparison of typing derivations. \n0 Polymorphic Structures An analogous treatment lets us encode structures with polymorphic fields in \nExp: u. Consider a set of global structure declarations struct S E = {11:7-1, . ..n.Tn}n} (2) Here, \nS is a type constructor, and 11, . . . . in are field labels. To keep the treatment simple, we assume \nthat every label 1 occurs in at most one structure type dec\u00adlaration; hence structures do not have scopes \nof their own. A more flexible scheme, in which a label could be part of several structures, would be \nobtained by adding overloading to our type system [Jon92, 0WW95]. In symmetry with our treatment of data \ntypes, we now adopt the convention that any type variables in one of the Ti that do not appear in a are \nuniversally quantified. Example 3.3 We define a type for set objects that contain as a field a polymorphic \nmap function. struct Set a= { elem :a+ Bool, union :Set a+ Set a, map : (a -b)+ Setb} Note that the type \nvariable b in map s signature does not appear on the left-hand side of the definition, and hence is considered \nto be universally quantified. This structure declaration could be expressed in Exp: a as follows. newtype \nSet a = Vc.Vb. ((a + Bool) + (Set a+ Set a) \u00ad((a + b)+ Setb)+ c) + c, More generally, let the term language \nExp: m +V be obtained by adding structure expressions and selector functions to Exp: u. .._ e .. . . \n. /{ll=el, . . ..ln=en}l#l Given a structure type declara~on (2), we add the following typing rules, \nwhere /3i = ftv(~i )\\E (i = 1,.. ., n). (PolyI) 17 + #ii : VE.S E + VT.Ti (i=l, . . ..n) r t ei : V~.T[ \n(i=l, . . ..n) (PolyE) r F #li : S ~ -+ V~.~; (i=l, . . ..n) I F{tl= el, . . ..ln=en}. ST Let t-v be \nthe relation that results from adding these rules to those in Figure 3. To encode Exp: u+V in Exp: u, \ndefine for every data type of form (2): (#li)v = ~ where each &#38; is a new variable, {ll=el, . . ..ln=en}v \n= S (Ak.k e; ... e:) Extend (v) homomorphically to all other expressions and add for every declaration \n(2) the global declarations newtype SE= Vy.VZ. ..3/(.. ( fl +.. .+rn + Y+Y in let ~ = Az. S l z (Ayl. \n... Ayn. y~) Then the following proposition is shown by a compari\u00ad son of typing derivations. Proposition \n3.4 For all typotheses r, terms e and type schemes m in 12cp: a +V, rtve:cr+rk~v:m. Discussion. One \nshort coming of the presented en\u00adcodings is that the component types of data types and structures can \nhave only one layer of quantifiers. The encodings share this property with the original propos\u00adals of \nLaufer and Odersky and Jones, but not with R&#38;my s system. A more powerful type system would admit \narbitrary type schemes for the components. This would present no problems for data types, hence R6my \ns system could be expressed by a straightforward combi\u00adnation of our encodings for data types and structures. \nBut an analogous generalization would not work for structure types, since there the result of a selection \nis captured in a type variable, and therefore needs to have a type without quantifiers. (Of course, it \nis pos\u00adsible to re-quantify at the outermost level after the se\u00adlection). Data types suffer a different \nshortcoming albeit for a similar reason in that each branch in a case-expression needs to have a type \nwithout quanti\u00adfiers. It is possible to lift both restrictions by considering product and sum types in \nthe kernel language, with a ranging over u ::= Tlc7+cTlaxa~c7+al VO!. (7 Alternatively, one can also \nwork around the restrictions by inventing intermediate data and structure types for each level of quantification. \n4 Encoding F2 In this section we present a translation of the second order polymorphic A-calculus F2 \ninto our typing disci\u00ad pline. F2 is given by the typing rules below. r,z:at~z:a (Taut) r,x:utFh4:u (+1) \nr EF ~x:a. A4:a+u rtpivf:u -+tr rtFN:u (+E) rl-Fh !l N:fl rl-FM:cJ (W) (~ ~ftv(r)) r tF Aa.Nl ; da.u \n The crucial idea of the translation of F2 into our typ\u00ading discipline is that a polymorphic F2 type \nVa .U is mapped to a data type T+ 71 r. where the type constructor Tti is indexed by an n-ary type abstraction \n~and(~, rl). ..rnrn ) is the a-lifting of a s translation: Definition. The a-lifting of a type ~ consists \nof an n\u00adary type abstraction + and types ~1, . ., ~~ such that @ rl Tn = r and TI, . . . . rn are maximal \nsubterms of T that do not contain a. We write in this case We arrange such that for every translated \ntype (Va.a)* the translation contains a global type declaration newtype T@~l . . . /3n = VCr.Q+IJ~l . \n. . On. where lifts u* = (~, . . .). For simplicity, we avoid variable renamings by as\u00adsuming that all \ntype variables in the F2 source are mu\u00adtually distinct. The encoding of F2 types is then given by: O!* \n=c1 (0-, + c,) = (r; -+ (7; (Va.a) = Tti T1. ..Tn where lifts a = (~,~1, . . . . ~n). This encoding \nis stable under substitutions, as is shown in the following lemma. Lemma 4.1 For all F2 types al, U2, \ntype variables a, ([u,/cl]o-,)* = [cT;/cY]c7; Proof: By induction on the structure of az. The case uz \n= Va .aj relies on the observation that if then lifts 6 7_ = (q!J, &#38;rl, . . . . 6 7_n), for any substitution \n0 that does not involve a. 0 We extend (*) pointwise to type environments, defh\u00ading {xi : O-,}* = {x, \n:a$}. We now address the encoding of F2 terms. Since this encoding depends on both a term and its type, \nwhich in turn depends on a type environment, we formulate (*) as a mapping from F2 s typing rules for \ntype judgments r t-F Al : a to a different set of typing rules for type judgments r t* A&#38; : u*. We \nwill then show in a second step that each t-* rule is valid as a 1\u00adderivation in an augmented environment. \nRules (Taut), (+1) and (@E) are mapped by (*) to identical rules with F* instead of hF . For the remaining \ntwo rules, we define: ma CT == (7/! ,71, . . . . Tn) ~ ~ftv(r*) (VI)* = r*t*N:u* Jiftau =( L!J, ~l, . \n. . . rn] (VE)* = r k N:T$T1...rn  r* I-* ~; N (d) : [(d)*/a]o* In rule (VE), the type argument [a] \nis translated to a representative (u), which is a term with type a . The mapping (.) from F2 types to \nrepresentatives is defined below. Definition. Given a type scheme U, let A. = {za :a I a eftv(a)}. Analogously \nfor an F2 term M, let AM = {za :a I a eftv(M)}. Finally, for an F2 derivation D with conclusion I h A4 \n: a, let &#38; be the set of all polymorphic types of form Va.a occurring in the environment or type \npart of a typing judgment in D. Then the type environment AD is given by Informally, Av contains a binding \nXa : a for every free variable CY in o, and it contains for every poly\u00admorphic type in the derivation \nD a corresponding type constructor T+. Av can be produced by a Exp: u con\u00adtext that consists of a series \nof type declarations of the form newtype T+ ,f31 . . . p. =va.a--+qJ,Bl . .. /3.. followed by a series \nof A-abstractions of the form ~Za : 0!. Lemma 4.2 A. 1-(o) : a Proof: Directly from the definition of \n(.). 0 The following proposition is shown by a straightfor\u00adward induction on tF derivations. Proposition \n4.3 Let D be a typing derivation in F2 with conclusion 17 tF ill : a. Then there exists a unique term \nAl and a t* -Proof with structure D that concludes with r*, A~ t-* M* :g . It remains to be shown that \neach D* derivation can be completed to a valid Exp: u derivation. To show this, we need a standard property \nof Ezp: u, namely that type derivations are invariant under weakening and additions of hypotheses. This \nis stated in the following lemma, which is shown by a straightforward induction on typing derivations. \nLemma 4.4 Ifx+fv(e) then r,z:CJ R e:uiff I 1-e:u. Theorem 4.5 If r FF &#38;f : ~ by an F2 derivation \nD then I *, AD ~ M* :u*. Proof: By an induction on the structure of D. If the last step in the proof \nis an application of a (Taut) rule, the result follows immediately. If it is one of (-+1) or (--+ E), \nthe result follows by a simple inductive step. Assume now that the proof consists of a derivation D of \n17 i-r A4 : a, followed by an application of rule rkFiw:g (VI) (a +ftv(r)). r IF Aa.M :Va.o By the induction \nhypothesis, 17 , AD) FF Al* : u*. Let A = An/\\{xa : a}. Assume first that a c ftv(kf). Then AD, contains \na binding Za : CY. By rule (Lambda), r*, A 1-Axa:a.M*: cl-c*. (3) On the other hand, if a + ftv(lll), \n(3) follows from the induction hypothesis, rule (Lambda), and Lemma 4.4. Then by rule (Gen), since CYis \nfree in r , A , r , A k Axa: Q .M* : VO!. CY+ V*. (4) Furthermore, AD contains both A and the binding \nIt follows by rules (Taut), (Sub) that It also follows from (4) and Lemma 4.4 that r , AD t Axa : CY.M* \n: Vo!. ck+ U*. (7) Since CT* = 4 F by assumption, the case then follows from (6), (7) and an application \nof (App). Assume finally that the proof D consists of a deriva\u00adtion D of r I-F Ll : a, followed by an \napplication of rule r tF h4: v~.fl (VE) r p? ~[a(] : [a /a]~ By the induction hypothesis, I *, An, F \nIll : (Va.u)*, where (Va.a) = T+ T, for some type constructor T@ such that * F = u and D contains the \nbinding Then by (Taut), (Proj) and (Sub): r*, AD/ 1-T;l :T$ T~VcY. (cY~o-*). (9) By rule (App), r*, \nAD/ E T;l M* : Va. (cY + c*). (10) Then by rule (Sub), r , A~J R T;l M* : (a ) + [(a ) */a]a*. (11) \nSince An ~ An, it follows with Lemma 4.4 that I *, An t\u00ad T~l A4* : (o )* ~ [(a ) */cY]u*. (12) Furthermore, \nsince Av ~ AO, Lemma 4.2 with Lemma 4.4 implies that r*, AD } ((7 ) : (a ) . (13) Then by (12), (13) \nand rule (App), r*,Av k T~~ M* (a ) : [(a ) */a]a . (14) Finally with Lemma 4.1, r*,AD t- Tjl Al (u \n) : ([a /a]o)*, (15) which proves the case. 0 Example 4.6 Consider the successor function on Church-numerals \n n = Acx.J~ : a + CY.~X : CY.fn X, which is given by: Succ : (Va!.(a+ a) + cl! --+ a) -+ d/3. (/3+p)+/8+p \nSucc = Am: v a.(a + ~) + o + CY. A/3.,Xf ; ~ + ~.~X: ~. m[~] f (f x). The liftings of SUCC S argument \nand result type schemes with respect to their quantified type variables are: liftaya.(a+a)+a+~ = (~+cY)+~_~ \nliftp Y@.(/3+,@+/3+~ = (/3+,B)+/3+~, We thus need the following global type declarations: newtype S \n= Va. a+(cl+a)+a!+a newtype T = v p.p+(p+p)+f?+~, Translating the successor function results in SUCC* \n= Am: S. T(AXP: fl.Af: ~ -~. kz:/3.S-l m zp f (f z)). Although S and T are identical and a single type \ndec\u00adlaration would be sufficient, the translation does not provide this simplification. It might seem \nthat the F? translation makes our previous encodings of abstract types and polymorphic structures superfluous, \nsince these can clearly be ex\u00adpressed in F2. However, unlike these previous en\u00adcodings, which had only \nlocal transformation rules for terms, the translation of F2 depends on the full typing derivation of \nan F2 program. It is therefore not clear how to use the translation for validating typing rules for abstract \ntypes and polymorphic structures in Ezp; u, as we did in the last section. 5 Finding Most General Instantiators \nIn this section we study the problem of finding sub\u00adstitutions that make one type scheme an instance \nof another. Preliminaries: Substitutions and Uni\u00adfiers. A (type variable) substitution is an idempotent \nmapping from type variables to types that maps all but a finite number of type variables to themselves. \nLet dom(0) = {a I (la # a}. Substitutions are extended ho\u00admomorphically to mappings on types and type \nschemes. When applying a substitution 0 to a type scheme a, we assume that the bound variables in a are \ndisjoint from dom(~). This can always be achieved by renam\u00ading bound variables in u. Let 1 be the identity \nsubstitution and let [r/a] be the mapping (idempotent or not) that replaces a by -r. Composition of substitutions \n@ and d is written 00 ~. Let V be a set of type variables. Then Olv is the substitution that equals 0 \non all type variables in V and that is the identity on all other type variables. Conversely, O\\v is the \nsubstitution that equals 0 except on V, where it is the identity. Let U be a finite set of type variables. \nUsually we use U for the universe of type variables that are of interest in the situation at hand. We \ndefine 91 ~~, 02 if ($J o ~l)lu = 1921u. we write 191 <c, 6 z if 3@.01 <$6 2. Note that this makes the \n(more general substitution the smaller element in the pre-order ~u. This choice, which reverses the usual \nconvention m treatments of unification (e.g. [LMM87]), was made to stay in line with the semantic notion \nof type instance. We make <u a partial order by identifying substitu\u00adtions that are equal up to variable \nrenaming, or equiv\u00adalently, by defining @ =U 0 iff ~ <u 0 and 6 <u ~. It follows from [L MM87] [Theorem \n7] that <u is a com\u00adplete lower semi-lattice where least upper bounds, if they exist, correspond to unifications \nand greatest lower bounds correspond to anti-unifications. The Instantiation Algorithm. We address here \nthe following problem. (Instant~aizng Substdutxon). Given type schemes a and a , find the most general \nsub\u00ad stitution @ = AIG1(a < a ) such that L9CJ < da , provided d exists; return failure otherwise. This \nproblem can be reduced to the unification un\u00adder a mixed prefix problem [Mi192]. Unification under a \nmixed prefix involves finding a substitution [r that solves a system of equations 62 Figure 4: Algorithm \nMGI. where the Qi are 3V-quantifiers and Si and tiare simply\u00adtyped }-terms. We shall be concerned here \nonly with th~ simpler problem where s~ and t~ are first-order terms, i.e. types. The domain of the substitution \nU are the existentially quantified variables in the prefix QICYI . . . Qmam. Let ai be one such variable. \nThen Lrai can refer to any variable CYj with j ~ i, but not to any variable bound further to the right \nthan a~. The reduction of the instantiation problem to a uni\u00adfication under a mixed prefix problem proceeds \nin three steps. Step 1:. Decompose the instantiation problem to a system of equations with quantifier \nprefixes by applying the mapping (0) defined below. The meta-variable p in the first clause of this mapping \nis assumed to range over type schemes without quantifiers at the outermost-level: .. .. Tla+d. P Step \n2: Bring the resulting system into prefix form by applying the equations $ A (Qa.t?) = QcY.($ AS ) (Qa.S) \nA t? = Qa.(c$A S ) left-to-right as often as necessary. Step 3: Let ~z(a < a ) be the system resulting \nfrom Step 2. Then a unification under a mixed prefix prob\u00adlem $(o < u ) is obtained by existentially \nquantifying all free variables in S2. :(0 < 0 ) = 3ftv(c$2).s2 Proposition 5,1 F 19a < Oa iff 6 is a \nsolution to the problem ~(a < a ). A more direct approach, which combines the trans\u00adformation to a unification \nunder a mixed prefix and the solution of this problem in a single algorithm, is shown in Figure 4. Algorithm, \nMGI is expressed as an inference system whose clauses are of the form ok~u <u . 63 Each derivation step \ntakes as inputs two type schemes a and a . It yields as output a substitution 6 . We will show that 0 \nis the most general substitution such that } @u < Oa holds. The most interesting rule of the algorithm \nis (< V)r. This rule has to enforce the side-condition (a ~ ftv(a)] in the corresponding instance rule, \n(< d). It does this by replacing a with a Skolem function T that has as arguments all other type variables \nin a and Va a . This way, any substitution which would violate the side-condition by instantiating some \ntype variable to a would lead to failure of an (a)~ rule in MGI due to a circular variable dependence \n(an (occurs check ). We now state soundness and completeness of algo\u00adrithm MGI. The proofs for this and \nthe following the\u00adorems proceed by standard inductions on derivations. Proofs are omitted here; they \nwill be given in a forth\u00adcoming technical report [O L95]. Lemma 5.2 (Substitution) If 1-a < a then E \nda < Ou . Theorem 5.3 Let a, CT be type schemes, let 6 be a substitution and let U be a finite set of \ntype variables. (Soundness) If 0 F a <a then dom(~) < ftv(a, a ) and t $CJ < 9u . (Completeness) If E \nOa < da then there is a sub\u00adstitution 4 <u 8 such that ~ t-~ u <0 . For type reconstruction we need a \nslightly different version of this algorithm that restricts the returned sub\u00adstitution to be the identity \non some given variable set V. This algorithm is again given in logical form. For simplicity, we reuse \nthe Fr symbol, writing V,6 !-1cl< fJ . The modified algorithm is obtained from MGI by skolemizing V, \nusing the rule below. Corollary 5.4 Let a, a be type schemes, let U and V be finite sets of type variables, \nand let 0 be a substitu\u00adtion. (Soundness) If V , 0 tr u<d then dom(~) ~ ftv(a, d)\\V and F Oa < da . (Completeness) \nIf E @a < Oa and 61V = 1 then there is a substitution ~ <u d such that V , @ ti~ o < u . Proof: Direct \nfrom Theorem 5.3 and the definition of modified MGI. 0 6 Type Reconstruction Figure 5 explains the type \nreconstruction algorithm. Following [R6m89], it is expressed as an inference sys\u00adtem, with clauses of \nthe form Each derivation step takes as input a type variable set V, a typothesis r and an expression \ne. It yields as out\u00adput a substitution 0 and a type scheme a. Informally, whenever a clause V, W +G e \n: a is derivable, then 0 is the identity on V and W t-e : a holds. Furthermore, whenever V, Or l-w e \n: u is derivable, then a is the most general type scheme such that 017 E e : a holds. This will be made \nprecise in the theorems below. The purpose of the set of variables V is to prevent the computed substitution \nfrom touching type variables that occur free in annotations. For instance, given the function declaration \n map = Af a+ b Axs [a]. case xsof the body of map would be typechecked under assump\u00adtions f: a ~ b, XS: \n[a]. It is not OK to instantiate these variables when t ypechecking the body of map. Such an instantiation \nis prevented by including a and b in V. The type reconstruction algorithm uses the auxil\u00ad iary clause \ntE a < a , which states that u is obtained from a by instantiating generic type variables. The only derivation \nrule for this clause is (VElim)w. All l-w clauses have a derivation that ends in a (Taut)w and (Gen)w \nrule. All other rules in Figure 5 have a t-G conclusion. Informally, this forces a complete general\u00adization \nof the result type scheme after each derivation step. The most complex rules in the reconstruction algo\u00adrithm \nhave to do with function application. Two rules are needed, depending on whether type reconstruction \nfor the function part of the application yields a function type or a type variable. In the first case, \nthe rule com\u00adputes a substitution instance of the result type scheme of the function. In the second case, \na fresh type vari\u00adable is created to hold the function result type, which corresponds to what is done \nin Hindley/Milner type reconstruction. Lemma 6.1 (Substitution) If r E e : a then Or E e : 19u. Theorem \n6.2 Let r be a typothesis, let e be an expres\u00adsion, let a be a type scheme. Let V z ftv(r) n ftv(e) and \nU be finite sets of type variables and let 0 be a substitution. (Soundness) If k , W t-w e : a then dom(6 \n) ~ ftv(I )\\(V Uftv(e, o-) and Or F e a. 64 (VElim) w (Taut)w (Gen)w (Lambda)w (Apply)w (Typed)w (Let)w \n(Proj)w (Newtype)w  P v@.a [p/zi]a < B new V,l(r, x:a)l-wz:a v,l(r, T:6)~w T:a V,017tGe:i7 V , 0 Iftvr \nr t-w e : vftv(u)\\ftv(Or).~ V, o(r,.~:a) l-w e:a a new V, O1 ZRGJx.e:O~-+a V u ftv(u) , O(rz.z: a) \nfw e : u v,m. t-G Ax:u. e:c7+u  V,dlr+we:a PU5C71-+C72 V,0217twe :0 V,031JU < (71 o=e1u02u63 V, or tG \nee :~ux V,dlrl-we:u I-E Lr<cY /3 new V,6 217twe :u v, Q3tIcY<u +p O=61U02U6 3 V, OI tGee :OP Vu ftv(a) \n, dlr Hw e :d v u ftv(u) , &#38; F~ a < a 19=!91U6 2 V,6TFG(e:a):o V,8117Ghwe:o V , 02(rz..t:~) 1-w e \n:0 o=(?~uox V,6W zF Gletz=eine :W T:u Er EEO<U -+T7 V,l I FG T l:TT_U  CT ==QG. CT--+ T E v u ftv(u \n) , 8(rT , T: u ) Fw e : u V,~rT I--G newtype TZ=uine:u Figure 5: Type reconstruction algorithm. 65 \n (Completeness) If .W t-e : a and O\\Vu~,,f,J = 1 then there is a substitution $ <$ % and a type scheme \nu such that V, q51 tw e : u and ~ cd < a. Corollary 6.3 (Principal Types) Let r be a closed hy\u00adpothesis. \nIf r E e : CT then there is a type scheme u <usuch that 0,1 I t-we :u andrte: u . Conclusion We have \npresented a type system that generalizes sev\u00aderal recent second-order polymorphic extensions of the Hindley/Milner \nsystem. The presented type system stays firmly in the tradition of Hindley/Milner in that all Hindley/Milner \nprograms continue to be typable with the same types, and the essential theorems carry over. To keep the \npresent treatment simple we have kept the type system fairly small. When applied in a pro\u00adgramming language, \nseveral extensions would be possi\u00adble and maybe even desirable. We have already dis\u00adcussed polymorphic \nsum and product type schemes. As another possible extension, it is straightforward to add polymorphic \nrecursion [Myc84], which is known to be undecidable in the absence of type declarations [Hen93, KTU93]. \nStarting with Hope [BMS80], many programming languages have supported polymorphic recursion when explicit \ndeclarations are given for polymorphically re\u00adcursive functions. Nevertheless, we are not aware of a \nformal analysis of type reconstruction for these lan\u00adguages. Our system can be extended to polymorphic \nrecursion by adding the typing rule below. 17z, x:flt e:u rz, x:u 1-e :u (Letrec) r 1-letrecz:a=eine \n:a The corresponding clause for the type reconstruction algorithm is: Vu ftv(a) , Ol(rz, z:m) l-w e : \n0 v Uftv(a) , 6 2 E1 a < a (Letrec)w V U ftv(a) , OS(I C, x: a) &#38;w e : a O=oluo,uo. v,dr t-letrecz:~=eine \n:~ An extension of the soundness and completeness proofs for type reconstruction is straightforward. \nAs a more ambitious extension one could combine our system with subtyping. This is particularly intrigu\u00ading \nsince we already have a subsumption rule, albeit for type schemes, not for types. Moreover, the instance \nre\u00adlationship on function type schemes uses the contravari\u00adance rule that is standard in subtyping systems. \nWhat is still missing is a definition of subtyping for types. An extension along these lines should yield \na system in which parametric polymorphism is regarded as a spe\u00adcial form of subtyping, which would lead \nto a closer integration of the two typing disciplines. Acknowleclgments We d like to thank Mark Jones, \nBenjamin Pierce, Didier R6my and Phil Wadler for stimulating discussions. The idea of lifting out maximal \nsubterms of polymorphic types in the F2 encoding is due to Didier R6my. Thanks also to Dilip Sequeira \nfor helpful comments on an earlier version of the paper. References [Aug94] L. Augustsson. Haskell B. \nuser s manual version 0.999.7, October 1994. Distributed with the HBC compiler. [BMS80] Rod Burstall, \nDavid MacQueen, and Donald T. Sanella. Hope: An experimental applicative lan\u00adguage. In Conference Record \nof the 1980 LISP Conference, pages 136 143, Redwood Estates, California, August 1980. The LISP Company. \n[Boe89] Hans-J. Boehm. Type inference in the presence of type abstraction. In Proceedings of the SIGPLAN \n89 Conference on Programmmg Language De\u00adsign and Implementation, pages 192 206. ACM, ACM Press, June \n1989. [DM82] Luis Damas and Robin Milner. Principal type schemes for functional programs. In Proc. 9th \nACM Symposium on Principles of Programming Languages, January 1982. [Fe190] Matthias Felleisen. On the \nexpressive power of programming languages. In Neil D. Jones, ed\u00aditor, ESOP 9o, European Symposium on \nPro\u00adgramming, pages 134-151. Springer-Verlag, 1990. Lecture Notes in Computer Science 432. [Gir71] J. \nGirard. Une extension de l interpretation de Godel a l analyse, et son application a l elimination des \ncoupures clans l analyse et la theorie des types. In 2nd Scandznauian Logic Symp., pages 63-92, 1971. \n[Hen93] Fritz Henglein. Type inference with polymorphic recursion. ACM Transactions on Programming Languages \nand S@ems, 15(1):253-289, April 1993. [Jon92] Mark P. Jones. Quaiified Types: Theory and Pra c t~ce. \nD.phil. thesis, Oxford University, September 1992. [Jon95] Mark P. Jones. From Hindley-Milner types to \nfirst-class structures. In Proc. Haskell Workshop, La Jolla, pages 115 136, June 1995. Yale Univer\u00adsity \nResearch Report YALEU/DCS/RR-1075. [KTU89] A. Kfoury, J. Tiuryn, and P. Urzyczyn. The undecidability \nof the semi-unification problem. Technical Report BUCS-89-010, Boston Univer\u00adsity, oct. 1989. also in \nProc. of Symp. on Theory of Computing, Baltimore, Maryland, May 1990. [KTU93] A.J. Kfoury, J. Tiuryn, \nand P. Urzyczyn. Type reconstruction in the presence of polymorphic recursion. ACM Transactions on Programming \nLanguages and Systems. 15(1):290-311, April 1993. [LMM87] J. Lassez, M. Maher, and K. Marriott. Unifica\u00adtion \nrevisited. In J. Minker, editor, Foundations of Deductive Databases and Log~c Programmmg. Morgan Kauffman, \n1987. [L094] Konstantin Laufer and Martin Odersky. Poly\u00admorphic type inference and abstract data types. \nACM Transactions on Programming Languages and Systems, 16(5):1411 1430, September 1994. [LPar] John Launchbury \nand Simon Peyton Jones, State in Haskell. Lisp and Symbolic Computation, to appear. [McC84] N. McCracken. \nThe typechecking of programs with implicit type structure. In Gilles Kahn, David B, MacQueen, and Gordon \nD. Plotkin, ed\u00aditors, Semantics of Data Types, pages 301 315. Springer-Verlag, June 1984. Lecture Notes \nin Computer Science 173. [Mi178] Robin Milner. A theory of type polymorphism in programming. Journal \nof Computer and System Sciences, 17:348-375, Dec 1978. [Mi192] Dale Miller. Unification under a mixed \nprefix. Journal o} Symbolic Computation, 14:321-358, 1992. [Mit90] John C. Mitchell. Polymorphic type \ninference and containment. In G&#38;-ard Huet, editor, Logi\u00adcal Foundations of Functional Programming, \nThe UT Year of Programming Series, chapter 8. Addison-Wesley Publishing Company, Inc., 1990. [Mor68] \nJ. H. Morris. Lambda-Calculus Models of Pro\u00adgramming Languages. PhD thesis, Massachusetts Institute of \nTechnology, 1968. Technical Report MAC-TR-57. [MP88] J. Mitchell and G. Plotkin. Abstract types have \nexistential types. ACM Trans. on Programming Languages and Systems, 10(3):470-502, 1988. [MP93] M. Mauny \nand F. Pottier. An implementation of Carol-Light with existential types. Technical report, INRIA, October \n1993. Distributed with the Carol-Light system. [Myc84] A. Mycroft. Polymorphic type schemes and re\u00adcursive \ndefinitions. In Proc. 6th Int. Symposium. on Programm~ng, LNCS 167, 1984. [OG89] James William O Toole \nand David K. Gifford. Polymorphic type reconstruction. In Proceed\u00adings of the ACM SIGPLAN Conference \non Pro\u00adgramming Language Design and Implementation, pages 207-217. ACM, ACM Press, June 1989. [OL95] \nMartin Odersky and Konstantin Laufer. Type reconstruction in the presence of type scheme an\u00adnotations. \nTechnical report, University of Karl\u00adsruhe, 1995. forthcoming. [OWW95] Martin Odersky, Philip Wadler, \nand Martin Wehr. A second look at overloading. In PKJC. ACM Conf. on Functional Programming and Computer \nArchitecture, pages 135 1469, June 1995. [Per90] N. Perry. The Implementation of Practical tional Programming \nLanguages. PhD Imperial College of Science, Technology, Medicine, University of London, 1990. Func\u00adthesis, \nand [P fe88] Frank Pfenning. Partial polymorphic type infer\u00adence and higher-order unification. In Proceedings \nof the 1988 ACM Conference on Lisp and Func\u00adtional Programming, pages 153-163, July 1988. [R6m89] Didier \nR4my. Typechecking in a natural extension of ML. records and variants In Proc. 16th ACM Symposium on \nguages, 1989. Principles of Programming Lan\u00ad [R6m94] Didier ART, record R6my. Programming objects with \nML\u00adand extension to ML with abstract and types. In Proc. Theoretical Aspects of Computer Springer Software, \nLNCS 789. pages 321-346, April 1994. [Rey74] John C. Reynolds. Towards a theory of type structure. In \nInternational Programming Sympo\u00adsium, pages 408 425. Springer-Verlag, 1974. Lec\u00adture Notes in Computer \nScience 19. [We194] J.B. Wells. Typability second order A-calculus cidable. In Proc. 9th in Computer \nScience, and are IEEE pages type checking in the equivalent and unde-Symposium on Logic 176 185, July \n1994. 67  \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Martin Odersky", "author_profile_id": "81100056476", "affiliation": "Department of Computer Science, University of Karlsruhe 76128 Karlsruhe, Germany", "person_id": "PP14030830", "email_address": "", "orcid_id": ""}, {"name": "Konstantin L&#228;ufer", "author_profile_id": "81100009927", "affiliation": "Department of Mathematical Sciences, Loyola University Chicago, Chicago, Illinois", "person_id": "P162824", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237729", "year": "1996", "article_id": "237729", "conference": "POPL", "title": "Putting type annotations to work", "url": "http://dl.acm.org/citation.cfm?id=237729"}