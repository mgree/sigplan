{"article_publication_date": "01-01-1996", "fulltext": "\n Faster Checking of Software Specifications By Eliminating Isomorphs Daniel Jackson, Somesh Jha and \nCraig A. Damon School of Computer Science Carnegie Mellon University So as fast as you can, Think of \nsomething to do! YOU will have to get rid of Thing One and Thing Two! Dr. Seuss (1957) Abstract Both \nsoftware specifications and their intended properties can be expressed m a simple relational language. \nThe clalm that a specification satisfies a property becomes a relational formula that can be checked \nautomatically by enumerating the formu\u00adla s interpretations. Because the number of interpretations is \nusually huge, this approach has not been thought to be practi\u00adcal. But by ehminating isomorphic interpretations, \nthe enu\u00admeration can be reduced substantially, with a factor of rough\u00adly k! contributed by each type \nof k elements. Keywords: validity checking, model enumeration, symmetry, relational calculus, formal \nspecification, Z notation. Introduction The success of model checking in verifying hardware designs \nsuggests that systematic enumeration, once considered imprac\u00adtical for all but toy problems, 1s a promismg \nbasis for practical design analysis tools, Enumeration provides two benefits over Authors postal address: \nSchool of Computer Science, Carnegie Mellon University, .5000 Forbes Ave., Pittsburgh, PA 15213. Email: \ndnj@cs.cmu.edu; httP:/Jwww.cs.cm u.edu[-dnj. This research was sponsored in part by a Research Initiation \nAward from the National Science Foundation (NSF), under grant CCR-9308726, by a grant from the TRW Corporation, \nand by tbe Wright Laboratory, Aeronautical Systems Centec Air Force Materiel Command, US~ and the Advanced \nResearch Projects Agency (ARPA), under grant F3361S-93-1-1330. Permission to make digital/bard copies \nof all or part of this material for personal or classroom use is granted without fee provided that the \ncopies are not made or distributed for profit or corrnnewial advantage, the copy\u00ad right notice, the title \nof the publication and ita date appear, and notice is given that copyright is by permission of the ACM, \nInc. To copy otherwise, to republish, to post on servers or to redistribute to lists, rcquims specific \npermission and/or fee. POPL 96, St. Petersburg FLA USA @ 1996 ACM 0-89791-769-3/95/01. .$3.50 syntactic \ntechiques: full automation (no need to invent lemmas or devise proof strategies), and the generation \nof counterex\u00adamples when a check fails. We are investigating enumerative analyses for checking software \nspecifications. Unfortunately, model checking meth\u00adods that have been remarkably successful m verlfymg \nhard\u00adware designs and protocols (such as [BC+92, Kur94, Ho19 1]) have no obvious application to software. \nIn software designs, state explosion arises more from the data structures of a single machine s state \nthan from the product of the control states of several machines, making it hard to analyze even a simple \nsequential operation. This paper describes a method for reducing the number of cases a checker must \nconsider by eliminating isomorphic inter\u00adpretations. It achieves this in two ways: first by noting that \npermutations of variables maybe independent of one another, and second by exploiting symmetries in the \nunderlying data values. These symmetries are independent of the specification being checked, and are \ntrivially determined prior to checking. Detection of symmetry therefore has no runtime cost and imposes \nno burden on the user. The method gives a reduction, in the number of cases, that increases exponentially \nin the number of types and the sizes of the their carrier sets. Since the exploitation of symmetry has \nhtde runtime overhead, the reduction in cases translates mto a corresponding reduction in execution time. \nOur specification language N a relational subset of Z, an increasing popular notation for formalizing \nsoftware designs and requirements [Spi92, Hay93]. Properties are expressed in the same language; checking \nthat a design has a gwen proper\u00adty amounts to determining the validity of a relational formula. The method \nhas been implemented m a practical tool, the Nitpick specification checker. An example of the application \nof Nitpick to a realistic problem is given, along with the ratio\u00adnale underlying lts design, in ~D96]. \nThe principles guiding the form of the specification language are discussed in ~ac96]. This paper explains \nthe isomorph elimination method and demonstrates Its soundness. 1.1 Operations, Inuarzants and Claims \nThe transition relatlon of a state machme is commonly expressed as a formula, with unprimed and primed \nvariables denoting values of state components before and after a transi\u00adtion respectively. The formula \nX =x+lvx =x l for example, describes a machme that non-deterministically increments and decrements x. \nIn software designs, the transi\u00adtion relatlon is dlwded mto operations incr~x =x+l decr~x =x l whose \nproperties can be investigated mdependendy. The increment operation, for example, preserves a lower bound \non x: incr A (x > win) d (x > n-zin) where mm ts some constant of unspecified value. It 1s conve\u00adnient \nto introduce a name for the invariant inv ~ x> min so that the claim can be written more concisely claim \n~ ilXGYA WZV 3 UUI where F is short for the formula F with its variables primed. Note that incr and inv \nare just names for formulae, and have no semantic significance: there IS no notion of a label on a transition. \nRelationships between operations can also be cast as simple formulae using further syntactic conventions \n[Spi92]; the formula (incr; deer) d x = x for example, says that decrementing undoes incrementing. \nRepresenting operations, invarlants and clalms all as Ioglcal formulae greatly simplifies both our language \nand our check\u00ading tool. It also allows simulated execution to be incorporated smoothly, the counterexamples \ngenerated for the formula not incr are exactly the executions of the mc7 operation. 1.2 Relational Formulae \nSoftware designs, unhke theu hardware counterparts, revolve more complex datatypes than integers and \nbooleans. At a level of abstraction appropriate for design analysls, all datatypes can be expressed in \nterms of relations. The connections of a phone switch, for example, can be modelled as a relatlon on \nphones contzs: Phone + Phone where (p, q) e corms means that a call from p to q is actwe. Members of \nthe domain of the relation (such asp) are making calls; members of the range (such as q) are receiving \ncalls. The calhng operation with two arguments from, to: Phone might then be specified as Call ~ to g \nran corms A corms = corms U {(from, to)} corms PI PI o :0 o P,% Pj P3 Figure 1a: Legal state satisfying \nboth invariant from corms to comz.s P, P,P, o o P2 P2 o P3 P3% o Figure 1b: Transition to legal state \nfrom corms to corms PI P, P2 P2 o P3 P.3 P3 oo F Figure lC Transition to illegal state That is. a new \ncall IS constructed and added to the set of con\u00adnections so long as the called party to is not already \nreceiving a call. Suppose we intend the state to satdy two mvariants. First, although comzs is not a \nfunction (because of conference calls), Its transpose should be, so that there IS most one phone calling \na given phone (and thus a smgIe party to blll for each call): i?zvl ~ func (com-ts-) Second, no party \nshould both be making and receiving a call at once: invz ~ dom corms n ran corms = 0 The claims that \nthe calling operation preserves these invariants are then: Glalml = call A lnV~ * inV~ claiWZ2 S call \nA inV~ * inV~ The first clalm is vahd. The second is not, because the specifi\u00adcation should have precluded \nnot only to being called but also to being a caller (and from being called); it has the counterex\u00adample: \ncorms = {(pl, p2)} from = p3 to =p~ Figure 1 illustrates some of these points. It shows an instance \nof the state satisfying both invariants, in which PI has established a call to P2 (la); the transition \nfrom this state cor\u00adresponding to an execution of Cull with arguments from = p, and to = p3, resulting \nagain in a legal state in which pl is con\u00adference to frz and p~ (lb); and the counterexample, a transi\u00adtion \nleading to a state that violates invz (lc). 1.3 Case Enumeration and State Explosion A claim about a \nspecdication holds if it is true for every case, that is, every assignment of values to variables. A \ncase may comprise one state (for a claim that the state space definition satisfies an invariant), two \nstates (for a claim about an opera\u00adtion, as in the example above) or perhaps more (for a claim about \na sequence of operations). To check a claim, we might enumerate cases until one is found for which the \nformula evaluates to false. If the property does hold and there is no counterexample, then since the \nrela\u00adtions are generally unbounded, enumeration would not termi\u00adnate. But this is rare. Most designs \nare flawed, and, in our experience so far, exhibit small counterexamples. Our tool therefore conducts \nthe enumeration within a scope specified by the user (3 phones, say) and always termmates. Even for a \nsmall finite scope, the number of cases can stall be enormous. The primary challenge of our work, like \nthat of model checking in hardware, is thus to overcome a state explosion problem, but one of different \nnature. It arises from the growth in the number of underlying data values as the scope increases: for \nk phones, there are 2A x ~values of corms. Each of the claims above (Claiml and Claim2), for exam\u00adple, \nhas a space of more than 2 milhon cases when Phone N restricted to have at most 3 values. Our tool determines, \nby static analysls, that the variable co;zrzs need not be enumerated independently, but can be derived \nfrom the other variables. The actual formula checked for Claim ~ is thus fr&#38;?C (GO?ZnS-) A tO @ i \nan COnflS a fine (corms U {(from, to)})\u00ad which has only 4608 cases for 3 phones. The method described \nin this paper reduces the space further to 167 cases. As we shall see, the reduction depends on the structure \nof the formula; a smaller reduct:on is obtained for Claim2. But, encouragingly, as the scope is increased, \nthe reduction factor increases exponentially (see Table 1, discussed in Section 9). 1.4 Overview of \nIsomorph Elimination Our method works by eliminating isomorphic mterpretations. Since the values of the \nbasic type Phone have no structure, the Iabelling of a case such as from = p,, to = p,, comzs = {(p,, \np3)} has no significance; permutmg {pl, p2, p3} can have no effect on the evaluation of the formula. \nThere are 6 permutations of 3 elements, so at a stroke we can identify 5 cases equivalent to this one. \nBut the space is not reduced by a factor of 6, because some cases have symmetries permutations under \nwhich they are invariant. The permutation that exchanges p, and Pz is a symmetry of from corms to 1. \n. . .  o  o 4- -;0..+ :: 2 ... ,., 5 ,., 0 ,,6 3 ... ,. ,,, \\0 Figure 2: Generating assignments \nfor C/airnl for a fixed, canonical value of corms by varying its wirings to the other variables from \n= p3, to = p,, corms= {(~,, frJ, (Pzj PJ} for example, so of the 5 equivalent cases, 2 are identical \nany\u00adway. Our method does not eliminate isomorphs by computing permutations, but avoids their generauon \nin the first place. Consider a particular instance of comzs (such as any of those shown in Figure 1). \nThe actual labels do not matter; what determines the value of the formula is simply the relative Iabelling \nof from, to and corms. Instead of generating different labelings, we therefore vary the relationships \nbetween vari\u00adables. Only isomorphically distinct values of each variable are generated; the effect of \nIabelhng is accounted for by enumer\u00adating, additionally, bij ections between the variables. The form \nof these bisections, which we call wirings , and how they are generated, are the focus of this paper. \nWhich variables must be related? This depends on the structure of the formula. Claiml tests whether corms \nis a func\u00adtion, but does not compare its domain and range. So the only relative labelings that matter \nare between from and the left side of corms and between to and the right side. Claim2, on the other hand, \ntests whether the domain and range of corms intersect, and so their relationship will matter. Figure \n2 shows the assignments that can arise for Claim, when comzs has a canonical value that maps two phones \nto one phone. There are two wirings, one relating from and the left side of corms, one relating to and \nthe right side of corms. Each wu-ing has three values, shown as dotted lines, so there are at most 9 \ndistinct interpretations for this canonical value of corms. The symmetry m corms, which (as noted above) \nseems to detract from the available savings, can now be turned to our advantage. It renders wiring 1 \nequivalent to wiring 2, and 4 equivalent to 5, so only 4 of the 9 assignments need be checked. It may \nhelp to cast this argument in terms of exphcit labels, even though the method works with canotucal values \nand wirings. For the case from = p,, to = p,, corms = {(p,, p;), (P2, pJ} it is clear that exchanging \np, and Pz giving from = p,, to = p2, corms = {(pi, p;), (i%>pJ} wdl have no effect on the meaning of \nClaiml. But permuting the elements of the basic type N not the only way to identify Isomorphic cases. \nLess obviously, we can exchange the values of from and to independently, giving from = p,, to = pl, Co?tns \n= {(pi, pJ, (pzj pJ} for example. The reason is that the formula never compares from and to, nor does \nIt compare the elements m the domam of comts to elements in its range. Since PI and P1 play symmet\u00adrical \nroles in the domain of corms (because both are mapped to pJ and in the range (because nothing is mapped \nto either), p, and pz can be exchanged in from and to independently. In Ciuimz, on the other hand, the \ndomain and range elements of comzs are indeed compared, and the independent permutation of from and to \ndoes not generally gwe Isomorphs. In summary, the reduction arises both from the indepen\u00addence of wirings \nand from equivalences on wirings induced by the symmetry of the values of variables. In fact, the notion \nof wirings alone can increase the space, since permuting a rela\u00adtlon on both sides simultaneously can \nleave it invariant. Exploiting symmetry both compensates for this and brings fur\u00adther reductions. Whether \na wiring is placed between two variables depends on whether their values are independent in the formula. \nThis is easily determined by type inference. If two variables (or rela\u00adtion sides) have different types, \ntheir values are never com\u00adpared, and they can be permuted independently; therefore no wu-ing is inserted \nbetween them. In Claiml, for example, corms can be given the type corms: Callers w Receivers and so the \nleft and right sides of corms need not be wired together, but in Claimz, they have matching types and \nare thus wired. Our method consists of the following steps. In a prelimi\u00adnary static analysis, a type \ninference is applied to the formula to be checked, and for each type equwalence class obtained, a collection \nof wu-mg variables is introduced. Then the assign\u00adments are enumerated. Each variable is assigned every \npossible lsomorphically distinct value; and for each combination of variable values, the values of the \nwiring variables are enumer\u00adated. The assignment of canonical values to the formula vari\u00adables induces, \nby its underlying symmetries, equivalences on the values of wirings, so that not all wn-mg values need \nbe gen\u00aderated. 2 Syntax of Relational Calculus Our notation IS a relational subset of Z. Variables may \nbe scalars, sets or binary relations over unstructured types. Formulae and them variable declarations \nare combined into named schemas which help structure the specification and Its associated claims. Here, \nfor the purpose of explammg the lsomorph elimina\u00adtion method, we consider a much simpler language the \nrela\u00adtional calculus that serves as a kernel into which the con\u00adstructs of the practical notation can \nbe readily translated. Its abstract syntax is: f::= e~elfz.mc(e)l + lfAf e ::=vl OIJ\\L\\e; ele Uele O \nele-le where ~is a formula, e is a relational expression and v is a rela\u00adtional variable. O, ~ and L \nare constants denoting the empty, ldentlty and umversal relations respectwely, e-(e ) is the transpose \n(complement) of e. The formula fwzc(e) N true when e denotes a function. * Although purely relational, \nthis language can express famil\u00adiar notions of sets and scalars [SS93]. A subset of a set X can be modelled \nas a relation u on X X Y that pairs each element of u with every element of Y, so that a relatlon u denotes \na set when u;L=u where r =s is short for r cs As J r. The domain of a relation r, namely the set of elements \nit maps from ({a I 3 (a, b) G r}), and Its range, the set of elements lt maps to ({b I 3 (a, b) E r}), \nare then easily defined: domr~r; L ranr~r-; L Similarly, a scalar x in X is a relarion on X X Y that \npairs the single element x with every element of Y, so that a relation x denotes a point when z;L=x AX; \nX-g~AX#O A pair of points (x, y) is thus represented by the relation x; y-. Example. Writing C for corms, \nand T and F for the relations representing the points to and from, the formula Claim ~ func (corms-) \nA to @ ran corms = func (corms U {(from, to)})\u00ad becomes -((func (c-) A -T C C-; L) A +nc ((C U (F; T-))-) \nwith the additional constraints F; L= FAF; F-L] A=FCO AT;L=TAT;T-~]AT~ LO. The formula for Claimz dom \ncorms ~ ran cozns = @ A to @ ran corms + dom (corms u {(from, to)}) n ran (corms U {(from, to)}) = 0 \n noting the simphficatlon dom corms n ran corms = 0 -comzs ; corms-= 0 becomes -((C; C-=O A 4cC-; L) \nA-(CU (F; T-)) ;(CU (F; T-)) -=O) with the same additional constraints. o 3 Types Our typing scheme \nis a little unusual. Its purpose is to support the identification and construction of wirings between \nvari\u00adables. By giving each variable a distinct type, we can express * func(r) can be formulated, without \nthe need for a spe.tal con\u00adstruct, as r ; r c J, but this leads to an ouerconstraint in the type system: \nit suggests that the left and right elements of r need to be compared when m fact whether r is a function \ncan be determmed from its unlabeled shape. the placement of a wiring in its type structure alone, without \nsaying explicitly which variables it relates. The standard notion of type is then cast as an equivalence \non type names. If this equivalence is incompatible with the declared types of the variables, the formula \nis ill-typed. Since we are not concerned with type checking, however, we shall ignore the declared types \nand consider only the inferred equivalence. A relational expression has a type (A, f?) consisting of \na left type A (the type from which domain elements are drawn) and a right type B (from which range elements \nare drawn). Each relation variable is given a unique type (that is, neither its left or right type appears \nin the type of another relation). The rela\u00adtional constants should be regarded as indexed sets, so that \neach instance of a constant in an expression is distinct, and has its own type. An expression has a type \nthat is derived from, and induces an equivalence on, the types of its constituent variables. Given expressionss \nand twith types s : (b, Rs) t: (Lt, Rt) the compound expressions have types s;t :(Ls, Rt) sut:(Ls, Rs) \nsnt:(Ls, Rs) s-:(&#38;, Ls) s : (Ls, Rs) The choice of the type ofs (rather than oft) for the types \nofs U tands fl tis arbitrary and has no significance; the types ofs and twill be deemed equivalent anyway. \nWriting e t-A = B for the prdgment that m expression (or formula) e, the types A and B are equivalent, \nthe type equiva\u00adlence induced by an expression is defined to be the smallest equivalence relation that \nsatisfies the matching rules s;t FRs=Lt sUt ELs=Lt>Rs=Rt s(ltl-Ls=Lt, Rs=Rt sGtt-Ls=Lt>Rs=Rt incorporates \nthe equivalences induced by its subexpressions eFA=B expr(e) EA=B where expr(e) is any expression in \nwhich e appears, and for any instance of the identity relatlon J with type (Lj, Rj), has Lj = Rj. Example. \nGiven the typing: C: (Lc, Rc) F: (Lfi Rf) T: (Lt, Rt) L: (Ll, Rl) the formula for Claim ~ =((func (C-) \nA -T C C-; L) A -func ((C U (F; T-))-) induces the equivalence classes {Lc, Lfi Ll} {Rc, Lt} {Rf, Rt, \nRl} The formula for Claimz -I((C; C-= OA-TGC-; L) Al(cu (F; T-)) ;(CU (F; T-)) -=O) on the other hand, \ninduces {Lc, Lfi Ll, Rc, Lt} {Rf, Rt, ~} Note that Claimz, because its invariant compares the domain \nand range elements of comzs, has a coarser type equivalence, collapsing the first two classes of Claim \n~ into one. o 4 Conventional Semantics The meaning of an expression (and thus a formula) is defined with \nrespect to an interpretation that gives values to the rela\u00adtion variables. An interpretation has three \ncomponents: a finite universe of atoms U, a type assignment T and a variable assign\u00adment A. The type \nassignment maps each type name to its carri\u00ader, a finite set of atoms from the universe c Type + 9(U) \nand maps equivalent types to the same sets: S=T* T[S]=T[T] The variable assignment A:Var -+ 9(U X U) \nassociates a value a finite set of pairs with each relatlon variable. This value must respect the variable \ns type, so that if r has type (S, T), @] ~~s] xT[~j The meaning of relation expressions for a given interpretation \n(U, T, A) is given by the function E:Expr -+ w (UXU) defined inductively over the syntax: E[v] = a[v] \nEIO] =0 E[s ; t] = {(X,y) I ~Z. (x,.z) e E[s] A (Z,y) ~ ElIt]} E[s U t] = {(X,Y) I (X,y) e ~[S] V (X,y) \nG E[t]} E[s (1 t] = {(x,y) I (x,y) e E[s] A (X,y) e E[t]} E[s-] = {(y,X) I (X,y) e E[s]} The meaning \nof two of the constants, and of complementa\u00ad tion, depends on the type assignment: ~ (S, T) K Em = {(x,x) \n[x G ~~]} L: (S, T) 1= E[L] = ~.S] X~T] s: (S, T) k E[s ] = {(X,y) ~ T[S] X TUT] I (X,Y) 6 E[s]} The \nmeaning of formulae is given by the function M: Formula + Boolean defined in the obvious way: M[s G t] \n= d(X,y) E E[s-]. (X,y) E E[t] M~itic (s)] = ~(X,y), (X,2) = E[s]. y = Z M~A g]=Mu] AM~] M[~f] = T M~] \n When we want to make the interpretation expliclt, we shall write I[e] for the meaning of e (that N, \nE[e]) under interpreta\u00adtion 1, and shall say that I != f holds when M~] is true for 1. When 1> f holds \nfor all interpretations 1, the formula f N valid; an interpretation 1 for which 1 k f does not hold is \na counterexample to f. Example. Given the type equivalences of Claiml {Lc, Lf, Ll} {Rc, Lt} {Rf Rt, Rl} \nthe type assignment T[~C] = flLf] = TIL1] = callers = {cl, C2, C3} T[Rc] = TIRfl = Receivers = {rl, r2, \nr3} T[Rf] = T[R~] = TIR1] = Dummies = {dl, dz, dl} is appropriate for a universe U containing at least \nthe elements of the three sets Callers, Receiuers and Dummies (this last set being required to represent \nscalars as relations). Under the interpretation formed by this type assignment and the variable assignment \nl[C] = {(cl, 71)} A[F] = {cz} X Dummies A[T] = {s 2} X Dummtes the formula for Clatml -4(fw-zc (C-) A \n-~ G c-; L) A -func ((C U (F; ~-))-) is true. The formula (even with the additional constraints that \nF and T be scalars) is true for any interpretation, and is thus valid. The formula for Claimz Y((C;C-=OA-TCC-;L) \nAl(cu (F; T-)) ;(CU (F; T-)) -=O) with typing {Lc, Lf, Ll, Rc, Lt} {Rfi Rt, Rl} requires a type assignment \nthat does not distinguish callers and receivers: T[~C] = ?[Lf] = = T[Lt] = ... = pb ZeS = {PI) Pz, ,03} \nTIRfl = flRt] = TIR1] = Dummies = {dl, d2, dj} and 1s not vahd, having the counterexample (Figure lc) \nA[C] = {(PI> P2)} A[F] = @3} X Dummzes A[T] = {pl} X Dummies o s Wired Semantics As sketched above (m \nsection 1.4), our method works by enu\u00admerating assignments of relation variables to canonical values. \nEach value of a relation can be relabeled in many ways; the canonical value is any one of these arbltrardy \nselected. To account for relabelings that can affect the value of the formu\u00adla, we enumerate bl]ections, \ncalled wirings, between the rela\u00adtions. Varying the wirings is equivalent to applying permuta\u00adtions independently \nto the different relatlons, but much cheap\u00ader, first because some relative permutations do not matter \n(and are thus not represented by wirings) and second because, due to the symmetry of the canomcal values, \nsome values of the wumgs themselves can be ignored. To show that this method is sound, we give a semantics \nin terms of wirings, which is sub\u00adsequently shown to be compatible with the conventional semantics. Assume \nsome infinite universe of places P and an infinite collection of fimte relatlons R whose domam and range \nele\u00adments are drawn from P. R contains one relation Isomorphic to any finite relation; given any relation \nthere are bisections v and w and exactly one r = R such that v-; q;w=r R may thus be viewed as a collection \nof unlabeled relations. In the conventional semantics, equwalent types were assigned equivalent carriers. \nThis time, equivalent types may have dlstmct carrier sets, which are related instead by exphclt bl]ections \nthat wire the relatlons together. A wzring u(S, T) is a bljection from the carrier of type S to the carrier \nof type T: CT(S,T) ~ T[s] X T[~] The wirings must respect the type equivalence relation, so for all types \nS, T and U CT(S,T) = u(T, S)- S= T=U* a(S, U)=a(S, T); cr(T, U) A wwed interpretation (T, A, W) consists \nof a type assign\u00adment that maps types to carriers a variable assignment that maps variables to canonical \nrela\u00ad tlons and, as before, 1s constrained to respect the variable s type, and a wiring set W, containing \na wiring a(t,t )for every pair of equivalent types t and t . Let s and t be relational expressions with \ntypes s : (Ls, Rs) t: (Lt, Rt) and let ] and L be instances of the constants with types: J: (Lj, Rj) \nL: (Ll, Rl) The rules defining the meaning of expressions in the wired semantics are no different to \nthe conventional rules for expressions involving a single relation; for those mvolvmg two relatlons, \nthe wirings must be inserted: E[s ; t] = E[s] ; cr(Rs, Lt) ; E[t] E[s U t] = E[s] U (m(k Lt) ; E[t] \n: a(Rt, R.s)) E[s n t] = E[S] n (oiLs, Lt) ; E[t] ; a(Rt, Rs)) ED] =the* j E R that is a btjection m \nT[Lj] ~ T[Rj] A tecbmcality: if no j E R can be found as a meanmg for J, the type assignment is not \nwell-formed. Wirings do not affect the meaning of the logical connective, nor are they required to determine \nif a relation is a function. So the only case for which the meaning function on formulae changes is: \nM[s G t] = E[s] Q (17(LS,Lt) ; E[t] ; c@, R-$)) Example. Let P = {n,, rrz, rrj, } and assume R contains \n{rrl} ... .X {RI, mz, rr,} and {(rrl, n,)}. Then a legal type assignment for Claimz -((c;c-=OA-~~c-;~) \nA -(CU (F; T-)); (CU (F; T-))-=O) maps all types to {rTl, n-z, n,]}. The variable assignment A[cJj= \n{(rrl, rrl)}. a[F] = A[T] = {rrl} x {~1, ~2, ~3} along with any wiring set that includes the wn-ings \nCT(IJ Lc) = {(7T1, r-rt), (rr3> 7T1), (Trz> rrz)} CT(LZ, Rc) = {(7T1, 7TJ, (7r2, ml), (nv n.1)} Cw, L) \n= {(rrl, rrl), (7r2, lr2), (lr3, rr3)} is a counterexample< o 6 Relating Semantics To relate the two \nsemantics, we shall first show how to con\u00adstruct a wired interpretation from a conventional interpreta\u00adtion \nand vice versa, and then prove that, under corresponding interpretations, the two semantics are equivalent. \nExcept when clear from the context, we shall subscript wired inter\u00adpretations and their components (lW, \nTLU, Aw) to set them apart from conventional ones. Let the triple (o-l, R, az) denote the relation value \nobtained by applying the labelling bl]ection ml to the left side of the canonical relation R and m2 to \nthe right side. Let us write CT(S, U) for the function that labels elements of type S. Then if R has \nthe type (LY, Rr), (o-(Lr, U), R, dRr, U))= cdU, Ix); R; o-(Rr, U) To obtain a wu-ed from a conventional \ninterpretation, each labelled relation value must be converted to a triple; the canonical relation is \nthen the value of the relatlon in the wired assignment, and the Iabellings are used to construct a wiring. \nSuppose for some variable r with type (Lr, Rr) /l[r] = (cT(~Y, U), R, m(Rr, U)) where R E R is an canonical \nrelation. Then aW[r] = R and the wiring set 1s obtained from the Iabellings; for example o-(Lr,Rr) = \nO(LY, U) ; u(U, R7) = cT(Lr, U) ; cdRr, U)\u00ad is the wiring from Lr to Rr. * This is a slight abuse of \nnotation. Tbe labelling function u(S, U) is a bijection, and should strictly be written o-(S, U ) where \nV n an appropriate subset of U. To apply the translation in reverse, it is necessary to find a set of \nlabelings a(T,,, U) for all types T, that is consistent with the wiring, satisfying the constraints such \nas the one above. Since the left and right types of any relation are unique, this is trivial, each relation \ns Iabellings being determined indepen\u00addently. Example. The conventional counterexample to Claiml: m = \n{(PI, P2)} AUF] = @l} X Dummies L[T] = @l} X Dummies 1srelated to the wu-ed counterexample AW[C] = {(rrl> \nml)}. aw[F] = A[T] = {rrl} X {rTl, rT2, Tr3} by the labelings cJ(Lfi U) = {(ml, /@> (7T2,z%)>(~1> h)} \ncr(Lt,U) = m(Lc, U) = {(rTl, pi)> (NZ>pz), (T~, p])} u(Rc, U) = {(rTl, PJ, (rrz, pi)> (~]> j%)} Notice \nthat A[C] = CT(U,Lc) ; AW[C] ; a(U, Rc). o The relationship between the values of the variables in the \ntwo semantics applies identically to the values of the expres\u00adsions: Lemma 1. For any pair of corresponding \ninterpretations I and IW, and for any expression e of type (Le, Re) I [e] = (a(Le, U), R, a(Re, U)) e \nIW[e] = R From this, it follows that a formula holds under a convention\u00adal interpretation exactly when \nIt holds under the correspond\u00ading wired mterpretation: Lemma 2. For any formula f and corresponding interpreta\u00adtions \nI and IW, We have demonstrated above how to translate any conven: tional interpretation into a wired \none and vice versa. Consequently, the notions of validity m the two semantics match exactly: Theorem \n1. A formula /_is valid in the wired semantics when it is valid in the conventional semantics. This theorem \nis the fundamental prstdication of our checking method. Instead of enumerating assignments that bind \nrela\u00adtlons to Iabelled relation values and interpreting the formula conventionally, we can enumerate \nassignments to canonical values, and for each assignment, enumerate wnings and inte\u00adrpret the formula \nfor each combination of assignment and wiring set. Since, in the translation between semantics, Iabelled \nrela\u00adtions are obtained from canomcal relatlons by applying bijec\u00advalues of P win tzgs values of Q 0-0 \n00 00 P o-o 0000 Q 0-o w Go 00 00 o-o o-o 0-+ 0-o o-o x 7 0 % o x Figure 3: Wired interpretations \n tions, a counterexample in the conventional semantics corre\u00adsponds to one of the same size in the wired \nsemantics. A scope 2:Type + N associates a bound on the size of the carrier set of each type; an assignment \nis within a scope Z if its type assignment T satis\u00adfies, for all types t, #&#38;] s X[t] Formally then, \na formula has a wired counterexample in some scope S exactly when it has a conventional counterexample \nm the same scope. 7 Independence of Wirings Within a given scope, there are generally fewer wired interpre\u00adtations \nthan conventional ones. The elements of mequlvalent types are not related by wuings, so the wired semantics \neffec\u00adtively ignores relative permutations that correspond to differ\u00adent interpretations m the conventional \nsemantics. Example. Take the valid formula with the scope 2[Lp] = Z[RP] = X[Rg] = 2. P and Q have 7 canonical \nvalues each, and the wrong o(RP, Lq) has 2 values, so there are 7 X 7 X 2 = 98 wired interpretations \n(Figure 3). In contrast, there are 64 Iabelled values of each relatlon and thus 64 X 64 = 256 conventional \ninterpretations. The reduction here arises because the domam of 1 and range of Q can be per\u00admuted independently \nwithout affecting the meamng of the formula. o o-o o %u 00 2 x  Figure4 Equivalence of wirings induced \nby symmetry of values Usually not even all the wired interpretations are necessary. When a canonical \nrelation value is symmetrical in some domain or range elements, two wirings that differ only m a permutation \nof those elements will be mdistinguishable. Theorem 2. Suppose that, for two wn-ed mterpretatlons 11 \n= (T, A, WI) and lZ = (T, A, W2) differing only m their wiring sets, any wrong UI(,S, T) in WI Is equivalent \nto its counterpart m2(S, T) in Wz m the following sense: for the pair of relatlon values R4, R~ in the \nvariable assignment (or them transposes) which have the appropriate types Then the interpretations themselves \nare equivalent: 111= f*121=f This completes the )ustdication of our method. Instead of enu\u00admerating conventional \nmterpretations, we enumerate wired interpretations. Each assignment of canonical relation values to variables \nhas symmetries that induce equwalences m the wuwrgs, so that not all wirings need be generated, and the \nnumber of wined mterpretatlons N thus dramatically reduced. Example. For the same formula, if P has the \nvalue {(rrl, rrl), (ml, TT2)}and Q has the value {(ml, ml)}, the wirings are indlstmguishable, since \nthe value of P has the symmetry (rrlrr2) (Figure 4). Excluding all such unnecessary wirings reduces the \nnumber of wired interpretations from 98 to 67. o Example. Consider enumerating wn-ed mterpretatlons of \nClaiml with Z[LC] = 2[Rc] = 3 (that N, considering three phones). The wn-ings shown in Figure 2 are m(Lfi \nLC) and o+ct, Rc). The symmetry of this value of comzs reduces the number of combinations of these wirings \nfrom 9 to 4. o 8 Exte?zsions of the Method Sometimes enumerating wirings, even modulo symmetry, wdl produce \ntwo assignments that are actually equwalent. To see why, consider a canorucal value of a 2 x 2 relation \nthat is a 2\u00adedge bijection (such as {(a,c), (b,d)} ). According to our method, this value has no symmetry, \nsince there is no permu\u00adtation which, when apphed to one side of the relatlon, leaves it scope # cases \nClairol Claim2 2 64 16 (4.0) 32 (2.0) 3 4608 167 (24) 713 (5.7) 4 1048576 2707 (387) 33306 (31) 5 8.39 \nE8 82432 (1.0e5) 4.0e6 (208) Table 1: Reduction factors for the formulae introduced in Section 1.2. \nA scope of k means that the enumeration was restricted to cases involv\u00ading k phones or fewer (ZIPhone] \n= k). The second column gives the number of cases in the unreduced space. The others give, for the two \nclaims checked, the number of cases, and the reduction factor (in parentheses), for an enumeration of \nthe same space using isomorph elimination. invariant. Yet permuting both sides simultaneously has no \neffect, and so of 4 possible combinations of the two wirings, two are redundant. In the implemented version \nof our method, we account for this kind of symmetry by arbitrarily picking the left side of the relation \nand marking its two places as equivalent. As a result, only the wiring on the right side is varied, and \nthe spurious cases are not generated. There are symmetries in composite values that might also be exploited. \nAn expression such as P ; Q, for example, often has symmetries when its consistent values F and Q do \nnot; by identifying such symmetries higher m the parse tree, It should be possible to obtain even greater \nreductions. 9 Implementation The method has been implemented within the Nitpick specifi\u00adcation checker. \nIt is written in about 30,000 lines of C and runs (so far only) on Macintosh computers. The user loads \na file containing the specification and associated clalms and selects a scope by choosing a bound for \neach type; the tool then runs until a counterexample 1s found or the space is exhausted. Isomorph elimination, \nin addition to a variety of other reduction mechanisms, may be toggled on and off. This feature is purely \nfor research; we have yet to come across a claim that runs faster when a reduction is turned off. Generation \nof canonical relations is delegated to the pub\u00adlic-domain Nauty tool [McK81, McK94a, McK94b]. For effi\u00adciency, \nscalars, sets, functions and domain/range operators are implemented directly (rather than being translated \ninto the relational calculus as the formalization above suggests). Because there are relatively few relatlon \nvalues there are 5624 canonical 5 X 5 relatlons they can usually be cached with their symmetries for \nan entire session. Table 1 shows results for the examples discussed above. The tool was set to exhaust \nthe entrre space even if counterex\u00adamples were found. Each type equivalence class whose types have k \nelements might be expected to contribute a reduction factor of k!, the number of ways to permute those \nnodes. (The actual reduction factor N lower for small scopes but grows more rapidly, because of symmetry.) \nConsequently, adding constraints (which tends to collapse type classes together) leads to smaller reductions \nwitness the effect of the invariant in ClaimZ but adding more variables (when it adds new type scope \n# cases Claim 1 Claim2 2 576 80 (7.2) 144 (4.0) 3 294912 2060 (143) 6780 (43) 4 6.6e8 85118 (7699) 580433 \n(1129) 5 6.5e12 6.7e6 (9.8e5) 1.le8 (5.7e4) Table 2: Reductions for the elaborated example of Figure \n5 (below). A scope of k means that the enumeration was restricted to cases involv\u00ading at most k phones \nand k numbers (>[Phone] = X[fiumber] = k). Called: Phone i-i Number Net: Number + Phone Corms: Phone \n++ Phone from: Phone to: Number Corms z Called; Net Call E to g ran Called A Called = Called U {(from, \nto)} A Net = Net invl ~ fzmc (Comzs-) inu2 z dom Corms f ran Corms = D Claim 1 ~ Call A invl * invl \nClaim2 ~ call A if?.V2 * inV2 Figure 5: An elaborated version of the example of Section 1.2 that dis\u00adtinguishes \ntelephones and their directory numbers. In this case, Claiml is also invalid, because a single phone \nmay have more than one number (Net is not infective). classes) leads to larger reductions. Table 2 illustrates \nthis latter effect, showinrz reductions for an elaborated version of our example that distinguishes phones \nand their numbers (see Figure 3). On a PowerMac 7100, Nitpick enumerates and checks 2,000-9,000 cases/second; \nthe space of a billion cases for 5 phones is covered in 14 seconds for Claim, and just over 8 mmutes \nfor Claiml. With short-circuiting also activated, zreater reductions are obtained. In the elaborated \nexample, ~or 5 phones and numbers, the space is reduced further to-5.0 E5 cases for Claiml and 5.2 E6 \ncases for Claim2, which are covered in 3 and 32 minutes respectively. 10 Discussion Small data structures \nhave huge numbers of values. For this reason, enumerative analysis of software speciicatlons has been \nregarded as infeasible. A specification can be executed if limlted to a constructive subset of the language \n(see [LL91, ELL94] for VDM, ~a191] for Z, and [DK94]). This deprives the specifier of conjunc\u00adtion arguably \nthe most useful specification construct but not necessarily non-determinism [LL9 1]. As:de from our method, \ntheorem proving is the only approach that can accommodate implicit specifications (see [GGH90] for Larch, \n[B+94] for VDM, Uon92, BG94, ES94] for Z, and [BH94] for the relational calculus), For checking safety-critical \nalgorithms, where proof is needed to give perfect assurance, theorem proving wdl remam indispensable, \nbut its cost rules out its use for everyday specification work. Abstraction can reduce a huge (and even \ninfirute) space of interpretations to a relatively small number of cases ~ac94], but it has hmited applicability \nand demands ingenuity from thespeclfier in the choice of abstraction. Techruques for finding satisfying \nassignments of formulae have been mvestlgated before. The FINDER tool [Sla94], for example, uses backtracking \nto find models of a logic with functions and equality. Our example can be translated into Its input language, \nalbelt somewhat tediously; relational composi\u00adtion is handled by mtroducmg Skolem constants for the exis\u00adtentially \nquantified variables. On the examples of this paper, FINDER is much slower than Nitpick. If its input \n1s manually tweaked, however, by adding extra constraints and directives to order the search and break \nsymmetries, FINDER can match Nitpick s performance, and beat lt m some cases. FINDER constructs function \nvalues element-wise, and so its backtrack\u00ading prunes the search more efficiently than Nltplck s short-clr\u00adcumng \nmechanism, which exammes entire relatlon values. Unfortunately, isomorph ehrninatlon and element-wise \ncon\u00adstruction seem to be incompatible and it is unlikely that a tool could incorporate both. Symmetry \nhas been investigated in the context of automat\u00aded deduction: [BS92], for example, shows how to take \nadvan\u00adtage of symmetries m a formula by exchanging one variable for another. But as far as we know, no \nother method uses sym\u00admetry in the assignable values themselves. Isomorph elimination N related to a \nnumber of model checking techniques that explolt symmetry m the transition relation [Sta91, CFJ93, ES93, \nID93]. The symmetries identi\u00adfied by our method, in contrast, are not in the entire formula but rather \nin the individual relatlon values. Consequently, the symmetries need not be provided by the specifier, \nand, because each type contributes an exponential factor, our method tends to give much larger reductions. \nThe equivalence classes into which our method partitions the formula s mterpretations are reveahng subdomains \nm the jargon of testing theory ~080]. Our method might have some application m testing, although resource \nboundaries introduce discontmuiues m behaviour where many, bugs reside. Consequently, an enumeration \nthat is confined to a small scope is unlikely to expose most errors. Isomorph elimination IS only one \nreduction mechanism in Nitpick s repertoire. Although its reduction factor increases with the scope, \nlt tends to decrease with the complexity of the formula. Reassuringly, another mechamsm-short-cn-cuit \nenu\u00admeration tends to produce better reductions the more com\u00adplex the formula, so in combination we are \nable to handle complex formulae and larger scopes. This approach has already made feasible the analysis \nof small specdicatlons; Nltplck found an anomaly m Microsoft Word s style mecha\u00adnism in 4 seconds for \nwhich a straightforward enumeration would have required 70 hours UD95]. We are now embarkmg on the analysis \nof larger specifications. Our reductions, although exponential, do not grow as fast as the space of cases, \nso the checking problem for fimte scopes remams fundamentally retractable. Whatever successes we achieve, \nenumerative checking of software is hkely to be a game of brmksmanshlp, teetering on the edge of intractabdny. \nAcknowledgments Many thanks to Brendan McKay for providing us with code (not included m his Nauty program) \nfor Isomorph-free gener\u00adation. Thanks also to Merrick Furst and Steve Rudich for some helpful early discussions \nabout graph lsomorphism; to Anthony Hall and the referees for their comments on the paper; to Jeannette \nWing, Darrell Kindred and the other mem\u00adbers of the software group for their critlclsm of our approach; \nto John Slaney for running hls FINDER tool on our examples; and to Jacob McGuire for collecting the performance \nnumbers of a prewous draft. Appendix: Proofs of Lemmas Lemma 2. For any formula f and corresponding interpreta- \nLemma 1. For any pair of corresponding interpretations I and lW, and for any expression e of type (Le, \nRe) 1 [e] = (a(Le, U), R, @le, U)) e IW[e] = R Proof. By structural mductlon. Throughout assume that \nexpression s has type (Ls, Rs), t has type (Lt, Rt) and let 1[s] = (a(Ls, U), RS, a(Rs, U)) , I[t] = \n(a(Lt, U), RT, a(Rt, U)) Case 1: e is a variable (obvious from construction). Case 2: e is a constant \n(easy). Case 3:e=s; t 1[s;t] = U(U,Ls) ;RS;@s, U) ;dU, Lt) ;RT ;a(Rt, U) {by conventional semantics) \n= m(U, Ls) ; RS ; o-(Rs, Lt) ; RT ; a(Rt, U) (by property of wirings) = o_(U, Ls) ; ~w[S] ; a(Rs, Lt) \n; Iw[t] ; a(Rt, U) (by hypothesis) = o(U, Ls) ; ~W[S; t];dRt, U) {by wired semantics) Case4:e=s Ut. 1[s \nu t] = a(U, Ls) ;RS;u(Rs, U) U a(U> Lt) ; RT ; a(Rt, U) (by conventional semantics) = o-(U, Ls) ; (RS \nU a(h) U) ; u(U, IJ) ; RT ; c&#38;, U); oiU> Rs)) am.s, u) ~by property of wirings) = o(U, h) ; (RS \nU a(h, Lt) ; RT ; cJ(Rt, Rs)) ; dt$, U) (by property of wirivgs) = a(U, Ls) : (~&#38;] U 17(h, Lt) ; \nlW[t] ; 17(Rt, RS)) <@s, u) {by hypothesis) = CT(U,Ls) ; ~w[S U t];a(Rt, U) (by wired semantics) Case5: \ne= sn t.Same as case 4. Case 6: e= s-. l[s-] = (a(U, Ls) ; RS ; cr(Rs, U))\u00ad {by conventional semantics) \n= a(Ls, U) ; RS-; cT(U,Rs) = Iw[s]\u00ad (by hypothesis) = Iw[s-] (by wired semantics) Case 7: e = s . Same \nas case 6. tions 1 and IW, [W+f * Iw+f Proof. By structural induction; only the base cases are non\u00adtrivial. \nThe cases of the logical connective are trivial. Assume that expression s has type (Ls, RS), thas type \n(Lt, Rt) and let 1[s] = (cJ(Ls, U), R&#38; WU, U)) I[t] = (a(Lt, U), RT, a(Rt, U)) Case l: f=s~t. I[t] \n= (m(Lt, U), RT, a(Rt, U)) = a(U, Ls) ; c7(.LS, U) ; CT(U,Lt) ; RT ; u(Rt, U); u(U, k) ; dRs, U) {by \nproperty of wirings) = (0-(Ls, U) , (ofLs, U) ; a(U, U) ;RT ; o(Rt, U) ; m(U, Rs)), cr(R&#38; u)) (by \ndefinition of triple) = (a(Ls, U) , (a(Ls, Lt) ; RT ; o-(Rt, Rs)), o(Rs, U)) (by property of wirings) \n= (cdLs, U) , (U(b, Lt) ; Iw[t] ; c@> I+)), dR.s, U)) (by lemma 1 on RT) 1[s] = (a(Ls, U), RS, (@, U)) \n(by definition) = (cr(,Ls, u), Iw[s], U(RS, u)) (by lemma 1 on RS) M[s ct] = 1[s] g I[t] = (o(Ls, U), \n~W[s], u(Rs> U)) ~ (a(b, U) , (a(Ls, Lt) ; IW[t] ; a(Rt, Rs)), c@_, U)) Now (a, R, a ) c (m, R , o \n) iff R c R (since CJand o- are bisections), so M[s G t] = lWIS] G a(Ls, Lt) ; lW[t] ; a(Rt, Rs) = MW[S \nC t] Case 2: f = func(s). 1[s] = (cd-h-, U), lWIS], u(Rs, U)) and the wirings are total bijectlons, so \n1[s] is a function exactly when Ids] is. References [B+94] [BC+92] [BG94] [BH94] [BS92] [CFJ93] [DK94] \n[ELL94] [ES93] [ES94] [GGH90] [Hay93] [Ho191] [ID93] J. Bicarregul, J.S. Fitzgerald, I?A. Lindsay, R. \nMoore and B. Ritchie. Proof in VDM: A Practitioner s Grde. FACIT, Springer-Verlag, 1994. J.R. Burch, \nE.M. Clarke, K.L. McMillan, D.L. Dill and L.J. Hwang. Syrnbohc Model Checking: 1020 States and Beyond. \nInformation and Computation, Vol. 98, No. 2, pp. 142-170, June 1992.  J. Bowen and M,J,C. Gordon. Z \nand HOL. Z Usev Workshop, Cambridge, England, 1994, Springer- Verlag Workshops in Computing, pp. 141-167. \nRudolf Berghammer and Claudia Hattensperger. Computer-Aided Manipulation of Relational Expressions and \nFormulae Using R4LF. Technical Report, Institut fur Informatik und Praktlsche Mathematik, Christian-Albrechts \nUniversitat Zu Kiel, Kiel, Germany 1994. Belaid Benharnou and Lakhdar Sais. Theoretical study of symmetries \nm propositional calculus and applications. Automated Deduction (CADE-1 1): Proc. 11th International Conference \non Automated Deduction, Saratoga Springs, M, June 1992. Lecture Notes i~ Artificial Intelligence, Vol. \n607, Springer-Verlag, Berlin, 1992.  E.M. Clarke, T. Filkorn and S. Jha. Exploltmg sym\u00admetry in temporal \nlogic model checking. Fifth International Conference on Computer-Aided Verij$catton, June 1993. Jeffrey \nDouglas and Richard A. Kemmerer. Aslantest: a symbolic execution tool for testing AsIan formal specifications. \nProc. of International Symposium on Software Testing and Analysis, Seattle, August 1994. Rene Elmstrom, \nPeter Germ Larsen and Poul Bogh Lassen. The IFAD VDM-SL toolbox: a practical approach to formal specifications. \nACM SIGPLAN Notices, Vol. 29, No. 9, September 1994.  E. Allen Emerson and A. Prasad Sistla. Symmetry \nand Model Checking. Proc. Fifth International Conference on Computer-Aided Verification, June 1993. Marcm \nEngeI and Jens Ulrlk Skakkebaek. Applying PVS to Z. Techmcal Report ID/DTU ME 3/1, ProCos Project, Department \nof Computer Science, Technical University of Denmark, Lyngby, Denmark. Stephen Garland, John Guttag and \nJames Horning. Debugging Larch Shared Language Specifications. IEEE Transactions on Software Engineering, \nVol 16, No. 9, 1990. Ian Hayes. Speczficatzon Case Stud~es. Second ed.  Prentice Hall International \n(UK) Ltd, 1993. Gerard J. ,Holtzmann. Design and Vahdatzosz of Computer Protocols. Prentice Hall Software \nSeries, Prentice Hall, 1991. C. Ip and D. Dill. Better verification through sym\u00admetry. Proc. 1 lth International \nSymposium on Computer Hardware Description Languages and their Applications, April 1993. Uac94] Uac96] \nUD96] Uon92] [Kur86] [Kur94] [LL91] [McK81] [McK94a] [McK94b] [S1a94] [Spi92] [ss93] [Sta91] ~a191] ~080] \nDaniel Jackson. Abstract model checking of infimte Proc. Formal Methods Europe, sPeclficatlons. Barcelona, \nSpain, October 1994. Daniel Jackson. Nitpick: A Checkable Specification Language. Proc.Workshop on Formal \nMethods m Software Practice, San Diego, CA, January 1996. Daniel Jackson and Craig A. Damon. Elements \nof Style: Analyzing a Software Design Feature with a Counterexample Detector. Proc. International Symposium \non Software Testing and Analysis. San Diego, CA, 1996. R.B. Jones. ICL Proof Power. British Computer \nSociety Formal Aspects of Computer Sczence, Series 3, l(l), 1992, pp. 10-13, R.l? Kurshan. Testing Containment \nof Omega-Regular Languages. AT&#38;T Bell Laboratories, Techmcal Report 1121-861010-33 (1986). R.l? Kurshan. \nComputer-Atded Verification of Coordinating Processes: The Automata -Theoretic Approach. Princeton University \nPress, Princeton, New Jersey, 1994. Peter Germ Larsen and Poul Bogh Lassen. An exe\u00adcutable subset of \nMets-IV with loose specification. In S. Prehn, W!J. Toetenel (eds.), VDM 91: Formal Software Development \nMethods, Vol. 1, Lecture Notes in Computer Science 551, Springer-Verlag, 1991. Brendan D. McKay. Practical \ngraph isomorphism. Congresses Numerantium 21 (198 1), pp. 499-517. Brendan D. McKay. Nauty User s Guide, \nversion 1.5. Computer Science Department, Austrahan National University, GPO BOX 4, ACT 2601, Austraha. \nBrendan D. McKay. Isomorph-free exhaustive gen\u00ad eratton. Unpubhshed manuscript. Computer Science Department, \nAustrahan National Umversity, GPO Box 4, ACT 2601, Australia. John K. Slaney. Finder: Fmlte Domam Enumerator, \nSystem Description. Proc. 12th International Conference on Automated Deduction, Lecture Notes in Artificial \nIntelligence series, Springer Verlag, Berhn, 1994, pp. 798-801. J.M. Spivey, The Z Notation: A Reference \nManual, Prentice Hall International, Second Edltlon, 1992. Gunther Schmidt and Thomas Strohlein. Relations \nand Graphs. EATCS Monographs in Theoretical Computer Science, Springer-Verlag, 1993. I? Starke. Reachabdity \nanalysls of Petri nets using symmetry. Syst. Anal. Model. Stmul., 8 (4/5), pp. 293-303, 1991. Samuel \nH. Valentine. Z--, an executable subset of  Z. In J.E. Nicholls (cd.), Z User Workshop, York, 1991. \nSprmger-Verlag Workshops m Computmg, 1992.  E.J. Weyuker and T.J. Ostrand. Theories of pro\u00adgram testing \nand the apphcatlon of reveahng sub\u00addomains. IEEE Trans. on Software Engineering, vol. SE-6, pp. 236-245, \nMay 1980.  \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Daniel Jackson", "author_profile_id": "81406595262", "affiliation": "School of Computer Science, Carnegie Mellon University, 5000 Forbes Ave., Pittsburgh, PA", "person_id": "PP77026573", "email_address": "", "orcid_id": ""}, {"name": "Somesh Jha", "author_profile_id": "81100352621", "affiliation": "School of Computer Science, Carnegie Mellon University, 5000 Forbes Ave., Pittsburgh, PA", "person_id": "PP79024726", "email_address": "", "orcid_id": ""}, {"name": "Craig A. Damon", "author_profile_id": "81100350976", "affiliation": "School of Computer Science, Carnegie Mellon University, 5000 Forbes Ave., Pittsburgh, PA", "person_id": "P50328", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237733", "year": "1996", "article_id": "237733", "conference": "POPL", "title": "Faster checking of software specifications by eliminating isomorphs", "url": "http://dl.acm.org/citation.cfm?id=237733"}