{"article_publication_date": "01-01-1996", "fulltext": "\n Filter Fusion Todd A. Proebsting Scott A. Watterson University of Arizona University of Arizona Introduction \nFilters are a common data-manipulation abstraction in networking, operating systems, and simulation software. \nFilters read data from a single source and write data to a single destination. In filter applica\u00adtions, \ndata flows from a source to a sink through intermediate filters. Logically, filters are separate, modular \nentities. Modular implementations unfor\u00adtunately suffer a substantial performance penalty rel\u00adative to \nintegrated implementations. Where perfor\u00admance matters most, systems programmers will sac\u00adrifice the \nmodular design for the greater speed of an integrated design. We present a new compiler optimization, \nFilter Fu\u00adsion, that eliminates the overhead of a modular de\u00adsign of independent filters. Our algorithm \nautomates the integration of arbitrary, independently designed filters. FFC, our Filter Fusion compiler, \ncomposes fil\u00adters and produces code that is as efficient as hand\u00adintegrated code. The optimized code \ncan achieve up to a t we-fold improvement over independent filters. Network protocol layers are often \nfilters. Typically, each protocol layer performs some data manipula\u00adtion by traversing the message from \nbeginning to end. Programmers have traditionally merged these filters by hand to produce efficient code. \nIntegrating filters allows data to be read once, manipulated many times, and then stored once, thus avoiding \nloads and stores for each filter s manipulations. Excessive memory ac- Address: Department of Computer \nScience, Uni\u00ad versity of Arizona, Tucson, AZ 85721. Internet: {todd,.aw}@cs. arizona. edu. Permission \nto make digitsl/hard copies of ail or prut of this material for personel or clasaroom use ia granted \nwithout fee provided that the copies are not made or distributed for profit or commercial advantage, \nthe copy\u00adright notice, the title of the publication and ita date appear, and notice ia given that copyright \nia by permiaaion of the ACM, Inc. To copy otherwise, to republish, to post on servera or to redistribute \nto Iiats, requires specific permission and/or fee. POPL 96, St. Petersburg FLA USA @1996 ACM 0-89791-769-3/95/01. \n.$3.50 cesses cripple the performance of network code. Filter Fusion eliminates unnecessary memory accesses. \nManually integrating filters is a time-consuming, error-prone process. In addition, hand-integrated programs \nare difficult to maintain and modify be\u00adcause small changes in a single filter can result in global changes \nin the integrated program. FFC au\u00adtomates the integration process and therefore elimi\u00adnates this concern. \nFurthermore, automatic integra\u00adtion enables the maintenance of a library of useful filters (protocol \nlayers) that can be composed freely to develop specialized protocols. Each library com\u00adponent is maintained \nseparately, and yet integration and optimization is automatic. The programmer de\u00adsigns and optimizes \nin a modular fashion, without sacrificing performance in the final composition. While Filter Fusion is \nwell suited for systems soft\u00adware applications, no assumptions about its problem domain are made. FFC \nplaces few restrictions on the filters it integrates. It handles arbitrary control flow and data manipulations \nwithin each each filter. 2 Related Work 2.1 Network Programming FFC is part of the compiler suite of \nthe Scout project [MMO~95]. Scout aims to deliver high-performance systems soft ware especially communications\u00adoriented \noperating systems. The Scout compilers do non-traditional optimizations, like Filter Fusion, to increase \nsoftware performance and to liberate the programmer from tedious, error-prone tasks [OPM94]. Network \napplications often require many simple manipulations of each network packet. These manip\u00adulat ions form \nthe protocol stack. Redundant mem\u00adory access can dominate the processing time for these applications. \nA technique called Integrated Layer Processing (ILP) optimizes these data ma\u00adnipulations [CT90]. ILP, \na generalization of loop j arnming or loop fusion, does increase performance [CT90, CJRS89, DAPP93]. \nClark and Tennenhouse report dramatic perfor\u00admance improvements from ILP [CT90]. Based on their results, \nthey argue for less modular programming when efficiency is critical and sequen\u00adtial data manipulations \nare too costly, the program\u00admer must abandon abstraction and merge protocols. By automating ILP, Filter \nFusion allows the program\u00admer to retain modular design without sacrificing per\u00adformance. Abbot partially \nautomated ILP for network appli\u00adcations [Abb93]. His system has two significant draw\u00adbacks, however: \nit cannot handle arbitrary control\u00adflow within a filter, and it assumes the typical network data layout \nthat partitions header and data. His pro\u00adtocols had three stages: initial, data manipulation, and final. \nThe integrated code performed the initial and final stages serially with only the data manipu\u00adlation \nstages truly integrated. Not all protocols (e.g., message re-assembly), and certainly not all filters, \nfit into this framework. Filter Fusion has no such re\u00adstrictions. These prior implementations have proven \nthe effi\u00adcacy of ILP, but they have not fully generalized or au\u00adtomated the optimization. Thus, a tension \nexists be\u00adtween modular software design and integrated high\u00adperformance implementation. FFC, an implementa\u00adtion \nof Filter Fusion, provides a solution. While main\u00adtaining a clean, intuitive model for protocol construc\u00adtion, \nit provides both modularity and performance.  2.2 Program Transformation Many different program transformations \nthat im\u00adprove performance by removing redundant compu\u00adtations have been previously studied. Partial evalu\u00adation, \nlistlessness, and deforestation exploit, in one way or another, the basic unfold/instantiate/fold framework \noriginally proposed by Burstall and Dar\u00adlington to improve programs [B D77]. While this sys\u00adtem automated \nprogram transformation rather than program analysis, its framework was revolutionary. Recently, partial \nevaluation has been the dom\u00adinant paradigm for eliminating unnecessary com\u00adputation from programs [JGS93]. \nWhile an over\u00adsimplification, partial evaluation strengthens Burstall and Darlington s work by maintaining \nsignificant state information the state of the static values at all program points during transformation. \nPar\u00adtial evaluation has been applied to functional lan\u00adguages with much more success than to imperative \nlanguages. Filter Fusion is a very limited special-purpose par\u00adtial evaluation system for producer and \nconsumer functions that alternate their computations like co\u00adrout ines. Partially evaluating adjacent \nfilters with respect to a given composition results in a fusion of those filters. Restricting the optimization \nto compos\u00ading filters simplifies the partial evaluation consider\u00adably. Filter Fusion most strongly resembles \nWadler s list\u00adless transformer [Wad84]. This functional program\u00adming optimization composes functions \nthat create and utilize lists into code that avoids building inter\u00admediate lists. Like listlessness, \nFilter Fusion sym\u00adbolically executes programs to create a graph rep\u00adresentations of the residual, composed \nprogram that eliminates intermediate steps (list manipulations for listlessness, and reads/writes for \nFilter Fusion). Fil\u00adter Fusion, on the other hand, operates on impera\u00adtive filters that explicitly read \nfrom and write to one another. Given a function, F, that maps im\u00adperative programs to functional programs, \nand an imperative filter program, P, it would be interest\u00ading to know whether Listlessness(F (P)) is \nisomor\u00adphic to F(FilterF uszon( P)). Whether or not Filter Fusion is isomorphic to listlessness is not \nclear, but the symbolic execution and residual graphs do indi\u00adcate a close relationship. We developed \nFilter Fusion without knowledge of the listless transformer. Deforestation is related to listlessness \nand Filter Fusion, because it too eliminates intermediate struc\u00adtures through symbolic execution [Wad90]. \n 3 Filters A linear composition of filters specifies the path data will follow from source to sink: \nSource --+ Filterl -+ ~. . + FilterN + Sink In a modular implementation, the source produces all of the \ndata before passing it to the first filter. That fil\u00adter then processes all the data before passing it \nto the next filter. This continues until the sink ultimately consumes the data. Unfortunately, this implementa\u00adtion \nrequires that each filter read and write data. It is much more efficient to merge these filters to perform \nall the data manipulations at once. 3.1 Filter Specifications A filter specification is simply a parameterless \npro\u00adcedure extended by three operations: put, get, and filter. A put produces data for the next filter, \nand a get retrieves data from the previous filter. (Filter Fusion will merge filters so that matching \nput s and get s can be replaced by assignments.) filter is a special predicate that guides Filter Fusion. \nfilter guards statements that either require more input or may produce more output. filter is explained \nfur\u00adther in section 5. The first filter of a composition, the source, cannot contain any get s. The \nlast filter, the sink, cannot contain any put s. Figure 1 contains source and sink filters for simple \narray reading and writing. Data manipulation filters exist between the source and the sink. Typical filters \nmay do encryption, com\u00adpression, checksumming, or data marshaling (e.g., byte swapping). In addition, \nglue filters are useful for combining filters that may require special invariants. For instance, the \nsimple filter for swapping pairs of adjacent bytes, 2ByteSwap, requires an even number of bytes as input. \nThe Evener is a glue filter that al\u00adways writes an even number of bytes by simply copy\u00ading its input \nto its output and conditionally append\u00ading a single zero. Thus, the Evener typically precedes 2ByteSwap \nto ensure proper functioning. Figure 2 gives the specifications for 2ByteSwap and Evener. Lightweight \nfilter design encourages modular design and separation of concerns. Typical network protocols such as \nCRC32 check\u00adsum and MD-5 encryption are also filters. Other functions we have implemented as filters \ninclude Run\u00adlength Decoding and Run-length Encoding, simple checksumming, and data marshaling. Filter \nFusion allows the programmer to create arbitrarily complex compositions of these independently developed \nfilters; FFC will integrate them into a single optimized func\u00adtion. Efficiency and modularity are advantages \nof using FFC. Without FFC, reorganizing a protocol stack re\u00adquires re-integrating the stack by hand. \nWith FFC, reorganizing a stack simply requires changing the in\u00addividual filters (if necessary) and specifying \na new composition.  Sample Fusion Filter Fusion is an optimization based on a symbolic execution of \nthe filters. Filter Fusion integrates two filters-a producer and a consume~at a time. The goal is to \nmatch the put s of the producer with the get s of the consumer and to replace them with as\u00adsignments. \nUsing dynamic programming, Filter Fu\u00adsion follows all possible control flow paths through both filters \nwhile tracking the flow of values via the put s and get s. Filter Fusion composes the control\u00adflow graphs \nof the filters into new, larger graph. Where necessary, Filter Fusion replicates filter code. As an example, \nwe will merge the Evener and the 2ByteSwap filters in Figure 2. Figure 3 gives their control-flow graphs, \nRectangles denote nodes from 2ByteSwap throughout this example; ovals denote Evener nodes. The final \ncontrol-flow graph is composed of nodes from the two original graphs, except that the ap\u00adpropriate put \ns and get s are replaced with assign\u00adments to temporary variables. Basically, the dynamic programming \nexecutes each filter symbolically alternating between the producer and consumer at put s and get s, respectively. \nFor each node that is symbolically executed, a copy of that node is placed into the fused graph. Bookkeeping \ninformation main\u00adtained at each node of the final graph controls the composition. Each added node is \nannotated with three pieces of information: the last node executed in the producer, the last node executed \nin the con\u00adsumer, and which filter this node came from. This information is a configuration. Two nodes \nare equal if their configurate ions are identical. The producer symbolically executes until it reaches \na put or end operation. After reaching a put in the producer, execution switches to the consumer, which \nmust execute until it reaches a get (or end). The put that suspended the producer is matched with the \nconsumer s get for subsequent replacement by an as\u00adsignment. This alternating execution continues until \nall possible execution paths are exhausted. The filter predicate will represent a conditional node in \na control flow graph of either the producer or the consumer. The state of a suspended producer determines \nthe value of a consumer s filter predi\u00adcate. If a consumer is executing while the producer is suspended \nat a put, then filter evaluates to true; if the producer is suspended at its end, then filter evaluates \nto false. filter predicates in the producer remain undetermined. 1 Figure 4 depicts the control flow \nof the fused filter after the producer has followed all possible paths to put s or end s. Symbolic execution \nmust now switch to the consumer. When expanding the consumer (2 ByteSwap), the first node to be executed \nis a f ilter predicate. Thus, all three paths will add a filter node. On the left\u00ad most path, the producer \nhad suspended at a end, but on the center and right-most paths, the producer sus\u00ad pended at a put. Therefore, \nconsumer will continue along the false branch when expanding the left-most I This discussion assumes \nthat the producer is driving Fil\u00adter Fusion. If the consumer were driving Filter Fufiion, then the filter \npredicates in the producer would be determined by whether or not the consumer were suspended at a get. \nFilter ReadFromArray Filter WriteToArray Decls Decls int i; int j; Code Code i=O; while filter while \n(i < 10000) get output[j]; put input[i]; j++; 1++; end-while end-while End-Filter End-Filter Figure 1: \nSource and Sink Filters Filter Evener Decls int c, k; Code ~=o; while filter get c; put c; k++ ; end-while \nif (k%2) put o; End-Filter Filter 2ByteSwap Decls int x, y; Code while filter get x; get y; put y; put \nx; end-while End-Filter Figure 2: Sample Filters path, and itwill continue along the true branch when \nexpanding the others. Along the left-most path, the consumer immedi\u00adately encounters an end node. This \npath is com\u00adplete. Along the other paths, the consumer, following the true branch, immediately hits a \nget. The get matches the suspended put of the producer, so exe\u00adcution suspends at the consumer and resumes \nat the producer along both paths. Figure ,5 gives the flow graph at this point. The producer must now \nresume execution by ex\u00adploring all possible control paths from its suspended put. Control continues to \nswitch back and forth until no more progress can be made. A configuration la\u00adbelseach new node. Prior \nto adding anew node, its configuration is checked against the nodes already in the new graph upon a match, \nthe existing node is used rather than the new node. Figure 6shows the graph resulting from this corn\u00adposition. \nFilter Fusion is not finished at this point, however. Some paths reach a get without a corre\u00adsponding \nput. These paths are removed from the control flow, since they make no sense. Trimming of\u00adten creates \na conditional for which only one branch remains in these cases, we may remove the condi\u00adtional too. In \ngeneral, trimming conditionals is an unsafe optimization. If, however, filters are properly composed \nsuch that put s must always reach get s (as they do here), the optimization can be both safe and effective. \nThe nodes to be safely trimmed have dou\u00adble borders in Figure 6. Figure 7 gives the trimmed graph. The \nfinal step of Filter Fusion is transforming the matched put s and get s into assignments to and reads \nfrom a temporary, respectively. The temporary is unique to a particular filter composition. Each sus\u00adpended \nput that is copied into the composition graph becomes a write to the temporary, and all get s be\u00adcome \nreads of the temporary. Figure 8 highlights the transformed nodes in the resulting graph with double \nborders. Evener 2ByteS wap begin be in - k=O filter 8 True False get x end b L9!ll ._ . Figure 3: Original \nbegin k=o 8 Figure 4: Stage 1 Algorithm Filter Fusion is done pairwise, starting with the source and \nits immediate consumer. Because the composition of a source and a general filter is itself a source, \nthis method can compose arbitrarily many filters. (Filter Fusion can operate in the opposite di\u00adrection \ntoo, but giving the less general algorithm here is simpler, ) FFC implements Filter Fusion with a work-list \nal\u00adgorithm. Elements of the work-list represent config\u00adurations that have been added to the control-flow \ngraph (CFG), but whose successors have not. The algorithm is responsible for computing the successors \nand adding them to the CFG and the work-list, when necessary. No computed configuration already in the \n10get y M Control Flow Graphs begin k=O z filter True False &#38;  *** Figure 5: Stage 2 CFG will be \nadded to the work-list, since the previ\u00ad ous inst ante can be reused in its place. This ensures termination. \nIt also bounds number of nodes in the fused graph by the product of the number of nodes in the input \ngraphs. (In practice, the code size will not increase to this maximum, particularly when merging filters \nwith the same size data units.) Figure 9 gives the algorithm. Let z be a CFG node. Its configuration \nis defined by x. orig~roducer], x. orig[consumer], and x. tag. x. orig[prochmer] and x. orig[consumer] \nrepresent the last nodes visited in the two filters when this node was generated. x. tag indicates which \nfilter generated this node. Additional attributes of x, insn and successors, denote the node s  act \nual instruction and its CFG successors. The algorithm begins by adding a start con figu\u00adFigure 6: Untrimmed \nControl Graph bejyn k =0 f,lcer E I get . Eput c p t y put x Figure 7: Final Control Graph Figure 8: \nAssignment Substitution Procedure Fusiono start. orig[producer] := producer s start node // Initialize \nstart node s configuration start. orig[consumer] := consumer s start node start. tag := producer start. \ninsn := empty instruction CFG := { start } // Seed CFG and worklist, worklist := { start } repeat x \n:= Pop(worklist) if x.insn @ trigger[x.tag] then // {put,end} for producer; {get ,end} for consumer. \nthis := x. tag // Stay with current filter. other := not x. tag else // Switch to other filter. thts \n:= not x. tag other := x.tag endif Vi 6 r. orig[this] successors do // Follow all paths. node := new \nnode node. orig[this] := i // Store current nodes. node. orig[other] := x. orig[other] node. tag := \nthis // Tag which filter derived node, node. insn := i.insn if node @ CFG then CFG := (7FG u node Append(worklist, \nnode) x.successors := x.successors u node else // Reuse existing node. x.successors := x. successors \nU CFG [node] endif end V until worklist = q5 end Fusion Figure 9: Algorithm ration that represents the \ninitial nodes of each of the input graphs to both the CFG and the work\u00adlist. start will be the beginning \nnode of the resulting graph. While elements remain in the work-list, they are removed one at a time, \nto compute their succes\u00adsors. Recall that successor nodes may or may not come from the same control flow \ngraph as a node, x, itself (e.g., the successor of a put in the producer comes from the consumer, but \nthe successor of a sim\u00adple statement in the producer would also come from the producer). trigger~roducer] \nrepresents the set of nodes that cause control to switch from the pro\u00adducer to consumer, put and end. \ntrigger[consumer] is a set consisting only of get. not tag alternates between producer and consumer. \nAfter computing the source of x s successors, the algorithm simply follows the control flow from the \npoints to the existing configuration. If the configura\u00adtion is new, it is added to the CFG and the work-list. \nThe new configuration is also the target of the arc from x. last executed statement in that source graph \nto find the actual successor instructions. Each successor has a configuration that is checked against \nthe CFG to determine if it already exists. If the configuration already exists, the control flow arc \nout of x simply The algorithm describes the steps to compute the untrimmed graph. Trimming the graph \nof dangling put nodes is straightforward. Also, a little additional bookkeeping is necessary to transform \nput s and get s into assignment and reads of temporaries.  Experimental Results FFC is a 200-line Icon \nprogram [G G90]. FFC is a preprocessor that generates C code from a compact specification language. We \ntested FFC S code against modular and hand-integrated implementations on a variety of platforms and compilers. \nThe modular im\u00adplementation uses arrays for communicating values between adjacent filters. Because gcc \nconsistently produced worse code than the vendor compilers, we aborted its use. (gee had difficulty re-ordering \nba\u00adsic blocks to avoid chains of jumps. It also did not handle copy propagation and dead-code elimination \nas well as the vendor compilers. ) To test FFGgenerated code, we created different filter compositions. \nOur first test was the following composition. ReadFromArray ~ Evener ~ 2ByteSwap ~ CRC32 ~ WriteToArray \n These filters (1) read bytes from an array, (2) pad arrays to an even length, (3) swap bytes, (4) com\u00adpute \nCRC32 checksumming, and finally, (5) write the bytes to an array. Appendix A contains the speci\u00adfication \nfor CRC32 and the composition, Figure 10 gives the final flow graph. Note that some chunks of code are \nreplicated multiple times and that the graph is quite complicated given the simple nature of its constituent \nfilters. Table 1 shows the size of sev\u00aderal fused filters on both a DEC Alpha and the Sun SPARCsystem \n10. Since FFC may replicate the same code multiple times, the final fused filter may contain a great \namount of C code, Although the C code pro\u00adduced by the Filter Fusion compiler was much larger than that \nof the modular and hand-integrated imple\u00admentations, the object code sizes were very nearly comparable. \nCompiler optimizations eliminate much of the redundancy. FFC-generated code must be optimized because \nof its heavy reliance on temporary variables and arbi\u00adtrary control flow. The code particularly stresses \nand finds deficiencies in a compiler s copy propaga\u00adtion and dead code elimination optimizations. Unfor\u00adtunately, \nin many cases, all of the available compilers failed to eliminate useless counters or to propagate copies. \nIn addition, the compilers did not appear to unroll unstructured loops. Therefore, FFC-generated code \ns performance suffered. Performing these opti\u00admization by hand yields code that performs compa\u00adrably \nto that of the hand-integrated routines. We timed three different implementations of the first five-filter \ncomposition: modular, hand\u00adintegrated, and FFC-generated integration. Table 2 gives the results of running \nthese filters 10,000 times over a 10,000 element array. All tests were run on four different architectures \nusing the vendor s C com\u00adpilers. The second experiment again used five filters. ReadFromArray -+ RLE \n-+ 2ByteSwap + PES -+ WriteToArray These filters (1) read bytes from an array, (2) Run-Length Encode \nbytes, (3) swap bytes, (4) PES en\u00adcrypt bytes, and (5) write the bytes to an array. Timings for 10,000 \niterations over a 10,OOO byte input yields the results in Table 3. Appendix A contains the specification \nfor PES and RLE. The PES encryp\u00adtion simply takes two bytes and creates a new pair of bytes by alternating \nbits from the originals. This filter is a self inverse the original data can be re\u00adcovered from the encrypted \ndata by simply reapply\u00ading the filter. The data-accessing overhead in most encryption methods (e.g., \nRSA, DES) is dwarfed by intensive computation, and therefore gains little from Filter Fusion. The PES \nfilter is not intended to model an actual encryption method, but rather to model an\u00adother lightweight \ndata manipulation [Abb93]. Our third experiment used more new filters. We added a decryption phase, another \nbyteswapping phase, and a decode phase to the previous exper\u00adiment. To verify the correctness of FFC-generated \ncode, we created the following composition. ReadFromArray +. RLE + 2ByteSwap -+ PES -+ PES + 2ByteSwap \n+ RLD -+ WriteToArray These filters (1) read bytes from an array, (2) Run-Length Encode bytes, (3) swap \nbytes, (4) PES en\u00adcrypt bytes, (5) PES decrypt bytes, (6) swap bytes, (7) Run-Length Decode bytes, and \nfinally, (8) write the bytes to an array. Timings for 10,000 iterations over a 10,000 byte input yields \nthe results in Table 4. Appendix A contains the specification for RLD filter. FFC-generated output is \nalways superior to mod\u00adular code. FFGgenerated output typically is slower than hand-integrated code, \nbut only because of the C compiler s shortcomings. Filter Fusion allows the programmer to maintain a \nmodular design and im\u00adplementation without sacrificing performance. This exhaustive computation of all \npossible execu\u00adtion paths is tedious and error-prone when done by hand. Fortunately, FFC, an implementation \nof Filter Fusion, automates this transformation. Filter Fusion allows the programmer to forget about \nthis complex work, and focus on optimizing independent filters in a modular fashion. Program C size \nAlpha Binary Size Spare Binary Size (in lines) (in bytes) (in bytes) Modular Implementation 36 2,784 \n1,955 Hand Integrated 28 2,592 1,898 Filter Fusion 197 2,976 2,323 Fused &#38; Tuned 144 3,040 2,127 \nTablel: Code Size: ReadFromArray +Evener +2 ByteSwap +CRC324WrlteToArray Architecture Fusion Technique \n(in sec.) No Hand Filter Integration Integration Fusion DEC/Alpha 21.9 8.3 9.1 Sun/Spare 26.2 12.0 13.9 \nHP/700 38.5 19.9 28.2 Mips R2000A 66,7 33.9 41.4 Table2: FteadFromArray +Evener+2ByteSwap ~CRC32+ Wri \nteToArray Architecture Fusion Technique (in sec.) No Hand Filter Integration Integration Fusion DEC/Alpha \n22.3 11.9 12.2 Sun/Spare 26.7 13.1 13.5 HP/700 37.0 26.2 30.2 Mips R2000A 64.6 37.6 41.8 Table3: ReadFromArray \n-+ RLE-+2ByteSwap +PES+WriteToArray Architecture Fusion Technique (in set.) No Hand Filter Integration \nIntegration Fusion DEC/Alpha 41.7 20.1 21.4 Sun/Spare 47.2 26.3 33.2 HP/700 68.4 41.3 52.3 Mips R2000A \n121.5 70.1 88.4 Table 4: ReadFromArray +RLE+2ByteSwap +PES+PES+ 2ByteSwap+RLD +WriteToArray References \ncursive programs. JournaloftheACM, 24(1):44-67, January 1977. [Abb93] Mark B. Abbott. ALanguoge-Based \nAp\u00ad proach to Protocol Implementation. PhD [CJRS89] David D. Clark, Van Jacobson, John thesis, University \nof Arizona, 1993. Romkey, and Howard Salwen. An anal\u00ad ysis oftcp processing overhead. IEEE [ASU86] A. \nV.Aho, R. Sethi, andJ. D, Unman. Communications Magazine, June 1989. Compilers: Principles, Techniques, \nand Tools. Addison-Wesley, Reading, Mas\u00ad [CT90] David D. Clark and David L. Tennen\u00ad sachusetts, 1986. \nhouse. Architectural considerations fora new generation of protocols. In Proceed\u00ad [BD77] R. M. Burstall \nand John Darlington. A ings of the SIGCOMM 90 Symposium, transformation system for developing re\u00ad pages \n200-208, September 1990. [DAPP93] Peter Druschel, Mark B. Abbott, // Experiment 2 Michael A. Pagels, \nand Larry L. Pe\u00ad terson. Network subsystem design: A case for an integrated data path. IEEE Network Magazine, \nJuly 1993. [GG90] Ralph E. Griswold and Madge T. Gris\u00adwold. The Icon Programming Language. Prentice Hall, \n1990. [JGS93] Neil D. Jones, Carsten K. Gomard, and Peter Sestoft. Partial Evaluation and Au\u00adtomatic \nProgram Generation. Prentice-Hall, New York, 1993. [MMO+95] A. B. Montz, D. Mosberger, S. W. O Malley, \nL. L. Peterson, and T. A. Proebsting. Scout: A communications\u00adoriented operating system. In Proceed\u00adings \nof the 5th Workshop on Hot Toptcs m Operating Systems, pages 58 61. IEEE Computer Society Press, May \n1995. [OPM94] Sean O Malley, Todd A. Proebsting, and A. Brady Montz. USC: A universal stub compiler. \nIn Proceedings of SIGCOMM 94 Conference on Communacataons Ar\u00adchitectures, Protocols and Applications, \npages 295-306, August 1994. [Wad84] Philip Wadler. Listlessness is better than laziness: Lazy evaluation \nand garbage collect ion at compile-time. In Proceed\u00adings of theA CM Symposium on Lisp and Functional \nProgramming, pages 45-52, August 1984. [Wad90] Philip Wadler. Deforestation: llans\u00adforming programs \nto eliminate trees. Theoretical Computer Science, 73:23 l 248, 1990. A Five-Filter Specification The \nFFC specifications of the Evener, 2ByteSwap, ReadFromArray, and WriteToArray. are given in the paper. \nThe specification below describes the remain\u00ad ing filters used in this paper. Figure 10 shows the first \ncomposition s final flow graph. // Experiment 1 Compose prodeven i-ReadFromArray Evener Compose prodevenBS \n4--prodeven Byteswap Compose prodevenBSCRC + prodevenBS CRC32 Compose fulltest + prodevenBSCRC WriteToArray \nCompose prodRLE + producer RLE Compose BSmid i-prodRLE Byteswap Compose RLencodemid + BSmid PES Compose \nRLencode + RLencodemid consumer // Experiment 3 Compose prodRLE + producer RLE Compose BSmid i-prodRLE \nByteswap Compose pesmid +-BSmid PES Compose unpesmid +-pesmid PES Compose RLencodemid +-unpesmid Byteswap \nCompose RLencode +-RLencodemid RLD Compose massive G RLencode consumer Filter CRC32 Decls unsigned long \ncrc = O; unsigned char idx; unsigned char CRC32temp; Code while filter get CRC32temp idx = (CRC32temp \nA crc) ; idx k= Oxff; crc >>= 8; Crc A= crctable[idx]; put CRC32temp endwhile put crc &#38; Oxff put \n(crc >> 8) &#38; Oxff put (crc >> 16) &#38; Oxff put (crc > 24) &#38; Oxff End-Filter Filter RLD Decls \nunsigned char item, count, number; Code while filter get item get number count = o; while (count < number) \nput item cou nt++ ; endwhile endwhile End-Filter Filter RLE Decls unsigned char current, next, count; \nCode if filter get current endif while filter count = 1; get next while (filter F&#38; (current == next)) \ncount++ ; get next endwhile put current put count current = next; endwhile End-Filter Filter PES Decls \nunsigned char pesl, pes2; unsigned char outl, out2; co&#38;? while filter get pesl get pes2 Outl = (pesl&#38; \nOxaa) + (pes2&#38;Ox55); out2 = (pes2k Oxaa) + (pesl &#38; 0x55); put Outi put out2 endwhile End-Filter \n la .M E 5T  /  I * 3 ..+.,14., .W. v u , I m ,,OM - $ti.Nkl !*.<., .., -,,.= >>,,.0. , ,*.-Q/l pm:* \n,* ,.. . ,1, -*.*!-! ,W..!lk.,. (->>,4,.0, ,.. -[l, . :&#38;! . Figure 10: Final Composition: ReadFromArray \n-+ Evener + 2ByteSwap -+ CRC32 + WriteToArray. (Note the nonstructured control flow in the lower-right.) \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Todd A. Proebsting", "author_profile_id": "81100592757", "affiliation": "Department of Computer Science, University of Arizona, Tucson, AZ", "person_id": "P283229", "email_address": "", "orcid_id": ""}, {"name": "Scott A. Watterson", "author_profile_id": "81100513863", "affiliation": "Department of Computer Science, University of Arizona, Tucson, AZ", "person_id": "P261241", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237760", "year": "1996", "article_id": "237760", "conference": "POPL", "title": "Filter fusion", "url": "http://dl.acm.org/citation.cfm?id=237760"}