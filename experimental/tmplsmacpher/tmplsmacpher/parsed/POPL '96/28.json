{"article_publication_date": "01-01-1996", "fulltext": "\n ~o~l~osillg Ilocesses Kohei Honda* Department of Computer Science University of Manchester Oxford Road, \nManchester M13 9PL, England kohei@cs, Abstract We present a theory of types for concurrency based on \na simple notion of typed algebras, and discuss its applica\u00ad tions. The basic idea is to determine a partial \nalgebra of processes by a partial algebra of types, thus controlling process composability, just as types \nin a typed applica\u00adtive structure [25] determine composability of elements of the underlying applicative \nstructure. A class of typed algebras with a simple operator for process composition are introduced, which \nare shown to encompass a wide range of type disciplines for processes, placing extant theories such as \nMilner s sorting [22] and Lafont s typed nets [20] on a uniform technical footing, suggesting gen\u00aderalisations, \nand offering a secure basis for integration. We also prove that the class of typable operations in the \nunderlying partial algebras is completely characterised by a certain modularity principle in process \ncomposi\u00adtion, which gives us the basic understanding on the na\u00adture of the type disciplines representable \nin the proposed construction. 1 Introduction This is an elementary study of composability of pro\u00ad cesses. \nGiven a set of processes and all possible ways of composing them, some composition may be desirable while \nsome may not, in view of the resulting computa\u00ad tional behaviour. The field of science which addresses \na similar problem domain in the setting of sequential programs, is called the study of type disciplines \nfor pro\u00ad gramming languages, which has offered useful contribu\u00ad tions to the extent that well-developed \ngeneral theories as well as significant applications are at hand [8, 24, 25]. A simple yet basic mathematical \nstructure arising in the study is a typed applicative structure [25], where if an element el has a type, \nsay, Nat + Nat, and another el\u00ad Supported by EPSRC Fellowship. permission to make digitaI/hard copies \nof aII or part of this matetia] for per-sons] or classroom use is granted wirhout fee provided that the \ncopies are not made or distributed for profit or cmnrnemial advantage, the copy\u00ad right notice, the title \nof the publication and its date appear, and notice is given that copyright is by permission of the ACM, \nInc. To copy otherwise, to republish, to post on servers or to mdistribu~ to Ma, requires specific permission \nand/or fee. POPL 96, St. Petersburg FLA USA 01996 ACM 0-89791 -769-3/95/01.. $3.50 man, ac. uk ement \ne2 has a type, say, Bool, then the composition e 1 . e2 is prohibited. Note, in this way, the algebra \nof the underlying applicative structure becomes partial. While the framework has varied ramifications, \ne.g. im\u00adplicit typing, the central idea remains essentially the same, even in highly developed typed \nfunctional pro\u00ad gramming languages. Practically speaking, partiality in algebra precludes careless composition \nof program phrases, which may result in undesirable situations such as run-time constructor error or \ndivergence. The present work tries to follow a similar path in the context of concurrent computing. Thus \nwe start from a simplest possible algebraic framework, embodying ba\u00adsic elements of process composition, \nand build a typed algebra. The key observation concerning the general algebraic framework is that, as \nfound in process alge\u00adbras, composition of processes is done not only at the level of processes but also \nat the level of communication ports. Thus we first stipulate that elements of our alge\u00adbra should be \nequipped with the notion of free names, i.e. for each element P of an algebra, we equip F,V(P), the set \nof free names of P. Now a conspicuous fact about semantics of processes cesses such as behavioral relations \nare all closed ample: both a.~ + ~.a in CCS [2 I], where w is because the semantic structural correspondence \nis that basic relations over pro\u00ad equivalences and reduction under bzject ive renaming (an ex\u00adw a/~ and \ne.~ + ~.e w el~ hold is the strong bisimilarity). This role of names is to represent of interface points \nbetween processes. Note also that the very example above shows that the same may not hold for non-bijective \nname sub\u00adstitution, e.g. e.~ + F.e # el~. This motivates the intro\u00adduction of renammg operations on processes: \nfor each bijection a over the set of names, we have a unary oper\u00adation P [u], which obeys certain coherence \ncriteria, such as P[az o Cl] = P[CT1][Cr2] and .TJV(P[U]) = CJ(.FJV (P)). This defines a simple structure \nof processes and names, on which we introduce an algebra for com\u00adposing processes. It relies on the second \nobservation, which concerns the equation on free names as found in the usual parallel composition, i.e. \nTM(PIQ) = Yfl(P) U TN(Q). Understanding that each free name denotes a point of connection for composing \nprocesses, the equation says that all original ports in P and Q, including those used for composition \nof two processes (represented by names common to P and Q), can al\u00adways be used for further composition \nagain, allowing in effect arbitrarily overridden connections among pro\u00adcesses. In this sense, the equation \nis based on a quite /iberal philosophy for process composition. Then if we introduce partiality in this \nsetting, where certain ways of connecting ports may be prohibited, we are to have the whole spectrum \nof restricted composability, starting from the least constrained one (when the operation is total) and \nending up with the case where no composi\u00adtion is possible (when the operation is empty). The par\u00adtial \noperation for parallel composition is written P Q, which we assume to be (partially) commutative and \nas\u00adsociative, cf. [3], and closed under renaming. We do not consider other operators like prefix or hiding \nin or\u00adder to keep the algebraic framework as simple as possi\u00adble. Moreover preceding works such as [16, \n17] suggest we may, in principle, develop algebra of processes with\u00adout prefix operators, while hiding \nmay be catered for by types, as we shall discuss later. Types are conceived without no proper type constructor, \nbut are given a spe\u00adcific structure of a partial binary algebra. Each process is typed by associating \nits free names with types, which completely determine the partial algebra of processes. Thus two processes \nare composable if and only if each pair of their ports to get connected, own composable types with respect \nto the underlying partial algebra of types. A notion of typed reduction then ensures that the consistency \nof typed composition is maintained dur\u00ading computation. The framework is quite simple; but it does contain \nbasic elements of process composition, such as possibility of arbitrary connection of ports, which are \npart of the major sources of diversity and complexity of concurrent computing. Indeed it turned out that \nthis simple framework is already rich in theory and applications. On the theo\u00adretical side, the framework \nallows us to give a rigorous description of a strong modularity principle in process composability, which \ncompletely characterises the typa\u00adbility in the underlying partial algebras. The charac\u00adterisation gives \nthe basic insight on the nature of typed algebras, as well as suggesting a broader perspective on the \nvaried principles of process composition and their types. On the more concrete side, the class of typed \nal\u00adgebras encompasses a wide range of type disciplines for processes, placing extant theories such as \nMilner s sort\u00ading [10, 22, 27 , 30, 31] and Lafont s typed nets [7, 20] on a uniform technical footing, \nsuggesting new type dis\u00adciplines of practical significance, and offering a secure basis for integration. \nHopefully these constructions and results will become a cornerstone for effective utilisa\u00adtion of the \npresented framework in theory and practice, contributing to the sound development of principles of typed \nconcurrent programming. The purpose of the present paper is to convey the ba\u00adsic ideas and results of \ntyped algebras together with their important applications, without going into too much technical details. \nSee [15] for the full develop\u00adment of the theory of typed algebras. See also a se\u00adries of the author \ns study on semantics of processes [11, 12, 13, 14,-15] which form the general mathemati\u00ad cal backgrounds \nof the present work. In the rest of the paper, Section 2 presents the basic elements of typed algebras. \nSection 3 gives the main theoretical result, characterisation of the typability among the underlying \npartial algebras by a modularity principle called strict additivity. Sections 4 and 5 discuss concrete \nexamples of typed algebras, emphasising how type disciplines result in significant behavioral properties \nof processes, start\u00ading from Milner s sorting for m-calculus and Lafont s typed nets, proceeding to novel \ntype disciplines which extend those two, and finally showing how we can inte\u00adgrate the higher-order nature \nof sorting into these (and any possible) typed algebras. Section 6 gives a brief discussion, including \ncomparisons with related work. 2 Algebra for Typed Processes 2.1 Partial Milner Algebra We start from \nthe formulation of a simple structure based on processes and names, introduced in [1 1]. Definition 2.1 \n(rooted process structure) Fix a count\u00adable set N of names, ranged over by a, b, c, . Then an N-rooted \nprocess structure, or simply a rooted process structure, is a set P of rooted processes, ranged over \nby P, Q, R, . . . . together with a function TN : P -+ 2N, as well as the set of bisections {u} over \nN acting on ? in the way: ( 1). P[cr] [d] = F [a o u] (o is a functional composition). (2). (Va E FN(~). \na(a) = a) a P[cT] = P. For simplicity we assume FN(P ), the set of free names of P, to be finite. Throughout \nthe rest of the paper we fix N as given. Intuitively a rooted process P denotes an entity hav\u00ading several \ninterface points with the outside, which are labelled by (or rooted to) names, given by 3N(P ). Rooted \nprocesses are simply called processes from now on. Axioms (1) (2) (3) make renaming operations be\u00adhave \nas we expect them to. Examples of rooted process structures include most process algebras and concurrent \nprogramming languages, forgetting various constructors and sometimes regarding variables as names when \nnec\u00adessary. [11] studies this structure and its algebra in detail. See also [14] for discussions on related \nworks in a different context by Nerode. Aczel and others. Let 7 be a rooted process structure. Then a \npar\u00ad tial binary operaiion@ on~ is apartial function from 7 x P top with (Po Q)[u] + P[a](DQ[a] where \n G means that if the left hand side is defined then so is the right hand side and has the same value, \nsimilarly in another direction. An operation is a way to compose processes, thus some ways of composing \nprocesses may not be allowed in partial operations. The following de\u00adfines a partial algebra over a rooted \nprocess structure, which forms the background of our present study. Definition 2.2 A partial Mdner algebra \nis a rooted process structure 7 together with a partial binary op\u00aderation e on P and a specific process \nO E P such that, for any F , Q and R, we have: (i) P*O = P PeQ ~ QeP (PoQ)eR ~ Pe(QeR). (ii) Iff(;~ \nis defined, then FJV(P e Q) = TN(P) U  where = says that both sides are defined and have the same value, \nin contrast to =. A., l?, . . . . or sometimes AP, B~, ..., making the underlying process structure explicit, \ndenote partial algebras. It is easy to check that $Af(0) = 0 and O is unique. e can be understood as \na semantic form of parallel compo\u00adsition operator. The equations in (i) come from Berry\u00adBoudol s Chemical \nAbstract Machine [3], The equation (ii) is the free name equation as found in process al\u00adgebras, on which \nwe already discussed in Introduction, and which, as far as we know, first appeared in the orig\u00adinal study \nof C,CS [2 I], hence the name of the algebra. The typed algebras we shall investigate arise as a special \nsubclass of the whole class of the above partial algebras.  2.2 Types and their Algebra The basic idea \nunderlying the present theory is to con\u00adtrol partial algebra of processes by partial algebra of types, \njust as in typed applicative structure. For the algebra of types to be consistent with the nature of \nthe operation o, it also needs be (partially) associative and commutative. Indeed this is the only condition \nwe im\u00adpose on the structure of algebra. Definition 2.3 A type structure is a set of types T (a, fl, ) \ntogether with a partial binary operation @ on T, such that: a @I 0 G p@cY and (a@9)@Y = CJ@(~@y), foralla, \n~, y&#38;T, Given a type structure, the essential tool for its un\u00adderstanding is the composabiliiy ordering, \ninduced by the partial algebra of types. Below &#38; : T x T T is given by: c@c ~f a and Q&#38;)/30 \n~ ~f (a @ /30)&#38;~ where, in El ~f E2, we put El as undefined when E2 is. Definition 2.4 (composability \npreorder) Given T, we define the relation < on T by: al ~ Q2 ~f VP c T . (al~~ defined* cYZ&#38;~ defined.) \n< is called the composability preorder in T. We can easily check < is indeed a preorder. We can also \neasily check, by associativity of @, that al < az iff for all ~, al @ /? defined implies cr2 @,6 defined. \nThe above definition makes it clearer that we are concerned with hereditary comparison of composability. \nSince a ~ /l and ~ ~ a mean a and ~ have exactly the same degree of composability in a given type structure, \n~ may well be a partial order. We say a type structure 1s ezfenszonal if the composability ordering is \nindeed a partial order. As the following shows, an arbitrary type structure induces its extensional counterpart. \nProposition 2.5 Given a ~ype structure T and the composabiliiy ordering <, the standard quotient T/ < \nis an extensional type struciure, where we define the al\u00ad gebra as: [a]< o[~]< *f [a@/3]<. In the above, \nthe well-definedness of @ relies on the following fact: if al < aa and /31 < @z, then whenever CYl @ \n/31 is defined then so is az @ &#38; and we have al @ pi <CY2C9P2. In some practical situations, the \norder-theoretic prop\u00aderty (in terms of <) of a given type structure becomes important. In Section ,5, \nwe shall see one such example, where existence of finite joins is useful. The following gives a procedure \nwhich converts any type structure to the one with all finite joins. Proposition 2.6 (semi-lattice completion) \nGZ ven T, let A, B, . . . . C denote non-empty jinite sets of types from T. Dejine ~ as a type structure \nso that: (i) Types: The non-empty finite subsets of T which are either singletons or, if not, which do \nnot have a join in T. Let A, B, . . . denote them. (ii) Algebra: A @ B is defined iff a @ /3 is defined \nfor some a c A and /3c B. If soput C asthe set of the results of composing those composable pairs of \ntypes, one from A and one from B. Then A @ B is given as {VC} if C has a join in T, as C itself if not. \n Then ~ is a ~oin-semi-lattzce, mto whzch the map a ++ {CY} gzves an order-ernJeddmg from T. Indeed \nthe Joins in the new structure are given by: A V B = {V(A U B)} if such exists in the original structure, \nand, ifnot, AVB=AUB. 2.3 Typed Processes and Reduction has a type I and a tuple (P . I ) with r = type(P)). \nGiven a partial Milner algebra and a type structure, we now want to type the processes in the former \nby the types in the latter. Types are assigned to ports of a process, which are the actual points of \ncomposition with another process; hence one type is given to each free name of a process. We start from \nthe notion of type assignments. Definition 2.7 Given the set of types T, we define: TAT ~f {r /r :A + \nT, AcM, A finite}. TAT k the set of iype assignments from T to ~. I , A, ~, . range over TAT. For ease \nof writing we write each el\u00adement of such r as a datum of the form a : a, where a~~anda~~. The following \nnotations are convenient to manipulate type assignments. Definition 2.8 (i) I (a)=d %f a:aer. (ii) ~(r) \n%f {a(a) :a Ia :a r}.  (iii) x(r) % {a Ia :a c r}. (iv) l /A*f{a: a~I ]a$ZA} with ACM. (v) r w A \n$/$ (a c N(f )nAf(A) + r(a)= A(a)).  (vi) r x A %f (a c M(f ) r7.W(A) + 17(a)@ A(a) defined).  (vii) \n17@ A % I /~(A) U A/Af(r) U {a : r(a) @ A(a) I a E.M(I ) nAf(A)} (r x A). Typed Milner algebras are now \ndefined. Definition 2.9 (typed Milner algebras) A triple (Ap, T, type(.)) with type : P -+ TAT satisfy\u00ading \n~(type(P)) = 7~(P) and writing P D 17 for type(P) = r, is called a typed Milner algebra, if the following \nholds: (i) PD r + PIo] Dc7(r). (ii) PDrAQDA + (Po Qdefined @ I =A).  (iii) Pbr AQb AA RbOApeQ=R + \nr@A=@. type(. ) is called a typing function. We often write AT, B~ to denote typed Milner algebras. Note, \nby (ii) and (iii) of Definition 2.9, the composabil\u00ad ity of processes in a typed Milner algebra is completely \ndetermined by the types those processes own together with the partial algebra of types. For ease of writing, \nwe often treat a process and its type together, which we write P D r (so P D 17 stands for both the assertion \nP Then we set: 3J$ (P D I ) % FN(P) (= M(r)). (2.1) (Pb r)[~] &#38;f P[a] Do(r) (2.2) P~r QPA = PoQhr@A \n(2.3) where, in (2.3), we regard the left hand side is defined if and only if the right hand side is \ndefined. Note this gives essentially the same partial algebra as the original one (they are isomorphic \nas partial Milner algebras, cf. [15]). To define the notion of reduction in typed Milner al\u00adgebra, we \nuse composability ordering discussed in the previous subsection. Some terminology: a relation 7? over \ntyped processes in some typed Milner algebra is closed under renamzng iff P p r 7? Q b A implies (P D \nI )[u] 7? (Q D A)[a]. It is closed tinder paraliei com\u00adposition iff Pb rRQ bA and P b I %?Q b A with \nr~r and Ax A imply (PDroP br )~(QDAo Q P A ). Definition 2.10 (typed reduction) A typed reductzon in \na given typed algebra A~, often written -, is a preorder over typed processes closed under renaming and \nparallel composition, which should satisfy: P~r-.+.QpAa (a:aEA*3P.a:,6ErAp<a) If a preorder 7? over AT \nsatisfies the above property, we say it has the subject reduction property. The condition in the above \ndefinition says that, as re\u00adduction proceeds, a process should always become easier to get composed. \nAs a consequence, we get: Proposition 2.11 If B is a typed reduction in a typed h{ilner algebra, then \nP b r -Q PA and P D r with r x A imply f x A, and, therefore, (PDr@P Dr ) (Q DAo P Dr ). Thus local \nreduction within a legitimate configuration always leads to a legitimate configuration again. If we regard \n as a parallel composition of processes, the above condition would be the minimum requirement on the \ncoherence between dynamics and typability. We also note that the increase in composability ordering is \nnot only theoretically consistent in the above sense but also is useful in concrete applications, as \nwe shall see in Sec\u00adtion 5.1. We close the section with one basic result on typa\u00adbility, which illuminates \nrelationship between process composability embodied in a typed algebra and the un\u00adderlying type structure \n(for the proof see [15]]. We say a typed Milner algebra (Ap, T, type(.)) is fully typed, ifforanyaETwecanfind \nsomePandaE7JV(P) such that type(P)(a) = CX. Proposition 2.12 (uniqueness of type assignment) If (i) \nand (ii) ~ hold, the algebra is addittve. This says that mutually disjoint legitimate connections always \n(i) Let (AP, T, type(.)) be a fully typed Milner alge-add up to form another legitimate connection (with \n(i) bra. Then define type (.) : P --+ TA~I< by: serving as the starting case). If (ii) < holds, the algebra \n a : [d]< ~ type (~) !$ a : a E type(P). is semi-additive. This says that any legitimate connec-Then \na trzple (Ap, T/ <, type ()) is again a f~~hl tion can always be decomposed into its parts to form typed \nMzlner algebra where T/ < as edensional by legitimate connections again. As a whole, the defini-Proposition \n2.5. tion says that the judgement of composability is a syn\u00ad onym for that of connectability of individual \nports. Here (ii) Suppose AT and AT are fully typed. Then ifT and the modularity in judging composability \nis our foremost T are extensional, they are isomorphic in the sense concern. For the typable class of \npartial algebras, we that: there is a bijection @ from T to T such that just define: G 7J(cr @@). @(@) \n@ @(P) Definition 3.2 A partial Milner algebra AP is typable if there exists a typed Milner algebra (Ap, \nT, type())  3 Characterisation Theorem for some T and type(.). 3.1 strict Additivity 3.2 Characterisation \n In this section we give a complete characterisation of ty-The main theorem follows. pability among the \nunderlying partial algebras. It uses a notion representing a basic modularity concern in pro- Theorem \n3.3 (Main Theorem, Characterisation) cess composability called strict additiuity. The class of stricily \naddtitve partial Milner algebras and We start from defining a pure notion of connection ihe class of \ntypable partial Mtlner algebras coinctde. in the present setting. Suppose Y.M(P) n $JV(Q) = 0. Then a \nbijection IJ over ~ is called a correspondence Before the outline of the proof, we give some discussions \nbelween P and Q (cf. [11]) if the following holds: on the theorem. (1)By the theorem, any partial Milner \nalgebra (or a (i)a:a~b+a ~ (a EfN(P)Ab Er~(Q))V formalism inducing one) which obeys the principle (a \nE FM(Q) A b 67N(P)). of strict additivity, is immediately known to be ty\u00ad (ii) u- = u. pable by a certain \ntype structure. A suitable type structure, especially algebra of types there, often So a correspondence \nconnects ports of P labelled by exposes essential aspects of a given notion of pro\u00ad some names to ports \nof Q labelled by other names as cess composability in a concrete way and suggests a self-inverse bijection \nbetween them. Two correspon\u00adfurther extensions, cf. Sections 4 and 5. dences U1 and uz between P and \nQ (with FN(P) fl 3JV(Q) = 0 implicit] are dis-jomt when, if al : a -b # (2) Conversely, if a partial \nMilner algebra is typable a, then U2 : a = a, and, conversely, if V2 : a * b # a, by a type structure, \nwe know it is strictly additive then al : a ti a. Thus two disjoint correspondences without exception. \nThis gives us the general under\u00adconnect disjoint sets of ports to disjoint sets of ports. standing on \nwhat kind of composability principle If al and U2 are disjoint, we can take their sum, writ-the concerned \ntype structure captures, which, in ten al ~ cz, which is another correspondence, setting turn, tells \nus its essential limitation of the present a10u2:a ~bifand onlyif notion of typed algebras, in the sense \nthat it does not go beyond strict additivity. This direction is gl:a*b#aVu2:a_b# aVa=b. also made use \nof in Sections 4 and 5. (3) Indeed, one may ask what principles of processNow we are ready to give a \nspecific subclass of partial composition are not represented in strict additiv-Milner algebras which \nembodies a basic modularity con\u00adit y. As a first step, we can take two decomposi\u00adcern in composability. \n tion of strict additivit y noted after Definition 3.1. In sem i-additivity, we can prohibit a compositionDefinition \n3.1 (strict additivity) A partial Milner al\u00ad where the sum of individually legitimate local con\u00ad gebra \nis strictly additive it nections results in an undesirable configuration, as (i) FAr(P) n 7N(Q) = 0 * \nP e Q defined. in the criteria for deadlock-free property [5, 7, 20] (cf. Section 4.3); while additwity \ncan prohibit a (ii) P[al] o Q and P[az] * Q are both defined # composition which results in an incomplete \nconfig\u00ad  P[al @ az] e Q is defined. uration. It is an interesting question whether one where, in (ii), \n7N(P) n FN(Q) = 0 and al and u? are can find a characterisation along the line of Theo\u00addisjoint correspondences \nbetween P and Q. rem 3.3 for these and other cases. PROOF OUTLINE OF THEOREM 3.3: Suppose a typed Milner \nalgebra is given. Then we easily know it is strictly additive. The reasoning goes roughly as fol\u00adlows: \nsince the composability of two processes solely relies on types each port owns, if two are composable \nby connecting a set of ports, then each individual con\u00adnection is again possible; in turn, for the same \nreason, if each individual connection, mutually disjoint, is possi\u00adble, then we can do the whole connections \nat one time, which is again legitimate. Connection-less composition is permitted by noting ~(r) n M(A) \n= @implies r x A always. The non-trivial part is the other direction. The rea\u00adsoning uses a type structure \nconstructed from partial algebra of processes as a quotient of ports of processes, modulo a certain bisimilarity \ninduced by a transition relation representing port-by-port composability in a given algebra. Assume given \na strictly additive partial Milner algebra, say AP. We first define the transition relation. Let us write \nP(a) for a pair (P , a) when a G 7~(P). Then we define a transition P(a)oQ(a) = R(a) as: P oQ = R A FM(P) \nnFJV(Q) = {a} which reads: P(a) can be composed to Q(a) and be\u00adcomes R(a). Note a E .FN(R) automatically \nresults from 7Jf(P)rWN(Q ) = {a} by the free name equation. Next we introduce a variant of a bisimulation \nover the transition. A symmetric relation over {P(a) I P c P} is a e-bisimulaiion (pronounced dot bisimulation) \nif the following holds: whenever we have PI (a)RQl (b), if PI (a) R(a) = Pz(a) then we have, for some \nQ2(b) and C, Ql(b)*R[u](o(a)) = Qz(b) such that Pz(a)7?Qz(b). Note we have relativised the bisimulation \nby renaming operation. It is easy to check that the union of all o\u00adbisimulations is the largest -bisimulation \nwhich is also an equivalence relation and is closed under renaming, called the -bisimilaraty, which we \nwrite z. Now the de\u00ad sired type structure is defined as TAP * {P(a) \\ P E P}/ E whose elements we denote \nby a, /3, -y, . . . . and on which we define the algebra by: a@p=~ % 3P, Q,R. (P(a) e Q(cL) = R(a) A \nP(a) E CY,Q(cL) E /?, R(a) c Y). By checking that @ thus given does define a partial function (using \nthe -bisimulations) and is closed by re\u00adnaming, and since it is trivially partially commutative and associative, \nwe know TAP is a type structure. In many senses TAP is the canonical type structure cor\u00adresponding to \nAF, since it indeed gives an extensional type structure to which there is a fully typing from AP (cf. \nProposition 2.11). Here, however, all our concern is to show that there exists a typing function from \nAP to T~P. The typing function, which we write typeAP, is defined simply by: a : ~ e typeAP(P) &#38;f \nP(a We should show this does define a typing function as specified in Definition 2.9. Write P b r for \nr = @PeAp (P), as always. Suppose P b r. Then it is trivial from the construction of typeAP that ~(1 \n) = F. M(P), while P[u] D u(I ) is also easy since, by def\u00adinition, a : [p(a)]= E r and a(a) : [p[c](cT(cL))]~ \nc ~ypeAP (P [u]), but R is closed under renaming, so that P(a) cz P[u](a(a)), hence done. Thus if we \nverify the clauses (ii) and (iii) of Definition 2.9, we are done. (ii) is the most difficult part of \nthe proof, using strict addi\u00adtivity in an essential way. We first note two elementary yet useful facts. \n(i) Given any P and Q, there exists a permutation p such that FJV(P[p-l]) n FN(Q) = @ and, more\u00adover, \np is a correspondence between P[p-l] and Q.  (ii) Given a finite family of mutually dis~oint corre \u00adspondences \n{pi} between the same pazr of processes, write @ p$ for their consecutive sums. Then for any correspondence \nu between P and Q we have: u= @L2, where each Li is a correspondence between P and Q which is a transposition, \nt.e. a permutation which tmchange one pair of names and do no other alteration.  Observe p in (i) exactly \nrelates P [p-1] and Q at those ports represented by fti(P)n3N(Q) in the pair (P. Q). Now suppose P Dr \nand Q b A. We first show if P Q is defined, then r x A. If FN(P) n FN(Q) = 0 then immediately r x A. \nIf not, take some p as given in (i) above for P and Q. Put P = P[p-l] and I = p-l(l ). Then we have P \nDI . Now let p = @ Li with ~i as specified in (ii) above. Take any Li. By semi-additiviiy, we know, for \nsuch Li, P [Li] e Q is defined. So suppose P [~i](a) e Q(a) = R(a). Observing ~i(l?)(a) = I (a), this \nshows that I (a) @ A(a) is defined. The same holds for each a ~ N(I ) n N(A), taking different ~i, so \nthat we know r x A, as required. We next show that, if r x A, P Q is defined, i.e. P and Q are composable. \nIf Af(I ) n N(A) = 0, then by Definition 3.1 P Q is defined. If not, again take p as specified in (i) \nabove for P and Q and let p = @i ~i as specified in (ii) above. Again put P = P[p l] and any Li. Since \nFN(P[Lj]) n FN(Q) = a~ for some ai c YN(I ) n FN(A), we have: p[Li](ai) Q(ai) = Ri(ai) (Rt(ai) c r(ai) \n@ A(ai)) in other words, P [~i] Q is defined for each i. Now using additivity in AP, we know P[p]eQ \nis defined, hence done. Finally the clause (iii) of Definition 2.9 is verified by constructing appropriate \n.-bisimulations. Suppose r x A. Then by the above we already know P Q= R for some R. Suppose r, A, @ \nare type assignments for P, Q, R respectively. If a c F.M(P) but a @ TN(Q), then we should show I (a) \n= ~(a), for which purpose we just form: S ~f {( P(a) R(a)) and show $ is a bisirnulation. Similarly for \nthe case of a E 3N(Q) and a c FM(Q). When a c XAf(P) n Y, M(Q), we should show I (a) @ A(a) = O(a). For \nthe purpose we take p satisfying (i) above, and put P %f P[p-l] and, according to (ii) above, p = @ ~i. \nNow by semi-additivity, we can put, for each i, P [~i](a, ) e Q(ai) = A&#38;(ai). Observing that Rj(a;) \nc r(a, )@ A(a~), we define: 7? ~f {( R(a~) ~R~(a~)) I P e Q = RA Ri, ai as above.} Then the symmetric \nclosure of 7? is a e-bisimulation, from which @(ai) = [R(ai)]% = [Ri(ai)]% = I (ai) @ A (ai), as required. \nThus ty~eAp is a typing function, concluding the proof. We shall use the following result in Section \n4, easily proved using Theorem 3.3. Proposition 3,4 (n-party strict additivity) Lei! Pl, P2, . . . , \nPn be processes of a strictly additive partial Mil\u00adner aigebra such ihat Y.M(Pi) nFN(Pj) nYN(Pk) = 0 \nfor any pairwise disiinct i, j, k. Then ~l<i<n Pi is de\u00adfined if and only if Pi e Pj is defined fo; ;ach \ni # j, where we write ~ ~<%<nP~ for PI ePz @ ... ePn, i.e. n-ary product by e. -- PROOF: Using Theorem \n3.3, we know the statement is equivalent to: Given n typed processes {Pz > I i }, where ~~(p~ P r~) n~~(pj \nD r]) n~fi(pk P rk) = @ for any pairwise distinct i, j, k, we have Pit= I z e Pj b 17j is de\u00adfined for \neach i # j if and only if ~l<i<n pi b l i is defined. But this restated statement is ~m-mediate by inspecting \ncomposabilit y among {I i}. m  4 Applications (1): Sorting and Interaction Net 4.1 Inhoduction to Discussions \non Ap\u00ad~lications In Sections 4 and 5, we discuss several examples of typed Milner algebras, each embodying \na specific type disci\u00adpline for concurrent processes. The aim is to show how the abstract framework and \nresults in the preceding sec\u00adtions can be applied to significant concrete problems of interest. One of \nthe main themes is how diverse disci\u00adplines of process corhposition can be abstracted at the level of \nalgebra of types, as well as how those disciplines are reflected on significant computational behaviour. \nTo facilitate the presentation, we use some conventions, Convention 4.1 Each example is shown as a formal \nsystem, where terms quotiented by certain equations, neglecting extra constructors if necessary, form \npro\u00adcesses in a typed Milner algebra (free names and re\u00adnaming are taken syntactically). On terms a reduc\u00adtion \nrelation is defined, which induces a reduction on processes. Since there is common part which all sys\u00adtems \nown, we pick up that part in Figure 1. As seen, in Term Formation, we close the set under parallel composition \nand renaming, while the rules for Struc\u00ad ture impose partial commutative/associative structure on terms, \nwhere the smallest equivalence relation closed under rules is meant. In Reduction, we again explicitly \nclose the rules under parallel composition and renaming, where the smallest preorder thus closed is meant. \nNote, in this way, the subject reduction property of Definition 2.10 is automatically satisfied if the \nrules specific to a given system satisfy the property.  4.2 Sorting for Polyadic ~-calculus Milner presented \na notion of types called sorting for polyadic r-calculus [22], which was later studied by sev\u00aderal researchers \n[4, 31, 27]. It is not difficult to check sorted terms modulo structural equality conforms to the strict \nadditivity; thus it can be typed, and we will find out that the resulting algebra of types vividly exposes \nthe philosophy of process composition in sorting. Definition 4.2 (type structure for sorting) Let X be \na countable set of type variables. Define: c1 ::= z I (al ...an) Ipx.a where, in ~x .a, we assume occurrences \nof z is guarded, i.e. within some parenthesis. a, a , . . . range over these expressions. Write ~ for \nthe standard unfolding of a as an infinite tree (cf. [31]). Then the type structure Tm is given by the \nfollowing data. (i) The set of types: {Q, g ,.. .}. (ii) The algebra of types: ~@~=~foreach~~Tm,  By \nthe above (ii), a type can only be composed to the same type, and it does not change after connection. \nObserve that this results in an arbitrarily shared con\u00adnection of typed ports, as far as they have the \nsame type. The underlying idea is that types are only used to ensure compatibility of interacting operations; \nthus, as far as compatibility is maintained, arbitrarily shared connection is allowed. The following \ntyped formalism substantiates this idea. Definition 4.3 (sorted ~-calculus) Processes and re\u00adduction \nin Ax is given by Figures 1 and 2. By examining the reduction rules, we can immediately know that + in \nA.m satisfies the subject reduction property in the sense of Definition 2.10. Because it is easy to know \nthat, if P E (~)(a : (Z1..Zn).Qe E : [U1,.Vm].Q2e R) then we always have n = m, the subject reduction \ntells us that typed terms never cause the mismatch in the number of arguments, as was already verified \nin [31]. Term Formation: (unit) (ren) (par) l--Pbr ~ODO ~ r ) Structure: ~ Reduction: Figure 1: Common \nRules Term Formation: (input) 1-a : (xl.. Fppr zn).Pba : (al.. an)) r/{ Xi} (output) FE: kpb [zl..zn].Pba: \n(al..% ), (res) h_PD 1-(a) PP /{a} (rep) kpb m where r x {a: (al..an)} U {xi : ~i} in (input) and (output). \nStructure: . Pb ~Qb wheneverP~@ (a)ob@=obo ((a) P)e Qb = !P S!P *P. (Ua)Pbr (a)(P. Q E(a)PD (ab)Pb \n~(ba)Pb Q)b if a @fN(Q). Reduction: (con) (res) a : (zl..z~).p ti Pb r + QbA : [TJ1,.Vn].Q ~ (a)P b \nr + P /{a} P{?J1..Vn/%l..~n} + (a)Q b A/{a} . Q b r/A where A c {vi} U {a} which no longer occur free \nin P{ol..wn/z1..~n} Q in (con). Figure 2: Polyadic ~-Calculus Term Format ion: (true) 1-true(a) D a \n: bool+ (and] t-and(abc) D a : bool-, b : bool-, c : bool+ (false) h false(a) P a : bool+ (or) 1-or(abc) \nD a : bool-) b : bool-, c : bool+ (not) F not(ab) b a : bool-, b : bool+ (erase) \\ erase(a) D a : bool\u00ad(fw) \n!-fw(ab) D a : bool-, b : bool+ R.educt ion: not(ab) e true(a) ~ false(b) and(abc) e true(a) ---+ fw(bc) \nnot(ab) e false(a) -true(b) and(abc) e false(a)  ifalse(c) e erase(b) erase(a) e C+(a) -0 or(abc) e \ntrue(a) -true(c) e erase(b) fw(ab) e C+(a) C+(b) or(abc) o false(a) ---+ fw(bc) where C+ is either true \nor false. Figure 3: Typed Interaction Nets 4.3 Interaction Net Next we introduce a typed algebra whose \ntype discipline is in strong contrast with sorting. Lafont s Interaction Net [20] was born from Girard \ns proof nets [7], and gives a framework of typed programming based on a graph\u00adical format. We take the \ncase of boolean values and operations on them. The scheme easily generalises to any instance of typed \nnets. To conform to our represen\u00adtation, we use terms instantiated by names to present nets, originally \nused by Simon Gay. The definition of the type structure follows. Definition 4.4 (type structure for interaction \nnets) Tin is given by: (i) The set of types: {bool+, bool-, 1}. (ii) The@gebra: bool @ boo~ = 1, where \n@ E {+, -} and @ is involution. 1  Observe the difference from the preceding algebra. Here a type is \ncomposable to only its opposite type, and the resulting type is absolutely non-composable (such a type \nis called inert; an inert type is unique in an extensional type structure, where it is the minimum element \nw.r.t. <). Thus connection of ports are allowed only when two ports own opposite types, and, once connected, \nno further connections are permitted. In this way, the type discipline prohibits sharing of ports, except \none-to-one connection. The example also shows that the typing by an inert type results in the same effect \nas the hiding. Definition 4.5 (Typed Interaction Nets) Given Tin, we define Ain by Figures 1 and 3. 1For \nreference, we give a type structure for an untyped inter\u00ad action net. There are only two types, T and \n1, and the algebra is: T@ T = 1. So we lose polarity and every port is composable to another, but is \nso only once. We omit types in reduction rules since they are deter\u00admined uniquely from typeless terms. \nNote wire con\u00adnecting a and b [20] is represented by a forwarder fw(ub) originating in the actor model \n[9], which faithfully cap\u00adtures the original computation, e.g. and(abc) e true(a) e false(b) +e false(b) \n-false(c). fw(bc) It is easy to deduce from the rules that the reduc\u00adtion satisfies the subject reduction \nproperty. In addi\u00adtion, we know, as was already shown in [20], that it is Church-Rosser, since, by the \ntype discipline, interaction is always done between one positive and one negative ports, and the rules \nfor reduction tells us that the ports once used for reduction disappear, while others remain as they \nwere with their original types. Note that this suggests that the reduction in Ain can be regarded as \nrewriting, i.e. substitution of equals for equals (as in the usual term rewriting systems). This observation, \nwhich is in accordance with Lafont s original intention [20], can be made formal if we introduce a suitable \ntyped behavioral equality, cf. Section 6, with which one may prove that the reduction in Ain indeed induces \nequal\u00adity, using the reasoning as for Proposition 3.7 of [16]. In this way, the algebra of types, when \ncombined with suit\u00adable conditions on reduction rules, results in significant syntactic/semantic properties \nof the formalism. Finally one important observation is that Lafont s cri\u00ad terion for deadlock-free property \ncalled simple net [20] cannot be captured as a typed Milner algebra. This can be easily verified by noting \nthat the criterion al\u00ad lows processes like: not(ab) e not(bc), not(bc) e not(ca), not(ca)enot(ab), but \nnot not(ab)e not(bc)enot(ca). This violates strict additivity via Proposition 3.4. By The\u00ad orem 3.3, \nany complex type structure in typed Milner algebras cannot capture simplicity, thus It is an interest\u00ad \ning issue to find out if there is a more general framework of typed algebras which captures, e.g semi-additivity. \n ::= !boo] I ?bool Types: a Type Algebra: (1)!bool[a ?bool = !bool (2) ?bool@ ?bool = ?bool Term Formation: \n(true) }!true(a) D a :!bool (and) I-?and(abc) D a :?bool, b :?bool, c :!bool (false) h! false(a) P a \n:!bool (or) I-?or(abc) D a :?bool, b :?bool, c :!bool (not) F?not(ab) D a :?bool, b :!bool (fw) F!fw(ab) \nD a :!bool, b :?bool Reduction: ?noqab) c !t,rue(a) -!false(b) !true(a) ?and(abc) !true(a) !fw(cb) \n !true(a) ?not(ab) !false(a) !true(b) * !false(a) ?and (abc) !false(a) !false(c) !false(a) ?C-(UF) \n !fw(ab) ?C (b5) o !fw(ab) ?Or(abc) o !true(a) -!true(c) !true(a) ?or(abc) !false(a) + !fw(cb) o !false(a) \nwhere ?C-is either ?not, ?and or ?or. Figure 4: Shared Booleans (1) 5 Applications (2): Extensions rule \n(2), we allow two clients to wait for a server hand in hand. However, as the lack of the rule for !bool@!bool \n  and Integration shows, we do not allow two servers to get connected like true(a) and false(a) since, \nas this very example 5.1 Type Disciplines for Controlled shows, it would result in an inconsistent situation. \nSharing As an example, the following gives reduction starting from a configuration with a shared name. \nHaving seen Milner s sorting and Lafont s types in the uniform framework of typed algebras, we observe \nthat ?ncjt(a~) 6 !true(a) ?or(bac) !false(b) !true(a) c !fw(cu). the former allows arbitrary overridden \nshared connec\u00adtion, while the latter permits none (except the exactly Note that the process !true(a) \n !fw(ca) behaves as matching connection). But in many practical situations, !true(a) !true(c), e.g. \n!true(a) !fw(ca) !not(cc ) + !true(a) !fw(ca) !false(c ). This can be made formal what we need is \nthe control of shared access. Indeed, shared access to resources is one of the fundamental el-by defining \na suitable behavioral equivalence. ements in multi-processing or networked computing en-The essential \nconsequence of the type discipline is vironments, as exemplified in the framework of server-that the \ncomputation in &#38;c enjoys the same Church\u00adclient software organisation. Once conceived, the range \nRosser property as the original Lafont s net. The ver\u00adof type disciplines for controlled sharing is vast, \ninclud-ification relies on analysis of redex (note two redexes ing quite complex ones. Below we present \none of the would share an agent), which again depends on the type simplest. For illustration, we take \nan extension of the discipline ( !bool@!bool is not allowed) and the form of previous example of Lafont \ns typed net. It is based on the reduction (e.g. agents with persistent types are in\u00ad deed persistent). \nEquationally this again lets reduction induce equality, under a suitable formulation. For this Definition \n5.1 The type structure Tsc and the alge\u00ad an untyped construction due to Nobuko Yoshida [33]. and other \ninteresting equalities in &#38;c, see [15]. bra L&#38;c are given by Figures 1 and 4. The type discipline \nof&#38;c has an interesting ramifi\u00adcation, where an agent like !true(a) !true(a) is typable. In Figure \n4, ?bool is the same as bool-, denoting a The agent seems to behave consistently from the user s type \nof operation on boolean valuesz. !bool, in contrast, viewpoint because true is stateless (i.e. never \nchangesis a persistent version of bool+, representing a shared its behaviour), and, moreover, such a \nconfiguration in\u00adboolean datum. The idea is to share a port of type !bool creases the possibility of \nparallelism. This can be donein a consistent way by ports of type ?bool. Thus the rule by refining the \ntyping, thus enlarging the set of typable(1) in the type algebra says that a client and a server can \nprocesses, without any change of dynamics. The systembe connected, and the server is still available. \nIn the is given in Figure 5, combined with Figure 1 and the re\u00ad The not at ions come from [7], though \nthe associated compu\u00ad duction rules in Figure 4. The type structure refines tational behaviors are a \nlittle different. that of Tsc, where !boolo is a type for persistent data 3 Thus the present discipline \nresults in unbounded sharing of one server. Pragmatic concern would use bounded sharing by whose is not \nand and value yet determined, !booll !boolz having integer-indexed types. are types for determined persistent \ndata. In the algebra Figure 5: Shared Types: a ::= !bool~ I !booll I !boolz \\ ?bool Type Algebra: (1)!booli \n@ !booli = !booli (i = 1,2) (2) !booli @ ?bool = !booli (i =0,1,2) (3) ?bool @ ?bool = ?bool Term Formation: \n(true) F!true(a) D a :!booll (and) t-?and(abc) D a :?bool, b :?bool, c :! boolo (false) !--!fake(a) D \na :!boolz (or) fi?or(abc) D a :?bool, b :?bool, c :!boo10 (not) t-?not(ab) D a :?bool, b :!bool~ (fw) \n+! fw(ab) P a :!bool~, b :?bool of types in Figure 5, we allow two server types to get connected as \nfar as they are deterrnaned and of the same kind. We then have !boolo <!bool; (i= 1, 2), which are the \nonly non-trivial orde~ing in the type structure. The following is the reduction, starting from the process \nwhich has become newly typable. ?not(ab) e !true(a) o !true(a] e ?or(bac) + !false(b) e !true(a) e !true(a) \ne ?fw(ca) Here types change in the way: a :!booll, b :! boolo, c : !boolo j a :! boon, b :! boolz, c \n:! boolo, which shows, for the first time, the proper increase of the ordering in types (cf. Definition \n2.10 ). In this way, the reduction satisfies the subject reduction property, and it is again Church-Rosser. \nTwo remarks are due in regard of the examples in this subsection. (i) Due to the introduction of sharing, \nunnecessary processes can remain after computation, unlike La\u00adfont s original construction. This is the \ncost we should pay for introducing shared access.  (ii) The presented schemes are easily applicable \nto stateful processes too. Indeed shared access be\u00adcomes even more important when we deal with changeable \ndata since consistency is maintained only by having one centralised data or by replicat\u00ading it carefully. \nFormulation of behavioral prop\u00aderties we require to hold for such non-convergent computation is an interesting \nsubject of study.   5.2 Integrating Mobility Suppose we have typed agents, which form a typed Milner \nalgebra, equipped with a suitable typed reduc\u00adtion, such as those in the preceding sections. As far as \nthe configuration is self-contained, the subject re\u00adduction property ensures that things never go wrong. \nSuppose, however, that the typed port names of those agents can be passed around by some programs, so \nthat the receiving program will generate new agents with re\u00adceived port names, which are ready to interact \nwith the Booleans (2) original agents. Can we ensure, in the face of transmis\u00adsion of port names, that \nthe whole configuration never violates the discipline imposed in the original algebra? If this is achieved, \ninteraction among those agents can preserve the important syntactic/semantic properties as in the original \nsituation, e.g. Church-Rosser property in 4.2/5.1. This is essential when we think of apply\u00ad ing the \npresent framework to those concurrent program\u00ad ming languages which allow transmission of port names, \ncf. [2, 9, 18, 28, 29, 30, 32]. In another context, we may say this allows us to form a typed ~-calculus \nwith con\u00adstants, just as a typed A-calculus with constants. We give a positive answer to this problem \nby show\u00ading that any typed Milner algebra can be integrated into the sorting type discipline discussed \nin Section 4. This means that the higher-order feature of sorting, which operationally corresponds to \nname passing, can be soundly integrated with any typed Milner algebra. The following example shows the \nbasic difficulty we encounter in achieving our goal, Example 5.2 We assume the type discipline of Ai~ \nThen the following seemingly well-typed agent: a(z), true(x) e E[b]. not(bc) e false(b) b a : (bool ), \nb : _L, c :bool+ is problematic, since, after reduction, we get true(b) e not(bc) e false(b), which cannot \nbe typed. This is be\u00adcause of the dynamic instantiation of name b. Note that the original type structure \ncan be made arbitrarily complex in the above example: thus a spe\u00adcific solution utilising the property \nof, say, Ain, may be useless in other situations (for example, linearity is im\u00adportant in Ain, while \nit is not in &#38;c or its refinement we noted; further, these examples are all confined to dyadic nature \noft ypes). Thus the general solution is preferred, which is indeed possible on the uniform basis of typed \nMilner algebras. In the following, we omit recursive types to avoid possible clutter of notations. Their \nin\u00adtroduction is straightforward, just following A* Term Formation: where In (input), a fresh, xi # \nZj (z # j), for all xi c Af(I ) we have r(zi) > r.Yi, and ((al.. an)+ ~(,lll..@n)-) c Tmc.  In (output), \na fresh, vi # vi (i # j), for all vi E ~(17) we have 17(vi) > fh, and ((al.. a~)+ . (~l..~~) ) G Trc. \n Figure 6: Polyadic r-Calculus with Constants. Definition 5.3 We assume an original t ype structure, \nsay Tc. Define: CY ::= al) I ((al.. c%)+ . (/31../3n)-) where a. c Tc and, in ((crl..an)+ . (~l..~n)-), \ncalled paw sorting types, we assume either CW, /3~ E Tc with at @ pi defined in T=, m ai and /3i are \nboth pair sorting types and cti = pi (for simplicity we assume there is no overlapping between Tc and \nnewly introduced types). The resulting set is called Tmc. Over TTC, define the following algebra, considering \nalso the symmetric case. CY($!(l = a for a ~ Tc. A pair sorting type represents constraint on both input \n(+) and output ( ). Their functionality would be\u00adcome clear later. The above algebra of pair sortings \nuse the simple algebra of sorting, cf. Definition 4.2. A more general variant would take, when a type \nin Tc occur in the output part of a pair sorting, the join of each pair of types in the corresponding \npositions of the original sortings, where if Tc does not own all finite joins then we can use the completion \nprocedure in Proposition 2.6. We now give the definition of the corresponding typed algebra. Definition \n5.4 (integrated typed r-calculus) First we assume the original typed Milner algebra &#38; corre\u00adsponding \nto Tc, its typed processes, as well as a typed reduction over them. We then define a typed Milner algebra, \ndenoted A~c, as follows. (i) Processes: As given by rules in: Figure 1, Figure 6, (res) (rep) of Figure \n2 with the side condition a:aEr ~ cr@cr=a added in (rep), and {i-F Drl PDI in&#38;}. (ii) Reduction: \nAs given by rules in: Figure 1, Figure 2, and {Pt=I d QDA[ifso in&#38;.}.  The essential idea of the \ntyping rules in Figure 6 is the following: first, in (input), if the input agent has, at a name xi, a \ntype, say, a(, then the rule says that a pos\u00adsible output at a should expect worse than that (so in this \ncase CYi < a;), by which any type ,l?~gre~ter than ,Bi is composable with a;, ensured by ((ii)+ . (,8)-) \nc TTC. The freshness of a is only to make the rule simpler, and the case when a does occur in P can be \nhandIed by (sub) rule. Now when we go to (output), first, as in (in\u00adput), each vi should initially have \na type greater than @i, the latter specified in the type for a. However, we also compose rx~ to each \ntype of vi, to make it prepare for the real instant iation. This is necessary since we may further make \nthe type lower than the present type by parallel composition and substitution. Since a type has already \nbeen pre-composed, when the real instantiation (via communication) takes place, the resulting configu\u00adration \ncannot have a type lower than the configuration just before communication, which is crucial for Propo\u00ad \nsition 5.5 later. Freshness of a as well as distinctness of Z are again to make the rule simple: other \ncases can be handled by (sub) rule again. The rule (<) says that we can replace a type with a less composable \ntype. As an example, the process in Example 5.2 is un\u00adtypable (i.e. no typed process can exist with the \nsame typeless part), since: a(z). true(z), ?i[b].not(bc) b a : ((bool+)+ . (bool-)-), b : bool-@ bool+ \ncannot be composed with false(b) P b : bool+, because bool-@ bool+ = 1 cannot be composed with any type. \nFormally we know: Proposition 5.5 -in ATC satisjies the subject re\u00adduction property. which is proved \nby showing that, if a : (ZI..L%). P E: [V1..V~].Q b r, we have -P{vl..v~/zl,.z~} Q Dr such that I (a) \n< I (a) for each a c fl(J7), which is not difficult by inspecting the side conditions in Figure 6. Note \nthat the above scheme can be used for typing the generalisation of partial Milner algebra as the un\u00adprocesses \nof ~-calculus themselves, refining the sorting derlying framework. Concretely we may use the by combining \nit with other type disciplines. Consistency combination of reduction-closure for equality and of type \nassignment is ensured if the refinement conser-typed action predicates, cf. [16] (e.g. a port with an \nvatively extends the construction presented above. Sig-inert type may give no action). Such construction \nnificant examples would include the combination with was also given in [15]. As was already discussed \nin T in, T~c and their ramifications. As another example Sections 4 and 5, this line of study would give \nthe in a different context, a possible way to incorporate the semantic elucidation of type disciplines \nas repre\u00ad refinement which captures input/output modes of com-sent able in typed Milner algebras. In \nthis context, munication, studied by Pierce and Sangiorgi [27], would it is interesting to see whether \nsuch type disciplines be to extend the pair sorting by IO-tags as in [27] with as Tin and T~c can be \nof significant use for non\u00adrequiring exact mat thing of (nested) IO-tags in algebra. trivial verification \nof concurrent programs, such as This set of types are given a simple (covariant) ordering those discussed \nby Jones [19]. based on 10-tags in addition to the ordering <, and we (4) As we noted in Section 3, finding \na uniform frame\u00aduse this IO-ordering to refine (input) and (output) rules work of types which goes beyond \nstrict additivity is so that each port (zi and V$ in Figure 6) should have a important, both for theoretical \nunderstanding and lower IO-type than the corresponding expected type for pragmatic concerns. (0$ and \npi in Figure 6), in addition to the constraint (5) The present work shares part of its motivations in \nterms of < and composability, as is already speci\u00adwith Interaction Categories introduced by Abram\u00ad fied \nin Figure 6. See [15] for details. Note that such sky and studied by Abramsky, Gay, and Nagarajan a scheme \ncan be used to consistently combine multiple [1, 5, 6]. What is lacking in the present frame\u00ad type disciplines \nwith sorting, which would be important work in comparison with their work is the categor\u00ad in practice. \nWe believe that the pragmatic as well as ical framework for semantics of types (cf. carte\u00ad theoretical \nstudy of such integrated schemes is a fruit\u00adsian closed categories for typed A-calculi). At the ful subject \nof further research. same time, our algebraic framework seems simpler while retaining enough generality \nfor many pur\u00adposes. One interesting technical point is to compare  Discussions the passage from SProc \nto its deadlock-free coun- We list a few further issues with some comparisons be-terpart (cf. [5]) on \nthe one hand, and the passage low. from strict-additivity to semi-additivity (cf. Sec\u00adtion 3), on the \nother hand. Their work, as well as (1) One of the basic concerns we have not addressed in Milner s Action \nStructure [23] and our study in e.g. tL,. -..,. c.,.-+ -+.. J., :-+L. a :--.. ,. ,.~ 4., -. ;-~.-..,.-. \nT~ bllc ~lcx1lb bbuuy 1> IJ1lC lhh UC U1 LIJ~C LILJCJC/LL~.11 [14], also relates to (2) above. we take \nexamples in Sections 4 and 5, all except the (6) In view of recent proposals on concrete type sys\u00adfinal \none pose no problem. The interesting case is tems for concurrent programming languages includ\u00ad the integrated \nscheme, where we use composability ing [10, 26, 27, 30, 29], we note that the presentedin the side conditions \nof Figure 6. However a type framework deliberately does not address individual inference for this case \nseems still possible in general, concerns treated in these languages (e.g. abstrac\u00adas far as the original \nalgebra of types (Tc in Section tion of interactive behaviour), and tries to offer a 5) satisfies a certain \norder-theoretic property. general framework based on simple mathematics. (2) Another important issue \nis the semantic founda- We believe that our framework will facilitate the tions of the present algebraic \nframework. We be\u00ad study of varied proposals on a uniform technical ba\u00adlieve that the identification of \ncanonical type con\u00ad sis, which in turn would be reflected on the further structors, in analogy with the \nfunction space con\u00ad development of the present algebraic construction structor in a typed applicative \nstructure, is essen\u00ad and its refinement, e.g. extensions of the present tial to this line of study, which \nis one of the most scheme to other kinds of process constructors. prominent issues for further study. \nThis also relates to the clarification of how the combination of type Acknowledgements disciplines and \nreduction rules results in significant computational behaviour. Special thanks go to Cliff Jones for \na series of insight\u00ad (3) Apart from a general semantic framework, it is pos-ful discussions on this and \nrelated subjects. Discussions sible, for each typed algebra, to formulate a certain with Samson Abramsky, \nSimon Gay and Robin Milner typed behavioral (inequality, cf. [27], with which on the present work were \ninvaluable, Pierre Collette, we can reason about (in)equations over processes. Vasco Vasconcelos and \ntwo anonymous reviewers gave Abstractly this means we take quotient algebras. me useful comments on the \nmanuscript. Some ideas of See [15] for such development where we use a slight the present work were jointly \ndeveloped with Nobuko Yoshida. I thank her for her insight, for criticisms on [16] Honda, K. and Yoshida, \nN., Combinatory Representa\u00ad various versions of the paper, and for her warm encour\u00ad tion of Mobile Processes. \nPOPL 94, pp.348-360, ACM agement. Press, 1994.  References [1]Abramsky,S., Gay, S. and Nagarajan, R., \nInteraction Categories and Foundations of Typed Concurrent Com\u00adputing. Deductive Program Design: Proceedings \nof the 1.994 Marktoberdorf International Summer School, Springer-Verlag, 1995. [2] Agha, G., Mason, I., \nSmithjS. and Talcott,C., A Foun\u00addation for Actor Computation. Journal of Functional Programming. To appear. \n [3] Berry, G. and Boudol, G., The Chemical Abstract Ma\u00ad chine. Theoretical Computer Science, vol 96, \npp. 217 248, 199 2. [4] Gay, S., A Sort Inference Algorithm for the Polyadic mCalculus. POPL 93, ACM \nPress, 1993. [5] Gay, S., Linear Types for Comrrsunicuting Processes. Ph.D. thesis, University of London, \n1995. [6] Gay, S. and Nagarajan, R., A Typed Calculus of Syn-ChrOIIOUS processes. .LICS 95, pp.210 220, \n1995. [7] Girard, J.-Y., Linear Logic, Theoretical Computer Sci\u00adence, Vol. 50, pp.1 102, 1987. [8] Goguen, \nJ., Thatcher, J. and Wagner E., An Initial Algebra Approach to the Specification, Current Trends in Programming \nMethodology, vol. 4, ed, Raymond T., Prentice-Hall, 1978. [9] Hewitt, C., Bishop, P., and Steiger, R., \nA Universal Modular ACTOR Formalism for Artificial Intelligence. IJCAI 7.9, pp.235-245, 1973. [10] Honda, \nK., Types for Dyadic Interaction. CONCUR 93, LNCS 715, pp.509-523, Spiinger-Verlag, 1993. [11] Honda, \nK., Notes on P-Algebra (l): Process Structure. Proc. TPPP 9.4, LNCS 907, pp.25-44, Springer-Verlag, 1995. \n[12] Honda, K., Notes on P-Algebra (2): Group Presenta\u00adtion of Process Structure. March, 1995. A typescript, \n15pp. To appear as a CS technical report, Manchester University. [13] Honda, IX., Notes on P-Algebra \n(3): Product of Process Structures. March 1995. A typescript, 17pp. To appear as a CS technical report, \nManchester University. [14] Honda, K., A70tes on P-Algebra (~): Algebra on Process Structure. October \n1995. A typescript, 43pp. To appear as a CS technical report, Manchester University. [15] Honda, K. Notes \non P-algebra (5): Partial Milner Al\u00ad gebras. April 1995. Typescript. 29 pages (Main Part), 22 pages (Addendum). \nA revised version to appear as a CS technical report, Manchester University. [H ] Honda, K. and Yoshida, \nN., Replication in Concur\u00adrent Combinators, TACS 9.4, LNCS 789, pp.786 805, Springer-Verlagj 1994. [18] \nJones, C. B., Process-A lgebrazc Foundations for an Object-Based Design Notation. UMCS-93-1O-I, Com\u00adputer \nScience Department, Manchester University, 1993. [19] Jones, C. B., Accommodating Interference in Object-Based \nFormal Design, to appear in Formal Methods in System Design, Kluwer Academic, 1996. [20] Lafont, Y., \nInteraction Nets, POPL 90, pp. 95-108, ACM press, 1990. [21] Milner, R., A Calculus of Communicating \nSystems, LNCS 76, Springer-Verlag, 1980. [22] Milner, R., Polyadic x-Calculus: a tutorial. Logic and \nAlgebra of Specification, Springer-Verlag, 1992. [23] Milner, R., Action Structures. Research Report \nLFCS\u00ad92-249, Computer Science Department, Edinburgh University, 1992. [24] Milner, R., Harper, R., and \nTofte, M., The Definition of Standard ML, MIT Press, 1990. [25] Mitchell, J., Type Systems for Programming \nLan\u00adguages. Handbook of Theoretical Computer Science B, pp.367-458, MIT Press, 1990. [26] Nielson, H.R, \nand Nielson, F., Higher-Order Concur\u00adrent Programs with Finite Communication Topology. In POPL 91, 1994. \n[27] Pierce, B.C. and Sangiorgi.D, Typing and subtyping for mobile processes. LICS 93, pp. 187 215, 1993. \n[28] Pierce, B.C. and Turner, D. N., Concurrent Objects in a Process Calculus, TPPP 9J, Springer-Verlag, \nLNCS 907, pp.187-215, 1995. [29] Reppy, J.H. CML: A Higher-Order Concurrent Lan\u00adguage. PLDI 91, pp.293-259, \n1991. [30] Takeuchi, K., Honda, K. and Kubo, M., An Interaction-based Language and its Typing System. \nProc. PA RLE 94, LNCS 817, pp.398-413, Springer-Verlag, 1994. [31] Vasconcelos, V. and Honda, K., Principal \nTyping Scheme for Polyadic rr-Calculus. CONCUR 93, LNCS 715, pp.524-538, Springer-Verlag, 1993, [32] \nYonezawa, A. and Tokoro, M., ed. Object-Oriented Concurrent Programming. MIT Press, 1986. [33] Yoshida, \nN., Graph Notation for Concurrent Com\u00adbinators, Proc. TPPP 94, LNCS 907, pp.393-412, Springer-Verlag, \n1995. \n\t\t\t", "proc_id": "237721", "abstract": "", "authors": [{"name": "Kohei Honda", "author_profile_id": "81100624236", "affiliation": "Department of Computer Science, University of Manchester, Oxford Road, Manchester M13 9PL, England", "person_id": "PP31081915", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/237721.237802", "year": "1996", "article_id": "237802", "conference": "POPL", "title": "Composing processes", "url": "http://dl.acm.org/citation.cfm?id=237802"}