{"article_publication_date": "06-01-1995", "fulltext": "\n EEL: Machine-Independent Executable Editing James R. I.arus and Eric Schnarr Computer Sciences Department \nUniversity of Wisconsin Madison 1210 West Dayton St. Madiscm, WI 53706 USA {larus,schnarr} @cs.wise.edu \nAbstract EEL (Executable Editing Library) is a library for builliing tools to analyze and nzodifi an \nexecutable (compi[ed) pro\u00adgram. The systems and languages communities have built many tools for error \ndetection, fault isolation, architecture translation, performance measurement, simulation, and optimization \nusing this approach of modifiing executable. Currently, howeve~ tools of this sort are difticult and \ntime\u00adconsurning to write and are usually closely tied to a particu\u00adlar machine and operating system. \nEEL supports a machine-and system-independent editing model that enables tool builders to modijj an executable \nwithout being aware of the details of the underlying architecture or oper\u00adating system or being concerned \nwith the consequences of deleting instructions or adding foreign code. 1 Introduction A program executable \nholds instructions and data for a compiled program. In most situations, executable are atomic entities \nthat are created, used (executed), and dis\u00adcarded, Sometimes, however, it is convenient or necessary \nto look inside one of these entities and observe, measure, or modify a program s behavior. Executable \nediting changes This work is supponed in part by Wright Laboratory Avionics Directorate, Au Force Material \nCommand, USAF, under grant #F336 15-94-1-1525 and ARPA order no. B550, an NSF NYI Award CCR-9357779, \nNSF Grants CCR-910 1035 and MIP-9225097, DOE Grant DE-FG02-93ER25 176, and donations from Digital .l?qmpment \nCorporation and Sun Microsystems. The U.S. Government is authorized to reproduc~ and distribute reprints \nfor Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained \nherein are those of the authors and should not be interpreted as necessarily representing the official \npolicies or endorsements, either expressed or implied, of the Wright Laboratory Avi\u00adonics Directorate \nor the U.S. Government. Permission to copy without fee all or part of this material is granted provided \nthat the copies are not made or distributed for direct commercial advantage, the ACM copyright notice \nanti the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association of Computing Machinery.To copy otherwise, or to republish, requires a fee and/or specific \npermission. SIGPLAN 95La Jolla, CA USA Q 1995 ACM 0-89791 -697-2/95/0006...$3.50 executable (compiled) \ncode by removing existing instruc\u00adtions and adding foreign code that observes or modifies a program s \nexecution. It is an effective technique for measur\u00adingandmodifying program behavior since executable \nhold an entire program (including libraries) 1 and editing them does not require source code or modification \nto system tools such as compilers and linkers. Executable editing is widely used for three purposes: \nemulation, observation, and optimization. An edited execut\u00adable can emulate features that hardware does \nnot provide. For example, the Wisconsin Wind Tunnel architecture simu\u00adlator [19] drives a distributed, \ndiscrete-event simulation of a parallel computer from the logical cycle times of processors directly \nexecuting a parallel program. The underlying hard\u00adware (a SPARC processor in a Thinking Machines CM-5) \ndoes not provide a cycle counter or an efficient mechanism for interleaving computation and simulation. \nThe Wind Tunnel system edits programs so that they update a cycle timer and return control at timer expirations. \nSimilarly, one version of the Blizzard distributed shared-memory system [20] edits programs to insert \nfine-grain access tests before shared loads and stores. These tests permit data sharing at cache-block \ngranularity, which reduces the false sharing incurred by page-granularity distributed shared-memory systems. \nAnother emulation is software fault isolation (sandboxing) [27], which implements protection domains \nby modifying code to prevent it from referencing or trans\u00adferring control out of its domain. In the limit, \nediting can replace an entire program with instructions for a different architecture. Translation is \nused both to migrate legacy code to new architectures (e.g., Tandem [2] and VAX [21]) and to run binaries \non other systems [12]. Technology trends are increasing opportunities for edit\u00ading executable. Machines, \nboth sequential and parallel, are built almost exclusively from commodity microprocessors, which offer \ninstructions and memory systems targeted at a 1 This process can also be pet-fo]-med on components of \nm executable (objecl files). However, a patent obtained by Pure Software precludes many uses of object-file \nmodificahon [17]. mass market that has no need for semantically-rich protec\u00adtion or memory models. Although \nits performance is lower than hardware s, executable editing enables research by allowing new ideas, \nsuch as sandboxing or user-level shared memory [19], to be demonstrated on existing processors and tested \non real applications, Editing can also solve prac\u00adtical problems raised by new architectures. For example, \ngood performance on highly-parallel superscalar or VLIW processors requires instruction scheduling tuned \nfor a par\u00adticular implementation. Rescheduling an executable (by editing) offers an attractive alternative \nto purchasing, dis\u00adtributing, managing, and updating binaries. Finally, editing offers a solution to \nthe instruction-set compatibility issues [12] that have hindered widespread acceptance of RISC processors, \ndespite their cost-effective performance. Binary translation provides machines with the operations necessary \nto run the vast amount of software for Intel processors. Another use of executable editing is program \nobserva\u00adtion. Profiling and tracing tools, such as MIPS s pixie [22] or gpt [4], edit executable to record \nexecution frequencies or trace memory references. These tools are widely used to study program or system \nbehavior (e.g., [6,8]) and computer architecture (e.g., [5, 11,29]). More recently, a tool based on EEL, \nActive Memory [16], dramatically lowered the cost of cache simulation to a 2-7x slowdown by inserting \ncache-miss tests before a program s memory references rather than post-processing an address trace. In \naddition, software development tools, such as Pure Software s F w /fY [13], detect programming errors, \nsuch as out-of-bounds memory references or memory leaks. Finally, executable editing has also been used \nfor global register allocation and program optimization [24,25]. Unlike most compilers, which operate \non a single file, edit\u00ading can manipulate an entire program, which permits h to perform interprocedural \nanalysis rather than stopping at procedure boundaries. Executable editing is conceptually easy, but complex \nin practice because of a myriad of architectural and system\u00adspecific details [15]. This complexity reduces \nthe attractive\u00adness of the technique by increasing the time and effort required to produce a robust tool. \nAd-hoc systems are unlikely to employ reliable, general analyses for difficult constructs, such as indirect \njumps. Moreover, differences among machines and operating systems lead to tools that are closely tied \nto one or two platforms and which are diffi\u00adcult to port to other systems. EEL (Executable Editing Library) \nis a new C++ library that hides much of the complexity and system-specific detail of editing executable. \nEEL provides abstractions that allow a tool to analyze and modify executable programs without being concerned \nwith particular instruction sets, executable file formats, or consequences of deleting exist\u00ading code \nand adding foreign code, EEL greatly simplifies the construction of program measurement, protection, \ntrans\u00adlation, and debugging tools. EEL differs from other systems in two major ways: it can edit fully-linked \nexecutable, not just object files, and It emphasizes portability across a wide range of systems. Both \naspects require new algorithms, which this paper describes. The first part describes EEL s machine-indepen\u00addent \nabstractions and the analysis underlying them. The sec\u00adond part describes how EEL is parameterized to \nbe ported easily to new systems. The third part describes some mea\u00adsurements and applications of EEL. \n2 Related Work As the introduction relates, many tools modify executa\u00adble to perform a wide range of \ntasks. However, in most tools, the application and executable modification are inter\u00adtwined and details \nof the latter have not been published. An exception is Srivastava and Wall s OM system [25], which is \na library, similar to EEL, for modifying object files, OM internally represents instructions as RTL, \nwhich can be manipulated and translated back into machine instructions. OM S RTL and EEL s instructions \nserve the same roles. OM, however, uses relocation information from object files to analyze a program \ns control structure and to relocate the edited code. EEL, by contrast, directly analyzes and modifies \na program s instructions, and consequently can operate on programs without relocation information, such \nas fully compiled and linked programs. 1 This facility comes at a price, as EEL requires more sophisticated \npro\u00adgram analysis and occasionally falls back on run-time code when static analysis is insufficient. \nHowever, this analysis also permits EEL to provide common functionality across vastly different systems. \nLarus and Ball [15] described the ad-hoc analysis used by their profiling and tracing tool qpt to instrument \nexecut\u00adable files. EEL extends the earlier work by providing a gen\u00aderal library for manipulating executable \nthat is not tied to a specific application. EEL also shows that many problems raised in the earlier paper \ncan be handled with more power\u00adful program analysis. ATOM [23] is a system that provides a simple interface \nto OM for adding instrumentation to programs. ATOM s interface is higher-level and more concise than \nEEL s (or OM S), which simplifies writing tools, but provides less control over the instrumentation process. \nFor example, ATOM does not permit existing instructions to be modified2 and invokes foreign code through \na function call. ATOM s principle advantage is that foreign code can be written entirely In a high-level \nlanguage. Figure 1 contains the EEL code to implement the same branch-counting application as discussed \nby Srivastava and Eustace [23]. The code for the 1. In the near future. EEL WI1l supplement and verify \nIts analysis with relocation information. when ava~lable, and WI1l modify thk reformation, which will \npermit editing of object files, 2. Newer versions provide a limited facility for changing instructions \n(Wall: personal communications).  ,,, ., ,,, ,,, ,, int main(int argc, char* argv[l) mach_inst incr_count_code[] \n= executable* exec = new executable (argv[ll); exec->read_contents( ) ; routine* r; FOREACH_ROUTINE (r, \nexec->routineso ) t instrument(r) ; while( !exec->hldden_routlnes ()->iS_emPtY( ) ) { r = exec-.hldden_routines \n()->first() ; exec->hidden_routines ()->remove(r) ; instrument(r) ; exec->routines ()->add(r) ; addr \nx . exec->edited_addr (exec->start_address () ) ; exec->wrlte_ed~ted_executable (st_cat(argv[ll , count \n) , x); return (,0) ; , void ir)strument (routine* r) t static long num . 0; cfg g . r->control_flow_graph( \n) ; bb* b; FOREACH_BB(b, g->blockso) { if (1 < b->succo->sizeo) edge* e; FOREACH_EDGE (e, b->succo ) \n e->add_code_along (incr_count (num) ) ; num +. 1; J r->produce_edited_routine () ; r->delete_control_flow_graph \n() ; } FIGURE 1. Instrumentation routines for a branch counting tool (see Srivastava and Eustace [23]). \n,., ,, two systems are similar. However, a much larger difference is apparent in the low-level foreign \ncode (Figure 2). 3 EELAbstractions EEL provides five major abstractions (C++ class hierar\u00ad chies) that \nallow a tool to examine and modify an execut\u00ad able: executable, routine, CFG, instruction, and snippet. \n1 An executable contains code and data from either an object, library, or executable file. A tool opens \nan executable, examines and modifies its contents, and writes an edited version. An executable primarily \ncontains routines, the sec\u00adond abstraction, but also contains non-executable data. A tool can examine \nand modify routines in any order and place them, and new routines, in the edited executable in any order. \nEEL represents a routine s body with two further 1, EEL also supports interprocedural analysis and call \ngraphs, which are not described here. #include incr_count bin ); long incr_count_Offsets[l = ~include \nincr_count oft 1; class incr_count_snlppet : publ~c tagged_code_snippet t public : lncr_count_snippet \n( ) : tagged_code_snippet( incr_count_code, sizeof( incr_count_code) , NULL , NULL, incr_cOunt_Offsets, \nsizeOf(incr_cOunt_Offsets) ) 1; code_snippet * incr_count (long counter_num) ( assert(O <= counter_num) \n; tagged_code_snlppet* snippet . new incr_count_snippeto ; addr counter_addr = COUNTER_START + counter_num \n* sizeof(long); SET_SETHI_HI (*snippet->find_lnst (1) , counter_addr) ; SET_SETHI_LOW( *snippet->flnd_inst \n(2) , counter_addr) ; SET_SETHI_LOW (*snippet->flnd_lnst (3), counter_addr) ;  return (snippet) ; } \ni-lGURE 2. Low-level instrumentation for branch counting on aSPARC processor. ,.., ., abstractions: control-jlow \ngraphs (CFGS) and instructions. A CFG is a directed graph whose nodes are basic blocks (single-entry, \nsingle-exit straight-line code sequences) and whose edges represent control flow between blocks [1]. \nEEL provides extensive control-flow anddata-flow analysis for CFGs. Blocks contain asequence of instructions, \neach ofwhich is a machine-independent descriptionof amachine instruction. A tool edits a CFG by deleting \ninstructions or adding code snippets to blocks and edges. Asnippet encap\u00adsulates machine-specific foreign \ncode and provides context\u00addependent register allocation. EEL modifies calls, branch, and jumps to ensure \nthat control flows correctly in the edited program. EEL s abstractions are similar to those found incompil\u00aders, \nwhich is not surprising given that both systems manipu\u00adlate programs. Like many recent compilers such \nas gcc [26] EEL s internal representation is a register-transfer level (RTL) instruction description \n[10]. A crucial differ\u00adence, however, is that a compiler writer can choose RTL operations with clean \nsemantics and translate constructs to a sequence of operations, while each EEL instruction must capture \nthe semantics of a machine instruction. The remainder of this section presents these abstractions in \nmore detail anddescribes theanalysis underlying them. 3.1 Executable EEL executable objects are an abstraction \nof executable files-object, library [, or static and dynamically-linked pro\u00adgrams that hide differences \namong file formats. Most operations are inquiries that return the location or size of a named entity, \nsuch as a routine. A few operations modify a program s state by changing a memory location or replacing \nor adding a routine. Most editing, however, is performed on a routine s control-flow graph, as described \nbelow. Symbol table information in executable files is typically incomplete or misleading [15], which \ngreatly complicates accurate analysis of a program. For example, compilers hide routines by not producing \ndebugger symbol table information or put data tables in the text segment with a symbol table entry indistinguishable \nfrom a routine s. In addition, symbol tables commonly record only the starting point of a routine and \ndo not distinguish multiple entry points arising from Fortran ENTRY statements or interpro\u00adcedural jumps. \nRelocation information, when available, can refine this information. EEL uses a more general, but sometimes \nless precise, approach and refines a symbol table by analyzing a program to find data tables, hidden \nroutines, and multiple entry points. The analysis has several stages: 1. Initially, EEL reads a program \ns symbol table and eliminates all duplicate, temporary, and debugging labels in the text segment. It \nalso discards labels that are not aligned on an instruction boundary or that are the target of a branch \nor jump (not call!) from the preceding routine (these are probably internal labels). The remaining labels \nform the ini\u00adtial set of routines. Each routine s initial entry point is its starting address. 2, If \nthe executable has no symbol table (i.e., is stripped), the initial set of routines contains only the \npro\u00adgram s entry point and the first address in the text segment. In this case, EEL makes an extra pass \nover the program s instructions to find direct subroutine calls. These instruc\u00adtions targets become the \ninitial set of routines. 3. EEL then examines instructions to find jumps out of a routine or calls on \nroutines not in this initial set. The desti\u00adnation of these control transfers become entry points to \nthe routines that contain them. This analysis is conservative. It may find invalid entries, as for example, \nwhen data is inter\u00ad 1. EEL cannot yet modify Ilbraries, although the extension 1s stralght-for\u00adwa~d. \nWhen complete. this feature will permh ed]tmg dynamically -hnked programs by modifying their executable \n(already working) and dynamic llbranes. preted as an instruction, but it does not miss entry points, \nwhich is important to construct accurate CFGS. 4. The key part of the analysis occurs when EEL con\u00adstructs \na routine s control-flow graph. A reachable, but invalid, instruction in a CFG leads EEL to assume that \nthe routine contains data. However, unreachable instructions at the end of a routine comprise another \nroutine, which EEL records in its symbol table and analyzes. As a side effect, recognizing a new routine \nmay add entry points to existing routines. This analysis refines the initial symbol table and allows \neach routine to be identified and processed individually, with full knowledge of its interprocedural \nlinkages. In a stripped executable, the analysis finds all routines, but can\u00adnot recreate their names, \nwhich makes many tools, such as program profilers, far less useful. EEL maintains symbol table information \nfor the edited program. EEL uses it to produce debugging information for the edited executable, so that \nstandard tools, such as debug\u00adgers, work for edited programs. 3.2 Routines Routines are named objects \nin a program s text segment that contain instructions and data. EEL uses routines in two roles. First, \nthey hold information about an entity in the text segment (its name, extent, entry points, etc.), Second, \nrou\u00adtines provide the interface to EEL s control-and data-flow analysis and editing facility, which is \ndescribed below. 3.3 Control-Flow Graph The primary program representation in EEL is a control\u00adftow \ngraph (CFG) of a routine. EEL represents a routine as a CFG, as opposed to a sequence of instructions. \nfor three rea\u00adsons. First, the initial application of EEL, qpr, required CFGS to implement efficient \nprofiling and tracing by plac\u00ading instrumentation on CFG edges [4], Moreover, previous experience with \nsimple tools showed that even they could reduce overhead by using control-flow information to place instrumentation \nintelligently. Second, EEL itself uses CFGS to adjust addresses in branch and jump instructions affected \nby editing. Most important, CFGS provide an architecture-indepen\u00addent way of representing control flow. \nA key question is how to represent the semantics of instructions on a particu\u00adlar machine. Unlike compiler \nintermediate representations, which are the usual basis for CFGS, machine instructions can have internal \ncontrol flow. For example, delayed branches in many RISC processors execute the subsequent instruction \n(in the branch delay slot) before transferring control. These instructions come in many variants, such \nas annulled branches that execute the delay slot only if the branch is taken. EEL explicitly represents \ninstructions internal control flow in a CFG, so that internal and external control flow are treated uniformly \nand instructions appear to have no control flow (i.e., are non-delayed branches). Figure 3 shows an instruction \nin an annulled branch s delay brie, add a L1 %11, %12, %11 in an architecture and compiler-independent \nmanner by computing a backward slice [ 14,28] from the jump instruc\u00adtion s registers. Although at the \ntime of slicing, the CFG is incomplete, a path from the routine s entry to the jump must bne,a L1 l \n+ ~ : FIGURE 3. Example of CFG normalization. EEL CFGS explicitly represent control flow in instructions. \nIn this case, the add instruction is in the delay slot of ian annulled conditional branch and executes \nonly if the branch is taken, so the add instruction appears along only one CFG edge, .... . slot, which \nis placed in its own basic block, which is linked to the appropriate outgoing edge of the branch s block. \nThis process can repeat several times if the instruction from the delay slot is itself a delayed control-transfer. \nIn a rlon\u00ad annulled branch, the delay slot instruction is duplicated along both edges. W~th this explicit \nrepresentation, a tool can add foreign code before or after almost any instruction without consid\u00ad ering \nhow the code interacts with local control flow, which means that the tool need not be aware of architectural \ndetails such as delayed branches. However, if left unre\u00ad versed, duplicated delay slot instructions increase \na pro\u00ad gram s size and execution time, so EEL folds instructions back into unedited delay slots. EEL \nmarks some CFG edges and blocks as uneditable, to simplify the process of producing executable code from \nan edited CFG. Most uneditable blocks and edges transfer con\u00adtrol out of the current routine (e.g., the \ndelay slot after a call), which would require interprocedural editing to place foreign code in another \nroutine. Although 15 20% of edges and blocks are uneditable, it is usually easy to find an alter\u00adnative \nlocation to edit (e.g., before the call). Because EEL builds CFGS a single routine at a time, it treats \nsubroutine calls specially. EEL uses a distinguished, zero-length basic block after the block containing \nthe call s delayed instruction as a placeholder for the control transfer and possible side-effects of \nthe subroutine s body. In general, when control flow cannot be completely ana\u00adlyzed, run-time code ensures \nthat control passes to the cor\u00adrect edited instruction [ 15]. EEL can perform several standard CFG analyses: \ndominators, natural loops, live reg\u00adisters, and slicing [1,28]. EEL uses them to improve the pre\u00adcision \nof control analysis and to reduce the need for run\u00adtime mechanisms. These analyses also provide an analytic \nbasis for building tools. Consider, for example, indirect jumps. Most indirect jumps occur in case statements, \nin which they jump through a dispatch table of addresses. EEL finds this type of table\u00adcompute the dispatch \ntable s address (or the jump would fail along the path). After finding the table s address, EEL builds \na precise CFG for the indirect jump and subsequently modifies the table to point to edited locations. \nThe same slice also can find the address used in the common idiom of an indirect jump to a literal value. \nIf a slice fails to find a dispatch table or literal address, EEL marks the CFG as incomplete and inserts \ncode to translate the jump s target address at run time. Fortunately, EEL s slicing makes run-time translation \na rare occurrence. We measured the frequency of unanalyz\u00adable indirect jumps in the SPEC92 benchmarks. \nOn SunOS 4.1.3 using gcc version 2.6.2 and the Sun Fortran compiler, EEL found no unanalyzable indirect \njumps among the 1,325 indirect jumps (and 1,027,148 instructions in 11,975 rou\u00adtines). On Solaris 2.4 \nusing the SunPro compilers (version SC3.O.1), EEL found 138 unanalyzable indirect jumps among the 1,244 \nindirect jumps (and 1,185,018 instructions in 16,613 routines). All 138 indirect jumps resulted from \noptimizing a call in a return statement by popping the cur\u00adrent stack frame and jumping to the callee. \nSix of these jumps occurred in compiled C code and the remainder were in the Fortran library. None of \nthese jumps affect EEL, since EEL s CFG are intraprocedural. 3.3.1 Editing CFGS A tool edits a routine \ns CFG by deleting instructions, adding new code before or after any instruction, or adding code along \na control-flow graph edge. A snippet (Section 3.5) contains the new code. EEL accumulates edits without \nchanging the CFG. In general, this batch style of editing works well since tools operate on the original \nCFG and need not see changes as they occur. Snippet call-backs (Section 3.5), which provide a final chance \nto modify an edit, easily handled the few exceptions. After a tool edits a CFG, EEL produces a new version \nof the routine that incorporates the changes. Producing an edited routine involves laying out its blocks \nand snippets to minimize unnecessary jumps and adjusting displacements and addresses in control-transfer \ninstructions or occasion\u00ad ally replacing these instructions by snippets containing instructions with \na longer span. 3.4 Instructions EEL instructions are abstractions of RISC-like machine instructions. \nThey divide instructions in functional catego\u00adries and provide operations to inquire about semantics. \nThe categories include memory references (loads and stores), control transfers (calls, returns, system \ncalls, jumps, and branches), computations, and invalid (data). The categories are common to many machines, \nso a tool can analyze EEL ., // Compute a backward address slice with respect // to register R, from \nPC. bool instruction ::backward_slice (bb b, addr PC, int_reg r) if (is_easyo I I is_hardo) // .~lreacfy \nLn earner slice return (true) ; else if (writes o->is_member(r) ) // .W2dlfies register R { if (! fp_reads \no->is_emptY( )) // Do not trace floating point ops mark_as_impossible (b, PC) ; else if (reads o->is_emptY()) \n,// Easy instruction reads nothing mark_as_easy(b, PC) : else // Harti instruction reacis registers. \nmark_as_hard(b, Pc) ; int_reg read_reg; I/ Continue slicing them FOREACH_REG (read_reg, readso ) { \nb->backward_slice (pc, read_reg); return (true) ; return (false) ; FIGURE 4. Operation on instructions. \nThis code com\u00adputes abackward address slice for instructions thatdo not read memory or call routines \n(these are analyzedby other functions). It demonstrates how EEL instructions hide architectural detad, \nbut still permit a tool to analyze a program. EEL s abstractions are in bold. instructionsin place ofthe \nunderlying machine instructions. These categories cover simple RISC machines (e.g., MIPS and SPARC). \nSince categories are C++ classes, EEL can derive new ones that span boundaries. For example, the autoincrement \nload in HP s PA-RISC machines is both a memory reference and a computation. Combining classes, unfortunately, \nis unlikely to synthesize the semantics of CISC instructions, suchas string edits. These instructions, \nhowever, are also difficult to analyze and instrument because oftheirdynamic behavior and internal control \nflow. The best representation may be a sequence of simpler instructions [25], EEL provides many inquiries \nabout an instruction s effect on a program s state (i.e., which registers it reads and writes, how it \nchanges the program counter, or what its operation is). These inquiries provide enough information to \nanalyze many aspects of a program, For example, Figure 4 contains code from @ that computes a backward \naddress slice for address tracing [14]. Because it operates on EEL instructions, this code is similar \nto the original algo\u00adrithmand independentof an underlying machine. To improve efficiency, EEL allocates \nonly one instruc\u00adtion to represent all instances of a particular machine 1! INCR_COUNT records a basic \nblock or edge by !! incrementing its counter in the count array. 1 sethl Oxl, %gb ! upper bits of &#38;counter \n2* Id [%1o(OX1) + %g6], %g7! load counter add %g7, 1, %g7 ! increment 3* st %g7, [%1o(OX1) + %g6] ! store \ncounter code_snippe~ * routine: :incr_counter_code long cOunter_num) t assert(O <. cOunter_num) tagged_code_snippet \nsnippet . new incr_cOunt_snlppeto ; addr counter_addr = PROFILE_COUNTER_START + cOunter_num * sizeof(counter) \n; SET_SETHI_HI (*sn~ppet->flnd_lnst (l), counter_addr) ; SET_SETHI_LOW (*snippet->find_inst (2), counter_addr) \n; SET_SETHI_LOW (*snippet->find_inst (3) , counter_addr) ; return (sn~ppet) ; FIGURE 5. Sample code \nsnippet (for the SPARC). Above the line is the snippet s body, which contains instructions to increment \na profile counter. Labels before each line (e.g., 1* ) name instructions that are custom\u00adized for each \ncounter. Below the line is qptcode that inserts acounter s address. instruction. Typically, this optimization \nreduces the number of allocated EEL instructions by a factor of four. 3.5 Code Snippets Acode snippet \nencapsulates foreign code that is addedto an executable. On one hand, EEL provides some system\u00adindependence \nfor snippets since it allocates registers for them. On the other hand, snippets are the one point at \nwhich a tool is machine specific, since the code in a snippet is crafted for a machine. This is not a \nserious drawback, since thecode isoften short andcarefully written forefficiency. A programmer writes \na snippet s body in assembly language or ahigh-level language compiled to assembly language, in which \ncase the snippet can be machine-independent, Figure 5 shows a sample snippet. When a tool creates a snippet, \nit specifies the instruc\u00ad tions, two sets of registers, and a call-back function (all, except the first, \nmay be omitted). The first set contains reg\u00adisters used in the snippet that need to be assigned unused \nregisters. EEL finds the live registers at the point at which the snippet is inserted and assigns dead \n(unused) registers to the snippet. IfEEL cannot find enough dead registers, it wraps the snippet with \ncode to spill registers to the stack. Sometimes, a snippet must use a particular register for example, \nto record its value or to execute a subroutine call and EEL should not spill or assign it. The second \nset specifies registers that cannot be used, even if free. This technique of register scavenging [15] \nis a way of utilizing // unused registers in snippets. 1 // Return the EEL instruction corresponding \nto The final parameter to a snippet is a call-back procedure, which is invoked after register allocation, \nbut before the instructions are placed in the modified program. The call \u00adback procedure is passed the \nregister-allocated instructions, their starting address in memory, and details of the reg,tster assignment. \nThe call-back may modify the instructions (but cannot change their length). This mechanism has been used \nto adjust instruction displacements when an instruction s final location is known, record addresses for \nsubsequent backpatching, and adjust code that records the stack pointer to discount the effects of EEL \ns spill code. 4 System-Dependent EEL Beneath the machine-independent portions of EEL are system-and architecture-specific \ncomponents that manipu\u00adlate executable files and machine instructions. The first piece is a library to \nread and write Unix executable files. EEL currently uses the GNU tyld library [7], which is also used \nby the GNU assembler, linker, and debugger (gdb) The second piece is an EEL-specific library to parse, \ndecode, analyze, and modify binary instructions. Previous experience argued against implementing these \nroutines, by hand. A surprising number of bugs in qpt arose in machine\u00adspecific binary instruction manipulations. \nThese bugs were of two types: improperly decoding or extracting an instruc\u00adtion field or omitting a particular \ninstance from an analysis. EEL alleviates these problems by generating this low-level code from a concise, \nhigh-level machine description. The tool spcww transforms a file of annotated C++ func\u00adtions and a machine \ndescription into machine-specific code for analyzing and manipulating binary instructions. The code in \nthe file defines the interface and functionality of EEL s machine-specific library (see Figure 6). The \nannota\u00adtions identify points at which spawn needs to insert code. derived from a machine s description, \nto decode and manipu\u00adlate a particular machine s instructions. For example, consider the function in \nFigure 6, which creates an EEL instruction corresponding to a machine instruction. The function examines \nan instruction, to deter\u00admine the class of the corresponding EEL instruction. The code for a particular \nclass of instruction calls the EEL instruction constructor, passing it the machine instruction and some \nvalues extracted from instruction fields. Spawn s annotations (in bold) specify instruction classes and \nattributes. Spawn processes the code and replaces {he annotations with machine-specific code to dispatch \non an instruction s type and to extract and modify instruction fields. For example, in the memory-referencing \ninstructions, spawn replaces the annotation { {WIDTH} } by the number 1. 1[is not, however, a way of \nfttxmg a registel across the entire program for the t oreIgn code, Lotet releases of EEL will provide \na mechani~m to free a register. // the machine instruction INST In executable !/ EXEC at address PC. \n!/ instruction mach_lns t_ma~e_inscruction (executable exec , macbl_inst* Inst, addr PC J {{ INST inst \nAT PC CATEGORY CALL DIRECT:: return new call_ instruct ion(inst) ; ; JUMP DIRECT:: return new jump_instruction \n(inst) ; ; BRANCH DIRECT:: return new branch_instructlon (Inst) ; ; JUMP:: { if (mach_inst_do_op (inst, \nOP_ICALL) ) return new lndirect_call_instruction (inst) ; If (mach_inst_do_op (inst, OP_RET) ) return \nnew return_instruction (inst) ; if ({{IS LITERAL}} &#38;&#38; {{READ 1}} == O) return new jump_instruction \n(lnst ) ; return new indirect_jump_instruction (inst) ; };; LOAD STORE:: return new memory_load_store_instruction \n(inst, {{WIDTH}});; LOAD :: return new memory_load_instruction (inst, {{WIDTH}}) ;; STORE :: return new \nmemoz-y_store_lnstmctlon (inst, {{WIDTH}]) ;: SYSTEM:: { If ((*lnst &#38; TRAP_COND) .= TA &#38;&#38; \nIMM(*lnst) == ST_SYSCALL) ( mdch_lnst *i = lnst -1; return new sY~tem call_lnstructiOn (inst, {{INST \ni LITVAL}}); } else return new system_call_instruction (inst, 1) ; };; vALID: : return new computatlon_lnstructiOn(inst \n) ;; ANY:: return new invalid_instruction (inst) ;; }) f FIGURE 6. EEL machine-specific code. This function \nbuilds an EEL instruction corresponding to a machine instruction. Spawn replace annotations (in bold) \nin the C++ code with machine-specific code thatdispatcheson different instruction types and extracts \nor modifies instruction fields. . .. ofbytesofaccessed memory. Spawn is currently unaware of a system \ns subroutine and system call conventions [3], so these instructions require additional processing to \ndistin\u00ad ,guish overloaded instruction uses. For example, the code in the figure resolves the SPARC S \nthree overload uses of a jump instruction. Spawn derives its machine-specific information from a machine \ndescription, which specifies both instruction syn\u00ad tax (i.e., encoding) and semantics. The syntax description \nis silmilar to the one in Ramsey s retargetable debugger [18] and NJ Machine Code Toolkit. SPCNWZextends \nRamsey s work by expressing instructions semantics with a simple register-transfer description of instruction \nsemantics [9]. Spcwvn descriptions are concise and easily derived from processor architecture manuals. \nThey first describe registers and instruction fields by specifying their width and, for reg\u00adisters, a \ntype for use in semantic expressions. Each instruc\u00adtion is described by a pattern that identifies its \nbinary encoding and a semantic expression that describes its opera\u00adtion and internal control flow. Spawn, \nborrowing from Ramsey, directly supports the common convention of expressing instruction encodings as \na matrix of instruction names. Spawn s concise instruction encoding encourages complete specification \nof an instruc\u00adtion set, which allows spawn-generated code to reliably detect invalid instructions and \nenables EEL s control-flow analysis to distinguish data from instructions by detecting where control \npasses to an invalid instruction. Figure 7 shows a portion of spawn s SPARC description. To make a description \nconcise, similar instructions are gl-ouped together and described by a common semantic function (which \ncan be parameterized for small differences among instructions). For example, this figure contains the \nsemantics of many SPARC control-transfer instructions. The function branch describes all conditional \nbranches. It consists of an expression parameterized by a condition code register (i e., integer or floating \npoint) and a branch test. When these arguments are bound, the expression describes a particular branch \ninstruction s semantics. The description also contains minimal timing information: the semicolon in the \nfunction s body indicates that the first statement exe\u00adcutes before the second statement (which overlaps \nthe next instruction s execution). Immediately below its description, this function is applied to the \ninteger condition codes (PSR) and a vector of test conditions, yielding a vector of fully instantiated \nsemantic functions. The semantic statements (sem) binds each function to the corresponding instruction \n(whose encoding was defined previously). Spawn extracts much information about a machine s instructions \nand registers from a machine description. It determines a classification for each instruction (jump, \ncall, store, invalid, etc.). It finds registers that each instruction reads and writes and literal values \nin instruction fields. It finds the number of registers in each register set and their width and type. \nIt even generates C++ code to replicate the computation in most instructions, such as computing the target \naddress of a jump or load and the result of an add. Machine descriptions of this type are far more concise \nthan hand-written code to manipulate instructions. For example, the SPARC description is 145 non-comment, \nnon\u00adblank lines and the mostly machine-independent annotated C++ file is 504 lines. The handwritten equivalent \nis 2,268 lines (spawn produces a file 6,178 lines long). For compari\u00ad // Instruction field de finltlons: \n/,/ instruct lon (32] fields 0p 30:31, 0P2 22:24, 0P3 19:24, OpC 5:13, rd 25:29, rsl 14:18, rs2 0:4, \niflag 13:13, simm13 0:12, imm22 0:21, disp22 0:21, disp30 0:29, cond 25:28, aflag 2 3 :29, asi 5:12 // \nGeneral purpose register set // register integer (32} R[35] alias integer {32) PSR is R[32] alias integer \n{32} FSR is R[33] register integer {32} PC // Control-transfer instruction syntax: // pat [ bn be ble \nbl bleu bcs bneg bvs ba bne bg bge bgu bcc bpos bvc fbn fbne fblg fbul fbl fbug fbg f bu fba fbe fbue \nfbge fbuge fble fbul e fbo cbn cb123 cb12 cb13 cbl cb23 cb2 cb3 cba cbO cb03 cb02 cb023 cbOl cbO13 cbO12 \n 1s OP() &#38;&#38; op2=[ObO10 Obl10 Oblll] &#38;&#38; cond=[O. .l5] 1/ Control-transfer instruction \nsemantics: II val disp is (integer [32] )disp30 val branch is \\r. \\op. (t:=pc+disp; op r ? pc:. t : aflag=l \n? annul) sem [brie be bg ble bge bl bgu bleu bcc bcs bpos bneg bvc bvs] is branch PSR @ [Jne e g ~le \n/ge ,1 Jgu leu cc CS pos neg VC VS] sem [fbu fbg fbug fbl fbul fblg fbne fbe fbue fbge fbuge fble fbule \nfbo] is branch FSR @ [ u g ug 1 u1 lg ne be ue ge uge ble ule o] sem call is t:=pc+ (# (lnteger{32} \n)dlsp30<<2 ) , R[151:=Pc; pc:=t sem jmpl 1s t:=addr, R[rd] :=pc; pc:=t FIGURE7. Portion of spawn s SPARC \ndescription. The first part defines resources suchas registers andinstruc\u00adtionfields. The middle part \ndefines the encoding (syntax) of some control-transfer instructions. The final part defines these instructions \nsemantics. In this description, the keyword val introduces a (function) binding. The statements started \nby (sem define the semantics of instructions in their first argument by the corresponding semantic function \nin their second argument. A comma separates operations that can execute in parallel, A semicolon separates \nsequential operations. son, a spawn description of the MIPS R2000 architecture is 128 lines and the \nDigital Alpha architecture is 138 lines. 5 Experience EEL currently runs on workstations with SPARC proces\u00adsors, \nunder SunOS and Solaris (an older version also ran on MIPS under Ultrix). We rewrote qpt to use this \nlibrary. In the process, qpt dropped from 14,500 non-comment, non\u00adblank lines of C code to 6,276 lines \nof C++ code, of which 975 lines are system-dependent manipulations of snippets (which contain 116 lines \nof assembly code). More impor\u00adtantly, the new qpt is far easier to understand and modify and contains \nseveral machine-specific optimization that were too cumbersome to implement in the old system. Program \nSize Tool (bytes) Run Time (sec.) 7 Version (text &#38; data) (user + system) qpt 246,784 4.4 + I \nCrr)t-02 II 164,864 I 3.5 I 950,240 19.0  I qPt2 H 1 I qpt2 -02 810,976 8.4 qpt2 -ND 868,320 18.0 \nqpt2 -02 -ND 720,864 7.7 + TABLE 1. Comparison of qptand qpt2. qpt is the original program profiler. \nqpt2 is a new profiler, based on EEL, that uses the same algorithms. Both tools instrumented a small \nprogram, spire, that consists of 320,536 bytes of text and data. Programs were compiled with gcc (g++) \nversicm 2.6.3 and run on a SPARCstation 20/61, with a 60Mhz SuperSPARC processor and local disk. Times \nare best of three runs. Base versions were compiled without optimization. The -02 versions were compiled \nat that optimization level, The -ND versions were compiled without assert statements (qpt contains no \nasserts). EEL consists of 13,960 non-comment, non-blank lines of C++ code, of which 1,501 lines are system-dependent \nmanipulations of snippets (which contain 114 lines of assembly code), 410 lines are executable-format \nspecific, and 2,268 are (handwritten) architecture-specific code. Unfortunately, this reduction in a \ntool s program length and complexity comes at the cost of increased tool size and exe\u00adcution time. Table \n1 shows the size and running time of the old (qpt) and new (qpt2) versions, compiled several ways. Without \noptimization, the new version runs 4.3 times slower. Optimization, however, narrows the gap to 2.4 times \nslower. It is worth noting that qpr2 s performance is still acceptable, These measurements used the hand-written \nmachine specific code, even though the spawn-generated code ran at the same speed. The time gap is attributable \nto inefficiencies introduced by C++ and the style in which EEL is written. Turning on optimization narrows \nthe gap because at -02, g++ produces much better code and inlines member functions, which greatly reduces \nthe overhead of EEL s abstract datatypes. Better compilers should further reduce the C++ penalty. EEL, \nbecause of its object-oriented programming style and its explicit program representations, allocates \nmany more objects (317,494 vs. 84,655) than the old code, which itself increases execution time. In particular, \nEEL s CFGS are larger (26,9 12 vs. 15,441 blocks 1), which disproportion\u00adately increases execution time \nbecause many CFG algo\u00adrithms are non-linear. To date, we have used EEL to build four other tools. Alvin \nLebeck and David Wood built Active Memory [16], which is a platform for efficiently simulating memory \nsys\u00adtems. It inserts a quick test before load and store instruc\u00adtions to check the state of the accessed \nlocation, Different states invoke handlers to perform tasks such as cache simu\u00adlation. Active Memory \nexploits EEL s ability to insert for\u00adeign code efficiently and to add many routines (another program, \nin fact) to an executable. Steven Reinhardt built a direct-execution architectural simulator called Elsie. \nElsie replaces loads, stores, and system calls in a program with simulator calls (using EEL) and then \nloads the edited exe\u00adcutable into the simulator. Sashikanth Chandrasekaran is rewriting the Wisconsin \nWind Tunnel architectural simula\u00adtor [ 19] using EEL. We also used EEL to re-implement Blizzard-S s fine-grain \naccess control [20]. The old version of Blizzard-S used code from qpt to insert access-control tests. \nThe new version greatly improves performance with several optimization that would have been difficult \nto implement in the old system. For example, one optimization exploits EEL s live register analysis to \ninsert a faster test sequence when condition codes are not live. In spite of these optimization, the \nnew version consists of roughly 1,300 lines of code (exclusive of EEL), while the old ver\u00adsion contains \napproximately 2,800 lines (exclusive of qpt\u00adspecific code). 6 Conclusions EEL is a library that aids \nprogrammers in writing porta\u00adble tools to edit executable programs. Tools to modify exe\u00adcutable have \nproven their value in many areas. However, these tools are difficult and expensive to develop and usu\u00adally \nare specific to an architecture and operating-system, EEL addresses these problems by providing a mostly \narchi\u00adtecture-and entirely system-independent set of operations to read, analyze, and modify code in \nan executable file. EEL itself is highly portable because of its extensive program analysis and because \nits machine-specific portion is derived from a concise machine description. EEL does not solve all problems \nin executable editing (self-modifying code and unrestricted indirect jumps and calls are open problems) \nbut I The two programs use slightly different definitions of o basic block (EEL s blocks end at calls). \nHowever, a more important difference is EEL s 12,774 delay slot blocks, 920 CFG entry/exit blocks, and \n1,94 2 call surro\u00adgate blocks, none of which exist in the old code it simplifies the analysis and manipulations \nof most pro\u00adgrams. For an EEL programmer s manual and information on the status of EEL, check: http://m \n.cs. wise. edu/-larue elehkmlml Acknowledgments Norman Ramsey and Mary Fernandez kindly provided copies \nof their machine descriptions and information on their toolkit. Amitabh Srivastava, Tom Ball, Trishul \nChilimbi. Mark Hill, Alvin Lebeck, Anne Rogers, Brad Richards. David Wall, and David Wood provided helpful \ncomments on drafts of this paper. Sashikanth Chandraseka\u00adran, Babak Falsafi. Alvin Lebeck, and Steve \nReinhardt and other members of the Wisconsin Wind Tunnel project bravely used a new tool and contributed \nmany helpful sug\u00adgestions. References [1] Alfred V Aho, Ravi Sethi, and Jeffrey D. Unman. Cmpi[err: Principles. \nTechiqaes, and Took. Addison-Wesley, 1985. [2] Krmty Andrews and Duane Sand. Migrating a CISC Computer \nFatnily onto RISC via Object Code Translation. In Proceedings of the Flftlt In terrrat[ ona[ Conje t \netwe on Arch tecrut a 1 Support fo? .PW,qrmnung Languages md Opermrg S.wem (ASPLOS W, pages 213 222, \nOctober 1992 [3] Mark W. Badey and Jack W Davidson A Formal Model mrd Speclficatlon Language for Procedure \nCalling Conventions [n Co@ren(e Record c,j POPL 95-22rrd ACM SIGPL4N-SIGA CT Symposium on Pr~ncip/e~ \n{/fPr~~,qr[//~~/7li/1,qL.angwges. pages 298 310, January 1995 [4] Thonms Ball and James R. Larus Ophmally \nProfdmg and Tracing Progmms. ACM Trwsactwns ort Progmnmmg b~~m~e.! and .$,vmms, 16(4).13 19-1360, July \n1994. [5] Amta Borg, R. E. Kessler, and David W. Wall. Generation and Analysls of Very Long Address Traces. \nIn Proceeding of fhe 17//1 Annual fnrernatmal Symposium on C[)t?z~?llterArc/zitectlLre, pages 270 28 \n1, May 1990. [6] Brad Calder, Dirk Grunwald, and Benjamin Zom. Quantifying Be\u00adhavioral Differences Between \nC and C++ Programs. Journal of Pro~ramnun# Lwxuaws, 1995 To appear. [7] Steve Chamberlain hbbfd: The \nBinary Fde Descriptor Library, Cygnus Support. bfd version 30 edition, Aprd 1991. [8] J. Bradley Chen \nand Brian N Bershad The Impact of Operating System Structure on Memory System Performance [n Proceed\u00adwgs \nof the Fourteenth A ChJ SVMPO.H UHZoil @eratiw $ .$teln Pr~nc~p/es (SOSP}, pages 120 1 33, 1993. [9] \nJack W. Davidson and Christopher W. Fraser. Code Selection through Object Code Optimization ACM Transac \ntiorrs on Pr[}\u00ad~rmming Languages and Systems, 6(4):505-526, October 1984 [10] Jack W. Davidson and Christopher \nW. Fraser Register Allocation and Exhaustwe Peephole Optlmlzatlon. Sofnwtre Pmcrtce &#38; Er\u00adpenence, \n14(9),857 865, September ]994 [11] Amer Diwan, David Tarditl, and Eliot Moss. Memory Subsystem Performance \nof Programs Using Copying Garbage Collection. in Cmzference Re<:ord of the Twenty-Fret Annual ACM SYnzposwn \nw Prmctples of Pwgra//u~unS Lw%w,qes, pages I 14, January 1994. [[2] Ton] R. Halfhill Emulation RISC \nS Secret Weapon. B,we, pages I 19 130, April 1994 [13] Reed Hastings and Bob Joyce. Purify Fast DetectIon \nof Memory Leaks and Access Errors. In Proceedm$y or the Winrer U sem Conference, pages I 12, January \n1992 [14] James R Lm us. Abstract Execution: A Techmque for Efficiently Tracing Programs. Sojhtwe Practi[ \ne &#38; E.tperlence. 20( 12): [ 241\u00ad1258, December 1990. [15] James R. Larus and Thomas Ball. Rewrit}ng \nExecutable Files to Measure Progratn Behawor. .htrwre Practice &#38; E.tperlence, 24(2): 197 2 18, February \n1994. [16] Alvin R Lebeck and David A Wood. Active Memory A New Ab\u00adstraction for Menlory-Systenl Simulation \n10 Proceedings of rhe 1995 ACM Stgmetr[cs Conference on Memlrewen r und Modelinx @ Cowpwer Sysfems, May \n1995. To appear [17] Prwe Software. United States Patent 5.193,180, March 1993. [18] Norman Ramsey and \nDavid Hanson. A Retargetable Debugger. In Proceedings (~ the SYGPLAN 92 Cmjererrce on Progranznunx Lmzguage \nDest,qt and ~nzplerrtentc~tmn (PLDI), pages 22 31, June 1992. [19] Steven K. Reinhardt, Mark D. Hall, \nJames R. Larus, Alvin R. Leb\u00adeck, James C. Lewis, and Dawd A. Wood The Wisconsin Wind Tunnel: Vmcral \nPrototyping of Parallel Computers. In Proceedin~s (fl the 1993 ACM St#metr/c.~ Cntrference on Measurement \nand Modehng of Cmpurer Sysrem, p%es 48-60, May 1993. p)] Ioanms Schoinas. Babak Falsafi, Alvin R. Lebeck, \nSteven K Re\u00adinhardt, James R. Larus, and David A Wood. Fine-grain Access Control for Distributed Shared \nMemory In Proceedings @ fhe Si.Yt/z/nterrrariow! Co?ljerem e on Archirecrurc[[ .$upporfjor pro\u00adgranmin~ \nLanguages and Operaring System (ASPLOS VI), pages 297 307, October 1994. [21] Richard L. Sites, Anton \nChernoff, Matthew B. Kirk, Marrrrce P. Marks, and Scott G Robinson. Binary Translation. Comrnwzica\u00adtions \noj rhe ACM. 36(2):69 81. February 1993 [22] Michael D. Smith. Tracing with pixie. Memo from Center for \nIn\u00adteg~ated Systems, Stanford Univ, April 1991. [23] Amitabh Srivastava and Alan Eustace. ATOM A System \nfor Building Customized Program Analysls Tools In Prweed/rzg.r of the SIGPLAN 94 Cm~erenc e on Progrwfmlin,y \nLorrgaage De.rt~n cald /))t/~/e//ze/lrttri~JrT(PLDI), pages 196 205.June 1994 Amltabh Sr~vastava and \nDavid Wall Link-Tune Optimlzatlon of Address Calculation on a 64-bit Architecture, In Proceedut#s of \ntk SIGPLAN 94 Conferem:e m Pro:rantmwg L{lltgll(lge De.!lgn and [)fi~~let]le[lr<{rtc~)~(t LDl), pages \n49 60, June 1994. [25] Amltabh Srlvastava and Dawd W. Wall. A practical system for in\u00adtermodrde code \noptimization at hnk-time. Journal @ Progrwn\u00adrrung Languages, 1(1): l l 8, March 1993. [26] Richard M. \nStallman Usins and Porrm$ GNU CC. Free Software Foundation, October 1993. For GCC Version 2.5 [27] Robert \nWahbe, Steven Lucco, Thomas E. Anderson, and Susan L. Graham Efficient Software-Based Fault Isolation. \n[n Proceedwtgs (If the Fourteenth ACM Symposium on Operatwtg Systenz Princ\u00adiples (SOSP), pages 203 2 \n16, December 1993. [28] Mark Welser. Program Slicing. IEEE Transacts on Software En#meenn~, SE-10(4):352-357. \nJuly 1984. [29] Cheryl A. Wiecek. A CaseStudy of VAX-11Instruction SetUsage for Compiler Execution. in \nProceedmHs nj SYYWL~iUnt on Arc/~i\u00adtectaral Support forPro,grarnrning Lmgwtges and Operations Sys\u00adfem. \npages 177 184, April 1982. \n\t\t\t", "proc_id": "207110", "abstract": "<p>EEL (Executable Editing Library) is a library for building tools to analyze and modify an executable (compiled) program. The systems and languages communities have built many tools for error detection, fault isolation, architecture translation, performance measurement, simulation, and optimization using this approach of modifying executables. Currently, however, tools of this sort are difficult and time-consuming to write and are usually closely tied to a particular machine and operating system. EEL supports a machine- and system-independent editing model that enables tool builders to modify an executable without being aware of the details of the underlying architecture or operating system or being concerned with the consequences of deleting instructions or adding foreign code.</p>", "authors": [{"name": "James R. Larus", "author_profile_id": "81100277326", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 West Dayton St., Madison, WI", "person_id": "P132790", "email_address": "", "orcid_id": ""}, {"name": "Eric Schnarr", "author_profile_id": "81100559026", "affiliation": "Computer Sciences Department, University of Wisconsin-Madison, 1210 West Dayton St., Madison, WI", "person_id": "P78433", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/207110.207163", "year": "1995", "article_id": "207163", "conference": "PLDI", "title": "EEL: machine-independent executable editing", "url": "http://dl.acm.org/citation.cfm?id=207163"}