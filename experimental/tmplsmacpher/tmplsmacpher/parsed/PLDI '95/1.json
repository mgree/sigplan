{"article_publication_date": "06-01-1995", "fulltext": "\n Context-Insensitive Alias Analysis Reconsidered Erik Ruf Microsoft Research One Microsoft Way, Redmond, \nWA 98052 USA erikruf@microsoft. com Abstract Recent work on alias analysis in the presence of pointers \nhas concentrated on context-sensitive interprocedural anal\u00ad yses, which treat multiple calls to a single \nprocedure inde\u00ad pendently rather than constructing a single approximation to a procedure s effect on \nall of its callers. While context\u00ad sensitive modeling offers the potential for greater precision by considering \nonly realizable call-return paths, its empirical benefits have yet to be measured. This paper compares \nthe precision of a simple, efficient, tontext-tnsensdtve points-to analysis for the C programming language \nwith that of a maximally context-sensitive version of the same analysis. We demonstrate that, for a number \nof pointer-intensive benchmark programs, cent ext-insensitivity exerts little to no precision penalty. \nWe also describe tech\u00adniques for using the output of context-insensitive analysis to improve the efficiency \nof context-sensitive analysis without affecting precision. Introduction Modern compilers and programming \nenvironments are be\u00adcoming increasingly dependent on semantic information ex\u00adtracted viadataflow analysis. \nInprograms containing point\u00aders, many dataflow analyses depend crucially on the ability to approximate \nthe targets of indirect memory operations, so that all potential uses or modifications of a value can \nbe taken into account. Alias analysisl provides this approxi\u00admation; its precision directly effects the \nquality of virtually all other dataflow analyses. Early pointer alias analyses were completely flow\u00adinsensitive; \nboth Weihl [Wei80] and Coutant [COU86] com\u00adputed alias information on a program-wide basis, building \na single, global mapping between pointers and their potential referents. Others later found that these \nmethods generated overly large, imprecise approximations, handicapping sub\u00adsequent analyses [Ryd89, LR92]. \n1~11 this paper, we use the term alias analysis to denote a dataflow analysis for estimating the effects \nof indirect memory ref\u00aderences through pointers, Weaker forms of alias analysis, such as the treatment \nof call-by-reference parameters and Fortran COMMON blocks, are well understood and will not be discussed \nhere Permission to copy without fee all or part of this material is granted provided that the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that copying is by permission of the Association \nof Computing Machinerv.To cow otherwise, or to republish, requires a fee andjor spe~fic permission. SIGPLAN \n95La Jolla, CA USA (3 1995 ACM 0-89791 -697-2/95/0006 ...$3.50 A number of algorithms compute program-point-specific \nalias infcmnation by treating calls and returns as n-way branches; that is, combining the control flow \ngraphs of all procedures into a single super-graph and using intraproce\u00addural flow analysis techniques \non the enlarged graph, Such context-i nsensitivez techniques can introduce imprecision by exploring call/return \npaths that cannot occur in any ex\u00adecution c,f the program. The system of Chow and Rud\u00admik [CR82] operates \nin this manner; Chase et al [CWZ90] and Deutsch [Deu941 perform more sophisticated modeling intraprocedurally, \nbut are still context-insensitive at the in\u00adterprocedlural level. Recent research in interprocedural \nalias analysis has fo\u00adcused on avoiding the spurious alias relationships generated by context-insensitive \nstrategies. One approach explicitly re-analyzes each procedure under multiple contexts: Emami et al [EGH94] \ncreate a context for each each acyclic path from the root of the call graph to the current invocation, \nwhile Wilson and Lam [WL95] build one context per set of relevant aliases holding on entry to the procedure. \nAn\u00adother approach tags each alias relationship with informa\u00adtion that allows a procedure to propagate \nonly appropri\u00adate relationships to each of its callers: Landi [LR92, Lan92] uses information about the \nalias relationships on entry to the enclosing procedure, while Cooper [CO089] and Choi et al [CBC93 ] \naugment this with an abstraction of the call stack. All context-sensitive amx-oaches have ex~onential \n.. time complexity in the size of the input program unless some effort is made to limit the number of \ncontexts in which a procedure is analyzed. Context-sensitive alias analysis techniques have been quite \nsuccessful, in that they run in reasonable amounts of time, and find relatively few aliases (e.g., the \naverage indi\u00adrect memory operation is found to reference/modify approx\u00adimately 1.2 memory locations [LRZ93, \nEGH94]). However, published work in this area includes comparisons only to Weihl s program-wide analysis, \nso it is unclear how much of this precision derives from the program-point-specific nature of the analysis, \nand how much is truly due to its context\u00adsensitivity. This paper presents the results of an experiment \nto mea\u00adsure the benefits of context-sensitivity. We implemented 2We use the terminology of [EGH94], \nin which the terms contezt\u00adsensitive and contezt-irts ensztive are used to distinguish analyses that \npropagate dataflow facts from procedure returns solely to appropriate call sites from those that propagate \nto all call sites Other terms with similar meanings include the zmprecise/precise distinction of [LR92] \nand the m(~novar~ant/poly varzant distinction made in partial evalu\u00adation and abstract interpretation. \nboth context-insensitive and context-sensitive versions of a single alias analysis and evaluated the \nprecision of the re\u00adsults. We found that In our empirical tests, the context-sensitive analysis does \ncompute more precise alias relationships at some program points. However, when we restrict our at\u00adtention \nto the locations accessed or modified by in\u00addn-ect memory references, no additional precision is measured. \n* Information computed by the context-insensitive anal\u00adysis can be very-useful in improving the efficiency \nof the context-sensitive analysis. Section 2 of this paper introduces a points-to formula\u00adtion of the \npointer alias problem; Section 3 describes a sim\u00adple, efficient, context-insensitive analysis for finding \npoints\u00adto relations. We then (Section 4) extend the analysis to be fully context-sensitive, and compare \nthe results with those from the context-insensitive analysis. Section 5 discusses our results and their \nrelevance to other alias analysis frame\u00ad works. We conclude with a brief summary and discussion of future \nwork. Framework We analyze C programs represented as value dependence graphs, or VDGS [WCES94a) WCES94bl \nFor purposes of this paper, VDG form can be thought of as an extended version of static single assignment \n(SSA) form [CFR+91], in wluch all program dependence (not merely alias-free clef/use dependence) are \nmodeled explicitly. Computation is ex\u00adpressed by nodes that consume input values (outputs of other nodes) \nand produce output values. For example, mem\u00adory accesses (both direct and indirect) are uniformly repre\u00adsented \nas lookup and update operations that consume (and, in the case of update, produce) explicit store values. \nIn gen\u00aderal, inputs and outputs may be of scalar, pointer, function, aggregate, or store type; the standard \ncontrol-flow graph representation of programs can be viewed as a degenerate VDG in which all inputs and \noutputs are of store type. Our analyses apply equally well to control-flow graph represen\u00adtations; they \nmerely run faster on the VDG because it is more sparse [Ruf95]. We use a (points-to model of aliasing; \nthat is, at each program point, our analysis models the contents of storage locations (potnts-to relations) \nrather than modeling equiva\u00adlence classes of location-valued expressions ( alms relations). In this respect, \nour analysis is similar to [RM88, HPR89, CWZ90, EGH94, WL95] and different from [C0089) LR92, CBC93, \nDeu94]. We chose the points-to model because it fits naturally into our intermediate representation, \nand be\u00adcause its storage requirements are likely to be smaller. In our framework, a finite number of \nbase-locatzons name allocation sites: there is one base-location for each variable, and for each static \ninvocation site of memory-allocating li\u00adbrary code such as malloc.3 An access path consists of an op\u00adtional \nbase-location, followed by a possibly empty sequence of access operators, each of which denotes either \na strnc\u00adture/union member access or an array access. 31ncreztsing the number of base-locations per malloc, \ne.g., by nam\u00ading such base-locations with a call string instead of a single allocation site, would be \na trivlzd modification. Access paths starting with base-locations are referred to as locations, and denote \nindirection through the store, while those with empty base-locatlons, called oflsets, denote rel\u00adative \naddressing into aggregate values. Careful interning of access operators ensures that an access path is \naliased only to its prefixes, allowing us to easdy model static aliasing due to C s union types Access \npaths may model single runtime locations (e. g., global variables and local variables of non\u00adrecursive \nprocedures), while others model multiple runtime Iocatlons (array contents, heap-allocated data, and \nlocals of recursive procedures ). Paths corresponding to at most one location at runtime can be strongly \nupdated [CWZ90] during analysis, while others cannot. The output of our points-to analysis is a mapping \nfrom outputs of VDG nodes to sets of poznts-to-patr objects, each of which IS a pam (a, b) of access \npaths denoting in the value produced by this output, indirecting through any location (or offset) denoted \nby a may return any location denoted by path b. The first element of a points-to pair 1s the path; the \nsecond is the referent. Our points-to pairs denote posszble, rather than deflntte relationships; however, \nwe fol\u00adlow [CWZ90] m treating any singleton set of possibly points to pairs as a definitely points to \npair, This allows us to exploit strong updates without additional representational overhead. We also \nrequire the usual caveats of pointer alias analysis, namely, we allow pointer arithmetic only on array \ninterior pointers, and assume that such arithmetic does not cause the pointer to denote storage outside \nthe array. We do not perform array dependence analysis, and thus maintain one approximation to all values \nstored in the array, Neither signal handlers, longjmp, nor casts between pointer and non\u00ad pointer types \nare modeled. 3 Context-Insensitive Analysis 3.1 Algorithm Our context-insensitive analysis, described \nin Figure 1, is es\u00adsentially the simple algorithm of [CWZ90, Sections 3 and 4.2], and has the same effect \nas the intraprocedural portion of [EGH94]. We maintain a set of points-to pairs on every node output \nin the program,5 and incrementally grow these sets using a worklist strategy, Whenever a points-to pair \nis added to a set, all consumers of that output are notified; they in turn make appropriate modifications \nto the points\u00adto sets on their outputs. Calls and returns are handled like jumps, in that all information \nat a call s actuals is propa\u00adgated to all called procedures, and all information at a pro\u00ad 4A local variable \nof a recursive procedure may require special han\u00ad dling if its address is taken, because pointers to \nmultiple instances of such variables may be simultaneously hve. In the case where the variable is of \npointer type, this behavior could lead to an incorrect points-to solution if the variable s location \nis strongly updated by the analysm. We have experimented w,th two solutions to this prob\u00ad lem Our first \nscheme is essentially Cooper s [CO089] model. each such variable v=ri.able IS assigned two base locations, \none denoting the most recent instance of the variable, the other denoting all other instances on the \nstack The former can be strongly updated, while the latter cannot. Our second scheme approwmates this \nby assigning only a weakly -updateable base-location to each such variable. The choice of solutlan M \nirrelevant for the benchmarks in this paper, as they do not contain recurmve procedures that pass addresses \nof 10CZ1 pointer-valued variables downward 5We could reduce our storage costs (at log n time cost) via \nthe sparse stOrage strategy described in [CWZ90], but we have yet to see a need for this m practice 14 \nanalyze program worldtst := O for each base-location b c program f low-out output(b) (,, b) while worklzst \nnot empty do take 6 = (Anput, pa%r) from worklzst flow-in input-node ( input) d flow-out output paw if \npaar @ P(output) then P(output) := T(output) U {pair-} for each c E consumers (output) add (c, pazr) \nto wor!dwt flow-in (lookup, 10C, store, oualue) d case 6 of (/Oci(p~, r~)) for each (PS, rs) C P(store) \n] r~ dom p, flow-out ovalue (p, r~, r.) (stOre, (p~, r9)) for each (pi, rl) E P(1oc) I r-z dom p. flow-out \noualue (p. r~, r. ) flow-in (update, 10C) store, value, ostore) 6 case c! of (loc, (p~, r~)) for each \n(pv, rv) G ?J(value) flow-out ostore (r~ + r-v, rv) for each (p., r.) E P(store) I T(V strong+m p., flow-out \nostore (p., r. ) (stOre, (p., r.)) for each (pl, rl) E 7J(1oc) I ~(~1 strong-dom p.) flow-out ostore \n(p., r.) (value, (pv, rv)) for each (pt, rz) E ~(icx) flow-out ostore (rl + r., r.) flow-in n = (call, \nfen, actualo, . . . . resrdto, . .) d case 6 of (~cn, (pf, rf)) (omitted) (actuat,, (pa, ra)) for each \nc c callees n let o = corresponding-formal c actual, in flow-out 0 (pa, ra) flow-m n = (return, value) \nf5 case 6 of (uaiue, (pv, ~u)) for each c C callers n let o = corresponding-result c due in f low-out \n0 (p., ?-.) flow-in (if, pred, then, else, ovalue) 6 (omitted) flow-in (primop, name, actualo, . . . \n. re.wdto, .) J (omitted) Definitions af globals/prunitives: + Append fuuctlon on access paths. Prefix \nsubtraction function on access paths, callees Function mapping a call node to the cor\u00adresponding function \nnodes, callers Function mapping a return node to the cor\u00adresponding call nodes. consumers Function mapping \na node output to a set of node Inputs. corresponding-formal Function mapping a function node and aanactualmput \ntotbe corresponding formal output corresponding-result Function mapping a call node and a return input \nto the corresponding r,esult output. dom Binary relation on access paths used to model static may-aliasmg \nin aggregates. A dom B if a read (Write) of A may observe (modify) a value written to B In our path representation, \nthis is true if A IS a prefix of B. input-node Function mapping a node input to its node, P Function \nmapping a node output to a set of points\u00adto pairs. strong-dom Binary relation on access paths used to \nmodel static must-abasing m aggregates, A strong-dom B If a read (write) of A must observe (modify) a \nvalue written to B. In our path representatlonj this is true if A is both strongly updateable (e.g. its \nbase-locatton de\u00adnotes a single storage locatlon and none of its access operators are array dereferences) \nand a prefix of B worklwt Queue of (znput, points-to-paar) pares. Explanations of flow-in methods: lookup \nA new location is dereferenced in the store. A new store pair is used to dereference all of the locations. \nupdate A new location generates a store pair for each value, and also propagates all store pairs not \nstrongly updated by this location. A new store pair M propagated if at least one location doesn t strongly \nupdate it A new value gen\u00aderates a store pair for each location pair (The propagation behavior for non-strongly-updated \nstore pairs in the actual implementation is more efiiclent than in this pseudocode) call A new function \nupdates the call graph and per\u00adfcrms appropriate repropagation (code omitted here). A new actual value \n]s propagated to the corresponding formal in each callee. returm A new return value is propagated to \nthe cor\u00adresponding result output at each call site if Valwes from both branches propagate to the out\u00adput; \npredicate is ignored. primop Behavior varies by operator. Figure 1: Context-insensitive analysis name \nsource VDG alias-related hnes nodes outputs allrOOts* 231 554 278 anagram F 648 1 018 560 assembler \n2764 4741 2 990 baclcpropt 286 721 421 bc~ 6771 9 024 5 435 compiler 2282 3 852 2 057 compress+ 1502 \n2 080 1 124 lex31.5* 1039 1 453 716 loader* 1241 2 033 1 202 part t 684 1 6?7 1 105 simulator* 4009 7 \n052 4047 spant 1297 1 364 944 yacr2t 3208 5 963 3 047 F]eure 2. Benchmark ~ronams and their sizes in \nsource and VDG . form, An ahas-related output is a node output that can carry pointer or function values; \ne.g., one whose type IS pointer, func\u00adtion, aggregate contamlng pointer or function, or store Sources \n(*) Wilham A. Landl, (i ) Todd K, Austin, (j) Free Software Foun\u00addation, (+) SPEC92 suite. ceclure s \nreturns is propagated to all of its callers Termina\u00adtion is assured because the number of outputs and \npoints-to pairs are finite, yielding 0(n3 ) time and space bounds in the worst case (0(n2 ) in the average \ncase, in which each pointer has only a small constant number of ~eferents). This algo\u00adrithm has the desirable \nproperty that its convergence time is independent of the scheduling strategy used for the worklist. Because \npoints-to analysis 1s not a distributive problem, the effects of points-to pairs arriving on multiple \ninputs of a node cannot always be computed independently For exam\u00adple, a new points-to pair arriving \non the location input of a lookup node causes the node to iterate over the points-to pairs on its store \ninput and emit the referents of all pairs whose path might be aliased to the referent of the newly arrived \npair. Update nodes are even more interesting due to our desire to perform strong updates whenever possible, \nSince strong updates block points-to pairs on the store input from propagating through the node, we must \n(1) delay pro\u00adcessing of any points-to pairs on the store input until at least one pair has arrived on \nthe location input, and (2) reprocess all strongly-updated ( i e., blocked) pairs on the store input \nonce a second pair arrives on the location input. This gives the same effect as the dual-worklist strategy \nof [CWZ90]. Similar reasoning applies to indirect calls (and the returns of indirectly called procedures), \nwhich must propagate old reformation to new destinations every time a new points-to pair arrives on the \nfunction input of a call. 3.2 Results ety these sis We tested of small programs publications our contprograms \nfrom [LR92, ext-insensitive described those analyzed LRZ93, algorithm in Figure 2. in other EGH94] and \nalias in on a vari-We chose analy\u00ad[ABS94], which instrumented pointer-intensive programs. Under our \nScheme-based implementation, analysis times for the bench\u00admark programs range from 1 to 35 seconds. Figure \n3 reports the number of points-to pairs discov\u00adered, These aggregate figures are relatively uninformative \nby themselves; we can learn more by considering an ap\u00adplication, such as clef/use or mod/ref analysis, \nSuch ap\u00adplications are concerned only with the memory locations referenced by each memory read or writej \ne.g., the point\u00aders arriving at the location inputs of lookup and update nodes, Figure 4 reports these \nstatistics. We see that, on av\u00aderage, most indirect memory operations reference very few locations, Our \nstatistics for memory writes are higher than those in [LRZ93] for two reasons, First, we do not construct \nsynthetic locations to represent lexically non-visible vari\u00adables, meaning that we lose some opportunities \nfor strong updates (cf. Section 5.1), Second, the VDG intermediate representation often coalesces series \nof structure or array operations into a single memory read followed by a series of aggregate update operations \nand a single memory write; thus, many array/structure operations are not counted as memory operations \nm our statistics ( e g., m our representa\u00adtion, assembler contains 115 indirect write operations, while \nin that of [LRZ93], it contains 290). Since the majority of array/structure operations reference only \none location, this increases the our average number of locations refer\u00adenced/modified statistic. Three \nprograms, backprop, compder, and span, have no indirect loads/stores that reference more than one location, \nindicating that (under the assumption that all memory op\u00aderations reference only valid pointers, and \nare executed at least once at runtime) performing a context-sensitive anal\u00adysls would not add any precision \nto a clef/use or mod/ref application in these cases, We also note that the maxi\u00admum locations modified \nvalues for allroots, assembler, com\u00adpder, lez3f 5, loader, and szmulator are identical to those produced \nby context-sensitive means in [LRZ93], allowing us to conclude that the worst-case behavior at indirect \nmem\u00adory references in these programs was not caused by context\u00adinsensitivity. What cannot be concluded \nfrom this data is how much improvement we would see under context-sensitive methods; that is the subject \nof the next section. 4 Context-Sensitive Analysis 4.1 Modifying the Context-Insensitive Algorithm Our \ngoal in constructing a context-sensitive analysis is not to produce a reasonable compromise between efficiency \nand precision, bnt rather to establish an empirical upper bound on the precision of alias analysis m \nour points-to framework. Thus we are willing to pay an exponential per\u00adformance penalty and will not, \nas in [LR92, CBC93] limit our representation to avoid such a penalty, We choose to use assumption-set-based \ncontexts (rather than call-stack-based contexts) because doing so allows us to prune contexts based on \nthe output of the context-insensitive analysls. We make the analysis of Section 3,1 context-sensitive \nby alte~ing it to propagate qualtjied poznts-to pazrs rather than ordinary points-to pairs, A qualified \npair consists of an ordinary points-to pair ( e.g., a path and its referent), along with a set of assnrnptlons, \neach of which consists of a points-to pair and a formal parameter output on which that pair must hold. \nThe interpretation of the qualified pair ((a, c), {(s, (a, ~)), (s, (b, c))}) on some output ,s a points \nto c on this output if, on entry to this procedure, a points to b in formal s and b points to c in formal \ns , 6 These assump\u00adtion sets are similar to those of [CO089, LR92, CBC93], ex\u00adcept that (1) our assumptions \nconcern points-to, rather than 6&#38;SUmPt10~S need not be restmcted to store OutPUts; we might just \nas easily assume that &#38; pointer.valued formzd parameter has a particular value, e.g., ((c, a), {(f, \na)}) means tlus output has pointer value a if formal f has value a, 16 name - function aggregate store \ntot al allroots 123 0 4 254 381 anagram 206 3 13 1394 1616 assembler 1509 0 1798 165622 168929 backprop \n142 0 4 497 643 bc 3017 10 1193 333389 337609 compiler 484 0 189 20566 21239 compress 339 2 114 2459 \n2914 1ex315 264 0 33 10269 10566 loader 491 0 77 .5753 6321 part .521 0 311 6597 7429 simulator 1921 \n0 634 176828 179383 span 322 0 484 3244 4050 vacr2 1174 n 141 38949 40264 TOTAL I 10513 I Ii I 4995 \n765821 781344 Figure 3: Total points-to relationships, as computed by context-insensitive analysls, Each \ncolumn indicates the number of ~oints-to pairs that appear on node outputs of the indicated type, name \nindirect referent~s type total accessing n locations max avg 1 2 3 >4 allroots read 34 16 18 0 u ~ 1.53 \nallroots writ e 3 3 0 0 0 1 1.00 anagram read 56 53 3 0 0 2 1.05 anagram write 25 25 0 0 0 1 1.00 assembler \nread 176 135 17 0 24 60 2.34 assembler write 115 80 13 0 22 9 1.93 backprop read 32 31 0 0 0 1 097 backprop \nwrite 21 21 0 0 0 1 1.00 IJC* read 553 462 50 21 19 33 2.16 bc writ e 250 216 18 8 8 26 150 compiler \nread 83 83 0 0 0 1 100 compder write 50 50 0 0 0 1 100 compress read 77 76 1 0 o 2 101 compress write \n84 84 0 0 0 1 100 lex315 read 16 7 9 0 o 2 1.56 lex315 writ e 9 4 5 0 0 ~ 156 loader read 80 77 2 0 \n 1 7 1.10 loader write 43 36 1 1 5 9 191 part read 114 56 .58 0 o 2 1.51 part write 49 35 14 0 0 2 1,28 \nsimulator read 339 323 0 8 8 22 1,22 simulator write 210 183 5 12 10 13 145 span read 101 101 0 0 o \n1 1,00 span write 45 45 0 0 0 1 1.00 yacr2 read 268 261 7 0 o 2 103 yacr2 write 109 98 10 1 0 3 1.11 \nTOTAL read 1929 1681 165 29 52 60 1.55 TOTAL write 1013 880 66 22 45 26 1.39 Figure 4: Points-to statistics \nfor indirect memory reads and writes Backprop and bc each contain one indirect read that, if executed, \nwould reference only the null pointer value 17 flow-in (lookup, 10C, store, ovaiue) 6 case 6 of (loc, \n((p~, r ~))cq)) for each ((p,, r , ),a~) < p(store) I r~ dom p. flow-out oualue ((p. r-~)r-.),a~ U a.) \n(stOr-e) ((p~, r-~)) a~)) for each ((pi, rl), at) C P(1oc) I rl dom p, flow-out ovalue ((p, r-~, r.), \nal U a.) flow-in (update, 10C, store, value, ostore) 6 case 6 of (~oc, ((Pt> r-1), ~1)) for each ((pu, \nrv), G) c P(value) flow-out ostore ((r-~ +Tv, r-u), a~ U au) for each ((ps, r.), as) E P(store) I 1(TL \nstrong-dom p.) flow-out ostore ((p., 7-s), at U as) (store, ((p,, r,), a.)) for each ((pi, rz), a[) 6 \nP(Joc) I -I(T j strong-clomps) flow-out ostore ((p. , r-.), at U a.) (ucslue, ((po, rv), av)) for each \n((pi, rl), al) E P(Joc) flow-out ostor-e ((r-~ + r-u, r-v), al U au) flow-in n = (call, fen, actualo, \n., resdto, ,) c! case 6 of (fc~)((Pf!~f)>~f)) (omitted) (actuQlt, ((Pa, ra))aa)) for each c C callees \nn let o = corresponding-formal c actual, m flow-out o ((pa, ra), {(% (lhz)~a))}) for each r E returns \nc for each p E P(T) propagate-return n r p flow-m n = (return, value) 6 case J of (wcdue, ((pv, rv))a,u)) \nfor each c E callers n propagate-return c n ((pv, r.),%) propagate-return caller return ((p., rv ), \nau ) let o = corresponding-result caller return S = {s1 s= {aal ((pf)~f)) am) EF (actual)} where actual \n= corresponding-actual caller f where (f, (Pf, ~f)) ~ a.} for each aE~ S flow-out 0 ((pu, rti), a) Figure \n5: Transfer functions of Figure 1, modified for cent ext-sensitive analysis, This pseudocode does not \nInclude the optimization described in Section 4,2, The code in propagate-return operates as follows. \nfor each element of the assumption set au of the qualzjied-pazr-being returned, we com\u00adpute a set s of \nassumption sets which, if holding at the call site, would be sufficient to satisfy that element of ao. \nThe Cartesian product of these sets gives us all possible caller assumption sets sufficleut to satisfy \nthe assumptions on the callee s return value, For each element of this product, we propagate an appropriately \nqualified version of the return value to the caller alias, relations, and (2) we do not limit the size \nof assump\u00adtion sets. Our rules for propagation of assumptions (shown in Fig\u00adure 5) are similar to those \nin [Lan92]. Assumptions are in\u00adtroduced and removed at procedure calls and returns. When a new qualified-pair \np arrives at a call, it is propagated to the corresponding formal f of each potential callee as be\u00adfore; \nhowever, the propagated pair is given the assumption set { (~, p) }, indicating that p will hold within \nthe called procedure only if it held on entry. When a qualified-pair reaches a return node, its assumptions \nare checked against the pairs holding at each call site, and it is propagated only to those call sites \nsatisfying all of its assumptions; the prop\u00adagated value is given new assumptions corresponding to the \nassumption sets of the actual parameter qualified-pairs used to satisfy the assumptions. Additional assumptions \nare introduced at lookup and update nodes because a points-to pair on output may hold only if multiple \npoints-to pairs hold on input For exam\u00ad ple, if ((~, a), {(.fl, (e, u))}) holds On the location input \nof a lookup, and ((a, b), {(fz, (c, b))}) holds on the store in\u00adput, then ((c, b), {(fl, (c, a)), (~2, \n(c, b))}) holds on the out\u00adput. In other words, the memory read returns b only when the pointer-valued \nformal parameter fl is a, and when the store-valued formal parameter fz maps path c to value b, Similar \nchaining occurs when processing new qualified-pairs arriving on the inputs of update nodes. In the worst \ncase, this behavior can yield assumption sets whose size is expo\u00adnential in the number of indirect storage \noperations in the program. Strong updates also add assumptions, An update node propagates a points-to \npair on its store input only when its location input contains at least one path that will not def\u00adinitely \noverwrite the pair s path. In the context-sensitive analysis, such a pair must be propagated under a \ndiffer\u00adent assumption for each non-overwriting location input; in essence, we must enumerate all of the \nways in which the input pair could fail to be overwritten. 7 A chain of such update nodes quickly yields \na large combinatorial explosion. Finally, we must also introduce assumptions whenever we make use of \nparticular function values in an indirect call, We have not yet implemented this feature in our analysis; \nhence, our function pointer results are context-insensitive. This is not an issue for our benchmark programs, \nwhich make only light use of indirect function calls (we have hand\u00adverified that this context-insensitivity \ndoes not affect any of our empirical results). After the context-sensitive analysis has completed, we \ncompute the set of ordinary points-to pairs on each node output by stripping the assumption sets from \nthe quali\u00adfied points-to pairs on that output and removmg duplicates. Some context-sensitive analyses \n[PLR92, LRZ93] prefer to use the qualified information directly; this would be easy to accommodate. \n4.2 Implementation The analysis described in the previous subsection 1s too in\u00adefficient to run on any \nbut the smallest of examples. We use several techniques to improve its efficiency. One important optimization \n1s a subsumption rule on assumption sets, Any qualified points-to pair (p, 1?) reach\u00ad 7A language of \nassumptions having a negat~on operator would per\u00admit this to be expressed more concisely; however. this \nwould make composition and compamson of assumptions far more difficult, ing an output where (p, A) already \nholds may be discarded whenever A C B. In other words, if p already holds under A, there is no need to \nstore (or process) the fact that p holds under some stronger assumption B, Another class of optimizations \nuses the results of our efficient context-insensitive analysis to prune the number and size of assumption \nsets that are generated: Assumptions about location values need not be intro\u00adduced at indirect memory \noperations that the context\u00adinsensitive analysis has proven to reference/modify only a single location. \nThat is, if we adopt the stan\u00addard assumptions that all intraprocedural paths are executed, and that \nall memory reads and writes deref\u00aderence only non-null pointers, then it must be the case that such a \nnode will reference the same location un\u00adder all calling contexts, removing the need for tracking assumptions \nabout the locations As can be seen from Figure 4, this optimization applies to 87~0 of the indirect \nreads and writes in our test programs. Once we consider that only indirect reads and writ es of pointer \nand function values affect the analysis results, only 970 of the indirect reads and 7% of the indirect \nwrites need to introduce assumptions.  We can also limit the growth of assumption sets due to strong \nupdates. The context-insensitive analysis pro\u00advides an upper bound on the set of locations modified by \neach update node; any location not in the context\u00adiusensitive estimate for a node cannot possibly be \nmod\u00adified by that node, Thus, all qualified points-to pairs on the store input that can be shown to be \nunmodified may be passed on without the need to add a new as\u00adsumption about the update s location argument. \nSince the vast majority of update nodes modify only one or two locations (average is 1.39 locations modifiecl), \nalmost all points-to pairs can be propagated though update nodes without the need for additional assump\u00adtions. \n We were unable to measure the speedup due to these op\u00ad timization because the unoptimized algorithm \ncould only be applied to very small examples. These optimizations do not alter the exponential character \nof the analysis, but they have served to make its execution feasible. With the opti\u00ad mization in place, \nthe context-sensitive algorithm executes only slightly more (1 OYO) transfer functions (applications \nof flow-in in the pseudocode) than the context-insensitive algorithm, but as many as 100 times more meet \noper\u00ad ations (applications of flow-out). The net result is that the context-sensitive algorithm IS 2-3 \norders of magnitude slower than the context-insensitive algorithm on our larger test programs (assembler \nand bc each take several hours to analyzer This performance is acceptable for our purpose (establishing \nan upper bound on precision), but it does limit the algorithm s practicality. Optimization techniques \nsimilar to our use of context\u00ad insensitive information might also be useful in systems such as [LR92] \nthat maintain bounded-size assumption sets. Such sys tems presently must arbitrarily choose which assump\u00ad \ntions to discard when the bound is reached; in many cases, 8~f we ~\\id*llt ,nake this assumption, we \nmight l~e able 0 rule Ut some zntraprocedural pnths under some contexts, and reduce the num\u00ad ber of locatlons \nreferenced to zero. In such cases, it would he inlpre\u00ad cise to make use of the single-location result \nfrom context-insensitive analysis, as that result nnght be overly conservative. information from context-insensitive \nanalysis could be used to judiciously discard those assumptions that cannot possi\u00adbly affect precision. \n 4.3 Results Figure 6 summarizes the number of points-to pairs gen\u00aderated by our context-sensitzve analysis \nfor the benchmark programs of Figure 2. In most cases, the context-sensitive analysis generates fewer \n(2Y0, on average) points-to pairs than the context-insensitive analysis. This information, however, gives \nno indication of how much ccmservative behavior in subsequent analyses would be induced by the spurious \npoints-to information. When we consider only the points-to pairs reaching the location in\u00adputs of indirect \nmemory references, we find that the spurz\u00adous tnforrnatzon does not affect the solution at alfi the results \nfor indirect memory references are identical to the context\u00adiusensitive results of Figure 4. Thus, for \nuse/clef or mod/ref applications, our fully context-sensitive analysis provides no precision benefit \non our test programs. We initially found this result rather surprising, but, after further reflection, \nit appears reasonable given our framework and test programs, In the next section, we describe several \nfactors contributing to this result, and explain how differ\u00adent problem formulations, implementations, \nor benchmark suites mi~y affect the precision benefits of context-sensitivity. 5 Discussion Our results \nraise two questions: 1. Why does context-insensitive analysis generate so few spurious points-to pairs \n? 2. Why don t the spurious points-to pairs affect the paths reaching location inputs of indirect memory \nopera\u00adtions?  Since our result is empirical, we cannot provide complete explanations that are valid \nfor all test programs; indeed, it is easy to construct programs where context-sensitivity provides an \narbitrarily large benefit. The remainder of this section gives our working hypotheses. 5.1 Lack of spurious \npoints-to pairs The lack of spurious points-to pairs can be attributed both the the c[eslgn of our analysis \nframework and to character\u00ad istics of the benchmark programs used to test it. 5.1.1 Design Choices Some \nof the apparent precision of the context-insensitive analysis is due to choices we made in our analysis \nframework and its irnplernentation: Treatment of invisible locations. Many alias analy\u00adsis algorithms \n[LR921 EGH94, CBC93] explicitly con\u00adstruct svnthetic locations (called invisible variables or representative \naliases ) to represent storage ad\u00addresses not lexically visible to a procedure (e g , a caller s local \nvariable, whose address is passed to the procedure as a parameter or in a global variable), and perform \nmapping operations on procedure call and re\u00adturn, Our algoritlums do not map invisible locations 19 name \npointer function aggregate store total tot al percent (insens,tlve) spurious allroots 123 o 4 254 381 \n381 00 anagram 206 3 13 1204 1426 1616 11.8 assembler 1509 0 1798 162972 166279 168929 1.6 backprop 142 \n0 4 497 643 643 0.0 bc 3017 10 1193 325749 329969 337609 23 compiler 484 0 189 20484 21157 21239 0.4 \ncompress 333 2 114 2392 2841 2914 2.5 lex315 264 0 33 10269 10566 10566 00 loader 491 0 77 5445 6013 \n6321 49 part 521 0 311 6540 7372 7429 0.8 simulator 1921 0 634 175268 177823 179383 09 span 320 0 473 \n3092 3885 4050 4.1 yacr2 1174 141 36204 37519 40264 68 n TOTAL 10505 15 4984 750370 765874 781344 2.0 \nII II Fiewre 6: Points-to relationships, as computed by context-sensitive analysis Each Of the first \nfive columns indicates the number Of POints\u00adto~>ams that appear on node o-utputs of {he indicated type \nThe total insensitive columns indicates the total number of points-to pares obtained by the context-insensitive \nmethod; the final column shows the context-sensitive method to such synthetic representatives, but merely \nuse them directly (with the exception of locations representing locals whose addresses pass through a \nrecursive call). Mapping can improve precision by allowing more strong updates to be performed; bodies \nof called pro\u00adcedures will sometimes see a single synthetic location where our analysis will see a set \nof invisible loca\u00adtions, However, mapping may worsen the precision of context-insensitive analysis. Consider \ntwo locations that participate in a points-to relationship at a call site, but which are invisible to \nthe called procedure. Under a context-insensitive analysis, the correspond\u00ad ing synthetic locations must \nalso have a points-to lationship. Depending on the mapping scheme this may force all invocations of the \nprocedure to be analyzed in a context where these synthetic cations have a points-to relationship, even \nthough relationship may not apply at some sites. Treating invisible variables explicitly increases costs \n(due re\u00ad used, body lo\u00ad this the to less memorization), but allows LW to avoid this pollution in the \ncontext-insensitive case. * Handling of heap allocation sites. Our analysis con\u00adstructs only a single \nrepresentative base-location for each invocation site of heap memory allocators (mal\u00ad 10C, reallot, etc). \nThus, data abstraction will respective of whether sensitive analysis are yses [Har89, CWZ90, multiple \nrepresentatives larger pool of locations, ous points-to relations all clients of a heap-allocated manipulate \nthe same paths, ir\u00adcontext-insensitive or context\u00adused. More precise heap anal- CBC93, Deu92, Deu94] \nallow per allocation site, yielding a and thus a larger set of spuri\u00adin the context-insensitive case.~ \nA similar argument applies to the handling of arrays (treating various subscript ranges independently \nwill increase the number of distinct access paths). $JTI,ere ,s ~r, ~nterestillg paradox here: more Precise \nanalYses fter~ produce what appear to he inferior statistics (in terms of the number of paths accessed/modified \nby an indirect memory operation) because they begin with a larger pool of potential locations. Research \nresults would be easier to compare If statistics were reported m terms of the fract~on of potential locat,ons \nreferenced/moddied, instead of the absolute number the percentage of context-insensitive pairs found \nto be spurious by Program representation, Before our points-to analy\u00ad ses run, our compiler has already \nperformed signifi\u00ad cant amounts of value numbering, loop invariant code motion, and dead code removal, \nalong with an SSA\u00ad like transformation that removes non-addressed vari\u00ad ables from the store [Ruf95, \nSection 3]. It may be the case that, without these optimizations, more spurious (though irrelevant) points-to \npairs would be generated. Problem formulation. Because an ahas-pair formu\u00adlation of the problem manipulates \na set ~f location\u00advalued expressions that is potentially far larger than our set of access paths (since \nlocation-valued expres\u00adsions may include multiple levels of indirection), the problem of spurious pairs \nis likely to be larger in such a framework. 5.1.2 Benchmark Characteristics The structure of our test \nprograms also contributes to the lack of spurions points-to pairs, In these small programs, ab\u00ad stract \ndata types types typically have only one client. Thus, even under context-insensitive analysis, there \nis little danger of cross-pollution this is difficult more important likely to change Additionally, graphs; \nwhile cedures have callers tend to ing the number between an abstraction s clients. While to quantify, \nwe believe it to be one of the factors leading to our result, and the most when larger programs are analyzed. \nthese programs have relatively sparse call procedures average 4.2 callers, 54% of pro\u00adonly one caller. \n10 Procedures with multiple be near the leaves of the call graph, decreas\u00adof contexts they induce in \ntheir callees. Finally, these programs exhibit only shallow nesting of pointer datatypes; the vast majority \nof pointers are smgle\u00ad level (t, e., they reference scalar many procedures that perform not modify points-to \nrelationships ple, utility code for performing character-valued pointers, but valued (rather than pointer-valued) \n10 T1, e~e ~tatl~tic~ do nOt include affect the points-to solution; these tion on stores, avoiding any \ndanger datatypes). This means that indirect reads and writes do in their callers, For exam\u00adstring operations \nreads many only writes to character\u00ad memory locations. Shal\u00ad library procedures knOwn ot 0 are modeled \nas the identity func\u00ad of context pollution 20 All points-to pairs (context-insensitive) H~ea~ I 0.0% \nI <0.1% I 5.6% I 16.8% H Figure 7: Context-insensitive and spurious points-to pairs, broken paths without \nbase-locations; i. e., pointer, function, and aggregate locals and parameters, global includes string \nliteral storage low nesting also means that a single spurious pair is less likely to generate a cascade \nof other spurious relationships downstream when that pair is dereferenced, since the deref\u00aderence is \nunlikely to yield a pointer value.  5.2 Lack of consequences due to spurious pairs The lack of adverse \nconsequences of spurious points-to pairs can be attributed to several factors. The first is the prob\u00adlem \ndefinition itself. If the goal of points-to analysis is to model all relationships at all program points \n(perhaps for use in a debugger or programming environment), then spu\u00adrious points-to pairs are clearly \na problem. If, however, we restrict the problem, then only certain subclasses of thespu\u00adrious pairs (in \nthis case, those on pointer-valued outputs consumed by indirect memory operations) are relevant. In every \ntest case other than compress and span, all of the spu\u00adrious pairs are on store-valued outputs and are \nthus uninter\u00adesting (the spurious pointer pairs in compress and span are produced by library calls whose \nreturn values are not used; such spurious pairs on dead code can also be considered harmless). For an \nuninteresting spurious points-to pair to induce no int cresting spurious pairs downstream, it must be \nthe case that either (1) no downstream code references this pair s path, or (2) references to this pair \ns path also read another, non-spurious, pair with the same referent. Case (1) is typi\u00adcally a consequence \nof coding style, in that most callers to a procedure performing a side effect will detect only some of \nthe potential effects. For example, a common paradigm has callers pass addresses of pointer-valued local \nstorage to a procedure which then modifies that storage. A particu\u00adlar caller will typically not detect \nthe (spurious) side effects performed on other callers storage because it doesn t look there. If the \ncallee writes the same pointer value (perhaps the address of a buffer in global or heap space) to all \ncallers storage, the caller won t detect the spurious side-effects to its storage either, (Due to the \nlargely single-level nature of pointers in our benchmarks, the callee usually writes a scalar, in which \nthe callee s write won t induce any points\u00adto pairs in the first place). Case (2) can occur in a number \nof ways, including the merging of points-to sets at intraprocedural control flow joins, and the coarse \nhandling of arrays and heap alloca\u00adtion. Sometimes this case appears through pure serendipity; e.g., \nthe part benchmark independently construct two linked lists that are both manipulated via the same set \nof routines, resulting in cross-pollution from context insensitivity. How\u00ad ever, earl y in its execution, \nthe program exchanges elements between the lists, forcing each list s locations to model all of the values \nheld by the other list s locations. Thus, any spurious pair pointing into the incorrect list will reference \nthe correct values anyway. Spurious points-to pairs only referent path function local global heap offset \n0.0% o o% <0.170 0.1% local 0,0% 0.09?0 34.1% 8.1 ZO global o o% 0.0% 3,1~o 29 9~o heap 0070 0.1% 5.1% \n19 5~o down by path and referent types. Offset paths include all access edges in the VDG The local designation \nincludes all procedure Circumstantial evidence supporting both possibilities can be found in Figure 7, \nwhich shows the distribution of path and referent types for all context-insensitive points-to pairs and \nfor slpurious points-to pairs only. A far larger proportion of the spurious pairs model local variables, \nwhich are more likely to be dead at any given point (e. g., incorrectly return\u00ading a pair whose path \nis a local variable of procedure A to procedure B won t cause problems because B will not deref\u00aderence \nA s local). Spurious pairs are also more likely to point to heap storage, which (due to the relative \nscarcity of heap locations in our model, and the inability to perform strong updates on heap locations) \nis more likely to correctly con\u00adtain a larger variety of locations than global storage, which is strongly \nupdateable. With the exception of the mapping of invisible locations to synthetics, the arguments of \nSections 5,1 and 5.2 apply equally well to other context-sensitive pointer alias analy\u00adses [LR92, CBC93, \nEGH94]. Thus, we believe that they, too, will realize only minor precision benefits from context\u00adsensitivity \non our benchmark suite. 6 Conclusion and Future Work We have performed what we believe to be the first \nem\u00adpirical comparison between program-point-specific context\u00adinsensitive and context-sensitive alias \nanalysis techniques. Our conclusion, that adding context-sensitivity to a points\u00adto analysis provides \nlittle or no precision benefit on our test cases, should not be taken to mean that we do not find context-:sensitive \nanalyses to be a useful line of research. On the contrary, we believe that context-sensitivity will be \nes\u00adsential cmce we begin analyzing larger programs under a richer model of the heap, However, we do believe \nthat present benchmarks and analysis results form inadequate proof of the utility of context-sensitive \ntechniques in prac\u00adtice. In addition, we have found that context-insensitive tech\u00adniques can be implemented \nquite efficiently, and can produce information that is surprisingly precise, as well as useful in improving \nthe efficiency of more sophisticated techniques. We plan to continue working in this vein, using simple, \neffi\u00adcient techniques to limit the search space of more expensive, more precise analyses. Acknowledgements \nRoger Crew, Michael Ernst, Ellen Spertus, Bjarne Steens\u00adgaard, and Daniel Weise co-developed the VDG-based \npro\u00adgramming environment in which this work is situated. Bjarne Steensgaard and Daniel Weise commented \non drafts of this paper. We would like to thank William Landi and Todd Austin for sharing their benchmark \nsuites with us. References [ABS94] [CBC93] [cFR+91] [Ccm89] [C!OU86] [CR82] [CWZ90] [Deu92] [Deu94] [EGH94] \n[Har89] [HPR89] [Lan92] [LR92] T. M Austin, S. E Breach, and G. S. Sohi. Ef\u00adficient detect]on of all \npointer and array access er\u00adrors. In Proceedings of the SIGPLAN 94 Conference on Programming Language \nDestgn and Implementa\u00adhon, pages 290 301, ACM Press, 1994. J -D Choi, M. Burke, and P. Carini. Efficient \nflow\u00adsensltive mterprocedural computation of pomter\u00adinduced aliases and side effects. In Proceedings \nof the Twentteth Annual ACM SIGPLAN-SIGA CT Sym\u00adpos~rsm on Pr-mctples of Programmmg Languages, pages \n232 245 ACM Press, Jan 1993. R. Cytron, J Ferrante, B K Rosen, M. N Wegman, and F. K. Zadeck Efficiently \ncomputing static single assignment form and the control dependence graph. ACM Transactions on Programmmg \nLanguages and Systems, 13(4) 451-490, Ott 1991 B. G, Cooper. Ambitious data flow analysls of proce\u00addural \nprograms. Master s thesm, Umversity of Min\u00adnesota, May 1989. D S. Coutant Retargetable high-level alias \nanalysis. In Proceed~ngs of the Thmteenth Annual ACM Sym\u00adpostum on Principles of Programmmg Languages, \npages 110 118. ACM Press, 1986. A. L. Chow and A Rudmlk The design of a data flow analyzer. In Proceedings \nof the SIGPLAN 82 Symposzum cm Compder Construct~on, pages 106\u00ad 119. ACM Press, 1982. D, R Chase, M. \nWegmau, and F. K. Zadeck. Anal\u00adysis of pointers and structures In Pr-oceedtngs of the SIGPLAN 90 Conference \non Programmmg Lan\u00adguage Deszgn and Implementation, pages 296 310, Jnne 20-22, 1990 A. Deutsch. A storeless \nmodel of aliasing and its abstractions using fimte representations of right\u00adregular equivalence relations. \nIn lnternatwnal Con\u00adference on Computer Languages, pages 2-13 IEEE, Apr. 1992. A. Deutsch. Interprocedural \nmay-alias analysis for pointers, Beyond k-limiting. In Proceedings of the SIGPLAN 94 Conference on Programmmg \nLan\u00adguage Des~gn and Implementation, pages 230 239. ACh I Press, 1994. M Emami, R Ghiya, and L J Hendren \nContext\u00adsensitive iuterprocedural analysis in the presence of functlan poln cers. In Proceedings of the \nSIGPLA N 94 Conference on Programmmg Language Des~gn and Implementation, pages 242 256. ACM Press, June \n1994 W. L Harrison 111. The iuterprocedural analysis and automatic parallelization of Scheme programs \nLzsp and Sgmbolic Computation, 2(3/4).179 396, 1989. S. Horwitz, P. Pfelffer, and T Reps. Dependence \nanalysis for pointer variables. In Proceedings o.f the SIGPLAN 89 Symposusm on Compiler Construc\u00adtion, \npages 28 40, June 1989 Published as SIG-PLAN Notices Vol 24, Num. 7. W. A Landi Interprocedural Alzasmg \nm the Pres\u00adence of Potnters PhD thesis, Rutgers University, Jan 1992 W. Laudl and B. G. Ryder A safe \napproximate al\u00adgorithm for mterprocedural pointer aliaslng In Pro\u00adceedings of the SIGPLAN 92 Conference \non Pro\u00adgramming Language Des%gn and Implementation, pages 235 248 ACM Press, June 1992 [LRZ93] [PLR92] \n[RM88] [Ruf95] [Ryd89] [WCES94a] [WCES94b] [Wei80] [WL95] W Landi, B G Ryder, and S Zhang Iwterproce\u00addural \nmodification side effect analysis with pointer aliasing. In Proceedings of the SIGPLAN 93 Con\u00adference \non Programming Language Design and Im\u00adplementahon, pages 56 67 ACM Press, June 1993 H. D. Paude, W Landl, \nand B, G, Ryder, Interpro\u00adcedural reaching definitions m the presence of single level pointers, Techmcal \nReport lcsr-tr-193, Labora\u00adtory for Computer Science Research, Rutgers Uni\u00adversity, Ott 1992, C. Rugglerl \nand T P. Murtagh. Llfetlme analysls of dynanmcally allocated objects, In Proceedings of the Ftfteenth \nAnnual ACM Sympostum on Pranctples of Progr-ammzng Languages, pages 285 293, Jan, 1988. E. Ruf Optimizing \nsparse representatlous for dataflow analysis. In ACM SIGPLAN Workshop on Intermediate Repr-esentatzom \n(IR 95), pages 50-61, Jan 1995 Proceedings available as Microsoft Re\u00adsearch technical report MSR-TR-95-01 \nB. G. Ryder Ismm Incremental software mainte\u00adnance manager. In Proceedings of the IEEE Com\u00adputer Society \nConference on Software Maintenance, pages 142 164, 1989, D. Weise, R. F Crew, M Ernst, and B, Steensgaard. \nValue dependence graphs: Representat,lon without taxation In Proceedings 21st ACM SIGPLAN-SIGA CT Symposzum \non Pr-zncaples of Programming Languages, pages 297-310, Jan 1994 D. Weise, R F, Crew, M. Ernst, and B. \nSteens\u00adgaard Value dependence graphs: Representation without taxation, Techmcal Report MS R-TR-94-03, \nMicrosoft Research, Redmond, WA, Apr, 13, 1994 W. E. Welhl. Interprocedural data flow analysm m the presence \nof pointers, procedure variables, and label variables In Proceedings of the Seventh An\u00adnual ACM Sympos~um \non Pr%nctples of Program\u00adming Languages, pages 83 94, Jan 1980. R P Wilson and M S Lam. Efficient context\u00adseusitive \npointer analysis for C programs In Pr-oceed\u00adtngs of the SIGPLA N 95 Conference on Program\u00admlnq Language \nDe.ngn and Implementafzon ACM Press, June 1995 (this volume) 22  \n\t\t\t", "proc_id": "207110", "abstract": "<p>Recent work on alias analysis in the presence of pointers has concentrated on <italic>context-sensitive</italic> interprocedural analyses, which treat multiple calls to a single procedure independently rather than constructing a single approximation to a procedure's effect on all of its callers. While context-sensitive modeling offers the potential for greater precision by considering only realizable call-return paths, its empirical benefits have yet to be measured.</p><p>This paper compares the precision of a simple, efficient, <italic>context-insensitive</italic> points-to analysis for the C programming language with that of a maximally context-sensitive version of the same analysis. We demonstrate that, for a number of pointer-intensive benchmark programs, context-insensitivity exerts little to no precision penalty. We also describe techniques for using the output of context-insensitive analysis to improve the efficiency of context-sensitive analysis without affecting precision.</p>", "authors": [{"name": "Erik Ruf", "author_profile_id": "81100400397", "affiliation": "Microsoft Research, One Microsoft Way, Redmond, WA", "person_id": "P78858", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/207110.207112", "year": "1995", "article_id": "207112", "conference": "PLDI", "title": "Context-insensitive alias analysis reconsidered", "url": "http://dl.acm.org/citation.cfm?id=207112"}